[
  {
    "key": "c:S2095",
    "name": "Resources should be closed",
    "defaultSeverity": "BLOCKER",
    "type": "BUG",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003cp\u003eA function call to \u003ccode\u003efopen\u003c/code\u003e or \u003ccode\u003eopen\u003c/code\u003e must be matched with a call to \u003ccode\u003efclose\u003c/code\u003e or \u003ccode\u003eclose\u003c/code\u003e,\nrespectively.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe standard C library provides \u003ccode\u003efopen\u003c/code\u003e and the system call \u003ccode\u003eopen\u003c/code\u003e to open and possibly create files. Each call to one of\nthese functions must be matched with a respective call to \u003ccode\u003efclose\u003c/code\u003e or \u003ccode\u003eclose\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eFailing to close files that have been opened may lead to using up all of the OS’s file handles.\u003c/p\u003e\n\u003ch2\u003eWhat is the potential impact?\u003c/h2\u003e\n\u003cp\u003eIf a program does not properly close or release file handles after using them, it will leak resources. In that case, the program will continue to\nhold onto file handles even when they are no longer needed, eventually exhausting the available file handles.\u003c/p\u003e\n\u003cp\u003eIf a program has run out of file handles and tries to open yet another file, the file opening operation will fail. This can result in errors or\nunexpected behavior in the program.\u003c/p\u003e\n\u003cp\u003eThe program may not be able to read or write to files anymore, which can cause data loss, corruption, or incomplete operations. In some cases, when\na program runs out of file handles, it may crash or hang indefinitely. This can happen if the program does not handle the error condition properly or\nif it enters an infinite loop trying to open files, for instance. In the worst case, a resource leak can lock up everything that runs on the\nmachine.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eMake sure that each call to \u003ccode\u003efopen\u003c/code\u003e and \u003ccode\u003eopen\u003c/code\u003e has a matching call to \u003ccode\u003efclose\u003c/code\u003e and \u003ccode\u003eclose\u003c/code\u003e,\nrespectively.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n\nint process_file(int print) {\n  FILE *f \u003d fopen(\"example.txt\", \"r\");\n  if (!f) {\n    perror(\"fopen() failed\");\n    return 1;\n  }\n\n  if (print) {\n    char buffer[256];\n    while (fgets(buffer, 256, f)) {\n      printf(\"%s\", buffer);\n    }\n  }\n\n  return 0; // Noncompliant: file `f` has not been closed\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n\nint process_file(int print) {\n  FILE *f \u003d fopen(\"example.txt\", \"r\");\n  if (!f) {\n    perror(\"fopen() failed\");\n    return 1;\n  }\n\n  if (print) {\n    char buffer[256];\n    while (fgets(buffer, 256, f)) {\n      printf(\"%s\", buffer);\n    }\n  }\n\n  fclose(f);\n  return 0; // Compliant: file `f` has been closed\n}\n\u003c/pre\u003e\n\u003ch3\u003eGoing the extra mile\u003c/h3\u003e\n\u003cp\u003eUsing C++\u0027s \u003cem\u003eRAII\u003c/em\u003e idiom can mitigate unmatched calls to \u003ccode\u003efopen\u003c/code\u003e and \u003ccode\u003eopen\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eFollowing this idiom, one would create a class that manages the underlying file by opening it when the object is constructed and closing it when\nthe object is destroyed, effectively using a constructor-destructor pair as a \"do-undo\"-mechanism.\u003c/p\u003e\n\u003cp\u003eAn exemplary class that manages a pointer to a file is shown in what follows.\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;cstdio\u0026gt;\n#include \u0026lt;fstream\u0026gt;\n#include \u0026lt;string\u0026gt;\n#include \u0026lt;utility\u0026gt;\n\n// Although `std::fstream` should be preferred, if available, a file stream\n// managed by this `File` class cannot suffer from \"double-close\" issues.\nclass File {\n  FILE *f;\n\npublic:\n  // Opens file stream on construction.\n  File(std::string const \u0026amp;path, std::string const \u0026amp;modes)\n      : f(fopen(path.c_str(), modes.c_str())) {\n    if (!f) {\n      throw std::ios_base::failure(\"fopen() failed\");\n    }\n  }\n  // Will close the file stream upon destruction.\n  ~File() {\n    // Here we are fine with `std::terminate` being called here in case `close`\n    // throws and exception.\n    close();\n  }\n  // Allow only one owner of a file, disallow copy operations.\n  File(const File \u0026amp;other) \u003d delete;\n  File \u0026amp;operator\u003d(const File \u0026amp;other) \u003d delete;\n  // Moving a file to a different scope shall be allowed.\n  File(File \u0026amp;\u0026amp;other) : f(std::exchange(other.f, nullptr)) {}\n  File \u0026amp;operator\u003d(File \u0026amp;\u0026amp;other) {\n    if (this !\u003d \u0026amp;other) {\n      // In case of non-self-assignment, close the currently managed file and\n      // \"steal\" the other\u0027s file.\n      close();\n      f \u003d std::exchange(other.f, nullptr);\n    }\n    return *this;\n  }\n  // Allow file to be closed explicitly.\n  void close() {\n    if (f !\u003d nullptr \u0026amp;\u0026amp; fclose(std::exchange(f, nullptr)) \u003d\u003d EOF) {\n      throw std::ios_base::failure(\"fclose() failed\");\n    }\n  }\n  // Allow access to underlying file via `f`.\n  FILE *handle() { return f; }\n  // Release `f`, i.e., stop managing it.\n  FILE *release() { return std::exchange(f, nullptr); }\n};\n\nvoid file_user() {\n  File fh{\"example.txt\", \"r\"};\n  FILE *f \u003d fh.handle();\n  // Use `f` for the desired file operation(s).\n  //\n  // The file stream managed by `fh` will be automatically closed when `fh` goes\n  // out of scope at the end of this function.\n}\n\u003c/pre\u003e\n\u003cp\u003eWith the design shown above, calls to \u003ccode\u003efopen\u003c/code\u003e will be automatically matched with a corresponding call to \u003ccode\u003efclose\u003c/code\u003e by default.\nThe associated file will be automatically closed when the \u003ccode\u003eFile\u003c/code\u003e typed file handle object goes out of scope and its destructor is called.\nHowever, it is still possible to leak a resource, if \u003ccode\u003eFile\u003c/code\u003e\u0027s function member \u003ccode\u003eFile::release\u003c/code\u003e is used inappropriately. If this\nis a concern, this function member should be removed.\u003c/p\u003e\n\u003cp\u003eIf falling back to low-level file operations is not necessary, one should prefer \u003ccode\u003estd::fstream\u003c/code\u003e.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/QtUxBQ\"\u003eFIO42-C. Close files when they are no longer needed\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/459\"\u003e459 Incomplete Cleanup\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/772\"\u003e772 Missing Release of Resource after Effective Lifetime\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:c:S3588} ensures that \u003ccode\u003eFILE*\u003c/code\u003e typed variables are not accessed after the associated file has been closed \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eA function call to \u003ccode\u003efopen\u003c/code\u003e or \u003ccode\u003eopen\u003c/code\u003e must be matched with a call to \u003ccode\u003efclose\u003c/code\u003e or \u003ccode\u003eclose\u003c/code\u003e,\nrespectively.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe standard C library provides \u003ccode\u003efopen\u003c/code\u003e and the system call \u003ccode\u003eopen\u003c/code\u003e to open and possibly create files. Each call to one of\nthese functions must be matched with a respective call to \u003ccode\u003efclose\u003c/code\u003e or \u003ccode\u003eclose\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eFailing to close files that have been opened may lead to using up all of the OS’s file handles.\u003c/p\u003e\n\u003ch2\u003eWhat is the potential impact?\u003c/h2\u003e\n\u003cp\u003eIf a program does not properly close or release file handles after using them, it will leak resources. In that case, the program will continue to\nhold onto file handles even when they are no longer needed, eventually exhausting the available file handles.\u003c/p\u003e\n\u003cp\u003eIf a program has run out of file handles and tries to open yet another file, the file opening operation will fail. This can result in errors or\nunexpected behavior in the program.\u003c/p\u003e\n\u003cp\u003eThe program may not be able to read or write to files anymore, which can cause data loss, corruption, or incomplete operations. In some cases, when\na program runs out of file handles, it may crash or hang indefinitely. This can happen if the program does not handle the error condition properly or\nif it enters an infinite loop trying to open files, for instance. In the worst case, a resource leak can lock up everything that runs on the\nmachine.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eMake sure that each call to \u003ccode\u003efopen\u003c/code\u003e and \u003ccode\u003eopen\u003c/code\u003e has a matching call to \u003ccode\u003efclose\u003c/code\u003e and \u003ccode\u003eclose\u003c/code\u003e,\nrespectively.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n\nint process_file(int print) {\n  FILE *f \u003d fopen(\"example.txt\", \"r\");\n  if (!f) {\n    perror(\"fopen() failed\");\n    return 1;\n  }\n\n  if (print) {\n    char buffer[256];\n    while (fgets(buffer, 256, f)) {\n      printf(\"%s\", buffer);\n    }\n  }\n\n  return 0; // Noncompliant: file `f` has not been closed\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n\nint process_file(int print) {\n  FILE *f \u003d fopen(\"example.txt\", \"r\");\n  if (!f) {\n    perror(\"fopen() failed\");\n    return 1;\n  }\n\n  if (print) {\n    char buffer[256];\n    while (fgets(buffer, 256, f)) {\n      printf(\"%s\", buffer);\n    }\n  }\n\n  fclose(f);\n  return 0; // Compliant: file `f` has been closed\n}\n\u003c/pre\u003e\n\u003ch3\u003eGoing the extra mile\u003c/h3\u003e\n\u003cp\u003eUsing C++\u0027s \u003cem\u003eRAII\u003c/em\u003e idiom can mitigate unmatched calls to \u003ccode\u003efopen\u003c/code\u003e and \u003ccode\u003eopen\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eFollowing this idiom, one would create a class that manages the underlying file by opening it when the object is constructed and closing it when\nthe object is destroyed, effectively using a constructor-destructor pair as a \"do-undo\"-mechanism.\u003c/p\u003e\n\u003cp\u003eAn exemplary class that manages a pointer to a file is shown in what follows.\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;cstdio\u0026gt;\n#include \u0026lt;fstream\u0026gt;\n#include \u0026lt;string\u0026gt;\n#include \u0026lt;utility\u0026gt;\n\n// Although `std::fstream` should be preferred, if available, a file stream\n// managed by this `File` class cannot suffer from \"double-close\" issues.\nclass File {\n  FILE *f;\n\npublic:\n  // Opens file stream on construction.\n  File(std::string const \u0026amp;path, std::string const \u0026amp;modes)\n      : f(fopen(path.c_str(), modes.c_str())) {\n    if (!f) {\n      throw std::ios_base::failure(\"fopen() failed\");\n    }\n  }\n  // Will close the file stream upon destruction.\n  ~File() {\n    // Here we are fine with `std::terminate` being called here in case `close`\n    // throws and exception.\n    close();\n  }\n  // Allow only one owner of a file, disallow copy operations.\n  File(const File \u0026amp;other) \u003d delete;\n  File \u0026amp;operator\u003d(const File \u0026amp;other) \u003d delete;\n  // Moving a file to a different scope shall be allowed.\n  File(File \u0026amp;\u0026amp;other) : f(std::exchange(other.f, nullptr)) {}\n  File \u0026amp;operator\u003d(File \u0026amp;\u0026amp;other) {\n    if (this !\u003d \u0026amp;other) {\n      // In case of non-self-assignment, close the currently managed file and\n      // \"steal\" the other\u0027s file.\n      close();\n      f \u003d std::exchange(other.f, nullptr);\n    }\n    return *this;\n  }\n  // Allow file to be closed explicitly.\n  void close() {\n    if (f !\u003d nullptr \u0026amp;\u0026amp; fclose(std::exchange(f, nullptr)) \u003d\u003d EOF) {\n      throw std::ios_base::failure(\"fclose() failed\");\n    }\n  }\n  // Allow access to underlying file via `f`.\n  FILE *handle() { return f; }\n  // Release `f`, i.e., stop managing it.\n  FILE *release() { return std::exchange(f, nullptr); }\n};\n\nvoid file_user() {\n  File fh{\"example.txt\", \"r\"};\n  FILE *f \u003d fh.handle();\n  // Use `f` for the desired file operation(s).\n  //\n  // The file stream managed by `fh` will be automatically closed when `fh` goes\n  // out of scope at the end of this function.\n}\n\u003c/pre\u003e\n\u003cp\u003eWith the design shown above, calls to \u003ccode\u003efopen\u003c/code\u003e will be automatically matched with a corresponding call to \u003ccode\u003efclose\u003c/code\u003e by default.\nThe associated file will be automatically closed when the \u003ccode\u003eFile\u003c/code\u003e typed file handle object goes out of scope and its destructor is called.\nHowever, it is still possible to leak a resource, if \u003ccode\u003eFile\u003c/code\u003e\u0027s function member \u003ccode\u003eFile::release\u003c/code\u003e is used inappropriately. If this\nis a concern, this function member should be removed.\u003c/p\u003e\n\u003cp\u003eIf falling back to low-level file operations is not necessary, one should prefer \u003ccode\u003estd::fstream\u003c/code\u003e.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/QtUxBQ\"\u003eFIO42-C. Close files when they are no longer needed\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/459\"\u003e459 Incomplete Cleanup\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/772\"\u003e772 Missing Release of Resource after Effective Lifetime\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:c:S3588} ensures that \u003ccode\u003eFILE*\u003c/code\u003e typed variables are not accessed after the associated file has been closed \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "cert",
      "cwe",
      "denial-of-service",
      "leak",
      "symbolic-execution"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S5000",
    "name": "\"memcmp\" should only be called with pointers to trivially copyable types with no padding",
    "defaultSeverity": "BLOCKER",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003cp\u003eThe function \u003ccode\u003ememcmp\u003c/code\u003e only returns meaningful results for objects of trivially copyable types without padding. This includes scalar\ntypes, arrays, and trivially copyable classes.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003ememcmp\u003c/code\u003e compares the raw memory representation of two objects (what the standard calls their \u003cem\u003eobject representation\u003c/em\u003e). When\nobjects are not trivially copyable or contain padding, they could have different raw memory representations even though they store identical values.\nSo the result of \u003ccode\u003ememcmp\u003c/code\u003e is not meaningful.\u003c/p\u003e\n\u003cp\u003ePadding refers to the insertion of additional bits into a structure or class to ensure proper alignment of its members in memory.\u003c/p\u003e\n\u003cp\u003eTrivially copyable types include:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e scalar types \u003c/li\u003e\n  \u003cli\u003e trivially copyable classes \u003c/li\u003e\n  \u003cli\u003e arrays of these types \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eA class is trivially copyable when:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e all its non-static data members and base classes are trivially copyable types, \u003c/li\u003e\n  \u003cli\u003e it has no virtual functions or base classes, \u003c/li\u003e\n  \u003cli\u003e its destructor is trival, \u003c/li\u003e\n  \u003cli\u003e and one or more of the following special member functions is trivial, and the rest are deleted: copy constructor, move constructor, copy\n  assignment operator, and move assignment operator. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cem\u003eNote: a default implementation is always considered trivial, both when it is explicit (with \u003ccode\u003e\u003d default\u003c/code\u003e) or implicit (if the special\nmember function is omitted).\u003c/em\u003e\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eThe comparison operator \u003ccode\u003eoperator\u003d\u003d\u003c/code\u003e should be defined and used instead of \u003ccode\u003ememcmp\u003c/code\u003e when the types are not trivially copyable\nor contain padding. This allows comparing member by member to check object equality.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nstruct Shape { // Trivially copyable, but will contain padding after the bool on most architectures\n  bool visible;\n  int x;\n  int y;\n};\n\nbool isSame(Shape *s1, Shape *s2)\n{\n    return memcmp(s1, s2, sizeof(Shape)) \u003d\u003d 0; // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nstruct Shape { // Trivially copyable, but will contain padding after the bool on most architectures\n  bool visible;\n  int x;\n  int y;\n};\n\nbool isSame(Shape *s1, Shape *s2)\n{\n  return s1-\u0026gt;visible \u003d\u003d s2-\u0026gt;visible \u0026amp;\u0026amp; s1-\u0026gt;x \u003d\u003d s2-\u0026gt;x \u0026amp;\u0026amp; s1-\u0026gt;y \u003d\u003d s2-\u0026gt;y;\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\nclass Resource { // Not trivially copyable\npublic:\n  Ptr* ptr;\n  ~Resource();\n};\n\nbool isSame(Resource *r1, Resource *r2)\n{\n    return memcmp(r1, r2, sizeof(Resource)) \u003d\u003d 0; // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\nclass Resource { // Not trivially copyable\npublic:\n  Ptr* ptr;\n  ~Resource();\n};\n\nbool operator\u003d\u003d(Resource const \u0026amp;r1, Resource const \u0026amp;r2) {\n  return r1.ptr \u003d\u003d r2.ptr;\n}\n\nbool isSame(Resource *r1, Resource *r2)\n{\n    return (*r1) \u003d\u003d (*r2);\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/classes#Trivially_copyable_class\"\u003eDefinition of a trivially copyable\n  class\u003c/a\u003e. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e S4999 - \"memcpy\", \"memmove\", and \"memset\" should only be called with pointers to trivially copyable types \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eThe function \u003ccode\u003ememcmp\u003c/code\u003e only returns meaningful results for objects of trivially copyable types without padding. This includes scalar\ntypes, arrays, and trivially copyable classes.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003ccode\u003ememcmp\u003c/code\u003e compares the raw memory representation of two objects (what the standard calls their \u003cem\u003eobject representation\u003c/em\u003e). When\nobjects are not trivially copyable or contain padding, they could have different raw memory representations even though they store identical values.\nSo the result of \u003ccode\u003ememcmp\u003c/code\u003e is not meaningful.\u003c/p\u003e\n\u003cp\u003ePadding refers to the insertion of additional bits into a structure or class to ensure proper alignment of its members in memory.\u003c/p\u003e\n\u003cp\u003eTrivially copyable types include:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e scalar types \u003c/li\u003e\n  \u003cli\u003e trivially copyable classes \u003c/li\u003e\n  \u003cli\u003e arrays of these types \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eA class is trivially copyable when:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e all its non-static data members and base classes are trivially copyable types, \u003c/li\u003e\n  \u003cli\u003e it has no virtual functions or base classes, \u003c/li\u003e\n  \u003cli\u003e its destructor is trival, \u003c/li\u003e\n  \u003cli\u003e and one or more of the following special member functions is trivial, and the rest are deleted: copy constructor, move constructor, copy\n  assignment operator, and move assignment operator. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cem\u003eNote: a default implementation is always considered trivial, both when it is explicit (with \u003ccode\u003e\u003d default\u003c/code\u003e) or implicit (if the special\nmember function is omitted).\u003c/em\u003e\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eThe comparison operator \u003ccode\u003eoperator\u003d\u003d\u003c/code\u003e should be defined and used instead of \u003ccode\u003ememcmp\u003c/code\u003e when the types are not trivially copyable\nor contain padding. This allows comparing member by member to check object equality.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nstruct Shape { // Trivially copyable, but will contain padding after the bool on most architectures\n  bool visible;\n  int x;\n  int y;\n};\n\nbool isSame(Shape *s1, Shape *s2)\n{\n    return memcmp(s1, s2, sizeof(Shape)) \u003d\u003d 0; // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nstruct Shape { // Trivially copyable, but will contain padding after the bool on most architectures\n  bool visible;\n  int x;\n  int y;\n};\n\nbool isSame(Shape *s1, Shape *s2)\n{\n  return s1-\u0026gt;visible \u003d\u003d s2-\u0026gt;visible \u0026amp;\u0026amp; s1-\u0026gt;x \u003d\u003d s2-\u0026gt;x \u0026amp;\u0026amp; s1-\u0026gt;y \u003d\u003d s2-\u0026gt;y;\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\nclass Resource { // Not trivially copyable\npublic:\n  Ptr* ptr;\n  ~Resource();\n};\n\nbool isSame(Resource *r1, Resource *r2)\n{\n    return memcmp(r1, r2, sizeof(Resource)) \u003d\u003d 0; // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\nclass Resource { // Not trivially copyable\npublic:\n  Ptr* ptr;\n  ~Resource();\n};\n\nbool operator\u003d\u003d(Resource const \u0026amp;r1, Resource const \u0026amp;r2) {\n  return r1.ptr \u003d\u003d r2.ptr;\n}\n\nbool isSame(Resource *r1, Resource *r2)\n{\n    return (*r1) \u003d\u003d (*r2);\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/classes#Trivially_copyable_class\"\u003eDefinition of a trivially copyable\n  class\u003c/a\u003e. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e S4999 - \"memcpy\", \"memmove\", and \"memset\" should only be called with pointers to trivially copyable types \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "unpredictable"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S5485",
    "name": "Only valid arguments should be passed to stream functions",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003cp\u003ePassing invalid arguments to standard C library functions for handling I/O streams results in undefined behavior.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe standard C library includes a number of functions for handling I/O streams. These functions put certain constraints on the values of their\nparameters. The constraints include the following:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The value for the \u003ccode\u003eFILE*\u003c/code\u003e-typed parameter may \u003cem\u003enot\u003c/em\u003e be \u003ccode\u003eNULL\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e The third argument of \u003ccode\u003efseek\u003c/code\u003e must be either of \u003ccode\u003eSEEK_SET\u003c/code\u003e, \u003ccode\u003eSEEK_END\u003c/code\u003e, or \u003ccode\u003eSEEK_CUR\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eFailing to pass correctly constrained parameters renders them invalid and will result in undefined behavior.\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;stdio.h\u0026gt;\n\nsize_t get_file_size() {\n  FILE *f \u003d fopen(\"example_file.txt\", \"r\");\n  // `f` may be NULL if `fopen` fails.\n  fseek(f, 0L, SEEK_END); // Leads to undefined behavior, if `f` is NULL.\n  size_t size \u003d ftell(f); // Leads to undefined behavior, if `f` is NULL.\n  fclose(f);\n  return size;\n}\n\u003c/pre\u003e\n\u003ch2\u003eWhat is the potential impact?\u003c/h2\u003e\n\u003cp\u003eUsing the standard C library’s functions for handling I/O streams with invalid arguments leads to \u003cstrong\u003eundefined behavior\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eWhen a program comprises undefined behavior, the compiler no longer needs to adhere to the language standard, and the program has no meaning\nassigned to it.\u003c/p\u003e\n\u003cp\u003eDue to the resulting NULL pointer dereferences in the C library functions, the application might just crash, but in the worst case, the application\nmay appear to execute correctly, while losing data or producing incorrect results.\u003c/p\u003e\n\u003cp\u003eBesides affecting the application’s availability, NULL pointer dereferences may lead to code execution, in rare circumstances. If NULL is\nequivalent to the 0x0 memory address that can be accessed by privileged code, writing and reading memory is possible, which compromises the integrity\nand confidentiality of the application.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eEnsure that the \u003ccode\u003eFILE*\u003c/code\u003e-typed pointer parameters passed to the standard C library’s I/O stream handling functions are\nnon-\u003ccode\u003eNULL\u003c/code\u003e and also any other parameters such as the third argument of \u003ccode\u003efseek\u003c/code\u003e carry appropriate values, namely any of\n\u003ccode\u003eSEEK_SET\u003c/code\u003e, \u003ccode\u003eSEEK_END\u003c/code\u003e, or \u003ccode\u003eSEEK_CUR\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n\nint process_file(const char *fname) {\n  FILE *f \u003d fopen(fname, \"r\");\n  fseek(f, 0L, SEEK_END);\n  size_t size \u003d ftell(f);\n  rewind(f);\n  char *buf \u003d (char *)malloc(size);\n  // Read file into buffer ...\n  fclose(f);\n  // Process buffer ...\n  free(buf);\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n\nint process_file(const char *fname) {\n  FILE *f \u003d fopen(fname, \"r\");\n  if (!f) {\n    printf(\"Could not open file!\\n\");\n    return 1;\n  }\n  fseek(f, 0L, SEEK_END);\n  size_t size \u003d ftell(f);\n  rewind(f);\n  char *buf \u003d (char *)malloc(size);\n  // Read file into buffer ...\n  fclose(f);\n  // Process buffer ...\n  free(buf);\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n\nvoid process_tmp_file() {\n  FILE *f \u003d tmpfile();\n  size_t pos_indicator \u003d ftell(f); // Noncompliant: `f` could be NULL.\n  fseek(f, 0L, 3); // Noncompliant: 3rd argument should either be SEEK_SET, SEEK_CUR or SEEK_END.\n  // Further file processing ...\n  fclose(f);\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n\nint process_tmp_file() {\n  FILE *f \u003d tmpfile();\n  if (!f) {\n    printf(\"Could not create temporary file!\\n\");\n    return 1;\n  }\n  size_t pos_indicator \u003d ftell(f); // Compliant: `f` cannot be NULL here.\n  fseek(f, 0L, SEEK_END); // Compliant: 3rd argument is now a valid value.\n  // Further file processing ...\n  fclose(f);\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/476\"\u003e476 NULL Pointer Dereference\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:c:S3807} ensures that appropriate arguments are passed to C standard library functions \u003c/li\u003e\n  \u003cli\u003e {rule:c:S5488} ensures that appropriate arguments are passed to UNIX/POSIX functions \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003ePassing invalid arguments to standard C library functions for handling I/O streams results in undefined behavior.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe standard C library includes a number of functions for handling I/O streams. These functions put certain constraints on the values of their\nparameters. The constraints include the following:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The value for the \u003ccode\u003eFILE*\u003c/code\u003e-typed parameter may \u003cem\u003enot\u003c/em\u003e be \u003ccode\u003eNULL\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e The third argument of \u003ccode\u003efseek\u003c/code\u003e must be either of \u003ccode\u003eSEEK_SET\u003c/code\u003e, \u003ccode\u003eSEEK_END\u003c/code\u003e, or \u003ccode\u003eSEEK_CUR\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eFailing to pass correctly constrained parameters renders them invalid and will result in undefined behavior.\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;stdio.h\u0026gt;\n\nsize_t get_file_size() {\n  FILE *f \u003d fopen(\"example_file.txt\", \"r\");\n  // `f` may be NULL if `fopen` fails.\n  fseek(f, 0L, SEEK_END); // Leads to undefined behavior, if `f` is NULL.\n  size_t size \u003d ftell(f); // Leads to undefined behavior, if `f` is NULL.\n  fclose(f);\n  return size;\n}\n\u003c/pre\u003e\n\u003ch2\u003eWhat is the potential impact?\u003c/h2\u003e\n\u003cp\u003eUsing the standard C library’s functions for handling I/O streams with invalid arguments leads to \u003cstrong\u003eundefined behavior\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eWhen a program comprises undefined behavior, the compiler no longer needs to adhere to the language standard, and the program has no meaning\nassigned to it.\u003c/p\u003e\n\u003cp\u003eDue to the resulting NULL pointer dereferences in the C library functions, the application might just crash, but in the worst case, the application\nmay appear to execute correctly, while losing data or producing incorrect results.\u003c/p\u003e\n\u003cp\u003eBesides affecting the application’s availability, NULL pointer dereferences may lead to code execution, in rare circumstances. If NULL is\nequivalent to the 0x0 memory address that can be accessed by privileged code, writing and reading memory is possible, which compromises the integrity\nand confidentiality of the application.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eEnsure that the \u003ccode\u003eFILE*\u003c/code\u003e-typed pointer parameters passed to the standard C library’s I/O stream handling functions are\nnon-\u003ccode\u003eNULL\u003c/code\u003e and also any other parameters such as the third argument of \u003ccode\u003efseek\u003c/code\u003e carry appropriate values, namely any of\n\u003ccode\u003eSEEK_SET\u003c/code\u003e, \u003ccode\u003eSEEK_END\u003c/code\u003e, or \u003ccode\u003eSEEK_CUR\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n\nint process_file(const char *fname) {\n  FILE *f \u003d fopen(fname, \"r\");\n  fseek(f, 0L, SEEK_END);\n  size_t size \u003d ftell(f);\n  rewind(f);\n  char *buf \u003d (char *)malloc(size);\n  // Read file into buffer ...\n  fclose(f);\n  // Process buffer ...\n  free(buf);\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n\nint process_file(const char *fname) {\n  FILE *f \u003d fopen(fname, \"r\");\n  if (!f) {\n    printf(\"Could not open file!\\n\");\n    return 1;\n  }\n  fseek(f, 0L, SEEK_END);\n  size_t size \u003d ftell(f);\n  rewind(f);\n  char *buf \u003d (char *)malloc(size);\n  // Read file into buffer ...\n  fclose(f);\n  // Process buffer ...\n  free(buf);\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n\nvoid process_tmp_file() {\n  FILE *f \u003d tmpfile();\n  size_t pos_indicator \u003d ftell(f); // Noncompliant: `f` could be NULL.\n  fseek(f, 0L, 3); // Noncompliant: 3rd argument should either be SEEK_SET, SEEK_CUR or SEEK_END.\n  // Further file processing ...\n  fclose(f);\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n\nint process_tmp_file() {\n  FILE *f \u003d tmpfile();\n  if (!f) {\n    printf(\"Could not create temporary file!\\n\");\n    return 1;\n  }\n  size_t pos_indicator \u003d ftell(f); // Compliant: `f` cannot be NULL here.\n  fseek(f, 0L, SEEK_END); // Compliant: 3rd argument is now a valid value.\n  // Further file processing ...\n  fclose(f);\n  return 0;\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/476\"\u003e476 NULL Pointer Dereference\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:c:S3807} ensures that appropriate arguments are passed to C standard library functions \u003c/li\u003e\n  \u003cli\u003e {rule:c:S5488} ensures that appropriate arguments are passed to UNIX/POSIX functions \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "suspicious",
      "symbolic-execution"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S897",
    "name": "Unused type declarations should be removed",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eIf a type is declared but not used, then it is unclear to a reviewer if the type is redundant or it has been left unused by mistake.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid unusedtype()\n{\n  typedef int local_Type; // Noncompliant, unused\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 0-1-5 - A project shall not contain unused type declarations. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eIf a type is declared but not used, then it is unclear to a reviewer if the type is redundant or it has been left unused by mistake.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid unusedtype()\n{\n  typedef int local_Type; // Noncompliant, unused\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 0-1-5 - A project shall not contain unused type declarations. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "based-on-misra",
      "unused"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:M23_224",
    "name": "The macro \"offsetof\" shall not be used",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 21.2.4\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eThe \u003ccode\u003eoffsetof\u003c/code\u003e macro is used to access the underlying representation of an object, breaking its encapsulation. In addition, its use\nresults in \u003cem\u003eundefined behaviour\u003c/em\u003e when the specified member is a bit-field, a static data member, or a member function.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nstruct A\n{\n  int32_t i;\n};\n\nvoid f1()\n{\n  offsetof( A, i );      // Non-compliant\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003e{rule:c:S986} targets the same defect as this rule but for a non-mission-critical context.\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 21.2.4\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eThe \u003ccode\u003eoffsetof\u003c/code\u003e macro is used to access the underlying representation of an object, breaking its encapsulation. In addition, its use\nresults in \u003cem\u003eundefined behaviour\u003c/em\u003e when the specified member is a bit-field, a static data member, or a member function.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nstruct A\n{\n  int32_t i;\n};\n\nvoid f1()\n{\n  offsetof( A, i );      // Non-compliant\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003e{rule:c:S986} targets the same defect as this rule but for a non-mission-critical context.\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "misra-c++2023",
      "misra-required",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S5802",
    "name": "Changing directories improperly when using \"chroot\" is security-sensitive",
    "defaultSeverity": "CRITICAL",
    "type": "SECURITY_HOTSPOT",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "SECURITY": "HIGH"
    },
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe purpose of creating a jail, the \"virtual root directory\" created with chroot-type functions, is to limit access to the file system by isolating\nthe process inside this jail. However, many chroot function implementations don’t modify the current working directory, thus the process has still\naccess to unauthorized resources outside of the \"jail\".\u003c/p\u003e"
      },
      {
        "key": "assess_the_problem",
        "htmlContent": "\u003ch2\u003eAsk Yourself Whether\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e The application changes the working directory before or after running chroot. \u003c/li\u003e\n  \u003cli\u003e The application uses a path inside the jail directory as working directory. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere is a risk if you answered no to any of those questions.\u003c/p\u003e\n\u003ch2\u003eSensitive Code Example\u003c/h2\u003e\n\u003cp\u003eThe current directory is not changed with the \u003ccode\u003echdir\u003c/code\u003e function before or after the creation of a jail with the \u003ccode\u003echroot\u003c/code\u003e\nfunction:\u003c/p\u003e\n\u003cpre\u003e\nconst char* root_dir \u003d \"/jail/\";\nchroot(root_dir); // Sensitive: no chdir before or after chroot, and missing check of return value\n\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003echroot\u003c/code\u003e or \u003ccode\u003echdir\u003c/code\u003e operations could fail and the process still have access to unauthorized resources. The return code\nshould be checked:\u003c/p\u003e\n\u003cpre\u003e\nconst char* root_dir \u003d \"/jail/\";\nchroot(root_dir); // Sensitive: missing check of the return value\nconst char* any_dir \u003d \"/any/\";\nchdir(any_dir); // Sensitive: missing check of the return value\n\u003c/pre\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003ch2\u003eRecommended Secure Coding Practices\u003c/h2\u003e\n\u003cp\u003eChange the current working directory to the root directory after switching to a jail directory.\u003c/p\u003e\n\u003ch2\u003eCompliant Solution\u003c/h2\u003e\n\u003cp\u003eTo correctly isolate the application into a jail, change the current directory with \u003ccode\u003echdir\u003c/code\u003e before the \u003ccode\u003echroot\u003c/code\u003e and check the\nreturn code of both functions:\u003c/p\u003e\n\u003cpre\u003e\nconst char* root_dir \u003d \"/jail/\";\n\nif (chdir(root_dir) \u003d\u003d -1) {\n  exit(-1);\n}\n\nif (chroot(root_dir) \u003d\u003d -1) {  // compliant: the current dir is changed to the jail and the results of both functions are checked\n  exit(-1);\n}\n\u003c/pre\u003e\n\u003ch2\u003eSee\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/Top10/A05_2021-Security_Misconfiguration/\"\u003eOWASP Top 10 2021 Category A5\u003c/a\u003e - Security Misconfiguration \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A5-Broken_Access_Control\"\u003eOWASP Top 10 2017 Category A5\u003c/a\u003e -\n  Broken Access Control \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/243\"\u003eMITRE, CWE-243\u003c/a\u003e - Creation of chroot Jail Without Changing Working Directory \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://man7.org/linux/man-pages/man2/chdir.2.html\"\u003eman7.org\u003c/a\u003e - chdir \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://man7.org/linux/man-pages/man2/chroot.2.html\"\u003eman7.org\u003c/a\u003e - chroot \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "cwe",
      "symbolic-execution"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": [],
    "vulnerabilityProbability": "LOW"
  },
  {
    "key": "c:S3626",
    "name": "Jump statements should not be redundant",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eJump statements, such as \u003ccode\u003ereturn\u003c/code\u003e, \u003ccode\u003ebreak\u003c/code\u003e, \u003ccode\u003egoto\u003c/code\u003e, and \u003ccode\u003econtinue\u003c/code\u003e let you change the default flow of\nprogram execution, but jump statements that direct the control flow to the original direction are just a waste of keystrokes.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid Foo()\n{\n  goto A; // Noncompliant\n  A:\n  while (condition1)\n  {\n    if (condition2)\n    {\n      continue; // Noncompliant\n    }\n    else\n    {\n      DoTheThing();\n    }\n  }\n  return; // Noncompliant; this is a void method\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid Foo()\n{\n  while (condition1)\n  {\n    if (!condition2)\n    {\n      DoTheThing();\n    }\n  }\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eJump statements, such as \u003ccode\u003ereturn\u003c/code\u003e, \u003ccode\u003ebreak\u003c/code\u003e, \u003ccode\u003egoto\u003c/code\u003e, and \u003ccode\u003econtinue\u003c/code\u003e let you change the default flow of\nprogram execution, but jump statements that direct the control flow to the original direction are just a waste of keystrokes.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid Foo()\n{\n  goto A; // Noncompliant\n  A:\n  while (condition1)\n  {\n    if (condition2)\n    {\n      continue; // Noncompliant\n    }\n    else\n    {\n      DoTheThing();\n    }\n  }\n  return; // Noncompliant; this is a void method\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid Foo()\n{\n  while (condition1)\n  {\n    if (!condition2)\n    {\n      DoTheThing();\n    }\n  }\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "clumsy",
      "redundant"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S5488",
    "name": "Only valid arguments should be passed to UNIX/POSIX functions",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003cp\u003ePassing invalid arguments to UNIX/POSIX functions may result in undefined behavior.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eMany UNIX/POSIX functions put certain constraints on the values of their parameters. The behavior for some of those UNIX/POSIX functions is not\ndefined but instead, their behavior is implementation-defined, if one passes incorrectly constrained parameters. This may lead to undefined behavior\ndepending on a function’s concrete implementation. The constraints include the following:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Allocation sizes of \u003ccode\u003ecalloc\u003c/code\u003e, \u003ccode\u003emalloc\u003c/code\u003e, \u003ccode\u003erealloc\u003c/code\u003e, \u003ccode\u003ereallocf\u003c/code\u003e, \u003ccode\u003ealloca\u003c/code\u003e and\n  \u003ccode\u003evalloc\u003c/code\u003e must be strictly positive \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003eopen\u003c/code\u003e and \u003ccode\u003eopenat\u003c/code\u003e should be called with a flag that contains one of the access modes: \u003ccode\u003eO_RDONLY\u003c/code\u003e,\n  \u003ccode\u003eO_WRONLY\u003c/code\u003e, or \u003ccode\u003eO_RDWR\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003eopen\u003c/code\u003e and \u003ccode\u003eopenat\u003c/code\u003e with flag \u003ccode\u003eO_CREAT\u003c/code\u003e should be called with a third argument \u003c/li\u003e\n  \u003cli\u003e The \u003ccode\u003eO_EXCL\u003c/code\u003e flag should be used with \u003ccode\u003eO_CREAT\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e The first argument of \u003ccode\u003epthread_once\u003c/code\u003e should not have automatic storage duration and should be initialized by the constant\n  \u003ccode\u003ePTHREAD_ONCE_INIT\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eFailing to pass correctly constrained parameters can result in undefined behavior.\u003c/p\u003e\n\u003cpre\u003e\n// Depending on the implementation, either NULL is returned, or the behavior is\n// as if the passed size parameter were a non-zero value, except that accesses\n// of the returned pointer result in undefined behavior.\nvoid *mem \u003d alloca(0); // May result in undefined behavior.\n\nint fd \u003d open(\"example.txt\", O_ APPEND); // Access mode is missing, may result in undefined behavior.\n\n// Third argument should be used to specify the file\u0027s access permissions.\nint fd_1 \u003d open(\"another_example.txt\", O_CREAT); // May result in undefined behavior.\n\n// Since `O_EXCL` prevents file creation if it already exists, the flag for\n// file creation `O_CREAT` should be used in combination with `O_EXCL`.\nint fd_3 \u003d open(\"further_example.txt\", O_EXCL); // `O_CREAT` flag is missing, may result in undefined behavior.\n\nint counter \u003d 0;\n\nvoid inc_counter() { ++counter; }\n\nvoid bar() {\n  // May trigger undefined behavior, because `once_control`\u0027s storage duration\n  // is automatic. `counter` might be incremented with each call to `bar`.\n  pthread_once_t once_control \u003d PTHREAD_ONCE_INIT;\n  pthread_once(\u0026amp;once_control, \u0026amp;inc_counter); // May result in undefined behavior.\n}\n\u003c/pre\u003e\n\u003ch2\u003eWhat is the potential impact?\u003c/h2\u003e\n\u003cp\u003eUsing UNIX/POSIX functions with invalid arguments results in implementation-defined behavior and may lead to \u003cstrong\u003eundefined\nbehavior\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eWhen a function emits implementation-defined behavior, its behavior is unspecified and each implementation documents how the choice is made.\nImplementation-defined behavior can quickly lead to undefined behavior, if the respective function is not used exactly as per the documentation.\u003c/p\u003e\n\u003cp\u003eWhen a program comprises undefined behavior, the compiler no longer needs to adhere to the language standard, and the program has no meaning\nassigned to it.\u003c/p\u003e\n\u003cp\u003eDepending on the concrete situation, the application might just crash, but in the worst case, the application may appear to execute correctly,\nwhile losing data or producing incorrect results.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eEnsure that allocation sizes are strictly positive, calls to \u003ccode\u003eopen\u003c/code\u003e and \u003ccode\u003eopenat\u003c/code\u003e are correctly parameterized, and the first\nargument of \u003ccode\u003epthread_once\u003c/code\u003e has non-automatic storage duration and is initialized with \u003ccode\u003ePTHREAD_ONCE_INIT\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n\nchar *allocate_buffer(size_t size) {\n  char *buf \u003d (char *)malloc(size); // Noncompliant: `size` might be zero.\n  if (buf \u003d\u003d NULL) {\n    // Handle allocation error.\n    perror(\"malloc failed\");\n    exit(1);\n  }\n  return buf;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n\nchar *allocate_buffer(size_t size) {\n  if (size \u003d\u003d 0) { // Compliant: `size` is checked for zero.\n    // Handle error.\n    printf(\"Cannot allocate 0 bytes!\\n\");\n    exit(1);\n  }\n  char *buf \u003d (char *)malloc(size);\n  if (buf \u003d\u003d NULL) {\n    // Handle allocation error.\n    perror(\"malloc failed\");\n    exit(1);\n  }\n  return buf;\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;fcntl.h\u0026gt;\n#include \u0026lt;sys/stat.h\u0026gt;\n\nint foo() {\n  int fd \u003d open(\"example.txt\", O_CREAT); // Noncompliant: file permissions are not set.\n  if (fd \u003d\u003d -1) {\n    return -1;\n  }\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;fcntl.h\u0026gt;\n#include \u0026lt;sys/stat.h\u0026gt;\n\nint foo() {\n  // Specify read permissions for user, group and others.\n  int fd \u003d open(\"example.txt\", O_CREAT, S_IRUSR | S_IRGRP | S_IROTH); // Compliant: file permissions correctly set.\n  if (fd \u003d\u003d -1) {\n    return -1;\n  }\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;pthread.h\u0026gt;\n#include \u0026lt;stdio.h\u0026gt;\n\nint counter \u003d 0;\n\nvoid inc_counter() { ++counter; }\n\nvoid bar() {\n  pthread_once_t once_control \u003d PTHREAD_ONCE_INIT;\n  pthread_once(\u0026amp;once_control, \u0026amp;inc_counter); // Noncompliant: `once_control` has automatic storage duration.\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;pthread.h\u0026gt;\n#include \u0026lt;stdio.h\u0026gt;\n\nint counter \u003d 0;\npthread_once_t once_control \u003d PTHREAD_ONCE_INIT;\n\nvoid inc_counter() { ++counter; }\n\nvoid bar() {\n  pthread_once(\u0026amp;once_control, \u0026amp;inc_counter); // Compliant: `once_control` has global storage duration here.\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/display/c/MEM04-C.+Beware+of+zero-length+allocations\"\u003eMEM04-C. Beware of zero-length\n  allocations\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:c:S3807} ensures that appropriate arguments are passed to C standard library functions \u003c/li\u003e\n  \u003cli\u003e {rule:c:S5485} ensures that appropriate arguments are passed to C standard library for handling I/O streams \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003ePassing invalid arguments to UNIX/POSIX functions may result in undefined behavior.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eMany UNIX/POSIX functions put certain constraints on the values of their parameters. The behavior for some of those UNIX/POSIX functions is not\ndefined but instead, their behavior is implementation-defined, if one passes incorrectly constrained parameters. This may lead to undefined behavior\ndepending on a function’s concrete implementation. The constraints include the following:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Allocation sizes of \u003ccode\u003ecalloc\u003c/code\u003e, \u003ccode\u003emalloc\u003c/code\u003e, \u003ccode\u003erealloc\u003c/code\u003e, \u003ccode\u003ereallocf\u003c/code\u003e, \u003ccode\u003ealloca\u003c/code\u003e and\n  \u003ccode\u003evalloc\u003c/code\u003e must be strictly positive \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003eopen\u003c/code\u003e and \u003ccode\u003eopenat\u003c/code\u003e should be called with a flag that contains one of the access modes: \u003ccode\u003eO_RDONLY\u003c/code\u003e,\n  \u003ccode\u003eO_WRONLY\u003c/code\u003e, or \u003ccode\u003eO_RDWR\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003eopen\u003c/code\u003e and \u003ccode\u003eopenat\u003c/code\u003e with flag \u003ccode\u003eO_CREAT\u003c/code\u003e should be called with a third argument \u003c/li\u003e\n  \u003cli\u003e The \u003ccode\u003eO_EXCL\u003c/code\u003e flag should be used with \u003ccode\u003eO_CREAT\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e The first argument of \u003ccode\u003epthread_once\u003c/code\u003e should not have automatic storage duration and should be initialized by the constant\n  \u003ccode\u003ePTHREAD_ONCE_INIT\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eFailing to pass correctly constrained parameters can result in undefined behavior.\u003c/p\u003e\n\u003cpre\u003e\n// Depending on the implementation, either NULL is returned, or the behavior is\n// as if the passed size parameter were a non-zero value, except that accesses\n// of the returned pointer result in undefined behavior.\nvoid *mem \u003d alloca(0); // May result in undefined behavior.\n\nint fd \u003d open(\"example.txt\", O_ APPEND); // Access mode is missing, may result in undefined behavior.\n\n// Third argument should be used to specify the file\u0027s access permissions.\nint fd_1 \u003d open(\"another_example.txt\", O_CREAT); // May result in undefined behavior.\n\n// Since `O_EXCL` prevents file creation if it already exists, the flag for\n// file creation `O_CREAT` should be used in combination with `O_EXCL`.\nint fd_3 \u003d open(\"further_example.txt\", O_EXCL); // `O_CREAT` flag is missing, may result in undefined behavior.\n\nint counter \u003d 0;\n\nvoid inc_counter() { ++counter; }\n\nvoid bar() {\n  // May trigger undefined behavior, because `once_control`\u0027s storage duration\n  // is automatic. `counter` might be incremented with each call to `bar`.\n  pthread_once_t once_control \u003d PTHREAD_ONCE_INIT;\n  pthread_once(\u0026amp;once_control, \u0026amp;inc_counter); // May result in undefined behavior.\n}\n\u003c/pre\u003e\n\u003ch2\u003eWhat is the potential impact?\u003c/h2\u003e\n\u003cp\u003eUsing UNIX/POSIX functions with invalid arguments results in implementation-defined behavior and may lead to \u003cstrong\u003eundefined\nbehavior\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eWhen a function emits implementation-defined behavior, its behavior is unspecified and each implementation documents how the choice is made.\nImplementation-defined behavior can quickly lead to undefined behavior, if the respective function is not used exactly as per the documentation.\u003c/p\u003e\n\u003cp\u003eWhen a program comprises undefined behavior, the compiler no longer needs to adhere to the language standard, and the program has no meaning\nassigned to it.\u003c/p\u003e\n\u003cp\u003eDepending on the concrete situation, the application might just crash, but in the worst case, the application may appear to execute correctly,\nwhile losing data or producing incorrect results.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eEnsure that allocation sizes are strictly positive, calls to \u003ccode\u003eopen\u003c/code\u003e and \u003ccode\u003eopenat\u003c/code\u003e are correctly parameterized, and the first\nargument of \u003ccode\u003epthread_once\u003c/code\u003e has non-automatic storage duration and is initialized with \u003ccode\u003ePTHREAD_ONCE_INIT\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n\nchar *allocate_buffer(size_t size) {\n  char *buf \u003d (char *)malloc(size); // Noncompliant: `size` might be zero.\n  if (buf \u003d\u003d NULL) {\n    // Handle allocation error.\n    perror(\"malloc failed\");\n    exit(1);\n  }\n  return buf;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n\nchar *allocate_buffer(size_t size) {\n  if (size \u003d\u003d 0) { // Compliant: `size` is checked for zero.\n    // Handle error.\n    printf(\"Cannot allocate 0 bytes!\\n\");\n    exit(1);\n  }\n  char *buf \u003d (char *)malloc(size);\n  if (buf \u003d\u003d NULL) {\n    // Handle allocation error.\n    perror(\"malloc failed\");\n    exit(1);\n  }\n  return buf;\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;fcntl.h\u0026gt;\n#include \u0026lt;sys/stat.h\u0026gt;\n\nint foo() {\n  int fd \u003d open(\"example.txt\", O_CREAT); // Noncompliant: file permissions are not set.\n  if (fd \u003d\u003d -1) {\n    return -1;\n  }\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;fcntl.h\u0026gt;\n#include \u0026lt;sys/stat.h\u0026gt;\n\nint foo() {\n  // Specify read permissions for user, group and others.\n  int fd \u003d open(\"example.txt\", O_CREAT, S_IRUSR | S_IRGRP | S_IROTH); // Compliant: file permissions correctly set.\n  if (fd \u003d\u003d -1) {\n    return -1;\n  }\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;pthread.h\u0026gt;\n#include \u0026lt;stdio.h\u0026gt;\n\nint counter \u003d 0;\n\nvoid inc_counter() { ++counter; }\n\nvoid bar() {\n  pthread_once_t once_control \u003d PTHREAD_ONCE_INIT;\n  pthread_once(\u0026amp;once_control, \u0026amp;inc_counter); // Noncompliant: `once_control` has automatic storage duration.\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;pthread.h\u0026gt;\n#include \u0026lt;stdio.h\u0026gt;\n\nint counter \u003d 0;\npthread_once_t once_control \u003d PTHREAD_ONCE_INIT;\n\nvoid inc_counter() { ++counter; }\n\nvoid bar() {\n  pthread_once(\u0026amp;once_control, \u0026amp;inc_counter); // Compliant: `once_control` has global storage duration here.\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/display/c/MEM04-C.+Beware+of+zero-length+allocations\"\u003eMEM04-C. Beware of zero-length\n  allocations\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:c:S3807} ensures that appropriate arguments are passed to C standard library functions \u003c/li\u003e\n  \u003cli\u003e {rule:c:S5485} ensures that appropriate arguments are passed to C standard library for handling I/O streams \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "suspicious",
      "symbolic-execution"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S5489",
    "name": "\"pthread_mutex_t\" should be unlocked in the reverse order they were locked",
    "defaultSeverity": "BLOCKER",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cem\u003eMutexes\u003c/em\u003e are synchronization primitives that allow the managing of concurrency. It is a common situation to have to use multiple\n\u003cem\u003emutexes\u003c/em\u003e to protect multiple resources with different access patterns.\u003c/p\u003e\n\u003cp\u003eIn such a situation, it is crucial to define an order on the set of all \u003cem\u003emutexes\u003c/em\u003e:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e This order should be strictly followed when \u003cem\u003elocking\u003c/em\u003e \u003cem\u003emutexes\u003c/em\u003e. \u003c/li\u003e\n  \u003cli\u003e The reverse order should be strictly followed when \u003cem\u003eunlocking\u003c/em\u003e \u003cem\u003emutexes\u003c/em\u003e. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eFailure to do so can lead to \u003cem\u003edeadlocks\u003c/em\u003e. i.e., situations where two or more threads are blocked forever, each holding one mutex and waiting\nfor one held by the other(s).\u003c/p\u003e\n\u003cp\u003eIn C++, an easy way to make sure the unlocks are called in reverse order from the lock is to wrap the lock/unlock operations in an RAII class\n(since destructors of local variables are called in reverse order of their creation).\u003c/p\u003e\n\u003cp\u003eIf instead of \u003ccode\u003epthread_mutex_t\u003c/code\u003e you are using \u003ccode\u003estd::mutex\u003c/code\u003e, there are other mechanisms that allow you to avoid deadlocks in\nthat case, see S5524.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eReorder locking and unlocking operations to always lock in the same order and unlock in the reverse order.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre\u003e\npthread_mutex_t mtx1;\npthread_mutex_t mtx2;\n\nvoid thread_safe_operation(void) {\n  pthread_mutex_lock(\u0026amp;mtx1);\n  pthread_mutex_lock(\u0026amp;mtx2);\n  use_resources();\n  pthread_mutex_unlock(\u0026amp;mtx1); // Noncompliant\n  pthread_mutex_unlock(\u0026amp;mtx2);\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eC solution:\u003c/p\u003e\n\u003cpre\u003e\npthread_mutex_t mtx1;\npthread_mutex_t mtx2;\n\nvoid thread_safe_operation(void) {\n  pthread_mutex_lock(\u0026amp;mtx1);\n  pthread_mutex_lock(\u0026amp;mtx2);\n  use_resources();\n  pthread_mutex_unlock(\u0026amp;mtx2);\n  pthread_mutex_unlock(\u0026amp;mtx1);\n}\n\u003c/pre\u003e\n\u003cp\u003eC++03 solution:\u003c/p\u003e\n\u003cpre\u003e\npthread_mutex_t mtx1;\npthread_mutex_t mtx2;\n\nstruct MutexLocker {\n  MutexLocker(pthread_mutex_t* mtx) : mtx(mtx) {\n    pthread_mutex_lock(mtx);\n  }\n  ~MutexLocker() {\n    pthread_mutex_unlock(mtx);\n  }\n  pthread_mutex_t* mtx;\n};\n\nstruct ResourcesLocker {\n  ResourcesLocker() : m1(\u0026amp;mtx1), m2(\u0026amp;mtx2) {}\n  MutexLocker m1;\n  MutexLocker m2;\n};\n\nvoid thread_safe_operation(void) {\n  ResourcesLocker locker;\n  use_resources();\n}\n\u003c/pre\u003e\n\u003cp\u003eC++11 and C++14 solution:\u003c/p\u003e\n\u003cpre\u003e\nstd::mutex m1;\nstd::mutex m2;\n\nvoid thread_safe_operation(void) {\n  std::lock(m1, m2);\n  std::lock_guard\u0026lt;std::mutex\u0026gt; lck1(m1, std::adopt_lock);\n  std::lock_guard\u0026lt;std::mutex\u0026gt; lck2(m2, std::adopt_lock);\n  use_resources();\n}\n\u003c/pre\u003e\n\u003cp\u003eC++17 and after:\u003c/p\u003e\n\u003cpre\u003e\nstd::mutex m1;\nstd::mutex m2;\n\nvoid thread_safe_operation(void) {\n  std::scoped_lock lck1(m1, m2);\n  use_resources();\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cem\u003eMutexes\u003c/em\u003e are synchronization primitives that allow the managing of concurrency. It is a common situation to have to use multiple\n\u003cem\u003emutexes\u003c/em\u003e to protect multiple resources with different access patterns.\u003c/p\u003e\n\u003cp\u003eIn such a situation, it is crucial to define an order on the set of all \u003cem\u003emutexes\u003c/em\u003e:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e This order should be strictly followed when \u003cem\u003elocking\u003c/em\u003e \u003cem\u003emutexes\u003c/em\u003e. \u003c/li\u003e\n  \u003cli\u003e The reverse order should be strictly followed when \u003cem\u003eunlocking\u003c/em\u003e \u003cem\u003emutexes\u003c/em\u003e. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eFailure to do so can lead to \u003cem\u003edeadlocks\u003c/em\u003e. i.e., situations where two or more threads are blocked forever, each holding one mutex and waiting\nfor one held by the other(s).\u003c/p\u003e\n\u003cp\u003eIn C++, an easy way to make sure the unlocks are called in reverse order from the lock is to wrap the lock/unlock operations in an RAII class\n(since destructors of local variables are called in reverse order of their creation).\u003c/p\u003e\n\u003cp\u003eIf instead of \u003ccode\u003epthread_mutex_t\u003c/code\u003e you are using \u003ccode\u003estd::mutex\u003c/code\u003e, there are other mechanisms that allow you to avoid deadlocks in\nthat case, see S5524.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eReorder locking and unlocking operations to always lock in the same order and unlock in the reverse order.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre\u003e\npthread_mutex_t mtx1;\npthread_mutex_t mtx2;\n\nvoid thread_safe_operation(void) {\n  pthread_mutex_lock(\u0026amp;mtx1);\n  pthread_mutex_lock(\u0026amp;mtx2);\n  use_resources();\n  pthread_mutex_unlock(\u0026amp;mtx1); // Noncompliant\n  pthread_mutex_unlock(\u0026amp;mtx2);\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eC solution:\u003c/p\u003e\n\u003cpre\u003e\npthread_mutex_t mtx1;\npthread_mutex_t mtx2;\n\nvoid thread_safe_operation(void) {\n  pthread_mutex_lock(\u0026amp;mtx1);\n  pthread_mutex_lock(\u0026amp;mtx2);\n  use_resources();\n  pthread_mutex_unlock(\u0026amp;mtx2);\n  pthread_mutex_unlock(\u0026amp;mtx1);\n}\n\u003c/pre\u003e\n\u003cp\u003eC++03 solution:\u003c/p\u003e\n\u003cpre\u003e\npthread_mutex_t mtx1;\npthread_mutex_t mtx2;\n\nstruct MutexLocker {\n  MutexLocker(pthread_mutex_t* mtx) : mtx(mtx) {\n    pthread_mutex_lock(mtx);\n  }\n  ~MutexLocker() {\n    pthread_mutex_unlock(mtx);\n  }\n  pthread_mutex_t* mtx;\n};\n\nstruct ResourcesLocker {\n  ResourcesLocker() : m1(\u0026amp;mtx1), m2(\u0026amp;mtx2) {}\n  MutexLocker m1;\n  MutexLocker m2;\n};\n\nvoid thread_safe_operation(void) {\n  ResourcesLocker locker;\n  use_resources();\n}\n\u003c/pre\u003e\n\u003cp\u003eC++11 and C++14 solution:\u003c/p\u003e\n\u003cpre\u003e\nstd::mutex m1;\nstd::mutex m2;\n\nvoid thread_safe_operation(void) {\n  std::lock(m1, m2);\n  std::lock_guard\u0026lt;std::mutex\u0026gt; lck1(m1, std::adopt_lock);\n  std::lock_guard\u0026lt;std::mutex\u0026gt; lck2(m2, std::adopt_lock);\n  use_resources();\n}\n\u003c/pre\u003e\n\u003cp\u003eC++17 and after:\u003c/p\u003e\n\u003cpre\u003e\nstd::mutex m1;\nstd::mutex m2;\n\nvoid thread_safe_operation(void) {\n  std::scoped_lock lck1(m1, m2);\n  use_resources();\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "multi-threading",
      "symbolic-execution"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S5486",
    "name": "\"pthread_mutex_t\" should not be locked when already locked, or unlocked when already unlocked",
    "defaultSeverity": "BLOCKER",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003cp\u003e\u003ccode\u003epthread_mutex_t\u003c/code\u003e should not be locked when already locked, or unlocked when already unlocked.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cem\u003eMutexes\u003c/em\u003e are synchronization primitives that allow to manage concurrency. This is the most fundamental building block for creating\n\u003cem\u003esafe\u003c/em\u003e concurrent applications. By using a \u003cem\u003emutex\u003c/em\u003e, one can ensure that a block of code is executed by a single thread concurrently.\nData structures are designed to maintain their invariants between member-function calls. If a data structure is accessed concurrently, and one of the\naccesses is a write operation, then it has a \u003cem\u003edata race\u003c/em\u003e. Having \u003cem\u003edata races\u003c/em\u003e is \u003cem\u003eundefined behavior\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eAdversaries actively exploit \u003cem\u003edata races\u003c/em\u003e to take over systems, but \u003cem\u003edata races\u003c/em\u003e are also a common source of \u003cem\u003edata corruption\u003c/em\u003e\nin concurrent applications resulting in dormant and hard-to-find bugs.\u003c/p\u003e\n\u003cp\u003eTo prevent \u003cem\u003edata races\u003c/em\u003e, the shared resource (usually memory) must be protected by obtaining mutual access to the data during both reading\nand writing. Such mutual exclusion is generally achieved by using a \u003cem\u003emutex\u003c/em\u003e, which is frequently referred to as a \u003cem\u003elock\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eA \u003cem\u003emutex\u003c/em\u003e has two states: \u003cem\u003ereleased\u003c/em\u003e - which is the initial state, or \u003cem\u003eacquired\u003c/em\u003e. These two states are frequently called\n\u003cem\u003eunlocked\u003c/em\u003e and \u003cem\u003elocked\u003c/em\u003e as well.\u003c/p\u003e\n\u003cp\u003eTo effectively protect the shared resource from concurrent accesses, all such accesses should be guarded by the same \u003cem\u003emutex\u003c/em\u003e. They need to\n\u003cem\u003elock\u003c/em\u003e the \u003cem\u003emutex\u003c/em\u003e to gain \u003cem\u003esafe\u003c/em\u003e exclusive access to the resource and \u003cem\u003eunlock\u003c/em\u003e it after they are done mutating or reading\nit.\u003c/p\u003e\n\u003cp\u003eYou can abstract away the concurrent threads sharing the mutex and think of it as owned by the current thread. It never spontaneously changes\nbetween \u003cem\u003eacquired\u003c/em\u003e and \u003cem\u003ereleased\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eIn this view, these are the possible transitions when calling \u003ccode\u003elock\u003c/code\u003e or \u003ccode\u003eunlock\u003c/code\u003e on a \u003cem\u003emutex\u003c/em\u003e in a given state:\u003c/p\u003e\n\u003col\u003e\n  \u003cli\u003e \u003cem\u003ereleased\u003c/em\u003e + \u003ccode\u003elock()\u003c/code\u003e ⇒ \u003cem\u003eacquired\u003c/em\u003e \u003c/li\u003e\n  \u003cli\u003e \u003cem\u003eacquired\u003c/em\u003e + \u003ccode\u003eunlock()\u003c/code\u003e ⇒ \u003cem\u003ereleased\u003c/em\u003e \u003c/li\u003e\n  \u003cli\u003e \u003cem\u003eacquired\u003c/em\u003e + \u003ccode\u003elock()\u003c/code\u003e ⇒ \u003cem\u003edeadlock\u003c/em\u003e \u003c/li\u003e\n  \u003cli\u003e \u003cem\u003ereleased\u003c/em\u003e + \u003ccode\u003eunlock()\u003c/code\u003e ⇒ \u003cem\u003eundefined behavior\u003c/em\u003e \u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eWhen a thread locks a mutex, another thread trying to \u003cem\u003eacquire\u003c/em\u003e the same mutex will be \u003cem\u003eblocked\u003c/em\u003e and have to wait for the first\nthread to \u003cem\u003erelease\u003c/em\u003e it. This waiting period can take some time. If a thread attempts to lock a mutex it has already acquired, it will\n\u003cem\u003edeadlock\u003c/em\u003e because it would need to release it to lock it again.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eLocking an \u003cem\u003eacquired\u003c/em\u003e mutex leads to a \u003cem\u003edeadlock\u003c/em\u003e, as a mutex can only be obtained once. Unlocking a \u003cem\u003ereleased\u003c/em\u003e mutex is\n\u003cem\u003eundefined behavior\u003c/em\u003e. Removing synchronization can cause \u003cem\u003edata races\u003c/em\u003e, leading to \u003cem\u003edata corruption\u003c/em\u003e, which adversaries might\nleverage to take over the system.\u003c/p\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThere are \u003cem\u003erecursive mutexes\u003c/em\u003e that can be \u003cem\u003eacquired\u003c/em\u003e multiple times by the same thread, given that just as many times we also\n\u003cem\u003erelease\u003c/em\u003e the \u003cem\u003emutex\u003c/em\u003e. They are rare in practice and usually signal design problems in the code. Thus we assume\n\u003ccode\u003epthread_mutex_t\u003c/code\u003e refers to \u003cem\u003enon-recursive\u003c/em\u003e mutexes.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eNever lock an \u003cem\u003eacquired\u003c/em\u003e mutex. Lock the mutexes in a strict order that is followed throughout the project. Unlock operations should be done\nthe same way but in reversed order.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;pthread.h\u0026gt;\n\npthread_mutex_t m1 \u003d PTHREAD_MUTEX_INITIALIZER;\npthread_mutex_t m2 \u003d PTHREAD_MUTEX_INITIALIZER;\n\nvoid locks() {\n  pthread_mutex_lock(\u0026amp;m1);\n  pthread_mutex_lock(\u0026amp;m1); // Noncompliant: \u0027m1\u0027 is already acquired\n}\n\nvoid unlocks() {\n  pthread_mutex_unlock(\u0026amp;m1);\n  pthread_mutex_unlock(\u0026amp;m1); // Noncompliant: \u0027m1\u0027 is already released\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;pthread.h\u0026gt;\n\npthread_mutex_t m1 \u003d PTHREAD_MUTEX_INITIALIZER;\npthread_mutex_t m2 \u003d PTHREAD_MUTEX_INITIALIZER;\n\nvoid locks() {\n  pthread_mutex_lock(\u0026amp;m1);\n  pthread_mutex_lock(\u0026amp;m2); // Compliant: we acquired both \u0027m1\u0027 and \u0027m2\u0027 for the first time.\n}\n\nvoid unlocks() {\n  pthread_mutex_unlock(\u0026amp;m2);\n  pthread_mutex_unlock(\u0026amp;m1); // Compliant: we released both \u0027m1\u0027 and \u0027m2\u0027 for the first time.\n}\n\u003c/pre\u003e\n\u003ch3\u003ePitfalls\u003c/h3\u003e\n\u003cp\u003eCalling arbitrary functions while holding a lock should be avoided, as the function might also want to lock the resource we already acquired,\ncausing a deadlock. One particular example of such functions is callbacks.\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;pthread.h\u0026gt;\n\npthread_mutex_t m \u003d PTHREAD_MUTEX_INITIALIZER;\n\nvoid handle_callback(void (*callback)(void)) {\n  pthread_mutex_lock(\u0026amp;m);\n  callback(); // If tries to lock mutex \u0027m\u0027, then we have a deadlock.\n  pthread_mutex_unlock(\u0026amp;m);\n}\n\u003c/pre\u003e\n\u003ch3\u003eGoing the extra mile\u003c/h3\u003e\n\u003cp\u003eThe section of code for which the \u003cem\u003emutex\u003c/em\u003e is \u003cem\u003eacquired\u003c/em\u003e is called the \u003cem\u003ecritical section\u003c/em\u003e. Inside the \u003cem\u003ecritical\nsection\u003c/em\u003e, we are the only ones with access to the shared resource. Thus we are free to mutate or read it without considering what other threads\nare doing concurrently. However, having large \u003cem\u003ecritical sections\u003c/em\u003e can prevent other threads from making progress if they want to also\n\u003cem\u003eacquire\u003c/em\u003e the same \u003cem\u003emutex\u003c/em\u003e and access the shared resource. Consequently, \u003cem\u003ecritical sections\u003c/em\u003e are supposed to be as small as\npossible.\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;pthread.h\u0026gt;\n#include \u0026lt;stdbool.h\u0026gt;\n\nint input;\nint result;\nbool isFib;\n\n// Guards both \u0027num1\u0027 and \u0027num2\u0027.\npthread_mutex_t m \u003d PTHREAD_MUTEX_INITIALIZER;\n\nint fibonacci(int n);\nint factorial(int n);\n\nvoid locks(bool calcFib, int n) {\n  // Do the calculations without taking the lock.\n  int res;\n  if (calcFib) {\n    res \u003d fibonacci(n);\n  } else {\n    res \u003d factorial(n);\n  }\n\n  pthread_mutex_lock(\u0026amp;m);\n  // Critical section starts\n  input \u003d n;\n  result \u003d res;\n  isFib \u003d calcFib;\n  // Critical section ends.\n  pthread_mutex_unlock(\u0026amp;m);\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/764\"\u003e764 Multiple Locks of a Critical Resource\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/362\"\u003e362 Multiple Concurrent Execution using Shared Resource with Improper\n  Synchronization (\u0027Race Condition\u0027)\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:c:S5487} enforces proper initialization and destruction of \u003ccode\u003epthread\u003c/code\u003e mutexes. \u003c/li\u003e\n  \u003cli\u003e {rule:c:S5489} enforces unlocking held \u003ccode\u003epthread\u003c/code\u003e mutexes in reverse order. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e The Open Group - \u003ca href\u003d\"https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_mutex_init.html\"\u003e\u003ccode\u003epthread_mutex_init\u003c/code\u003e,\n  \u003ccode\u003epthread_mutex_destroy\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e The Open Group - \u003ca href\u003d\"https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_mutex_lock.html\"\u003e\u003ccode\u003epthread_mutex_lock\u003c/code\u003e,\n  \u003ccode\u003epthread_mutex_unlock\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003e\u003ccode\u003epthread_mutex_t\u003c/code\u003e should not be locked when already locked, or unlocked when already unlocked.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cem\u003eMutexes\u003c/em\u003e are synchronization primitives that allow to manage concurrency. This is the most fundamental building block for creating\n\u003cem\u003esafe\u003c/em\u003e concurrent applications. By using a \u003cem\u003emutex\u003c/em\u003e, one can ensure that a block of code is executed by a single thread concurrently.\nData structures are designed to maintain their invariants between member-function calls. If a data structure is accessed concurrently, and one of the\naccesses is a write operation, then it has a \u003cem\u003edata race\u003c/em\u003e. Having \u003cem\u003edata races\u003c/em\u003e is \u003cem\u003eundefined behavior\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eAdversaries actively exploit \u003cem\u003edata races\u003c/em\u003e to take over systems, but \u003cem\u003edata races\u003c/em\u003e are also a common source of \u003cem\u003edata corruption\u003c/em\u003e\nin concurrent applications resulting in dormant and hard-to-find bugs.\u003c/p\u003e\n\u003cp\u003eTo prevent \u003cem\u003edata races\u003c/em\u003e, the shared resource (usually memory) must be protected by obtaining mutual access to the data during both reading\nand writing. Such mutual exclusion is generally achieved by using a \u003cem\u003emutex\u003c/em\u003e, which is frequently referred to as a \u003cem\u003elock\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eA \u003cem\u003emutex\u003c/em\u003e has two states: \u003cem\u003ereleased\u003c/em\u003e - which is the initial state, or \u003cem\u003eacquired\u003c/em\u003e. These two states are frequently called\n\u003cem\u003eunlocked\u003c/em\u003e and \u003cem\u003elocked\u003c/em\u003e as well.\u003c/p\u003e\n\u003cp\u003eTo effectively protect the shared resource from concurrent accesses, all such accesses should be guarded by the same \u003cem\u003emutex\u003c/em\u003e. They need to\n\u003cem\u003elock\u003c/em\u003e the \u003cem\u003emutex\u003c/em\u003e to gain \u003cem\u003esafe\u003c/em\u003e exclusive access to the resource and \u003cem\u003eunlock\u003c/em\u003e it after they are done mutating or reading\nit.\u003c/p\u003e\n\u003cp\u003eYou can abstract away the concurrent threads sharing the mutex and think of it as owned by the current thread. It never spontaneously changes\nbetween \u003cem\u003eacquired\u003c/em\u003e and \u003cem\u003ereleased\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eIn this view, these are the possible transitions when calling \u003ccode\u003elock\u003c/code\u003e or \u003ccode\u003eunlock\u003c/code\u003e on a \u003cem\u003emutex\u003c/em\u003e in a given state:\u003c/p\u003e\n\u003col\u003e\n  \u003cli\u003e \u003cem\u003ereleased\u003c/em\u003e + \u003ccode\u003elock()\u003c/code\u003e ⇒ \u003cem\u003eacquired\u003c/em\u003e \u003c/li\u003e\n  \u003cli\u003e \u003cem\u003eacquired\u003c/em\u003e + \u003ccode\u003eunlock()\u003c/code\u003e ⇒ \u003cem\u003ereleased\u003c/em\u003e \u003c/li\u003e\n  \u003cli\u003e \u003cem\u003eacquired\u003c/em\u003e + \u003ccode\u003elock()\u003c/code\u003e ⇒ \u003cem\u003edeadlock\u003c/em\u003e \u003c/li\u003e\n  \u003cli\u003e \u003cem\u003ereleased\u003c/em\u003e + \u003ccode\u003eunlock()\u003c/code\u003e ⇒ \u003cem\u003eundefined behavior\u003c/em\u003e \u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eWhen a thread locks a mutex, another thread trying to \u003cem\u003eacquire\u003c/em\u003e the same mutex will be \u003cem\u003eblocked\u003c/em\u003e and have to wait for the first\nthread to \u003cem\u003erelease\u003c/em\u003e it. This waiting period can take some time. If a thread attempts to lock a mutex it has already acquired, it will\n\u003cem\u003edeadlock\u003c/em\u003e because it would need to release it to lock it again.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eLocking an \u003cem\u003eacquired\u003c/em\u003e mutex leads to a \u003cem\u003edeadlock\u003c/em\u003e, as a mutex can only be obtained once. Unlocking a \u003cem\u003ereleased\u003c/em\u003e mutex is\n\u003cem\u003eundefined behavior\u003c/em\u003e. Removing synchronization can cause \u003cem\u003edata races\u003c/em\u003e, leading to \u003cem\u003edata corruption\u003c/em\u003e, which adversaries might\nleverage to take over the system.\u003c/p\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThere are \u003cem\u003erecursive mutexes\u003c/em\u003e that can be \u003cem\u003eacquired\u003c/em\u003e multiple times by the same thread, given that just as many times we also\n\u003cem\u003erelease\u003c/em\u003e the \u003cem\u003emutex\u003c/em\u003e. They are rare in practice and usually signal design problems in the code. Thus we assume\n\u003ccode\u003epthread_mutex_t\u003c/code\u003e refers to \u003cem\u003enon-recursive\u003c/em\u003e mutexes.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eNever lock an \u003cem\u003eacquired\u003c/em\u003e mutex. Lock the mutexes in a strict order that is followed throughout the project. Unlock operations should be done\nthe same way but in reversed order.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;pthread.h\u0026gt;\n\npthread_mutex_t m1 \u003d PTHREAD_MUTEX_INITIALIZER;\npthread_mutex_t m2 \u003d PTHREAD_MUTEX_INITIALIZER;\n\nvoid locks() {\n  pthread_mutex_lock(\u0026amp;m1);\n  pthread_mutex_lock(\u0026amp;m1); // Noncompliant: \u0027m1\u0027 is already acquired\n}\n\nvoid unlocks() {\n  pthread_mutex_unlock(\u0026amp;m1);\n  pthread_mutex_unlock(\u0026amp;m1); // Noncompliant: \u0027m1\u0027 is already released\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;pthread.h\u0026gt;\n\npthread_mutex_t m1 \u003d PTHREAD_MUTEX_INITIALIZER;\npthread_mutex_t m2 \u003d PTHREAD_MUTEX_INITIALIZER;\n\nvoid locks() {\n  pthread_mutex_lock(\u0026amp;m1);\n  pthread_mutex_lock(\u0026amp;m2); // Compliant: we acquired both \u0027m1\u0027 and \u0027m2\u0027 for the first time.\n}\n\nvoid unlocks() {\n  pthread_mutex_unlock(\u0026amp;m2);\n  pthread_mutex_unlock(\u0026amp;m1); // Compliant: we released both \u0027m1\u0027 and \u0027m2\u0027 for the first time.\n}\n\u003c/pre\u003e\n\u003ch3\u003ePitfalls\u003c/h3\u003e\n\u003cp\u003eCalling arbitrary functions while holding a lock should be avoided, as the function might also want to lock the resource we already acquired,\ncausing a deadlock. One particular example of such functions is callbacks.\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;pthread.h\u0026gt;\n\npthread_mutex_t m \u003d PTHREAD_MUTEX_INITIALIZER;\n\nvoid handle_callback(void (*callback)(void)) {\n  pthread_mutex_lock(\u0026amp;m);\n  callback(); // If tries to lock mutex \u0027m\u0027, then we have a deadlock.\n  pthread_mutex_unlock(\u0026amp;m);\n}\n\u003c/pre\u003e\n\u003ch3\u003eGoing the extra mile\u003c/h3\u003e\n\u003cp\u003eThe section of code for which the \u003cem\u003emutex\u003c/em\u003e is \u003cem\u003eacquired\u003c/em\u003e is called the \u003cem\u003ecritical section\u003c/em\u003e. Inside the \u003cem\u003ecritical\nsection\u003c/em\u003e, we are the only ones with access to the shared resource. Thus we are free to mutate or read it without considering what other threads\nare doing concurrently. However, having large \u003cem\u003ecritical sections\u003c/em\u003e can prevent other threads from making progress if they want to also\n\u003cem\u003eacquire\u003c/em\u003e the same \u003cem\u003emutex\u003c/em\u003e and access the shared resource. Consequently, \u003cem\u003ecritical sections\u003c/em\u003e are supposed to be as small as\npossible.\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;pthread.h\u0026gt;\n#include \u0026lt;stdbool.h\u0026gt;\n\nint input;\nint result;\nbool isFib;\n\n// Guards both \u0027num1\u0027 and \u0027num2\u0027.\npthread_mutex_t m \u003d PTHREAD_MUTEX_INITIALIZER;\n\nint fibonacci(int n);\nint factorial(int n);\n\nvoid locks(bool calcFib, int n) {\n  // Do the calculations without taking the lock.\n  int res;\n  if (calcFib) {\n    res \u003d fibonacci(n);\n  } else {\n    res \u003d factorial(n);\n  }\n\n  pthread_mutex_lock(\u0026amp;m);\n  // Critical section starts\n  input \u003d n;\n  result \u003d res;\n  isFib \u003d calcFib;\n  // Critical section ends.\n  pthread_mutex_unlock(\u0026amp;m);\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/764\"\u003e764 Multiple Locks of a Critical Resource\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/362\"\u003e362 Multiple Concurrent Execution using Shared Resource with Improper\n  Synchronization (\u0027Race Condition\u0027)\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:c:S5487} enforces proper initialization and destruction of \u003ccode\u003epthread\u003c/code\u003e mutexes. \u003c/li\u003e\n  \u003cli\u003e {rule:c:S5489} enforces unlocking held \u003ccode\u003epthread\u003c/code\u003e mutexes in reverse order. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e The Open Group - \u003ca href\u003d\"https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_mutex_init.html\"\u003e\u003ccode\u003epthread_mutex_init\u003c/code\u003e,\n  \u003ccode\u003epthread_mutex_destroy\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e The Open Group - \u003ca href\u003d\"https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_mutex_lock.html\"\u003e\u003ccode\u003epthread_mutex_lock\u003c/code\u003e,\n  \u003ccode\u003epthread_mutex_unlock\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "cwe",
      "multi-threading",
      "symbolic-execution"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S5487",
    "name": "\"pthread_mutex_t\" should be properly initialized and destroyed",
    "defaultSeverity": "BLOCKER",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003cp\u003eFailing to properly initialize or destroy a \u003ccode\u003epthread\u003c/code\u003e mutex can lead to undefined behavior.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cem\u003eMutexes\u003c/em\u003e are synchronization primitives that allow managing concurrency.\u003c/p\u003e\n\u003cp\u003eTheir use requires following a well-defined life cycle:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003cem\u003eMutexes\u003c/em\u003e need to be initialized (using \u003ccode\u003epthread_mutex_init\u003c/code\u003e) before being used. Once it is initialized, a \u003cem\u003emutex\u003c/em\u003e is\n  in an \u003cem\u003eunlocked\u003c/em\u003e state. \u003c/li\u003e\n  \u003cli\u003e \u003cem\u003eMutexes\u003c/em\u003e need to be destroyed (using \u003ccode\u003epthread_mutex_destroy\u003c/code\u003e) to free the associated internal resources. Only\n  \u003cem\u003eunlocked\u003c/em\u003e \u003cem\u003emutexes\u003c/em\u003e can be safely destroyed. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eBefore initialization and after destruction, a mutex is in an uninitialized state.\u003c/p\u003e\n\u003cp\u003eDuring a \u003cem\u003emutex\u003c/em\u003e\u0027 life cycle, the following patterns should be avoided as they result in undefined behavior:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e trying to initialize an already initialized \u003cem\u003emutex\u003c/em\u003e \u003c/li\u003e\n  \u003cli\u003e trying to destroy an initialized \u003cem\u003emutex\u003c/em\u003e that is in a \u003cem\u003elocked\u003c/em\u003e state \u003c/li\u003e\n  \u003cli\u003e trying to destroy an uninitialized \u003cem\u003emutex\u003c/em\u003e \u003c/li\u003e\n  \u003cli\u003e trying to lock an uninitialized \u003cem\u003emutex\u003c/em\u003e \u003c/li\u003e\n  \u003cli\u003e trying to unlock an uninitialized \u003cem\u003emutex\u003c/em\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn C++11 and higher, \u003ccode\u003estd::mutex\u003c/code\u003e is less error-prone and is supported by more platforms.\u003c/p\u003e\n\u003cp\u003eIn C++03, it is recommended to wrap mutex creation/destruction in an RAII class, as well as mutex lock/unlock. Those RAII classes will perform the\nright operations, even in the presence of exceptions.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eFailing to properly initialize or destroy a POSIX Thread Mutex leads to \u003cstrong\u003eundefined behavior\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eFor programs that exercise undefined behavior, the compiler is no longer bound by the language specification. The application may crash or, even\nworse, the application may appear to execute correctly while losing data or producing incorrect results. In a multi-threaded context, additionally,\nthe application may experience spurious deadlocks or data races.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eEnsure that all mutexes follow the well-defined life cycle.\u003c/p\u003e\n\u003cp\u003eIf C++11 (or higher) is available, use \u003ccode\u003estd::mutex\u003c/code\u003e and \u003ccode\u003estd::lock_guard\u003c/code\u003e, instead, to avoid invalid usage patterns that lead\nto undefined behavior. Depending on the scenario, \u003ccode\u003estd::atomic\u003c/code\u003e may be used as an alternative if only small and primitive data shall be\nmodified in a concurrent context and in a synchronized manner.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre\u003e\n#include \u0026lt;pthread.h\u0026gt;\n\npthread_mutex_t mtx;\n\nvoid double_initialization(void)\n{\n  pthread_mutex_init(\u0026amp;mtx, /*mutex attribute\u003d*/NULL); // Initializes the mutex using an implementation-defined default attribute.\n  pthread_mutex_init(\u0026amp;mtx, /*mutex attribute\u003d*/NULL); // Noncompliant: initializing an already initialized mutex\n}\n\nvoid destroy_locked(void)\n{\n  pthread_mutex_init(\u0026amp;mtx, /*mutex attribute\u003d*/NULL);\n  pthread_mutex_lock(\u0026amp;mtx);\n  pthread_mutex_destroy(\u0026amp;mtx); // Noncompliant: destroying a locked mutex\n}\n\nvoid double_destruction(void)\n{\n  pthread_mutex_init(\u0026amp;mtx, /*mutex attribute\u003d*/NULL);\n  pthread_mutex_destroy(\u0026amp;mtx);\n  pthread_mutex_destroy(\u0026amp;mtx); // Noncompliant: destroying an uninitialized mutex\n}\n\nvoid lock_destroyed(void)\n{\n  pthread_mutex_init(\u0026amp;mtx, /*mutex attribute\u003d*/NULL);\n  pthread_mutex_destroy(\u0026amp;mtx);\n  pthread_mutex_lock(\u0026amp;mtx); // Noncompliant: locking an uninitialized mutex\n}\n\nvoid unlock_destroyed(void)\n{\n  pthread_mutex_init(\u0026amp;mtx, /*mutex attribute\u003d*/NULL);\n  pthread_mutex_destroy(\u0026amp;mtx);\n  pthread_mutex_unlock(\u0026amp;mtx); // Noncompliant: unlocking an uninitialized mutex\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eC solution:\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;pthread.h\u0026gt;\n\npthread_mutex_t mtx;\n\nvoid destroy_initialized(void)\n{\n  pthread_mutex_init(\u0026amp;mtx, /*mutex attribute\u003d*/NULL);\n  pthread_mutex_destroy(\u0026amp;mtx);\n}\n\nvoid use_and_destroy_initialized(void)\n{\n  pthread_mutex_init(\u0026amp;mtx, /*mutex attribute\u003d*/NULL);\n  pthread_mutex_lock(\u0026amp;mtx);\n  // Critical code that processes a shared resource (e.g. memory).\n  pthread_mutex_unlock(\u0026amp;mtx);\n  pthread_mutex_destroy(\u0026amp;mtx);\n}\n\u003c/pre\u003e\n\u003cp\u003eFor static mutex variables:\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;pthread.h\u0026gt;\n\npthread_mutex_t mtx \u003d PTHREAD_MUTEX_INITIALIZER;\n\nvoid use_statically_initialized(void)\n{\n  pthread_mutex_lock(\u0026amp;mtx); // Compliant: mutex is initialized statically\n  // Critical code that processes a shared resource (e.g. memory).\n  pthread_mutex_unlock(\u0026amp;mtx);\n}\n\u003c/pre\u003e\n\u003cp\u003eC++11 and higher solution:\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;mutex\u0026gt;\n#include \u0026lt;stdexcept\u0026gt;\n\nstd::mutex mtx;\n\nvoid use_lock_guard(bool condition) {\n  std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mtx);\n  // Critical code that processes a shared resource (e.g. memory).\n  if (condition) {\n    // Compliant: mutex will unlock automatically even in case of an exception\n    throw std::invalid_argument(\"Expected false\");\n  }\n  // Compliant: mutex will unlock automatically at the end of the scope\n}\n\u003c/pre\u003e\n\u003cp\u003eC++03 solution:\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;pthread.h\u0026gt;\n\npthread_mutex_t mtx;\n\nclass Mutex {\npublic:\n  Mutex(pthread_mutex_t* mtx) : pmtx(mtx) {\n    pthread_mutex_init(pmtx, /*mutex attribute\u003d*/NULL);\n  }\n  ~Mutex() {\n    pthread_mutex_destroy(pmtx);\n  }\n  pthread_mutex_t* pmtx;\nprivate:\n  // Disallow copy operations to avoid double-free issues.\n  Mutex(Mutex const\u0026amp; other);\n  Mutex\u0026amp; operator\u003d(Mutex const\u0026amp; other);\n};\n\nstruct LockGuard {\n  LockGuard(Mutex \u0026amp;m) : mtx(m) {\n    pthread_mutex_lock(mtx.pmtx);\n  }\n  ~LockGuard() {\n    pthread_mutex_unlock(mtx.pmtx);\n  }\n  Mutex \u0026amp;mtx;\n};\n\nvoid destroy_initialized()\n{\n  Mutex m(\u0026amp;mtx);\n  // Compliant: mtx will be properly initialized and destroyed\n}\n\nvoid use_and_destroy_initialized()\n{\n  Mutex m(\u0026amp;mtx);\n  {\n    LockGuard lock(m);\n    // Critical code that processes a shared resource (e.g. memory).\n    // Compliant: mutex will unlock automatically at the end of the scope\n  }\n  // Compliant: mtx will be destroyed properly\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e The Open Group - \u003ca href\u003d\"https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_mutex_init.html\"\u003e\u003ccode\u003epthread_mutex_init\u003c/code\u003e,\n  \u003ccode\u003epthread_mutex_destroy\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/atomic/atomic\"\u003e\u003ccode\u003estd::atomic\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/thread/lock_guard\"\u003e\u003ccode\u003estd::lock_guard\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/thread/mutex\"\u003e\u003ccode\u003estd::mutex\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eConference presentations\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CppCon 2020 - \u003ca href\u003d\"https://youtu.be/A7sVFJLJM-A?si\u003dv76jhmv3XnHExZYU\"\u003eAn Introduction to Multithreading in C++20\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:c:S5486} enforces the proper locking and unlocking of \u003ccode\u003epthread\u003c/code\u003e mutexes. \u003c/li\u003e\n  \u003cli\u003e {rule:c:S5489} enforces unlocking multiple held \u003ccode\u003epthread\u003c/code\u003e mutexes in reverse order. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eFailing to properly initialize or destroy a \u003ccode\u003epthread\u003c/code\u003e mutex can lead to undefined behavior.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cem\u003eMutexes\u003c/em\u003e are synchronization primitives that allow managing concurrency.\u003c/p\u003e\n\u003cp\u003eTheir use requires following a well-defined life cycle:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003cem\u003eMutexes\u003c/em\u003e need to be initialized (using \u003ccode\u003epthread_mutex_init\u003c/code\u003e) before being used. Once it is initialized, a \u003cem\u003emutex\u003c/em\u003e is\n  in an \u003cem\u003eunlocked\u003c/em\u003e state. \u003c/li\u003e\n  \u003cli\u003e \u003cem\u003eMutexes\u003c/em\u003e need to be destroyed (using \u003ccode\u003epthread_mutex_destroy\u003c/code\u003e) to free the associated internal resources. Only\n  \u003cem\u003eunlocked\u003c/em\u003e \u003cem\u003emutexes\u003c/em\u003e can be safely destroyed. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eBefore initialization and after destruction, a mutex is in an uninitialized state.\u003c/p\u003e\n\u003cp\u003eDuring a \u003cem\u003emutex\u003c/em\u003e\u0027 life cycle, the following patterns should be avoided as they result in undefined behavior:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e trying to initialize an already initialized \u003cem\u003emutex\u003c/em\u003e \u003c/li\u003e\n  \u003cli\u003e trying to destroy an initialized \u003cem\u003emutex\u003c/em\u003e that is in a \u003cem\u003elocked\u003c/em\u003e state \u003c/li\u003e\n  \u003cli\u003e trying to destroy an uninitialized \u003cem\u003emutex\u003c/em\u003e \u003c/li\u003e\n  \u003cli\u003e trying to lock an uninitialized \u003cem\u003emutex\u003c/em\u003e \u003c/li\u003e\n  \u003cli\u003e trying to unlock an uninitialized \u003cem\u003emutex\u003c/em\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn C++11 and higher, \u003ccode\u003estd::mutex\u003c/code\u003e is less error-prone and is supported by more platforms.\u003c/p\u003e\n\u003cp\u003eIn C++03, it is recommended to wrap mutex creation/destruction in an RAII class, as well as mutex lock/unlock. Those RAII classes will perform the\nright operations, even in the presence of exceptions.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eFailing to properly initialize or destroy a POSIX Thread Mutex leads to \u003cstrong\u003eundefined behavior\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eFor programs that exercise undefined behavior, the compiler is no longer bound by the language specification. The application may crash or, even\nworse, the application may appear to execute correctly while losing data or producing incorrect results. In a multi-threaded context, additionally,\nthe application may experience spurious deadlocks or data races.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eEnsure that all mutexes follow the well-defined life cycle.\u003c/p\u003e\n\u003cp\u003eIf C++11 (or higher) is available, use \u003ccode\u003estd::mutex\u003c/code\u003e and \u003ccode\u003estd::lock_guard\u003c/code\u003e, instead, to avoid invalid usage patterns that lead\nto undefined behavior. Depending on the scenario, \u003ccode\u003estd::atomic\u003c/code\u003e may be used as an alternative if only small and primitive data shall be\nmodified in a concurrent context and in a synchronized manner.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre\u003e\n#include \u0026lt;pthread.h\u0026gt;\n\npthread_mutex_t mtx;\n\nvoid double_initialization(void)\n{\n  pthread_mutex_init(\u0026amp;mtx, /*mutex attribute\u003d*/NULL); // Initializes the mutex using an implementation-defined default attribute.\n  pthread_mutex_init(\u0026amp;mtx, /*mutex attribute\u003d*/NULL); // Noncompliant: initializing an already initialized mutex\n}\n\nvoid destroy_locked(void)\n{\n  pthread_mutex_init(\u0026amp;mtx, /*mutex attribute\u003d*/NULL);\n  pthread_mutex_lock(\u0026amp;mtx);\n  pthread_mutex_destroy(\u0026amp;mtx); // Noncompliant: destroying a locked mutex\n}\n\nvoid double_destruction(void)\n{\n  pthread_mutex_init(\u0026amp;mtx, /*mutex attribute\u003d*/NULL);\n  pthread_mutex_destroy(\u0026amp;mtx);\n  pthread_mutex_destroy(\u0026amp;mtx); // Noncompliant: destroying an uninitialized mutex\n}\n\nvoid lock_destroyed(void)\n{\n  pthread_mutex_init(\u0026amp;mtx, /*mutex attribute\u003d*/NULL);\n  pthread_mutex_destroy(\u0026amp;mtx);\n  pthread_mutex_lock(\u0026amp;mtx); // Noncompliant: locking an uninitialized mutex\n}\n\nvoid unlock_destroyed(void)\n{\n  pthread_mutex_init(\u0026amp;mtx, /*mutex attribute\u003d*/NULL);\n  pthread_mutex_destroy(\u0026amp;mtx);\n  pthread_mutex_unlock(\u0026amp;mtx); // Noncompliant: unlocking an uninitialized mutex\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eC solution:\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;pthread.h\u0026gt;\n\npthread_mutex_t mtx;\n\nvoid destroy_initialized(void)\n{\n  pthread_mutex_init(\u0026amp;mtx, /*mutex attribute\u003d*/NULL);\n  pthread_mutex_destroy(\u0026amp;mtx);\n}\n\nvoid use_and_destroy_initialized(void)\n{\n  pthread_mutex_init(\u0026amp;mtx, /*mutex attribute\u003d*/NULL);\n  pthread_mutex_lock(\u0026amp;mtx);\n  // Critical code that processes a shared resource (e.g. memory).\n  pthread_mutex_unlock(\u0026amp;mtx);\n  pthread_mutex_destroy(\u0026amp;mtx);\n}\n\u003c/pre\u003e\n\u003cp\u003eFor static mutex variables:\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;pthread.h\u0026gt;\n\npthread_mutex_t mtx \u003d PTHREAD_MUTEX_INITIALIZER;\n\nvoid use_statically_initialized(void)\n{\n  pthread_mutex_lock(\u0026amp;mtx); // Compliant: mutex is initialized statically\n  // Critical code that processes a shared resource (e.g. memory).\n  pthread_mutex_unlock(\u0026amp;mtx);\n}\n\u003c/pre\u003e\n\u003cp\u003eC++11 and higher solution:\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;mutex\u0026gt;\n#include \u0026lt;stdexcept\u0026gt;\n\nstd::mutex mtx;\n\nvoid use_lock_guard(bool condition) {\n  std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mtx);\n  // Critical code that processes a shared resource (e.g. memory).\n  if (condition) {\n    // Compliant: mutex will unlock automatically even in case of an exception\n    throw std::invalid_argument(\"Expected false\");\n  }\n  // Compliant: mutex will unlock automatically at the end of the scope\n}\n\u003c/pre\u003e\n\u003cp\u003eC++03 solution:\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;pthread.h\u0026gt;\n\npthread_mutex_t mtx;\n\nclass Mutex {\npublic:\n  Mutex(pthread_mutex_t* mtx) : pmtx(mtx) {\n    pthread_mutex_init(pmtx, /*mutex attribute\u003d*/NULL);\n  }\n  ~Mutex() {\n    pthread_mutex_destroy(pmtx);\n  }\n  pthread_mutex_t* pmtx;\nprivate:\n  // Disallow copy operations to avoid double-free issues.\n  Mutex(Mutex const\u0026amp; other);\n  Mutex\u0026amp; operator\u003d(Mutex const\u0026amp; other);\n};\n\nstruct LockGuard {\n  LockGuard(Mutex \u0026amp;m) : mtx(m) {\n    pthread_mutex_lock(mtx.pmtx);\n  }\n  ~LockGuard() {\n    pthread_mutex_unlock(mtx.pmtx);\n  }\n  Mutex \u0026amp;mtx;\n};\n\nvoid destroy_initialized()\n{\n  Mutex m(\u0026amp;mtx);\n  // Compliant: mtx will be properly initialized and destroyed\n}\n\nvoid use_and_destroy_initialized()\n{\n  Mutex m(\u0026amp;mtx);\n  {\n    LockGuard lock(m);\n    // Critical code that processes a shared resource (e.g. memory).\n    // Compliant: mutex will unlock automatically at the end of the scope\n  }\n  // Compliant: mtx will be destroyed properly\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e The Open Group - \u003ca href\u003d\"https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_mutex_init.html\"\u003e\u003ccode\u003epthread_mutex_init\u003c/code\u003e,\n  \u003ccode\u003epthread_mutex_destroy\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/atomic/atomic\"\u003e\u003ccode\u003estd::atomic\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/thread/lock_guard\"\u003e\u003ccode\u003estd::lock_guard\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/thread/mutex\"\u003e\u003ccode\u003estd::mutex\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eConference presentations\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CppCon 2020 - \u003ca href\u003d\"https://youtu.be/A7sVFJLJM-A?si\u003dv76jhmv3XnHExZYU\"\u003eAn Introduction to Multithreading in C++20\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:c:S5486} enforces the proper locking and unlocking of \u003ccode\u003epthread\u003c/code\u003e mutexes. \u003c/li\u003e\n  \u003cli\u003e {rule:c:S5489} enforces unlocking multiple held \u003ccode\u003epthread\u003c/code\u003e mutexes in reverse order. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "multi-threading",
      "symbolic-execution"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S5801",
    "name": "Using \"strcpy\" or \"wcscpy\" is security-sensitive",
    "defaultSeverity": "MAJOR",
    "type": "SECURITY_HOTSPOT",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "SECURITY": "MEDIUM"
    },
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eIn C, a string is just a buffer of characters, normally using the \u003ccode\u003enull\u003c/code\u003e character as a sentinel for the end of the string. This means\nthat the developer has to be aware of low-level details such as buffer sizes or having an extra character to store the final \u003ccode\u003enull\u003c/code\u003e\ncharacter. Doing that correctly and consistently is notoriously difficult and any error can lead to a security vulnerability, for instance, giving\naccess to sensitive data or allowing arbitrary code execution.\u003c/p\u003e\n\u003cp\u003eThe function \u003ccode\u003echar *strcpy(char * restrict dest, const char * restrict src);\u003c/code\u003e copies characters from \u003ccode\u003esrc\u003c/code\u003e to\n\u003ccode\u003edest\u003c/code\u003e. The \u003ccode\u003ewcscpy\u003c/code\u003e does the same for wide characters and should be used with the same guidelines.\u003c/p\u003e\n\u003cp\u003eNote: the functions \u003ccode\u003estrncpy\u003c/code\u003e and \u003ccode\u003ewcsncpy\u003c/code\u003e might look like attractive safe replacements for \u003ccode\u003estrcpy\u003c/code\u003e and\n\u003ccode\u003ewcscpy\u003c/code\u003e, but they have their own set of issues (see {rule:c:S5816}), and you should probably prefer another more adapted\nalternative.\u003c/p\u003e"
      },
      {
        "key": "assess_the_problem",
        "htmlContent": "\u003ch2\u003eAsk Yourself Whether\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e There is a possibility that either the source or the destination pointer is \u003ccode\u003enull\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e There is a possibility that the source string is not correctly \u003ccode\u003enull\u003c/code\u003e-terminated, or that its length (including the final\n  \u003ccode\u003enull\u003c/code\u003e character) can be larger than the size of the destination buffer. \u003c/li\u003e\n  \u003cli\u003e There is an overlap between source and destination \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere is a risk if you answered yes to any of those questions.\u003c/p\u003e\n\u003ch2\u003eSensitive Code Example\u003c/h2\u003e\n\u003cpre\u003e\nint f(char *src) {\n  char dest[256];\n  strcpy(dest, src); // Sensitive: might overflow\n  return doSomethingWith(dest);\n}\n\u003c/pre\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003ch2\u003eRecommended Secure Coding Practices\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C11 provides, in its annex K, the \u003ccode\u003estrcpy_s\u003c/code\u003e and the \u003ccode\u003ewcscpy_s\u003c/code\u003e that were designed as safer alternatives to\n  \u003ccode\u003estrcpy\u003c/code\u003e and \u003ccode\u003ewcscpy\u003c/code\u003e. It’s not recommended to use them in all circumstances, because they introduce a runtime overhead and\n  require to write more code for error handling, but they perform checks that will limit the consequences of calling the function with bad arguments.\n  \u003c/li\u003e\n  \u003cli\u003e Even if your compiler does not exactly support annex K, you probably have access to similar functions, for example, \u003ccode\u003estrlcpy\u003c/code\u003e in\n  FreeBSD \u003c/li\u003e\n  \u003cli\u003e If you are writing C++ code, using \u003ccode\u003estd::string\u003c/code\u003e to manipulate strings is much simpler and less error-prone \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eCompliant Solution\u003c/h2\u003e\n\u003cpre\u003e\nint f(char *src) {\n  char *dest \u003d malloc(strlen(src) + 1); // For the final 0\n  strcpy(dest, src); // Compliant: we made sure the buffer is large enough\n  int r\u003d doSomethingWith(dest);\n  free(dest);\n  return r;\n}\n\u003c/pre\u003e\n\u003ch2\u003eSee\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/Top10/A06_2021-Vulnerable_and_Outdated_Components/\"\u003eOWASP Top 10 2021 Category A6\u003c/a\u003e - Vulnerable and Outdated\n  Components \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/www-project-top-ten/2017/A9_2017-Using_Components_with_Known_Vulnerabilities\"\u003eOWASP Top 10 2017 Category A9\u003c/a\u003e -\n  Using Components with Known Vulnerabilities \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/120\"\u003eMITRE, CWE-120\u003c/a\u003e - Buffer Copy without Checking Size of Input (\u0027Classic Buffer\n  Overflow\u0027) \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/HdcxBQ\"\u003eCERT, STR07-C.\u003c/a\u003e - Use the bounds-checking interfaces for string manipulation \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "cert",
      "cwe"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": [],
    "vulnerabilityProbability": "HIGH"
  },
  {
    "key": "c:S3744",
    "name": "Macros should not be redefined",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eA macro definition should not be redefined without marking that intent specifically by un-defining it first.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#define A 1\n#define A 2\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#define A 1\n#undef A\n#define A 2\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eIf the redefinition has the same value as the original one. This is consistent with most C compilers warnings.\u003c/p\u003e\n\u003cpre\u003e\n#define A 1\n#define A 1\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eA macro definition should not be redefined without marking that intent specifically by un-defining it first.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#define A 1\n#define A 2\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#define A 1\n#undef A\n#define A 2\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eIf the redefinition has the same value as the original one. This is consistent with most C compilers warnings.\u003c/p\u003e\n\u003cpre\u003e\n#define A 1\n#define A 1\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "confusing"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S4263",
    "name": "Include directives should not rely on non-portable search strategy",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eMicrosoft’s MSVC has a search strategy which differs from other compilers when resolving quoted include directives \u003ccode\u003e#include \"file.h\"\u003c/code\u003e.\nRelying on such a strategy is not portable and may lead to compilation failure when trying to build with a different compiler.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue whenever the file specified in a \u003ccode\u003e#include\u003c/code\u003e directive can only be found using the MSVC search strategy.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e Microsoft Learn - \u003ca href\u003d\"https://learn.microsoft.com/en-us/cpp/preprocessor/hash-include-directive-c-cpp\"\u003e\u003ccode\u003e#include\u003c/code\u003e directive\n  (C/C++)\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eMicrosoft’s MSVC has a search strategy which differs from other compilers when resolving quoted include directives \u003ccode\u003e#include \"file.h\"\u003c/code\u003e.\nRelying on such a strategy is not portable and may lead to compilation failure when trying to build with a different compiler.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue whenever the file specified in a \u003ccode\u003e#include\u003c/code\u003e directive can only be found using the MSVC search strategy.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e Microsoft Learn - \u003ca href\u003d\"https://learn.microsoft.com/en-us/cpp/preprocessor/hash-include-directive-c-cpp\"\u003e\u003ccode\u003e#include\u003c/code\u003e directive\n  (C/C++)\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S4143",
    "name": "Array values should not be replaced unconditionally",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eStoring a value inside a collection at a given key or index and then unconditionally overwriting it without reading the initial value is a case of\na \"dead store\".\u003c/p\u003e\n\u003cpre\u003e\ntowns[i] \u003d \"London\";\ntowns[i] \u003d \"Chicago\";  // Noncompliant: We never used the previous value\n\u003c/pre\u003e\n\u003cp\u003eThis practice is redundant and will cause confusion for the reader. More importantly, it is often an error and not what the developer intended to\ndo.\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eStoring a value inside a collection at a given key or index and then unconditionally overwriting it without reading the initial value is a case of\na \"dead store\".\u003c/p\u003e\n\u003cpre\u003e\ntowns[i] \u003d \"London\";\ntowns[i] \u003d \"Chicago\";  // Noncompliant: We never used the previous value\n\u003c/pre\u003e\n\u003cp\u003eThis practice is redundant and will cause confusion for the reader. More importantly, it is often an error and not what the developer intended to\ndo.\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S6200",
    "name": "\"volatile\" should not be used to qualify objects for which the meaning is not defined",
    "defaultSeverity": "CRITICAL",
    "type": "BUG",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003evolatile\u003c/code\u003e can be used to qualify many objects in C and C++, but only a few of the possible places have a well-defined meaning (global\nvariables and local variables, for instance). There is no well-defined meaning to the use of volatile to qualify a function return type or a function\nparameter. Furthermore, for structured bindings, the volatile qualifier appertains to the decomposed object, which cannot be referred to. Since C++20,\nthese uses are deprecated, but even before you should not use volatile in those places.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue for a volatile qualified function return type, function parameter, and structured binding (available in C++ since\nC++17).\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint volatile f(int volatile i); // Noncompliant, both for the return type and the parameter\n\nvoid g() {\n  auto volatile [a, b] \u003d getPair(); // Noncompliant\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003ccode\u003evolatile\u003c/code\u003e can be used to qualify many objects in C and C++, but only a few of the possible places have a well-defined meaning (global\nvariables and local variables, for instance). There is no well-defined meaning to the use of volatile to qualify a function return type or a function\nparameter. Furthermore, for structured bindings, the volatile qualifier appertains to the decomposed object, which cannot be referred to. Since C++20,\nthese uses are deprecated, but even before you should not use volatile in those places.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue for a volatile qualified function return type, function parameter, and structured binding (available in C++ since\nC++17).\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint volatile f(int volatile i); // Noncompliant, both for the return type and the parameter\n\nvoid g() {\n  auto volatile [a, b] \u003d getPair(); // Noncompliant\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S886",
    "name": "The three expressions of a \"for\" statement should only be concerned with loop control",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003efor\u003c/code\u003e loops are very flexible in C and C++. Because of that, they can carry a complexity that can make the code error-prone, difficult\nto understand, and hard to maintain.\u003c/p\u003e\n\u003cp\u003eMany for loops can be written in a way that clearly separates the iteration process from the content of the iteration. This rule makes sure that\nall the code relevant to the iteration is placed in the for-loop header. The compliant code is then easier to reason about.\u003c/p\u003e\n\u003cp\u003eA for loop is composed of 4 sub-parts:\u003c/p\u003e\n\u003cpre\u003e\nfor([initialization]; [condition]; [update])\n  [body]\n\u003c/pre\u003e\n\u003cp\u003eWe classify the variables used to control them in three categories:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e A \u003cem\u003eloop-counter\u003c/em\u003e is a variable modified in the update. It should not be modified in the body. \u003c/li\u003e\n  \u003cli\u003e A \u003cem\u003eloop-constant\u003c/em\u003e is an auxiliary variable declared in the initialization. It’s very often used to precompute some data about the end\n  condition or the stride. \u003c/li\u003e\n  \u003cli\u003e A \u003cem\u003epseudo-counter\u003c/em\u003e shares some properties with a loop counter, but its update conditions are more complex. It will therefore only be\n  updated in the body, and cannot be used in the update. Using a pseudo-counter makes the loop more complex to reason about, and therefore is not\n  permitted. They are very often declared in the initialization, for instance, to limit their scope, but in some cases reuse existing variables. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eAdditionally, the loop condition should refer to at least one \u003cem\u003eloop-counter\u003c/em\u003e, and should not modify anything.\u003c/p\u003e\n\u003cp\u003eThis rule is only checking for loops with a condition and an update.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nfor( int h \u003d 0, int i \u003d 0 ; h \u0026lt; 10 ; i +\u003d 1 ) { // Noncompliant, the loop-counter is not used in the condition\n}\n\nfor( int i \u003d 0 ; i++ \u0026lt; 10 ; i +\u003d 1 ) { // Noncompliant, loop-counter i is updated in the condition\n}\n\nfor( int i \u003d 0 , int h \u003d 0; i+(++h) \u0026lt; 10 ; i +\u003d 1 ) { // Noncompliant, pseudo-counter h is updated in the condition\n}\n\nfor( int i \u003d 0 ; i \u0026lt; 10 ; i +\u003d 1 ) { // Noncompliant, loop-counter i is updated in the body\n  if (i%2)  { ++i;}\n}\n\nfor( int i \u003d 0 , j \u003d 0 ; i \u0026lt; 10 ; i +\u003d j) { // Noncompliant, pseudo-counter j is is used in the update\n  j \u003d i + 1;\n}\n\nfor( int i \u003d 0 , j \u003d 0 ; i \u0026lt; 10 + j ; i +\u003d 1) { // Noncompliant, pseudo-counter j is is used in the condition\n  j \u003d i + 1;\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 13.5 - The three expressions of a for statement shall be concerned only with loop control. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 6-5-5 - A \u003cem\u003eloop-control-variable\u003c/em\u003e other than the \u003cem\u003eloop-counter\u003c/em\u003e shall not be modified within \u003cem\u003econdition\u003c/em\u003e\n  or \u003cem\u003eexpression\u003c/em\u003e. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 14.2 - A for loop shall be well-formed \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003ccode\u003efor\u003c/code\u003e loops are very flexible in C and C++. Because of that, they can carry a complexity that can make the code error-prone, difficult\nto understand, and hard to maintain.\u003c/p\u003e\n\u003cp\u003eMany for loops can be written in a way that clearly separates the iteration process from the content of the iteration. This rule makes sure that\nall the code relevant to the iteration is placed in the for-loop header. The compliant code is then easier to reason about.\u003c/p\u003e\n\u003cp\u003eA for loop is composed of 4 sub-parts:\u003c/p\u003e\n\u003cpre\u003e\nfor([initialization]; [condition]; [update])\n  [body]\n\u003c/pre\u003e\n\u003cp\u003eWe classify the variables used to control them in three categories:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e A \u003cem\u003eloop-counter\u003c/em\u003e is a variable modified in the update. It should not be modified in the body. \u003c/li\u003e\n  \u003cli\u003e A \u003cem\u003eloop-constant\u003c/em\u003e is an auxiliary variable declared in the initialization. It’s very often used to precompute some data about the end\n  condition or the stride. \u003c/li\u003e\n  \u003cli\u003e A \u003cem\u003epseudo-counter\u003c/em\u003e shares some properties with a loop counter, but its update conditions are more complex. It will therefore only be\n  updated in the body, and cannot be used in the update. Using a pseudo-counter makes the loop more complex to reason about, and therefore is not\n  permitted. They are very often declared in the initialization, for instance, to limit their scope, but in some cases reuse existing variables. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eAdditionally, the loop condition should refer to at least one \u003cem\u003eloop-counter\u003c/em\u003e, and should not modify anything.\u003c/p\u003e\n\u003cp\u003eThis rule is only checking for loops with a condition and an update.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nfor( int h \u003d 0, int i \u003d 0 ; h \u0026lt; 10 ; i +\u003d 1 ) { // Noncompliant, the loop-counter is not used in the condition\n}\n\nfor( int i \u003d 0 ; i++ \u0026lt; 10 ; i +\u003d 1 ) { // Noncompliant, loop-counter i is updated in the condition\n}\n\nfor( int i \u003d 0 , int h \u003d 0; i+(++h) \u0026lt; 10 ; i +\u003d 1 ) { // Noncompliant, pseudo-counter h is updated in the condition\n}\n\nfor( int i \u003d 0 ; i \u0026lt; 10 ; i +\u003d 1 ) { // Noncompliant, loop-counter i is updated in the body\n  if (i%2)  { ++i;}\n}\n\nfor( int i \u003d 0 , j \u003d 0 ; i \u0026lt; 10 ; i +\u003d j) { // Noncompliant, pseudo-counter j is is used in the update\n  j \u003d i + 1;\n}\n\nfor( int i \u003d 0 , j \u003d 0 ; i \u0026lt; 10 + j ; i +\u003d 1) { // Noncompliant, pseudo-counter j is is used in the condition\n  j \u003d i + 1;\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 13.5 - The three expressions of a for statement shall be concerned only with loop control. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 6-5-5 - A \u003cem\u003eloop-control-variable\u003c/em\u003e other than the \u003cem\u003eloop-counter\u003c/em\u003e shall not be modified within \u003cem\u003econdition\u003c/em\u003e\n  or \u003cem\u003eexpression\u003c/em\u003e. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 14.2 - A for loop shall be well-formed \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "based-on-misra"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S5350",
    "name": "Pointer and reference local variables should be \"const\" if the corresponding object is not modified",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThis rule leads to greater precision in the definition of local variables by making the developer intention about modifying the variable explicit.\nThe \u003ccode\u003econst\u003c/code\u003e qualification shall be applied to the object pointed to, not to the pointer, since it is the object itself that is being\nprotected.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstd::string\u0026amp; getString();\nvoid myfunc()\n{\n  std::string\u0026amp; s \u003d getString(); // Noncompliant\n  if (s.size()) {\n   std::cout \u0026lt;\u0026lt; s;\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstd::string\u0026amp; getString();\nvoid myfunc () {\n  const std::string\u0026amp; x \u003d getString();\n  if (s.size()) {\n    std::cout \u0026lt;\u0026lt; s;\n  }\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThis rule leads to greater precision in the definition of local variables by making the developer intention about modifying the variable explicit.\nThe \u003ccode\u003econst\u003c/code\u003e qualification shall be applied to the object pointed to, not to the pointer, since it is the object itself that is being\nprotected.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstd::string\u0026amp; getString();\nvoid myfunc()\n{\n  std::string\u0026amp; s \u003d getString(); // Noncompliant\n  if (s.size()) {\n   std::cout \u0026lt;\u0026lt; s;\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstd::string\u0026amp; getString();\nvoid myfunc () {\n  const std::string\u0026amp; x \u003d getString();\n  if (s.size()) {\n    std::cout \u0026lt;\u0026lt; s;\n  }\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "bad-practice",
      "based-on-misra"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S883",
    "name": "Tests of non-Boolean values against zero should be explicit",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhere a data value is to be tested against zero then the test should be made explicit. The exception to this rule is when data represents a Boolean\nvalue, even though in C this will in practice be an integer.\u003c/p\u003e\n\u003cp\u003eThis rule is in the interests of clarity, and makes clear the distinction between integers and logical values.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nif ( x ) // Noncompliant, unless x is effectively Boolean data\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nif ( x \u003d\u003d 0) // Compliant solution\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 13.2 - Tests of a value against zero should be made explicit, unless the operand is effectively Boolean. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhere a data value is to be tested against zero then the test should be made explicit. The exception to this rule is when data represents a Boolean\nvalue, even though in C this will in practice be an integer.\u003c/p\u003e\n\u003cp\u003eThis rule is in the interests of clarity, and makes clear the distinction between integers and logical values.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nif ( x ) // Noncompliant, unless x is effectively Boolean data\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nif ( x \u003d\u003d 0) // Compliant solution\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 13.2 - Tests of a value against zero should be made explicit, unless the operand is effectively Boolean. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "based-on-misra"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:M23_112",
    "name": "All \"if ... else if\" constructs shall be terminated with an \"else\" statement",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 9.4.1\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eA final \u003ccode\u003eelse\u003c/code\u003e shall always be provided whenever an \u003ccode\u003eif\u003c/code\u003e statement is followed by a sequence of one or more \u003ccode\u003eelse\nif\u003c/code\u003e constructs.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e a final \u003ccode\u003eelse\u003c/code\u003e statement is not required for a simple \u003ccode\u003eif\u003c/code\u003e statement.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eTerminating a sequence of \u003ccode\u003eif ... else if\u003c/code\u003e constructs with an \u003ccode\u003eelse\u003c/code\u003e statement is defensive programming, complementing the\nrequirement for a \u003ccode\u003edefault\u003c/code\u003e clause in a \u003ccode\u003eswitch\u003c/code\u003e statement (see MISRA C++ 2023 Rule\u0026nbsp;9.4.2 (The structure of a\n\u003ccode\u003eswitch\u003c/code\u003e statement shall be appropriate)).\u003c/p\u003e\n\u003cp\u003eThe addition of an \u003ccode\u003eelse\u003c/code\u003e statement, even when empty, indicates that consideration has been given regarding the behaviour when all other\nconditions evaluate to \u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nvoid f1( bool flag_1, bool flag_2 )\n{\n  if ( flag_1 )\n  {\n    action_1();\n  }\n  else if ( flag_2 )\n  {\n    action_2();\n  }                     // Non-compliant\n}\n\nvoid f2(bool flag_1, bool flag_2)\n{\n  if ( flag_1 )\n  {\n    action_1();\n  }\n  else if ( flag_2 )\n  {\n    action_2();\n  }\n  else                  // Compliant\n  {\n  }\n}\n\nvoid f3( bool flag )\n{\n  if ( flag )\n  {\n    action_1();\n  }                     // Simple \u0027if\u0027 - rule does not apply\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e S5307 targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2023 Rule\u0026nbsp;9.4.2 - The structure of a \u003ccode\u003eswitch\u003c/code\u003e statement shall be appropriate \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 9.4.1\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eA final \u003ccode\u003eelse\u003c/code\u003e shall always be provided whenever an \u003ccode\u003eif\u003c/code\u003e statement is followed by a sequence of one or more \u003ccode\u003eelse\nif\u003c/code\u003e constructs.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e a final \u003ccode\u003eelse\u003c/code\u003e statement is not required for a simple \u003ccode\u003eif\u003c/code\u003e statement.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eTerminating a sequence of \u003ccode\u003eif ... else if\u003c/code\u003e constructs with an \u003ccode\u003eelse\u003c/code\u003e statement is defensive programming, complementing the\nrequirement for a \u003ccode\u003edefault\u003c/code\u003e clause in a \u003ccode\u003eswitch\u003c/code\u003e statement (see MISRA C++ 2023 Rule\u0026nbsp;9.4.2 (The structure of a\n\u003ccode\u003eswitch\u003c/code\u003e statement shall be appropriate)).\u003c/p\u003e\n\u003cp\u003eThe addition of an \u003ccode\u003eelse\u003c/code\u003e statement, even when empty, indicates that consideration has been given regarding the behaviour when all other\nconditions evaluate to \u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nvoid f1( bool flag_1, bool flag_2 )\n{\n  if ( flag_1 )\n  {\n    action_1();\n  }\n  else if ( flag_2 )\n  {\n    action_2();\n  }                     // Non-compliant\n}\n\nvoid f2(bool flag_1, bool flag_2)\n{\n  if ( flag_1 )\n  {\n    action_1();\n  }\n  else if ( flag_2 )\n  {\n    action_2();\n  }\n  else                  // Compliant\n  {\n  }\n}\n\nvoid f3( bool flag )\n{\n  if ( flag )\n  {\n    action_1();\n  }                     // Simple \u0027if\u0027 - rule does not apply\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e S5307 targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2023 Rule\u0026nbsp;9.4.2 - The structure of a \u003ccode\u003eswitch\u003c/code\u003e statement shall be appropriate \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "misra-c++2023",
      "misra-required"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:M23_233",
    "name": "Local variables shall not have static storage duration",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 6.7.1\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eThis rule does not apply to variables declared \u003ccode\u003econstexpr\u003c/code\u003e or \u003ccode\u003econst\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eThe use of mutable variables with static storage duration, even when they do not have linkage, potentially results in hidden temporal coupling.\nThis can lead to data races (and thus \u003cem\u003eundefined behaviour\u003c/em\u003e). Additionally, functions with persistent state are usually more difficult to\nunderstand and test.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e the lifetime of local variables with static storage duration ends at program termination in the reverse order of their\ncreation. Suitable care should be taken to ensure that the code executed during destruction does not access a previously destroyed variable.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nint32_t bar();\n\nint32_t ga \u003d 0;                         // Compliant - but violates \"See also\"\n\nint32_t foo()\n{\n                   int32_t a \u003d 0;       // Compliant\n  static           int32_t b \u003d 0;       // Non-compliant\n  static constexpr int32_t c \u003d 0;       // Compliant\n  static const     int32_t d \u003d bar();   // Compliant\n}\n\nclass Application\n{\n  static Application \u0026amp; theApp()\n  {\n    static Application app;             // Non-compliant\n\n    return app;\n  }\n};\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e S6018 targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n  \u003cli\u003e {rule:c:M23_388}: MISRA C++ 2023 Rule\u0026nbsp;6.7.2 - \u003cem\u003eGlobal variables\u003c/em\u003e shall not be used \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 6.7.1\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eThis rule does not apply to variables declared \u003ccode\u003econstexpr\u003c/code\u003e or \u003ccode\u003econst\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eThe use of mutable variables with static storage duration, even when they do not have linkage, potentially results in hidden temporal coupling.\nThis can lead to data races (and thus \u003cem\u003eundefined behaviour\u003c/em\u003e). Additionally, functions with persistent state are usually more difficult to\nunderstand and test.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e the lifetime of local variables with static storage duration ends at program termination in the reverse order of their\ncreation. Suitable care should be taken to ensure that the code executed during destruction does not access a previously destroyed variable.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nint32_t bar();\n\nint32_t ga \u003d 0;                         // Compliant - but violates \"See also\"\n\nint32_t foo()\n{\n                   int32_t a \u003d 0;       // Compliant\n  static           int32_t b \u003d 0;       // Non-compliant\n  static constexpr int32_t c \u003d 0;       // Compliant\n  static const     int32_t d \u003d bar();   // Compliant\n}\n\nclass Application\n{\n  static Application \u0026amp; theApp()\n  {\n    static Application app;             // Non-compliant\n\n    return app;\n  }\n};\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e S6018 targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n  \u003cli\u003e {rule:c:M23_388}: MISRA C++ 2023 Rule\u0026nbsp;6.7.2 - \u003cem\u003eGlobal variables\u003c/em\u003e shall not be used \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "confusing",
      "misra-c++2023",
      "misra-required",
      "unpredictable"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S1314",
    "name": "Octal values should not be used",
    "defaultSeverity": "BLOCKER",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eInteger literals starting with a zero are octal rather than decimal values. While using octal values is fully supported, most developers do not\nhave experience with them. They may not recognize octal values as such, mistaking them instead for decimal values.\u003c/p\u003e\n\u003cp\u003eHexadecimal literals (\u003ccode\u003e0xdeadbeef\u003c/code\u003e) and binary literals (\u003ccode\u003e0b0101\u00270110\u002700011\u003c/code\u003e, available since C++14), on the other hand, have\na clear marker (\u003ccode\u003e0x\u003c/code\u003e or \u003ccode\u003e0b\u003c/code\u003e) and can be used to define the binary representation of a value.\u003c/p\u003e\n\u003cp\u003eCharacter literals starting with \u003ccode\u003e\\\u003c/code\u003e and followed by one to three digits are octal escaped literals. Character literals starting with\n\u003ccode\u003e\\x\u003c/code\u003e and followed by one or more hexits are hexadecimal escaped literals, and are usually more readable.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint myNumber \u003d 010;   // Noncompliant. myNumber will hold 8, not 10 - was this really expected?\n\nchar myChar \u003d \u0027\\40\u0027; // Noncompliant. myChar will hold 32 rather than 40\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint myNumber \u003d 8; // Use decimal when representing the value 8\n// or\nint myNumber \u003d 0b1000; // Use binary or hexadecimal for a bit mask\n\nchar myChar \u003d \u0027\\x20\u0027; // Use hexadecimal\n// or\nchar myChar \u003d \u0027\\n\u0027; // Use the common notation if it exists for the literal\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Octal values have traditionally been used for user permissions in Posix file systems, and this rule will ignore octal literals used in this\n  context. \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003e\u0027\\0\u0027\u003c/code\u003e is a common notation for a null character, so the rule ignores it. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 7.1 - Octal constants (other than zero) and octal escape sequences shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 2-13-2 - Octal constants (other than zero) and octal escape sequences (other than \"\\0\") shall not be used \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 7.1 - Octal constants shall not be used \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/atYxBQ\"\u003eCERT, DCL18-C.\u003c/a\u003e - Do not begin integer constants with 0 when specifying a decimal\n  value \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eInteger literals starting with a zero are octal rather than decimal values. While using octal values is fully supported, most developers do not\nhave experience with them. They may not recognize octal values as such, mistaking them instead for decimal values.\u003c/p\u003e\n\u003cp\u003eHexadecimal literals (\u003ccode\u003e0xdeadbeef\u003c/code\u003e) and binary literals (\u003ccode\u003e0b0101\u00270110\u002700011\u003c/code\u003e, available since C++14), on the other hand, have\na clear marker (\u003ccode\u003e0x\u003c/code\u003e or \u003ccode\u003e0b\u003c/code\u003e) and can be used to define the binary representation of a value.\u003c/p\u003e\n\u003cp\u003eCharacter literals starting with \u003ccode\u003e\\\u003c/code\u003e and followed by one to three digits are octal escaped literals. Character literals starting with\n\u003ccode\u003e\\x\u003c/code\u003e and followed by one or more hexits are hexadecimal escaped literals, and are usually more readable.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint myNumber \u003d 010;   // Noncompliant. myNumber will hold 8, not 10 - was this really expected?\n\nchar myChar \u003d \u0027\\40\u0027; // Noncompliant. myChar will hold 32 rather than 40\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint myNumber \u003d 8; // Use decimal when representing the value 8\n// or\nint myNumber \u003d 0b1000; // Use binary or hexadecimal for a bit mask\n\nchar myChar \u003d \u0027\\x20\u0027; // Use hexadecimal\n// or\nchar myChar \u003d \u0027\\n\u0027; // Use the common notation if it exists for the literal\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Octal values have traditionally been used for user permissions in Posix file systems, and this rule will ignore octal literals used in this\n  context. \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003e\u0027\\0\u0027\u003c/code\u003e is a common notation for a null character, so the rule ignores it. \u003c/li\u003e\n\u003c/ul\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 7.1 - Octal constants (other than zero) and octal escape sequences shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 2-13-2 - Octal constants (other than zero) and octal escape sequences (other than \"\\0\") shall not be used \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 7.1 - Octal constants shall not be used \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/atYxBQ\"\u003eCERT, DCL18-C.\u003c/a\u003e - Do not begin integer constants with 0 when specifying a decimal\n  value \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "based-on-misra",
      "cert",
      "pitfall"
    ],
    "deprecatedKeys": [
      "c:OctalConstantAndSequence"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S2761",
    "name": "Unary prefix operators should not be repeated",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe repetition of a unary operator is usually a typo. The second operator invalidates the first one in most cases:\u003c/p\u003e\n\u003cpre\u003e\nint i \u003d 1;\n\nint j \u003d - - -i;  // Noncompliant: equivalent to \"-i\"\nint k \u003d ~~i;     // Noncompliant: equivalent to \"i\"\n\nbool b \u003d false;\nbool c \u003d !!!b;   // Noncompliant: equivalent to \"!b\"\n\u003c/pre\u003e\n\u003cp\u003eOn the other hand, while repeating the increment and decrement operators is technically correct, it obfuscates the meaning:\u003c/p\u003e\n\u003cpre\u003e\nint i \u003d 1;\nint j \u003d ++ ++i;  // Noncompliant\nint k \u003d ----i; // Noncompliant\n\u003c/pre\u003e\n\u003cp\u003eUsing \u003ccode\u003e+\u003d\u003c/code\u003e or \u003ccode\u003e-\u003d\u003c/code\u003e improves readability:\u003c/p\u003e\n\u003cpre\u003e\nint i \u003d 1;\ni +\u003d 2;\nint j \u003d i;\ni -\u003d2;\nint k \u003d i;\n\u003c/pre\u003e\n\u003cp\u003eThis rule raises an issue for repetitions of:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003e!\u003c/code\u003e, \u003ccode\u003e~\u003c/code\u003e, \u003ccode\u003e-\u003c/code\u003e, and \u003ccode\u003e+\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e the increment \u003ccode\u003e++\u003c/code\u003e and decrement \u003ccode\u003e- -\u003c/code\u003e operators in C++ \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThe rule ignores boolean normalization \u003ccode\u003e!!\u003c/code\u003e.\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe repetition of a unary operator is usually a typo. The second operator invalidates the first one in most cases:\u003c/p\u003e\n\u003cpre\u003e\nint i \u003d 1;\n\nint j \u003d - - -i;  // Noncompliant: equivalent to \"-i\"\nint k \u003d ~~i;     // Noncompliant: equivalent to \"i\"\n\nbool b \u003d false;\nbool c \u003d !!!b;   // Noncompliant: equivalent to \"!b\"\n\u003c/pre\u003e\n\u003cp\u003eOn the other hand, while repeating the increment and decrement operators is technically correct, it obfuscates the meaning:\u003c/p\u003e\n\u003cpre\u003e\nint i \u003d 1;\nint j \u003d ++ ++i;  // Noncompliant\nint k \u003d ----i; // Noncompliant\n\u003c/pre\u003e\n\u003cp\u003eUsing \u003ccode\u003e+\u003d\u003c/code\u003e or \u003ccode\u003e-\u003d\u003c/code\u003e improves readability:\u003c/p\u003e\n\u003cpre\u003e\nint i \u003d 1;\ni +\u003d 2;\nint j \u003d i;\ni -\u003d2;\nint k \u003d i;\n\u003c/pre\u003e\n\u003cp\u003eThis rule raises an issue for repetitions of:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003e!\u003c/code\u003e, \u003ccode\u003e~\u003c/code\u003e, \u003ccode\u003e-\u003c/code\u003e, and \u003ccode\u003e+\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e the increment \u003ccode\u003e++\u003c/code\u003e and decrement \u003ccode\u003e- -\u003c/code\u003e operators in C++ \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThe rule ignores boolean normalization \u003ccode\u003e!!\u003c/code\u003e.\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S3973",
    "name": "A conditionally executed single line should be denoted by indentation",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "FORMATTED",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhen the line immediately after a conditional has neither curly braces nor indentation, the intent of the code is unclear and perhaps not what is\nexecuted. Additionally, such code is confusing to maintainers.\u003c/p\u003e\n\u003cpre\u003e\nif (condition)  // Noncompliant\ndoTheThing();\ndoTheOtherThing(); // Was the intent to call this function unconditionally?\n\u003c/pre\u003e\n\u003cp\u003eIt becomes even more confusing and bug-prone if lines get commented out.\u003c/p\u003e\n\u003cpre\u003e\nif (condition)  // Noncompliant\n//  doTheThing();\ndoTheOtherThing(); // Was the intent to call this function conditionally?\n\u003c/pre\u003e\n\u003cp\u003eIndentation alone or together with curly braces makes the intent clear.\u003c/p\u003e\n\u003cpre\u003e\nif (condition)\n  doTheThing();\ndoTheOtherThing(); // Clear intent to call this function unconditionally\n\n// or\n\nif (condition) {\n  doTheThing();\n}\ndoTheOtherThing(); // Clear intent to call this function unconditionally\n\u003c/pre\u003e\n\u003cp\u003eThis rule raises an issue if the line controlled by a conditional has the same indentation as the conditional and is not enclosed in curly\nbraces.\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhen the line immediately after a conditional has neither curly braces nor indentation, the intent of the code is unclear and perhaps not what is\nexecuted. Additionally, such code is confusing to maintainers.\u003c/p\u003e\n\u003cpre\u003e\nif (condition)  // Noncompliant\ndoTheThing();\ndoTheOtherThing(); // Was the intent to call this function unconditionally?\n\u003c/pre\u003e\n\u003cp\u003eIt becomes even more confusing and bug-prone if lines get commented out.\u003c/p\u003e\n\u003cpre\u003e\nif (condition)  // Noncompliant\n//  doTheThing();\ndoTheOtherThing(); // Was the intent to call this function conditionally?\n\u003c/pre\u003e\n\u003cp\u003eIndentation alone or together with curly braces makes the intent clear.\u003c/p\u003e\n\u003cpre\u003e\nif (condition)\n  doTheThing();\ndoTheOtherThing(); // Clear intent to call this function unconditionally\n\n// or\n\nif (condition) {\n  doTheThing();\n}\ndoTheOtherThing(); // Clear intent to call this function unconditionally\n\u003c/pre\u003e\n\u003cp\u003eThis rule raises an issue if the line controlled by a conditional has the same indentation as the conditional and is not enclosed in curly\nbraces.\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "confusing",
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S3730",
    "name": "\"#include_next\" should not be used",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003e#include_next\u003c/code\u003e is a gcc-specific language extension that alters the search path for the specified header file by starting the search\nfrom the header file directory \u003cem\u003eafter\u003c/em\u003e the one in which the directive was encountered. It also ignores the distinction between\n\u003ccode\u003e\"file\"\u003c/code\u003e and \u003ccode\u003e\u0026lt;file\u0026gt;\u003c/code\u003e. It is typically used when you have two (probably related) header files with the same name, although\nthere is nothing in the extension to enforce or limit the use to same-name files.\u003c/p\u003e\n\u003cp\u003eUse of this extension can be tricky to get right, and is almost never justified. Instead, you should use an absolute path in the\n\u003ccode\u003e#include\u003c/code\u003e statement or rename one of the files.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include_next \"foo.h\" // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#include \"/usr/local/include/foo.h\"\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003ccode\u003e#include_next\u003c/code\u003e is a gcc-specific language extension that alters the search path for the specified header file by starting the search\nfrom the header file directory \u003cem\u003eafter\u003c/em\u003e the one in which the directive was encountered. It also ignores the distinction between\n\u003ccode\u003e\"file\"\u003c/code\u003e and \u003ccode\u003e\u0026lt;file\u0026gt;\u003c/code\u003e. It is typically used when you have two (probably related) header files with the same name, although\nthere is nothing in the extension to enforce or limit the use to same-name files.\u003c/p\u003e\n\u003cp\u003eUse of this extension can be tricky to get right, and is almost never justified. Instead, you should use an absolute path in the\n\u003ccode\u003e#include\u003c/code\u003e statement or rename one of the files.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include_next \"foo.h\" // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#include \"/usr/local/include/foo.h\"\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "confusing",
      "lock-in"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S3972",
    "name": "Conditionals should start on new lines",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "FORMATTED",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003ePlacing an \u003ccode\u003eif\u003c/code\u003e statement on the same line as the closing \u003ccode\u003e}\u003c/code\u003e from a preceding \u003ccode\u003eif\u003c/code\u003e, \u003ccode\u003eelse\u003c/code\u003e, or\n\u003ccode\u003eelse if\u003c/code\u003e block can lead to confusion and potential errors. It may indicate a missing \u003ccode\u003eelse\u003c/code\u003e statement or create ambiguity for\nmaintainers who might fail to understand that the two statements are unconnected.\u003c/p\u003e\n\u003cp\u003eThe following code snippet is confusing:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nif (condition1) {\n  // ...\n} if (condition2) {  // Noncompliant\n  //...\n}\n\u003c/pre\u003e\n\u003cp\u003eEither the two conditions are unrelated and they should be visually separated:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nif (condition1) {\n  // ...\n}\n\nif (condition2) {\n  //...\n}\n\u003c/pre\u003e\n\u003cp\u003eOr they were supposed to be exclusive and you should use \u003ccode\u003eelse if\u003c/code\u003e instead:\u003c/p\u003e\n\u003cpre\u003e\nif (condition1) {\n  // ...\n} else if (condition2) {\n  //...\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003ePlacing an \u003ccode\u003eif\u003c/code\u003e statement on the same line as the closing \u003ccode\u003e}\u003c/code\u003e from a preceding \u003ccode\u003eif\u003c/code\u003e, \u003ccode\u003eelse\u003c/code\u003e, or\n\u003ccode\u003eelse if\u003c/code\u003e block can lead to confusion and potential errors. It may indicate a missing \u003ccode\u003eelse\u003c/code\u003e statement or create ambiguity for\nmaintainers who might fail to understand that the two statements are unconnected.\u003c/p\u003e\n\u003cp\u003eThe following code snippet is confusing:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nif (condition1) {\n  // ...\n} if (condition2) {  // Noncompliant\n  //...\n}\n\u003c/pre\u003e\n\u003cp\u003eEither the two conditions are unrelated and they should be visually separated:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nif (condition1) {\n  // ...\n}\n\nif (condition2) {\n  //...\n}\n\u003c/pre\u003e\n\u003cp\u003eOr they were supposed to be exclusive and you should use \u003ccode\u003eelse if\u003c/code\u003e instead:\u003c/p\u003e\n\u003cpre\u003e\nif (condition1) {\n  // ...\n} else if (condition2) {\n  //...\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S1313",
    "name": "Using hardcoded IP addresses is security-sensitive",
    "defaultSeverity": "MINOR",
    "type": "SECURITY_HOTSPOT",
    "cleanCodeAttribute": "TRUSTWORTHY",
    "defaultImpacts": {
      "SECURITY": "LOW"
    },
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eHardcoding IP addresses is security-sensitive. It has led in the past to the following vulnerabilities:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"http://cve.mitre.org/cgi-bin/cvename.cgi?name\u003dCVE-2006-5901\"\u003eCVE-2006-5901\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"http://cve.mitre.org/cgi-bin/cvename.cgi?name\u003dCVE-2005-3725\"\u003eCVE-2005-3725\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eToday’s services have an ever-changing architecture due to their scaling and redundancy needs. It is a mistake to think that a service will always\nhave the same IP address. When it does change, the hardcoded IP will have to be modified too. This will have an impact on the product development,\ndelivery, and deployment:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The developers will have to do a rapid fix every time this happens, instead of having an operation team change a configuration file. \u003c/li\u003e\n  \u003cli\u003e It misleads to use the same address in every environment (dev, sys, qa, prod). \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eLast but not least it has an effect on application security. Attackers might be able to decompile the code and thereby discover a potentially\nsensitive address. They can perform a Denial of Service attack on the service, try to get access to the system, or try to spoof the IP address to\nbypass security checks. Such attacks can always be possible, but in the case of a hardcoded IP address solving the issue will take more time, which\nwill increase an attack’s impact.\u003c/p\u003e\n\u003ch2\u003eExceptions\u003c/h2\u003e\n\u003cp\u003eNo issue is reported for the following cases because they are not considered sensitive:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Loopback addresses 127.0.0.0/8 in CIDR notation (from 127.0.0.0 to 127.255.255.255) \u003c/li\u003e\n  \u003cli\u003e Broadcast address 255.255.255.255 \u003c/li\u003e\n  \u003cli\u003e Non-routable address 0.0.0.0 \u003c/li\u003e\n  \u003cli\u003e Strings of the form \u003ccode\u003e2.5.\u0026lt;number\u0026gt;.\u0026lt;number\u0026gt;\u003c/code\u003e as they \u003ca href\u003d\"http://www.oid-info.com/introduction.htm\"\u003eoften match\n  Object Identifiers\u003c/a\u003e (OID) \u003c/li\u003e\n  \u003cli\u003e Addresses in the ranges 192.0.2.0/24, 198.51.100.0/24, 203.0.113.0/24, reserved for documentation purposes by \u003ca\n  href\u003d\"https://datatracker.ietf.org/doc/html/rfc5737\"\u003eRFC 5737\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e Addresses in the range 2001:db8::/32, reserved for documentation purposes by \u003ca href\u003d\"https://datatracker.ietf.org/doc/html/rfc3849\"\u003eRFC\n  3849\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      },
      {
        "key": "assess_the_problem",
        "htmlContent": "\u003ch2\u003eAsk Yourself Whether\u003c/h2\u003e\n\u003cp\u003eThe disclosed IP address is sensitive, e.g.:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Can give information to an attacker about the network topology. \u003c/li\u003e\n  \u003cli\u003e It’s a personal (assigned to an identifiable person) IP address. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere is a risk if you answered yes to any of these questions.\u003c/p\u003e\n\u003ch2\u003eSensitive Code Example\u003c/h2\u003e\n\u003cpre\u003e\ndbi_conn conn \u003d dbi_conn_new(\"mysql\");\nstring host \u003d \"10.10.0.1\"; // Sensitive\ndbi_conn_set_option(conn, \"host\", host.c_str());\ndbi_conn_set_option(conn, \"host\", \"10.10.0.1\"); // Sensitive\n\u003c/pre\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003ch2\u003eRecommended Secure Coding Practices\u003c/h2\u003e\n\u003cp\u003eDon’t hard-code the IP address in the source code, instead make it configurable with environment variables, configuration files, or a similar\napproach. Alternatively, if confidentially is not required a domain name can be used since it allows to change the destination quickly without having\nto rebuild the software.\u003c/p\u003e\n\u003ch2\u003eCompliant Solution\u003c/h2\u003e\n\u003cpre\u003e\ndbi_conn conn \u003d dbi_conn_new(\"mysql\");\nstring host \u003d getDatabaseHost(); // Compliant\ndbi_conn_set_option(conn, \"host\", host.c_str()); // Compliant\n\u003c/pre\u003e\n\u003ch2\u003eSee\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/Top10/A01_2021-Broken_Access_Control/\"\u003eOWASP Top 10 2021 Category A1\u003c/a\u003e - Broken Access Control \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://www.owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\"\u003eOWASP Top 10 2017 Category A3\u003c/a\u003e - Sensitive Data\n  Exposure \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "cert"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": [],
    "vulnerabilityProbability": "LOW"
  },
  {
    "key": "c:S5381",
    "name": "\"^\" should not be confused with exponentiation",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eIn C and its family of languages, the \u003ccode\u003e^\u003c/code\u003e operator performs the \u003cem\u003eexclusive or\u003c/em\u003e (xor) operation. This can be misleading since\n\u003ccode\u003e^\u003c/code\u003e is also commonly used to designate the exponentiation operation, for instance, in BASIC or R.\u003c/p\u003e\n\u003cp\u003eThis rule will flag uses of \u003ccode\u003e^\u003c/code\u003e in places where exponentiation is suspected to be the intended operation, i.e., on expressions that\nattempt to \u003cem\u003exor\u003c/em\u003e 2 or 10 with a constant expression.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;stdint.h\u0026gt;\n\nuint32_t max_uint16 \u003d 2 ^ 16; // Noncompliant: expression evaluates to 18, instead of the intended 65536\nuint32_t one_billion \u003d 10 ^ 9; // Noncompliant: expression evaluates to 3 instead of the intended 1e9\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;stdint.h\u0026gt;\n#include \u0026lt;math.h\u0026gt;\n\nuint32_t max_uint16 \u003d 1 \u0026lt;\u0026lt; 16; // Compliant: using left shift to generate a power of 2\nuint32_t one_billion \u003d pow(10, 9); // Compliant: using the math pow function\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThe rule does not raise an issue when at least one of the operands is expressed as a binary, octal, or hexadecimal literal. The assumption is that\nthe \u003cem\u003exor\u003c/em\u003e operation is intended in such cases.\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;stdint.h\u0026gt;\n\nuint32_t using_octal \u003d 02 ^ 016; // Compliant by exception\nuint32_t using_binary \u003d 0b10 ^ 9; // Compliant by exception\nuint32_t using_hex \u003d 0xFF ^ 0x09; // Compliant by exception\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e Wikipedia - \u003ca href\u003d\"https://en.wikipedia.org/wiki/Exponentiation#In_programming_languages\"\u003eExponentiation: In programming languages\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e Wikipedia - \u003ca href\u003d\"https://en.wikipedia.org/wiki/Exclusive_or\"\u003eExclusive or (xor)\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eIn C and its family of languages, the \u003ccode\u003e^\u003c/code\u003e operator performs the \u003cem\u003eexclusive or\u003c/em\u003e (xor) operation. This can be misleading since\n\u003ccode\u003e^\u003c/code\u003e is also commonly used to designate the exponentiation operation, for instance, in BASIC or R.\u003c/p\u003e\n\u003cp\u003eThis rule will flag uses of \u003ccode\u003e^\u003c/code\u003e in places where exponentiation is suspected to be the intended operation, i.e., on expressions that\nattempt to \u003cem\u003exor\u003c/em\u003e 2 or 10 with a constant expression.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;stdint.h\u0026gt;\n\nuint32_t max_uint16 \u003d 2 ^ 16; // Noncompliant: expression evaluates to 18, instead of the intended 65536\nuint32_t one_billion \u003d 10 ^ 9; // Noncompliant: expression evaluates to 3 instead of the intended 1e9\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;stdint.h\u0026gt;\n#include \u0026lt;math.h\u0026gt;\n\nuint32_t max_uint16 \u003d 1 \u0026lt;\u0026lt; 16; // Compliant: using left shift to generate a power of 2\nuint32_t one_billion \u003d pow(10, 9); // Compliant: using the math pow function\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThe rule does not raise an issue when at least one of the operands is expressed as a binary, octal, or hexadecimal literal. The assumption is that\nthe \u003cem\u003exor\u003c/em\u003e operation is intended in such cases.\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;stdint.h\u0026gt;\n\nuint32_t using_octal \u003d 02 ^ 016; // Compliant by exception\nuint32_t using_binary \u003d 0b10 ^ 9; // Compliant by exception\nuint32_t using_hex \u003d 0xFF ^ 0x09; // Compliant by exception\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e Wikipedia - \u003ca href\u003d\"https://en.wikipedia.org/wiki/Exponentiation#In_programming_languages\"\u003eExponentiation: In programming languages\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e Wikipedia - \u003ca href\u003d\"https://en.wikipedia.org/wiki/Exclusive_or\"\u003eExclusive or (xor)\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S5261",
    "name": "\"else\" statements should be clearly matched with an \"if\"",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe dangling \u003ccode\u003eelse\u003c/code\u003e problem appears when nested \u003ccode\u003eif\u003c/code\u003e/\u003ccode\u003eelse\u003c/code\u003e\u0026nbsp;statements are written without curly braces. In\nthis case, \u003ccode\u003eelse\u003c/code\u003e is associated with the nearest\u0026nbsp;\u003ccode\u003eif\u003c/code\u003e but that is not always obvious and sometimes the indentation can also\nbe misleading.\u003c/p\u003e\n\u003cp\u003eThis rules reports \u003ccode\u003eelse\u003c/code\u003e statements that are difficult to understand, because they are inside nested \u003ccode\u003eif\u003c/code\u003e statements without\ncurly braces.\u003c/p\u003e\n\u003cp\u003eAdding curly braces can generally make the code clearer (see rule {rule:c:S121} ), and in this situation of dangling \u003ccode\u003eelse\u003c/code\u003e, it really\nclarifies the intention of the code.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n if (a)\n   if (b)\n     d++;\n else     // Noncompliant, is the \"else\" associated with \"if(a)\" or \"if (b)\"? (the answer is \"if(b)\")\n   e++;\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n if (a) {\n   if (b) {\n     d++;\n   }\n } else { // Compliant, there is no doubt the \"else\" is associated with \"if(a)\"\n   e++;\n }\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Dangling_else\"\u003ehttps://en.wikipedia.org/wiki/Dangling_else\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe dangling \u003ccode\u003eelse\u003c/code\u003e problem appears when nested \u003ccode\u003eif\u003c/code\u003e/\u003ccode\u003eelse\u003c/code\u003e\u0026nbsp;statements are written without curly braces. In\nthis case, \u003ccode\u003eelse\u003c/code\u003e is associated with the nearest\u0026nbsp;\u003ccode\u003eif\u003c/code\u003e but that is not always obvious and sometimes the indentation can also\nbe misleading.\u003c/p\u003e\n\u003cp\u003eThis rules reports \u003ccode\u003eelse\u003c/code\u003e statements that are difficult to understand, because they are inside nested \u003ccode\u003eif\u003c/code\u003e statements without\ncurly braces.\u003c/p\u003e\n\u003cp\u003eAdding curly braces can generally make the code clearer (see rule {rule:c:S121} ), and in this situation of dangling \u003ccode\u003eelse\u003c/code\u003e, it really\nclarifies the intention of the code.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n if (a)\n   if (b)\n     d++;\n else     // Noncompliant, is the \"else\" associated with \"if(a)\" or \"if (b)\"? (the answer is \"if(b)\")\n   e++;\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n if (a) {\n   if (b) {\n     d++;\n   }\n } else { // Compliant, there is no doubt the \"else\" is associated with \"if(a)\"\n   e++;\n }\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Dangling_else\"\u003ehttps://en.wikipedia.org/wiki/Dangling_else\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "confusing"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S799",
    "name": "Identifiers should not be longer than 31 characters",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "IDENTIFIABLE",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eIn addition to being difficult to use, too-long variable names can limit code portability. The ISO standard requires that variable, type, function\nand label names be no more than 31 characters long.\u003c/p\u003e\n\u003cp\u003eNote that 31 characters is an upper bound, rather than a length recommendation. Shorter names are better, as long as they’re still\ncommunicative.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint this_is_a_very_long_identifier_that_definitely_should_be_renamed \u003d 0;\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint reasonable_identifier \u003d 0;\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 5.1 - Identifiers (internal and external) shall not rely on the significance of more than 31 character. \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/FtcxBQ\"\u003eCERT, DCL23-C.\u003c/a\u003e - Guarantee that mutually visible identifiers are unique \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eIn addition to being difficult to use, too-long variable names can limit code portability. The ISO standard requires that variable, type, function\nand label names be no more than 31 characters long.\u003c/p\u003e\n\u003cp\u003eNote that 31 characters is an upper bound, rather than a length recommendation. Shorter names are better, as long as they’re still\ncommunicative.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint this_is_a_very_long_identifier_that_definitely_should_be_renamed \u003d 0;\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint reasonable_identifier \u003d 0;\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 5.1 - Identifiers (internal and external) shall not rely on the significance of more than 31 character. \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/FtcxBQ\"\u003eCERT, DCL23-C.\u003c/a\u003e - Guarantee that mutually visible identifiers are unique \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "based-on-misra",
      "cert"
    ],
    "deprecatedKeys": [
      "c:IdentifierLongerThan31"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S797",
    "name": "Trigraphs should not be used",
    "defaultSeverity": "BLOCKER",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eTrigraphs are denoted by a sequence of 2 question marks followed by a specified third character (e.g. ??- represents a \u0027~\u0027 (tilde) character and\n??) represents a \u0027]\u0027). They can cause accidental confusion with other uses of two question marks.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstatic const char str[] \u003d \"(Date should be in the form ??-??-??)\"; // Noncompliant. Evaluates to \"(Date should be in the form ~~]\"\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstatic const char str[] \u003d \"(Date should be in the form ?\" \"?-?\" \"?-?\" ?)\";  // adjacent string literals concatenated at compile time\nstatic const char str2[] \u003d \"(Date should be in the form ?-?-?)\"; // problem avoided by eliminating 2nd \u0027?\u0027 in each sequence\nstatic const char str3[] \u003d \"(Date should be in the form ? ?-? ?-? ?)\"; // problem avoided by spacing \u0027?\u0027s out\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/operator_alternative\"\u003eAlternative operator representations: Trigraphs\u003c/a\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/uNUxBQ\"\u003ePRE07-C. - Avoid using repeated question marks\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 4.2 - Trigraphs shall not be used \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 2-3-1 - Trigraphs shall not be used \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 4.2 - Trigraphs shall not be used \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eTrigraphs are denoted by a sequence of 2 question marks followed by a specified third character (e.g. ??- represents a \u0027~\u0027 (tilde) character and\n??) represents a \u0027]\u0027). They can cause accidental confusion with other uses of two question marks.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstatic const char str[] \u003d \"(Date should be in the form ??-??-??)\"; // Noncompliant. Evaluates to \"(Date should be in the form ~~]\"\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstatic const char str[] \u003d \"(Date should be in the form ?\" \"?-?\" \"?-?\" ?)\";  // adjacent string literals concatenated at compile time\nstatic const char str2[] \u003d \"(Date should be in the form ?-?-?)\"; // problem avoided by eliminating 2nd \u0027?\u0027 in each sequence\nstatic const char str3[] \u003d \"(Date should be in the form ? ?-? ?-? ?)\"; // problem avoided by spacing \u0027?\u0027s out\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/operator_alternative\"\u003eAlternative operator representations: Trigraphs\u003c/a\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/uNUxBQ\"\u003ePRE07-C. - Avoid using repeated question marks\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 4.2 - Trigraphs shall not be used \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 2-3-1 - Trigraphs shall not be used \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 4.2 - Trigraphs shall not be used \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "based-on-misra",
      "cert",
      "obsolete",
      "suspicious"
    ],
    "deprecatedKeys": [
      "c:TrigraphUsage"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S798",
    "name": "Digraphs should not be used",
    "defaultSeverity": "BLOCKER",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe use of digraphs may not meet developer expectations.\u003c/p\u003e\n\u003cp\u003eThe digraphs are:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003e\u0026lt;%\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003e%\u0026gt;\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003e\u0026lt;:\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003e:\u0026gt;\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003e%:\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003e%:%:\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\ntemplate \u0026lt;typename T\u0026gt;\nclass A\n{\n  public:\n    template\u0026lt;int32_t i\u0026gt;\n    void f2();\n};\n\nvoid f(A\u0026lt;int32_t\u0026gt; * a\u0026lt;:10:\u0026gt;)    /* Noncompliant - usage of \u0027\u0026lt;:\u0027 instead of \u0027[\u0027 and \u0027:\u0026gt;\u0027 instead of \u0027]\u0027 */\n\u0026lt;%                              /* Noncompliant - usage of \u0027\u0026lt;%\u0027 instead of \u0027{\u0027 */\n  a\u0026lt;:0:\u0026gt;-\u0026gt;f2\u0026lt;20\u0026gt;();             /* Noncompliant - usage of \u0027\u0026lt;:\u0027 and \u0027:\u0026gt;\u0027 */\n%\u0026gt;                              /* Noncompliant - usage of \u0027%\u0026gt;\u0027 instead of \u0027}\u0027 */\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n/* ... */\n\nvoid f(A\u0026lt;int32_t\u0026gt; * a[10])      /* Compliant */\n{                               /* Compliant */\n  a[0]-\u0026gt;f2\u0026lt;20\u0026gt;();               /* Compliant */\n}                               /* Compliant */\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 2-5-1 - Digraphs should not be used. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe use of digraphs may not meet developer expectations.\u003c/p\u003e\n\u003cp\u003eThe digraphs are:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003e\u0026lt;%\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003e%\u0026gt;\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003e\u0026lt;:\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003e:\u0026gt;\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003e%:\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003e%:%:\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\ntemplate \u0026lt;typename T\u0026gt;\nclass A\n{\n  public:\n    template\u0026lt;int32_t i\u0026gt;\n    void f2();\n};\n\nvoid f(A\u0026lt;int32_t\u0026gt; * a\u0026lt;:10:\u0026gt;)    /* Noncompliant - usage of \u0027\u0026lt;:\u0027 instead of \u0027[\u0027 and \u0027:\u0026gt;\u0027 instead of \u0027]\u0027 */\n\u0026lt;%                              /* Noncompliant - usage of \u0027\u0026lt;%\u0027 instead of \u0027{\u0027 */\n  a\u0026lt;:0:\u0026gt;-\u0026gt;f2\u0026lt;20\u0026gt;();             /* Noncompliant - usage of \u0027\u0026lt;:\u0027 and \u0027:\u0026gt;\u0027 */\n%\u0026gt;                              /* Noncompliant - usage of \u0027%\u0026gt;\u0027 instead of \u0027}\u0027 */\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n/* ... */\n\nvoid f(A\u0026lt;int32_t\u0026gt; * a[10])      /* Compliant */\n{                               /* Compliant */\n  a[0]-\u0026gt;f2\u0026lt;20\u0026gt;();               /* Compliant */\n}                               /* Compliant */\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 2-5-1 - Digraphs should not be used. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "based-on-misra",
      "obsolete"
    ],
    "deprecatedKeys": [
      "c:DigraphUsage"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S5262",
    "name": "Dereferenced null pointers should not be bound to references",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eDereferencing a null pointer has undefined behavior, and it is particularly harmful if a reference is then bound to the result, because a reference\nis assumed to refer to a valid object.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid doSomething(A\u0026amp; a);\nvoid f() {\n  A* a \u003d nullptr;\n  // ...\n  doSomething(*a); // Noncompliant\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eDereferencing a null pointer has undefined behavior, and it is particularly harmful if a reference is then bound to the result, because a reference\nis assumed to refer to a valid object.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid doSomething(A\u0026amp; a);\nvoid f() {\n  A* a \u003d nullptr;\n  // ...\n  doSomething(*a); // Noncompliant\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "unpredictable"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S5263",
    "name": "Logical operators should not be confused with bitwise operators",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhile working with bitwise operators \u003ccode\u003e\u0026amp;\u003c/code\u003e or \u003ccode\u003e|\u003c/code\u003e, it is easy to make a typo and\u0026nbsp;write the equivalent logical\noperators \u003ccode\u003e\u0026amp;\u0026amp;\u003c/code\u003e or \u003ccode\u003e||\u003c/code\u003e. This rule raises an issue when the right operand of a logical expression \u003ccode\u003e\u0026amp;\u0026amp;\u003c/code\u003e\nor \u003ccode\u003e||\u003c/code\u003e is a constant of integral type, as the developer probably meant to use the corresponding bitwise operator \u003ccode\u003e\u0026amp;\u003c/code\u003e or\n\u003ccode\u003e|\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nint fun(int a) {\n  return a || 4; // Noncompliant: did you mean to use bitwise operator \u0027|\u0027?\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nint fun(int a) {\n return a | 4;\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/operator_arithmetic#Bitwise_logic_operators\"\u003eBitwise logic operators\u003c/a\u003e\n  \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/operator_logical\"\u003eLogical operators\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhile working with bitwise operators \u003ccode\u003e\u0026amp;\u003c/code\u003e or \u003ccode\u003e|\u003c/code\u003e, it is easy to make a typo and\u0026nbsp;write the equivalent logical\noperators \u003ccode\u003e\u0026amp;\u0026amp;\u003c/code\u003e or \u003ccode\u003e||\u003c/code\u003e. This rule raises an issue when the right operand of a logical expression \u003ccode\u003e\u0026amp;\u0026amp;\u003c/code\u003e\nor \u003ccode\u003e||\u003c/code\u003e is a constant of integral type, as the developer probably meant to use the corresponding bitwise operator \u003ccode\u003e\u0026amp;\u003c/code\u003e or\n\u003ccode\u003e|\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nint fun(int a) {\n  return a || 4; // Noncompliant: did you mean to use bitwise operator \u0027|\u0027?\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nint fun(int a) {\n return a | 4;\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/operator_arithmetic#Bitwise_logic_operators\"\u003eBitwise logic operators\u003c/a\u003e\n  \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/operator_logical\"\u003eLogical operators\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S796",
    "name": "Only escape sequences defined in the ISO C standard should be used",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe use of an undefined escape sequence leads to undefined behavior. The defined escape sequences (ISO/IEC 14882:2003 [1] §2.13.2) are:\n\u003ccode\u003e\\n\u003c/code\u003e, \u003ccode\u003e\\t\u003c/code\u003e, \u003ccode\u003e\\v\u003c/code\u003e, \u003ccode\u003e\\b\u003c/code\u003e, \u003ccode\u003e\\r\u003c/code\u003e, \u003ccode\u003e\\f\u003c/code\u003e, \u003ccode\u003e\\a\u003c/code\u003e, \u003ccode\u003e\\\\\u003c/code\u003e,\n\u003ccode\u003e?\u003c/code\u003e, \u003ccode\u003e\\\u0027\u003c/code\u003e, \u003ccode\u003e\\\"\u003c/code\u003e, \u003ccode\u003e\\\u0026lt;Octal Number\u0026gt;\u003c/code\u003e, and \u003ccode\u003e\\x\u0026lt;Hexadecimal Number\u0026gt;\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nconst char_t a[ 2 ] \u003d \"\\k\";   // Noncompliant\nconst char_t b[ 2 ] \u003d \"\\b\";   // Compliant\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 4.1 - Only those escape sequences that are defined in ISO C standard shall be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 2-13-1 - Only those escape sequences that are defined in ISO/IEC 14882:2003 shall be used. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe use of an undefined escape sequence leads to undefined behavior. The defined escape sequences (ISO/IEC 14882:2003 [1] §2.13.2) are:\n\u003ccode\u003e\\n\u003c/code\u003e, \u003ccode\u003e\\t\u003c/code\u003e, \u003ccode\u003e\\v\u003c/code\u003e, \u003ccode\u003e\\b\u003c/code\u003e, \u003ccode\u003e\\r\u003c/code\u003e, \u003ccode\u003e\\f\u003c/code\u003e, \u003ccode\u003e\\a\u003c/code\u003e, \u003ccode\u003e\\\\\u003c/code\u003e,\n\u003ccode\u003e?\u003c/code\u003e, \u003ccode\u003e\\\u0027\u003c/code\u003e, \u003ccode\u003e\\\"\u003c/code\u003e, \u003ccode\u003e\\\u0026lt;Octal Number\u0026gt;\u003c/code\u003e, and \u003ccode\u003e\\x\u0026lt;Hexadecimal Number\u0026gt;\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nconst char_t a[ 2 ] \u003d \"\\k\";   // Noncompliant\nconst char_t b[ 2 ] \u003d \"\\b\";   // Compliant\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 4.1 - Only those escape sequences that are defined in ISO C standard shall be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 2-13-1 - Only those escape sequences that are defined in ISO/IEC 14882:2003 shall be used. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "based-on-misra"
    ],
    "deprecatedKeys": [
      "c:InvalidEscapeSequence"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:M23_126",
    "name": "The \"goto\" statement shall jump to a label declared later in the function body",
    "defaultSeverity": "BLOCKER",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 9.6.3\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eThe unconstrained use of \u003ccode\u003egoto\u003c/code\u003e can lead to programs that are extremely difficult to comprehend and analyse. However, flags may need to\nbe introduced to give the required control flow when it is not used, with the possibility that the flags may themselves make the code less transparent\nthan if \u003ccode\u003egoto\u003c/code\u003e were used. The restricted use of \u003ccode\u003egoto\u003c/code\u003e is therefore allowed where that use will not lead to semantics contrary\nto developer expectations.\u003c/p\u003e\n\u003cp\u003eThis rule prohibits the use of back jumps as they can be used to introduce iteration without using the well-defined iteration statements supplied\nby the language.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e the C++ Standard places restrictions on the uses of forward jumps. For example, it is not permitted to jump from a point\nwhere a local variable with initialization is not in scope to a point where it is in scope.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nvoid f()\n{\n  int32_t x \u003d 0;\n\nL1:\n  if ( x \u003d\u003d 10 )\n  {\n    goto L2;       // Compliant\n  }\n  else\n  {\n    ++x;\n    goto L1;       // Non-compliant\n  }\n\nL2:\n  return;\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:c:S999} targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n  \u003cli\u003e {rule:c:M23_403}: MISRA C++ 2023 Rule\u0026nbsp;9.6.1 - The \u003ccode\u003egoto\u003c/code\u003e statement should not be used \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2023 Rule\u0026nbsp;9.6.2 - A \u003ccode\u003egoto\u003c/code\u003e statement shall reference a label in a surrounding block \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 9.6.3\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eThe unconstrained use of \u003ccode\u003egoto\u003c/code\u003e can lead to programs that are extremely difficult to comprehend and analyse. However, flags may need to\nbe introduced to give the required control flow when it is not used, with the possibility that the flags may themselves make the code less transparent\nthan if \u003ccode\u003egoto\u003c/code\u003e were used. The restricted use of \u003ccode\u003egoto\u003c/code\u003e is therefore allowed where that use will not lead to semantics contrary\nto developer expectations.\u003c/p\u003e\n\u003cp\u003eThis rule prohibits the use of back jumps as they can be used to introduce iteration without using the well-defined iteration statements supplied\nby the language.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e the C++ Standard places restrictions on the uses of forward jumps. For example, it is not permitted to jump from a point\nwhere a local variable with initialization is not in scope to a point where it is in scope.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nvoid f()\n{\n  int32_t x \u003d 0;\n\nL1:\n  if ( x \u003d\u003d 10 )\n  {\n    goto L2;       // Compliant\n  }\n  else\n  {\n    ++x;\n    goto L1;       // Non-compliant\n  }\n\nL2:\n  return;\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:c:S999} targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n  \u003cli\u003e {rule:c:M23_403}: MISRA C++ 2023 Rule\u0026nbsp;9.6.1 - The \u003ccode\u003egoto\u003c/code\u003e statement should not be used \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2023 Rule\u0026nbsp;9.6.2 - A \u003ccode\u003egoto\u003c/code\u003e statement shall reference a label in a surrounding block \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "misra-c++2023",
      "misra-required",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:M23_007",
    "name": "The value returned by a function shall be \"used\"",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 0.1.2\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eThis rule only applies when the function is called explicitly using \u003cem\u003efunction call\u003c/em\u003e syntax.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eIt is possible to call a function without \u003cem\u003eusing\u003c/em\u003e [1] the return value, which may be an error. If the return value of a function is intended\nto be explicitly discarded, it should be cast to \u003ccode\u003evoid\u003c/code\u003e to ensure that it is \u003cem\u003eused\u003c/em\u003e [1].\u003c/p\u003e\n\u003cp\u003eOverloaded operators are excluded from this requirement, as they should behave in the same way as built-in operators.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e this rule effectively requires all non-\u003ccode\u003evoid\u003c/code\u003e functions to be treated as if they were declared\n\u003ccode\u003e[[nodiscard]]\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nuint16_t func();\n\nvoid discarded()\n{\n  func();                         // Non-compliant - implicitly discarded\n  ( void )func();                 // Compliant - void cast is a use\n  auto b \u003d func();                // Compliant - used as initializer\n}\n\nvoid f1( std::string q )\n{\n  std::string s { q } ;           // Rule does not apply - not function call syntax\n  s \u003d q;                          // Rule does not apply - not function call syntax\n  s.operator\u003d( q );               // Non-compliant\n}\n\nvoid f2( std::function\u0026lt; int() \u0026gt; \u0026amp; f )\n{\n  f();                            // Non-compliant - using function call syntax\n\n  auto a \u003d []() { return 10; };\n  a();                            // Non-compliant - using function call syntax\n}\n\u003c/pre\u003e\n\u003ch3\u003eGlossary\u003c/h3\u003e\n\u003ch4\u003e[1] Use / used / using\u003c/h4\u003e\n\u003cp\u003eAn object is \u003cem\u003eused\u003c/em\u003e if:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e It is the subject of a cast; or \u003c/li\u003e\n  \u003cli\u003e It is explicitly initialized at declaration time; or \u003c/li\u003e\n  \u003cli\u003e It is an operand in an expression; or \u003c/li\u003e\n  \u003cli\u003e It is referenced. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eA function is \u003cem\u003eused\u003c/em\u003e as defined in {rule:c:M23_331}: MISRA C++ 2023 Rule\u0026nbsp;0.2.4.\u003c/p\u003e\n\u003cp\u003eA type is \u003cem\u003eused\u003c/em\u003e as defined in MISRA C++ 2023 Rule\u0026nbsp;0.2.3 (Types with \u003cem\u003elimited visibility\u003c/em\u003e should be \u003cem\u003eused\u003c/em\u003e at least\nonce).\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e M23_287: MISRA C++ 2023 Rule\u0026nbsp;28.6.4 - The result of \u003ccode\u003estd::remove\u003c/code\u003e, \u003ccode\u003estd::remove_if\u003c/code\u003e,\n  \u003ccode\u003estd::unique\u003c/code\u003e and \u003ccode\u003eempty\u003c/code\u003e shall be \u003cem\u003eused\u003c/em\u003e \u003c/li\u003e\n  \u003cli\u003e S6007 targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 0.1.2\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eThis rule only applies when the function is called explicitly using \u003cem\u003efunction call\u003c/em\u003e syntax.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eIt is possible to call a function without \u003cem\u003eusing\u003c/em\u003e [1] the return value, which may be an error. If the return value of a function is intended\nto be explicitly discarded, it should be cast to \u003ccode\u003evoid\u003c/code\u003e to ensure that it is \u003cem\u003eused\u003c/em\u003e [1].\u003c/p\u003e\n\u003cp\u003eOverloaded operators are excluded from this requirement, as they should behave in the same way as built-in operators.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e this rule effectively requires all non-\u003ccode\u003evoid\u003c/code\u003e functions to be treated as if they were declared\n\u003ccode\u003e[[nodiscard]]\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nuint16_t func();\n\nvoid discarded()\n{\n  func();                         // Non-compliant - implicitly discarded\n  ( void )func();                 // Compliant - void cast is a use\n  auto b \u003d func();                // Compliant - used as initializer\n}\n\nvoid f1( std::string q )\n{\n  std::string s { q } ;           // Rule does not apply - not function call syntax\n  s \u003d q;                          // Rule does not apply - not function call syntax\n  s.operator\u003d( q );               // Non-compliant\n}\n\nvoid f2( std::function\u0026lt; int() \u0026gt; \u0026amp; f )\n{\n  f();                            // Non-compliant - using function call syntax\n\n  auto a \u003d []() { return 10; };\n  a();                            // Non-compliant - using function call syntax\n}\n\u003c/pre\u003e\n\u003ch3\u003eGlossary\u003c/h3\u003e\n\u003ch4\u003e[1] Use / used / using\u003c/h4\u003e\n\u003cp\u003eAn object is \u003cem\u003eused\u003c/em\u003e if:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e It is the subject of a cast; or \u003c/li\u003e\n  \u003cli\u003e It is explicitly initialized at declaration time; or \u003c/li\u003e\n  \u003cli\u003e It is an operand in an expression; or \u003c/li\u003e\n  \u003cli\u003e It is referenced. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eA function is \u003cem\u003eused\u003c/em\u003e as defined in {rule:c:M23_331}: MISRA C++ 2023 Rule\u0026nbsp;0.2.4.\u003c/p\u003e\n\u003cp\u003eA type is \u003cem\u003eused\u003c/em\u003e as defined in MISRA C++ 2023 Rule\u0026nbsp;0.2.3 (Types with \u003cem\u003elimited visibility\u003c/em\u003e should be \u003cem\u003eused\u003c/em\u003e at least\nonce).\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e M23_287: MISRA C++ 2023 Rule\u0026nbsp;28.6.4 - The result of \u003ccode\u003estd::remove\u003c/code\u003e, \u003ccode\u003estd::remove_if\u003c/code\u003e,\n  \u003ccode\u003estd::unique\u003c/code\u003e and \u003ccode\u003eempty\u003c/code\u003e shall be \u003cem\u003eused\u003c/em\u003e \u003c/li\u003e\n  \u003cli\u003e S6007 targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "misra-c++2023",
      "misra-required",
      "unused"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:M23_003",
    "name": "Variables with \"limited visibility\" should be \"used\" at least once",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 0.2.1\u003c/p\u003e\n\u003cp\u003eCategory: Advisory\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eA variable has \u003cem\u003elimited visibility\u003c/em\u003e if it is not a function parameter, and it has internal linkage or no linkage.\u003c/p\u003e\n\u003cp\u003eA variable is \u003cem\u003eused\u003c/em\u003e [1] when:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e It is part of an \u003cem\u003eid-expression\u003c/em\u003e; or \u003c/li\u003e\n  \u003cli\u003e The variable is of class type and has a \u003cem\u003euser-provided\u003c/em\u003e constructor or a \u003cem\u003euser-provided\u003c/em\u003e destructor. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eVariables that are declared and never used within a project do not contribute to program output; they constitute noise and may indicate that the\nwrong variable name has been used or that one or more statements are missing.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e this rule allows the introduction of variables for the sole purpose of providing scoped resource allocation and release. For\nexample:\u003c/p\u003e\n\u003cpre\u003e\n{\n  std::lock_guard\u0026lt; std::mutex \u0026gt; lock { mutex };    // Compliant - has user-provided\n                                                   //             constructor\n  // ...\n} // User-provided destructor implicitly called here\n\u003c/pre\u003e\n\u003ch3\u003eException\u003c/h3\u003e\n\u003cp\u003eThis rule does not apply to:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Variables that have at least one \u003cem\u003edeclaration\u003c/em\u003e [2] with the \u003ccode\u003e[[maybe_unused]]\u003c/code\u003e attribute. \u003c/li\u003e\n  \u003cli\u003e Constant variables at namespace scope that are declared within a \u003cem\u003eheader file\u003c/em\u003e [3]. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nclass C { };                  // No user-provided constructor or destructor\n\nnamespace\n{\n  C c;                        // Non-compliant - unused\n}\n\nvoid maybeUnused( int32_t a )\n{\n  [[maybe_unused]]\n    bool b \u003d a \u0026gt; 0;           // Compliant (by exception #1 if NDEBUG is defined)\n\n  assert( b );                // Does not use b if NDEBUG is defined\n\n  usefn( a );\n}\n\nconst int16_t x \u003d 19;         // Compliant - x is read in initializedButNotUsed\nconst int16_t y \u003d 21;         // Non-compliant - would be compliant by exception #2\n                              //                 if declared in a header file\n\nvoid initializedButNotUsed()\n{\n  int16_t local_1 \u003d 42;       // Non-compliant - local_1 is never read\n  int16_t local_2;            // Compliant\n\n  local_2 \u003d x;                // Use of local_2 for the purposes of this rule\n}\n\nvoid userProvidedCtor()\n{\n  std::ifstream fs { \"cfg.ini\" };    // Compliant - user-provided constructor\n}\n\u003c/pre\u003e\n\u003ch3\u003eGlossary\u003c/h3\u003e\n\u003ch4\u003e[1] Use / used / using\u003c/h4\u003e\n\u003cp\u003eAn object is \u003cem\u003eused\u003c/em\u003e if:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e It is the subject of a cast; or \u003c/li\u003e\n  \u003cli\u003e It is explicitly initialized at declaration time; or \u003c/li\u003e\n  \u003cli\u003e It is an operand in an expression; or \u003c/li\u003e\n  \u003cli\u003e It is referenced. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eA function is \u003cem\u003eused\u003c/em\u003e as defined in {rule:c:M23_331}: MISRA C++ 2023 Rule\u0026nbsp;0.2.4.\u003c/p\u003e\n\u003cp\u003eA type is \u003cem\u003eused\u003c/em\u003e as defined in MISRA C++ 2023 Rule\u0026nbsp;0.2.3 (Types with \u003cem\u003elimited visibility\u003c/em\u003e should be \u003cem\u003eused\u003c/em\u003e at least\nonce).\u003c/p\u003e\n\u003ch4\u003e[2] Declaration\u003c/h4\u003e\n\u003cp\u003eA \u003cem\u003edeclaration\u003c/em\u003e introduces the name of an \u003cem\u003eentity\u003c/em\u003e into a \u003cem\u003etranslation unit\u003c/em\u003e (see [basic.def]/1).\u003c/p\u003e\n\u003cp\u003eAn \u003cem\u003eentity\u003c/em\u003e may be \u003cem\u003edeclared\u003c/em\u003e several times. The first \u003cem\u003edeclaration\u003c/em\u003e of an \u003cem\u003eentity\u003c/em\u003e in a \u003cem\u003etranslation unit\u003c/em\u003e is\ncalled an \u003cem\u003eintroduction\u003c/em\u003e [4]. All subsequent \u003cem\u003edeclarations\u003c/em\u003e are called \u003cem\u003eredeclarations\u003c/em\u003e [5].\u003c/p\u003e\n\u003cp\u003eA \u003cem\u003edefinition\u003c/em\u003e [6] is a \u003cem\u003edeclaration\u003c/em\u003e, as described in [basic.def]/2.\u003c/p\u003e\n\u003ch4\u003e[3] Header file\u003c/h4\u003e\n\u003cp\u003eA \u003cem\u003eheader file\u003c/em\u003e is considered to be any file that is included during preprocessing (for example via the \u003ccode\u003e#include\u003c/code\u003e directive),\nregardless of its name or suffix.\u003c/p\u003e\n\u003ch4\u003e[4] Introduction\u003c/h4\u003e\n\u003cp\u003eSee \u003cem\u003edeclaration\u003c/em\u003e [2].\u003c/p\u003e\n\u003ch4\u003e[5] Redeclaration\u003c/h4\u003e\n\u003cp\u003eSee \u003cem\u003edeclaration\u003c/em\u003e [2].\u003c/p\u003e\n\u003ch4\u003e[6] Definition\u003c/h4\u003e\n\u003cp\u003eSee \u003cem\u003edeclaration\u003c/em\u003e [2].\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:c:S1481} targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2023 Rule\u0026nbsp;0.2.2 - A named function parameter shall be \u003cem\u003eused\u003c/em\u003e at least once \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 0.2.1\u003c/p\u003e\n\u003cp\u003eCategory: Advisory\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eA variable has \u003cem\u003elimited visibility\u003c/em\u003e if it is not a function parameter, and it has internal linkage or no linkage.\u003c/p\u003e\n\u003cp\u003eA variable is \u003cem\u003eused\u003c/em\u003e [1] when:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e It is part of an \u003cem\u003eid-expression\u003c/em\u003e; or \u003c/li\u003e\n  \u003cli\u003e The variable is of class type and has a \u003cem\u003euser-provided\u003c/em\u003e constructor or a \u003cem\u003euser-provided\u003c/em\u003e destructor. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eVariables that are declared and never used within a project do not contribute to program output; they constitute noise and may indicate that the\nwrong variable name has been used or that one or more statements are missing.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e this rule allows the introduction of variables for the sole purpose of providing scoped resource allocation and release. For\nexample:\u003c/p\u003e\n\u003cpre\u003e\n{\n  std::lock_guard\u0026lt; std::mutex \u0026gt; lock { mutex };    // Compliant - has user-provided\n                                                   //             constructor\n  // ...\n} // User-provided destructor implicitly called here\n\u003c/pre\u003e\n\u003ch3\u003eException\u003c/h3\u003e\n\u003cp\u003eThis rule does not apply to:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Variables that have at least one \u003cem\u003edeclaration\u003c/em\u003e [2] with the \u003ccode\u003e[[maybe_unused]]\u003c/code\u003e attribute. \u003c/li\u003e\n  \u003cli\u003e Constant variables at namespace scope that are declared within a \u003cem\u003eheader file\u003c/em\u003e [3]. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nclass C { };                  // No user-provided constructor or destructor\n\nnamespace\n{\n  C c;                        // Non-compliant - unused\n}\n\nvoid maybeUnused( int32_t a )\n{\n  [[maybe_unused]]\n    bool b \u003d a \u0026gt; 0;           // Compliant (by exception #1 if NDEBUG is defined)\n\n  assert( b );                // Does not use b if NDEBUG is defined\n\n  usefn( a );\n}\n\nconst int16_t x \u003d 19;         // Compliant - x is read in initializedButNotUsed\nconst int16_t y \u003d 21;         // Non-compliant - would be compliant by exception #2\n                              //                 if declared in a header file\n\nvoid initializedButNotUsed()\n{\n  int16_t local_1 \u003d 42;       // Non-compliant - local_1 is never read\n  int16_t local_2;            // Compliant\n\n  local_2 \u003d x;                // Use of local_2 for the purposes of this rule\n}\n\nvoid userProvidedCtor()\n{\n  std::ifstream fs { \"cfg.ini\" };    // Compliant - user-provided constructor\n}\n\u003c/pre\u003e\n\u003ch3\u003eGlossary\u003c/h3\u003e\n\u003ch4\u003e[1] Use / used / using\u003c/h4\u003e\n\u003cp\u003eAn object is \u003cem\u003eused\u003c/em\u003e if:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e It is the subject of a cast; or \u003c/li\u003e\n  \u003cli\u003e It is explicitly initialized at declaration time; or \u003c/li\u003e\n  \u003cli\u003e It is an operand in an expression; or \u003c/li\u003e\n  \u003cli\u003e It is referenced. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eA function is \u003cem\u003eused\u003c/em\u003e as defined in {rule:c:M23_331}: MISRA C++ 2023 Rule\u0026nbsp;0.2.4.\u003c/p\u003e\n\u003cp\u003eA type is \u003cem\u003eused\u003c/em\u003e as defined in MISRA C++ 2023 Rule\u0026nbsp;0.2.3 (Types with \u003cem\u003elimited visibility\u003c/em\u003e should be \u003cem\u003eused\u003c/em\u003e at least\nonce).\u003c/p\u003e\n\u003ch4\u003e[2] Declaration\u003c/h4\u003e\n\u003cp\u003eA \u003cem\u003edeclaration\u003c/em\u003e introduces the name of an \u003cem\u003eentity\u003c/em\u003e into a \u003cem\u003etranslation unit\u003c/em\u003e (see [basic.def]/1).\u003c/p\u003e\n\u003cp\u003eAn \u003cem\u003eentity\u003c/em\u003e may be \u003cem\u003edeclared\u003c/em\u003e several times. The first \u003cem\u003edeclaration\u003c/em\u003e of an \u003cem\u003eentity\u003c/em\u003e in a \u003cem\u003etranslation unit\u003c/em\u003e is\ncalled an \u003cem\u003eintroduction\u003c/em\u003e [4]. All subsequent \u003cem\u003edeclarations\u003c/em\u003e are called \u003cem\u003eredeclarations\u003c/em\u003e [5].\u003c/p\u003e\n\u003cp\u003eA \u003cem\u003edefinition\u003c/em\u003e [6] is a \u003cem\u003edeclaration\u003c/em\u003e, as described in [basic.def]/2.\u003c/p\u003e\n\u003ch4\u003e[3] Header file\u003c/h4\u003e\n\u003cp\u003eA \u003cem\u003eheader file\u003c/em\u003e is considered to be any file that is included during preprocessing (for example via the \u003ccode\u003e#include\u003c/code\u003e directive),\nregardless of its name or suffix.\u003c/p\u003e\n\u003ch4\u003e[4] Introduction\u003c/h4\u003e\n\u003cp\u003eSee \u003cem\u003edeclaration\u003c/em\u003e [2].\u003c/p\u003e\n\u003ch4\u003e[5] Redeclaration\u003c/h4\u003e\n\u003cp\u003eSee \u003cem\u003edeclaration\u003c/em\u003e [2].\u003c/p\u003e\n\u003ch4\u003e[6] Definition\u003c/h4\u003e\n\u003cp\u003eSee \u003cem\u003edeclaration\u003c/em\u003e [2].\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:c:S1481} targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2023 Rule\u0026nbsp;0.2.2 - A named function parameter shall be \u003cem\u003eused\u003c/em\u003e at least once \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "misra-advisory",
      "misra-c++2023",
      "unused"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S1226",
    "name": "Function parameters\u0027 initial values should not be ignored",
    "defaultSeverity": "MINOR",
    "type": "BUG",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "RELIABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhile it is technically correct to assign to parameters from within function bodies, it is better to use temporary variables to store intermediate\nresults.\u003c/p\u003e\n\u003cp\u003eAllowing parameters to be assigned to also reduces the code readability as developers will not be able to know whether the original parameter or\nsome temporary variable is being accessed without going through the whole function.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint glob \u003d 0;\nvoid function (int a) {\n  a \u003d glob; // Noncompliant\n  ...\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint glob \u003d 0;\nvoid function (int a) {\n  int b \u003d glob;\n  ...\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2012, 17.8 - A function parameter should not be modified \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhile it is technically correct to assign to parameters from within function bodies, it is better to use temporary variables to store intermediate\nresults.\u003c/p\u003e\n\u003cp\u003eAllowing parameters to be assigned to also reduces the code readability as developers will not be able to know whether the original parameter or\nsome temporary variable is being accessed without going through the whole function.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint glob \u003d 0;\nvoid function (int a) {\n  a \u003d glob; // Noncompliant\n  ...\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint glob \u003d 0;\nvoid function (int a) {\n  int b \u003d glob;\n  ...\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2012, 17.8 - A function parameter should not be modified \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "based-on-misra"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S1227",
    "name": "break statements should not be used except for switch cases",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003ebreak;\u003c/code\u003e is an unstructured control flow statement which makes code harder to read.\u003c/p\u003e\n\u003cp\u003eIdeally, every loop should have a single termination condition.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nfor (element \u003d list.first; element !\u003d null; element \u003d element-\u0026gt;next) { // First termination condition\n  if (!matches(element-\u0026gt;value)) {                                      // Second termination condition\n    break; // Noncompliant\n  }\n\n  /* ... */\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n// Compliant\nfor (element \u003d list.first; element !\u003d null \u0026amp;\u0026amp; matches(element-\u0026gt;value); element \u003d element-\u0026gt;next) {\n  /* ... */\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003ccode\u003ebreak;\u003c/code\u003e is an unstructured control flow statement which makes code harder to read.\u003c/p\u003e\n\u003cp\u003eIdeally, every loop should have a single termination condition.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nfor (element \u003d list.first; element !\u003d null; element \u003d element-\u0026gt;next) { // First termination condition\n  if (!matches(element-\u0026gt;value)) {                                      // Second termination condition\n    break; // Noncompliant\n  }\n\n  /* ... */\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n// Compliant\nfor (element \u003d list.first; element !\u003d null \u0026amp;\u0026amp; matches(element-\u0026gt;value); element \u003d element-\u0026gt;next) {\n  /* ... */\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S3646",
    "name": "Types and variables should be declared in separate statements",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "FOCUSED",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eIt is possible in the same statement, to declare a user-defined type (\u003ccode\u003eclass\u003c/code\u003e, \u003ccode\u003estruct\u003c/code\u003e, \u003ccode\u003eunion\u003c/code\u003e or\n\u003ccode\u003eenum\u003c/code\u003e) followed by variable declarations of this type. But mixing more than one concern in a single statement is confusing for\nmaintainers.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when a variable is declared at the end of a user-defined type declaration statement.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstruct Container { int size; } container; // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstruct Container { int size; };\nContainer container;\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c7-dont-define-a-class-or-enum-and-declare-a-variable-of-its-type-in-the-same-statement\"\u003eC.7: Don’t define a class or enum and declare a variable of its type in the same statement\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eIt is possible in the same statement, to declare a user-defined type (\u003ccode\u003eclass\u003c/code\u003e, \u003ccode\u003estruct\u003c/code\u003e, \u003ccode\u003eunion\u003c/code\u003e or\n\u003ccode\u003eenum\u003c/code\u003e) followed by variable declarations of this type. But mixing more than one concern in a single statement is confusing for\nmaintainers.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when a variable is declared at the end of a user-defined type declaration statement.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstruct Container { int size; } container; // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstruct Container { int size; };\nContainer container;\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c7-dont-define-a-class-or-enum-and-declare-a-variable-of-its-type-in-the-same-statement\"\u003eC.7: Don’t define a class or enum and declare a variable of its type in the same statement\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "confusing",
      "cppcoreguidelines"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S5824",
    "name": "Using \"tmpnam\", \"tmpnam_s\" or \"tmpnam_r\" is security-sensitive",
    "defaultSeverity": "CRITICAL",
    "type": "SECURITY_HOTSPOT",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "SECURITY": "HIGH"
    },
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe functions \"tmpnam\", \"tmpnam_s\" and \"tmpnam_r\" are all used to return a file name that does not match an existing file, in order for the\napplication to create a temporary file. However, even if the file did not exist at the time those functions were called, it might exist by the time\nthe application tries to use the file name to create the files. This has been used by hackers to gain access to files that the application believed\nwere trustworthy.\u003c/p\u003e\n\u003cp\u003eThere are alternative functions that, in addition to creating a suitable file name, create and open the file and return the file handler. Such\nfunctions are protected from this attack vector and should be preferred. About the only reason to use these functions would be to create a temporary\nfolder, not a temporary file.\u003c/p\u003e\n\u003cp\u003eAdditionally, these functions might not be thread-safe, and if you don’t provide them buffers of sufficient size, you will have a buffer\noverflow.\u003c/p\u003e"
      },
      {
        "key": "assess_the_problem",
        "htmlContent": "\u003ch2\u003eAsk Yourself Whether\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e There is a possibility that several threads call any of these functions simultaneously \u003c/li\u003e\n  \u003cli\u003e There is a possibility that the resulting file is opened without forcing its creation, meaning that it might have unexpected access rights\n  \u003c/li\u003e\n  \u003cli\u003e The buffers passed to these functions are respectively smaller than\n    \u003cul\u003e\n      \u003cli\u003e \u003ccode\u003eL_tmpnam\u003c/code\u003e for \u003ccode\u003etmpnam\u003c/code\u003e \u003c/li\u003e\n      \u003cli\u003e \u003ccode\u003eL_tmpnam_s\u003c/code\u003e for \u003ccode\u003etmpnam_s\u003c/code\u003e \u003c/li\u003e\n      \u003cli\u003e \u003ccode\u003eL_tmpnam\u003c/code\u003e for \u003ccode\u003etmpnam_r\u003c/code\u003e \u003c/li\u003e\n    \u003c/ul\u003e  \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere is a risk if you answered yes to any of those questions.\u003c/p\u003e\n\u003ch2\u003eSensitive Code Example\u003c/h2\u003e\n\u003cpre\u003e\nint f(char *tempData) {\n  char *path \u003d tmpnam(NULL); // Sensitive\n  FILE* f \u003d fopen(tmpnam, \"w\");\n  fputs(tempData, f);\n  fclose(f);\n}\n\u003c/pre\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003ch2\u003eRecommended Secure Coding Practices\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e Use a function that directly opens the temporary file, such a \u003ccode\u003etmpfile\u003c/code\u003e, \u003ccode\u003etmpfile_s\u003c/code\u003e, \u003ccode\u003emkstemp\u003c/code\u003e or\n  \u003ccode\u003emkstemps\u003c/code\u003e (the last two allow more accurate control of the file name). \u003c/li\u003e\n  \u003cli\u003e If you can’t get rid of these functions, when using the generated name to open the file, use a function that forces the creation of the file\n  and fails if the file already exists. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eCompliant Solution\u003c/h2\u003e\n\u003cpre\u003e\nint f(char *tempData) {\n  // The file will be opened in \"wb+\" mode, and will be automatically removed on normal program exit\n  FILE* f \u003d tmpfile(); // Compliant\n  fputs(tempData, f);\n  fclose(f);\n}\n\u003c/pre\u003e\n\u003ch2\u003eSee\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/Top10/A01_2021-Broken_Access_Control/\"\u003eOWASP Top 10 2021 Category A1\u003c/a\u003e - Broken Access Control \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/Top10/A06_2021-Vulnerable_and_Outdated_Components/\"\u003eOWASP Top 10 2021 Category A6\u003c/a\u003e - Vulnerable and Outdated\n  Components \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/www-project-top-ten/2017/A9_2017-Using_Components_with_Known_Vulnerabilities\"\u003eOWASP Top 10 2017 Category A9\u003c/a\u003e -\n  Using Components with Known Vulnerabilities \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/377\"\u003eMITRE, CWE-377\u003c/a\u003e - Insecure Temporary File \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/display/c/CON33-C.+Avoid+race+conditions+when+using+library+functions\"\u003eCERT, CON33-C.\u003c/a\u003e - Avoid\n  race conditions when using library functions \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/display/c/FIO21-C.+Do+not+create+temporary+files+in+shared+directories\"\u003eCERT, FIO21-C.\u003c/a\u003e - Do\n  not create temporary files in shared directories \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "cert",
      "cwe"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": [],
    "vulnerabilityProbability": "LOW"
  },
  {
    "key": "c:S5825",
    "name": "Macros should not be used as replacements for \"typedef\" and \"using\"",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eC provides a way of defining or aliasing a type through \u003ccode\u003etypedef\u003c/code\u003e. On top of it, C++ adds \u003ccode\u003eusing\u003c/code\u003e that can do the same and\nmore.\u003c/p\u003e\n\u003cp\u003eUsing a macro to define a type is inferior to the previous ways for two reasons:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e macros cannot be enclosed into scopes. Or at least, doing so is cumbersome and error-prone, as in that case, the macro needs to be defined and\n  undefined manually. \u003c/li\u003e\n  \u003cli\u003e macros are handled by the preprocessor and are not understood by the compiler. They can easily pollute the code in places where types are not\n  expected. \u003ccode\u003etypedef\u003c/code\u003e and \u003ccode\u003eusing\u003c/code\u003e are known to the compiler to define types and can be more strictly checked. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eAs a result, macros should not be used as a replacement for\u0026nbsp;\u003ccode\u003etypedef\u003c/code\u003e or \u003ccode\u003eusing\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#define UINT unsigned int  // Noncompliant\n#define INT int  // Noncompliant\nUINT uabs( INT i );\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\ntypedef unsigned int UINT;\ntypedef int INT;\nUINT uabs( INT i );\n\u003c/pre\u003e\n\u003cp\u003eor\u003c/p\u003e\n\u003cpre\u003e\nusing UINT \u003d unsigned int;\nusing INT \u003d int;\nUINT uabs( INT i );\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/typedef\"\u003etypedef specifier\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/type_alias\"\u003eType alias, alias template\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/display/c/PRE03-C.+Prefer+typedefs+to+defines+for+encoding+non-pointer+types\"\u003ePRE03-C.\n  Prefer typedefs to defines for encoding non-pointer types\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eC provides a way of defining or aliasing a type through \u003ccode\u003etypedef\u003c/code\u003e. On top of it, C++ adds \u003ccode\u003eusing\u003c/code\u003e that can do the same and\nmore.\u003c/p\u003e\n\u003cp\u003eUsing a macro to define a type is inferior to the previous ways for two reasons:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e macros cannot be enclosed into scopes. Or at least, doing so is cumbersome and error-prone, as in that case, the macro needs to be defined and\n  undefined manually. \u003c/li\u003e\n  \u003cli\u003e macros are handled by the preprocessor and are not understood by the compiler. They can easily pollute the code in places where types are not\n  expected. \u003ccode\u003etypedef\u003c/code\u003e and \u003ccode\u003eusing\u003c/code\u003e are known to the compiler to define types and can be more strictly checked. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eAs a result, macros should not be used as a replacement for\u0026nbsp;\u003ccode\u003etypedef\u003c/code\u003e or \u003ccode\u003eusing\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#define UINT unsigned int  // Noncompliant\n#define INT int  // Noncompliant\nUINT uabs( INT i );\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\ntypedef unsigned int UINT;\ntypedef int INT;\nUINT uabs( INT i );\n\u003c/pre\u003e\n\u003cp\u003eor\u003c/p\u003e\n\u003cpre\u003e\nusing UINT \u003d unsigned int;\nusing INT \u003d int;\nUINT uabs( INT i );\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/typedef\"\u003etypedef specifier\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/type_alias\"\u003eType alias, alias template\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/display/c/PRE03-C.+Prefer+typedefs+to+defines+for+encoding+non-pointer+types\"\u003ePRE03-C.\n  Prefer typedefs to defines for encoding non-pointer types\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "bad-practice",
      "cert",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S3529",
    "name": "Freed memory should not be used",
    "defaultSeverity": "BLOCKER",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003cp\u003eAccessing a memory block that was already freed is undefined behavior. This rule flags access via a pointer or a reference to released heap\nmemory.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eA program may allocate an additional memory block using the \u003ccode\u003emalloc\u003c/code\u003e function. When no longer needed, such memory blocks are released\nusing the \u003ccode\u003efree\u003c/code\u003e function. After it is released, reading or writing to a heap-allocated memory block leads to undefined behavior.\u003c/p\u003e\n\u003cpre\u003e\nchar *cp \u003d (char*)malloc(sizeof(char)*10); // memory is allocated\n// all bytes in cp can be used here\nfree(cp); // memory is released\ncp[9] \u003d 0; // Noncompliant: memory is used after it was released\n\u003c/pre\u003e\n\u003cp\u003eIn addition to the \u003ccode\u003emalloc\u003c/code\u003e and \u003ccode\u003efree\u003c/code\u003e pair, in C++ a heap memory may be acquired by use of the operator \u003ccode\u003enew\u003c/code\u003e,\nand later released using the operator \u003ccode\u003edelete\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\nint *intArray \u003d new int[20]; // memory is allocated\n// elements of intArray can be written or read here\ndelete[] intArray; // memory is released\nintArray[3] \u003d 10; // Noncompliant: memory is used after it was released\n\u003c/pre\u003e\n\u003cp\u003eReleasing a memory block by invoking \u003ccode\u003efree\u003c/code\u003e or operator \u003ccode\u003edelete\u003c/code\u003e informs the memory management system that the program no\nlonger uses the given block. Depending on the state and load of the program, such block can be then:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e reused, i.e., the allocation function returns the same pointer, \u003c/li\u003e\n  \u003cli\u003e released to the operating system, making it inaccessible to the program. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eAccessing released memory causes undefined behavior. This means the compiler is not bound by the language standard anymore, and your program has no\nmeaning assigned to it.\u003c/p\u003e\n\u003cp\u003ePractically this has a wide range of effects:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The program may crash due to the memory no longer being accessible, or due to unexpected value being read or written via the pointer. \u003c/li\u003e\n  \u003cli\u003e Reading from the released memory may produce a garbage value. \u003c/li\u003e\n  \u003cli\u003e When the memory was already reused to store sensitive data, such as passwords, it may lead to a vulnerability that uses this defect to extract\n  information from an instance of the program. \u003c/li\u003e\n  \u003cli\u003e Writing to released memory may change the value of the unrelated object in a remote part of the code if the memory was reused by it. As\n  different objects may reuse same the block of memory between runs, this leads to unintuitive and hard diagnose bugs. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eIn most situations, the use of an uninitialized object is a strong indication of a defect in the code, and fixing it requires a review of the\nobject allocation and deallocation strategies. Generally, the fix requires adjusting the code, so either:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Moving accesses to the memory before the deallocation \u003c/li\u003e\n  \u003cli\u003e Moving the deallocation so it happens after all the uses \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIf possible, it is desired to remove manual memory allocation, and replace it with stack-allocated objects, or in the case of C++, stack objects\nthat manage memory (using RAII idiom).\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nint *intArray \u003d (int*)malloc(sizeof(int)*10);\n// ...\nfree(intArray);\nintArray[9] \u003d 0;  // Noncompliant\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eRelease the memory after all of its uses.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nint *intArray \u003d (int*)malloc(sizeof(int)*10);\n// ...\nintArray[9] \u003d 0;  // Compliant\nfree(intArray);\n\u003c/pre\u003e\n\u003cp\u003eAlternatively, allocate the array on the stack, if the size of the array is known at compile-time:\u003c/p\u003e\n\u003cpre\u003e\nint intArray[10];\n// ...\nintArray[9] \u003d 0;  // Compliant\n\u003c/pre\u003e\n\u003cp\u003eIn C++, use \u003ccode\u003estd::vector\u003c/code\u003e with an arbitrary number of elements:\u003c/p\u003e\n\u003cpre\u003e\nstd::vector\u0026lt;int\u0026gt; intArray;\nintArray.resize(10);\n// ...\nintArray[9] \u003d 0;  // Compliant\n\u003c/pre\u003e\n\u003ch3\u003eGoing the extra mile\u003c/h3\u003e\n\u003cp\u003eIn C++, manually allocating and deallocating memory is considered a code smell.\u003c/p\u003e\n\u003cp\u003eIt is recommended to follow the \u003cem\u003eRAII\u003c/em\u003e idiom and create a class that manages the memory by allocating it when the object is constructed and\nfreeing it when it is destroyed. Furthermore, copy and move operations on such objects are designed such that this object can be passed by value\nbetween functions (either as an argument or by being returned) in place of raw pointers.\u003c/p\u003e\n\u003cp\u003eDepending on the type, passing an \u003cem\u003eRAII\u003c/em\u003e object operations may either:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Allocate a new block of memory and copy the elements (\u003ccode\u003estd::vector\u003c/code\u003e). \u003c/li\u003e\n  \u003cli\u003e Transfer ownership of the memory to constructed object (\u003ccode\u003estd::unique_ptr\u003c/code\u003e). \u003c/li\u003e\n  \u003cli\u003e Use shared ownership and free memory when the last object is destroyed (\u003ccode\u003estd::shared_ptr\u003c/code\u003e). \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis guarantees that accessing a memory managed by such an object is not released as long as such an object is not modified or destroyed (some\n\u003cem\u003eRAII\u003c/em\u003e types provide a stronger guarantee).\u003c/p\u003e\n\u003cpre\u003e\nstd::vector\u0026lt;int\u0026gt; intArray(10); // manages an array of 10 integers, on the heap\nstd::unique_ptr\u0026lt;Class\u0026gt; objPtr \u003d std::make_unique\u0026lt;Class\u0026gt;(); // manages an object on the heap\n\nintArray[5]; // OK\nobjPtr-\u0026gt;foo(); // OK\n\u003c/pre\u003e\n\u003cp\u003eHowever, any raw pointers or references to memory held by \u003cem\u003eRAII\u003c/em\u003e object may still lead to a use after free:\u003c/p\u003e\n\u003cpre\u003e\nint* p1 \u003d \u0026amp;intArray[0];    // becomes dangling when intArray is destroyed\nint* p2 \u003d intArray.data(); // same as above\nClass* p3 \u003d objPtr.get();  // becomes dangling, when objPtr releases the pointer\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/raii\"\u003eRAII\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/memory/unique_ptr\"\u003estd::unique_ptr\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/memory/shared_ptr\"\u003estd::shared_ptr\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/416\"\u003e416 - Use After Free\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/GdYxBQ\"\u003eMEM30-C - Do not access freed memory\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/onw-BQ\"\u003eMEM50-CPP - Do not access freed memory\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/OXw-BQ\"\u003eEXP54-CPP - Do not access an object outside of its lifetime\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e S5025 recommends avoiding manual memory management \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eAccessing a memory block that was already freed is undefined behavior. This rule flags access via a pointer or a reference to released heap\nmemory.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eA program may allocate an additional memory block using the \u003ccode\u003emalloc\u003c/code\u003e function. When no longer needed, such memory blocks are released\nusing the \u003ccode\u003efree\u003c/code\u003e function. After it is released, reading or writing to a heap-allocated memory block leads to undefined behavior.\u003c/p\u003e\n\u003cpre\u003e\nchar *cp \u003d (char*)malloc(sizeof(char)*10); // memory is allocated\n// all bytes in cp can be used here\nfree(cp); // memory is released\ncp[9] \u003d 0; // Noncompliant: memory is used after it was released\n\u003c/pre\u003e\n\u003cp\u003eIn addition to the \u003ccode\u003emalloc\u003c/code\u003e and \u003ccode\u003efree\u003c/code\u003e pair, in C++ a heap memory may be acquired by use of the operator \u003ccode\u003enew\u003c/code\u003e,\nand later released using the operator \u003ccode\u003edelete\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\nint *intArray \u003d new int[20]; // memory is allocated\n// elements of intArray can be written or read here\ndelete[] intArray; // memory is released\nintArray[3] \u003d 10; // Noncompliant: memory is used after it was released\n\u003c/pre\u003e\n\u003cp\u003eReleasing a memory block by invoking \u003ccode\u003efree\u003c/code\u003e or operator \u003ccode\u003edelete\u003c/code\u003e informs the memory management system that the program no\nlonger uses the given block. Depending on the state and load of the program, such block can be then:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e reused, i.e., the allocation function returns the same pointer, \u003c/li\u003e\n  \u003cli\u003e released to the operating system, making it inaccessible to the program. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eAccessing released memory causes undefined behavior. This means the compiler is not bound by the language standard anymore, and your program has no\nmeaning assigned to it.\u003c/p\u003e\n\u003cp\u003ePractically this has a wide range of effects:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The program may crash due to the memory no longer being accessible, or due to unexpected value being read or written via the pointer. \u003c/li\u003e\n  \u003cli\u003e Reading from the released memory may produce a garbage value. \u003c/li\u003e\n  \u003cli\u003e When the memory was already reused to store sensitive data, such as passwords, it may lead to a vulnerability that uses this defect to extract\n  information from an instance of the program. \u003c/li\u003e\n  \u003cli\u003e Writing to released memory may change the value of the unrelated object in a remote part of the code if the memory was reused by it. As\n  different objects may reuse same the block of memory between runs, this leads to unintuitive and hard diagnose bugs. \u003c/li\u003e\n\u003c/ul\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eIn most situations, the use of an uninitialized object is a strong indication of a defect in the code, and fixing it requires a review of the\nobject allocation and deallocation strategies. Generally, the fix requires adjusting the code, so either:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Moving accesses to the memory before the deallocation \u003c/li\u003e\n  \u003cli\u003e Moving the deallocation so it happens after all the uses \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIf possible, it is desired to remove manual memory allocation, and replace it with stack-allocated objects, or in the case of C++, stack objects\nthat manage memory (using RAII idiom).\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nint *intArray \u003d (int*)malloc(sizeof(int)*10);\n// ...\nfree(intArray);\nintArray[9] \u003d 0;  // Noncompliant\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eRelease the memory after all of its uses.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nint *intArray \u003d (int*)malloc(sizeof(int)*10);\n// ...\nintArray[9] \u003d 0;  // Compliant\nfree(intArray);\n\u003c/pre\u003e\n\u003cp\u003eAlternatively, allocate the array on the stack, if the size of the array is known at compile-time:\u003c/p\u003e\n\u003cpre\u003e\nint intArray[10];\n// ...\nintArray[9] \u003d 0;  // Compliant\n\u003c/pre\u003e\n\u003cp\u003eIn C++, use \u003ccode\u003estd::vector\u003c/code\u003e with an arbitrary number of elements:\u003c/p\u003e\n\u003cpre\u003e\nstd::vector\u0026lt;int\u0026gt; intArray;\nintArray.resize(10);\n// ...\nintArray[9] \u003d 0;  // Compliant\n\u003c/pre\u003e\n\u003ch3\u003eGoing the extra mile\u003c/h3\u003e\n\u003cp\u003eIn C++, manually allocating and deallocating memory is considered a code smell.\u003c/p\u003e\n\u003cp\u003eIt is recommended to follow the \u003cem\u003eRAII\u003c/em\u003e idiom and create a class that manages the memory by allocating it when the object is constructed and\nfreeing it when it is destroyed. Furthermore, copy and move operations on such objects are designed such that this object can be passed by value\nbetween functions (either as an argument or by being returned) in place of raw pointers.\u003c/p\u003e\n\u003cp\u003eDepending on the type, passing an \u003cem\u003eRAII\u003c/em\u003e object operations may either:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Allocate a new block of memory and copy the elements (\u003ccode\u003estd::vector\u003c/code\u003e). \u003c/li\u003e\n  \u003cli\u003e Transfer ownership of the memory to constructed object (\u003ccode\u003estd::unique_ptr\u003c/code\u003e). \u003c/li\u003e\n  \u003cli\u003e Use shared ownership and free memory when the last object is destroyed (\u003ccode\u003estd::shared_ptr\u003c/code\u003e). \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis guarantees that accessing a memory managed by such an object is not released as long as such an object is not modified or destroyed (some\n\u003cem\u003eRAII\u003c/em\u003e types provide a stronger guarantee).\u003c/p\u003e\n\u003cpre\u003e\nstd::vector\u0026lt;int\u0026gt; intArray(10); // manages an array of 10 integers, on the heap\nstd::unique_ptr\u0026lt;Class\u0026gt; objPtr \u003d std::make_unique\u0026lt;Class\u0026gt;(); // manages an object on the heap\n\nintArray[5]; // OK\nobjPtr-\u0026gt;foo(); // OK\n\u003c/pre\u003e\n\u003cp\u003eHowever, any raw pointers or references to memory held by \u003cem\u003eRAII\u003c/em\u003e object may still lead to a use after free:\u003c/p\u003e\n\u003cpre\u003e\nint* p1 \u003d \u0026amp;intArray[0];    // becomes dangling when intArray is destroyed\nint* p2 \u003d intArray.data(); // same as above\nClass* p3 \u003d objPtr.get();  // becomes dangling, when objPtr releases the pointer\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/raii\"\u003eRAII\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/memory/unique_ptr\"\u003estd::unique_ptr\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/memory/shared_ptr\"\u003estd::shared_ptr\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/416\"\u003e416 - Use After Free\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/GdYxBQ\"\u003eMEM30-C - Do not access freed memory\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/onw-BQ\"\u003eMEM50-CPP - Do not access freed memory\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/OXw-BQ\"\u003eEXP54-CPP - Do not access an object outside of its lifetime\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e S5025 recommends avoiding manual memory management \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "cert",
      "cwe",
      "symbolic-execution"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S3520",
    "name": "Memory locations should not be released more than once",
    "defaultSeverity": "BLOCKER",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003cp\u003eDeallocating a memory location more than once leads to undefined behavior.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eUsing \u003ccode\u003edelete\u003c/code\u003e or \u003ccode\u003efree\u003c/code\u003e releases the reservation on a memory location, making it immediately available for another purpose.\nReleasing the exact memory location twice leads to undefined behavior and can often crash the program.\u003c/p\u003e\n\u003cp\u003eThe C standard defines as \u003cem\u003eundefined behavior\u003c/em\u003e a call to \u003ccode\u003efree\u003c/code\u003e with a pointer to a memory area that has already been\nreleased.\u003c/p\u003e\n\u003cp\u003eThe C++ standard defines the first \u003ccode\u003edelete\u003c/code\u003e call as the end of the lifetime for dynamically allocated memory. Access to memory past its\nlifetime end, including another \u003ccode\u003edelete\u003c/code\u003e, is undefined behavior.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact\u003c/h3\u003e\n\u003cp\u003eThe danger of a \"double-free\" comes directly from the fact that it is undefined behavior (in both C and C++). Note that there is no guarantee that\na crash will happen on a \"double-free\" when the resource is released or at all until the end of the program’s execution.\u003c/p\u003e\n\u003cp\u003eThe effects of a \"double-free\" depend entirely on the program’s memory management implementation. In the case of such an event, one of the\nfollowing can be observed:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The program’s memory-management data structures can become corrupted. This will usually cause a crash. \u003c/li\u003e\n  \u003cli\u003e Demonstrative Example 2 on \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/415\"\u003eCWE-415\u003c/a\u003e presents a set of circumstances where a crash does\n  not occur. In these circumstances, the corruption of the mentioned data structures causes two later calls to \u003ccode\u003emalloc\u003c/code\u003e to return the same\n  pointer. This can lead to a sensitive-data-exposure vulnerability or a buffer-overflow vulnerability. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eTo ensure that every release happens once, you can follow these best practices:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Release any allocated memory in the function it was acquired in. The release should be independent of any additional conditions. \u003c/li\u003e\n  \u003cli\u003e After a \u003ccode\u003edelete\u003c/code\u003e or \u003ccode\u003efree\u003c/code\u003e, set the pointer’s value to \u003ccode\u003enullptr\u003c/code\u003e or \u003ccode\u003eNULL\u003c/code\u003e. \u003ccode\u003edelete\u003c/code\u003e of\n  \u003ccode\u003enullptr\u003c/code\u003e and \u003ccode\u003efree\u003c/code\u003e of \u003ccode\u003eNULL\u003c/code\u003e are defined as having no effect. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003cp\u003eExample for C:\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid doSomething(int size) {\n  char* cp \u003d (char*) malloc(sizeof(char) * size);\n\n  // ...\n  if (condition) {\n    // ...\n    free(cp);\n  }\n\n  free(cp);  // Noncompliant: potential call to free in the above branch\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eRemove the unnecessary call to \u003ccode\u003efree\u003c/code\u003e:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid doSomething(int size) {\n  char* cp \u003d (char*) malloc(sizeof(char) * size);\n\n  // ...\n  if (condition) {\n    // ...\n  }\n\n  free(cp); // Compliant: no previous call to free in the above branch\n}\n\u003c/pre\u003e\n\u003cp\u003eSet the pointer to \u003ccode\u003eNULL\u003c/code\u003e after any call to \u003ccode\u003efree\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\nvoid doSomething(int size) {\n  char* cp \u003d (char*) malloc(sizeof(char) * size);\n\n  // ...\n  if (condition) {\n    // ...\n    free(cp);\n    cp \u003d NULL; // This will prevent freeing the same memory again\n  }\n\n  free(cp); // Compliant: if the memory was freed in the if-block above, free(NULL) is a no-op\n}\n\u003c/pre\u003e\n\u003cp\u003eExample for C++:\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid doSomething(int size) {\n  std::string* p \u003d new std::string;\n\n  // ...\n  if (condition) {\n    // ...\n    delete p;\n  }\n\n  delete p;  // Noncompliant: potential invocation of delete in the above branch\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eRemove the unnecessary invocation of \u003ccode\u003edelete\u003c/code\u003e:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\nvoid doSomething(int size) {\n  std::string* p \u003d new std::string;\n\n  // ...\n  if (condition) {\n    // ...\n  }\n\n  delete p; // Compliant: no previous call to free in the above branch\n}\n\u003c/pre\u003e\n\u003cp\u003eSet the pointer to \u003ccode\u003enullptr\u003c/code\u003e after invoking \u003ccode\u003edelete\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\nvoid doSomething(int size) {\n  std::string* p \u003d new std::string;\n\n  // ...\n  if (condition) {\n    // ...\n    delete p;\n    p \u003d nullptr; // This will prevent freeing the same memory again\n  }\n\n  delete p; // Compliant: if the memory was freed in the if-block above, operator delete of nullptr is a no-op\n}\n\u003c/pre\u003e\n\u003ch3\u003eGoing the extra mile\u003c/h3\u003e\n\u003cp\u003eIn C++, manually allocating and deallocating memory is considered a code smell.\u003c/p\u003e\n\u003cp\u003eIt is recommended to follow the \u003cem\u003eRAII\u003c/em\u003e idiom and create a class that manages the memory by allocating it when the object is constructed and\nfreeing it when it is destroyed. Furthermore, copy and move operations on such objects are designed such that this object can be passed by value\nbetween functions (either as an argument or by being returned) in place of raw pointers.\u003c/p\u003e\n\u003cp\u003eDepending on the type, passing an \u003cem\u003eRAII\u003c/em\u003e object operations may either:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Allocate a new block of memory and copy the elements (\u003ccode\u003estd::vector\u003c/code\u003e). \u003c/li\u003e\n  \u003cli\u003e Transfer ownership of the memory to constructed object (\u003ccode\u003estd::unique_ptr\u003c/code\u003e). \u003c/li\u003e\n  \u003cli\u003e Use shared ownership and free memory when the last object is destroyed (\u003ccode\u003estd::shared_ptr\u003c/code\u003e). \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eUsing \u003cem\u003eRAII\u003c/em\u003e objects instead of manual memory management can mitigate most dynamic memory management issues, including \"double-free\".\u003c/p\u003e\n\u003cpre\u003e\nvoid doSomething(int size) {\n  auto p \u003d std::make_unique\u0026lt;std::string\u0026gt;();\n\n  // ...\n  if (condition) {\n    p.reset(); // Delete happens here.\n  }\n\n  // delete not called by std::unique_ptr destructor if the branch above was taken.\n}\n\u003c/pre\u003e\n\u003ch3\u003ePitfalls\u003c/h3\u003e\n\u003cp\u003eHowever, keeping a raw pointer or a reference to memory held by \u003cem\u003eRAII\u003c/em\u003e objects may still lead to a \"double-free\". Care must be taken to\navoid the following pitfalls:\u003c/p\u003e\n\u003ch4\u003eInitialization of \u003ccode\u003estd::shared_ptr\u003c/code\u003e\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003estd::shared_ptr\u003c/code\u003e relies on an internal counter of owners inside a \"control block\". This control block is either created when the object\nis constructed with a raw pointer or inherited when constructed from another \u003ccode\u003estd::shared_ptr\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eMisunderstanding this can lead to a \"double-free\", as the following example demonstrates.\u003c/p\u003e\n\u003cp\u003eNoncompliant code example\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid doSomething(char const* data) {\n  std::shared_ptr\u0026lt;std::string\u0026gt; p1(new std::string(data));\n  std::shared_ptr\u0026lt;std::string\u0026gt; p2(p1.get()); // Noncompliant: Intended: std::shared_ptr\u0026lt;string\u0026gt; p2(p1);\n}\n\u003c/pre\u003e\n\u003cp\u003eBoth objects are created from the raw pointer, leading them to have independent control blocks. Both will attempt to release the original memory\narea.\u003c/p\u003e\n\u003cp\u003eTo avoid this, only use copy/move construction for sharing ownership or the \u003ccode\u003estd::make_shared\u003c/code\u003e for initialization.\u003c/p\u003e\n\u003cp\u003eCompliant solution\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"compliant\"\u003e\nvoid doSomething(char const* data) {\n  auto p1 \u003d std::make_shared\u0026lt;std::string\u0026gt;(data);\n  auto p2 \u003d p1; // Compliant\n}\n\u003c/pre\u003e\n\u003ch4\u003eInitialization of \u003ccode\u003estd::unique_ptr\u003c/code\u003e\u003c/h4\u003e\n\u003cp\u003eSimilar to \u003ccode\u003estd::shared_ptr\u003c/code\u003e, a \"double-free\" can occur from an erroneous initialization. This also comes from confusion raised by the\nconstructor overloads of this class.\u003c/p\u003e\n\u003cp\u003eNoncompliant code example\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"4\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid doSomething(char const* data) {\n  // Creating another unique_ptr\n  std::unique_ptr\u0026lt;std::string\u0026gt; p1(new std::string(data));\n  // ...\n  std::unique_ptr\u0026lt;std::string\u0026gt; p2(p1.get()); // Noncompliant: both p1 and p2 own the pointer now.\n\n  // Transfering ownership\n  std::unqiue_ptr\u0026lt;std::string\u0026gt; p3(new std::string(data));\n  // ...\n  std::unique_ptr\u0026lt;std::string\u0026gt; p4(p3.get()); // Noncompliant: both p3 and p4 own the pointer now.\n}\n\u003c/pre\u003e\n\u003cp\u003eAs with \u003ccode\u003estd::shared_ptr\u003c/code\u003e, using \u003ccode\u003estd::make_unique\u003c/code\u003e avoids this pitfall. It does not accept a pointer to an existing object\nbut only creates a new one.\u003c/p\u003e\n\u003cp\u003eCompliant solution\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"4\" data-diff-type\u003d\"compliant\"\u003e\nvoid doSomething(char const* data) {\n  // Creating another unique_ptr\n  auto p1 \u003d std::make_unique\u0026lt;std::string\u0026gt;(data);\n  // ...\n  auto p2 \u003d std::make_unique\u0026lt;std::string\u0026gt;(*p1); // Compliant: Creates a copy.\n\n  // Transfering ownership\n  auto p3 \u003d std::make_unique\u0026lt;std::string\u0026gt;(data);\n  auto p4 \u003d std::move(p3); // Compliant: Will invoke move constructor, which is present in std::unique_ptr.\n}\n\u003c/pre\u003e\n\u003ch4\u003eOut-of-scope access\u003c/h4\u003e\n\u003cp\u003eExtra care must be taken when passing the memory address contained in an RAII object.\u003c/p\u003e\n\u003cp\u003eBoth \u003ccode\u003estd::shared_ptr\u003c/code\u003e and \u003ccode\u003estd::unique_ptr\u003c/code\u003e provide the \u003ccode\u003eget\u003c/code\u003e method to obtain a raw pointer to the contained\nmemory. This should only be used to read the data. Passing this pointer to a function that might release it can lead to a \"double-free\" and\n\"use-after-free\".\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/memory/unique_ptr\"\u003estd::unique_ptr\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/memory/unique_ptr/make_unique\"\u003estd::make_unique\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/memory/shared_ptr\"\u003estd::shared_ptr\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/memory/shared_ptr/make_shared\"\u003estd::make_shared\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/415\"\u003e415 Double Free\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/GdYxBQ\"\u003eMEM30-C - Do not access freed memory\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/Gns-BQ\"\u003eMEM51-CPP - Properly deallocate dynamically allocated resources\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/Zns-BQ\"\u003eMEM56-CPP - Do not store an already-owned pointer value in an unrelated smart\n  pointer\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e OWASP - \u003ca href\u003d\"https://owasp.org/www-community/vulnerabilities/Doubly_freeing_memory\"\u003eDoubly freeing memory\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e S5025 recommends avoiding manual memory management \u003c/li\u003e\n  \u003cli\u003e {rule:c:S3529} refers to \"use-after-free\", an issue with similar causes. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eDeallocating a memory location more than once leads to undefined behavior.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eUsing \u003ccode\u003edelete\u003c/code\u003e or \u003ccode\u003efree\u003c/code\u003e releases the reservation on a memory location, making it immediately available for another purpose.\nReleasing the exact memory location twice leads to undefined behavior and can often crash the program.\u003c/p\u003e\n\u003cp\u003eThe C standard defines as \u003cem\u003eundefined behavior\u003c/em\u003e a call to \u003ccode\u003efree\u003c/code\u003e with a pointer to a memory area that has already been\nreleased.\u003c/p\u003e\n\u003cp\u003eThe C++ standard defines the first \u003ccode\u003edelete\u003c/code\u003e call as the end of the lifetime for dynamically allocated memory. Access to memory past its\nlifetime end, including another \u003ccode\u003edelete\u003c/code\u003e, is undefined behavior.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact\u003c/h3\u003e\n\u003cp\u003eThe danger of a \"double-free\" comes directly from the fact that it is undefined behavior (in both C and C++). Note that there is no guarantee that\na crash will happen on a \"double-free\" when the resource is released or at all until the end of the program’s execution.\u003c/p\u003e\n\u003cp\u003eThe effects of a \"double-free\" depend entirely on the program’s memory management implementation. In the case of such an event, one of the\nfollowing can be observed:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The program’s memory-management data structures can become corrupted. This will usually cause a crash. \u003c/li\u003e\n  \u003cli\u003e Demonstrative Example 2 on \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/415\"\u003eCWE-415\u003c/a\u003e presents a set of circumstances where a crash does\n  not occur. In these circumstances, the corruption of the mentioned data structures causes two later calls to \u003ccode\u003emalloc\u003c/code\u003e to return the same\n  pointer. This can lead to a sensitive-data-exposure vulnerability or a buffer-overflow vulnerability. \u003c/li\u003e\n\u003c/ul\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eTo ensure that every release happens once, you can follow these best practices:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Release any allocated memory in the function it was acquired in. The release should be independent of any additional conditions. \u003c/li\u003e\n  \u003cli\u003e After a \u003ccode\u003edelete\u003c/code\u003e or \u003ccode\u003efree\u003c/code\u003e, set the pointer’s value to \u003ccode\u003enullptr\u003c/code\u003e or \u003ccode\u003eNULL\u003c/code\u003e. \u003ccode\u003edelete\u003c/code\u003e of\n  \u003ccode\u003enullptr\u003c/code\u003e and \u003ccode\u003efree\u003c/code\u003e of \u003ccode\u003eNULL\u003c/code\u003e are defined as having no effect. \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eExample for C:\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid doSomething(int size) {\n  char* cp \u003d (char*) malloc(sizeof(char) * size);\n\n  // ...\n  if (condition) {\n    // ...\n    free(cp);\n  }\n\n  free(cp);  // Noncompliant: potential call to free in the above branch\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eRemove the unnecessary call to \u003ccode\u003efree\u003c/code\u003e:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid doSomething(int size) {\n  char* cp \u003d (char*) malloc(sizeof(char) * size);\n\n  // ...\n  if (condition) {\n    // ...\n  }\n\n  free(cp); // Compliant: no previous call to free in the above branch\n}\n\u003c/pre\u003e\n\u003cp\u003eSet the pointer to \u003ccode\u003eNULL\u003c/code\u003e after any call to \u003ccode\u003efree\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\nvoid doSomething(int size) {\n  char* cp \u003d (char*) malloc(sizeof(char) * size);\n\n  // ...\n  if (condition) {\n    // ...\n    free(cp);\n    cp \u003d NULL; // This will prevent freeing the same memory again\n  }\n\n  free(cp); // Compliant: if the memory was freed in the if-block above, free(NULL) is a no-op\n}\n\u003c/pre\u003e\n\u003cp\u003eExample for C++:\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid doSomething(int size) {\n  std::string* p \u003d new std::string;\n\n  // ...\n  if (condition) {\n    // ...\n    delete p;\n  }\n\n  delete p;  // Noncompliant: potential invocation of delete in the above branch\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eRemove the unnecessary invocation of \u003ccode\u003edelete\u003c/code\u003e:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\nvoid doSomething(int size) {\n  std::string* p \u003d new std::string;\n\n  // ...\n  if (condition) {\n    // ...\n  }\n\n  delete p; // Compliant: no previous call to free in the above branch\n}\n\u003c/pre\u003e\n\u003cp\u003eSet the pointer to \u003ccode\u003enullptr\u003c/code\u003e after invoking \u003ccode\u003edelete\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\nvoid doSomething(int size) {\n  std::string* p \u003d new std::string;\n\n  // ...\n  if (condition) {\n    // ...\n    delete p;\n    p \u003d nullptr; // This will prevent freeing the same memory again\n  }\n\n  delete p; // Compliant: if the memory was freed in the if-block above, operator delete of nullptr is a no-op\n}\n\u003c/pre\u003e\n\u003ch3\u003eGoing the extra mile\u003c/h3\u003e\n\u003cp\u003eIn C++, manually allocating and deallocating memory is considered a code smell.\u003c/p\u003e\n\u003cp\u003eIt is recommended to follow the \u003cem\u003eRAII\u003c/em\u003e idiom and create a class that manages the memory by allocating it when the object is constructed and\nfreeing it when it is destroyed. Furthermore, copy and move operations on such objects are designed such that this object can be passed by value\nbetween functions (either as an argument or by being returned) in place of raw pointers.\u003c/p\u003e\n\u003cp\u003eDepending on the type, passing an \u003cem\u003eRAII\u003c/em\u003e object operations may either:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Allocate a new block of memory and copy the elements (\u003ccode\u003estd::vector\u003c/code\u003e). \u003c/li\u003e\n  \u003cli\u003e Transfer ownership of the memory to constructed object (\u003ccode\u003estd::unique_ptr\u003c/code\u003e). \u003c/li\u003e\n  \u003cli\u003e Use shared ownership and free memory when the last object is destroyed (\u003ccode\u003estd::shared_ptr\u003c/code\u003e). \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eUsing \u003cem\u003eRAII\u003c/em\u003e objects instead of manual memory management can mitigate most dynamic memory management issues, including \"double-free\".\u003c/p\u003e\n\u003cpre\u003e\nvoid doSomething(int size) {\n  auto p \u003d std::make_unique\u0026lt;std::string\u0026gt;();\n\n  // ...\n  if (condition) {\n    p.reset(); // Delete happens here.\n  }\n\n  // delete not called by std::unique_ptr destructor if the branch above was taken.\n}\n\u003c/pre\u003e\n\u003ch3\u003ePitfalls\u003c/h3\u003e\n\u003cp\u003eHowever, keeping a raw pointer or a reference to memory held by \u003cem\u003eRAII\u003c/em\u003e objects may still lead to a \"double-free\". Care must be taken to\navoid the following pitfalls:\u003c/p\u003e\n\u003ch4\u003eInitialization of \u003ccode\u003estd::shared_ptr\u003c/code\u003e\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003estd::shared_ptr\u003c/code\u003e relies on an internal counter of owners inside a \"control block\". This control block is either created when the object\nis constructed with a raw pointer or inherited when constructed from another \u003ccode\u003estd::shared_ptr\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eMisunderstanding this can lead to a \"double-free\", as the following example demonstrates.\u003c/p\u003e\n\u003cp\u003eNoncompliant code example\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid doSomething(char const* data) {\n  std::shared_ptr\u0026lt;std::string\u0026gt; p1(new std::string(data));\n  std::shared_ptr\u0026lt;std::string\u0026gt; p2(p1.get()); // Noncompliant: Intended: std::shared_ptr\u0026lt;string\u0026gt; p2(p1);\n}\n\u003c/pre\u003e\n\u003cp\u003eBoth objects are created from the raw pointer, leading them to have independent control blocks. Both will attempt to release the original memory\narea.\u003c/p\u003e\n\u003cp\u003eTo avoid this, only use copy/move construction for sharing ownership or the \u003ccode\u003estd::make_shared\u003c/code\u003e for initialization.\u003c/p\u003e\n\u003cp\u003eCompliant solution\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"compliant\"\u003e\nvoid doSomething(char const* data) {\n  auto p1 \u003d std::make_shared\u0026lt;std::string\u0026gt;(data);\n  auto p2 \u003d p1; // Compliant\n}\n\u003c/pre\u003e\n\u003ch4\u003eInitialization of \u003ccode\u003estd::unique_ptr\u003c/code\u003e\u003c/h4\u003e\n\u003cp\u003eSimilar to \u003ccode\u003estd::shared_ptr\u003c/code\u003e, a \"double-free\" can occur from an erroneous initialization. This also comes from confusion raised by the\nconstructor overloads of this class.\u003c/p\u003e\n\u003cp\u003eNoncompliant code example\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"4\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid doSomething(char const* data) {\n  // Creating another unique_ptr\n  std::unique_ptr\u0026lt;std::string\u0026gt; p1(new std::string(data));\n  // ...\n  std::unique_ptr\u0026lt;std::string\u0026gt; p2(p1.get()); // Noncompliant: both p1 and p2 own the pointer now.\n\n  // Transfering ownership\n  std::unqiue_ptr\u0026lt;std::string\u0026gt; p3(new std::string(data));\n  // ...\n  std::unique_ptr\u0026lt;std::string\u0026gt; p4(p3.get()); // Noncompliant: both p3 and p4 own the pointer now.\n}\n\u003c/pre\u003e\n\u003cp\u003eAs with \u003ccode\u003estd::shared_ptr\u003c/code\u003e, using \u003ccode\u003estd::make_unique\u003c/code\u003e avoids this pitfall. It does not accept a pointer to an existing object\nbut only creates a new one.\u003c/p\u003e\n\u003cp\u003eCompliant solution\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"4\" data-diff-type\u003d\"compliant\"\u003e\nvoid doSomething(char const* data) {\n  // Creating another unique_ptr\n  auto p1 \u003d std::make_unique\u0026lt;std::string\u0026gt;(data);\n  // ...\n  auto p2 \u003d std::make_unique\u0026lt;std::string\u0026gt;(*p1); // Compliant: Creates a copy.\n\n  // Transfering ownership\n  auto p3 \u003d std::make_unique\u0026lt;std::string\u0026gt;(data);\n  auto p4 \u003d std::move(p3); // Compliant: Will invoke move constructor, which is present in std::unique_ptr.\n}\n\u003c/pre\u003e\n\u003ch4\u003eOut-of-scope access\u003c/h4\u003e\n\u003cp\u003eExtra care must be taken when passing the memory address contained in an RAII object.\u003c/p\u003e\n\u003cp\u003eBoth \u003ccode\u003estd::shared_ptr\u003c/code\u003e and \u003ccode\u003estd::unique_ptr\u003c/code\u003e provide the \u003ccode\u003eget\u003c/code\u003e method to obtain a raw pointer to the contained\nmemory. This should only be used to read the data. Passing this pointer to a function that might release it can lead to a \"double-free\" and\n\"use-after-free\".\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/memory/unique_ptr\"\u003estd::unique_ptr\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/memory/unique_ptr/make_unique\"\u003estd::make_unique\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/memory/shared_ptr\"\u003estd::shared_ptr\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/memory/shared_ptr/make_shared\"\u003estd::make_shared\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/415\"\u003e415 Double Free\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/GdYxBQ\"\u003eMEM30-C - Do not access freed memory\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/Gns-BQ\"\u003eMEM51-CPP - Properly deallocate dynamically allocated resources\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/Zns-BQ\"\u003eMEM56-CPP - Do not store an already-owned pointer value in an unrelated smart\n  pointer\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e OWASP - \u003ca href\u003d\"https://owasp.org/www-community/vulnerabilities/Doubly_freeing_memory\"\u003eDoubly freeing memory\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e S5025 recommends avoiding manual memory management \u003c/li\u003e\n  \u003cli\u003e {rule:c:S3529} refers to \"use-after-free\", an issue with similar causes. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "cwe",
      "symbolic-execution"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S5266",
    "name": "Keywords shall not be used as macros identifiers",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eIn programming languages, keywords have a special meaning and are reserved for the language. Hence, it is a bad idea to define macros with keywords\nas macro identifiers as it can easily lead to undefined behavior:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The same object might be defined differently in different places, which violates the One Definition Rule \u003c/li\u003e\n  \u003cli\u003e If you include any header from the standard library, it is undefined behavior to define such macros \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eAdditionally, it is awkward for anyone reading the code to have a keyword that means something different.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#define int some_other_type // Noncompliant\n#include \u0026lt;stdlib.h\u0026gt;\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Wikipedia - \u003ca href\u003d\"https://en.wikipedia.org/wiki/One_Definition_Rule\"\u003eOne Definition Rule\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/definition\"\u003eDefinitions and ODR (One Definition Rule)\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2012, 20.4 -\u0026nbsp;A macro shall not be defined with the same name as a keyword \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eIn programming languages, keywords have a special meaning and are reserved for the language. Hence, it is a bad idea to define macros with keywords\nas macro identifiers as it can easily lead to undefined behavior:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The same object might be defined differently in different places, which violates the One Definition Rule \u003c/li\u003e\n  \u003cli\u003e If you include any header from the standard library, it is undefined behavior to define such macros \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eAdditionally, it is awkward for anyone reading the code to have a keyword that means something different.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#define int some_other_type // Noncompliant\n#include \u0026lt;stdlib.h\u0026gt;\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Wikipedia - \u003ca href\u003d\"https://en.wikipedia.org/wiki/One_Definition_Rule\"\u003eOne Definition Rule\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/definition\"\u003eDefinitions and ODR (One Definition Rule)\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2012, 20.4 -\u0026nbsp;A macro shall not be defined with the same name as a keyword \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "based-on-misra",
      "pitfall",
      "unpredictable"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S5267",
    "name": "Functions with \"noreturn\" attribute should not return",
    "defaultSeverity": "BLOCKER",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe \"noreturn\" attribute should be used to indicate that a function does not return to its caller: it may terminate the program, enter an infinite\nloop, or throw an exception.\u003c/p\u003e\n\u003cp\u003eThis attribute is typically used for functions that perform critical operations, such as exiting the program or handling an error condition. For\nexample, the \"exit\" function is marked with the \"noreturn\" attribute because it terminates the program and does not return to its caller.\u003c/p\u003e\n\u003cp\u003eUsing this attribute allows the compiler to make some assumptions that can lead to optimizations. However, functions marked with the \"noreturn\"\nattribute should not have a return statement because it leads to undefined behavior and unexpected results.\u003c/p\u003e\n\u003cp\u003eThis rules equally applies to C++11 \u003ccode\u003e[[noreturn]]\u003c/code\u003e notation or C11 \u003ccode\u003e_Noreturn\u003c/code\u003e keyword notation. It raises an issue when the\nattribute is incorrectly used.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eThere are two opposite approaches to fix this issue: remove the \"noreturn\" attribute or update the function to never return.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre\u003e\nint global;\n\n[[noreturn]]\nvoid longRunningTask() {\n  while (true) {\n    // ...\n    if (global \u003d\u003d 0) {\n      return; // Noncompliant: this function should not return.\n    }\n  }\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eThere are many ways to address the issue in the previous code snippet. Here are some examples.\u003c/p\u003e\n\u003cp\u003eIt can be updated to never return:\u003c/p\u003e\n\u003cpre\u003e\n[[noreturn]]\nvoid longRunningTask() {\n  while (true) {\n    // ...\n  }\n}\n\u003c/pre\u003e\n\u003cp\u003eOr the \"noreturn\" attribute can be removed:\u003c/p\u003e\n\u003cpre\u003e\nvoid longRunningTask() {\n  while (true) {\n    // ...\n    if (global \u003d\u003d 0) {\n      return;\n    }\n  }\n}\n\u003c/pre\u003e\n\u003cp\u003eOr, in C++, the return statement can be turned into a throw expression:\u003c/p\u003e\n\u003cpre\u003e\n[[noreturn]]\nvoid longRunningTask() {\n  while (true) {\n    // ...\n    if (global \u003d\u003d 0) {\n      throw std::runtime_error(\"invalid global state\");\n    }\n  }\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/attributes/noreturn\"\u003eC++ attribute: noreturn\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/c/language/_Noreturn\"\u003e_Noreturn function specifier\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe \"noreturn\" attribute should be used to indicate that a function does not return to its caller: it may terminate the program, enter an infinite\nloop, or throw an exception.\u003c/p\u003e\n\u003cp\u003eThis attribute is typically used for functions that perform critical operations, such as exiting the program or handling an error condition. For\nexample, the \"exit\" function is marked with the \"noreturn\" attribute because it terminates the program and does not return to its caller.\u003c/p\u003e\n\u003cp\u003eUsing this attribute allows the compiler to make some assumptions that can lead to optimizations. However, functions marked with the \"noreturn\"\nattribute should not have a return statement because it leads to undefined behavior and unexpected results.\u003c/p\u003e\n\u003cp\u003eThis rules equally applies to C++11 \u003ccode\u003e[[noreturn]]\u003c/code\u003e notation or C11 \u003ccode\u003e_Noreturn\u003c/code\u003e keyword notation. It raises an issue when the\nattribute is incorrectly used.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eThere are two opposite approaches to fix this issue: remove the \"noreturn\" attribute or update the function to never return.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre\u003e\nint global;\n\n[[noreturn]]\nvoid longRunningTask() {\n  while (true) {\n    // ...\n    if (global \u003d\u003d 0) {\n      return; // Noncompliant: this function should not return.\n    }\n  }\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eThere are many ways to address the issue in the previous code snippet. Here are some examples.\u003c/p\u003e\n\u003cp\u003eIt can be updated to never return:\u003c/p\u003e\n\u003cpre\u003e\n[[noreturn]]\nvoid longRunningTask() {\n  while (true) {\n    // ...\n  }\n}\n\u003c/pre\u003e\n\u003cp\u003eOr the \"noreturn\" attribute can be removed:\u003c/p\u003e\n\u003cpre\u003e\nvoid longRunningTask() {\n  while (true) {\n    // ...\n    if (global \u003d\u003d 0) {\n      return;\n    }\n  }\n}\n\u003c/pre\u003e\n\u003cp\u003eOr, in C++, the return statement can be turned into a throw expression:\u003c/p\u003e\n\u003cpre\u003e\n[[noreturn]]\nvoid longRunningTask() {\n  while (true) {\n    // ...\n    if (global \u003d\u003d 0) {\n      throw std::runtime_error(\"invalid global state\");\n    }\n  }\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/attributes/noreturn\"\u003eC++ attribute: noreturn\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/c/language/_Noreturn\"\u003e_Noreturn function specifier\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "confusing"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S1103",
    "name": "\"/*\" and \"//\" should not be used within comments",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eDefining a nested single-line comment within a multi-line comment invites errors. It may lead a developer to wrongly think that the lines located\nafter the single-line comment are not part of the comment.\u003c/p\u003e\n\u003cp\u003eIf a comment starting sequence, \u003ccode\u003e/*\u003c/code\u003e or \u003ccode\u003e//\u003c/code\u003e, occurs within a \u003ccode\u003e/*\u003c/code\u003e comment, is it quite likely to be caused by a\nmissing \u003ccode\u003e*/\u003c/code\u003e comment ending sequence.\u003c/p\u003e\n\u003cp\u003eIf a comment starting sequence occurs within a \u003ccode\u003e//\u003c/code\u003e comment, it is probably because a region of code has been commented-out using\n\u003ccode\u003e//\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n/* some comment, end comment marker accidentally omitted\n// Make sure this function is called in a thread safe context\nPerform_Critical_Safety_Function(X);\n...\n/* this comment is non-compliant */\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThe sequence // is permitted within a // comment.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/k9YxBQ\"\u003eCERT, MSC04-C.\u003c/a\u003e - Use comments consistently and in a readable fashion \u003c/li\u003e\n  \u003cli\u003e MISRA C:2004, 2.3 - The character sequence /* shall not be used within a comment. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 2-7-1 - The character sequence /* shall not be used within a C-style comment. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 3.1 - The character sequences /* and // shall not be used within a comment \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eDefining a nested single-line comment within a multi-line comment invites errors. It may lead a developer to wrongly think that the lines located\nafter the single-line comment are not part of the comment.\u003c/p\u003e\n\u003cp\u003eIf a comment starting sequence, \u003ccode\u003e/*\u003c/code\u003e or \u003ccode\u003e//\u003c/code\u003e, occurs within a \u003ccode\u003e/*\u003c/code\u003e comment, is it quite likely to be caused by a\nmissing \u003ccode\u003e*/\u003c/code\u003e comment ending sequence.\u003c/p\u003e\n\u003cp\u003eIf a comment starting sequence occurs within a \u003ccode\u003e//\u003c/code\u003e comment, it is probably because a region of code has been commented-out using\n\u003ccode\u003e//\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n/* some comment, end comment marker accidentally omitted\n// Make sure this function is called in a thread safe context\nPerform_Critical_Safety_Function(X);\n...\n/* this comment is non-compliant */\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThe sequence // is permitted within a // comment.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/k9YxBQ\"\u003eCERT, MSC04-C.\u003c/a\u003e - Use comments consistently and in a readable fashion \u003c/li\u003e\n  \u003cli\u003e MISRA C:2004, 2.3 - The character sequence /* shall not be used within a comment. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 2-7-1 - The character sequence /* shall not be used within a C-style comment. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 3.1 - The character sequences /* and // shall not be used within a comment \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "based-on-misra",
      "cert",
      "confusing"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S5491",
    "name": "Enums should be consistent with the bit fields they initialize",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eBit fields can only have integral or enumeration type. If it is quite straightforward to check if an integral type can initialize a bit field, it\nis however trickier with an enum type: the bit field has to be wide enough to store all the possible values of the enum.\u003c/p\u003e\n\u003cp\u003eIn addition to this, the signedness of the enum should be consistent with the signedness of the bit field:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e an unsigned bit field can not be initialized with a signed enum type \u003c/li\u003e\n  \u003cli\u003e a signed bit field uses one bit to store the sign and this needs to be taken into account while comparing the size of the enum type with the\n  size of the bit field. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nenum Color {\n  BLUE \u003d 16\n} myColor;\n\nenum Fruit {\n  ORANGE \u003d 1,\n  APPLE \u003d 2\n} myFruit;\n\nstruct BitStructForColor {\n    unsigned int b : 2;\n};\n\nstruct BitStructForFruit {\n    signed int b : 2;\n};\n\nvoid f(BitStructForColor  \u0026amp;bColorStruct, BitStructForFruit  \u0026amp;bFruitStruct) {\n  bColorStruct.b \u003d myColor; // Noncompliant, myColor is too wide for the bit field\n  bFruitStruct.b \u003d myFruit; // Noncompliant, one bit of the bit field is used to store the sign\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nenum Color {\n  BLUE \u003d 16\n} myColor;\n\nenum Fruit {\n  ORANGE \u003d 1,\n  APPLE \u003d 2\n} myFruit;\n\nstruct BitStructForColor {\n    unsigned int b : 5;\n};\n\nstruct BitStructForFruit {\n    signed int b : 3;\n};\n\nvoid f(BitStructForColor  \u0026amp;bColorStruct, BitStructForFruit  \u0026amp;bFruitStruct) {\n  bColorStruct.b \u003d myColor;\n  bFruitStruct.b \u003d myFruit;\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eBit fields can only have integral or enumeration type. If it is quite straightforward to check if an integral type can initialize a bit field, it\nis however trickier with an enum type: the bit field has to be wide enough to store all the possible values of the enum.\u003c/p\u003e\n\u003cp\u003eIn addition to this, the signedness of the enum should be consistent with the signedness of the bit field:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e an unsigned bit field can not be initialized with a signed enum type \u003c/li\u003e\n  \u003cli\u003e a signed bit field uses one bit to store the sign and this needs to be taken into account while comparing the size of the enum type with the\n  size of the bit field. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nenum Color {\n  BLUE \u003d 16\n} myColor;\n\nenum Fruit {\n  ORANGE \u003d 1,\n  APPLE \u003d 2\n} myFruit;\n\nstruct BitStructForColor {\n    unsigned int b : 2;\n};\n\nstruct BitStructForFruit {\n    signed int b : 2;\n};\n\nvoid f(BitStructForColor  \u0026amp;bColorStruct, BitStructForFruit  \u0026amp;bFruitStruct) {\n  bColorStruct.b \u003d myColor; // Noncompliant, myColor is too wide for the bit field\n  bFruitStruct.b \u003d myFruit; // Noncompliant, one bit of the bit field is used to store the sign\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nenum Color {\n  BLUE \u003d 16\n} myColor;\n\nenum Fruit {\n  ORANGE \u003d 1,\n  APPLE \u003d 2\n} myFruit;\n\nstruct BitStructForColor {\n    unsigned int b : 5;\n};\n\nstruct BitStructForFruit {\n    signed int b : 3;\n};\n\nvoid f(BitStructForColor  \u0026amp;bColorStruct, BitStructForFruit  \u0026amp;bFruitStruct) {\n  bColorStruct.b \u003d myColor;\n  bFruitStruct.b \u003d myFruit;\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S787",
    "name": "Source code should only use /* ... */ style comments",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThis excludes the use of \u003ccode\u003e//\u003c/code\u003e C99 style comments and C++ style comments, since these are not permitted in C90. Many compilers support\nthe \u003ccode\u003e//\u003c/code\u003e style of comments as an extension to C90. The use of \u003ccode\u003e//\u003c/code\u003e in preprocessor directives (e.g. \u003ccode\u003e#define\u003c/code\u003e) can\nvary. Also the mixing of \u003ccode\u003e/* ... */\u003c/code\u003e and \u003ccode\u003e//\u003c/code\u003e is not consistent. This is more than a style issue, since different (pre C99)\ncompilers may behave differently.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint main(int argc, char* argv[])\n{\n  // Do nothing - Noncompliant\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint main(int argc, char* argv[])\n{\n  /* Do nothing - Compliant */\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 2.2 - Source code shall only use /* …​ */ style comments. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThis excludes the use of \u003ccode\u003e//\u003c/code\u003e C99 style comments and C++ style comments, since these are not permitted in C90. Many compilers support\nthe \u003ccode\u003e//\u003c/code\u003e style of comments as an extension to C90. The use of \u003ccode\u003e//\u003c/code\u003e in preprocessor directives (e.g. \u003ccode\u003e#define\u003c/code\u003e) can\nvary. Also the mixing of \u003ccode\u003e/* ... */\u003c/code\u003e and \u003ccode\u003e//\u003c/code\u003e is not consistent. This is more than a style issue, since different (pre C99)\ncompilers may behave differently.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint main(int argc, char* argv[])\n{\n  // Do nothing - Noncompliant\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint main(int argc, char* argv[])\n{\n  /* Do nothing - Compliant */\n  return 0;\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 2.2 - Source code shall only use /* …​ */ style comments. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "based-on-misra",
      "convention"
    ],
    "deprecatedKeys": [
      "c:C99CommentUsage"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S784",
    "name": "Assembly language should be encapsulated and isolated",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "MODULAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eEnsuring that assembly language code is encapsulated and isolated aids portability. Where assembly language instructions are needed, they shall be\nencapsulated and isolated in either assembler functions or C++ functions.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid fn ( void )\n{\n  DoSomething ( );\n  asm ( \"NOP\" ); // Noncompliant, asm mixed with C/C++ statements\n  DoSomething ( );\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid Delay ( void )\n{\n  asm ( \"NOP\" ); // Compliant, asm not mixed with C/C++ statements\n}\n\nvoid fn ( void )\n{\n  DoSomething ( );\n  Delay ( ); // Compliant, Assembler is encapsulated\n  DoSomething ( );\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C 2004, 2.1 - Assembly language shall be encapsulated and isolated. \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2008, 7-4-3 - Assembly language shall be encapsulated and isolated. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eEnsuring that assembly language code is encapsulated and isolated aids portability. Where assembly language instructions are needed, they shall be\nencapsulated and isolated in either assembler functions or C++ functions.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid fn ( void )\n{\n  DoSomething ( );\n  asm ( \"NOP\" ); // Noncompliant, asm mixed with C/C++ statements\n  DoSomething ( );\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid Delay ( void )\n{\n  asm ( \"NOP\" ); // Compliant, asm not mixed with C/C++ statements\n}\n\nvoid fn ( void )\n{\n  DoSomething ( );\n  Delay ( ); // Compliant, Assembler is encapsulated\n  DoSomething ( );\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C 2004, 2.1 - Assembly language shall be encapsulated and isolated. \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2008, 7-4-3 - Assembly language shall be encapsulated and isolated. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "misra-c++2008",
      "misra-c2004"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S5494",
    "name": "Size of bit fields should not exceed the size of their types",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eBit fields allow the developers to declare a class member with a specific size.\u003c/p\u003e\n\u003cp\u003eHowever, the size of a bit field is also constrained by its type: even if the specified size is greater than the size of the type, the value of the\nbit field will not exceed the maximum value of this type. The extra bits will just create unused padding.\u003c/p\u003e\n\u003cp\u003eThe incompatibility of the size of the type with the specified size can have two causes: either the specified size is a typo error (that is the\nmost probable cause) or the developer did not realize the size of the type he chose was too small.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass A {\n  unsigned int b : 55; // Noncompliant, specified size is greater than the size of unsigned int\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nclass A {\n  unsigned int b : 32;\n};\n\u003c/pre\u003e\n\u003cp\u003eOr\u003c/p\u003e\n\u003cpre\u003e\nclass A {\n  unsigned long long int b : 55;\n};\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eBit fields allow the developers to declare a class member with a specific size.\u003c/p\u003e\n\u003cp\u003eHowever, the size of a bit field is also constrained by its type: even if the specified size is greater than the size of the type, the value of the\nbit field will not exceed the maximum value of this type. The extra bits will just create unused padding.\u003c/p\u003e\n\u003cp\u003eThe incompatibility of the size of the type with the specified size can have two causes: either the specified size is a typo error (that is the\nmost probable cause) or the developer did not realize the size of the type he chose was too small.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass A {\n  unsigned int b : 55; // Noncompliant, specified size is greater than the size of unsigned int\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nclass A {\n  unsigned int b : 32;\n};\n\u003c/pre\u003e\n\u003cp\u003eOr\u003c/p\u003e\n\u003cpre\u003e\nclass A {\n  unsigned long long int b : 55;\n};\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "bad-practice"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S1578",
    "name": "File names should comply with a naming convention",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "IDENTIFIABLE",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eShared coding conventions allow teams to collaborate effectively. For that reason, file names should conform to a defined standard. This rule\nraises an issue when the names of analyzed files don’t match the provided regular expression.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/GtYxBQ\"\u003eCERT, MSC09-C.\u003c/a\u003e - Character encoding: Use subset of ASCII for safety \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eShared coding conventions allow teams to collaborate effectively. For that reason, file names should conform to a defined standard. This rule\nraises an issue when the names of analyzed files don’t match the provided regular expression.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/GtYxBQ\"\u003eCERT, MSC09-C.\u003c/a\u003e - Character encoding: Use subset of ASCII for safety \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {
      "format": {
        "key": "format",
        "name": "format",
        "description": "POSIX regular expression used to check the file names against.",
        "defaultValue": "^[A-Za-z_-][A-Za-z0-9_-]+\\.(c|m|cpp|cc|cxx)$",
        "type": "STRING",
        "multiple": false,
        "possibleValues": []
      }
    },
    "defaultParams": {
      "format": "^[A-Za-z_-][A-Za-z0-9_-]+\\.(c|m|cpp|cc|cxx)$"
    },
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "cert",
      "convention"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S2668",
    "name": "Increment should not be used to set boolean variables to \u0027true\u0027",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eIt is possible to use the increment operator \u003ccode\u003e++\u003c/code\u003e, to set the value of a \u003ccode\u003ebool\u003c/code\u003e(C++) or \u003ccode\u003e_Bool\u003c/code\u003e(C) variable to\n\u003ccode\u003etrue\u003c/code\u003e. But this feature has been deprecated in C++ since the 1998 version of the standard, removed in C++17, and even where allowed, is\nsimply confusing.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nbool alive;\n...\nalive++;\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nbool alive;\n...\nalive \u003d true;\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e ISO/IEC 14882:1998, 5.3.2 \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eIt is possible to use the increment operator \u003ccode\u003e++\u003c/code\u003e, to set the value of a \u003ccode\u003ebool\u003c/code\u003e(C++) or \u003ccode\u003e_Bool\u003c/code\u003e(C) variable to\n\u003ccode\u003etrue\u003c/code\u003e. But this feature has been deprecated in C++ since the 1998 version of the standard, removed in C++17, and even where allowed, is\nsimply confusing.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nbool alive;\n...\nalive++;\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nbool alive;\n...\nalive \u003d true;\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e ISO/IEC 14882:1998, 5.3.2 \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "confusing",
      "obsolete"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S5815",
    "name": "Using \"strncat\" or \"wcsncat\" is security-sensitive",
    "defaultSeverity": "MAJOR",
    "type": "SECURITY_HOTSPOT",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "SECURITY": "MEDIUM"
    },
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eIn C, a string is just a buffer of characters, normally using the \u003ccode\u003enull\u003c/code\u003e character as a sentinel for the end of the string. This means\nthat the developer has to be aware of low-level details such as buffer sizes or having an extra character to store the final \u003ccode\u003enull\u003c/code\u003e\ncharacter. Doing that correctly and consistently is notoriously difficult and any error can lead to a security vulnerability, for instance, giving\naccess to sensitive data or allowing arbitrary code execution.\u003c/p\u003e\n\u003cp\u003eThe function \u003ccode\u003echar *strncat( char *restrict dest, const char *restrict src, size_t count );\u003c/code\u003e appends the characters of string\n\u003ccode\u003esrc\u003c/code\u003e at the end of \u003ccode\u003edest\u003c/code\u003e, but only add \u003ccode\u003ecount\u003c/code\u003e characters max. \u003ccode\u003edest\u003c/code\u003e will always be\n\u003ccode\u003enull\u003c/code\u003e-terminated. The \u003ccode\u003ewcsncat\u003c/code\u003e does the same for wide characters, and should be used with the same guidelines.\u003c/p\u003e"
      },
      {
        "key": "assess_the_problem",
        "htmlContent": "\u003ch2\u003eAsk Yourself Whether\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e There is a possibility that either the \u003ccode\u003esrc\u003c/code\u003e or the \u003ccode\u003edest\u003c/code\u003e pointer is \u003ccode\u003enull\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e The current string length of \u003ccode\u003edest\u003c/code\u003e plus the current string length of \u003ccode\u003esrc\u003c/code\u003e plus 1 (for the final \u003ccode\u003enull\u003c/code\u003e\n  character) is larger than the size of the buffer pointer-to by \u003ccode\u003esrc\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e There is a possibility that either string is not correctly \u003ccode\u003enull\u003c/code\u003e-terminated \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere is a risk if you answered yes to any of those questions.\u003c/p\u003e\n\u003ch2\u003eSensitive Code Example\u003c/h2\u003e\n\u003cpre\u003e\nint f(char *src) {\n  char dest[256];\n  strcpy(dest, \"Result: \");\n  strncat(dest, src, sizeof dest); // Sensitive: passing the buffer size instead of the remaining size\n  return doSomethingWith(dest);\n}\n\u003c/pre\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003ch2\u003eRecommended Secure Coding Practices\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C11 provides, in its annex K, the \u003ccode\u003estrncat_s\u003c/code\u003e and the \u003ccode\u003ewcsncat_s\u003c/code\u003e that were designed as safer alternatives to\n  \u003ccode\u003estrncat\u003c/code\u003e and \u003ccode\u003ewcsncat\u003c/code\u003e. It’s not recommended to use them in all circumstances because they introduce a runtime overhead and\n  require to write more code for error handling, but they perform checks that will limit the consequences of calling the function with bad arguments.\n  \u003c/li\u003e\n  \u003cli\u003e Even if your compiler does not exactly support annex K, you probably have access to similar functions \u003c/li\u003e\n  \u003cli\u003e If you are using \u003ccode\u003estrncat\u003c/code\u003e and \u003ccode\u003ewsncat\u003c/code\u003e as a safer version of \u003ccode\u003estrcat\u003c/code\u003e and \u003ccode\u003ewcscat\u003c/code\u003e, you should\n  instead consider \u003ccode\u003estrcat_s\u003c/code\u003e and \u003ccode\u003ewcscat_s\u003c/code\u003e because these functions have several shortcomings:\n    \u003cul\u003e\n      \u003cli\u003e It’s not easy to detect truncation \u003c/li\u003e\n      \u003cli\u003e The \u003ccode\u003ecount\u003c/code\u003e parameter is error-prone \u003c/li\u003e\n      \u003cli\u003e Computing the \u003ccode\u003ecount\u003c/code\u003e parameter typically requires computing the string length of \u003ccode\u003edest\u003c/code\u003e, at which point other\n      simpler alternatives exist \u003c/li\u003e\n    \u003c/ul\u003e  \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eCompliant Solution\u003c/h2\u003e\n\u003cpre\u003e\nint f(char *src) {\n  char result[] \u003d \"Result: \";\n  char dest[256];\n  strcpy(dest, result);\n  strncat(dest, src, sizeof dest - sizeof result); // Compliant but may silently truncate\n  return doSomethingWith(dest);\n}\n\u003c/pre\u003e\n\u003ch2\u003eSee\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/Top10/A06_2021-Vulnerable_and_Outdated_Components/\"\u003eOWASP Top 10 2021 Category A6\u003c/a\u003e - Vulnerable and Outdated\n  Components \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/www-project-top-ten/2017/A9_2017-Using_Components_with_Known_Vulnerabilities\"\u003eOWASP Top 10 2017 Category A9\u003c/a\u003e -\n  Using Components with Known Vulnerabilities \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/120\"\u003eMITRE, CWE-120\u003c/a\u003e - Buffer Copy without Checking Size of Input (\u0027Classic Buffer\n  Overflow\u0027) \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/HdcxBQ\"\u003eCERT, STR07-C.\u003c/a\u003e - Use the bounds-checking interfaces for string manipulation \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "cert",
      "cwe"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": [],
    "vulnerabilityProbability": "HIGH"
  },
  {
    "key": "c:S5816",
    "name": "Using \"strncpy\" or \"wcsncpy\" is security-sensitive",
    "defaultSeverity": "MAJOR",
    "type": "SECURITY_HOTSPOT",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "SECURITY": "MEDIUM"
    },
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eIn C, a string is just a buffer of characters, normally using the \u003ccode\u003enull\u003c/code\u003e character as a sentinel for the end of the string. This means\nthat the developer has to be aware of low-level details such as buffer sizes or having an extra character to store the final \u003ccode\u003enull\u003c/code\u003e\ncharacter. Doing that correctly and consistently is notoriously difficult and any error can lead to a security vulnerability, for instance, giving\naccess to sensitive data or allowing arbitrary code execution.\u003c/p\u003e\n\u003cp\u003eThe function \u003ccode\u003echar *strncpy(char * restrict dest, const char * restrict src, size_t count);\u003c/code\u003e copies the first \u003ccode\u003ecount\u003c/code\u003e\ncharacters from \u003ccode\u003esrc\u003c/code\u003e to \u003ccode\u003edest\u003c/code\u003e, stopping at the first \u003ccode\u003enull\u003c/code\u003e character, and filling extra space with 0. The\n\u003ccode\u003ewcsncpy\u003c/code\u003e does the same for wide characters and should be used with the same guidelines.\u003c/p\u003e\n\u003cp\u003eBoth of those functions are designed to work with fixed-length strings and might result in a non-\u003ccode\u003enull\u003c/code\u003e-terminated string.\u003c/p\u003e"
      },
      {
        "key": "assess_the_problem",
        "htmlContent": "\u003ch2\u003eAsk Yourself Whether\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e There is a possibility that either the \u003ccode\u003esource\u003c/code\u003e or the \u003ccode\u003edestination\u003c/code\u003e pointer is \u003ccode\u003enull\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e The security of your system can be compromised if the \u003ccode\u003edestination\u003c/code\u003e is a truncated version of the \u003ccode\u003esource\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e The \u003ccode\u003esource\u003c/code\u003e buffer can be both non-\u003ccode\u003enull\u003c/code\u003e-terminated and smaller than the \u003ccode\u003ecount\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e The \u003ccode\u003edestination\u003c/code\u003e buffer can be smaller than the \u003ccode\u003ecount\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e You expect \u003ccode\u003edest\u003c/code\u003e to be a \u003ccode\u003enull\u003c/code\u003e-terminated string \u003c/li\u003e\n  \u003cli\u003e There is an overlap between the \u003ccode\u003esource\u003c/code\u003e and the \u003ccode\u003edestination\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere is a risk if you answered yes to any of those questions.\u003c/p\u003e\n\u003ch2\u003eSensitive Code Example\u003c/h2\u003e\n\u003cpre\u003e\nint f(char *src) {\n  char dest[256];\n  strncpy(dest, src, sizeof(dest)); // Sensitive: might silently truncate\n  return doSomethingWith(dest);\n}\n\u003c/pre\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003ch2\u003eRecommended Secure Coding Practices\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C11 provides, in its annex K, the \u003ccode\u003estrncpy_s\u003c/code\u003e and the \u003ccode\u003ewcsncpy_s\u003c/code\u003e that were designed as safer alternatives to\n  \u003ccode\u003estrcpy\u003c/code\u003e and \u003ccode\u003ewcscpy\u003c/code\u003e. It’s not recommended to use them in all circumstances, because they introduce a runtime overhead and\n  require to write more code for error handling, but they perform checks that will limit the consequences of calling the function with bad arguments.\n  \u003c/li\u003e\n  \u003cli\u003e Even if your compiler does not exactly support annex K, you probably have access to similar functions \u003c/li\u003e\n  \u003cli\u003e If you are using \u003ccode\u003estrncpy\u003c/code\u003e and \u003ccode\u003ewsncpy\u003c/code\u003e as a safer version of \u003ccode\u003estrcpy\u003c/code\u003e and \u003ccode\u003ewcscpy\u003c/code\u003e, you should\n  instead consider \u003ccode\u003estrcpy_s\u003c/code\u003e and \u003ccode\u003ewcscpy_s\u003c/code\u003e, because these functions have several shortcomings:\n    \u003cul\u003e\n      \u003cli\u003e It’s not easy to detect truncation \u003c/li\u003e\n      \u003cli\u003e Too much work is done to fill the buffer with 0, leading to suboptimal performance \u003c/li\u003e\n      \u003cli\u003e Unless manually corrected, the \u003ccode\u003edest\u003c/code\u003e string might not be \u003ccode\u003enull\u003c/code\u003e-terminated \u003c/li\u003e\n    \u003c/ul\u003e  \u003c/li\u003e\n  \u003cli\u003e If you want to use \u003ccode\u003estrcpy\u003c/code\u003e and \u003ccode\u003ewcscpy\u003c/code\u003e functions and detect if the string was truncated, the pattern is the following:\n    \u003cul\u003e\n      \u003cli\u003e Set the last character of the buffer to \u003ccode\u003enull\u003c/code\u003e \u003c/li\u003e\n      \u003cli\u003e Call the function \u003c/li\u003e\n      \u003cli\u003e Check if the last character of the buffer is still \u003ccode\u003enull\u003c/code\u003e \u003c/li\u003e\n    \u003c/ul\u003e  \u003c/li\u003e\n  \u003cli\u003e If you are writing C++ code, using \u003ccode\u003estd::string\u003c/code\u003e to manipulate strings is much simpler and less error-prone \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eCompliant Solution\u003c/h2\u003e\n\u003cpre\u003e\nint f(char *src) {\n  char dest[256];\n  dest[sizeof dest - 1] \u003d 0;\n  strncpy(dest, src, sizeof(dest)); // Compliant\n  if (dest[sizeof dest - 1] !\u003d 0) {\n    // Handle error\n  }\n  return doSomethingWith(dest);\n}\n\u003c/pre\u003e\n\u003ch2\u003eSee\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/Top10/A06_2021-Vulnerable_and_Outdated_Components/\"\u003eOWASP Top 10 2021 Category A6\u003c/a\u003e - Vulnerable and Outdated\n  Components \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/www-project-top-ten/2017/A9_2017-Using_Components_with_Known_Vulnerabilities\"\u003eOWASP Top 10 2017 Category A9\u003c/a\u003e -\n  Using Components with Known Vulnerabilities \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/120\"\u003eMITRE, CWE-120\u003c/a\u003e - Buffer Copy without Checking Size of Input (\u0027Classic Buffer\n  Overflow\u0027) \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/HdcxBQ\"\u003eCERT, STR07-C.\u003c/a\u003e - Use the bounds-checking interfaces for string manipulation \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "cert",
      "cwe"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": [],
    "vulnerabilityProbability": "HIGH"
  },
  {
    "key": "c:S5813",
    "name": "Using \"strlen\" or \"wcslen\" is security-sensitive",
    "defaultSeverity": "MAJOR",
    "type": "SECURITY_HOTSPOT",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "SECURITY": "MEDIUM"
    },
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe function \u003ccode\u003esize_t strlen(const char *s)\u003c/code\u003e measures the length of the string \u003ccode\u003es\u003c/code\u003e (excluding the final null character).\u003cbr\u003e\nThe function \u003ccode\u003esize_t wcslen(const wchar_t *s)\u003c/code\u003e does the same for wide characters, and should be used with the same guidelines.\u003c/p\u003e\n\u003cp\u003eSimilarly to many other functions in the standard C libraries, \u003ccode\u003estrlen\u003c/code\u003e and \u003ccode\u003ewcslen\u003c/code\u003e assume that their argument is not a null\npointer.\u003c/p\u003e\n\u003cp\u003eAdditionally, they expect the strings to be null-terminated. For example, the 5-letter string \"abcde\" must be stored in memory as \"abcde\\0\" (i.e.\nusing 6 characters) to be processed correctly. When a string is missing the null character at the end, these functions will iterate past the end of\nthe buffer, which is undefined behavior.\u003c/p\u003e\n\u003cp\u003eTherefore, string parameters must end with a proper null character. The absence of this particular character can lead to security vulnerabilities\nthat allow, for example, access to sensitive data or the execution of arbitrary code.\u003c/p\u003e"
      },
      {
        "key": "assess_the_problem",
        "htmlContent": "\u003ch2\u003eAsk Yourself Whether\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e There is a possibility that the pointer is null. \u003c/li\u003e\n  \u003cli\u003e There is a possibility that the string is not correctly null-terminated. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere is a risk if you answered yes to any of those questions.\u003c/p\u003e\n\u003ch2\u003eSensitive Code Example\u003c/h2\u003e\n\u003cpre\u003e\nsize_t f(char *src) {\n  char dest[256];\n  strncpy(dest, src, sizeof dest); // Truncation may happen\n  return strlen(dest); // Sensitive: \"dest\" will not be null-terminated if truncation happened\n}\n\u003c/pre\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003ch2\u003eRecommended Secure Coding Practices\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e Use safer functions. The C11 functions \u003ccode\u003estrlen_s\u003c/code\u003e and \u003ccode\u003ewcslen_s\u003c/code\u003e from annex K handle typical programming errors.\u003cbr\u003e\n  Note, however, that they have a runtime overhead and require more code for error handling and therefore are not suited to every case. \u003c/li\u003e\n  \u003cli\u003e Even if your compiler does not exactly support annex K, you probably have access to similar functions. \u003c/li\u003e\n  \u003cli\u003e If you are writing C++ code, using \u003ccode\u003estd::string\u003c/code\u003e to manipulate strings is much simpler and less error-prone. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eCompliant Solution\u003c/h2\u003e\n\u003cpre\u003e\nsize_t f(char *src) {\n  char dest[256];\n  strncpy(dest, src, sizeof dest); // Truncation may happen\n  dest[sizeof dest - 1] \u003d 0;\n  return strlen(dest); // Compliant: \"dest\" is guaranteed to be null-terminated\n}\n\u003c/pre\u003e\n\u003ch2\u003eSee\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/120\"\u003eMITRE, CWE-120\u003c/a\u003e - Buffer Copy without Checking Size of Input (\u0027Classic Buffer\n  Overflow\u0027) \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/HdcxBQ\"\u003eCERT, STR07-C.\u003c/a\u003e - Use the bounds-checking interfaces for string manipulation \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "cert",
      "cwe"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": [],
    "vulnerabilityProbability": "HIGH"
  },
  {
    "key": "c:S3516",
    "name": "Methods returns should not be invariant",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhen a method is designed to return an invariant value, it may be poor design, but it shouldn’t adversely affect the outcome of your program.\nHowever, when it happens on all paths through the logic, it is surely a bug.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when a method contains several \u003ccode\u003ereturn\u003c/code\u003e statements that all return the same value.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint foo(int a) {\n  int b \u003d 12;\n  if (a \u003d\u003d 1) {\n    return b;\n  }\n  return b;  // Noncompliant\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhen a method is designed to return an invariant value, it may be poor design, but it shouldn’t adversely affect the outcome of your program.\nHowever, when it happens on all paths through the logic, it is surely a bug.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when a method contains several \u003ccode\u003ereturn\u003c/code\u003e statements that all return the same value.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint foo(int a) {\n  int b \u003d 12;\n  if (a \u003d\u003d 1) {\n    return b;\n  }\n  return b;  // Noncompliant\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S5814",
    "name": "Using \"strcat\" or \"wcscat\" is security-sensitive",
    "defaultSeverity": "MAJOR",
    "type": "SECURITY_HOTSPOT",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "SECURITY": "MEDIUM"
    },
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eIn C, a string is just a buffer of characters, normally using the \u003ccode\u003enull\u003c/code\u003e character as a sentinel for the end of the string. This means\nthat the developer has to be aware of low-level details such as buffer sizes or having an extra character to store the final \u003ccode\u003enull\u003c/code\u003e\ncharacter. Doing that correctly and consistently is notoriously difficult and any error can lead to a security vulnerability, for instance, giving\naccess to sensitive data or allowing arbitrary code execution.\u003c/p\u003e\n\u003cp\u003eThe function \u003ccode\u003echar *strcat( char *restrict dest, const char *restrict src );\u003c/code\u003e appends the characters of string \u003ccode\u003esrc\u003c/code\u003e at the\nend of \u003ccode\u003edest\u003c/code\u003e. The \u003ccode\u003ewcscat\u003c/code\u003e does the same for wide characters and should be used with the same guidelines.\u003c/p\u003e\n\u003cp\u003eNote: the functions \u003ccode\u003estrncat\u003c/code\u003e and \u003ccode\u003ewcsncat\u003c/code\u003e might look like attractive safe replacements for \u003ccode\u003estrcat\u003c/code\u003e and\n\u003ccode\u003ewcscaty\u003c/code\u003e, but they have their own set of issues (see {rule:c:S5815}), and you should probably prefer another more adapted\nalternative.\u003c/p\u003e"
      },
      {
        "key": "assess_the_problem",
        "htmlContent": "\u003ch2\u003eAsk Yourself Whether\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e There is a possibility that either the \u003ccode\u003esrc\u003c/code\u003e or the \u003ccode\u003edest\u003c/code\u003e pointer is \u003ccode\u003enull\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e The current string length of \u003ccode\u003edest\u003c/code\u003e plus the current string length of \u003ccode\u003esrc\u003c/code\u003e plus 1 (for the final\u0026nbsp;\u003ccode\u003enull\u003c/code\u003e\n  character) is larger than the size of the buffer pointer-to by \u003ccode\u003esrc\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e There is a possibility that either string is not correctly \u003ccode\u003enull\u003c/code\u003e-terminated \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere is a risk if you answered yes to any of those questions.\u003c/p\u003e\n\u003ch2\u003eSensitive Code Example\u003c/h2\u003e\n\u003cpre\u003e\nint f(char *src) {\n  char dest[256];\n  strcpy(dest, \"Result: \");\n  strcat(dest, src); // Sensitive: might overflow\n  return doSomethingWith(dest);\n}\n\u003c/pre\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003ch2\u003eRecommended Secure Coding Practices\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C11 provides, in its annex K, the \u003ccode\u003estrcat_s\u003c/code\u003e and the \u003ccode\u003ewcscat_s\u003c/code\u003e that were designed as safer alternatives to\n  \u003ccode\u003estrcat\u003c/code\u003e and \u003ccode\u003ewcscat\u003c/code\u003e. It’s not recommended to use them in all circumstances, because they introduce a runtime overhead and\n  require to write more code for error handling, but they perform checks that will limit the consequences of calling the function with bad arguments.\n  \u003c/li\u003e\n  \u003cli\u003e Even if your compiler does not exactly support annex K, you probably have access to similar functions \u003c/li\u003e\n  \u003cli\u003e If you are writing C++ code, using \u003ccode\u003estd::string\u003c/code\u003e to manipulate strings is much simpler and less error-prone \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eCompliant Solution\u003c/h2\u003e\n\u003cpre\u003e\nint f(char *src) {\n  char result[] \u003d \"Result: \";\n  char *dest \u003d malloc(sizeof(result) + strlen(src)); // Not need of +1 for final 0 because sizeof will already count one 0\n  strcpy(dest, result);\n  strcat(dest, src); // Compliant: the buffer size was carefully crafted\n  int r \u003d doSomethingWith(dest);\n  free(dest);\n  return r;\n}\n\u003c/pre\u003e\n\u003ch2\u003eSee\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/Top10/A06_2021-Vulnerable_and_Outdated_Components/\"\u003eOWASP Top 10 2021 Category A6\u003c/a\u003e - Vulnerable and Outdated\n  Components \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/www-project-top-ten/2017/A9_2017-Using_Components_with_Known_Vulnerabilities\"\u003eOWASP Top 10 2017 Category A9\u003c/a\u003e -\n  Using Components with Known Vulnerabilities \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/120\"\u003eMITRE, CWE-120\u003c/a\u003e - Buffer Copy without Checking Size of Input (\u0027Classic Buffer\n  Overflow\u0027) \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/HdcxBQ\"\u003eCERT, STR07-C.\u003c/a\u003e - Use the bounds-checking interfaces for string manipulation \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "cert",
      "cwe"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": [],
    "vulnerabilityProbability": "HIGH"
  },
  {
    "key": "c:S1219",
    "name": "\"switch\" statements should not contain non-case labels",
    "defaultSeverity": "BLOCKER",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eEven if it is legal, mixing case and non-case labels in the body of a switch statement is very confusing and can even be the result of a typing\nerror.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cp\u003eThe code is syntactically correct but the behavior is not the expected one\u003c/p\u003e\n\u003cpre\u003e\nswitch (day) {\n  case MONDAY:\n  case TUESDAY:\n  WEDNESDAY:   // instead of \"case WEDNESDAY\"\n    doSomething();\n    break;\n  ...\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nswitch (day) {\n  case MONDAY:\n  case TUESDAY:\n  case WEDNESDAY:\n    doSomething();\n    break;\n  ...\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 15.0 - The MISRA C \u003cem\u003eswitch\u003c/em\u003e syntax shall be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 6-4-3 - A switch statement shall be a well-formed switch statement. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 16.1 - All switch statements shall be well-formed \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eEven if it is legal, mixing case and non-case labels in the body of a switch statement is very confusing and can even be the result of a typing\nerror.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cp\u003eThe code is syntactically correct but the behavior is not the expected one\u003c/p\u003e\n\u003cpre\u003e\nswitch (day) {\n  case MONDAY:\n  case TUESDAY:\n  WEDNESDAY:   // instead of \"case WEDNESDAY\"\n    doSomething();\n    break;\n  ...\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nswitch (day) {\n  case MONDAY:\n  case TUESDAY:\n  case WEDNESDAY:\n    doSomething();\n    break;\n  ...\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 15.0 - The MISRA C \u003cem\u003eswitch\u003c/em\u003e syntax shall be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 6-4-3 - A switch statement shall be a well-formed switch statement. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 16.1 - All switch statements shall be well-formed \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "based-on-misra",
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S3519",
    "name": "Memory access should be explicitly bounded to prevent buffer overflows",
    "defaultSeverity": "BLOCKER",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003cp\u003eMemory accesses should be bounded to prevent buffer overflows.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eArray overruns and buffer overflows occur when a memory access accidentally goes beyond the boundary of the allocated array or buffer.\u003c/p\u003e\n\u003cp\u003eThese overreaching accesses cause some of the most damaging and hard to track defects. Not only do these faulty accesses constitute undefined\nbehavior, but they frequently introduce security vulnerabilities, too.\u003c/p\u003e\n\u003ch2\u003eWhat is the potential impact?\u003c/h2\u003e\n\u003cp\u003eAccessing memory that goes beyond the boundary of the allocated array or buffer results in undefined behavior.\u003c/p\u003e\n\u003cp\u003eFor programs that exercise undefined behavior, the compiler is no longer bound by the language specification. The application may crash or, even\nworse, the application may appear to execute correctly while losing data or producing incorrect results.\u003c/p\u003e\n\u003cp\u003eOut-of-bounds memory accesses cause some of the most damaging and hard-to-track defects. Unbounded memory accesses may also introduce severe\nsecurity vulnerabilities. In case a user of the program can control the contents of a buffer, for instance, a malicious attacker can use the buffer\noverflow to overwrite critical data, leak secret or private information, execute arbitrary code, or gain unauthorized access to the system.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eEnsure that memory accesses are within the bounds of the allocated array or buffer.\u003c/p\u003e\n\u003cp\u003eIf C++ is available, use the \u003ccode\u003estd::array\u003c/code\u003e or \u003ccode\u003estd::vector\u003c/code\u003e types to manage stack or heap-based arrays, respectively and use\n\u003ccode\u003estd::string\u003c/code\u003e to manage string buffers.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid access_exceeds(void) {\n  int id_sequence[3];\n  id_sequence[0] \u003d 100;\n  id_sequence[1] \u003d 200;\n  id_sequence[2] \u003d 300;\n  id_sequence[3] \u003d 400; // Noncompliant: memory access is out of bounds\n  // Accessed memory exceeds upper limit of memory block\n}\n\nvoid access_precedes(int x) {\n  int buf[100];\n  int *p \u003d buf;\n  --p;\n  p[0] \u003d 9001; // Noncompliant: memory access is out of bounds\n  // Accessed memory precedes memory block\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid access_exceeds(void) {\n  int id_sequence[3];\n  // Compliant: all memory accesses are within valid bounds between 0 and 2\n  id_sequence[0] \u003d 100;\n  id_sequence[1] \u003d 200;\n  id_sequence[2] \u003d 300;\n}\n\nvoid access_precedes(int x) {\n  int buf[100];\n  int *p \u003d buf;\n  p[0] \u003d 9001; // Compliant: memory access within valid bounds\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;string.h\u0026gt;\n\nvoid memcpy_fun(void) {\n  char src[] \u003d {1, 2, 3, 4};\n  char dst[10];\n  memcpy(dst, src, 5); // Noncompliant: memory copy function accesses out-of-bound array element\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;string.h\u0026gt;\n\nvoid memcpy_fun(void) {\n  char src[] \u003d {1, 2, 3, 4};\n  char dst[10];\n  memcpy(dst, src, sizeof(src)); // Compliant: memory copy function accesses only valid array elements\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n\nint fun(void) {\n  char buffer[64] \u003d {0};\n  if (fgets(buffer, 2048, stdin) !\u003d NULL) { // Noncompliant: target buffer may overflow\n    printf(\"buffer contents: %s\", buffer);\n    return 0;\n  }\n  return 1;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n\nint fun(void) {\n  char buffer[64] \u003d {0};\n  if (fgets(buffer, 64, stdin) !\u003d NULL) { // Compliant: reads at most 64 - 1 characters\n    printf(\"buffer contents: %s\", buffer);\n    return 0;\n  }\n  return 1;\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"4\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n#include \u0026lt;string.h\u0026gt;\n\nint foo(void) {\n  const char *const str \u003d \"AAAA\"\n                          \"BBBB\"\n                          \"CCCC\"\n                          \"DDDD\";\n  size_t str_len \u003d strlen(str);\n  char *buf1 \u003d (char *)malloc(str_len + /*null terminator*/ 1);\n  if (buf1 \u003d\u003d NULL) { return 1; }\n  memset(buf1, 0, str_len + 1);\n  strncpy(buf1, str, str_len);\n  char buf2[8] \u003d {0};\n  memcpy(buf2, buf1, str_len + 1); // Noncompliant: buf2 will overflow.\n  printf(\"buf1: %s\\n\", buf1);\n  printf(\"buf2: %s\\n\", buf2);\n  free(buf1);\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"4\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n#include \u0026lt;string.h\u0026gt;\n\nint foo(void) {\n  const char *const str \u003d \"AAAA\"\n                          \"BBBB\"\n                          \"CCCC\"\n                          \"DDDD\";\n  size_t str_len \u003d strlen(str);\n  char *buf1 \u003d (char *)malloc(str_len + /*null terminator*/ 1);\n  if (buf1 \u003d\u003d NULL) { return 1; }\n  memset(buf1, 0, str_len + 1);\n  strncpy(buf1, str, str_len + 1);\n  char buf2[8] \u003d {0};\n  // Compliant: copy only `sizeof(buf2) - 1` bytes and leave the last\n  // terminating null byte (\u0027\\0\u0027) untouched such that `buf2` can be correctly\n  // printed in the subsequent lines.\n  memcpy(buf2, buf1,  sizeof(buf2) - 1);\n  printf(\"buf1: %s\\n\", buf1);\n  printf(\"buf2: %s\\n\", buf2);\n  free(buf1);\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"5\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n\nvoid bar(void) {\n  int array[8] \u003d {1, 2, 3, 4, 5, 6, 7, 8};\n  array[8] \u003d 42; // Noncompliant: index should be between 0 and 7\n  for (size_t i \u003d 0; i \u0026lt; 8; ++i) {\n    printf(\"%d\\n\", array[i]); // Compliant: index is between 0 and 7\n  }\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"5\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n\nvoid bar(void) {\n  int array[8] \u003d {1, 2, 3, 4, 5, 6, 7, 8};\n  array[7] \u003d 42; // Compliant: index is between 0 and 7\n  for (size_t i \u003d 0; i \u0026lt; 8; ++i) {\n    printf(\"%d\\n\", array[i]); // Compliant: index is between 0 and 7\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003ePitfalls\u003c/h3\u003e\n\u003cp\u003eWhen managing and manipulating string buffers one needs to take great care that the buffers are correctly terminated with a null byte\n(\u003ccode\u003e\u0027\\0\u0027\u003c/code\u003e). Failing to correctly null terminate string buffers almost always causes buffer overruns and introduces undefined behavior.\u003c/p\u003e\n\u003cp\u003eThe following faulty program aims at creating a string copy. However, the heap-allocated memory buffer for holding the copy is too small since\n\u003ccode\u003estrlen\u003c/code\u003e calculates the length of its input string but excludes the \"invisible\" terminating null byte (\u003ccode\u003e\u0027\\0\u0027\u003c/code\u003e). The call to\n\u003ccode\u003estrncpy\u003c/code\u003e also uses the string length computed by \u003ccode\u003estrlen\u003c/code\u003e and the string copy hence lacks an implicitly copied null terminator.\nThis causes out-of-bounds reads and introduces undefined behavior in the subsequent processing steps. In this example, the call to \u003ccode\u003eprintf\u003c/code\u003e\nwill eventually trigger such erroneous behavior.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"6\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n#include \u0026lt;string.h\u0026gt;\n\nchar *make_str_copy(const char *const src) {\n  size_t src_len \u003d strlen(src);\n  char *dst \u003d (char *)malloc(src_len); // buffer too small to hold null terminator\n  if (dst \u003d\u003d NULL) {\n    perror(\"malloc failed\");\n    exit(1);\n  }\n  strncpy(dst, src, src_len); // null terminator is not (implicitly) copied either\n  return dst;\n}\n\nint main(void) {\n  const char str[] \u003d \"Hello, World!\";\n  char *str_copy \u003d make_str_copy(str);\n  // call to `printf` will trigger undefined behavior due to missing null terminator\n  printf(\"%s\\n\", str_copy); // Noncompliant: `str_copy` has not been null terminated\n  // More code that processes `str_copy` ...\n  free(str_copy);\n  return 0;\n}\n\u003c/pre\u003e\n\u003cp\u003eThe following fixed version of the program does correctly allocate a heap-based buffer of sufficient size \u003cem\u003eand\u003c/em\u003e (explicitly) terminates it\nwith a null byte (\u003ccode\u003e\u0027\\0\u0027\u003c/code\u003e):\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"6\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n#include \u0026lt;string.h\u0026gt;\n\nchar *make_str_copy(const char *const src) {\n  size_t src_len \u003d strlen(src);\n  // `src_len + 1` since `strlen` _excludes_ the terminating null byte\n  char *dst \u003d (char *)malloc(src_len + 1);\n  if (dst \u003d\u003d NULL) {\n    perror(\"malloc failed\");\n    exit(1);\n  }\n  dst[src_len] \u003d \u0027\\0\u0027; // explicitly add a null terminator\n  strncpy(dst, src, src_len);\n  return dst;\n}\n\nint main(void) {\n  const char str[] \u003d \"Hello, World!\";\n  char *str_copy \u003d make_str_copy(str);\n  printf(\"%s\\n\", str_copy); // Compliant: `str_copy` has been correctly null terminated\n  // More code that processes `str_copy` ...\n  free(str_copy);\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch3\u003eGoing the extra mile\u003c/h3\u003e\n\u003cp\u003eBuffer overflows occur when a program writes data beyond the boundaries of a buffer and can lead to memory corruption and potential security\nvulnerabilities. To mitigate this risk, developers must carefully manage array and buffer sizes. This includes using secure coding practices, and\nemploying techniques like input validation and bounds checking.\u003c/p\u003e\n\u003cp\u003eVarious modern C and C++ compilers allow one to automatically instrument a program during compilation using so-called \u003cem\u003esanitizers\u003c/em\u003e. The\naddress and undefined behavior sanitizers, for instance, aim at detecting out-of-bound memory accesses and undefined behavior, respectively. If the\ninstrumentation detects an error at runtime, the program will abort with an error message that provides valuable information for identifying and\nfixing the error.\u003c/p\u003e\n\u003cp\u003eAdditional capabilities of modern compilers that aim at hardening the binary include the \u003ccode\u003eFORTIFY_SOURCE\u003c/code\u003e compilation flag, or features\nsuch as stack canaries or address space layout randomization (ASLR). These hardening features provide some lightweight support for detecting buffer\noverflows.\u003c/p\u003e\n\u003cp\u003eYet another programming tool for memory debugging is Valgrind. Valgrind inspects a programming during its execution and is capable of detecting\nvarious memory-related issues including buffer overflows.\u003c/p\u003e\n\u003cp\u003eIn C++, manual array or string, i.e., buffer manipulations are considered a code smell.\u003c/p\u003e\n\u003cp\u003eInstead, the \u003ccode\u003estd::array\u003c/code\u003e type should be used to manage stack-based arrays, and the \u003ccode\u003estd::vector\u003c/code\u003e type should be used if a\nheap-based array is desired. Besides always carrying their respective sizes, i.e., number of elements, \u003ccode\u003estd::array\u003c/code\u003e and\n\u003ccode\u003estd::vector\u003c/code\u003e implement many useful member functions such as \u003ccode\u003ebegin()\u003c/code\u003e and \u003ccode\u003eend()\u003c/code\u003e, allowing one to safely and\nconveniently process them using algorithms from the C++\u0027s \u003ccode\u003e\u0026lt;algorithm\u0026gt;\u003c/code\u003e header, for instance. An example is shown in the\nfollowing:\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;algorithm\u0026gt;\n#include \u0026lt;array\u0026gt;\n#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;numeric\u0026gt;\n#include \u0026lt;vector\u0026gt;\n\nvoid bar() {\n  // stack-based array\n  std::array\u0026lt;int, 8\u0026gt; stack_buf;\n  std::fill(stack_buf.begin(), stack_buf.end(), 42);\n  for (auto i : stack_buf) {\n    std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0027 \u0027;\n  }\n  std::cout \u0026lt;\u0026lt; \u0027\\n\u0027;\n  std::cout \u0026lt;\u0026lt; \"sum of stack_buf\u0027s values: \"\n            \u0026lt;\u0026lt; std::accumulate(stack_buf.begin(), stack_buf.end(), 0) \u0026lt;\u0026lt; \u0027\\n\u0027;\n  // heap-based array\n  std::vector\u0026lt;int\u0026gt; heap_buf \u003d {1, 2, 3, 4};\n  heap_buf.resize(10);\n  std::iota(heap_buf.begin(), heap_buf.end(), 1);\n  std::cout \u0026lt;\u0026lt; \"sum of heap_buf\u0027s values: \"\n            \u0026lt;\u0026lt; std::accumulate(heap_buf.begin(), heap_buf.end(), 0) \u0026lt;\u0026lt; \u0027\\n\u0027;\n}\n\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003estd::string\u003c/code\u003e type should be used to manage buffers since it facilitates safe buffer manipulations. Instead of manually\nconcatenating two buffers using \u003ccode\u003estrncat\u003c/code\u003e, for instance, \u003ccode\u003estd::string\u003c/code\u003e allows this operation to be performed in a much more\nconvenient manner as shown in the following code:\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;string\u0026gt;\n\nvoid buz(std::string const \u0026amp;s) {\n  std::string t \u003d \"Hello, \" + s;\n  std::cout \u0026lt;\u0026lt; t \u0026lt;\u0026lt; \u0027\\n\u0027;\n}\n\u003c/pre\u003e\n\u003cp\u003eIn addition, the \u003ccode\u003estd::format\u003c/code\u003e function allows one to format strings according to a user-specified format and returns the result as a\nstring as shown in what follows:\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;format\u0026gt;\n#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;string\u0026gt;\n\nvoid tar(std::string const \u0026amp;s) {\n  std::string t \u003d std::format(\"Hello, World! Greetings {}\\n\", s);\n  std::cout \u0026lt;\u0026lt; t \u0026lt;\u0026lt; \u0027\\n\u0027;\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eArticles \u0026amp; blog posts\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Clang Hardening - \u003ca href\u003d\"https://blog.quarkslab.com/clang-hardening-cheat-sheet.html\"\u003eClang Hardening Cheat Sheet\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e FORTIFY_SOURCE - \u003ca href\u003d\"https://www.redhat.com/en/blog/enhance-application-security-fortifysource\"\u003eEnhance application security with\n  FORTIFY_SOURCE\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e Stack Protection - \u003ca href\u003d\"https://developers.redhat.com/articles/2022/06/02/use-compiler-flags-stack-protection-gcc-and-clang\"\u003eUse compiler\n  flags for stack protection in GCC and Clang\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e Valgrind - \u003ca href\u003d\"https://valgrind.org/docs/manual/quick-start.html\"\u003eThe Valgrind Quick Start Guide\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eConference presentations\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CppCon 2014 - \u003ca href\u003d\"https://youtu.be/V2_80g0eOMc?si\u003dU_qv9iBKI5B3a_EL\"\u003eSanitize your C++ code\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CppCon 2018 - \u003ca href\u003d\"https://youtu.be/0S0QgQd75Sw?si\u003dAW9mA09L5PEbkqXc\"\u003eSoftware Vulnerabilities in C and C++\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CppCon 2020 - \u003ca href\u003d\"https://youtu.be/xEzfnbTabyE?si\u003d9yJQkrcRKn6tuPaV\"\u003e2020: The Year of Sanitizers?\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/wtYxBQ\"\u003eARR30-C. Do not form or use out-of-bounds pointers or array subscripts\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/i3w-BQ\"\u003eSTR50-CPP. Guarantee that storage for strings has sufficient space for character\n  data and the null terminator\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/119\"\u003e119 Improper Restriction of Operations within the Bounds of a Memory Buffer\u003c/a\u003e\n  \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/121\"\u003e121 Stack-based Buffer Overflow\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/122\"\u003e122 Heap-based Buffer Overflow\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/131\"\u003e131 Incorrect Calculation of Buffer Size\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/193\"\u003e193 Off-by-one Error\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/788\"\u003e788 Access of Memory Location After End of Buffer\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:c:S5782} ensures that POSIX functions are not called with arguments that trigger buffer overflows \u003c/li\u003e\n  \u003cli\u003e S5945 discourages the use of C-style arrays and suggests the use of \u003ccode\u003estd::array\u003c/code\u003e or \u003ccode\u003estd::vector\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eMemory accesses should be bounded to prevent buffer overflows.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eArray overruns and buffer overflows occur when a memory access accidentally goes beyond the boundary of the allocated array or buffer.\u003c/p\u003e\n\u003cp\u003eThese overreaching accesses cause some of the most damaging and hard to track defects. Not only do these faulty accesses constitute undefined\nbehavior, but they frequently introduce security vulnerabilities, too.\u003c/p\u003e\n\u003ch2\u003eWhat is the potential impact?\u003c/h2\u003e\n\u003cp\u003eAccessing memory that goes beyond the boundary of the allocated array or buffer results in undefined behavior.\u003c/p\u003e\n\u003cp\u003eFor programs that exercise undefined behavior, the compiler is no longer bound by the language specification. The application may crash or, even\nworse, the application may appear to execute correctly while losing data or producing incorrect results.\u003c/p\u003e\n\u003cp\u003eOut-of-bounds memory accesses cause some of the most damaging and hard-to-track defects. Unbounded memory accesses may also introduce severe\nsecurity vulnerabilities. In case a user of the program can control the contents of a buffer, for instance, a malicious attacker can use the buffer\noverflow to overwrite critical data, leak secret or private information, execute arbitrary code, or gain unauthorized access to the system.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eEnsure that memory accesses are within the bounds of the allocated array or buffer.\u003c/p\u003e\n\u003cp\u003eIf C++ is available, use the \u003ccode\u003estd::array\u003c/code\u003e or \u003ccode\u003estd::vector\u003c/code\u003e types to manage stack or heap-based arrays, respectively and use\n\u003ccode\u003estd::string\u003c/code\u003e to manage string buffers.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid access_exceeds(void) {\n  int id_sequence[3];\n  id_sequence[0] \u003d 100;\n  id_sequence[1] \u003d 200;\n  id_sequence[2] \u003d 300;\n  id_sequence[3] \u003d 400; // Noncompliant: memory access is out of bounds\n  // Accessed memory exceeds upper limit of memory block\n}\n\nvoid access_precedes(int x) {\n  int buf[100];\n  int *p \u003d buf;\n  --p;\n  p[0] \u003d 9001; // Noncompliant: memory access is out of bounds\n  // Accessed memory precedes memory block\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid access_exceeds(void) {\n  int id_sequence[3];\n  // Compliant: all memory accesses are within valid bounds between 0 and 2\n  id_sequence[0] \u003d 100;\n  id_sequence[1] \u003d 200;\n  id_sequence[2] \u003d 300;\n}\n\nvoid access_precedes(int x) {\n  int buf[100];\n  int *p \u003d buf;\n  p[0] \u003d 9001; // Compliant: memory access within valid bounds\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;string.h\u0026gt;\n\nvoid memcpy_fun(void) {\n  char src[] \u003d {1, 2, 3, 4};\n  char dst[10];\n  memcpy(dst, src, 5); // Noncompliant: memory copy function accesses out-of-bound array element\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;string.h\u0026gt;\n\nvoid memcpy_fun(void) {\n  char src[] \u003d {1, 2, 3, 4};\n  char dst[10];\n  memcpy(dst, src, sizeof(src)); // Compliant: memory copy function accesses only valid array elements\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n\nint fun(void) {\n  char buffer[64] \u003d {0};\n  if (fgets(buffer, 2048, stdin) !\u003d NULL) { // Noncompliant: target buffer may overflow\n    printf(\"buffer contents: %s\", buffer);\n    return 0;\n  }\n  return 1;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n\nint fun(void) {\n  char buffer[64] \u003d {0};\n  if (fgets(buffer, 64, stdin) !\u003d NULL) { // Compliant: reads at most 64 - 1 characters\n    printf(\"buffer contents: %s\", buffer);\n    return 0;\n  }\n  return 1;\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"4\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n#include \u0026lt;string.h\u0026gt;\n\nint foo(void) {\n  const char *const str \u003d \"AAAA\"\n                          \"BBBB\"\n                          \"CCCC\"\n                          \"DDDD\";\n  size_t str_len \u003d strlen(str);\n  char *buf1 \u003d (char *)malloc(str_len + /*null terminator*/ 1);\n  if (buf1 \u003d\u003d NULL) { return 1; }\n  memset(buf1, 0, str_len + 1);\n  strncpy(buf1, str, str_len);\n  char buf2[8] \u003d {0};\n  memcpy(buf2, buf1, str_len + 1); // Noncompliant: buf2 will overflow.\n  printf(\"buf1: %s\\n\", buf1);\n  printf(\"buf2: %s\\n\", buf2);\n  free(buf1);\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"4\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n#include \u0026lt;string.h\u0026gt;\n\nint foo(void) {\n  const char *const str \u003d \"AAAA\"\n                          \"BBBB\"\n                          \"CCCC\"\n                          \"DDDD\";\n  size_t str_len \u003d strlen(str);\n  char *buf1 \u003d (char *)malloc(str_len + /*null terminator*/ 1);\n  if (buf1 \u003d\u003d NULL) { return 1; }\n  memset(buf1, 0, str_len + 1);\n  strncpy(buf1, str, str_len + 1);\n  char buf2[8] \u003d {0};\n  // Compliant: copy only `sizeof(buf2) - 1` bytes and leave the last\n  // terminating null byte (\u0027\\0\u0027) untouched such that `buf2` can be correctly\n  // printed in the subsequent lines.\n  memcpy(buf2, buf1,  sizeof(buf2) - 1);\n  printf(\"buf1: %s\\n\", buf1);\n  printf(\"buf2: %s\\n\", buf2);\n  free(buf1);\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"5\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n\nvoid bar(void) {\n  int array[8] \u003d {1, 2, 3, 4, 5, 6, 7, 8};\n  array[8] \u003d 42; // Noncompliant: index should be between 0 and 7\n  for (size_t i \u003d 0; i \u0026lt; 8; ++i) {\n    printf(\"%d\\n\", array[i]); // Compliant: index is between 0 and 7\n  }\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"5\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n\nvoid bar(void) {\n  int array[8] \u003d {1, 2, 3, 4, 5, 6, 7, 8};\n  array[7] \u003d 42; // Compliant: index is between 0 and 7\n  for (size_t i \u003d 0; i \u0026lt; 8; ++i) {\n    printf(\"%d\\n\", array[i]); // Compliant: index is between 0 and 7\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003ePitfalls\u003c/h3\u003e\n\u003cp\u003eWhen managing and manipulating string buffers one needs to take great care that the buffers are correctly terminated with a null byte\n(\u003ccode\u003e\u0027\\0\u0027\u003c/code\u003e). Failing to correctly null terminate string buffers almost always causes buffer overruns and introduces undefined behavior.\u003c/p\u003e\n\u003cp\u003eThe following faulty program aims at creating a string copy. However, the heap-allocated memory buffer for holding the copy is too small since\n\u003ccode\u003estrlen\u003c/code\u003e calculates the length of its input string but excludes the \"invisible\" terminating null byte (\u003ccode\u003e\u0027\\0\u0027\u003c/code\u003e). The call to\n\u003ccode\u003estrncpy\u003c/code\u003e also uses the string length computed by \u003ccode\u003estrlen\u003c/code\u003e and the string copy hence lacks an implicitly copied null terminator.\nThis causes out-of-bounds reads and introduces undefined behavior in the subsequent processing steps. In this example, the call to \u003ccode\u003eprintf\u003c/code\u003e\nwill eventually trigger such erroneous behavior.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"6\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n#include \u0026lt;string.h\u0026gt;\n\nchar *make_str_copy(const char *const src) {\n  size_t src_len \u003d strlen(src);\n  char *dst \u003d (char *)malloc(src_len); // buffer too small to hold null terminator\n  if (dst \u003d\u003d NULL) {\n    perror(\"malloc failed\");\n    exit(1);\n  }\n  strncpy(dst, src, src_len); // null terminator is not (implicitly) copied either\n  return dst;\n}\n\nint main(void) {\n  const char str[] \u003d \"Hello, World!\";\n  char *str_copy \u003d make_str_copy(str);\n  // call to `printf` will trigger undefined behavior due to missing null terminator\n  printf(\"%s\\n\", str_copy); // Noncompliant: `str_copy` has not been null terminated\n  // More code that processes `str_copy` ...\n  free(str_copy);\n  return 0;\n}\n\u003c/pre\u003e\n\u003cp\u003eThe following fixed version of the program does correctly allocate a heap-based buffer of sufficient size \u003cem\u003eand\u003c/em\u003e (explicitly) terminates it\nwith a null byte (\u003ccode\u003e\u0027\\0\u0027\u003c/code\u003e):\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"6\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n#include \u0026lt;string.h\u0026gt;\n\nchar *make_str_copy(const char *const src) {\n  size_t src_len \u003d strlen(src);\n  // `src_len + 1` since `strlen` _excludes_ the terminating null byte\n  char *dst \u003d (char *)malloc(src_len + 1);\n  if (dst \u003d\u003d NULL) {\n    perror(\"malloc failed\");\n    exit(1);\n  }\n  dst[src_len] \u003d \u0027\\0\u0027; // explicitly add a null terminator\n  strncpy(dst, src, src_len);\n  return dst;\n}\n\nint main(void) {\n  const char str[] \u003d \"Hello, World!\";\n  char *str_copy \u003d make_str_copy(str);\n  printf(\"%s\\n\", str_copy); // Compliant: `str_copy` has been correctly null terminated\n  // More code that processes `str_copy` ...\n  free(str_copy);\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch3\u003eGoing the extra mile\u003c/h3\u003e\n\u003cp\u003eBuffer overflows occur when a program writes data beyond the boundaries of a buffer and can lead to memory corruption and potential security\nvulnerabilities. To mitigate this risk, developers must carefully manage array and buffer sizes. This includes using secure coding practices, and\nemploying techniques like input validation and bounds checking.\u003c/p\u003e\n\u003cp\u003eVarious modern C and C++ compilers allow one to automatically instrument a program during compilation using so-called \u003cem\u003esanitizers\u003c/em\u003e. The\naddress and undefined behavior sanitizers, for instance, aim at detecting out-of-bound memory accesses and undefined behavior, respectively. If the\ninstrumentation detects an error at runtime, the program will abort with an error message that provides valuable information for identifying and\nfixing the error.\u003c/p\u003e\n\u003cp\u003eAdditional capabilities of modern compilers that aim at hardening the binary include the \u003ccode\u003eFORTIFY_SOURCE\u003c/code\u003e compilation flag, or features\nsuch as stack canaries or address space layout randomization (ASLR). These hardening features provide some lightweight support for detecting buffer\noverflows.\u003c/p\u003e\n\u003cp\u003eYet another programming tool for memory debugging is Valgrind. Valgrind inspects a programming during its execution and is capable of detecting\nvarious memory-related issues including buffer overflows.\u003c/p\u003e\n\u003cp\u003eIn C++, manual array or string, i.e., buffer manipulations are considered a code smell.\u003c/p\u003e\n\u003cp\u003eInstead, the \u003ccode\u003estd::array\u003c/code\u003e type should be used to manage stack-based arrays, and the \u003ccode\u003estd::vector\u003c/code\u003e type should be used if a\nheap-based array is desired. Besides always carrying their respective sizes, i.e., number of elements, \u003ccode\u003estd::array\u003c/code\u003e and\n\u003ccode\u003estd::vector\u003c/code\u003e implement many useful member functions such as \u003ccode\u003ebegin()\u003c/code\u003e and \u003ccode\u003eend()\u003c/code\u003e, allowing one to safely and\nconveniently process them using algorithms from the C++\u0027s \u003ccode\u003e\u0026lt;algorithm\u0026gt;\u003c/code\u003e header, for instance. An example is shown in the\nfollowing:\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;algorithm\u0026gt;\n#include \u0026lt;array\u0026gt;\n#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;numeric\u0026gt;\n#include \u0026lt;vector\u0026gt;\n\nvoid bar() {\n  // stack-based array\n  std::array\u0026lt;int, 8\u0026gt; stack_buf;\n  std::fill(stack_buf.begin(), stack_buf.end(), 42);\n  for (auto i : stack_buf) {\n    std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0027 \u0027;\n  }\n  std::cout \u0026lt;\u0026lt; \u0027\\n\u0027;\n  std::cout \u0026lt;\u0026lt; \"sum of stack_buf\u0027s values: \"\n            \u0026lt;\u0026lt; std::accumulate(stack_buf.begin(), stack_buf.end(), 0) \u0026lt;\u0026lt; \u0027\\n\u0027;\n  // heap-based array\n  std::vector\u0026lt;int\u0026gt; heap_buf \u003d {1, 2, 3, 4};\n  heap_buf.resize(10);\n  std::iota(heap_buf.begin(), heap_buf.end(), 1);\n  std::cout \u0026lt;\u0026lt; \"sum of heap_buf\u0027s values: \"\n            \u0026lt;\u0026lt; std::accumulate(heap_buf.begin(), heap_buf.end(), 0) \u0026lt;\u0026lt; \u0027\\n\u0027;\n}\n\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003estd::string\u003c/code\u003e type should be used to manage buffers since it facilitates safe buffer manipulations. Instead of manually\nconcatenating two buffers using \u003ccode\u003estrncat\u003c/code\u003e, for instance, \u003ccode\u003estd::string\u003c/code\u003e allows this operation to be performed in a much more\nconvenient manner as shown in the following code:\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;string\u0026gt;\n\nvoid buz(std::string const \u0026amp;s) {\n  std::string t \u003d \"Hello, \" + s;\n  std::cout \u0026lt;\u0026lt; t \u0026lt;\u0026lt; \u0027\\n\u0027;\n}\n\u003c/pre\u003e\n\u003cp\u003eIn addition, the \u003ccode\u003estd::format\u003c/code\u003e function allows one to format strings according to a user-specified format and returns the result as a\nstring as shown in what follows:\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;format\u0026gt;\n#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;string\u0026gt;\n\nvoid tar(std::string const \u0026amp;s) {\n  std::string t \u003d std::format(\"Hello, World! Greetings {}\\n\", s);\n  std::cout \u0026lt;\u0026lt; t \u0026lt;\u0026lt; \u0027\\n\u0027;\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eArticles \u0026amp; blog posts\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Clang Hardening - \u003ca href\u003d\"https://blog.quarkslab.com/clang-hardening-cheat-sheet.html\"\u003eClang Hardening Cheat Sheet\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e FORTIFY_SOURCE - \u003ca href\u003d\"https://www.redhat.com/en/blog/enhance-application-security-fortifysource\"\u003eEnhance application security with\n  FORTIFY_SOURCE\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e Stack Protection - \u003ca href\u003d\"https://developers.redhat.com/articles/2022/06/02/use-compiler-flags-stack-protection-gcc-and-clang\"\u003eUse compiler\n  flags for stack protection in GCC and Clang\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e Valgrind - \u003ca href\u003d\"https://valgrind.org/docs/manual/quick-start.html\"\u003eThe Valgrind Quick Start Guide\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eConference presentations\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CppCon 2014 - \u003ca href\u003d\"https://youtu.be/V2_80g0eOMc?si\u003dU_qv9iBKI5B3a_EL\"\u003eSanitize your C++ code\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CppCon 2018 - \u003ca href\u003d\"https://youtu.be/0S0QgQd75Sw?si\u003dAW9mA09L5PEbkqXc\"\u003eSoftware Vulnerabilities in C and C++\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CppCon 2020 - \u003ca href\u003d\"https://youtu.be/xEzfnbTabyE?si\u003d9yJQkrcRKn6tuPaV\"\u003e2020: The Year of Sanitizers?\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/wtYxBQ\"\u003eARR30-C. Do not form or use out-of-bounds pointers or array subscripts\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/i3w-BQ\"\u003eSTR50-CPP. Guarantee that storage for strings has sufficient space for character\n  data and the null terminator\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/119\"\u003e119 Improper Restriction of Operations within the Bounds of a Memory Buffer\u003c/a\u003e\n  \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/121\"\u003e121 Stack-based Buffer Overflow\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/122\"\u003e122 Heap-based Buffer Overflow\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/131\"\u003e131 Incorrect Calculation of Buffer Size\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/193\"\u003e193 Off-by-one Error\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/788\"\u003e788 Access of Memory Location After End of Buffer\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:c:S5782} ensures that POSIX functions are not called with arguments that trigger buffer overflows \u003c/li\u003e\n  \u003cli\u003e S5945 discourages the use of C-style arrays and suggests the use of \u003ccode\u003estd::array\u003c/code\u003e or \u003ccode\u003estd::vector\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "cert",
      "cwe",
      "symbolic-execution"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S3518",
    "name": "Zero should not be a possible denominator",
    "defaultSeverity": "CRITICAL",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003cp\u003eEnsure that integer division and remainder operations do not result in divide-by-zero errors.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eIf the denominator to a division or modulo operation is zero, the behavior of the application is undefined.\u003c/p\u003e\n\u003cp\u003eOperator \u003ccode\u003e/\u003c/code\u003e is used for division and \u003ccode\u003e%\u003c/code\u003e for modulo operation. Division and modulo operations are susceptible to\ndivide-by-zero (and signed integer overflow) errors.\u003c/p\u003e\n\u003cpre\u003e\nint foo(int a, int b) {\n  if (b \u003d\u003d 0) {\n    a \u003d 1;\n  }\n  return a / b; // Noncompliant: potential divide-by-zero error\n}\n\u003c/pre\u003e\n\u003ch2\u003eWhat is the potential impact?\u003c/h2\u003e\n\u003cp\u003eInteger division or remainder operations that result in divide-by-zero errors lead to \u003cstrong\u003eundefined behavior\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eFor programs that exercise undefined behavior, the compiler is no longer bound by the language specification. The application may crash or, even\nworse, the application may appear to execute correctly while losing data or producing incorrect results.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eEmploy adequate checks that prevent divide-by-zero errors when using integer division or remainder operations.\u003c/p\u003e\n\u003cp\u003eAlternatively, replace integer division with floating-point division for which the divide-by-zero case is well defined and does not introduce\nundefined behavior.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;limits\u0026gt;\n#include \u0026lt;optional\u0026gt;\n\nstd::optional\u0026lt;int\u0026gt; safe_division(int a, int b) {\n  // While the following check correctly prevents signed integer overflows,\n  // it fails to prevent divide-by-zero errors. If `b` is equal to `0`, the\n  // application emits undefined behavior.\n  if ((a \u003d\u003d std::numeric_limits\u0026lt;int\u0026gt;::min()) \u0026amp;\u0026amp; (b \u003d\u003d -1)) {\n    return std::nullopt;\n  }\n  return a / b; // Noncompliant: causes undefined behavior if `b` is zero\n}\n\nstd::optional\u0026lt;int\u0026gt; foo(int a, int b) {\n  if (b \u003d\u003d 0) {\n    a \u003d 1;\n  }\n  return safe_division(a, b);\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;limits\u0026gt;\n#include \u0026lt;optional\u0026gt;\n\nstd::optional\u0026lt;int\u0026gt; safe_division(int a, int b) {\n  if ((b \u003d\u003d 0) || ((a \u003d\u003d std::numeric_limits\u0026lt;int\u0026gt;::min()) \u0026amp;\u0026amp; (b \u003d\u003d -1))) {\n    return std::nullopt;\n  }\n  return a / b; // Compliant: check correctly prevents divide-by-zero and signed integer overflows\n}\n\nstd::optional\u0026lt;int\u0026gt; foo(int a, int b) {\n  if (b \u003d\u003d 0) {\n    a \u003d 1;\n  }\n  return safe_division(a, b);\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;limits\u0026gt;\n#include \u0026lt;optional\u0026gt;\n\nstd::optional\u0026lt;int\u0026gt; safe_division(int a, int b) {\n  if ((a \u003d\u003d std::numeric_limits\u0026lt;int\u0026gt;::min()) \u0026amp;\u0026amp; (b \u003d\u003d -1)) {\n    return std::nullopt;\n  }\n  return a / b; // Compliant: check to prevent divide-by-zero in the caller\n}\n\nstd::optional\u0026lt;int\u0026gt; foo(int a, int b) {\n  if (b \u003d\u003d 0) {\n    return std::nullopt;\n  }\n  return safe_division(a, b);\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\ndouble foo(int a, int b) {\n  return a / static_cast\u0026lt;double\u0026gt;(b); // Compliant: replace integer division by floating-point division\n}\n\u003c/pre\u003e\n\u003ch3\u003eGoing the extra mile\u003c/h3\u003e\n\u003cp\u003eBesides divide-by-zero errors, signed integer division is susceptible to overflows, too. When the dividend is the minimum value for the signed\ninteger type and the divisor is equal to \u003ccode\u003e-1\u003c/code\u003e an overflow is provoked due to two’s complement representation. This frequently causes\nhard-to-track bugs.\u003c/p\u003e\n\u003cp\u003eThe checks shown in the following code snippet correctly protect the division operation against divide-by-zero \u003cem\u003eand\u003c/em\u003e signed integer overflow\nerrors:\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;limits\u0026gt;\n#include \u0026lt;optional\u0026gt;\n\nstd::optional\u0026lt;int\u0026gt; safe_division(int a, int b) {\n  if ((b \u003d\u003d 0) || ((a \u003d\u003d std::numeric_limits\u0026lt;int\u0026gt;::min()) \u0026amp;\u0026amp; (b \u003d\u003d -1))) {\n    return std::nullopt;\n  }\n  return a / b; // Compliant: prevents divide-by-zero _and_ signed integer overflows\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca\n  href\u003d\"https://wiki.sei.cmu.edu/confluence/display/c/INT32-C.+Ensure+that+operations+on+signed+integers+do+not+result+in+overflow\"\u003eINT32-C. Ensure\n  that operations on signed integers do not result in overflow\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/ftYxBQ\"\u003eINT33-C. Ensure that division and remainder operations do not result in\n  divide-by-zero errors\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/369\"\u003e369 - Divide by zero\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es105-dont-divide-by-integer-zero\"\u003eES.105: Don’t divide by\n  integer zero\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eEnsure that integer division and remainder operations do not result in divide-by-zero errors.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eIf the denominator to a division or modulo operation is zero, the behavior of the application is undefined.\u003c/p\u003e\n\u003cp\u003eOperator \u003ccode\u003e/\u003c/code\u003e is used for division and \u003ccode\u003e%\u003c/code\u003e for modulo operation. Division and modulo operations are susceptible to\ndivide-by-zero (and signed integer overflow) errors.\u003c/p\u003e\n\u003cpre\u003e\nint foo(int a, int b) {\n  if (b \u003d\u003d 0) {\n    a \u003d 1;\n  }\n  return a / b; // Noncompliant: potential divide-by-zero error\n}\n\u003c/pre\u003e\n\u003ch2\u003eWhat is the potential impact?\u003c/h2\u003e\n\u003cp\u003eInteger division or remainder operations that result in divide-by-zero errors lead to \u003cstrong\u003eundefined behavior\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eFor programs that exercise undefined behavior, the compiler is no longer bound by the language specification. The application may crash or, even\nworse, the application may appear to execute correctly while losing data or producing incorrect results.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eEmploy adequate checks that prevent divide-by-zero errors when using integer division or remainder operations.\u003c/p\u003e\n\u003cp\u003eAlternatively, replace integer division with floating-point division for which the divide-by-zero case is well defined and does not introduce\nundefined behavior.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;limits\u0026gt;\n#include \u0026lt;optional\u0026gt;\n\nstd::optional\u0026lt;int\u0026gt; safe_division(int a, int b) {\n  // While the following check correctly prevents signed integer overflows,\n  // it fails to prevent divide-by-zero errors. If `b` is equal to `0`, the\n  // application emits undefined behavior.\n  if ((a \u003d\u003d std::numeric_limits\u0026lt;int\u0026gt;::min()) \u0026amp;\u0026amp; (b \u003d\u003d -1)) {\n    return std::nullopt;\n  }\n  return a / b; // Noncompliant: causes undefined behavior if `b` is zero\n}\n\nstd::optional\u0026lt;int\u0026gt; foo(int a, int b) {\n  if (b \u003d\u003d 0) {\n    a \u003d 1;\n  }\n  return safe_division(a, b);\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;limits\u0026gt;\n#include \u0026lt;optional\u0026gt;\n\nstd::optional\u0026lt;int\u0026gt; safe_division(int a, int b) {\n  if ((b \u003d\u003d 0) || ((a \u003d\u003d std::numeric_limits\u0026lt;int\u0026gt;::min()) \u0026amp;\u0026amp; (b \u003d\u003d -1))) {\n    return std::nullopt;\n  }\n  return a / b; // Compliant: check correctly prevents divide-by-zero and signed integer overflows\n}\n\nstd::optional\u0026lt;int\u0026gt; foo(int a, int b) {\n  if (b \u003d\u003d 0) {\n    a \u003d 1;\n  }\n  return safe_division(a, b);\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;limits\u0026gt;\n#include \u0026lt;optional\u0026gt;\n\nstd::optional\u0026lt;int\u0026gt; safe_division(int a, int b) {\n  if ((a \u003d\u003d std::numeric_limits\u0026lt;int\u0026gt;::min()) \u0026amp;\u0026amp; (b \u003d\u003d -1)) {\n    return std::nullopt;\n  }\n  return a / b; // Compliant: check to prevent divide-by-zero in the caller\n}\n\nstd::optional\u0026lt;int\u0026gt; foo(int a, int b) {\n  if (b \u003d\u003d 0) {\n    return std::nullopt;\n  }\n  return safe_division(a, b);\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\ndouble foo(int a, int b) {\n  return a / static_cast\u0026lt;double\u0026gt;(b); // Compliant: replace integer division by floating-point division\n}\n\u003c/pre\u003e\n\u003ch3\u003eGoing the extra mile\u003c/h3\u003e\n\u003cp\u003eBesides divide-by-zero errors, signed integer division is susceptible to overflows, too. When the dividend is the minimum value for the signed\ninteger type and the divisor is equal to \u003ccode\u003e-1\u003c/code\u003e an overflow is provoked due to two’s complement representation. This frequently causes\nhard-to-track bugs.\u003c/p\u003e\n\u003cp\u003eThe checks shown in the following code snippet correctly protect the division operation against divide-by-zero \u003cem\u003eand\u003c/em\u003e signed integer overflow\nerrors:\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;limits\u0026gt;\n#include \u0026lt;optional\u0026gt;\n\nstd::optional\u0026lt;int\u0026gt; safe_division(int a, int b) {\n  if ((b \u003d\u003d 0) || ((a \u003d\u003d std::numeric_limits\u0026lt;int\u0026gt;::min()) \u0026amp;\u0026amp; (b \u003d\u003d -1))) {\n    return std::nullopt;\n  }\n  return a / b; // Compliant: prevents divide-by-zero _and_ signed integer overflows\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca\n  href\u003d\"https://wiki.sei.cmu.edu/confluence/display/c/INT32-C.+Ensure+that+operations+on+signed+integers+do+not+result+in+overflow\"\u003eINT32-C. Ensure\n  that operations on signed integers do not result in overflow\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/ftYxBQ\"\u003eINT33-C. Ensure that division and remainder operations do not result in\n  divide-by-zero errors\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/369\"\u003e369 - Divide by zero\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es105-dont-divide-by-integer-zero\"\u003eES.105: Don’t divide by\n  integer zero\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "cert",
      "cwe",
      "denial-of-service",
      "symbolic-execution"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S793",
    "name": "All uses of the #pragma directive should be documented",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003e#pragma\u003c/code\u003e directive is implementation-defined, hence it is important both to demonstrate that all uses are correct, and to minimize,\nlocalize and encapsulate any use of pragmas within dedicated functions whenever possible.\u003c/p\u003e\n\u003cp\u003eThe meaning of each pragma shall be documented.\u003c/p\u003e\n\u003cp\u003eThere shall be sufficient supporting description to demonstrate that the behavior of the pragma and its implications for the application, have been\nfully understood.\u003c/p\u003e\n\u003cp\u003eThis rule flags all instances of \u003ccode\u003e#pragma\u003c/code\u003e directives, and leaves it to the user to determine whether they have been properly\ndocumented.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 3.4 - All uses of the #pragma directive shall be documented and explained \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 16-6-1 - All uses of the #pragma directive shall be documented \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/6NUxBQ\"\u003eCERT, MSC00-C\u003c/a\u003e - Compile cleanly at high warning levels \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe \u003ccode\u003e#pragma\u003c/code\u003e directive is implementation-defined, hence it is important both to demonstrate that all uses are correct, and to minimize,\nlocalize and encapsulate any use of pragmas within dedicated functions whenever possible.\u003c/p\u003e\n\u003cp\u003eThe meaning of each pragma shall be documented.\u003c/p\u003e\n\u003cp\u003eThere shall be sufficient supporting description to demonstrate that the behavior of the pragma and its implications for the application, have been\nfully understood.\u003c/p\u003e\n\u003cp\u003eThis rule flags all instances of \u003ccode\u003e#pragma\u003c/code\u003e directives, and leaves it to the user to determine whether they have been properly\ndocumented.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 3.4 - All uses of the #pragma directive shall be documented and explained \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 16-6-1 - All uses of the #pragma directive shall be documented \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/6NUxBQ\"\u003eCERT, MSC00-C\u003c/a\u003e - Compile cleanly at high warning levels \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "based-on-misra",
      "cert"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S1451",
    "name": "Track lack of copyright and license headers",
    "defaultSeverity": "BLOCKER",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "LAWFUL",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eEach source file should start with a header stating file ownership and the license which must be used to distribute the application.\u003c/p\u003e\n\u003cp\u003eThis rule must be fed with the header text that is expected at the beginning of every file.\u003c/p\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n/*\n * SonarQube, open source software quality management tool.\n * Copyright (C) 2008-2013 SonarSource\n * mailto:contact AT sonarsource DOT com\n *\n * SonarQube is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 3 of the License, or (at your option) any later version.\n *\n * SonarQube is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this program; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n */\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eEach source file should start with a header stating file ownership and the license which must be used to distribute the application.\u003c/p\u003e\n\u003cp\u003eThis rule must be fed with the header text that is expected at the beginning of every file.\u003c/p\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n/*\n * SonarQube, open source software quality management tool.\n * Copyright (C) 2008-2013 SonarSource\n * mailto:contact AT sonarsource DOT com\n *\n * SonarQube is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 3 of the License, or (at your option) any later version.\n *\n * SonarQube is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this program; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n */\n\u003c/pre\u003e"
      }
    ],
    "params": {
      "headerFormat": {
        "key": "headerFormat",
        "name": "headerFormat",
        "description": "Expected copyright and license header (plain text)",
        "type": "TEXT",
        "multiple": false,
        "possibleValues": []
      },
      "isRegularExpression": {
        "key": "isRegularExpression",
        "name": "isRegularExpression",
        "description": "Whether the headerFormat is a POSIX regular expression",
        "defaultValue": "false",
        "type": "BOOLEAN",
        "multiple": false,
        "possibleValues": []
      }
    },
    "defaultParams": {
      "isRegularExpression": "false"
    },
    "isActiveByDefault": false,
    "language": "C",
    "tags": [],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S5259",
    "name": "Header guards should be followed by according \"#define\" macro",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eUsing include guards, wrapping around the entire content of a header file, is a best practice ensuring that no matter how many times the header is\nincluded in a translation unit, its content will only be seen once.\u0026nbsp;\u003c/p\u003e\n\u003cp\u003eThe include guard pattern is made up of four parts:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003e#ifndef\u003c/code\u003e at the top of the file, with a unique macro name (usually, the name relates to the file’s name to ensure uniqueness).\n  \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003e#define\u003c/code\u003e\u0026nbsp;with the same macro name. \u003c/li\u003e\n  \u003cli\u003e The content of the file \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003e#endif\u003c/code\u003e at the end of the file \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe rule raises an issue when the name in the second part differs from the first (usually because of a typo or a copy/paste issue).\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#ifndef MYFILE_H\n#define MY_FILE_H // Noncompliant\n//...\n#endif\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#ifndef MYFILE_H\n#define MYFILE_H\n//...\n#endif\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eUsing include guards, wrapping around the entire content of a header file, is a best practice ensuring that no matter how many times the header is\nincluded in a translation unit, its content will only be seen once.\u0026nbsp;\u003c/p\u003e\n\u003cp\u003eThe include guard pattern is made up of four parts:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003e#ifndef\u003c/code\u003e at the top of the file, with a unique macro name (usually, the name relates to the file’s name to ensure uniqueness).\n  \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003e#define\u003c/code\u003e\u0026nbsp;with the same macro name. \u003c/li\u003e\n  \u003cli\u003e The content of the file \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003e#endif\u003c/code\u003e at the end of the file \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe rule raises an issue when the name in the second part differs from the first (usually because of a typo or a copy/paste issue).\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#ifndef MYFILE_H\n#define MY_FILE_H // Noncompliant\n//...\n#endif\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#ifndef MYFILE_H\n#define MYFILE_H\n//...\n#endif\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "unpredictable"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S2665",
    "name": "The \"sizeof\" and \"alignof\" operator should not be used with operands of a \"void\" type",
    "defaultSeverity": "MINOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eAlthough some compilers will allow it, the use of \u003ccode\u003esizeof\u003c/code\u003e and \u003ccode\u003ealignof\u003c/code\u003e with arguments that have a \u003ccode\u003evoid\u003c/code\u003e type is\nforbidden by both the C and C++ standards.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid fun() {\n  void* p;\n  sizeof(*p);  // Noncompliant\n  sizeof(void);  // Noncompliant\n  alignof(*p);  // Noncompliant\n  alignof(void);  // Noncompliant\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eAlthough some compilers will allow it, the use of \u003ccode\u003esizeof\u003c/code\u003e and \u003ccode\u003ealignof\u003c/code\u003e with arguments that have a \u003ccode\u003evoid\u003c/code\u003e type is\nforbidden by both the C and C++ standards.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid fun() {\n  void* p;\n  sizeof(*p);  // Noncompliant\n  sizeof(void);  // Noncompliant\n  alignof(*p);  // Noncompliant\n  alignof(void);  // Noncompliant\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "lock-in"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S1081",
    "name": "Insecure functions should not be used",
    "defaultSeverity": "CRITICAL",
    "type": "VULNERABILITY",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "SECURITY": "HIGH"
    },
    "description": "\u003cp\u003eInsecure functions often involve handling data, such as strings and memory operations. The vulnerability arises when these functions do not\nproperly check or limit the size of the data they are handling.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eAn attacker typically provides input that exceeds the expected size. This could be through a text field in a user interface, a file that the\nprogram reads, or data sent over a network. The insecure function processes this input and places the result into a provided buffer.\u003c/p\u003e\n\u003cp\u003eIf the input is larger than the buffer can handle, the insecure function will overwrite the memory following the buffer. This situation is known as\na buffer overflow vulnerability.\u003c/p\u003e\n\u003cp\u003eWhen using typical C or C++ functions, it’s up to the developer to make sure the size of the buffer to be written to is large enough to avoid\nbuffer overflows.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003ch4\u003eCode execution\u003c/h4\u003e\n\u003cp\u003eIn some cases, an attacker can craft input in a way that allows them to gain unauthorized access to your system. For example, they might be able to\noverwrite a function’s return address in memory, causing your program to execute code of the attacker’s choosing. This could potentially give the\nattacker full control over your system.\u003c/p\u003e\n\u003ch4\u003eDenial of service\u003c/h4\u003e\n\u003cp\u003eIf an attacker can trigger a buffer overflow by providing oversized input, it can cause the program to crash. If the attacker repeats this process,\nit can continually disrupt the service, denying access to other users. This can be particularly damaging for services that require high availability,\nsuch as online platforms or databases.\u003c/p\u003e\n\u003cp\u003eIn some cases, the input might cause the program to enter an infinite loop or consume excessive memory, slowing down the system or even causing it\nto become unresponsive. This type of attack is known as a resource exhaustion DoS attack.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eInsecure functions should be replaced with safer alternatives that limit how much data can be written to the buffer.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n\nchar str[20];\ngets(str); // Noncompliant; `str` buffer size is not checked and it is vulnerable to overflows\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;string.h\u0026gt;\n\nchar buffer[20];\nstrcpy(buffer, input); // Noncompliant; `input` length is not checked and it may overflow `buffer`\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#define __STDC_WANT_LIB_EXT1__\n#include \u0026lt;stdio.h\u0026gt;\n\nchar str[20];\ngets_s(str, sizeof(str));\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\n#define __STDC_WANT_LIB_EXT1__\n#include \u0026lt;string.h\u0026gt;\n\nchar buffer[20];\nstrcpy_s(buffer, sizeof buffer, input);\n\u003c/pre\u003e\n\u003ch3\u003eHow does this work?\u003c/h3\u003e\n\u003cp\u003eC and C++ have a number of functions that are considered insecure because they do not perform bounds checking. Functions like \u003ccode\u003egets\u003c/code\u003e are\nknown to be risky. Replace these with safer alternatives that include bounds checking. For example, instead of \u003ccode\u003egets\u003c/code\u003e, use\n\u003ccode\u003egets_s\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThe code can also checks if the size of input data is less than or equal to the size of a buffer (including the terminating null byte when dealing\nwith strings).\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003egets_s\u003c/code\u003e function is defined in annex K of C11 and is optional for C11 compilers. It will only be available if the macro\n\u003ccode\u003e__STDC_LIB_EXT1__\u003c/code\u003e is defined, and it must be enabled by defining the macro \u003ccode\u003e__STDC_WANT_LIB_EXT1__\u003c/code\u003e before including\n\u003ccode\u003e\u0026lt;stdio.h\u0026gt;\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eOther platform-specific functions can perform the same operations. For example, \u003ccode\u003estrcpy\u003c/code\u003e can be substituted with \u003ca\nhref\u003d\"https://learn.microsoft.com/en-us/windows/win32/api/strsafe/nf-strsafe-stringcbcopya\"\u003eStringCbCopyA\u003c/a\u003e (Windows) or \u003ca\nhref\u003d\"https://www.freebsd.org/cgi/man.cgi?query\u003dstrlcpy\"\u003estrlcpy\u003c/a\u003e (FreeBSD).\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eArticles \u0026amp; blog posts\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Wikipedia - \u003ca href\u003d\"https://en.wikipedia.org/wiki/Buffer_overflow\"\u003eBuffer overflow\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e OWASP - \u003ca href\u003d\"https://owasp.org/Top10/A06_2021-Vulnerable_and_Outdated_Components/\"\u003eTop 10 2021 - A06 - Vulnerable and Outdated\n  Components\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e OWASP - \u003ca href\u003d\"https://owasp.org/www-project-top-ten/2017/A9_2017-Using_Components_with_Known_Vulnerabilities\"\u003eTop 10 2017 Category A9 -\n  Using Components with Known Vulnerabilities\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/676\"\u003eCWE-676 - Use of Potentially Dangerous Function\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/119\"\u003eCWE-119 - Improper Restriction of Operations within the Bounds of a Memory\n  Buffer\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eInsecure functions often involve handling data, such as strings and memory operations. The vulnerability arises when these functions do not\nproperly check or limit the size of the data they are handling.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eAn attacker typically provides input that exceeds the expected size. This could be through a text field in a user interface, a file that the\nprogram reads, or data sent over a network. The insecure function processes this input and places the result into a provided buffer.\u003c/p\u003e\n\u003cp\u003eIf the input is larger than the buffer can handle, the insecure function will overwrite the memory following the buffer. This situation is known as\na buffer overflow vulnerability.\u003c/p\u003e\n\u003cp\u003eWhen using typical C or C++ functions, it’s up to the developer to make sure the size of the buffer to be written to is large enough to avoid\nbuffer overflows.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003ch4\u003eCode execution\u003c/h4\u003e\n\u003cp\u003eIn some cases, an attacker can craft input in a way that allows them to gain unauthorized access to your system. For example, they might be able to\noverwrite a function’s return address in memory, causing your program to execute code of the attacker’s choosing. This could potentially give the\nattacker full control over your system.\u003c/p\u003e\n\u003ch4\u003eDenial of service\u003c/h4\u003e\n\u003cp\u003eIf an attacker can trigger a buffer overflow by providing oversized input, it can cause the program to crash. If the attacker repeats this process,\nit can continually disrupt the service, denying access to other users. This can be particularly damaging for services that require high availability,\nsuch as online platforms or databases.\u003c/p\u003e\n\u003cp\u003eIn some cases, the input might cause the program to enter an infinite loop or consume excessive memory, slowing down the system or even causing it\nto become unresponsive. This type of attack is known as a resource exhaustion DoS attack.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eInsecure functions should be replaced with safer alternatives that limit how much data can be written to the buffer.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n\nchar str[20];\ngets(str); // Noncompliant; `str` buffer size is not checked and it is vulnerable to overflows\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;string.h\u0026gt;\n\nchar buffer[20];\nstrcpy(buffer, input); // Noncompliant; `input` length is not checked and it may overflow `buffer`\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#define __STDC_WANT_LIB_EXT1__\n#include \u0026lt;stdio.h\u0026gt;\n\nchar str[20];\ngets_s(str, sizeof(str));\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\n#define __STDC_WANT_LIB_EXT1__\n#include \u0026lt;string.h\u0026gt;\n\nchar buffer[20];\nstrcpy_s(buffer, sizeof buffer, input);\n\u003c/pre\u003e\n\u003ch3\u003eHow does this work?\u003c/h3\u003e\n\u003cp\u003eC and C++ have a number of functions that are considered insecure because they do not perform bounds checking. Functions like \u003ccode\u003egets\u003c/code\u003e are\nknown to be risky. Replace these with safer alternatives that include bounds checking. For example, instead of \u003ccode\u003egets\u003c/code\u003e, use\n\u003ccode\u003egets_s\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThe code can also checks if the size of input data is less than or equal to the size of a buffer (including the terminating null byte when dealing\nwith strings).\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003egets_s\u003c/code\u003e function is defined in annex K of C11 and is optional for C11 compilers. It will only be available if the macro\n\u003ccode\u003e__STDC_LIB_EXT1__\u003c/code\u003e is defined, and it must be enabled by defining the macro \u003ccode\u003e__STDC_WANT_LIB_EXT1__\u003c/code\u003e before including\n\u003ccode\u003e\u0026lt;stdio.h\u0026gt;\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eOther platform-specific functions can perform the same operations. For example, \u003ccode\u003estrcpy\u003c/code\u003e can be substituted with \u003ca\nhref\u003d\"https://learn.microsoft.com/en-us/windows/win32/api/strsafe/nf-strsafe-stringcbcopya\"\u003eStringCbCopyA\u003c/a\u003e (Windows) or \u003ca\nhref\u003d\"https://www.freebsd.org/cgi/man.cgi?query\u003dstrlcpy\"\u003estrlcpy\u003c/a\u003e (FreeBSD).\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eArticles \u0026amp; blog posts\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Wikipedia - \u003ca href\u003d\"https://en.wikipedia.org/wiki/Buffer_overflow\"\u003eBuffer overflow\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e OWASP - \u003ca href\u003d\"https://owasp.org/Top10/A06_2021-Vulnerable_and_Outdated_Components/\"\u003eTop 10 2021 - A06 - Vulnerable and Outdated\n  Components\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e OWASP - \u003ca href\u003d\"https://owasp.org/www-project-top-ten/2017/A9_2017-Using_Components_with_Known_Vulnerabilities\"\u003eTop 10 2017 Category A9 -\n  Using Components with Known Vulnerabilities\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/676\"\u003eCWE-676 - Use of Potentially Dangerous Function\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/119\"\u003eCWE-119 - Improper Restriction of Operations within the Bounds of a Memory\n  Buffer\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "cert",
      "cwe"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S2612",
    "name": "Setting loose POSIX file permissions is security-sensitive",
    "defaultSeverity": "MAJOR",
    "type": "SECURITY_HOTSPOT",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "SECURITY": "MEDIUM"
    },
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eIn Unix file system permissions, the \"\u003ccode\u003eothers\u003c/code\u003e\" category refers to all users except the owner of the file system resource and the\nmembers of the group assigned to this resource.\u003c/p\u003e\n\u003cp\u003eGranting permissions to this category can lead to unintended access to files or directories that could allow attackers to obtain sensitive\ninformation, disrupt services or elevate privileges.\u003c/p\u003e"
      },
      {
        "key": "assess_the_problem",
        "htmlContent": "\u003ch2\u003eAsk Yourself Whether\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e The application is designed to be run on a multi-user environment. \u003c/li\u003e\n  \u003cli\u003e Corresponding files and directories may contain confidential information. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere is a risk if you answered yes to any of those questions.\u003c/p\u003e\n\u003ch2\u003eSensitive Code Example\u003c/h2\u003e\n\u003cp\u003eWhen creating a file or directory with permissions to \"other group\":\u003c/p\u003e\n\u003cpre\u003e\nopen(\"myfile.txt\", O_CREAT, S_IRWXU | S_IRWXG | S_IRWXO); // Sensitive: the process set 777 permissions to this newly created file\n\nmkdir(\"myfolder\", S_IRWXU | S_IRWXG | S_IRWXO); // Sensitive: the process try to set 777 permissions to this newly created directory\n\u003c/pre\u003e\n\u003cp\u003eWhen explicitly adding permissions to \"other group\" with \u003ccode\u003echmod\u003c/code\u003e, \u003ccode\u003efchmod\u003c/code\u003e or \u003ccode\u003efilesystem::permissions\u003c/code\u003e\nfunctions:\u003c/p\u003e\n\u003cpre\u003e\nchmod(\"myfile.txt\", S_IRWXU | S_IRWXG | S_IRWXO);  // Sensitive: the process set 777 permissions to this file\n\nfchmod(fd, S_IRWXU | S_IRWXG | S_IRWXO); // Sensitive: the process set 777 permissions to this file descriptor\n\u003c/pre\u003e\n\u003cp\u003eWhen defining the \u003ccode\u003eumask\u003c/code\u003e without read, write and execute permissions for \"other group\":\u003c/p\u003e\n\u003cpre\u003e\numask(S_IRWXU | S_IRWXG); // Sensitive: the further files and folders will be created with possible permissions to \"other group\"\n\u003c/pre\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003ch2\u003eRecommended Secure Coding Practices\u003c/h2\u003e\n\u003cp\u003eThe most restrictive possible permissions should be assigned to files and directories.\u003c/p\u003e\n\u003ch2\u003eCompliant Solution\u003c/h2\u003e\n\u003cp\u003eWhen creating a file or directory, do not set permissions to \"other group\":\u003c/p\u003e\n\u003cpre\u003e\nopen(\"myfile.txt\", O_CREAT, S_IRWXU | S_IRWXG); // Compliant\n\nmkdir(\"myfolder\", S_IRWXU | S_IRWXG); // Compliant\n\u003c/pre\u003e\n\u003cp\u003eWhen using \u003ccode\u003echmod\u003c/code\u003e, \u003ccode\u003efchmod\u003c/code\u003e or \u003ccode\u003efilesystem::permissions\u003c/code\u003e functions, do not add permissions to \"other group\":\u003c/p\u003e\n\u003cpre\u003e\nchmod(\"myfile.txt\", S_IRWXU | S_IRWXG);  // Compliant\n\nfchmod(fd, S_IRWXU | S_IRWXG); // Compliant\n\u003c/pre\u003e\n\u003cp\u003eWhen defining the \u003ccode\u003eumask\u003c/code\u003e, set read, write and execute permissions to other group:\u003c/p\u003e\n\u003cpre\u003e\numask(S_IRWXO); // Compliant: further created files or directories will not have permissions set for \"other group\"\n\u003c/pre\u003e\n\u003ch2\u003eSee\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/Top10/A01_2021-Broken_Access_Control/\"\u003eOWASP Top 10 2021 Category A1\u003c/a\u003e - Broken Access Control \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/Top10/A04_2021-Insecure_Design/\"\u003eOWASP Top 10 2021 Category A4\u003c/a\u003e - Insecure Design \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control\"\u003eOWASP Top 10 2017 Category A5\u003c/a\u003e - Broken Access Control\n  \u003c/li\u003e\n  \u003cli\u003e \u003ca\n  href\u003d\"https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/02-Configuration_and_Deployment_Management_Testing/09-Test_File_Permission\"\u003eOWASP File Permission\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/732\"\u003eMITRE, CWE-732\u003c/a\u003e - Incorrect Permission Assignment for Critical Resource \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/266\"\u003eMITRE, CWE-266\u003c/a\u003e - Incorrect Privilege Assignment \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/display/c/FIO06-C.+Create+files+with+appropriate+access+permissions\"\u003eCERT, FIO06-C.\u003c/a\u003e - Create\n  files with appropriate access permissions \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "cert",
      "cwe"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": [],
    "vulnerabilityProbability": "MEDIUM"
  },
  {
    "key": "c:S1767",
    "name": "Pointers should not be cast to integral types",
    "defaultSeverity": "CRITICAL",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe size of integer required to hold a memory address is implementation-dependent. Therefore, casting a pointer (i.e. a memory address) to any\nintegral data type may result in data loss because the integral type is too small to hold the full address value.\u003c/p\u003e\n\u003cp\u003eWhen treating a memory address as integer type is absolutely required, you should be sure to use a large enough type to hold all the data.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint *p;\nint addr \u003d ( int ) \u0026amp;p;\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 11.3 - A cast should not be performed between a pointer type and an integral type. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 5-2-9 - A cast should not convert a pointer type to an integral type. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 11.4 - A conversion should not be performed between a pointer to object and an integer type \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/0dUxBQ\"\u003eCERT, INT36-C.\u003c/a\u003e - Converting a pointer to integer or integer to pointer \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe size of integer required to hold a memory address is implementation-dependent. Therefore, casting a pointer (i.e. a memory address) to any\nintegral data type may result in data loss because the integral type is too small to hold the full address value.\u003c/p\u003e\n\u003cp\u003eWhen treating a memory address as integer type is absolutely required, you should be sure to use a large enough type to hold all the data.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint *p;\nint addr \u003d ( int ) \u0026amp;p;\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 11.3 - A cast should not be performed between a pointer type and an integral type. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 5-2-9 - A cast should not convert a pointer type to an integral type. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 11.4 - A conversion should not be performed between a pointer to object and an integer type \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/0dUxBQ\"\u003eCERT, INT36-C.\u003c/a\u003e - Converting a pointer to integer or integer to pointer \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "based-on-misra",
      "cert"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S1768",
    "name": "The sign of an unsigned variable should not be tested",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eBecause the value in a variable of an unsigned type can never be less than zero, testing to see if it is negative is a useless operation which can\nonly confuse future readers of the code.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nunsigned int i \u003d 0; // the lowest value this var can have\n...\nif (i \u0026gt;\u003d 0) { // Noncompliant\n  do_x(i);\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nunsigned int i \u003d 0;\n...\ndo_x(i);\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eBecause the value in a variable of an unsigned type can never be less than zero, testing to see if it is negative is a useless operation which can\nonly confuse future readers of the code.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nunsigned int i \u003d 0; // the lowest value this var can have\n...\nif (i \u0026gt;\u003d 0) { // Noncompliant\n  do_x(i);\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nunsigned int i \u003d 0;\n...\ndo_x(i);\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S3949",
    "name": "Integral operations should not overflow",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eNumbers are infinite, but the types that hold them are not. Each numeric type has hard upper and lower bounds. Try to calculate or assign numbers\nbeyond those bounds, and the result will be surprising:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e For unsigned types, it will be a value that has silently wrapped around from the expected positive value to another one, following the rules of\n  modular arithmetic (if the maximum \u003ccode\u003eunsigned char\u003c/code\u003e is 255, adding 10 to an \u003ccode\u003eunsigned char\u003c/code\u003e equals to 250 will yield the value\n  4) \u003c/li\u003e\n  \u003cli\u003e For signed type, this is undefined behavior. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid test(char c) {\n  switch (c) {\n    case 2000: // Noncompliant\n      // ...\n      break;\n  }\n\n  int a \u003d 4608 * 1024 * 1024; // Noncompliant\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eNumbers are infinite, but the types that hold them are not. Each numeric type has hard upper and lower bounds. Try to calculate or assign numbers\nbeyond those bounds, and the result will be surprising:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e For unsigned types, it will be a value that has silently wrapped around from the expected positive value to another one, following the rules of\n  modular arithmetic (if the maximum \u003ccode\u003eunsigned char\u003c/code\u003e is 255, adding 10 to an \u003ccode\u003eunsigned char\u003c/code\u003e equals to 250 will yield the value\n  4) \u003c/li\u003e\n  \u003cli\u003e For signed type, this is undefined behavior. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid test(char c) {\n  switch (c) {\n    case 2000: // Noncompliant\n      // ...\n      break;\n  }\n\n  int a \u003d 4608 * 1024 * 1024; // Noncompliant\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "based-on-misra",
      "cert",
      "misra-c2004",
      "misra-c2012",
      "overflow"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S100",
    "name": "Function names should comply with a naming convention",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "IDENTIFIABLE",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eShared naming conventions allow teams to collaborate efficiently.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when a function name does not match a provided regular expression.\u003c/p\u003e\n\u003cp\u003eFor example, with the default provided regular expression: \u003ccode\u003e^[a-z][a-zA-Z0-9]*$\u003c/code\u003e, the function:\u003c/p\u003e\n\u003cpre\u003e\nvoid DoSomething(); // Noncompliant\n\u003c/pre\u003e\n\u003cp\u003eshould be renamed to\u003c/p\u003e\n\u003cpre\u003e\nvoid doSomething();\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThe rule ignores the names of:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Overriding methods \u003c/li\u003e\n  \u003cli\u003e Template specializations \u003c/li\u003e\n  \u003cli\u003e When an interface expects a specific name (e.g., \u003ccode\u003ebegin\u003c/code\u003e or \u003ccode\u003eend\u003c/code\u003e for range-based loops, \u003ccode\u003eget\u0026lt;N\u0026gt;\u003c/code\u003e for\n  structural binding, etc.) \u003c/li\u003e\n  \u003cli\u003e Coroutines (S6193 covers them) \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e S6193 - Coroutine names should comply with a naming convention \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eShared naming conventions allow teams to collaborate efficiently.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when a function name does not match a provided regular expression.\u003c/p\u003e\n\u003cp\u003eFor example, with the default provided regular expression: \u003ccode\u003e^[a-z][a-zA-Z0-9]*$\u003c/code\u003e, the function:\u003c/p\u003e\n\u003cpre\u003e\nvoid DoSomething(); // Noncompliant\n\u003c/pre\u003e\n\u003cp\u003eshould be renamed to\u003c/p\u003e\n\u003cpre\u003e\nvoid doSomething();\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThe rule ignores the names of:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Overriding methods \u003c/li\u003e\n  \u003cli\u003e Template specializations \u003c/li\u003e\n  \u003cli\u003e When an interface expects a specific name (e.g., \u003ccode\u003ebegin\u003c/code\u003e or \u003ccode\u003eend\u003c/code\u003e for range-based loops, \u003ccode\u003eget\u0026lt;N\u0026gt;\u003c/code\u003e for\n  structural binding, etc.) \u003c/li\u003e\n  \u003cli\u003e Coroutines (S6193 covers them) \u003c/li\u003e\n\u003c/ul\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e S6193 - Coroutine names should comply with a naming convention \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {
      "format": {
        "key": "format",
        "name": "format",
        "description": "POSIX regular expression used to check the function names against",
        "defaultValue": "^[a-z][a-zA-Z0-9]*$",
        "type": "STRING",
        "multiple": false,
        "possibleValues": []
      }
    },
    "defaultParams": {
      "format": "^[a-z][a-zA-Z0-9]*$"
    },
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "convention"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S6655",
    "name": "Variables should not be accessed outside of their scope",
    "defaultSeverity": "BLOCKER",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003cp\u003eAccessing local objects outside of their scope (for example, via a pointer taken inside the scope) has undefined behavior. This rule flags such\naccess for local variables and lifetime-extended temporaries.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eLocal variables in C++ are attached to the scope and destroyed when the end of the scope is reached. Any access to a variable outside of their\nscope has undefined behavior.\u003c/p\u003e\n\u003cp\u003eSuch access occurs, for example, when the address of a variable is stored in a pointer that is later dereferenced:\u003c/p\u003e\n\u003cpre\u003e\nint func() {\n  int* ptr \u003d nullptr;\n  {\n    int i \u003d 10;\n    ptr \u003d \u0026amp;i;\n  } // variable i goes out of scope here\n  *ptr \u003d 10; // Noncompliant: writing to out-of-scope-variable\n}\n\u003c/pre\u003e\n\u003cp\u003eA similar defect can occur in code that does not have curly braces (also referred to as a compound statement), but contain control structures, like\n\u003ccode\u003eif\u003c/code\u003e or \u003ccode\u003efor\u003c/code\u003e that also introduce scope:\u003c/p\u003e\n\u003cpre\u003e\nint exampleWithIf() {\n  int* ptr;\n  if (int i \u003d 10)\n    ptr \u003d \u0026amp;i;\n  else\n    ptr \u003d nullptr;\n  // variable i declared in if condition statement goes out of scope here\n  if (ptr)\n    return *ptr; // Noncompliant: reading from out-of-scope variable\n  return 0;\n}\nvoid exampleWithFor() {\n  int* ptr \u003d nullptr;\n  for (int i \u003d 0; i \u0026lt; 10; ++i)\n    ptr \u003d \u0026amp;i;\n  // variable i defined in for init-statement goes out of scope here\n  *ptr \u003d 10; // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eAccessing a dangling reference or pointer causes undefined behavior. This means the compiler is not bound by the language standard anymore and your\nprogram has no meaning assigned to it.\u003c/p\u003e\n\u003cp\u003ePractically this has a wide range of effects. In many cases, the access works by accident and succeeds at writing or reading a value. However, it\ncan start misbehaving at any time. If compilation flags, compiler, platform, or runtime environment change, the same code can crash the application,\ncorrupt memory, or leak a secret.\u003c/p\u003e\n\u003ch3\u003eWhy is the issue raised for reference variables?\u003c/h3\u003e\n\u003cp\u003eWhen a reference variable is directly initialized to a temporary object, such temporary is lifetime-extended by the variable, i.e., the temporary\nobject is destroyed when the variable goes out of scope. Lifetime-extended temporaries have the same behavior as if they were declared as local\nvariables and may lead to the same issues. For example:\u003c/p\u003e\n\u003cpre\u003e\nClazz create();\nvoid refExtension(Clazz const arg) {\n  Clazz const* aPtr;\n  Clazz const* tPtr;\n  {\n    Clazz const\u0026amp; aRef \u003d arg; // bounding reference to object arg\n    Clazz const\u0026amp; tRef \u003d create(); // temporary object is created here and bound to reference,\n                                  // behaves as Clazz const tRef \u003d create();\n    aPtr \u003d \u0026amp;aRef;  // points to arg\n    tPtr \u003d \u0026amp;tRef;  // point to a temporary object that is lifetime extended\n  } // both aRef and tRef go out of scope here, because tRef was extending the lifetime of\n    // temporary variable, the object is destroyed\n  aPtr-\u0026gt;foo(); // OK, a points to arg\n  tPtr-\u0026gt;foo(); // Noncompliant: the pointers point to a dangling temporary\n}\n\u003c/pre\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eCommonly, the use of an out-of-scope local object is an indication of a defect in code, where the local object was used by mistake, and in such\ncase, replacing it with the desired variable or removing the use is sufficient. For other scenarios, two general approaches are possible:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Extending the scope of the referenced variable \u003c/li\u003e\n  \u003cli\u003e Capturing a copy of the object instead of a pointer to it \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWhenever possible, it is preferable to use or create a dedicated algorithm that encapsulates the uses of pointers to local objects.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;span\u0026gt;\n#include \u0026lt;optional\u0026gt;\nstd::optional\u0026lt;int\u0026gt; minimum(std::span\u0026lt;int const\u0026gt; s) {\n  if (s.empty()) {\n    return std::nullopt;\n  }\n  int const* min \u003d nullptr;\n  for (int i \u003d 0; i \u0026lt; s.size(); ++i) {\n    if ((min \u003d\u003d nullptr) || (*min \u0026lt; s[i]))\n      min \u003d \u0026amp;i;  // should be address of \u0026amp;s[i]\n  }\n  return *min; // Noncompliant: dangling\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eFixing the typo, and taking the address of \u003ccode\u003e\u0026amp;s[i]\u003c/code\u003e:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;span\u0026gt;\n#include \u0026lt;optional\u0026gt;\nstd::optional\u0026lt;int\u0026gt; minimum(std::span\u0026lt;int const\u0026gt; s) {\n  if (s.empty()) {\n    return std::nullopt;\n  }\n  int const* min \u003d nullptr;\n  for (int i \u003d 0; i \u0026lt; s.size(); ++i) {\n    if ((min \u003d\u003d nullptr) || (*min \u0026lt; s[i]))\n      min \u003d \u0026amp;s[i];\n  }\n  return *min; // Compliant, points to an element of s\n}\n\u003c/pre\u003e\n\u003cp\u003eStoring a copy instead of a pointer:\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;span\u0026gt;\n#include \u0026lt;optional\u0026gt;\nstd::optional\u0026lt;int\u0026gt; minimum(span\u0026lt;int const\u0026gt; s) {\n   std::optional\u0026lt;int\u0026gt; min;\n   for (int i \u003d 0; i \u0026lt; s.size(); ++i) {\n      if (min.has_value() || (*min \u0026lt; s[i]))\n        min \u003d s[i];\n   }\n   return min; // Compliant, copy of the minimum element\n}\n\u003c/pre\u003e\n\u003cp\u003eUsing a dedicated algorithm that avoids the need to store the pointer:\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;span\u0026gt;\n#include \u0026lt;optional\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\nstd::optional\u0026lt;int\u0026gt; minimum(std::span\u0026lt;int const\u0026gt; s) {\n  auto it \u003d std::min_element(s.begin(), s.end());\n  if (it \u003d\u003d s.end())\n    return std::nullopt;\n  return *it;\n}\n\u003c/pre\u003e\n\u003ch3\u003ePitfalls\u003c/h3\u003e\n\u003cp\u003eReducing the number of nested scopes is not always the right solution to fix the issue because, for the variables that represent resources (using\nRAII idiom), the scope of the variables plays an important role in the correctness of the program. As an illustration, let’s consider the following\nexample that uses \u003ccode\u003estd::unique_lock\u003c/code\u003e that represents a lock of a mutex:\u003c/p\u003e\n\u003cpre\u003e\nstd::mutex dataMutex;\nData data;\nvoid process() {\n  Element e;\n  { // scope A\n    std::unique_lock\u0026lt;std::mutex\u0026gt; l1(dataMutex); // mutex is locked in constructor\n    e \u003d data.fetch();\n  } // l1 destructor is called here, and the lock is unlocked\n  // do processing of the element\n  if (e.finished())\n    return;\n  { // scope B\n    std::unique_lock\u0026lt;std::mutex\u0026gt; l2(dataMutex); // mutex is locked in constructor\n    data.append(std::move(e));\n  } // l2 destructor is called here, and the mutex is unlocked\n}\n\u003c/pre\u003e\n\u003cp\u003eIn the above example, scopes \u003ccode\u003eA\u003c/code\u003e and \u003ccode\u003eB\u003c/code\u003e limit the number of operations performed in the critical section (when the mutex is\nacquired). Removing all nested scopes would lead to deadlock, where \u003ccode\u003el2\u003c/code\u003e will try to lock \u003ccode\u003edataMutex\u003c/code\u003e, already acquired in the\nsame thread by the constructor of \u003ccode\u003el1\u003c/code\u003e.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/lifetime\"\u003eLifetime\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/raii\"\u003eRAII\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/thread/unique_lock\"\u003eunique_lock\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eArticles \u0026amp; blog posts\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Abseil - \u003ca href\u003d\"https://abseil.io/tips/107\"\u003eTip of the Week #107: Reference Lifetime Extension\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e S5553 detects uses of reclaimed temporary variables that are not lifetime-extended. \u003c/li\u003e\n  \u003cli\u003e {rule:c:S946} detects situation when address of reference to local variable is returned from function \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eAccessing local objects outside of their scope (for example, via a pointer taken inside the scope) has undefined behavior. This rule flags such\naccess for local variables and lifetime-extended temporaries.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eLocal variables in C++ are attached to the scope and destroyed when the end of the scope is reached. Any access to a variable outside of their\nscope has undefined behavior.\u003c/p\u003e\n\u003cp\u003eSuch access occurs, for example, when the address of a variable is stored in a pointer that is later dereferenced:\u003c/p\u003e\n\u003cpre\u003e\nint func() {\n  int* ptr \u003d nullptr;\n  {\n    int i \u003d 10;\n    ptr \u003d \u0026amp;i;\n  } // variable i goes out of scope here\n  *ptr \u003d 10; // Noncompliant: writing to out-of-scope-variable\n}\n\u003c/pre\u003e\n\u003cp\u003eA similar defect can occur in code that does not have curly braces (also referred to as a compound statement), but contain control structures, like\n\u003ccode\u003eif\u003c/code\u003e or \u003ccode\u003efor\u003c/code\u003e that also introduce scope:\u003c/p\u003e\n\u003cpre\u003e\nint exampleWithIf() {\n  int* ptr;\n  if (int i \u003d 10)\n    ptr \u003d \u0026amp;i;\n  else\n    ptr \u003d nullptr;\n  // variable i declared in if condition statement goes out of scope here\n  if (ptr)\n    return *ptr; // Noncompliant: reading from out-of-scope variable\n  return 0;\n}\nvoid exampleWithFor() {\n  int* ptr \u003d nullptr;\n  for (int i \u003d 0; i \u0026lt; 10; ++i)\n    ptr \u003d \u0026amp;i;\n  // variable i defined in for init-statement goes out of scope here\n  *ptr \u003d 10; // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eAccessing a dangling reference or pointer causes undefined behavior. This means the compiler is not bound by the language standard anymore and your\nprogram has no meaning assigned to it.\u003c/p\u003e\n\u003cp\u003ePractically this has a wide range of effects. In many cases, the access works by accident and succeeds at writing or reading a value. However, it\ncan start misbehaving at any time. If compilation flags, compiler, platform, or runtime environment change, the same code can crash the application,\ncorrupt memory, or leak a secret.\u003c/p\u003e\n\u003ch3\u003eWhy is the issue raised for reference variables?\u003c/h3\u003e\n\u003cp\u003eWhen a reference variable is directly initialized to a temporary object, such temporary is lifetime-extended by the variable, i.e., the temporary\nobject is destroyed when the variable goes out of scope. Lifetime-extended temporaries have the same behavior as if they were declared as local\nvariables and may lead to the same issues. For example:\u003c/p\u003e\n\u003cpre\u003e\nClazz create();\nvoid refExtension(Clazz const arg) {\n  Clazz const* aPtr;\n  Clazz const* tPtr;\n  {\n    Clazz const\u0026amp; aRef \u003d arg; // bounding reference to object arg\n    Clazz const\u0026amp; tRef \u003d create(); // temporary object is created here and bound to reference,\n                                  // behaves as Clazz const tRef \u003d create();\n    aPtr \u003d \u0026amp;aRef;  // points to arg\n    tPtr \u003d \u0026amp;tRef;  // point to a temporary object that is lifetime extended\n  } // both aRef and tRef go out of scope here, because tRef was extending the lifetime of\n    // temporary variable, the object is destroyed\n  aPtr-\u0026gt;foo(); // OK, a points to arg\n  tPtr-\u0026gt;foo(); // Noncompliant: the pointers point to a dangling temporary\n}\n\u003c/pre\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eCommonly, the use of an out-of-scope local object is an indication of a defect in code, where the local object was used by mistake, and in such\ncase, replacing it with the desired variable or removing the use is sufficient. For other scenarios, two general approaches are possible:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Extending the scope of the referenced variable \u003c/li\u003e\n  \u003cli\u003e Capturing a copy of the object instead of a pointer to it \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWhenever possible, it is preferable to use or create a dedicated algorithm that encapsulates the uses of pointers to local objects.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;span\u0026gt;\n#include \u0026lt;optional\u0026gt;\nstd::optional\u0026lt;int\u0026gt; minimum(std::span\u0026lt;int const\u0026gt; s) {\n  if (s.empty()) {\n    return std::nullopt;\n  }\n  int const* min \u003d nullptr;\n  for (int i \u003d 0; i \u0026lt; s.size(); ++i) {\n    if ((min \u003d\u003d nullptr) || (*min \u0026lt; s[i]))\n      min \u003d \u0026amp;i;  // should be address of \u0026amp;s[i]\n  }\n  return *min; // Noncompliant: dangling\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eFixing the typo, and taking the address of \u003ccode\u003e\u0026amp;s[i]\u003c/code\u003e:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;span\u0026gt;\n#include \u0026lt;optional\u0026gt;\nstd::optional\u0026lt;int\u0026gt; minimum(std::span\u0026lt;int const\u0026gt; s) {\n  if (s.empty()) {\n    return std::nullopt;\n  }\n  int const* min \u003d nullptr;\n  for (int i \u003d 0; i \u0026lt; s.size(); ++i) {\n    if ((min \u003d\u003d nullptr) || (*min \u0026lt; s[i]))\n      min \u003d \u0026amp;s[i];\n  }\n  return *min; // Compliant, points to an element of s\n}\n\u003c/pre\u003e\n\u003cp\u003eStoring a copy instead of a pointer:\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;span\u0026gt;\n#include \u0026lt;optional\u0026gt;\nstd::optional\u0026lt;int\u0026gt; minimum(span\u0026lt;int const\u0026gt; s) {\n   std::optional\u0026lt;int\u0026gt; min;\n   for (int i \u003d 0; i \u0026lt; s.size(); ++i) {\n      if (min.has_value() || (*min \u0026lt; s[i]))\n        min \u003d s[i];\n   }\n   return min; // Compliant, copy of the minimum element\n}\n\u003c/pre\u003e\n\u003cp\u003eUsing a dedicated algorithm that avoids the need to store the pointer:\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;span\u0026gt;\n#include \u0026lt;optional\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\nstd::optional\u0026lt;int\u0026gt; minimum(std::span\u0026lt;int const\u0026gt; s) {\n  auto it \u003d std::min_element(s.begin(), s.end());\n  if (it \u003d\u003d s.end())\n    return std::nullopt;\n  return *it;\n}\n\u003c/pre\u003e\n\u003ch3\u003ePitfalls\u003c/h3\u003e\n\u003cp\u003eReducing the number of nested scopes is not always the right solution to fix the issue because, for the variables that represent resources (using\nRAII idiom), the scope of the variables plays an important role in the correctness of the program. As an illustration, let’s consider the following\nexample that uses \u003ccode\u003estd::unique_lock\u003c/code\u003e that represents a lock of a mutex:\u003c/p\u003e\n\u003cpre\u003e\nstd::mutex dataMutex;\nData data;\nvoid process() {\n  Element e;\n  { // scope A\n    std::unique_lock\u0026lt;std::mutex\u0026gt; l1(dataMutex); // mutex is locked in constructor\n    e \u003d data.fetch();\n  } // l1 destructor is called here, and the lock is unlocked\n  // do processing of the element\n  if (e.finished())\n    return;\n  { // scope B\n    std::unique_lock\u0026lt;std::mutex\u0026gt; l2(dataMutex); // mutex is locked in constructor\n    data.append(std::move(e));\n  } // l2 destructor is called here, and the mutex is unlocked\n}\n\u003c/pre\u003e\n\u003cp\u003eIn the above example, scopes \u003ccode\u003eA\u003c/code\u003e and \u003ccode\u003eB\u003c/code\u003e limit the number of operations performed in the critical section (when the mutex is\nacquired). Removing all nested scopes would lead to deadlock, where \u003ccode\u003el2\u003c/code\u003e will try to lock \u003ccode\u003edataMutex\u003c/code\u003e, already acquired in the\nsame thread by the constructor of \u003ccode\u003el1\u003c/code\u003e.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/lifetime\"\u003eLifetime\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/raii\"\u003eRAII\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/thread/unique_lock\"\u003eunique_lock\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eArticles \u0026amp; blog posts\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Abseil - \u003ca href\u003d\"https://abseil.io/tips/107\"\u003eTip of the Week #107: Reference Lifetime Extension\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e S5553 detects uses of reclaimed temporary variables that are not lifetime-extended. \u003c/li\u003e\n  \u003cli\u003e {rule:c:S946} detects situation when address of reference to local variable is returned from function \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "symbolic-execution"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S1760",
    "name": "Keywords introduced in later specifications should not be used as identifiers",
    "defaultSeverity": "BLOCKER",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhile keywords introduced in later standards can legally be used as identifiers in code compiled to earlier standards, doing so will eventually\ncause problems. Such code will cause compile errors if (when) the compiler is upgraded, and fixing those errors could be difficult and painful.\u003c/p\u003e\n\u003cp\u003eAdditionally, such misuse of keywords has the potential to thoroughly confuse people who are unfamiliar with the code base, possibly leading them\nto introduce additional errors.\u003c/p\u003e\n\u003cp\u003eFor these reasons, the earlier this practice is stopped, the better.\u003c/p\u003e\n\u003cp\u003eThis rule flags instances of the following keywords used as identifiers:\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eC99\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003einline\u003c/code\u003e, \u003ccode\u003erestrict\u003c/code\u003e, \u003ccode\u003e_Bool\u003c/code\u003e, \u003ccode\u003e_Complex\u003c/code\u003e, \u003ccode\u003e_Noreturn\u003c/code\u003e, \u003ccode\u003e_Static_assert\u003c/code\u003e,\n\u003ccode\u003e_Thread_local\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eC11\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e_Alignas\u003c/code\u003e, \u003ccode\u003e_Alignof\u003c/code\u003e, \u003ccode\u003e_Atomic\u003c/code\u003e, \u003ccode\u003e_Generic\u003c/code\u003e, \u003ccode\u003e_Imaginary\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eC++11\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ealignas\u003c/code\u003e, \u003ccode\u003ealignof\u003c/code\u003e, \u003ccode\u003echar16_t\u003c/code\u003e, \u003ccode\u003echar32_t\u003c/code\u003e, \u003ccode\u003econstexpr\u003c/code\u003e, \u003ccode\u003edecltype\u003c/code\u003e,\n\u003ccode\u003enoexcept\u003c/code\u003e, \u003ccode\u003enullptr\u003c/code\u003e, \u003ccode\u003estatic_assert\u003c/code\u003e, \u003ccode\u003ethread_local\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eC++20\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003econcept\u003c/code\u003e, \u003ccode\u003erequires\u003c/code\u003e, \u003ccode\u003econstinit\u003c/code\u003e, \u003ccode\u003econsteval\u003c/code\u003e, \u003ccode\u003eco_await\u003c/code\u003e, \u003ccode\u003eco_return\u003c/code\u003e,\n\u003ccode\u003eco_yield\u003c/code\u003e, \u003ccode\u003echar8_t\u003c/code\u003e\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint inline \u003d 0;\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint inline_count \u003d 0;\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhile keywords introduced in later standards can legally be used as identifiers in code compiled to earlier standards, doing so will eventually\ncause problems. Such code will cause compile errors if (when) the compiler is upgraded, and fixing those errors could be difficult and painful.\u003c/p\u003e\n\u003cp\u003eAdditionally, such misuse of keywords has the potential to thoroughly confuse people who are unfamiliar with the code base, possibly leading them\nto introduce additional errors.\u003c/p\u003e\n\u003cp\u003eFor these reasons, the earlier this practice is stopped, the better.\u003c/p\u003e\n\u003cp\u003eThis rule flags instances of the following keywords used as identifiers:\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eC99\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003einline\u003c/code\u003e, \u003ccode\u003erestrict\u003c/code\u003e, \u003ccode\u003e_Bool\u003c/code\u003e, \u003ccode\u003e_Complex\u003c/code\u003e, \u003ccode\u003e_Noreturn\u003c/code\u003e, \u003ccode\u003e_Static_assert\u003c/code\u003e,\n\u003ccode\u003e_Thread_local\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eC11\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e_Alignas\u003c/code\u003e, \u003ccode\u003e_Alignof\u003c/code\u003e, \u003ccode\u003e_Atomic\u003c/code\u003e, \u003ccode\u003e_Generic\u003c/code\u003e, \u003ccode\u003e_Imaginary\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eC++11\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ealignas\u003c/code\u003e, \u003ccode\u003ealignof\u003c/code\u003e, \u003ccode\u003echar16_t\u003c/code\u003e, \u003ccode\u003echar32_t\u003c/code\u003e, \u003ccode\u003econstexpr\u003c/code\u003e, \u003ccode\u003edecltype\u003c/code\u003e,\n\u003ccode\u003enoexcept\u003c/code\u003e, \u003ccode\u003enullptr\u003c/code\u003e, \u003ccode\u003estatic_assert\u003c/code\u003e, \u003ccode\u003ethread_local\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eC++20\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003econcept\u003c/code\u003e, \u003ccode\u003erequires\u003c/code\u003e, \u003ccode\u003econstinit\u003c/code\u003e, \u003ccode\u003econsteval\u003c/code\u003e, \u003ccode\u003eco_await\u003c/code\u003e, \u003ccode\u003eco_return\u003c/code\u003e,\n\u003ccode\u003eco_yield\u003c/code\u003e, \u003ccode\u003echar8_t\u003c/code\u003e\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint inline \u003d 0;\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint inline_count \u003d 0;\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "lock-in"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S5443",
    "name": "Using publicly writable directories is security-sensitive",
    "defaultSeverity": "CRITICAL",
    "type": "SECURITY_HOTSPOT",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "SECURITY": "HIGH"
    },
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eOperating systems have global directories where any user has write access. Those folders are mostly used as temporary storage areas like\n\u003ccode\u003e/tmp\u003c/code\u003e in Linux based systems. An application manipulating files from these folders is exposed to race conditions on filenames: a malicious\nuser can try to create a file with a predictable name before the application does. A successful attack can result in other files being accessed,\nmodified, corrupted or deleted. This risk is even higher if the application runs with elevated permissions.\u003c/p\u003e\n\u003cp\u003eIn the past, it has led to the following vulnerabilities:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://nvd.nist.gov/vuln/detail/CVE-2012-2451\"\u003eCVE-2012-2451\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://nvd.nist.gov/vuln/detail/CVE-2015-1838\"\u003eCVE-2015-1838\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis rule raises an issue whenever it detects a hard-coded path to a publicly writable directory like \u003ccode\u003e/tmp\u003c/code\u003e (see examples bellow). It\nalso detects access to environment variables that point to publicly writable directories, e.g., \u003ccode\u003eTMP\u003c/code\u003e and \u003ccode\u003eTMPDIR\u003c/code\u003e.\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003e/tmp\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003e/var/tmp\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003e/usr/tmp\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003e/dev/shm\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003e/dev/mqueue\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003e/run/lock\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003e/var/run/lock\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003e/Library/Caches\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003e/Users/Shared\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003e/private/tmp\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003e/private/var/tmp\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003e\\Windows\\Temp\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003e\\Temp\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003e\\TMP\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      },
      {
        "key": "assess_the_problem",
        "htmlContent": "\u003ch2\u003eAsk Yourself Whether\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e Files are read from or written into a publicly writable folder \u003c/li\u003e\n  \u003cli\u003e The application creates files with predictable names into a publicly writable folder \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere is a risk if you answered yes to any of those questions.\u003c/p\u003e\n\u003ch2\u003eSensitive Code Example\u003c/h2\u003e\n\u003cpre\u003e\n#include \u0026lt;cstdio\u0026gt;\n// ...\n\nvoid f() {\n  FILE * fp \u003d fopen(\"/tmp/temporary_file\", \"r\"); // Sensitive\n}\n\u003c/pre\u003e\n\u003cpre\u003e\n#include \u0026lt;cstdio\u0026gt;\n#include \u0026lt;cstdlib\u0026gt;\n#include \u0026lt;sstream\u0026gt;\n// ...\n\nvoid f() {\n  std::stringstream ss;\n  ss \u0026lt;\u0026lt; getenv(\"TMPDIR\") \u0026lt;\u0026lt; \"/temporary_file\"; // Sensitive\n  FILE * fp \u003d fopen(ss.str().c_str(), \"w\");\n}\n\u003c/pre\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003ch2\u003eRecommended Secure Coding Practices\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e Use a dedicated sub-folder with tightly controlled permissions \u003c/li\u003e\n  \u003cli\u003e Use secure-by-design APIs to create temporary files. Such API will make sure:\n    \u003cul\u003e\n      \u003cli\u003e The generated filename is unpredictable \u003c/li\u003e\n      \u003cli\u003e The file is readable and writable only by the creating user ID \u003c/li\u003e\n      \u003cli\u003e The file descriptor is not inherited by child processes \u003c/li\u003e\n      \u003cli\u003e The file will be destroyed as soon as it is closed \u003c/li\u003e\n    \u003c/ul\u003e  \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eCompliant Solution\u003c/h2\u003e\n\u003cpre\u003e\n#include \u0026lt;cstdio\u0026gt;\n#include \u0026lt;cstdlib\u0026gt;\n// ...\n\nvoid f() {\n  FILE * fp \u003d tmpfile(); // Compliant\n}\n\u003c/pre\u003e\n\u003ch2\u003eSee\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/Top10/A01_2021-Broken_Access_Control/\"\u003eOWASP Top 10 2021 Category A1\u003c/a\u003e - Broken Access Control \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control\"\u003eOWASP Top 10 2017 Category A5\u003c/a\u003e - Broken Access Control\n  \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://www.owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\"\u003eOWASP Top 10 2017 Category A3\u003c/a\u003e - Sensitive Data\n  Exposure \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/377\"\u003eMITRE, CWE-377\u003c/a\u003e - Insecure Temporary File \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/379\"\u003eMITRE, CWE-379\u003c/a\u003e - Creation of Temporary File in Directory with Incorrect Permissions\n  \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/www-community/vulnerabilities/Insecure_Temporary_File\"\u003eOWASP, Insecure Temporary File\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "cwe",
      "symbolic-execution"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": [],
    "vulnerabilityProbability": "LOW"
  },
  {
    "key": "c:S1761",
    "name": "Pre-defined macros should not be defined, redefined or undefined",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe standard, predefined macros, such as \u003ccode\u003e__FILE__\u003c/code\u003e and \u003ccode\u003e__LINE__\u003c/code\u003e, are primarily intended for use by the implementation, and\nchanging them could result in undefined behavior.\u003c/p\u003e\n\u003cp\u003eThis rule checks that the following predefined macros are not defined, undefined, or redefined: \u003ccode\u003eassert\u003c/code\u003e, \u003ccode\u003eerrno\u003c/code\u003e,\n\u003ccode\u003e__FILE__\u003c/code\u003e, \u003ccode\u003e__LINE__\u003c/code\u003e, \u003ccode\u003e__TIME__\u003c/code\u003e, \u003ccode\u003e__DATE__\u003c/code\u003e, \u003ccode\u003e__TIMESTAMP__\u003c/code\u003e, \u003ccode\u003e__COUNTER__\u003c/code\u003e,\n\u003ccode\u003e__INCLUDE_LEVEL__\u003c/code\u003e, \u003ccode\u003e__BASE_FILE__\u003c/code\u003e, and \u003ccode\u003e_Pragma\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#undef __LINE__\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 20.1 - Reserved identifiers, macros and functions in the standard library shall not be defined, redefined, or undefined \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 17-0-1 - Reserved identifiers, macros and functions in the standard library shall not be defined, redefined, or undefined \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 21.1 - #define and #undef shall not be used on a reserved identifier or reserved macro name \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe standard, predefined macros, such as \u003ccode\u003e__FILE__\u003c/code\u003e and \u003ccode\u003e__LINE__\u003c/code\u003e, are primarily intended for use by the implementation, and\nchanging them could result in undefined behavior.\u003c/p\u003e\n\u003cp\u003eThis rule checks that the following predefined macros are not defined, undefined, or redefined: \u003ccode\u003eassert\u003c/code\u003e, \u003ccode\u003eerrno\u003c/code\u003e,\n\u003ccode\u003e__FILE__\u003c/code\u003e, \u003ccode\u003e__LINE__\u003c/code\u003e, \u003ccode\u003e__TIME__\u003c/code\u003e, \u003ccode\u003e__DATE__\u003c/code\u003e, \u003ccode\u003e__TIMESTAMP__\u003c/code\u003e, \u003ccode\u003e__COUNTER__\u003c/code\u003e,\n\u003ccode\u003e__INCLUDE_LEVEL__\u003c/code\u003e, \u003ccode\u003e__BASE_FILE__\u003c/code\u003e, and \u003ccode\u003e_Pragma\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#undef __LINE__\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 20.1 - Reserved identifiers, macros and functions in the standard library shall not be defined, redefined, or undefined \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 17-0-1 - Reserved identifiers, macros and functions in the standard library shall not be defined, redefined, or undefined \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 21.1 - #define and #undef shall not be used on a reserved identifier or reserved macro name \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "based-on-misra",
      "preprocessor",
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S1762",
    "name": "\"#pragma warning (default: ...)\" should not be used",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eUsing \"#pragma warning (default: …​)\" resets the warning in question to its default settings, which may not be what the compiler was initially\ninvoked with. Typically, this usage is seen after a warning is turned off, in preparation for code that is known to cause warnings. Instead, the\nwarning’s current state should be saved, and then restored after the code in question.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#pragma warning (disable: TheWarning)\n#include problem_code.h\n#pragma warning (default: TheWarning)\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#pragma warning (push)\n#include problem_code.h\n#pragma warning (pop)\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/6NUxBQ\"\u003eCERT, MSC00-C.\u003c/a\u003e - Compile cleanly at high warning levels \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eUsing \"#pragma warning (default: …​)\" resets the warning in question to its default settings, which may not be what the compiler was initially\ninvoked with. Typically, this usage is seen after a warning is turned off, in preparation for code that is known to cause warnings. Instead, the\nwarning’s current state should be saved, and then restored after the code in question.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#pragma warning (disable: TheWarning)\n#include problem_code.h\n#pragma warning (default: TheWarning)\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#pragma warning (push)\n#include problem_code.h\n#pragma warning (pop)\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/6NUxBQ\"\u003eCERT, MSC00-C.\u003c/a\u003e - Compile cleanly at high warning levels \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "cert"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S1642",
    "name": "\"struct\" names should comply with a naming convention",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "IDENTIFIABLE",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eSharing some naming conventions enables teams to collaborate more efficiently. This rule checks that all \u003ccode\u003estruct\u003c/code\u003e names match a provided\nregular expression.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cp\u003eUsing the default regular expression \u003ccode\u003e^[A-Z][a-zA-Z0-9]*$\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\nstruct myStruct {\n  int one;\n  int two;\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstruct MyStruct {\n  int one;\n  int two;\n};\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eSharing some naming conventions enables teams to collaborate more efficiently. This rule checks that all \u003ccode\u003estruct\u003c/code\u003e names match a provided\nregular expression.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cp\u003eUsing the default regular expression \u003ccode\u003e^[A-Z][a-zA-Z0-9]*$\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\nstruct myStruct {\n  int one;\n  int two;\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstruct MyStruct {\n  int one;\n  int two;\n};\n\u003c/pre\u003e"
      }
    ],
    "params": {
      "format": {
        "key": "format",
        "name": "format",
        "description": "POSIX regular expression struct names should match.",
        "defaultValue": "^[A-Z][a-zA-Z0-9]*$",
        "type": "STRING",
        "multiple": false,
        "possibleValues": []
      }
    },
    "defaultParams": {
      "format": "^[A-Z][a-zA-Z0-9]*$"
    },
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "convention"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S1763",
    "name": "All code should be reachable",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003cp\u003eOnce control flow has been moved out of the current code block, any subsequent statements become effectively unreachable.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eSome statements and expressions move the control flow out of the current code block. Additionally, some functions never return the control flow to\nthe caller. Any unlabeled statements that come after such a jump or function call is unreachable.\u003c/p\u003e\n\u003cp\u003eFor instance, within a code block, code following a statement containing any of these keywords is effectively dead code:\u003c/p\u003e\n\u003col\u003e\n  \u003cli\u003e \u003ccode\u003ereturn\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003ebreak\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003econtinue\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003egoto\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003eco_return\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003ethrow\u003c/code\u003e \u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eExamples of functions that never return the control flow to the caller:\u003c/p\u003e\n\u003col\u003e\n  \u003cli\u003e \u003ccode\u003eexit()\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003eabort()\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003estd::terminate()\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e Functions with the \u003ccode\u003e[[noreturn]]\u003c/code\u003e attribute. \u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eThe affected code block should be checked to verify the intended behavior, and the logic should be corrected, or the dead code removed.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nint fun(int a) {\n  int i \u003d 10;\n  return i + a;  // Noncompliant: There are following statements within the code block\n  i++;           // Dead code\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\nint divide(int a, int b) {\n  if (b \u003d\u003d 0) {\n    abort();    // Noncompliant: `abort()` never returns to the caller\n    std::cerr \u0026lt;\u0026lt; \"Divisor is 0!\" \u0026lt;\u0026lt; std::endl; // Dead code\n  }\n  return a / b;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nint fun(int a) {\n  int i \u003d 10;\n  return i + a;\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\nint divide(int a, int b) {\n  if (b \u003d\u003d 0) {\n    std::cerr \u0026lt;\u0026lt; \"Divisor is 0!\" \u0026lt;\u0026lt; std::endl;\n    abort();\n  }\n  return a / b;\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 14.1 - There shall be no unreachable code \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 0-1-1 - A project shall not contain unreachable code \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 2.1 - A project shall not contain unreachable code \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/561\"\u003eMITRE, CWE-561\u003c/a\u003e - Dead Code \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/5dUxBQ\"\u003eCERT, MSC12-C.\u003c/a\u003e - Detect and remove code that has no effect or is never executed\n  \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eOnce control flow has been moved out of the current code block, any subsequent statements become effectively unreachable.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eSome statements and expressions move the control flow out of the current code block. Additionally, some functions never return the control flow to\nthe caller. Any unlabeled statements that come after such a jump or function call is unreachable.\u003c/p\u003e\n\u003cp\u003eFor instance, within a code block, code following a statement containing any of these keywords is effectively dead code:\u003c/p\u003e\n\u003col\u003e\n  \u003cli\u003e \u003ccode\u003ereturn\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003ebreak\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003econtinue\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003egoto\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003eco_return\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003ethrow\u003c/code\u003e \u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eExamples of functions that never return the control flow to the caller:\u003c/p\u003e\n\u003col\u003e\n  \u003cli\u003e \u003ccode\u003eexit()\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003eabort()\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003estd::terminate()\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e Functions with the \u003ccode\u003e[[noreturn]]\u003c/code\u003e attribute. \u003c/li\u003e\n\u003c/ol\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eThe affected code block should be checked to verify the intended behavior, and the logic should be corrected, or the dead code removed.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nint fun(int a) {\n  int i \u003d 10;\n  return i + a;  // Noncompliant: There are following statements within the code block\n  i++;           // Dead code\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\nint divide(int a, int b) {\n  if (b \u003d\u003d 0) {\n    abort();    // Noncompliant: `abort()` never returns to the caller\n    std::cerr \u0026lt;\u0026lt; \"Divisor is 0!\" \u0026lt;\u0026lt; std::endl; // Dead code\n  }\n  return a / b;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nint fun(int a) {\n  int i \u003d 10;\n  return i + a;\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\nint divide(int a, int b) {\n  if (b \u003d\u003d 0) {\n    std::cerr \u0026lt;\u0026lt; \"Divisor is 0!\" \u0026lt;\u0026lt; std::endl;\n    abort();\n  }\n  return a / b;\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 14.1 - There shall be no unreachable code \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 0-1-1 - A project shall not contain unreachable code \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 2.1 - A project shall not contain unreachable code \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/561\"\u003eMITRE, CWE-561\u003c/a\u003e - Dead Code \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/5dUxBQ\"\u003eCERT, MSC12-C.\u003c/a\u003e - Detect and remove code that has no effect or is never executed\n  \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "based-on-misra",
      "cert",
      "cwe",
      "unused"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S1764",
    "name": "Identical expressions should not be used on both sides of a binary operator",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eUsing the same value on both sides of a binary operator is a code defect. In the case of logical operators, it is either a copy/paste error and,\ntherefore, a bug, or it is simply duplicated code and should be simplified. In the case of most binary mathematical operators, having the same value\non both sides of an operator yields predictable results and should be simplified as well.\u003c/p\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThe following are ignored:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The expression \u003ccode\u003e1 \u0026lt;\u0026lt; 1\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e When an increment or decrement operator is used, ex: \u003ccode\u003e*p++ \u003d\u003d *p++\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e Bitwise operators \u003ccode\u003e|, \u0026amp;, ^\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e Arithmetic operators \u003ccode\u003e+, *\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e Assignment operators \u003ccode\u003e\u003d, +\u003d, *\u003d\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre\u003e\nvoid foo(int a, int b) {\n  if ( a \u003d\u003d a ) { // Noncompliant: always true\n    // ...\n  }\n\n  if ( a !\u003d a ) { // Noncompliant: always false\n    // ...\n  }\n\n  if ( (a \u003d\u003d b) \u0026amp;\u0026amp; (a \u003d\u003d b) ) { // Noncompliant: if the first condition is true, the second one is too\n    // ...\n  }\n\n  if ( (a \u003d\u003d b) || (a \u003d\u003d b) ) { // Noncompliant: if the first condition is true, the second one is too\n    // ...\n  }\n\n  if ( 5 / 5 ) { // Noncompliant: always 1\n    // ...\n  }\n\n  if ( 5 - 5 ) { // Noncompliant: always 0\n    // ...\n  }\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/5dUxBQ\"\u003eCERT, MSC12-C.\u003c/a\u003e - Detect and remove code that has no effect or is never executed\n  \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:c:S1656} detects self-assignments \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eUsing the same value on both sides of a binary operator is a code defect. In the case of logical operators, it is either a copy/paste error and,\ntherefore, a bug, or it is simply duplicated code and should be simplified. In the case of most binary mathematical operators, having the same value\non both sides of an operator yields predictable results and should be simplified as well.\u003c/p\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThe following are ignored:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The expression \u003ccode\u003e1 \u0026lt;\u0026lt; 1\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e When an increment or decrement operator is used, ex: \u003ccode\u003e*p++ \u003d\u003d *p++\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e Bitwise operators \u003ccode\u003e|, \u0026amp;, ^\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e Arithmetic operators \u003ccode\u003e+, *\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e Assignment operators \u003ccode\u003e\u003d, +\u003d, *\u003d\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre\u003e\nvoid foo(int a, int b) {\n  if ( a \u003d\u003d a ) { // Noncompliant: always true\n    // ...\n  }\n\n  if ( a !\u003d a ) { // Noncompliant: always false\n    // ...\n  }\n\n  if ( (a \u003d\u003d b) \u0026amp;\u0026amp; (a \u003d\u003d b) ) { // Noncompliant: if the first condition is true, the second one is too\n    // ...\n  }\n\n  if ( (a \u003d\u003d b) || (a \u003d\u003d b) ) { // Noncompliant: if the first condition is true, the second one is too\n    // ...\n  }\n\n  if ( 5 / 5 ) { // Noncompliant: always 1\n    // ...\n  }\n\n  if ( 5 - 5 ) { // Noncompliant: always 0\n    // ...\n  }\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/5dUxBQ\"\u003eCERT, MSC12-C.\u003c/a\u003e - Detect and remove code that has no effect or is never executed\n  \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:c:S1656} detects self-assignments \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "cert"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S3491",
    "name": "Redundant pointer operator sequences should be removed",
    "defaultSeverity": "BLOCKER",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eBy contract, chaining the \u0027Address of\u0027 operator \u003ccode\u003e\u0026amp;\u003c/code\u003e with the \u0027Indirection\u0027 operator \u003ccode\u003e*\u003c/code\u003e results in a return to the\ninitial value. Thus, such combinations are confusing at best, and bugs at worst.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint *ptr \u003d ...;\nint *result1 \u003d \u0026amp;(*ptr); //Noncompliant\nint *result2 \u003d \u0026amp;*ptr; //Noncompliant\n\nint value \u003d 4;\nint result3 \u003d *(\u0026amp;value); //Noncompliant\nint result4 \u003d *\u0026amp;value; //Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint *ptr \u003d ...;\nint *result1 \u003d ptr;\nint *result2 \u003d ptr;\n\nint value \u003d 4;\nint result3 \u003d value;\nint result4 \u003d value;\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eNo issue is raised when the \u003ccode\u003e*\u003c/code\u003e or \u003ccode\u003e\u0026amp;\u003c/code\u003e operators are overloaded or when both operators are not located in the same piece\nof code (one being generated by a macro expansion and the other one located in the main source code for instance).\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eBy contract, chaining the \u0027Address of\u0027 operator \u003ccode\u003e\u0026amp;\u003c/code\u003e with the \u0027Indirection\u0027 operator \u003ccode\u003e*\u003c/code\u003e results in a return to the\ninitial value. Thus, such combinations are confusing at best, and bugs at worst.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint *ptr \u003d ...;\nint *result1 \u003d \u0026amp;(*ptr); //Noncompliant\nint *result2 \u003d \u0026amp;*ptr; //Noncompliant\n\nint value \u003d 4;\nint result3 \u003d *(\u0026amp;value); //Noncompliant\nint result4 \u003d *\u0026amp;value; //Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint *ptr \u003d ...;\nint *result1 \u003d ptr;\nint *result2 \u003d ptr;\n\nint value \u003d 4;\nint result3 \u003d value;\nint result4 \u003d value;\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eNo issue is raised when the \u003ccode\u003e*\u003c/code\u003e or \u003ccode\u003e\u0026amp;\u003c/code\u003e operators are overloaded or when both operators are not located in the same piece\nof code (one being generated by a macro expansion and the other one located in the main source code for instance).\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S3935",
    "name": "\"case\" ranges should not be empty",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe GNU compiler gives the possibility to specify a range of consecutive values in a \u003ccode\u003ecase\u003c/code\u003e label, for example: \u003ccode\u003ecase: 1 ...\n5\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eHowever, if the values are written in decreasing order, i.e., from the larger value to the smaller one, the range will evaluate as empty. So the\n\u003ccode\u003ecase\u003c/code\u003e body will never be executed.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eThe rule raises an issue when a range specified in a \u003ccode\u003ecase\u003c/code\u003e label is in decreasing order. Swap the values to define a valid range.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nswitch (i) {\n  case 0:\n    //...\n    break;\n  case 1 ... 2:\n    //...\n    break;\n  case 5 ... 3: // Noncompliant: it evaluates as empty, so the code will never be executed\n    //...\n    break;\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nswitch (i) {\n  case 0:\n    //...\n    break;\n  case 1 ... 2:\n    //...\n    break;\n  case 3 ... 5\n    //...\n    break;\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e GCC - \u003ca href\u003d\"https://gcc.gnu.org/onlinedocs/gcc/Case-Ranges.html\"\u003eCase Ranges\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe GNU compiler gives the possibility to specify a range of consecutive values in a \u003ccode\u003ecase\u003c/code\u003e label, for example: \u003ccode\u003ecase: 1 ...\n5\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eHowever, if the values are written in decreasing order, i.e., from the larger value to the smaller one, the range will evaluate as empty. So the\n\u003ccode\u003ecase\u003c/code\u003e body will never be executed.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eThe rule raises an issue when a range specified in a \u003ccode\u003ecase\u003c/code\u003e label is in decreasing order. Swap the values to define a valid range.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nswitch (i) {\n  case 0:\n    //...\n    break;\n  case 1 ... 2:\n    //...\n    break;\n  case 5 ... 3: // Noncompliant: it evaluates as empty, so the code will never be executed\n    //...\n    break;\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nswitch (i) {\n  case 0:\n    //...\n    break;\n  case 1 ... 2:\n    //...\n    break;\n  case 3 ... 5\n    //...\n    break;\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e GCC - \u003ca href\u003d\"https://gcc.gnu.org/onlinedocs/gcc/Case-Ranges.html\"\u003eCase Ranges\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "gnu"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S1878",
    "name": "\"union\" names should comply with a naming convention",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "IDENTIFIABLE",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eSharing some naming conventions enables teams to collaborate more efficiently. This rule checks that all \u003ccode\u003eunion\u003c/code\u003e names match a provided\nregular expression.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cp\u003eUsing the default regular expression \u003ccode\u003e^[A-Z][a-zA-Z0-9]*$\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\nunion my_union {\n    int one;\n    int two;\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nunion MyUnion {\n    int one;\n    int two;\n};\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eSharing some naming conventions enables teams to collaborate more efficiently. This rule checks that all \u003ccode\u003eunion\u003c/code\u003e names match a provided\nregular expression.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cp\u003eUsing the default regular expression \u003ccode\u003e^[A-Z][a-zA-Z0-9]*$\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\nunion my_union {\n    int one;\n    int two;\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nunion MyUnion {\n    int one;\n    int two;\n};\n\u003c/pre\u003e"
      }
    ],
    "params": {
      "format": {
        "key": "format",
        "name": "format",
        "description": "POSIX regular expression union names should match.",
        "defaultValue": "^[A-Z][a-zA-Z0-9]*$",
        "type": "STRING",
        "multiple": false,
        "possibleValues": []
      }
    },
    "defaultParams": {
      "format": "^[A-Z][a-zA-Z0-9]*$"
    },
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "convention"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S3936",
    "name": "\"case\" ranges should cover multiple values",
    "defaultSeverity": "BLOCKER",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe GNU compiler extension that allows \u003ccode\u003ecase\u003c/code\u003es to be specified with ranges should only be used when a range is actually needed. Use it\nwith the same number on both ends of the range, and you’ve either made a mistake because an actual range was intended, or you’ve used the syntax\ninappropriately in a way that is highly likely to confuse maintainers.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nswitch (i) {\n  case 0:\n    //...\n    break;\n  case 1 ... 2:\n    //...\n    break;\n  case 3 ... 3: // Noncompliant\n    //...\n    break;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nswitch (i) {\n  case 0:\n    //...\n    break;\n  case 1 ... 2:\n    //...\n    break;\n  case 3:\n    //...\n    break;\n}\n\u003c/pre\u003e\n\u003cp\u003eor\u003c/p\u003e\n\u003cpre\u003e\nswitch (i) {\n  case 0:\n    //...\n    break;\n  case 1 ... 2:\n    //...\n    break;\n  case 3 ... 5:\n    //...\n    break;\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe GNU compiler extension that allows \u003ccode\u003ecase\u003c/code\u003es to be specified with ranges should only be used when a range is actually needed. Use it\nwith the same number on both ends of the range, and you’ve either made a mistake because an actual range was intended, or you’ve used the syntax\ninappropriately in a way that is highly likely to confuse maintainers.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nswitch (i) {\n  case 0:\n    //...\n    break;\n  case 1 ... 2:\n    //...\n    break;\n  case 3 ... 3: // Noncompliant\n    //...\n    break;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nswitch (i) {\n  case 0:\n    //...\n    break;\n  case 1 ... 2:\n    //...\n    break;\n  case 3:\n    //...\n    break;\n}\n\u003c/pre\u003e\n\u003cp\u003eor\u003c/p\u003e\n\u003cpre\u003e\nswitch (i) {\n  case 0:\n    //...\n    break;\n  case 1 ... 2:\n    //...\n    break;\n  case 3 ... 5:\n    //...\n    break;\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "gnu",
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S1198",
    "name": "Deprecated K\u0026R syntax should not be used for function definition",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eIn 1978, Brian Kernighan and Dennis Ritchie published the first edition of The C Programming Language. This book, known to C programmers as\n\"K\u0026amp;R\", served for many years as an informal specification of the language. The version of C that it describes is commonly referred to as K\u0026amp;R\nC.\u003c/p\u003e\n\u003cp\u003eThe K\u0026amp;R function definition syntax introduced in the book was later deprecated in the ANSI C and ISO C standards. Even though the K\u0026amp;R\nsyntax is still supported in the ISO C11 standard, it’s not in ISO C++ standard versions and is not considered readable by most C/C++ developers\ntoday.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint foo(a, b)   // Noncompliant K\u0026amp;R C syntax\n  int a;\n  char* b;\n{\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint foo(int a, char* b) { // Compliant\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eIn 1978, Brian Kernighan and Dennis Ritchie published the first edition of The C Programming Language. This book, known to C programmers as\n\"K\u0026amp;R\", served for many years as an informal specification of the language. The version of C that it describes is commonly referred to as K\u0026amp;R\nC.\u003c/p\u003e\n\u003cp\u003eThe K\u0026amp;R function definition syntax introduced in the book was later deprecated in the ANSI C and ISO C standards. Even though the K\u0026amp;R\nsyntax is still supported in the ISO C11 standard, it’s not in ISO C++ standard versions and is not considered readable by most C/C++ developers\ntoday.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint foo(a, b)   // Noncompliant K\u0026amp;R C syntax\n  int a;\n  char* b;\n{\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint foo(int a, char* b) { // Compliant\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "confusing",
      "obsolete"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S3135",
    "name": "\"sizeof\" should not be called on pointers",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003esizeof\u003c/code\u003e returns the size in bytes of a type. One common usage pattern, especially in C, is to use \u003ccode\u003esizeof\u003c/code\u003e to determine the\nsize of an array. However, arrays decay to pointers when passed as arguments to a function, and if \u003ccode\u003esizeof\u003c/code\u003e is applied to such an argument,\nit will return the size of the pointer, not of the array. A similar issue happens when the array is used in an arithmetic operation.\u003c/p\u003e\n\u003cp\u003eThis rule raises issues when:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003esizeof\u003c/code\u003e is used to compute the array size of a pointer passed as a function argument. \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003esizeof\u003c/code\u003e is called on the result of an arithmetic operation involving an array. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eNote: C++17 provides a \u003ccode\u003estd::size\u003c/code\u003e function that will correctly compute the number of elements of an array and fail to compile if\nprovided with a pointer. It is simpler and safer to use this variant when available. C++20 also provides the functions \u003ccode\u003estd::ssize\u003c/code\u003e,\n\u003ccode\u003estd::ranges::size\u003c/code\u003e, and \u003ccode\u003estd::ranges::ssize\u003c/code\u003e with similar effects.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid fun(int *data, int array[10]) {\n  size_t const dataSize \u003d sizeof data / sizeof(int); // Noncompliant, type of data is int *\n  size_t const arraySize \u003d sizeof array / sizeof(int); // Noncompliant, type of array is int * too\n  int primes[] \u003d { 1, 2, 3, 5, 7, 13, 17, 19};\n  size_t const primesSize2 \u003d sizeof(primes + 1) / sizeof(int); // Noncompliant, type of primes + 1 is int *\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n// Computing dataSize is now the responsibility of the caller\nvoid fun(int *data, int dataSize, int (\u0026amp;array)[10]) {\n  size_t const arraySize \u003d sizeof array / sizeof(int); // Compliant, no decay\n  int primes[] \u003d { 1, 2, 3, 5, 7, 13, 17, 19};\n  size_t const primesSize \u003d std::size(primes); // Better variant in C++17\n  size_t const primesSize2 \u003d sizeof primes / sizeof(int) + 1; // Compliant, type of primes is int[8]\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/CdYxBQ\"\u003eCERT, ARR01-C.\u003c/a\u003e - Do not apply the \u003ccode\u003esizeof\u003c/code\u003e operator to a pointer when\n  taking the size of an array \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/467\"\u003eMITRE, CWE-467\u003c/a\u003e - Use of sizeof() on a Pointer Type \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003ccode\u003esizeof\u003c/code\u003e returns the size in bytes of a type. One common usage pattern, especially in C, is to use \u003ccode\u003esizeof\u003c/code\u003e to determine the\nsize of an array. However, arrays decay to pointers when passed as arguments to a function, and if \u003ccode\u003esizeof\u003c/code\u003e is applied to such an argument,\nit will return the size of the pointer, not of the array. A similar issue happens when the array is used in an arithmetic operation.\u003c/p\u003e\n\u003cp\u003eThis rule raises issues when:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003esizeof\u003c/code\u003e is used to compute the array size of a pointer passed as a function argument. \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003esizeof\u003c/code\u003e is called on the result of an arithmetic operation involving an array. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eNote: C++17 provides a \u003ccode\u003estd::size\u003c/code\u003e function that will correctly compute the number of elements of an array and fail to compile if\nprovided with a pointer. It is simpler and safer to use this variant when available. C++20 also provides the functions \u003ccode\u003estd::ssize\u003c/code\u003e,\n\u003ccode\u003estd::ranges::size\u003c/code\u003e, and \u003ccode\u003estd::ranges::ssize\u003c/code\u003e with similar effects.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid fun(int *data, int array[10]) {\n  size_t const dataSize \u003d sizeof data / sizeof(int); // Noncompliant, type of data is int *\n  size_t const arraySize \u003d sizeof array / sizeof(int); // Noncompliant, type of array is int * too\n  int primes[] \u003d { 1, 2, 3, 5, 7, 13, 17, 19};\n  size_t const primesSize2 \u003d sizeof(primes + 1) / sizeof(int); // Noncompliant, type of primes + 1 is int *\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n// Computing dataSize is now the responsibility of the caller\nvoid fun(int *data, int dataSize, int (\u0026amp;array)[10]) {\n  size_t const arraySize \u003d sizeof array / sizeof(int); // Compliant, no decay\n  int primes[] \u003d { 1, 2, 3, 5, 7, 13, 17, 19};\n  size_t const primesSize \u003d std::size(primes); // Better variant in C++17\n  size_t const primesSize2 \u003d sizeof primes / sizeof(int) + 1; // Compliant, type of primes is int[8]\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/CdYxBQ\"\u003eCERT, ARR01-C.\u003c/a\u003e - Do not apply the \u003ccode\u003esizeof\u003c/code\u003e operator to a pointer when\n  taking the size of an array \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/467\"\u003eMITRE, CWE-467\u003c/a\u003e - Use of sizeof() on a Pointer Type \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "cert",
      "cwe"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S1199",
    "name": "Nested code blocks should not be used",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eNested code blocks create new scopes where variables declared within are inaccessible from the outside, and their lifespan ends with the block.\u003c/p\u003e\n\u003cp\u003eAlthough this may appear beneficial, their usage within a function often suggests that the function is overloaded. Thus, it may violate the Single\nResponsibility Principle, and the function needs to be broken down into smaller functions.\u003c/p\u003e\n\u003cp\u003eThe presence of nested blocks that don’t affect the control flow might suggest possible mistakes in the code.\u003c/p\u003e\n\u003cp\u003eHowever, nested code blocks are acceptable when they encapsulate all statements within a \u003ccode\u003eswitch\u003c/code\u003e (a \u003ccode\u003ecase xxx:\u003c/code\u003e or a\n\u003ccode\u003edefault:\u003c/code\u003e) to prevent variable declarations from interfering with other \u003ccode\u003ecases\u003c/code\u003e.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eThe nested code blocks should be extracted into separate methods.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid f(Cache \u0026amp;c, int data) {\n  int value;\n  { // Noncompliant\n    std::scoped_lock l(c.getMutex());\n    if (c.hasKey(data)) {\n      value \u003d c.get(data);\n    } else {\n      value \u003d compute(data);\n      c.set(data, value);\n    }\n  } // Releases the mutex\n\n  switch(value) {\n    case 1:\n    { // Noncompliant, some statements are outside of the block\n       int result \u003d compute(value);\n       save(result);\n    }\n    log();\n    break;\n    case 2:\n    // ...\n  }\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nint getValue(Cache \u0026amp;c, int data) {\n  std::scoped_lock l(c.getMutex());\n  if (c.hasKey(data)) {\n    return c.get(data);\n  } else {\n    value \u003d compute(data);\n    c.set(data, value);\n    return value;\n  }\n}\n\nvoid f(Cache \u0026amp;c, int data) {\n  int value \u003d getValue(c, data);\n\n  switch(value) {\n    case 1:\n    { // Compliant, limits the scope of \"result\"\n       int result \u003d compute(value);\n       save(result);\n       log();\n    }\n    break;\n    case 2:\n    // ...\n  }\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Wikipedia - \u003ca href\u003d\"https://en.wikipedia.org/wiki/Single-responsibility_principle\"\u003eSingle Responsibility Principle\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eNested code blocks create new scopes where variables declared within are inaccessible from the outside, and their lifespan ends with the block.\u003c/p\u003e\n\u003cp\u003eAlthough this may appear beneficial, their usage within a function often suggests that the function is overloaded. Thus, it may violate the Single\nResponsibility Principle, and the function needs to be broken down into smaller functions.\u003c/p\u003e\n\u003cp\u003eThe presence of nested blocks that don’t affect the control flow might suggest possible mistakes in the code.\u003c/p\u003e\n\u003cp\u003eHowever, nested code blocks are acceptable when they encapsulate all statements within a \u003ccode\u003eswitch\u003c/code\u003e (a \u003ccode\u003ecase xxx:\u003c/code\u003e or a\n\u003ccode\u003edefault:\u003c/code\u003e) to prevent variable declarations from interfering with other \u003ccode\u003ecases\u003c/code\u003e.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eThe nested code blocks should be extracted into separate methods.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid f(Cache \u0026amp;c, int data) {\n  int value;\n  { // Noncompliant\n    std::scoped_lock l(c.getMutex());\n    if (c.hasKey(data)) {\n      value \u003d c.get(data);\n    } else {\n      value \u003d compute(data);\n      c.set(data, value);\n    }\n  } // Releases the mutex\n\n  switch(value) {\n    case 1:\n    { // Noncompliant, some statements are outside of the block\n       int result \u003d compute(value);\n       save(result);\n    }\n    log();\n    break;\n    case 2:\n    // ...\n  }\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nint getValue(Cache \u0026amp;c, int data) {\n  std::scoped_lock l(c.getMutex());\n  if (c.hasKey(data)) {\n    return c.get(data);\n  } else {\n    value \u003d compute(data);\n    c.set(data, value);\n    return value;\n  }\n}\n\nvoid f(Cache \u0026amp;c, int data) {\n  int value \u003d getValue(c, data);\n\n  switch(value) {\n    case 1:\n    { // Compliant, limits the scope of \"result\"\n       int result \u003d compute(value);\n       save(result);\n       log();\n    }\n    break;\n    case 2:\n    // ...\n  }\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Wikipedia - \u003ca href\u003d\"https://en.wikipedia.org/wiki/Single-responsibility_principle\"\u003eSingle Responsibility Principle\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "bad-practice"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S1079",
    "name": "\"scanf()\" and \"fscanf()\" format strings should specify a field width for the \"%s\" string placeholder",
    "defaultSeverity": "CRITICAL",
    "type": "VULNERABILITY",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "SECURITY": "HIGH"
    },
    "description": "\u003cp\u003eThe \u003ccode\u003e%s\u003c/code\u003e format specifier is used to read a string into a buffer. If the input string exceeds the size of this buffer, a buffer overflow\ncan occur.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eBy default, there is no limit on the length of the string being read. The \u003ccode\u003escanf\u003c/code\u003e family of functions will continue to read characters\ninto the buffer until they encounter a whitespace character.\u003c/p\u003e\n\u003cp\u003eIf the input contains a string that is long enough and lacks whitespace characters, it can result in memory beyond the end of the buffer being\noverwritten. This situation is known as a buffer overflow vulnerability.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eAn attacker could exploit this vulnerability to overwrite memory used by the application. This could result in the modification of application\ndata, unexpected behavior, or even cause the application to become unstable or crash. In some cases, the attacker might also gain control over the\nexecution flow of the application, leading to arbitrary code execution.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eA field width can be used together with the \u003ccode\u003e%s\u003c/code\u003e format specifier. This places an upper limit on the number of characters that will be\nread into the buffer.\u003c/p\u003e\n\u003cp\u003eNote that the \u003ccode\u003e%s\u003c/code\u003e format specifier always null-terminates the string in the buffer. You will need to ensure that the buffer is large\nenough to hold the required input and the null terminator.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nchar buffer[10];\nscanf(\"%s\", buffer);  // Noncompliant\n\u003c/pre\u003e\n\u003cp\u003eIf this code is given the word \u003ccode\u003enoncompliant\u003c/code\u003e as an input, \u003ccode\u003enoncomplia\u003c/code\u003e will be stored in \u003ccode\u003ebuffer\u003c/code\u003e and\n\u003ccode\u003ent␀\u003c/code\u003e will overwrite the contents of the memory immediately following \u003ccode\u003ebuffer\u003c/code\u003e.\u003c/p\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nchar buffer[10];\nscanf(\"%9s\", buffer);\n\u003c/pre\u003e\n\u003cp\u003eIf this code is given the word \u003ccode\u003enoncompliant\u003c/code\u003e as an input, \u003ccode\u003enoncompli␀\u003c/code\u003e will be stored in \u003ccode\u003ebuffer\u003c/code\u003e.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eArticles \u0026amp; blog posts\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Wikipedia - \u003ca href\u003d\"https://en.wikipedia.org/wiki/Buffer_overflow\"\u003eBuffer overflow\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e OWASP - \u003ca href\u003d\"https://owasp.org/www-project-top-ten/2017/A9_2017-Using_Components_with_Known_Vulnerabilities\"\u003eTop 10 2017 Category A9 -\n  Using Components with Known Vulnerabilities\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e MITRE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/120\"\u003eCWE-120 - Buffer Copy without Checking Size of Input\u003c/a\u003e (\u0027Classic Buffer\n  Overflow\u0027) \u003c/li\u003e\n  \u003cli\u003e MITRE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/676\"\u003eCWE-676 - Use of Potentially Dangerous Function\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eThe \u003ccode\u003e%s\u003c/code\u003e format specifier is used to read a string into a buffer. If the input string exceeds the size of this buffer, a buffer overflow\ncan occur.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eBy default, there is no limit on the length of the string being read. The \u003ccode\u003escanf\u003c/code\u003e family of functions will continue to read characters\ninto the buffer until they encounter a whitespace character.\u003c/p\u003e\n\u003cp\u003eIf the input contains a string that is long enough and lacks whitespace characters, it can result in memory beyond the end of the buffer being\noverwritten. This situation is known as a buffer overflow vulnerability.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eAn attacker could exploit this vulnerability to overwrite memory used by the application. This could result in the modification of application\ndata, unexpected behavior, or even cause the application to become unstable or crash. In some cases, the attacker might also gain control over the\nexecution flow of the application, leading to arbitrary code execution.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eA field width can be used together with the \u003ccode\u003e%s\u003c/code\u003e format specifier. This places an upper limit on the number of characters that will be\nread into the buffer.\u003c/p\u003e\n\u003cp\u003eNote that the \u003ccode\u003e%s\u003c/code\u003e format specifier always null-terminates the string in the buffer. You will need to ensure that the buffer is large\nenough to hold the required input and the null terminator.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nchar buffer[10];\nscanf(\"%s\", buffer);  // Noncompliant\n\u003c/pre\u003e\n\u003cp\u003eIf this code is given the word \u003ccode\u003enoncompliant\u003c/code\u003e as an input, \u003ccode\u003enoncomplia\u003c/code\u003e will be stored in \u003ccode\u003ebuffer\u003c/code\u003e and\n\u003ccode\u003ent␀\u003c/code\u003e will overwrite the contents of the memory immediately following \u003ccode\u003ebuffer\u003c/code\u003e.\u003c/p\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nchar buffer[10];\nscanf(\"%9s\", buffer);\n\u003c/pre\u003e\n\u003cp\u003eIf this code is given the word \u003ccode\u003enoncompliant\u003c/code\u003e as an input, \u003ccode\u003enoncompli␀\u003c/code\u003e will be stored in \u003ccode\u003ebuffer\u003c/code\u003e.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eArticles \u0026amp; blog posts\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Wikipedia - \u003ca href\u003d\"https://en.wikipedia.org/wiki/Buffer_overflow\"\u003eBuffer overflow\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e OWASP - \u003ca href\u003d\"https://owasp.org/www-project-top-ten/2017/A9_2017-Using_Components_with_Known_Vulnerabilities\"\u003eTop 10 2017 Category A9 -\n  Using Components with Known Vulnerabilities\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e MITRE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/120\"\u003eCWE-120 - Buffer Copy without Checking Size of Input\u003c/a\u003e (\u0027Classic Buffer\n  Overflow\u0027) \u003c/li\u003e\n  \u003cli\u003e MITRE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/676\"\u003eCWE-676 - Use of Potentially Dangerous Function\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "cwe",
      "injection"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S1871",
    "name": "Two branches in a conditional structure should not have exactly the same implementation",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "DISTINCT",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhen the same code is duplicated in two or more separate branches of a conditional, it can make the code harder to understand, maintain, and can\npotentially introduce bugs if one instance of the code is changed but others are not.\u003c/p\u003e\n\u003cp\u003eHaving two \u003ccode\u003ecases\u003c/code\u003e in a \u003ccode\u003eswitch\u003c/code\u003e statement or two branches in an \u003ccode\u003eif\u003c/code\u003e chain with the same implementation is at\nbest duplicate code, and at worst a coding error.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nif (a \u0026gt;\u003d 0 \u0026amp;\u0026amp; a \u0026lt; 10) {\n  doFirstThing();\n  doTheThing();\n}\nelse if (a \u0026gt;\u003d 10 \u0026amp;\u0026amp; a \u0026lt; 20) {\n  doTheOtherThing();\n}\nelse if (a \u0026gt;\u003d 20 \u0026amp;\u0026amp; a \u0026lt; 50) {\n  doFirstThing();\n  doTheThing();  // Noncompliant; duplicates first condition\n}\nelse {\n  doTheRest();\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\nswitch (i) {\n  case 1:\n    doFirstThing();\n    doSomething();\n    break;\n  case 2:\n    doSomethingDifferent();\n    break;\n  case 3:  // Noncompliant; duplicates case 1\u0027s implementation\n    doFirstThing();\n    doSomething();\n    break;\n  default:\n    doTheRest();\n}\n\u003c/pre\u003e\n\u003cp\u003eIf the same logic is truly needed for both instances, then:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e in an \u003ccode\u003eif\u003c/code\u003e chain they should be combined \u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nif ((a \u0026gt;\u003d 0 \u0026amp;\u0026amp; a \u0026lt; 10) || (a \u0026gt;\u003d 20 \u0026amp;\u0026amp; a \u0026lt; 50)) { // Compliant\n  doFirstThing();\n  doTheThing();\n}\nelse if (a \u0026gt;\u003d 10 \u0026amp;\u0026amp; a \u0026lt; 20) {\n  doTheOtherThing();\n}\nelse {\n  doTheRest();\n}\n\u003c/pre\u003e\n\u003cul\u003e\n  \u003cli\u003e for a \u003ccode\u003eswitch\u003c/code\u003e, one should fall through to the other \u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\nswitch (i) {\n  case 1:\n  case 3: // Compliant\n    doFirstThing();\n    doSomething();\n    break;\n  case 2:\n    doSomethingDifferent();\n    break;\n  default:\n    doTheRest();\n}\n\u003c/pre\u003e\n\u003cp\u003eWhen all blocks are identical, either this rule will trigger if there is no default clause or rule {rule:c:S3923} will raise if there is a\ndefault clause.\u003c/p\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eUnless all blocks are identical, blocks in an \u003ccode\u003eif\u003c/code\u003e chain that contain a single line of code are ignored. The same applies to blocks in a\n\u003ccode\u003eswitch\u003c/code\u003e statement that contains a single line of code with or without a following \u003ccode\u003ebreak\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\nif (a \u003d\u003d 1) {\n  doSomething();  // Compliant, usually this is done on purpose to increase the readability\n} else if (a \u003d\u003d 2) {\n  doSomethingElse();\n} else {\n  doSomething();\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:c:S3923} - All branches in a conditional structure should not have exactly the same implementation \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhen the same code is duplicated in two or more separate branches of a conditional, it can make the code harder to understand, maintain, and can\npotentially introduce bugs if one instance of the code is changed but others are not.\u003c/p\u003e\n\u003cp\u003eHaving two \u003ccode\u003ecases\u003c/code\u003e in a \u003ccode\u003eswitch\u003c/code\u003e statement or two branches in an \u003ccode\u003eif\u003c/code\u003e chain with the same implementation is at\nbest duplicate code, and at worst a coding error.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nif (a \u0026gt;\u003d 0 \u0026amp;\u0026amp; a \u0026lt; 10) {\n  doFirstThing();\n  doTheThing();\n}\nelse if (a \u0026gt;\u003d 10 \u0026amp;\u0026amp; a \u0026lt; 20) {\n  doTheOtherThing();\n}\nelse if (a \u0026gt;\u003d 20 \u0026amp;\u0026amp; a \u0026lt; 50) {\n  doFirstThing();\n  doTheThing();  // Noncompliant; duplicates first condition\n}\nelse {\n  doTheRest();\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\nswitch (i) {\n  case 1:\n    doFirstThing();\n    doSomething();\n    break;\n  case 2:\n    doSomethingDifferent();\n    break;\n  case 3:  // Noncompliant; duplicates case 1\u0027s implementation\n    doFirstThing();\n    doSomething();\n    break;\n  default:\n    doTheRest();\n}\n\u003c/pre\u003e\n\u003cp\u003eIf the same logic is truly needed for both instances, then:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e in an \u003ccode\u003eif\u003c/code\u003e chain they should be combined \u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nif ((a \u0026gt;\u003d 0 \u0026amp;\u0026amp; a \u0026lt; 10) || (a \u0026gt;\u003d 20 \u0026amp;\u0026amp; a \u0026lt; 50)) { // Compliant\n  doFirstThing();\n  doTheThing();\n}\nelse if (a \u0026gt;\u003d 10 \u0026amp;\u0026amp; a \u0026lt; 20) {\n  doTheOtherThing();\n}\nelse {\n  doTheRest();\n}\n\u003c/pre\u003e\n\u003cul\u003e\n  \u003cli\u003e for a \u003ccode\u003eswitch\u003c/code\u003e, one should fall through to the other \u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\nswitch (i) {\n  case 1:\n  case 3: // Compliant\n    doFirstThing();\n    doSomething();\n    break;\n  case 2:\n    doSomethingDifferent();\n    break;\n  default:\n    doTheRest();\n}\n\u003c/pre\u003e\n\u003cp\u003eWhen all blocks are identical, either this rule will trigger if there is no default clause or rule {rule:c:S3923} will raise if there is a\ndefault clause.\u003c/p\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eUnless all blocks are identical, blocks in an \u003ccode\u003eif\u003c/code\u003e chain that contain a single line of code are ignored. The same applies to blocks in a\n\u003ccode\u003eswitch\u003c/code\u003e statement that contains a single line of code with or without a following \u003ccode\u003ebreak\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\nif (a \u003d\u003d 1) {\n  doSomething();  // Compliant, usually this is done on purpose to increase the readability\n} else if (a \u003d\u003d 2) {\n  doSomethingElse();\n} else {\n  doSomething();\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:c:S3923} - All branches in a conditional structure should not have exactly the same implementation \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "design",
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S1751",
    "name": "Loops with at most one iteration should be refactored",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eA loop with at most one iteration is equivalent to the use of an \u003ccode\u003eif\u003c/code\u003e statement to conditionally execute one piece of code. No developer\nexpects to find such a use of a loop statement. If the initial intention of the author was really to conditionally execute one piece of code, an\n\u003ccode\u003eif\u003c/code\u003e statement should be used instead.\u003c/p\u003e\n\u003cp\u003eAt worst that was not the initial intention of the author and so the body of the loop should be fixed to use the nested \u003ccode\u003ereturn\u003c/code\u003e,\n\u003ccode\u003ebreak\u003c/code\u003e or \u003ccode\u003ethrow\u003c/code\u003e statements in a more appropriate way.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nfor (int i \u003d 0; i \u0026lt; 10; i++) { // noncompliant, loop only executes once\n  printf(\"i is %d\", i);\n  break;\n}\n...\nfor (int i \u003d 0; i \u0026lt; 10; i++) { // noncompliant, loop only executes once\n  if (i \u003d\u003d x) {\n    break;\n  } else {\n    printf(\"i is %d\", i);\n    return;\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nfor (int i \u003d 0; i \u0026lt; 10; i++) {\n  printf(\"i is %d\", i);\n}\n...\nfor (int i \u003d 0; i \u0026lt; 10; i++) {\n  if (i \u003d\u003d x) {\n    break;\n  } else {\n    printf(\"i is %d\", i);\n  }\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eA loop with at most one iteration is equivalent to the use of an \u003ccode\u003eif\u003c/code\u003e statement to conditionally execute one piece of code. No developer\nexpects to find such a use of a loop statement. If the initial intention of the author was really to conditionally execute one piece of code, an\n\u003ccode\u003eif\u003c/code\u003e statement should be used instead.\u003c/p\u003e\n\u003cp\u003eAt worst that was not the initial intention of the author and so the body of the loop should be fixed to use the nested \u003ccode\u003ereturn\u003c/code\u003e,\n\u003ccode\u003ebreak\u003c/code\u003e or \u003ccode\u003ethrow\u003c/code\u003e statements in a more appropriate way.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nfor (int i \u003d 0; i \u0026lt; 10; i++) { // noncompliant, loop only executes once\n  printf(\"i is %d\", i);\n  break;\n}\n...\nfor (int i \u003d 0; i \u0026lt; 10; i++) { // noncompliant, loop only executes once\n  if (i \u003d\u003d x) {\n    break;\n  } else {\n    printf(\"i is %d\", i);\n    return;\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nfor (int i \u003d 0; i \u0026lt; 10; i++) {\n  printf(\"i is %d\", i);\n}\n...\nfor (int i \u003d 0; i \u0026lt; 10; i++) {\n  if (i \u003d\u003d x) {\n    break;\n  } else {\n    printf(\"i is %d\", i);\n  }\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S5314",
    "name": "Blocking functions should not be called inside critical sections",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "EFFICIENT",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003cp\u003eBlocking functions should not be called inside critical sections\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eConcurrent accesses to shared resources are guarded by synchronization primitives such as mutexes to prevent data races. The section of code where\na mutex is held is called the critical section. Critical sections are generally designed to be as small as possible, allowing concurrent threads to\nprogress.\u003c/p\u003e\n\u003cp\u003eIt’s usually unintentional to perform blocking operations inside a critical section because the operation might block for long or even\nindefinitely, degrading performance or causing a deadlock.\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;cstdio\u0026gt;    // printf()\n#include \u0026lt;cstdlib\u0026gt;   // atoi()\n#include \u0026lt;mutex\u0026gt;\n#include \u0026lt;unistd.h\u0026gt;  // sleep()\n\nstd::mutex m;\nint load_shared_resource(); // Guarded by mutex \u0027m\u0027\n\n// Some time-intensive computation.\nvoid do_expensive_work(int value, FILE *fd) {\n  char buf[4] \u003d \"\";\n  std::fgets(buf, sizeof(buf), fd);\n  int sum \u003d value + std::atoi(buf);\n  std::printf(\"value + line: %d\\n\", sum);\n}\n\nvoid worker_thread(FILE *fd) {\n  std::scoped_lock guard(m);\n  int value \u003d load_shared_resource();\n  // Mutex \u0027m\u0027 could have been released here.\n  do_expensive_work(value, fd);\n} // Mutex \u0027m\u0027 only released here, after \u0027do_expensive_work\u0027 is returned.\n\u003c/pre\u003e\n\u003cp\u003eUsually, blocking operations involve I/O operations, such as reading or writing a file or socket or sleeping for some specified time.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eDoing time-intensive operations while holding one or multiple locks will prevent concurrent threads from making progress updating the shared\nresource. This can lead to \"bottlenecks\" and the under-utilization of the hardware capabilities.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eUsually, one can move blocking or expensive computations from critical sections. This leads to smaller and cleaner critical sections in\ngeneral,\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;unistd.h\u0026gt;  // sleep()\n#include \u0026lt;mutex\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n\nint magic_number;\nstd::mutex m;\n\nvoid consumer_thread() {\n  int current;\n  for (int items_processed \u003d 0; items_processed \u0026lt; 100; ++items_processed) {\n    std::scoped_lock guard(m);\n    current \u003d magic_number;\n\n    sleep(std::clamp(current, 0, 10)); // Noncompliant: \u0027sleep\u0027 blocks while holding mutext \u0027m\u0027\n  }\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;unistd.h\u0026gt;  // sleep()\n#include \u0026lt;pthread.h\u0026gt; // pthread_mutex_*()\n\nint magic_number;\npthread_mutex_t m \u003d PTHREAD_MUTEX_INITIALIZER;\n\nvoid consumer_thread() {\n  int current;\n  for (int items_processed \u003d 0; items_processed \u0026lt; 100; ++items_processed) {\n    pthread_mutex_lock(\u0026amp;m);\n    current \u003d magic_number;\n    // Could have \u0027unlocked\u0027 mutex \u0027m\u0027 here.\n    sleep(current); // Noncompliant: \u0027sleep\u0027 blocks while holding mutex \u0027m\u0027\n    pthread_mutex_unlock(\u0026amp;m);\n  }\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;unistd.h\u0026gt;  // sleep()\n#include \u0026lt;mutex\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n\nint magic_number;\nstd::mutex m;\n\nvoid consumer_thread() {\n  int current;\n  for (int items_processed \u003d 0; items_processed \u0026lt; 100; ++items_processed) {\n    {\n      std::scoped_lock guard(m);\n      current \u003d magic_number;\n    }\n\n    sleep(std::clamp(current, 0, 10)); // Ok, blocking without holding any mutexes.\n  }\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;unistd.h\u0026gt;  // sleep()\n#include \u0026lt;pthread.h\u0026gt; // pthread_mutex_*()\n\nint magic_number;\npthread_mutex_t m \u003d PTHREAD_MUTEX_INITIALIZER;\n\nvoid consumer_thread() {\n  int current;\n  for (int items_processed \u003d 0; items_processed \u0026lt; 100; ++items_processed) {\n    pthread_mutex_lock(\u0026amp;m);\n    current \u003d magic_number;\n    pthread_mutex_unlock(\u0026amp;m);\n    sleep(current); // Ok, blocking without holding any mutexes.\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003ePitfalls\u003c/h3\u003e\n\u003cp\u003eIt’s important to note that not all operations can be moved out from the critical section without redesigning the algorithm. It’s tempting to read,\ncompute and commit back the result to some shared resource, but that coding pattern is vulnerable to Time-Of-Check-To-Time-Of-Use (TOCTOU) bugs.\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;unistd.h\u0026gt;  // sleep()\n#include \u0026lt;mutex\u0026gt;\n\nint input;\nstd::mutex input_mutex;\n\nint output;\nstd::mutex output_mutex;\n\nint expensive_computation(int in);\n\nvoid worker_thread() {\n  int previous_input \u003d -1;\n  int previous_result \u003d -1;\n\n  for (int items_processed \u003d 0; items_processed \u0026lt; 100; ++items_processed) {\n    int current;\n    {\n      // Read an input.\n      std::scoped_lock guard(input_mutex);\n      current \u003d input;\n    }\n\n    // Potentially perform an expensive computation.\n    // The \u0027input\u0027 might have changed during the computation,\n    // in which case, we just drop the result without committing it.\n    if (current !\u003d previous_input) {\n      previous_input \u003d current;\n      previous_result \u003d expensive_computation(current);\n\n      // Verify that the \u0027input\u0027 didn\u0027t change, and we can commit our result.\n      std::scoped_lock in_guard(input_mutex);\n      if (input \u003d\u003d previous_input) {\n        std::scoped_lock out_guard(output_mutex);\n        output \u003d previous_result; // Commit the result.\n      }\n    }\n  }\n}\n\u003c/pre\u003e\n\u003cp\u003eIt might not always be correct to commit the result even if the \u003ccode\u003einput\u003c/code\u003e didn’t change since we last checked. It could be that it was\nchanged but restored, as we are rechecking it. This is commonly known as the ABA problem, where \u003ccode\u003eA\u003c/code\u003e and \u003ccode\u003eB\u003c/code\u003e refers to the values\nof the resource.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#cp43-minimize-time-spent-in-a-critical-section\"\u003eCP.43: Minimize\n  time spent in a critical section\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e S5184 enforces that guard objects are not temporary. \u003c/li\u003e\n  \u003cli\u003e S5506 detects direct calls to \u003ccode\u003elock\u003c/code\u003e and \u003ccode\u003eunlock\u003c/code\u003e on mutexes. \u003c/li\u003e\n  \u003cli\u003e S5524 detects individually locked mutexes. \u003c/li\u003e\n  \u003cli\u003e S5997 advocates for using \u003ccode\u003estd::scoped_lock\u003c/code\u003e over \u003ccode\u003estd::lock_guard\u003c/code\u003e. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/thread/mutex\"\u003e\u003ccode\u003estd::mutex\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/thread/scoped_lock\"\u003e\u003ccode\u003estd::scoped_lock\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/367\"\u003eMITRE, CWE-367\u003c/a\u003e - Time-of-check Time-of-use (TOCTOU) Race Condition \u003c/li\u003e\n  \u003cli\u003e Wikipedia - \u003ca href\u003d\"https://en.wikipedia.org/wiki/ABA_problem\"\u003eABA problem\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eBlocking functions should not be called inside critical sections\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eConcurrent accesses to shared resources are guarded by synchronization primitives such as mutexes to prevent data races. The section of code where\na mutex is held is called the critical section. Critical sections are generally designed to be as small as possible, allowing concurrent threads to\nprogress.\u003c/p\u003e\n\u003cp\u003eIt’s usually unintentional to perform blocking operations inside a critical section because the operation might block for long or even\nindefinitely, degrading performance or causing a deadlock.\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;cstdio\u0026gt;    // printf()\n#include \u0026lt;cstdlib\u0026gt;   // atoi()\n#include \u0026lt;mutex\u0026gt;\n#include \u0026lt;unistd.h\u0026gt;  // sleep()\n\nstd::mutex m;\nint load_shared_resource(); // Guarded by mutex \u0027m\u0027\n\n// Some time-intensive computation.\nvoid do_expensive_work(int value, FILE *fd) {\n  char buf[4] \u003d \"\";\n  std::fgets(buf, sizeof(buf), fd);\n  int sum \u003d value + std::atoi(buf);\n  std::printf(\"value + line: %d\\n\", sum);\n}\n\nvoid worker_thread(FILE *fd) {\n  std::scoped_lock guard(m);\n  int value \u003d load_shared_resource();\n  // Mutex \u0027m\u0027 could have been released here.\n  do_expensive_work(value, fd);\n} // Mutex \u0027m\u0027 only released here, after \u0027do_expensive_work\u0027 is returned.\n\u003c/pre\u003e\n\u003cp\u003eUsually, blocking operations involve I/O operations, such as reading or writing a file or socket or sleeping for some specified time.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eDoing time-intensive operations while holding one or multiple locks will prevent concurrent threads from making progress updating the shared\nresource. This can lead to \"bottlenecks\" and the under-utilization of the hardware capabilities.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eUsually, one can move blocking or expensive computations from critical sections. This leads to smaller and cleaner critical sections in\ngeneral,\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;unistd.h\u0026gt;  // sleep()\n#include \u0026lt;mutex\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n\nint magic_number;\nstd::mutex m;\n\nvoid consumer_thread() {\n  int current;\n  for (int items_processed \u003d 0; items_processed \u0026lt; 100; ++items_processed) {\n    std::scoped_lock guard(m);\n    current \u003d magic_number;\n\n    sleep(std::clamp(current, 0, 10)); // Noncompliant: \u0027sleep\u0027 blocks while holding mutext \u0027m\u0027\n  }\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;unistd.h\u0026gt;  // sleep()\n#include \u0026lt;pthread.h\u0026gt; // pthread_mutex_*()\n\nint magic_number;\npthread_mutex_t m \u003d PTHREAD_MUTEX_INITIALIZER;\n\nvoid consumer_thread() {\n  int current;\n  for (int items_processed \u003d 0; items_processed \u0026lt; 100; ++items_processed) {\n    pthread_mutex_lock(\u0026amp;m);\n    current \u003d magic_number;\n    // Could have \u0027unlocked\u0027 mutex \u0027m\u0027 here.\n    sleep(current); // Noncompliant: \u0027sleep\u0027 blocks while holding mutex \u0027m\u0027\n    pthread_mutex_unlock(\u0026amp;m);\n  }\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;unistd.h\u0026gt;  // sleep()\n#include \u0026lt;mutex\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n\nint magic_number;\nstd::mutex m;\n\nvoid consumer_thread() {\n  int current;\n  for (int items_processed \u003d 0; items_processed \u0026lt; 100; ++items_processed) {\n    {\n      std::scoped_lock guard(m);\n      current \u003d magic_number;\n    }\n\n    sleep(std::clamp(current, 0, 10)); // Ok, blocking without holding any mutexes.\n  }\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;unistd.h\u0026gt;  // sleep()\n#include \u0026lt;pthread.h\u0026gt; // pthread_mutex_*()\n\nint magic_number;\npthread_mutex_t m \u003d PTHREAD_MUTEX_INITIALIZER;\n\nvoid consumer_thread() {\n  int current;\n  for (int items_processed \u003d 0; items_processed \u0026lt; 100; ++items_processed) {\n    pthread_mutex_lock(\u0026amp;m);\n    current \u003d magic_number;\n    pthread_mutex_unlock(\u0026amp;m);\n    sleep(current); // Ok, blocking without holding any mutexes.\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003ePitfalls\u003c/h3\u003e\n\u003cp\u003eIt’s important to note that not all operations can be moved out from the critical section without redesigning the algorithm. It’s tempting to read,\ncompute and commit back the result to some shared resource, but that coding pattern is vulnerable to Time-Of-Check-To-Time-Of-Use (TOCTOU) bugs.\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;unistd.h\u0026gt;  // sleep()\n#include \u0026lt;mutex\u0026gt;\n\nint input;\nstd::mutex input_mutex;\n\nint output;\nstd::mutex output_mutex;\n\nint expensive_computation(int in);\n\nvoid worker_thread() {\n  int previous_input \u003d -1;\n  int previous_result \u003d -1;\n\n  for (int items_processed \u003d 0; items_processed \u0026lt; 100; ++items_processed) {\n    int current;\n    {\n      // Read an input.\n      std::scoped_lock guard(input_mutex);\n      current \u003d input;\n    }\n\n    // Potentially perform an expensive computation.\n    // The \u0027input\u0027 might have changed during the computation,\n    // in which case, we just drop the result without committing it.\n    if (current !\u003d previous_input) {\n      previous_input \u003d current;\n      previous_result \u003d expensive_computation(current);\n\n      // Verify that the \u0027input\u0027 didn\u0027t change, and we can commit our result.\n      std::scoped_lock in_guard(input_mutex);\n      if (input \u003d\u003d previous_input) {\n        std::scoped_lock out_guard(output_mutex);\n        output \u003d previous_result; // Commit the result.\n      }\n    }\n  }\n}\n\u003c/pre\u003e\n\u003cp\u003eIt might not always be correct to commit the result even if the \u003ccode\u003einput\u003c/code\u003e didn’t change since we last checked. It could be that it was\nchanged but restored, as we are rechecking it. This is commonly known as the ABA problem, where \u003ccode\u003eA\u003c/code\u003e and \u003ccode\u003eB\u003c/code\u003e refers to the values\nof the resource.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#cp43-minimize-time-spent-in-a-critical-section\"\u003eCP.43: Minimize\n  time spent in a critical section\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e S5184 enforces that guard objects are not temporary. \u003c/li\u003e\n  \u003cli\u003e S5506 detects direct calls to \u003ccode\u003elock\u003c/code\u003e and \u003ccode\u003eunlock\u003c/code\u003e on mutexes. \u003c/li\u003e\n  \u003cli\u003e S5524 detects individually locked mutexes. \u003c/li\u003e\n  \u003cli\u003e S5997 advocates for using \u003ccode\u003estd::scoped_lock\u003c/code\u003e over \u003ccode\u003estd::lock_guard\u003c/code\u003e. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/thread/mutex\"\u003e\u003ccode\u003estd::mutex\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/thread/scoped_lock\"\u003e\u003ccode\u003estd::scoped_lock\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/367\"\u003eMITRE, CWE-367\u003c/a\u003e - Time-of-check Time-of-use (TOCTOU) Race Condition \u003c/li\u003e\n  \u003cli\u003e Wikipedia - \u003ca href\u003d\"https://en.wikipedia.org/wiki/ABA_problem\"\u003eABA problem\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "cwe",
      "multi-threading",
      "symbolic-execution"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S5798",
    "name": "\"memset\" should not be used to delete sensitive data",
    "defaultSeverity": "BLOCKER",
    "type": "VULNERABILITY",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "SECURITY": "HIGH"
    },
    "description": "\u003cp\u003eIf a buffer contains sensitive data, such as passwords or access tokens, it is good practice to overwrite the buffer before releasing the memory.\nThis ensures that the sensitive data is not available when that memory is reallocated. The \u003ccode\u003ememset\u003c/code\u003e function is commonly used for this\npurpose.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe C language specification allows the compiler to remove unnecessary code during the optimization phase. For example, when a memory buffer is\nabout to be destroyed, any writes to that buffer may be seen as unnecessary to the operation of the program. The compiler may choose to remove these\nwrite operations.\u003c/p\u003e\n\u003cp\u003eWhen the \u003ccode\u003ememset\u003c/code\u003e function is used to clear sensitive data from memory and that memory is destroyed immediately afterward, the compiler\nmay see the \u003ccode\u003ememset\u003c/code\u003e call as unnecessary and remove it. The sensitive data will, therefore, remain in memory.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when a call to \u003ccode\u003ememset\u003c/code\u003e is followed by the destruction of the buffer.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eThe function \u003ca href\u003d\"https://en.cppreference.com/w/c/string/byte/memset\"\u003e\u003ccode\u003ememset_s\u003c/code\u003e\u003c/a\u003e behaves similarly to \u003ccode\u003ememset\u003c/code\u003e. The\nmain difference is that it cannot be optimized away and the memory will be overwritten in all cases. You should use \u003ccode\u003ememset_s\u003c/code\u003e to clear\nsecurity-sensitive data.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003ememset_s\u003c/code\u003e function is defined in annex K of C11 and is optional for C11 compilers. It will only be available if the macro\n\u003ccode\u003e__STDC_LIB_EXT1__\u003c/code\u003e is defined, and it must be enabled by defining the macro \u003ccode\u003e__STDC_WANT_LIB_EXT1__\u003c/code\u003e before including\n\u003ccode\u003e\u0026lt;string.h\u0026gt;\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eOther platform-specific functions can perform the same operation, such as \u003ca\nhref\u003d\"https://docs.microsoft.com/en-us/previous-versions/windows/desktop/legacy/aa366877(v\u003dvs.85)?redirectedfrom\u003dMSDN\"\u003eSecureZeroMemory\u003c/a\u003e (Windows)\nor \u003ca href\u003d\"https://www.freebsd.org/cgi/man.cgi?query\u003dexplicit_bzero\"\u003eexplicit_bzero\u003c/a\u003e (FreeBSD).\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;string\u0026gt;\n\nvoid f(char *password, size_t bufferSize) {\n  char localToken[256];\n  init(localToken, password);\n  memset(password, 0, strlen(password));  // Noncompliant\n  memset(localToken, 0, strlen(localToken));  // Noncompliant\n  free(password);\n}\n\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003ememset\u003c/code\u003e calls may be optimized away because \u003ccode\u003epassword\u003c/code\u003e is about to be freed and \u003ccode\u003elocalToken\u003c/code\u003e is about to go\nout of scope.\u003c/p\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#define __STDC_WANT_LIB_EXT1__\n#include \u0026lt;string\u0026gt;\n\nvoid f(char *password, size_t bufferSize) {\n  char localToken[256];\n  init(localToken, password);\n  memset_s(password, bufferSize, 0, strlen(password));\n  memset_s(localToken, sizeof(localToken), 0, strlen(localToken));\n  free(password);\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/c/string/byte/memset\"\u003e\u003ccode\u003ememset\u003c/code\u003e, \u003ccode\u003ememset_s\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e OWASP - \u003ca href\u003d\"https://www.owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\"\u003eTop 10 2017 Category A3 - Sensitive Data\n  Exposure\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e OWASP - \u003ca href\u003d\"https://github.com/OWASP/ASVS/blob/master/4.0/en/0x16-V8-Data-Protection.md#v83-sensitive-private-data\"\u003eApplication Security\n  Verification Standard 4.0 - 8.3.6\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e MITRE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/14\"\u003eCWE-14 - Compiler Removal of Code to Clear Buffers\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eIf a buffer contains sensitive data, such as passwords or access tokens, it is good practice to overwrite the buffer before releasing the memory.\nThis ensures that the sensitive data is not available when that memory is reallocated. The \u003ccode\u003ememset\u003c/code\u003e function is commonly used for this\npurpose.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe C language specification allows the compiler to remove unnecessary code during the optimization phase. For example, when a memory buffer is\nabout to be destroyed, any writes to that buffer may be seen as unnecessary to the operation of the program. The compiler may choose to remove these\nwrite operations.\u003c/p\u003e\n\u003cp\u003eWhen the \u003ccode\u003ememset\u003c/code\u003e function is used to clear sensitive data from memory and that memory is destroyed immediately afterward, the compiler\nmay see the \u003ccode\u003ememset\u003c/code\u003e call as unnecessary and remove it. The sensitive data will, therefore, remain in memory.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when a call to \u003ccode\u003ememset\u003c/code\u003e is followed by the destruction of the buffer.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eThe function \u003ca href\u003d\"https://en.cppreference.com/w/c/string/byte/memset\"\u003e\u003ccode\u003ememset_s\u003c/code\u003e\u003c/a\u003e behaves similarly to \u003ccode\u003ememset\u003c/code\u003e. The\nmain difference is that it cannot be optimized away and the memory will be overwritten in all cases. You should use \u003ccode\u003ememset_s\u003c/code\u003e to clear\nsecurity-sensitive data.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003ememset_s\u003c/code\u003e function is defined in annex K of C11 and is optional for C11 compilers. It will only be available if the macro\n\u003ccode\u003e__STDC_LIB_EXT1__\u003c/code\u003e is defined, and it must be enabled by defining the macro \u003ccode\u003e__STDC_WANT_LIB_EXT1__\u003c/code\u003e before including\n\u003ccode\u003e\u0026lt;string.h\u0026gt;\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eOther platform-specific functions can perform the same operation, such as \u003ca\nhref\u003d\"https://docs.microsoft.com/en-us/previous-versions/windows/desktop/legacy/aa366877(v\u003dvs.85)?redirectedfrom\u003dMSDN\"\u003eSecureZeroMemory\u003c/a\u003e (Windows)\nor \u003ca href\u003d\"https://www.freebsd.org/cgi/man.cgi?query\u003dexplicit_bzero\"\u003eexplicit_bzero\u003c/a\u003e (FreeBSD).\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;string\u0026gt;\n\nvoid f(char *password, size_t bufferSize) {\n  char localToken[256];\n  init(localToken, password);\n  memset(password, 0, strlen(password));  // Noncompliant\n  memset(localToken, 0, strlen(localToken));  // Noncompliant\n  free(password);\n}\n\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003ememset\u003c/code\u003e calls may be optimized away because \u003ccode\u003epassword\u003c/code\u003e is about to be freed and \u003ccode\u003elocalToken\u003c/code\u003e is about to go\nout of scope.\u003c/p\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#define __STDC_WANT_LIB_EXT1__\n#include \u0026lt;string\u0026gt;\n\nvoid f(char *password, size_t bufferSize) {\n  char localToken[256];\n  init(localToken, password);\n  memset_s(password, bufferSize, 0, strlen(password));\n  memset_s(localToken, sizeof(localToken), 0, strlen(localToken));\n  free(password);\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/c/string/byte/memset\"\u003e\u003ccode\u003ememset\u003c/code\u003e, \u003ccode\u003ememset_s\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e OWASP - \u003ca href\u003d\"https://www.owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\"\u003eTop 10 2017 Category A3 - Sensitive Data\n  Exposure\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e OWASP - \u003ca href\u003d\"https://github.com/OWASP/ASVS/blob/master/4.0/en/0x16-V8-Data-Protection.md#v83-sensitive-private-data\"\u003eApplication Security\n  Verification Standard 4.0 - 8.3.6\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e MITRE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/14\"\u003eCWE-14 - Compiler Removal of Code to Clear Buffers\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "cwe"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S1874",
    "name": "Code annotated as deprecated should not be used",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eCode is sometimes annotated as deprecated by developers maintaining libraries or APIs to indicate that the method, class, or other programming\nelement is no longer recommended for use. This is typically due to the introduction of a newer or more effective alternative. For example, when a\nbetter solution has been identified, or when the existing code presents potential errors or security risks.\u003c/p\u003e\n\u003cp\u003eDeprecation is a good practice because it helps to phase out obsolete code in a controlled manner, without breaking existing software that may\nstill depend on it. It is a way to warn other developers not to use the deprecated element in new code, and to replace it in existing code when\npossible.\u003c/p\u003e\n\u003cp\u003eDeprecated classes, interfaces, and their members should not be used, inherited or extended because they will eventually be removed. The\ndeprecation period allows you to make a smooth transition away from the aging, soon-to-be-retired technology.\u003c/p\u003e\n\u003cp\u003eCheck the documentation or the deprecation message to understand why the code was deprecated and what the recommended alternative is.\u003c/p\u003e\n\u003cpre\u003e\n// C++14 attribute\n[[deprecated(\"Use newFunction instead.\")]]\nvoid oldFunction();\n\n// GNU attribute\n__attribute__((deprecated(\"Use newFunction instead.\")))\nvoid oldFunction();\n\n// Microsoft attribute\n__declspec(deprecated(\"Use newFunction instead.\"))\nvoid oldFunction();\n\nvoid newFunction();\n\nvoid example() {\n  oldFunction(); // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/477\"\u003eMITRE, CWE-477\u003c/a\u003e - Use of Obsolete Functions \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eCode is sometimes annotated as deprecated by developers maintaining libraries or APIs to indicate that the method, class, or other programming\nelement is no longer recommended for use. This is typically due to the introduction of a newer or more effective alternative. For example, when a\nbetter solution has been identified, or when the existing code presents potential errors or security risks.\u003c/p\u003e\n\u003cp\u003eDeprecation is a good practice because it helps to phase out obsolete code in a controlled manner, without breaking existing software that may\nstill depend on it. It is a way to warn other developers not to use the deprecated element in new code, and to replace it in existing code when\npossible.\u003c/p\u003e\n\u003cp\u003eDeprecated classes, interfaces, and their members should not be used, inherited or extended because they will eventually be removed. The\ndeprecation period allows you to make a smooth transition away from the aging, soon-to-be-retired technology.\u003c/p\u003e\n\u003cp\u003eCheck the documentation or the deprecation message to understand why the code was deprecated and what the recommended alternative is.\u003c/p\u003e\n\u003cpre\u003e\n// C++14 attribute\n[[deprecated(\"Use newFunction instead.\")]]\nvoid oldFunction();\n\n// GNU attribute\n__attribute__((deprecated(\"Use newFunction instead.\")))\nvoid oldFunction();\n\n// Microsoft attribute\n__declspec(deprecated(\"Use newFunction instead.\"))\nvoid oldFunction();\n\nvoid newFunction();\n\nvoid example() {\n  oldFunction(); // Noncompliant\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/477\"\u003eMITRE, CWE-477\u003c/a\u003e - Use of Obsolete Functions \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "cert",
      "cwe",
      "obsolete"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S2190",
    "name": "Recursion should not be infinite",
    "defaultSeverity": "BLOCKER",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eRecursion happens when control enters a loop that has no exit. It can occur when a method invokes itself, when two methods invoke each other, or\nwhen \u003ccode\u003egoto\u003c/code\u003e statements are used to move between two code segments. Recursion can be a useful tool, but unless the method includes a\nprovision to break out the recursion and \u003ccode\u003ereturn\u003c/code\u003e, the recursion will continue until the stack overflows and the program crashes.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint pow(int num, int exponent) {  // Noncompliant: pow is always re-called\n  num \u003d num * pow(num, exponent-1);\n  return num;  // this is never reached\n}\n\nvoid internalRecursion(int i) {\n  start:\n    goto end;\n  end:\n    goto start;  // Noncompliant: there is no way to break out of this method\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint pow(int num, int exponent) {\n  if (exponent \u0026gt; 1) {  // recursion is now conditional and stop-able\n    num \u003d num * pow(num, exponent-1);\n  }\n  return num;\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eRecursion happens when control enters a loop that has no exit. It can occur when a method invokes itself, when two methods invoke each other, or\nwhen \u003ccode\u003egoto\u003c/code\u003e statements are used to move between two code segments. Recursion can be a useful tool, but unless the method includes a\nprovision to break out the recursion and \u003ccode\u003ereturn\u003c/code\u003e, the recursion will continue until the stack overflows and the program crashes.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint pow(int num, int exponent) {  // Noncompliant: pow is always re-called\n  num \u003d num * pow(num, exponent-1);\n  return num;  // this is never reached\n}\n\nvoid internalRecursion(int i) {\n  start:\n    goto end;\n  end:\n    goto start;  // Noncompliant: there is no way to break out of this method\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint pow(int num, int exponent) {\n  if (exponent \u0026gt; 1) {  // recursion is now conditional and stop-able\n    num \u003d num * pow(num, exponent-1);\n  }\n  return num;\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S912",
    "name": "The right-hand operands of \u0026\u0026 and || should not contain side effects",
    "defaultSeverity": "BLOCKER",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThere are some situations in C++ where certain parts of expressions may not be evaluated. If these sub-expressions contain side effects then those\nside effects may or may not occur, depending on the values of other sub expressions. The operators which can lead to this problem are\n\u003ccode\u003e\u0026amp;\u0026amp;\u003c/code\u003e and \u003ccode\u003e||\u003c/code\u003e, where the evaluation of the right-hand operand is conditional on the value of the left-hand operand. The\nconditional evaluation of the right-hand operand of one of the logical operators can easily cause problems if the developer relies on a side effect\noccurring.\u003c/p\u003e\n\u003cp\u003eOperations that cause side effects are:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e accessing a volatile object \u003c/li\u003e\n  \u003cli\u003e modifying an object \u003c/li\u003e\n  \u003cli\u003e modifying a file \u003c/li\u003e\n  \u003cli\u003e calling a function that performs any operations that cause changes in the state of the execution environment of the calling function. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis rule raises an issue when there is assignment or the use of the increment/decrement operators in right-hand operands.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nif ( ishigh \u0026amp;\u0026amp; ( x \u003d\u003d i++ ) ) // Noncompliant\n...\nif ( ishigh \u0026amp;\u0026amp; ( x \u003d\u003d  getX() ) ) // Only acceptable if getX() is known to have no side effects\n\u003c/pre\u003e\n\u003cp\u003eThe operations that cause side effects are accessing a volatile object, modifying an object, modifying a file, or calling a function\u003c/p\u003e\n\u003cp\u003ethat does any of those operations, which cause changes in the state of the execution environment of the calling function.\u003c/p\u003e\n\u003cp\u003eFor the time being, this rule only check that there is no assignment or no use of increment/decrement operators made in right hand operands.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 12.4 - The right-hand operand of a logical \u0026amp;\u0026amp; or || operator shall not contain side effects. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 5-14-1 - The right hand operand of a logical \u0026amp;\u0026amp; or || operator shall not contain side effects. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 13.5 - The right hand operand of a logical \u0026amp;\u0026amp; or || operator shall not contain persistent side effects \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/vdUxBQ\"\u003eCERT, EXP02-C.\u003c/a\u003e - Be aware of the short-circuit behavior of the logical AND and OR\n  operators \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThere are some situations in C++ where certain parts of expressions may not be evaluated. If these sub-expressions contain side effects then those\nside effects may or may not occur, depending on the values of other sub expressions. The operators which can lead to this problem are\n\u003ccode\u003e\u0026amp;\u0026amp;\u003c/code\u003e and \u003ccode\u003e||\u003c/code\u003e, where the evaluation of the right-hand operand is conditional on the value of the left-hand operand. The\nconditional evaluation of the right-hand operand of one of the logical operators can easily cause problems if the developer relies on a side effect\noccurring.\u003c/p\u003e\n\u003cp\u003eOperations that cause side effects are:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e accessing a volatile object \u003c/li\u003e\n  \u003cli\u003e modifying an object \u003c/li\u003e\n  \u003cli\u003e modifying a file \u003c/li\u003e\n  \u003cli\u003e calling a function that performs any operations that cause changes in the state of the execution environment of the calling function. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis rule raises an issue when there is assignment or the use of the increment/decrement operators in right-hand operands.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nif ( ishigh \u0026amp;\u0026amp; ( x \u003d\u003d i++ ) ) // Noncompliant\n...\nif ( ishigh \u0026amp;\u0026amp; ( x \u003d\u003d  getX() ) ) // Only acceptable if getX() is known to have no side effects\n\u003c/pre\u003e\n\u003cp\u003eThe operations that cause side effects are accessing a volatile object, modifying an object, modifying a file, or calling a function\u003c/p\u003e\n\u003cp\u003ethat does any of those operations, which cause changes in the state of the execution environment of the calling function.\u003c/p\u003e\n\u003cp\u003eFor the time being, this rule only check that there is no assignment or no use of increment/decrement operators made in right hand operands.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 12.4 - The right-hand operand of a logical \u0026amp;\u0026amp; or || operator shall not contain side effects. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 5-14-1 - The right hand operand of a logical \u0026amp;\u0026amp; or || operator shall not contain side effects. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 13.5 - The right hand operand of a logical \u0026amp;\u0026amp; or || operator shall not contain persistent side effects \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/vdUxBQ\"\u003eCERT, EXP02-C.\u003c/a\u003e - Be aware of the short-circuit behavior of the logical AND and OR\n  operators \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "based-on-misra",
      "cert"
    ],
    "deprecatedKeys": [
      "c:SideEffectInRightHandSideOfLogical"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S117",
    "name": "Local variable and function parameter names should comply with a naming convention",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "IDENTIFIABLE",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003cp\u003eLocal variables and function parameters should be named consistently to communicate intent and improve maintainability. Rename your local variable\nor function parameter to follow your project’s naming convention to address this issue.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eA naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.\u003cbr\u003e Local\nvariables and function parameters hold the meaning of the written code. Their names should be meaningful and follow a consistent and easily\nrecognizable pattern.\u003cbr\u003e Adhering to a consistent naming convention helps to make the code more readable and understandable, which makes it easier to\nmaintain and debug. It also ensures consistency in the code, especially when multiple developers are working on the same project.\u003c/p\u003e\n\u003cp\u003eThis rule checks that local variable and function parameter names match a provided regular expression.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eInconsistent naming of local variables and function parameters can lead to several issues in your code:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Reduced Readability: inconsistent local variable and function parameter names make the code harder to read and understand; consequently, it is\n  more difficult to identify the purpose of each variable, spot errors, or comprehend the logic. \u003c/li\u003e\n  \u003cli\u003e Difficulty in Identifying Variables: local variables and function parameters that don’t adhere to a standard naming convention are challenging\n  to identify; thus, the coding process slows down, especially when dealing with a large codebase. \u003c/li\u003e\n  \u003cli\u003e Increased Risk of Errors: inconsistent or unclear local variable and function parameter names lead to misunderstandings about what the variable\n  represents. This ambiguity leads to incorrect assumptions and, consequently, bugs in the code. \u003c/li\u003e\n  \u003cli\u003e Collaboration Difficulties: in a team setting, inconsistent naming conventions lead to confusion and miscommunication among team members. \u003c/li\u003e\n  \u003cli\u003e Difficulty in Code Maintenance: inconsistent naming leads to an inconsistent codebase. The code is difficult to understand, and making changes\n  feels like refactoring constantly, as you face different naming methods. Ultimately, it makes the codebase harder to maintain. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn summary, not adhering to a naming convention for local variables and function parameters can lead to confusion, errors, and inefficiencies,\nmaking the code harder to read, understand, and maintain.\u003c/p\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThis rule ignores \u003ccode\u003econst\u003c/code\u003e variables.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eFirst, familiarize yourself with the particular naming convention of the project in question. Then, update the name to match the convention, as\nwell as all usages of the name. For many IDEs, you can use built-in renaming and refactoring features to update all usages at once.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cp\u003eWith the default regular expression \u003ccode\u003e^[a-z][a-zA-Z0-9]*$\u003c/code\u003e:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid doSomething(int my_param) {\n  int LOCAL;\n  ...\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid doSomething(int myParam) {\n  int local;\n  ...\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Wikipedia - \u003ca href\u003d\"https://en.wikipedia.org/wiki/Naming_convention_(programming)\"\u003eNaming Convention (programming)\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:c:S100} - Function names should comply with a naming convention \u003c/li\u003e\n  \u003cli\u003e S101 - Class names should comply with a naming convention \u003c/li\u003e\n  \u003cli\u003e {rule:c:S116} - Field names should comply with a naming convention \u003c/li\u003e\n  \u003cli\u003e {rule:c:S1543} - Macro names should comply with a naming convention \u003c/li\u003e\n  \u003cli\u003e {rule:c:S1578} - File names should comply with a naming convention \u003c/li\u003e\n  \u003cli\u003e {rule:c:S1642} - \u003ccode\u003estruct\u003c/code\u003e names should comply with a naming convention \u003c/li\u003e\n  \u003cli\u003e {rule:c:S1878} - \u003ccode\u003eunion\u003c/code\u003e names should comply with a naming convention \u003c/li\u003e\n  \u003cli\u003e S2304 - Namespace names should comply with a naming convention \u003c/li\u003e\n  \u003cli\u003e {rule:c:S2342} - Enumeration names should comply with a naming convention \u003c/li\u003e\n  \u003cli\u003e {rule:c:S2343} - Enumeration values should comply with a naming convention \u003c/li\u003e\n  \u003cli\u003e {rule:c:S3222} - Label names should comply with a naming convention \u003c/li\u003e\n  \u003cli\u003e S6193 - Coroutine names should comply with a naming convention \u003c/li\u003e\n  \u003cli\u003e S6221 - Concept names should comply with a naming convention \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eLocal variables and function parameters should be named consistently to communicate intent and improve maintainability. Rename your local variable\nor function parameter to follow your project’s naming convention to address this issue.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eA naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.\u003cbr\u003e Local\nvariables and function parameters hold the meaning of the written code. Their names should be meaningful and follow a consistent and easily\nrecognizable pattern.\u003cbr\u003e Adhering to a consistent naming convention helps to make the code more readable and understandable, which makes it easier to\nmaintain and debug. It also ensures consistency in the code, especially when multiple developers are working on the same project.\u003c/p\u003e\n\u003cp\u003eThis rule checks that local variable and function parameter names match a provided regular expression.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eInconsistent naming of local variables and function parameters can lead to several issues in your code:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Reduced Readability: inconsistent local variable and function parameter names make the code harder to read and understand; consequently, it is\n  more difficult to identify the purpose of each variable, spot errors, or comprehend the logic. \u003c/li\u003e\n  \u003cli\u003e Difficulty in Identifying Variables: local variables and function parameters that don’t adhere to a standard naming convention are challenging\n  to identify; thus, the coding process slows down, especially when dealing with a large codebase. \u003c/li\u003e\n  \u003cli\u003e Increased Risk of Errors: inconsistent or unclear local variable and function parameter names lead to misunderstandings about what the variable\n  represents. This ambiguity leads to incorrect assumptions and, consequently, bugs in the code. \u003c/li\u003e\n  \u003cli\u003e Collaboration Difficulties: in a team setting, inconsistent naming conventions lead to confusion and miscommunication among team members. \u003c/li\u003e\n  \u003cli\u003e Difficulty in Code Maintenance: inconsistent naming leads to an inconsistent codebase. The code is difficult to understand, and making changes\n  feels like refactoring constantly, as you face different naming methods. Ultimately, it makes the codebase harder to maintain. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn summary, not adhering to a naming convention for local variables and function parameters can lead to confusion, errors, and inefficiencies,\nmaking the code harder to read, understand, and maintain.\u003c/p\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThis rule ignores \u003ccode\u003econst\u003c/code\u003e variables.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eFirst, familiarize yourself with the particular naming convention of the project in question. Then, update the name to match the convention, as\nwell as all usages of the name. For many IDEs, you can use built-in renaming and refactoring features to update all usages at once.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cp\u003eWith the default regular expression \u003ccode\u003e^[a-z][a-zA-Z0-9]*$\u003c/code\u003e:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid doSomething(int my_param) {\n  int LOCAL;\n  ...\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid doSomething(int myParam) {\n  int local;\n  ...\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Wikipedia - \u003ca href\u003d\"https://en.wikipedia.org/wiki/Naming_convention_(programming)\"\u003eNaming Convention (programming)\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:c:S100} - Function names should comply with a naming convention \u003c/li\u003e\n  \u003cli\u003e S101 - Class names should comply with a naming convention \u003c/li\u003e\n  \u003cli\u003e {rule:c:S116} - Field names should comply with a naming convention \u003c/li\u003e\n  \u003cli\u003e {rule:c:S1543} - Macro names should comply with a naming convention \u003c/li\u003e\n  \u003cli\u003e {rule:c:S1578} - File names should comply with a naming convention \u003c/li\u003e\n  \u003cli\u003e {rule:c:S1642} - \u003ccode\u003estruct\u003c/code\u003e names should comply with a naming convention \u003c/li\u003e\n  \u003cli\u003e {rule:c:S1878} - \u003ccode\u003eunion\u003c/code\u003e names should comply with a naming convention \u003c/li\u003e\n  \u003cli\u003e S2304 - Namespace names should comply with a naming convention \u003c/li\u003e\n  \u003cli\u003e {rule:c:S2342} - Enumeration names should comply with a naming convention \u003c/li\u003e\n  \u003cli\u003e {rule:c:S2343} - Enumeration values should comply with a naming convention \u003c/li\u003e\n  \u003cli\u003e {rule:c:S3222} - Label names should comply with a naming convention \u003c/li\u003e\n  \u003cli\u003e S6193 - Coroutine names should comply with a naming convention \u003c/li\u003e\n  \u003cli\u003e S6221 - Concept names should comply with a naming convention \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {
      "format": {
        "key": "format",
        "name": "format",
        "description": "POSIX regular expression used to check the names against.",
        "defaultValue": "^[a-z][a-zA-Z0-9]*$",
        "type": "STRING",
        "multiple": false,
        "possibleValues": []
      }
    },
    "defaultParams": {
      "format": "^[a-z][a-zA-Z0-9]*$"
    },
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "convention"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:M23_328",
    "name": "Reads and writes on the same file stream shall be separated by a positioning operation",
    "defaultSeverity": "BLOCKER",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 30.0.2\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Undecidable, System\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eAn explicit, interleaving stream positioning operation shall be used between input operations and output operations on a\n\u003ccode\u003estd::basic_filebuf\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThis rule applies to direct and indirect calls (e.g. from \u003ccode\u003estd::fstream\u003c/code\u003e) to \u003ccode\u003estd::basic_filebuf\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e for the purposes of this rule, a call to \u003ccode\u003efflush\u003c/code\u003e after an output operation is considered to be an explicit file\npositioning operation.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eThe C \u003ccode\u003eFILE *\u003c/code\u003e abstraction, used as the underlying system file I/O for \u003ccode\u003estd::basic_filebuf\u003c/code\u003e, holds a single file position\nthat is used when reading from or writing to the file. Using an input operation on a \u003ccode\u003eFILE *\u003c/code\u003e immediately after an output operation (or\nvice versa) results in \u003cem\u003eundefined behaviour\u003c/em\u003e, unless an interleaving file positioning operation is used to update the file’s position.\u003c/p\u003e\n\u003cp\u003eIn addition, a \u003ccode\u003estreambuf\u003c/code\u003e object keeps separate buffer positions for reading and writing characters from its internal buffer. A\n\u003ccode\u003ebasic_filebuf\u003c/code\u003e object is only guaranteed to synchronize the separate internal \u003ccode\u003estreambuf\u003c/code\u003e read and write positions that it\nmaintains when a positioning operation is called when alternating between reading and writing (and vice versa). Failure to include such a positioning\noperation leads to \u003cem\u003eundefined behaviour\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eThe accessible positioning operations for \u003ccode\u003estreambuf\u003c/code\u003e are \u003ccode\u003epubseekoff\u003c/code\u003e and \u003ccode\u003epubseekpos\u003c/code\u003e, whilst for file streams\nthey are \u003ccode\u003etellg\u003c/code\u003e, \u003ccode\u003eseekg\u003c/code\u003e, \u003ccode\u003etellp\u003c/code\u003e, and \u003ccode\u003eseekp\u003c/code\u003e. One of these functions shall be called when switching\nfrom output to input, or vice versa.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nvoid show_fstream_non_compliant()\n{\n  std::fstream f { \"hello.txt\" };\n\n  f \u0026lt;\u0026lt; \"Hello world!\\n\" \u0026lt;\u0026lt; std::flush;   // flush is not a positioning operation\n\n  std::string s {};\n\n  std::getline( f, s );                  // Non-compliant - undefined behaviour\n}\n\nvoid show_fstream_compliant()\n{\n  std::fstream f { \"hello.txt\" };\n\n  f \u0026lt;\u0026lt; \"Hello world!\\n\";\n\n  std::string s {};\n\n  f.seekg( 0, std::ios_base::beg );\n\n  std::getline(f, s);                    // Compliant - s holds \"Hello world!\"\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/L9YxBQ\"\u003eCERT, FIO39-C.\u003c/a\u003e - Do not alternately input and output from a stream without an\n  intervening flush or positioning call \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/2Hw-BQ\"\u003eCERT, FIO50-CPP.\u003c/a\u003e - Do not alternately input and output from a file stream without an\n  intervening positioning call \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 30.0.2\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Undecidable, System\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eAn explicit, interleaving stream positioning operation shall be used between input operations and output operations on a\n\u003ccode\u003estd::basic_filebuf\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThis rule applies to direct and indirect calls (e.g. from \u003ccode\u003estd::fstream\u003c/code\u003e) to \u003ccode\u003estd::basic_filebuf\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e for the purposes of this rule, a call to \u003ccode\u003efflush\u003c/code\u003e after an output operation is considered to be an explicit file\npositioning operation.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eThe C \u003ccode\u003eFILE *\u003c/code\u003e abstraction, used as the underlying system file I/O for \u003ccode\u003estd::basic_filebuf\u003c/code\u003e, holds a single file position\nthat is used when reading from or writing to the file. Using an input operation on a \u003ccode\u003eFILE *\u003c/code\u003e immediately after an output operation (or\nvice versa) results in \u003cem\u003eundefined behaviour\u003c/em\u003e, unless an interleaving file positioning operation is used to update the file’s position.\u003c/p\u003e\n\u003cp\u003eIn addition, a \u003ccode\u003estreambuf\u003c/code\u003e object keeps separate buffer positions for reading and writing characters from its internal buffer. A\n\u003ccode\u003ebasic_filebuf\u003c/code\u003e object is only guaranteed to synchronize the separate internal \u003ccode\u003estreambuf\u003c/code\u003e read and write positions that it\nmaintains when a positioning operation is called when alternating between reading and writing (and vice versa). Failure to include such a positioning\noperation leads to \u003cem\u003eundefined behaviour\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eThe accessible positioning operations for \u003ccode\u003estreambuf\u003c/code\u003e are \u003ccode\u003epubseekoff\u003c/code\u003e and \u003ccode\u003epubseekpos\u003c/code\u003e, whilst for file streams\nthey are \u003ccode\u003etellg\u003c/code\u003e, \u003ccode\u003eseekg\u003c/code\u003e, \u003ccode\u003etellp\u003c/code\u003e, and \u003ccode\u003eseekp\u003c/code\u003e. One of these functions shall be called when switching\nfrom output to input, or vice versa.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nvoid show_fstream_non_compliant()\n{\n  std::fstream f { \"hello.txt\" };\n\n  f \u0026lt;\u0026lt; \"Hello world!\\n\" \u0026lt;\u0026lt; std::flush;   // flush is not a positioning operation\n\n  std::string s {};\n\n  std::getline( f, s );                  // Non-compliant - undefined behaviour\n}\n\nvoid show_fstream_compliant()\n{\n  std::fstream f { \"hello.txt\" };\n\n  f \u0026lt;\u0026lt; \"Hello world!\\n\";\n\n  std::string s {};\n\n  f.seekg( 0, std::ios_base::beg );\n\n  std::getline(f, s);                    // Compliant - s holds \"Hello world!\"\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/L9YxBQ\"\u003eCERT, FIO39-C.\u003c/a\u003e - Do not alternately input and output from a stream without an\n  intervening flush or positioning call \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/2Hw-BQ\"\u003eCERT, FIO50-CPP.\u003c/a\u003e - Do not alternately input and output from a file stream without an\n  intervening positioning call \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "misra-c++2023",
      "misra-required",
      "unpredictable"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S116",
    "name": "Field names should comply with a naming convention",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "IDENTIFIABLE",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eA naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.\u003c/p\u003e\n\u003cp\u003eThe goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures\nconsistency in the code, especially when multiple developers are working on the same project.\u003c/p\u003e\n\u003cp\u003eThis rule checks that field names match a provided regular expression.\u003c/p\u003e\n\u003cp\u003eUsing the regular expression \u003ccode\u003e^[a-z][a-zA-Z0-9]*$\u003c/code\u003e, the noncompliant code below:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nclass MyClass {\n  int my_field; // Noncompliant\n};\n\u003c/pre\u003e\n\u003cp\u003eShould be replaced with:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nclass MyClass {\n  int myField;  // Compliant\n};\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Geeksforgeeks - \u003ca href\u003d\"https://www.geeksforgeeks.org/naming-convention-in-c/\"\u003eNaming convention in C++\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e Wikipedia - \u003ca href\u003d\"https://en.wikipedia.org/wiki/Naming_convention_(programming)\"\u003eNaming Convention (programming)\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eA naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.\u003c/p\u003e\n\u003cp\u003eThe goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures\nconsistency in the code, especially when multiple developers are working on the same project.\u003c/p\u003e\n\u003cp\u003eThis rule checks that field names match a provided regular expression.\u003c/p\u003e\n\u003cp\u003eUsing the regular expression \u003ccode\u003e^[a-z][a-zA-Z0-9]*$\u003c/code\u003e, the noncompliant code below:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nclass MyClass {\n  int my_field; // Noncompliant\n};\n\u003c/pre\u003e\n\u003cp\u003eShould be replaced with:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nclass MyClass {\n  int myField;  // Compliant\n};\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Geeksforgeeks - \u003ca href\u003d\"https://www.geeksforgeeks.org/naming-convention-in-c/\"\u003eNaming convention in C++\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e Wikipedia - \u003ca href\u003d\"https://en.wikipedia.org/wiki/Naming_convention_(programming)\"\u003eNaming Convention (programming)\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {
      "format": {
        "key": "format",
        "name": "format",
        "description": "POSIX regular expression used to check the field names against.",
        "defaultValue": "^[a-z][a-zA-Z0-9]*$",
        "type": "STRING",
        "multiple": false,
        "possibleValues": []
      }
    },
    "defaultParams": {
      "format": "^[a-z][a-zA-Z0-9]*$"
    },
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "convention"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S2193",
    "name": "\"for\" loop counters should not have essentially floating type",
    "defaultSeverity": "MINOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhen using a floating-point \u003ccode\u003efor\u003c/code\u003e loop counter, an accumulation of rounding errors may result in a mismatch between the expected and\nactual number of iterations.\u003c/p\u003e\n\u003cp\u003eEven if floating-point loop counters appears to behave correctly on one implementation, it may give a different number of iterations on another\nimplementation.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nfor (float counter \u003d 0.0f; counter \u0026lt; 1.0f; counter +\u003d 0.001f) {\n  ...\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nfor (int counter \u003d 0; counter \u0026lt; 1000; ++counter) {\n  ...\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 13.4 - The controlling expression of a for statement shall not contain any objects of floating type. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 6-5-1 - A \u003cem\u003efor\u003c/em\u003e loop shall contain a single \u003cem\u003eloop-counter\u003c/em\u003e which shall not have floating type. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 14.1 - A \u003cem\u003eloop counter\u003c/em\u003e shall not have essentially \u003cem\u003efloating type\u003c/em\u003e. \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/display/c/FLP30-C.+Do+not+use+floating-point+variables+as+loop+counters\"\u003eCERT, FLP30-C.\u003c/a\u003e - Do\n  not use floating-point variables as loop counters \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhen using a floating-point \u003ccode\u003efor\u003c/code\u003e loop counter, an accumulation of rounding errors may result in a mismatch between the expected and\nactual number of iterations.\u003c/p\u003e\n\u003cp\u003eEven if floating-point loop counters appears to behave correctly on one implementation, it may give a different number of iterations on another\nimplementation.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nfor (float counter \u003d 0.0f; counter \u0026lt; 1.0f; counter +\u003d 0.001f) {\n  ...\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nfor (int counter \u003d 0; counter \u0026lt; 1000; ++counter) {\n  ...\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 13.4 - The controlling expression of a for statement shall not contain any objects of floating type. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 6-5-1 - A \u003cem\u003efor\u003c/em\u003e loop shall contain a single \u003cem\u003eloop-counter\u003c/em\u003e which shall not have floating type. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 14.1 - A \u003cem\u003eloop counter\u003c/em\u003e shall not have essentially \u003cem\u003efloating type\u003c/em\u003e. \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/display/c/FLP30-C.+Do+not+use+floating-point+variables+as+loop+counters\"\u003eCERT, FLP30-C.\u003c/a\u003e - Do\n  not use floating-point variables as loop counters \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "based-on-misra",
      "cert"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S113",
    "name": "Files should end with a newline",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eSome tools work better when files end with a newline.\u003c/p\u003e\n\u003cp\u003eThis rule simply generates an issue if it is missing.\u003c/p\u003e\n\u003cp\u003eFor example, a Git diff looks like this if the empty line is missing at the end of the file:\u003c/p\u003e\n\u003cpre\u003e\n+class Test {\n+}\n\\ No newline at end of file\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eSome tools work better when files end with a newline.\u003c/p\u003e\n\u003cp\u003eThis rule simply generates an issue if it is missing.\u003c/p\u003e\n\u003cp\u003eFor example, a Git diff looks like this if the empty line is missing at the end of the file:\u003c/p\u003e\n\u003cpre\u003e\n+class Test {\n+}\n\\ No newline at end of file\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "convention"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:M23_325",
    "name": "Line-splicing shall not be used in \"//\" comments",
    "defaultSeverity": "CRITICAL",
    "type": "BUG",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 5.7.3\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eThis rule is applied in translation phase 2, after multibyte characters have been mapped to the basic source character set during translation phase\n1 (see [lex.phases]).\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eLine-splicing occurs when the \u003ccode\u003e\\\u003c/code\u003e character is immediately followed by a new-line character. If a source line containing a\n\u003ccode\u003e//\u003c/code\u003e comment ends with a \u003ccode\u003e\\\u003c/code\u003e character in the basic source character set, the next line becomes part of the comment. This may\nresult in the unintentional removal of code.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cp\u003eIn the following non-compliant example, the physical line containing the \u003ccode\u003eif\u003c/code\u003e keyword is logically part of the previous line and is\ntherefore part of a comment.\u003c/p\u003e\n\u003cpre\u003e\nvoid f( bool b )\n{\n  uint16_t x \u003d 0U;   // comment \\\n  if ( b )\n  {\n    ++x;             // This is always executed\n  }\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003e{rule:c:S2323} targets the same defect as this rule but for a non-mission-critical context.\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 5.7.3\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eThis rule is applied in translation phase 2, after multibyte characters have been mapped to the basic source character set during translation phase\n1 (see [lex.phases]).\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eLine-splicing occurs when the \u003ccode\u003e\\\u003c/code\u003e character is immediately followed by a new-line character. If a source line containing a\n\u003ccode\u003e//\u003c/code\u003e comment ends with a \u003ccode\u003e\\\u003c/code\u003e character in the basic source character set, the next line becomes part of the comment. This may\nresult in the unintentional removal of code.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cp\u003eIn the following non-compliant example, the physical line containing the \u003ccode\u003eif\u003c/code\u003e keyword is logically part of the previous line and is\ntherefore part of a comment.\u003c/p\u003e\n\u003cpre\u003e\nvoid f( bool b )\n{\n  uint16_t x \u003d 0U;   // comment \\\n  if ( b )\n  {\n    ++x;             // This is always executed\n  }\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003e{rule:c:S2323} targets the same defect as this rule but for a non-mission-critical context.\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "misra-c++2023",
      "misra-required"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S916",
    "name": "Switch labels should not be nested inside non-switch blocks",
    "defaultSeverity": "BLOCKER",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eA switch-label can be placed anywhere within the statements that form the body of a switch statement, potentially leading to unstructured code. To\nprevent this from happening, the scope of a case-label or default-label shall be the statement forming the body of a switch statement. All\ncase-clauses and the default-clause shall be at the same scope.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nswitch (x) {\n  case 1: // Compliant\n    if (foo) {\n      case 2: // Noncompliant\n        break;\n      default: // Noncompliant\n        break;\n    }\n    break;\n  default: // Compliant\n    break;\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C 2004, 15.1 - A switch label shall only be used when the most closely-enclosing compound statement is the body of a switch statement.\n  \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2008, 6-4-4 - A switch-label shall only be used when the most closely-enclosing compound statement is the body of a switch statement.\n  \u003c/li\u003e\n  \u003cli\u003e MISRA C 2012, 16.2 - A switch label shall only be used when the most closely-enclsoing compound statement is the body of a switch statement\n  \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eA switch-label can be placed anywhere within the statements that form the body of a switch statement, potentially leading to unstructured code. To\nprevent this from happening, the scope of a case-label or default-label shall be the statement forming the body of a switch statement. All\ncase-clauses and the default-clause shall be at the same scope.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nswitch (x) {\n  case 1: // Compliant\n    if (foo) {\n      case 2: // Noncompliant\n        break;\n      default: // Noncompliant\n        break;\n    }\n    break;\n  default: // Compliant\n    break;\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C 2004, 15.1 - A switch label shall only be used when the most closely-enclosing compound statement is the body of a switch statement.\n  \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2008, 6-4-4 - A switch-label shall only be used when the most closely-enclosing compound statement is the body of a switch statement.\n  \u003c/li\u003e\n  \u003cli\u003e MISRA C 2012, 16.2 - A switch label shall only be used when the most closely-enclsoing compound statement is the body of a switch statement\n  \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "confusing",
      "misra-c++2008",
      "misra-c2004",
      "misra-c2012"
    ],
    "deprecatedKeys": [
      "c:SwitchLabelPlacement"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:M23_321",
    "name": "All variables should be initialized",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 11.6.1\u003c/p\u003e\n\u003cp\u003eCategory: Advisory\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eAll variables should either be explicitly or implicitly initialized.\u003c/p\u003e\n\u003cp\u003eApart from the following, all variables should be explicitly initialized with an associated initializer in their definition:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Variables of a class type, or \u003c/li\u003e\n  \u003cli\u003e Function parameters (which are initialized with the corresponding argument value), or \u003c/li\u003e\n  \u003cli\u003e Variables with static storage duration (which are \u003cem\u003ezero-initialized\u003c/em\u003e by default). \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eHaving several states within a program increases the risk of defects being introduced. Each variable that is first uninitialized, then set to a\nvalue creates two program states. It is therefore better to initialize the variable directly to a value that is to be used. The intent of this rule is\nnot that each variable is initialized with some value, but that it is initialized with its real value; the one that will be used when the variable is\nnext read.\u003c/p\u003e\n\u003cp\u003eIn order to achieve this, the variable definition can be delayed until the \"right\" value is available. This naturally leads to reducing the\nvariable’s scope, reducing the risk of the variable being used inappropriately. An immediately evaluated lambda can be used to compute a value when a\nvariable’s initialization is more complex.\u003c/p\u003e\n\u003cp\u003eIn many cases, initializing the variable within its definition allows it to be a constant definition.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e there are many ways to explicitly initialize a variable. When possible, the list-initialization syntax (with curly braces)\nshould be used as it does not suffer from the issues that arise from the use of other syntactic forms (e.g. narrowing or declaring a function while\ntrying to define a variable, aka \"the most vexing parse\").\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nvoid f( bool cond )\n{\n  int32_t i;                        // Non-compliant\n\n  if ( cond ) { i \u003d  42; }\n  else        { i \u003d -1;  }\n\n  int32_t j \u003d cond ? 42 : -1;       // Compliant\n  int32_t k \u003d [\u0026amp;]()                 // Compliant\n    {\n      if ( cond ) { return 42; }\n      else        { return -1; }\n    }();\n\n  string s;                         // Compliant - default-initialized\n}\n\nint32_t g;                          // Compliant - static initialization applies\n\nvoid f()\n{\n  thread_local int32_t i;           // Compliant - static initialization applies\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e S5523 targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n  \u003cli\u003e {rule:c:S836} reports only when an uninitialized variable is read before being set \u003c/li\u003e\n  \u003cli\u003e {rule:c:M23_152}: MISRA C++ 2023 Rule\u0026nbsp;11.6.2 - The value of an object must not be read before it has been set \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2023 Rule\u0026nbsp;15.1.4 - All direct, non-static data members of a class should be initialized before the class object is\n  \u003cem\u003eaccessible\u003c/em\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cp\u003e\u003ca\nhref\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/036324/CppCoreGuidelines.md#es20-always-initialize-an-object\"\u003ehttps://github.com/isocpp/CppCoreGuidelines/blob/036324/CppCoreGuidelines.md#es20-always-initialize-an-object\u003c/a\u003e\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 11.6.1\u003c/p\u003e\n\u003cp\u003eCategory: Advisory\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eAll variables should either be explicitly or implicitly initialized.\u003c/p\u003e\n\u003cp\u003eApart from the following, all variables should be explicitly initialized with an associated initializer in their definition:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Variables of a class type, or \u003c/li\u003e\n  \u003cli\u003e Function parameters (which are initialized with the corresponding argument value), or \u003c/li\u003e\n  \u003cli\u003e Variables with static storage duration (which are \u003cem\u003ezero-initialized\u003c/em\u003e by default). \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eHaving several states within a program increases the risk of defects being introduced. Each variable that is first uninitialized, then set to a\nvalue creates two program states. It is therefore better to initialize the variable directly to a value that is to be used. The intent of this rule is\nnot that each variable is initialized with some value, but that it is initialized with its real value; the one that will be used when the variable is\nnext read.\u003c/p\u003e\n\u003cp\u003eIn order to achieve this, the variable definition can be delayed until the \"right\" value is available. This naturally leads to reducing the\nvariable’s scope, reducing the risk of the variable being used inappropriately. An immediately evaluated lambda can be used to compute a value when a\nvariable’s initialization is more complex.\u003c/p\u003e\n\u003cp\u003eIn many cases, initializing the variable within its definition allows it to be a constant definition.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e there are many ways to explicitly initialize a variable. When possible, the list-initialization syntax (with curly braces)\nshould be used as it does not suffer from the issues that arise from the use of other syntactic forms (e.g. narrowing or declaring a function while\ntrying to define a variable, aka \"the most vexing parse\").\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nvoid f( bool cond )\n{\n  int32_t i;                        // Non-compliant\n\n  if ( cond ) { i \u003d  42; }\n  else        { i \u003d -1;  }\n\n  int32_t j \u003d cond ? 42 : -1;       // Compliant\n  int32_t k \u003d [\u0026amp;]()                 // Compliant\n    {\n      if ( cond ) { return 42; }\n      else        { return -1; }\n    }();\n\n  string s;                         // Compliant - default-initialized\n}\n\nint32_t g;                          // Compliant - static initialization applies\n\nvoid f()\n{\n  thread_local int32_t i;           // Compliant - static initialization applies\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e S5523 targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n  \u003cli\u003e {rule:c:S836} reports only when an uninitialized variable is read before being set \u003c/li\u003e\n  \u003cli\u003e {rule:c:M23_152}: MISRA C++ 2023 Rule\u0026nbsp;11.6.2 - The value of an object must not be read before it has been set \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2023 Rule\u0026nbsp;15.1.4 - All direct, non-static data members of a class should be initialized before the class object is\n  \u003cem\u003eaccessible\u003c/em\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cp\u003e\u003ca\nhref\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/036324/CppCoreGuidelines.md#es20-always-initialize-an-object\"\u003ehttps://github.com/isocpp/CppCoreGuidelines/blob/036324/CppCoreGuidelines.md#es20-always-initialize-an-object\u003c/a\u003e\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "misra-advisory",
      "misra-c++2023",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S2755",
    "name": "XML parsers should not be vulnerable to XXE attacks",
    "defaultSeverity": "BLOCKER",
    "type": "VULNERABILITY",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "SECURITY": "HIGH"
    },
    "description": "\u003cp\u003eThis vulnerability allows the usage of external entities in XML.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eExternal Entity Processing allows for XML parsing with the involvement of external entities. However, when this functionality is enabled without\nproper precautions, it can lead to a vulnerability known as XML External Entity (XXE) attack.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003ch4\u003eExposing sensitive data\u003c/h4\u003e\n\u003cp\u003eOne significant danger of XXE vulnerabilities is the potential for sensitive data exposure. By crafting malicious XML payloads, attackers can\nreference external entities that contain sensitive information, such as system files, database credentials, or configuration files. When these\nentities are processed during XML parsing, the attacker can extract the contents and gain unauthorized access to sensitive data. This poses a severe\nthreat to the confidentiality of critical information.\u003c/p\u003e\n\u003ch4\u003eExhausting system resources\u003c/h4\u003e\n\u003cp\u003eAnother consequence of XXE vulnerabilities is the potential for denial-of-service attacks. By exploiting the ability to include external entities,\nattackers can construct XML payloads that cause resource exhaustion. This can overwhelm the system’s memory, CPU, or other critical resources, leading\nto system unresponsiveness or crashes. A successful DoS attack can disrupt the availability of services and negatively impact the user experience.\u003c/p\u003e\n\u003ch4\u003eForging requests\u003c/h4\u003e\n\u003cp\u003eXXE vulnerabilities can also enable Server-Side Request Forgery (SSRF) attacks. By leveraging the ability to include external entities, an attacker\ncan make the vulnerable application send arbitrary requests to other internal or external systems. This can result in unintended actions, such as\nretrieving data from internal resources, scanning internal networks, or attacking other systems. SSRF attacks can lead to severe consequences,\nincluding unauthorized data access, system compromise, or even further exploitation within the network infrastructure.\u003c/p\u003e\n\u003ch2\u003eHow to fix it in Xerces\u003c/h2\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003cp\u003eThe following code contains examples of XML parsers that have external entity processing enabled. As a result, the parsers are vulnerable to XXE\nattacks if an attacker can control the XML file that is processed.\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"11\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \"xercesc/parsers/XercesDOMParser.hpp\"\n\nvoid parse() {\n  XercesDOMParser *DOMparser \u003d new XercesDOMParser();\n  DOMparser-\u0026gt;setCreateEntityReferenceNodes(false); // Noncompliant\n  DOMparser-\u0026gt;setDisableDefaultEntityResolution(false); // Noncompliant\n\n  DOMparser-\u0026gt;parse(xmlFile);\n}\n\u003c/pre\u003e\n\u003cp\u003eBy default, entities resolution is enabled for \u003ccode\u003eXMLReaderFactory::createXMLReader\u003c/code\u003e.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"12\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \"xercesc/sax2/SAX2XMLReader.hpp\"\n\nvoid parse() {\n  SAX2XMLReader* reader \u003d XMLReaderFactory::createXMLReader();\n  reader-\u0026gt;setFeature(XMLUni::fgXercesDisableDefaultEntityResolution, false); // Noncompliant\n\n  reader-\u0026gt;parse(xmlFile);\n}\n\u003c/pre\u003e\n\u003cp\u003eBy default, entities resolution is enabled for \u003ccode\u003eSAXParser\u003c/code\u003e.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"13\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \"xercesc/parsers/SAXParser.hpp\"\n\nvoid parse() {\n  SAXParser* SAXparser \u003d new SAXParser();\n  SAXparser-\u0026gt;setDisableDefaultEntityResolution(false); // Noncompliant\n\n  SAXparser-\u0026gt;parse(xmlFile);\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eBy default, \u003ccode\u003eXercesDOMParser\u003c/code\u003e is safe.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"11\" data-diff-type\u003d\"compliant\"\u003e\n#include \"xercesc/parsers/XercesDOMParser.hpp\"\n\nvoid parse() {\n  XercesDOMParser *DOMparser \u003d new XercesDOMParser();\n  DOMparser-\u0026gt;setCreateEntityReferenceNodes(true);\n  DOMparser-\u0026gt;setDisableDefaultEntityResolution(true);\n\n  DOMparser-\u0026gt;parse(xmlFile);\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"12\" data-diff-type\u003d\"compliant\"\u003e\n#include \"xercesc/sax2/SAX2XMLReader.hpp\"\n\nvoid parse() {\n  SAX2XMLReader* reader \u003d XMLReaderFactory::createXMLReader();\n  reader-\u0026gt;setFeature(XMLUni::fgXercesDisableDefaultEntityResolution, true);\n\n  reader-\u0026gt;parse(xmlFile);\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"13\" data-diff-type\u003d\"compliant\"\u003e\n#include \"xercesc/parsers/SAXParser.hpp\"\n\nvoid parse() {\n  SAXParser* SAXparser \u003d new SAXParser();\n  SAXparser-\u0026gt;setDisableDefaultEntityResolution(true);\n\n  SAXparser-\u0026gt;parse(xmlFile);\n}\n\u003c/pre\u003e\n\u003ch3\u003eHow does this work?\u003c/h3\u003e\n\u003ch4\u003eDisable external entities\u003c/h4\u003e\n\u003cp\u003eThe most effective approach to prevent XXE vulnerabilities is to disable external entity processing entirely, unless it is explicitly required for\nspecific use cases. By default, XML parsers should be configured to reject the processing of external entities. This can be achieved by setting the\nappropriate properties or options in your XML parser library or framework.\u003c/p\u003e\n\u003cp\u003eIf external entity processing is necessary for certain scenarios, adopt a whitelisting approach to restrict the entities that can be resolved\nduring XML parsing. Create a list of trusted external entities and disallow all others. This approach ensures that only known and safe entities are\nprocessed.\u003cbr\u003e You should rely on features provided by your XML parser to restrict the external entities.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/Top10/A05_2021-Security_Misconfiguration/\"\u003eOWASP Top 10 2021 Category A5\u003c/a\u003e - Security Misconfiguration \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/www-project-top-ten/2017/A4_2017-XML_External_Entities_(XXE)\"\u003eOWASP Top 10 2017 Category A4\u003c/a\u003e - XML External\n  Entities (XXE) \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/611\"\u003eMITRE, CWE-611\u003c/a\u003e - Information Exposure Through XML External Entity Reference \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/827\"\u003eMITRE, CWE-827\u003c/a\u003e - Improper Control of Document Type Definition \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eThis vulnerability allows the usage of external entities in XML.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eExternal Entity Processing allows for XML parsing with the involvement of external entities. However, when this functionality is enabled without\nproper precautions, it can lead to a vulnerability known as XML External Entity (XXE) attack.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003ch4\u003eExposing sensitive data\u003c/h4\u003e\n\u003cp\u003eOne significant danger of XXE vulnerabilities is the potential for sensitive data exposure. By crafting malicious XML payloads, attackers can\nreference external entities that contain sensitive information, such as system files, database credentials, or configuration files. When these\nentities are processed during XML parsing, the attacker can extract the contents and gain unauthorized access to sensitive data. This poses a severe\nthreat to the confidentiality of critical information.\u003c/p\u003e\n\u003ch4\u003eExhausting system resources\u003c/h4\u003e\n\u003cp\u003eAnother consequence of XXE vulnerabilities is the potential for denial-of-service attacks. By exploiting the ability to include external entities,\nattackers can construct XML payloads that cause resource exhaustion. This can overwhelm the system’s memory, CPU, or other critical resources, leading\nto system unresponsiveness or crashes. A successful DoS attack can disrupt the availability of services and negatively impact the user experience.\u003c/p\u003e\n\u003ch4\u003eForging requests\u003c/h4\u003e\n\u003cp\u003eXXE vulnerabilities can also enable Server-Side Request Forgery (SSRF) attacks. By leveraging the ability to include external entities, an attacker\ncan make the vulnerable application send arbitrary requests to other internal or external systems. This can result in unintended actions, such as\nretrieving data from internal resources, scanning internal networks, or attacking other systems. SSRF attacks can lead to severe consequences,\nincluding unauthorized data access, system compromise, or even further exploitation within the network infrastructure.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eThe following code contains examples of XML parsers that have external entity processing enabled. As a result, the parsers are vulnerable to XXE\nattacks if an attacker can control the XML file that is processed.\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"11\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \"xercesc/parsers/XercesDOMParser.hpp\"\n\nvoid parse() {\n  XercesDOMParser *DOMparser \u003d new XercesDOMParser();\n  DOMparser-\u0026gt;setCreateEntityReferenceNodes(false); // Noncompliant\n  DOMparser-\u0026gt;setDisableDefaultEntityResolution(false); // Noncompliant\n\n  DOMparser-\u0026gt;parse(xmlFile);\n}\n\u003c/pre\u003e\n\u003cp\u003eBy default, entities resolution is enabled for \u003ccode\u003eXMLReaderFactory::createXMLReader\u003c/code\u003e.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"12\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \"xercesc/sax2/SAX2XMLReader.hpp\"\n\nvoid parse() {\n  SAX2XMLReader* reader \u003d XMLReaderFactory::createXMLReader();\n  reader-\u0026gt;setFeature(XMLUni::fgXercesDisableDefaultEntityResolution, false); // Noncompliant\n\n  reader-\u0026gt;parse(xmlFile);\n}\n\u003c/pre\u003e\n\u003cp\u003eBy default, entities resolution is enabled for \u003ccode\u003eSAXParser\u003c/code\u003e.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"13\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \"xercesc/parsers/SAXParser.hpp\"\n\nvoid parse() {\n  SAXParser* SAXparser \u003d new SAXParser();\n  SAXparser-\u0026gt;setDisableDefaultEntityResolution(false); // Noncompliant\n\n  SAXparser-\u0026gt;parse(xmlFile);\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eBy default, \u003ccode\u003eXercesDOMParser\u003c/code\u003e is safe.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"11\" data-diff-type\u003d\"compliant\"\u003e\n#include \"xercesc/parsers/XercesDOMParser.hpp\"\n\nvoid parse() {\n  XercesDOMParser *DOMparser \u003d new XercesDOMParser();\n  DOMparser-\u0026gt;setCreateEntityReferenceNodes(true);\n  DOMparser-\u0026gt;setDisableDefaultEntityResolution(true);\n\n  DOMparser-\u0026gt;parse(xmlFile);\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"12\" data-diff-type\u003d\"compliant\"\u003e\n#include \"xercesc/sax2/SAX2XMLReader.hpp\"\n\nvoid parse() {\n  SAX2XMLReader* reader \u003d XMLReaderFactory::createXMLReader();\n  reader-\u0026gt;setFeature(XMLUni::fgXercesDisableDefaultEntityResolution, true);\n\n  reader-\u0026gt;parse(xmlFile);\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"13\" data-diff-type\u003d\"compliant\"\u003e\n#include \"xercesc/parsers/SAXParser.hpp\"\n\nvoid parse() {\n  SAXParser* SAXparser \u003d new SAXParser();\n  SAXparser-\u0026gt;setDisableDefaultEntityResolution(true);\n\n  SAXparser-\u0026gt;parse(xmlFile);\n}\n\u003c/pre\u003e\n\u003ch3\u003eHow does this work?\u003c/h3\u003e\n\u003ch4\u003eDisable external entities\u003c/h4\u003e\n\u003cp\u003eThe most effective approach to prevent XXE vulnerabilities is to disable external entity processing entirely, unless it is explicitly required for\nspecific use cases. By default, XML parsers should be configured to reject the processing of external entities. This can be achieved by setting the\nappropriate properties or options in your XML parser library or framework.\u003c/p\u003e\n\u003cp\u003eIf external entity processing is necessary for certain scenarios, adopt a whitelisting approach to restrict the entities that can be resolved\nduring XML parsing. Create a list of trusted external entities and disallow all others. This approach ensures that only known and safe entities are\nprocessed.\u003cbr\u003e You should rely on features provided by your XML parser to restrict the external entities.\u003c/p\u003e",
        "context": {
          "key": "xerces",
          "displayName": "Xerces"
        }
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eThe following code contains examples of XML parsers that have external entity processing enabled. As a result, the parsers are vulnerable to XXE\nattacks if an attacker can control the XML file that is processed.\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \"libxml/parser.h\"\n\nvoid parse() {\n  xmlDocPtr doc \u003d xmlReadFile(xmlFile, nullptr, XML_PARSE_DTDLOAD | XML_PARSE_NOENT); // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eBy default, \u003ccode\u003exmlReadFile\u003c/code\u003e is safe since version 2.9.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \"libxml/parser.h\"\n\nvoid parse() {\n  xmlDocPtr doc \u003d xmlReadFile(xmlFile, nullptr, 0);\n}\n\u003c/pre\u003e\n\u003ch3\u003eHow does this work?\u003c/h3\u003e\n\u003ch4\u003eDisable external entities\u003c/h4\u003e\n\u003cp\u003eThe most effective approach to prevent XXE vulnerabilities is to disable external entity processing entirely, unless it is explicitly required for\nspecific use cases. By default, XML parsers should be configured to reject the processing of external entities. This can be achieved by setting the\nappropriate properties or options in your XML parser library or framework.\u003c/p\u003e\n\u003cp\u003eIf external entity processing is necessary for certain scenarios, adopt a whitelisting approach to restrict the entities that can be resolved\nduring XML parsing. Create a list of trusted external entities and disallow all others. This approach ensures that only known and safe entities are\nprocessed.\u003cbr\u003e You should rely on features provided by your XML parser to restrict the external entities.\u003c/p\u003e",
        "context": {
          "key": "libxml2",
          "displayName": "libxml2"
        }
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/Top10/A05_2021-Security_Misconfiguration/\"\u003eOWASP Top 10 2021 Category A5\u003c/a\u003e - Security Misconfiguration \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/www-project-top-ten/2017/A4_2017-XML_External_Entities_(XXE)\"\u003eOWASP Top 10 2017 Category A4\u003c/a\u003e - XML External\n  Entities (XXE) \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/611\"\u003eMITRE, CWE-611\u003c/a\u003e - Information Exposure Through XML External Entity Reference \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/827\"\u003eMITRE, CWE-827\u003c/a\u003e - Improper Control of Document Type Definition \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "cwe",
      "symbolic-execution"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S2637",
    "name": "\"nonnull\" pointers should not be set to null",
    "defaultSeverity": "MINOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "LOW"
    },
    "description": "\u003cp\u003ePointers marked as \"nonnull\" may not be set to null, since they are typically not null-checked before use.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eA function’s return value and parameters may be decorated with attributes to convey additional information to the compiler and/or other\ndevelopers.\u003c/p\u003e\n\u003cp\u003eA commonly used attribute is \u003ccode\u003enonnull\u003c/code\u003e which can be used to mark a function’s return value and parameters as shown in the following:\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;stdlib.h\u0026gt;\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;string.h\u0026gt;\n\n__attribute__((returns_nonnull)) int *\nmake_array_copy(__attribute__((nonnull)) int *src, size_t len) {\n  int *dst \u003d (int *)malloc(len * sizeof(int));\n  if (dst \u003d\u003d NULL) {\n    perror(\"malloc failed\");\n    exit(1);\n  }\n  memcpy(dst, src, len);\n  return dst;\n}\n\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003enonnull\u003c/code\u003e attribute is meant for other developers and as a hint for compilers. Values marked as \u003ccode\u003enonnull\u003c/code\u003e are assumed to\nhave non-null values.\u003c/p\u003e\n\u003cp\u003eHowever, developers may accidentally break the \u003ccode\u003enonnull\u003c/code\u003e attribute as shown in the following code snippet:\u003c/p\u003e\n\u003cpre\u003e\n__attribute__((returns_nonnull))\nint* foo(__attribute__((nonnull)) int* x) {\n  x \u003d 0; // Noncompliant: `x` is marked \"nonnull\" but is set to null\n  foo(0); // Noncompliant: null is passed as an argument marked as \"nonnull\"\n  return 0; // Noncompliant: return value is marked \"nonnull\" but null is returned\n}\n\u003c/pre\u003e\n\u003cp\u003eFailing to adhere to the attribute may introduce serious program errors. In particular, the compiler does not enforce that values marked as\n\u003ccode\u003enonnull\u003c/code\u003e are indeed non-null at runtime; it is the developers\u0027 responsibility to adhere to the attribute. These values are typically\n\u003cem\u003enot\u003c/em\u003e null-checked before use. Setting a value marked as \u003ccode\u003enonnull\u003c/code\u003e to null (i.e., \u003ccode\u003eNULL\u003c/code\u003e, \u003ccode\u003e0\u003c/code\u003e or\n\u003ccode\u003enullptr\u003c/code\u003e) is hence likely to cause a null-pointer dereference. Compilers may even apply optimizations based on this attribute and might,\nfor instance, \u003cem\u003eremove\u003c/em\u003e an explicit null-check if the parameter is declared as \u003ccode\u003enonnull\u003c/code\u003e — even in code outside of the function with\nthe attribute.\u003c/p\u003e\n\u003cp\u003eNote that the \u003ccode\u003enonnull\u003c/code\u003e attribute is a GNU extension (see \u003ca\nhref\u003d\"https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html#index-nonnull-function-attribute\"\u003enonnull\u003c/a\u003e and \u003ca\nhref\u003d\"https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html#index-returns_005fnonnull-function-attribute\"\u003ereturns_nonnull\u003c/a\u003e) which many\ncompiler vendors have implemented.\u003c/p\u003e\n\u003ch2\u003eWhat is the potential impact?\u003c/h2\u003e\n\u003cp\u003eIn case a program dereferences a null pointer, it’s behavior is undefined. For programs that exercise undefined behavior the compiler no longer\nneeds to adhere to the language standard and the program has no meaning assigned to it.\u003c/p\u003e\n\u003cp\u003eIn practice, dereferencing a null pointer may lead to program crashes, or the application may appear to execute correctly while losing data or\nproducing incorrect results.\u003c/p\u003e\n\u003cp\u003eBesides affecting the application’s availability, null-pointer dereferences may lead to malicious code execution, in rare circumstances. If null is\nequivalent to the 0x0 memory address that can be accessed by privileged code, writing, and reading memory is possible, which compromises the integrity\nand confidentiality of the application.\u003c/p\u003e\n\u003cp\u003eBecause compilers may apply optimizations based on the \u003ccode\u003enonnull\u003c/code\u003e attribute, not respecting \u003ccode\u003enonnull\u003c/code\u003e can also introduce more\ncomplex bugs such as resource leaks or infinite loops as indicated in the following code snippet:\u003c/p\u003e\n\u003cpre\u003e\nstruct Node {\n  int data;\n  Node *next; // NULL for a tail node.\n};\n\nsize_t len(__attribute__((nonnull)) Node *n) {\n  size_t l \u003d 0;\n  while (n) {\n    ++l;\n    n \u003d n-\u0026gt;next;\n  }\n  return l;\n}\n\u003c/pre\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eEnsure not to pass null values when non-null arguments are expected, do not return a null value when a non-null return value is expected, and do\nnot assign null to parameters marked as non-null. This especially holds for library functions, which frequently require \u003ccode\u003enonnull\u003c/code\u003e pointer\nparameters.\u003c/p\u003e\n\u003cp\u003eOn other occasions, it might be more appropriate to remove the attribute.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n__attribute__((returns_nonnull))\nint* foo(__attribute__((nonnull)) int* x) {\n  *x \u003d 42;\n  return x;\n}\n\nvoid bar() {\n  int *p \u003d nullptr;\n  int *q \u003d foo(p); // Noncompliant: null value is passed as an argument marked \"nonnull\"\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n__attribute__((returns_nonnull))\nint* foo(__attribute__((nonnull)) int* x) {\n  *x \u003d 42;\n  return x;\n}\n\nvoid bar() {\n  int i \u003d 0;\n  int *p \u003d \u0026amp;i;\n  int *q \u003d foo(p); // Compliant: `p` points to a valid memory location\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\n__attribute__((returns_nonnull))\nint* foo() {\n  return nullptr; // Noncompliant: function may not return a null pointer\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\n__attribute__((returns_nonnull))\nint* foo() {\n  int *p \u003d new int(0);\n  return p; // Compliant: `p` points to a valid memory location\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid process(int *p);\n\nvoid foo(__attribute__((nonnull)) int *p) {\n  p \u003d nullptr; // Noncompliant: `p` is marked \"nonnull\" but is set to null\n  process(p);\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"compliant\"\u003e\nvoid process(int *p);\n\nvoid foo(__attribute__((nonnull)) int *p) {\n  process(p);\n}\n\u003c/pre\u003e\n\u003ch3\u003eGoing the extra mile\u003c/h3\u003e\n\u003cp\u003eIn C++, it is preferred to use reference parameters (\u003ccode\u003eType const\u0026amp;\u003c/code\u003e or \u003ccode\u003eType\u0026amp;\u003c/code\u003e), or pass objects by value\n(\u003ccode\u003eType\u003c/code\u003e), instead of a pointer (\u003ccode\u003eType const*\u003c/code\u003e or \u003ccode\u003eType*\u003c/code\u003e), if the argument is expected to never be null.\u003c/p\u003e\n\u003cpre\u003e\n// Precondition: graph !\u003d null\nbool isDAG(Graph const* graph);\n\u003c/pre\u003e\n\u003cp\u003eThe preferred signature would be:\u003c/p\u003e\n\u003cpre\u003e\nbool isDAG(Graph const\u0026amp; graph);\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/QdcxBQ\"\u003eEXP34-C. Do not dereference null pointers\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/display/java/EXP01-J.+Do+not+use+a+null+in+a+case+where+an+object+is+required\"\u003eEXP01-J. Do\n  not use a null in a case where an object is required\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/476\"\u003e476 NULL Pointer Dereference\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f16-for-in-parameters-pass-cheaply-copied-types-by-value-and-others-by-reference-to-const\"\u003eF.16: For \"in\" parameters, pass cheaply-copied types by value and others by reference to \u003ccode\u003econst\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f17-for-in-out-parameters-pass-by-reference-to-non-const\"\u003eF.17:\n  For \"in-out\" parameters, pass by reference to non-\u003ccode\u003econst\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:c:S2259} detects null-pointer dereferences \u003c/li\u003e\n  \u003cli\u003e {rule:c:S3807} detects calls to C library functions that require valid, non-null pointers with null pointer arguments \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003ePointers marked as \"nonnull\" may not be set to null, since they are typically not null-checked before use.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eA function’s return value and parameters may be decorated with attributes to convey additional information to the compiler and/or other\ndevelopers.\u003c/p\u003e\n\u003cp\u003eA commonly used attribute is \u003ccode\u003enonnull\u003c/code\u003e which can be used to mark a function’s return value and parameters as shown in the following:\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;stdlib.h\u0026gt;\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;string.h\u0026gt;\n\n__attribute__((returns_nonnull)) int *\nmake_array_copy(__attribute__((nonnull)) int *src, size_t len) {\n  int *dst \u003d (int *)malloc(len * sizeof(int));\n  if (dst \u003d\u003d NULL) {\n    perror(\"malloc failed\");\n    exit(1);\n  }\n  memcpy(dst, src, len);\n  return dst;\n}\n\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003enonnull\u003c/code\u003e attribute is meant for other developers and as a hint for compilers. Values marked as \u003ccode\u003enonnull\u003c/code\u003e are assumed to\nhave non-null values.\u003c/p\u003e\n\u003cp\u003eHowever, developers may accidentally break the \u003ccode\u003enonnull\u003c/code\u003e attribute as shown in the following code snippet:\u003c/p\u003e\n\u003cpre\u003e\n__attribute__((returns_nonnull))\nint* foo(__attribute__((nonnull)) int* x) {\n  x \u003d 0; // Noncompliant: `x` is marked \"nonnull\" but is set to null\n  foo(0); // Noncompliant: null is passed as an argument marked as \"nonnull\"\n  return 0; // Noncompliant: return value is marked \"nonnull\" but null is returned\n}\n\u003c/pre\u003e\n\u003cp\u003eFailing to adhere to the attribute may introduce serious program errors. In particular, the compiler does not enforce that values marked as\n\u003ccode\u003enonnull\u003c/code\u003e are indeed non-null at runtime; it is the developers\u0027 responsibility to adhere to the attribute. These values are typically\n\u003cem\u003enot\u003c/em\u003e null-checked before use. Setting a value marked as \u003ccode\u003enonnull\u003c/code\u003e to null (i.e., \u003ccode\u003eNULL\u003c/code\u003e, \u003ccode\u003e0\u003c/code\u003e or\n\u003ccode\u003enullptr\u003c/code\u003e) is hence likely to cause a null-pointer dereference. Compilers may even apply optimizations based on this attribute and might,\nfor instance, \u003cem\u003eremove\u003c/em\u003e an explicit null-check if the parameter is declared as \u003ccode\u003enonnull\u003c/code\u003e — even in code outside of the function with\nthe attribute.\u003c/p\u003e\n\u003cp\u003eNote that the \u003ccode\u003enonnull\u003c/code\u003e attribute is a GNU extension (see \u003ca\nhref\u003d\"https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html#index-nonnull-function-attribute\"\u003enonnull\u003c/a\u003e and \u003ca\nhref\u003d\"https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html#index-returns_005fnonnull-function-attribute\"\u003ereturns_nonnull\u003c/a\u003e) which many\ncompiler vendors have implemented.\u003c/p\u003e\n\u003ch2\u003eWhat is the potential impact?\u003c/h2\u003e\n\u003cp\u003eIn case a program dereferences a null pointer, it’s behavior is undefined. For programs that exercise undefined behavior the compiler no longer\nneeds to adhere to the language standard and the program has no meaning assigned to it.\u003c/p\u003e\n\u003cp\u003eIn practice, dereferencing a null pointer may lead to program crashes, or the application may appear to execute correctly while losing data or\nproducing incorrect results.\u003c/p\u003e\n\u003cp\u003eBesides affecting the application’s availability, null-pointer dereferences may lead to malicious code execution, in rare circumstances. If null is\nequivalent to the 0x0 memory address that can be accessed by privileged code, writing, and reading memory is possible, which compromises the integrity\nand confidentiality of the application.\u003c/p\u003e\n\u003cp\u003eBecause compilers may apply optimizations based on the \u003ccode\u003enonnull\u003c/code\u003e attribute, not respecting \u003ccode\u003enonnull\u003c/code\u003e can also introduce more\ncomplex bugs such as resource leaks or infinite loops as indicated in the following code snippet:\u003c/p\u003e\n\u003cpre\u003e\nstruct Node {\n  int data;\n  Node *next; // NULL for a tail node.\n};\n\nsize_t len(__attribute__((nonnull)) Node *n) {\n  size_t l \u003d 0;\n  while (n) {\n    ++l;\n    n \u003d n-\u0026gt;next;\n  }\n  return l;\n}\n\u003c/pre\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eEnsure not to pass null values when non-null arguments are expected, do not return a null value when a non-null return value is expected, and do\nnot assign null to parameters marked as non-null. This especially holds for library functions, which frequently require \u003ccode\u003enonnull\u003c/code\u003e pointer\nparameters.\u003c/p\u003e\n\u003cp\u003eOn other occasions, it might be more appropriate to remove the attribute.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n__attribute__((returns_nonnull))\nint* foo(__attribute__((nonnull)) int* x) {\n  *x \u003d 42;\n  return x;\n}\n\nvoid bar() {\n  int *p \u003d nullptr;\n  int *q \u003d foo(p); // Noncompliant: null value is passed as an argument marked \"nonnull\"\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n__attribute__((returns_nonnull))\nint* foo(__attribute__((nonnull)) int* x) {\n  *x \u003d 42;\n  return x;\n}\n\nvoid bar() {\n  int i \u003d 0;\n  int *p \u003d \u0026amp;i;\n  int *q \u003d foo(p); // Compliant: `p` points to a valid memory location\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\n__attribute__((returns_nonnull))\nint* foo() {\n  return nullptr; // Noncompliant: function may not return a null pointer\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\n__attribute__((returns_nonnull))\nint* foo() {\n  int *p \u003d new int(0);\n  return p; // Compliant: `p` points to a valid memory location\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid process(int *p);\n\nvoid foo(__attribute__((nonnull)) int *p) {\n  p \u003d nullptr; // Noncompliant: `p` is marked \"nonnull\" but is set to null\n  process(p);\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"compliant\"\u003e\nvoid process(int *p);\n\nvoid foo(__attribute__((nonnull)) int *p) {\n  process(p);\n}\n\u003c/pre\u003e\n\u003ch3\u003eGoing the extra mile\u003c/h3\u003e\n\u003cp\u003eIn C++, it is preferred to use reference parameters (\u003ccode\u003eType const\u0026amp;\u003c/code\u003e or \u003ccode\u003eType\u0026amp;\u003c/code\u003e), or pass objects by value\n(\u003ccode\u003eType\u003c/code\u003e), instead of a pointer (\u003ccode\u003eType const*\u003c/code\u003e or \u003ccode\u003eType*\u003c/code\u003e), if the argument is expected to never be null.\u003c/p\u003e\n\u003cpre\u003e\n// Precondition: graph !\u003d null\nbool isDAG(Graph const* graph);\n\u003c/pre\u003e\n\u003cp\u003eThe preferred signature would be:\u003c/p\u003e\n\u003cpre\u003e\nbool isDAG(Graph const\u0026amp; graph);\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/QdcxBQ\"\u003eEXP34-C. Do not dereference null pointers\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/display/java/EXP01-J.+Do+not+use+a+null+in+a+case+where+an+object+is+required\"\u003eEXP01-J. Do\n  not use a null in a case where an object is required\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/476\"\u003e476 NULL Pointer Dereference\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f16-for-in-parameters-pass-cheaply-copied-types-by-value-and-others-by-reference-to-const\"\u003eF.16: For \"in\" parameters, pass cheaply-copied types by value and others by reference to \u003ccode\u003econst\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f17-for-in-out-parameters-pass-by-reference-to-non-const\"\u003eF.17:\n  For \"in-out\" parameters, pass by reference to non-\u003ccode\u003econst\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:c:S2259} detects null-pointer dereferences \u003c/li\u003e\n  \u003cli\u003e {rule:c:S3807} detects calls to C library functions that require valid, non-null pointers with null pointer arguments \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "cert",
      "cwe",
      "symbolic-execution"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S2757",
    "name": "Non-existent operators like \"\u003d+\" should not be used",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eUsing operator pairs (e.g., \u003ccode\u003e\u003d+\u003c/code\u003e) that look like reversed single operators (e.g., \u003ccode\u003e+\u003d\u003c/code\u003e) is confusing. They compile and run\nbut do not produce the same result as their mirrored counterpart.\u003c/p\u003e\n\u003cpre\u003e\nint target \u003d -5;\nint num \u003d 3;\n\ntarget \u003d- num;  // Noncompliant: target \u003d -3. Is that the intended behavior?\ntarget \u003d+ num; // Noncompliant: target \u003d 3\n\u003c/pre\u003e\n\u003cp\u003eThis rule raises an issue when \u003ccode\u003e\u003d+\u003c/code\u003e, \u003ccode\u003e\u003d-\u003c/code\u003e, \u003ccode\u003e\u003d!\u003c/code\u003e, \u003ccode\u003e\u003d\u0026amp;\u003c/code\u003e, \u003ccode\u003e\u003d*\u003c/code\u003e, \u003ccode\u003e+\u003d+\u003c/code\u003e, and\n\u003ccode\u003e-\u003d-\u003c/code\u003e are used without any space between the operators and when there is at least one whitespace after.\u003c/p\u003e\n\u003cp\u003eReplace the operators with a single one if that is the intention\u003c/p\u003e\n\u003cpre\u003e\nint target \u003d -5;\nint num \u003d 3;\n\ntarget -\u003d num;  // target \u003d -8\n\u003c/pre\u003e\n\u003cp\u003eOr fix the spacing to avoid confusion\u003c/p\u003e\n\u003cpre\u003e\nint target \u003d -5;\nint num \u003d 3;\n\ntarget \u003d -num;  // target \u003d -3\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eUsing operator pairs (e.g., \u003ccode\u003e\u003d+\u003c/code\u003e) that look like reversed single operators (e.g., \u003ccode\u003e+\u003d\u003c/code\u003e) is confusing. They compile and run\nbut do not produce the same result as their mirrored counterpart.\u003c/p\u003e\n\u003cpre\u003e\nint target \u003d -5;\nint num \u003d 3;\n\ntarget \u003d- num;  // Noncompliant: target \u003d -3. Is that the intended behavior?\ntarget \u003d+ num; // Noncompliant: target \u003d 3\n\u003c/pre\u003e\n\u003cp\u003eThis rule raises an issue when \u003ccode\u003e\u003d+\u003c/code\u003e, \u003ccode\u003e\u003d-\u003c/code\u003e, \u003ccode\u003e\u003d!\u003c/code\u003e, \u003ccode\u003e\u003d\u0026amp;\u003c/code\u003e, \u003ccode\u003e\u003d*\u003c/code\u003e, \u003ccode\u003e+\u003d+\u003c/code\u003e, and\n\u003ccode\u003e-\u003d-\u003c/code\u003e are used without any space between the operators and when there is at least one whitespace after.\u003c/p\u003e\n\u003cp\u003eReplace the operators with a single one if that is the intention\u003c/p\u003e\n\u003cpre\u003e\nint target \u003d -5;\nint num \u003d 3;\n\ntarget -\u003d num;  // target \u003d -8\n\u003c/pre\u003e\n\u003cp\u003eOr fix the spacing to avoid confusion\u003c/p\u003e\n\u003cpre\u003e\nint target \u003d -5;\nint num \u003d 3;\n\ntarget \u003d -num;  // target \u003d -3\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S3728",
    "name": "String literals should not be concatenated implicitly",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "FORMATTED",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhile in C, and derived languages, it is legal to concatenate two literals by putting them next to each other, this is only justified in a few\ncases. For instance if one is a macro or if the layout makes it clearer.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nconst char * v1 \u003d \"a\"\"b\";      // Noncompliant; same as \"ab\"\nconst char * v2 \u003d \"a\\n\" \"b\\n\"; // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nconst char * v1 \u003d \"ab\"\nconst char * v2 \u003d \"a\\n\"\n                  \"b\\n\";\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cpre\u003e\nconst char * v3 \u003d \"a\" /* comment */ \"b\";\n\n#define _s \"b\"\nconst char * v4 \u003d \"a\" _s; // concatenation with macro ignored\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhile in C, and derived languages, it is legal to concatenate two literals by putting them next to each other, this is only justified in a few\ncases. For instance if one is a macro or if the layout makes it clearer.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nconst char * v1 \u003d \"a\"\"b\";      // Noncompliant; same as \"ab\"\nconst char * v2 \u003d \"a\\n\" \"b\\n\"; // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nconst char * v1 \u003d \"ab\"\nconst char * v2 \u003d \"a\\n\"\n                  \"b\\n\";\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cpre\u003e\nconst char * v3 \u003d \"a\" /* comment */ \"b\";\n\n#define _s \"b\"\nconst char * v4 \u003d \"a\" _s; // concatenation with macro ignored\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "confusing"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S3729",
    "name": "Array indices should be placed between brackets",
    "defaultSeverity": "BLOCKER",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhile C syntax considers array subscripts (\u003ccode\u003e[]\u003c/code\u003e) as symmetrical, meaning that \u003ccode\u003ea[i]\u003c/code\u003e and \u003ccode\u003ei[a]\u003c/code\u003e are equivalent,\nthe convention is to put the index in the brackets rather than the array name. Inverting the index and array name serves no purpose, and is very\nconfusing.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n10[P1] \u003d 0; // Noncompliant\ndostuff(i[arr]); // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nP1[10] \u003d 0;\ndostuff(arr[i]);\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhile C syntax considers array subscripts (\u003ccode\u003e[]\u003c/code\u003e) as symmetrical, meaning that \u003ccode\u003ea[i]\u003c/code\u003e and \u003ccode\u003ei[a]\u003c/code\u003e are equivalent,\nthe convention is to put the index in the brackets rather than the array name. Inverting the index and array name serves no purpose, and is very\nconfusing.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n10[P1] \u003d 0; // Noncompliant\ndostuff(i[arr]); // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nP1[10] \u003d 0;\ndostuff(arr[i]);\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S122",
    "name": "Statements should be on separate lines",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "FORMATTED",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003ePutting multiple statements on a single line lowers the code readability and makes debugging the code more complex.\u003c/p\u003e\n\u003cpre\u003e\nfoo(); bar(); // Noncompliant\n\u003c/pre\u003e\n\u003cp\u003eWrite one statement per line to improve readability.\u003c/p\u003e\n\u003cpre\u003e\nfoo();\nbar();\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThe rule ignores:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e control flow statements with a single nested statement \u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\nif (condition) doSomething();     // Compliant by exception\nwhile (condition) doSomething();  // Compliant by exception\n\u003c/pre\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003ecase\u003c/code\u003e or \u003ccode\u003edefault\u003c/code\u003e statements containing a single statement followed by \u003ccode\u003ebreak\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\nswitch (foo) {\n  case  0: doSomething(); break;    // Compliant by exception\n  default: doSomething(); break;    // Compliant by exception\n}\n\u003c/pre\u003e\n\u003cul\u003e\n  \u003cli\u003e statements enclosed in curly braces on the same line \u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\nauto lambda \u003d [](int x) { doSomething(x); return x; }; // Compliant by exception\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003ePutting multiple statements on a single line lowers the code readability and makes debugging the code more complex.\u003c/p\u003e\n\u003cpre\u003e\nfoo(); bar(); // Noncompliant\n\u003c/pre\u003e\n\u003cp\u003eWrite one statement per line to improve readability.\u003c/p\u003e\n\u003cpre\u003e\nfoo();\nbar();\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThe rule ignores:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e control flow statements with a single nested statement \u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\nif (condition) doSomething();     // Compliant by exception\nwhile (condition) doSomething();  // Compliant by exception\n\u003c/pre\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003ecase\u003c/code\u003e or \u003ccode\u003edefault\u003c/code\u003e statements containing a single statement followed by \u003ccode\u003ebreak\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\nswitch (foo) {\n  case  0: doSomething(); break;    // Compliant by exception\n  default: doSomething(); break;    // Compliant by exception\n}\n\u003c/pre\u003e\n\u003cul\u003e\n  \u003cli\u003e statements enclosed in curly braces on the same line \u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\nauto lambda \u003d [](int x) { doSomething(x); return x; }; // Compliant by exception\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "convention"
    ],
    "deprecatedKeys": [
      "c:OneStatementPerLine"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S121",
    "name": "Control structures should use curly braces",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003cp\u003eControl structures are code statements that impact the program’s control flow (e.g., if statements, for loops, etc.)\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhile not technically incorrect, the omission of curly braces can be misleading and may lead to the introduction of errors during maintenance.\u003c/p\u003e\n\u003cp\u003eIn the following example, the two calls seem to be attached to the \u003ccode\u003eif\u003c/code\u003e statement, but only the first one is, and\n\u003ccode\u003echeckSomething\u003c/code\u003e will always be executed:\u003c/p\u003e\n\u003cpre\u003e\nif (condition)  // Noncompliant\n  executeSomething();\n  checkSomething();\n\u003c/pre\u003e\n\u003cp\u003eAdding curly braces improves the code readability and its robustness:\u003c/p\u003e\n\u003cpre\u003e\nif (condition) {\n  executeSomething();\n  checkSomething();\n}\n\u003c/pre\u003e\n\u003cp\u003eThe rule raises an issue when a control structure has no curly braces.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 14.8 - The statement forming the body of a switch, while, do …​ while or for statement shall be a compound statement \u003c/li\u003e\n  \u003cli\u003e MISRA C:2004, 14.9 - An if (expression) construct shall be followed by a compound statement. The else keyword shall be followed by either a\n  compound statement, or another if statement \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 6-3-1 - The statement forming the body of a switch, while, do …​ while or for statement shall be a compound statement \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 6-4-1 - An if (condition) construct shall be followed by a compound statement. The else keyword shall be followed by either a\n  compound statement, or another if statement \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 15.6 - The body of an iteration-statement or a selection-statement shall be a compound-statement \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/g9YxBQ\"\u003eCERT, EXP19-C.\u003c/a\u003e - Use braces for the body of an if, for, or while statement \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eControl structures are code statements that impact the program’s control flow (e.g., if statements, for loops, etc.)\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhile not technically incorrect, the omission of curly braces can be misleading and may lead to the introduction of errors during maintenance.\u003c/p\u003e\n\u003cp\u003eIn the following example, the two calls seem to be attached to the \u003ccode\u003eif\u003c/code\u003e statement, but only the first one is, and\n\u003ccode\u003echeckSomething\u003c/code\u003e will always be executed:\u003c/p\u003e\n\u003cpre\u003e\nif (condition)  // Noncompliant\n  executeSomething();\n  checkSomething();\n\u003c/pre\u003e\n\u003cp\u003eAdding curly braces improves the code readability and its robustness:\u003c/p\u003e\n\u003cpre\u003e\nif (condition) {\n  executeSomething();\n  checkSomething();\n}\n\u003c/pre\u003e\n\u003cp\u003eThe rule raises an issue when a control structure has no curly braces.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 14.8 - The statement forming the body of a switch, while, do …​ while or for statement shall be a compound statement \u003c/li\u003e\n  \u003cli\u003e MISRA C:2004, 14.9 - An if (expression) construct shall be followed by a compound statement. The else keyword shall be followed by either a\n  compound statement, or another if statement \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 6-3-1 - The statement forming the body of a switch, while, do …​ while or for statement shall be a compound statement \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 6-4-1 - An if (condition) construct shall be followed by a compound statement. The else keyword shall be followed by either a\n  compound statement, or another if statement \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 15.6 - The body of an iteration-statement or a selection-statement shall be a compound-statement \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/g9YxBQ\"\u003eCERT, EXP19-C.\u003c/a\u003e - Use braces for the body of an if, for, or while statement \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "based-on-misra",
      "cert",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S1541",
    "name": "Cyclomatic Complexity of functions should not be too high",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "FOCUSED",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe Cyclomatic Complexity of functions should not exceed a defined threshold. Complex code may perform poorly and can be difficult to test\nthoroughly.\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe Cyclomatic Complexity of functions should not exceed a defined threshold. Complex code may perform poorly and can be difficult to test\nthoroughly.\u003c/p\u003e"
      }
    ],
    "params": {
      "maximumFunctionComplexityThreshold": {
        "key": "maximumFunctionComplexityThreshold",
        "name": "maximumFunctionComplexityThreshold",
        "description": "The maximum authorized complexity.",
        "defaultValue": "20",
        "type": "INTEGER",
        "multiple": false,
        "possibleValues": []
      }
    },
    "defaultParams": {
      "maximumFunctionComplexityThreshold": "20"
    },
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "brain-overload"
    ],
    "deprecatedKeys": [
      "c:FunctionComplexity"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S1301",
    "name": "\"if\" statements should be preferred over \"switch\" when simpler",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eswitch\u003c/code\u003e statements are useful when there are many different cases depending on the value of the same expression. For just one or two\ncases, however, the code will be more readable with \u003ccode\u003eif\u003c/code\u003e statements.\u003c/p\u003e\n\u003cp\u003eIn particular, \u003ccode\u003eif\u003c/code\u003e statements are more suitable when the condition of the \u003ccode\u003eswitch\u003c/code\u003e is boolean.\u003c/p\u003e\n\u003cp\u003eThis rule detects statements that could be simplified with a simple \u003ccode\u003eif / else\u003c/code\u003e. That is when there is at most one \u003ccode\u003ecase\u003c/code\u003e,\nnot counting those that fall through to a \u003ccode\u003edefault\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThe following code:\u003c/p\u003e\n\u003cpre\u003e\nswitch (variable) {\n  case 0:\n    doSomething();\n    break;\n  case 1:\n  case 2:\n  default:\n    doSomethingElse();\n    break;\n}\n\u003c/pre\u003e\n\u003cp\u003eWould be more readable that way:\u003c/p\u003e\n\u003cpre\u003e\nif (variable \u003d\u003d 0) {\n  doSomething();\n} else {\n  doSomethingElse();\n}\n\u003c/pre\u003e\n\u003cp\u003eWhile the following snippets don’t trigger the rule because using \u003ccode\u003eif\u003c/code\u003e would not improve their readability:\u003c/p\u003e\n\u003cpre\u003e\nswitch (variable) {\n  case 0:\n  case 1: // Would need a less readable check in an `if`\n    doSomething();\n    break;\n}\n\nswitch (variable) {\n  case 0:\n    doSomething();\n    break;\n  case 1: // Would require introducing `else if`\n    doSomethingElse();\n    break;\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2012, 16.6 - Every switch statement shall have at least two switch-clauses \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003ccode\u003eswitch\u003c/code\u003e statements are useful when there are many different cases depending on the value of the same expression. For just one or two\ncases, however, the code will be more readable with \u003ccode\u003eif\u003c/code\u003e statements.\u003c/p\u003e\n\u003cp\u003eIn particular, \u003ccode\u003eif\u003c/code\u003e statements are more suitable when the condition of the \u003ccode\u003eswitch\u003c/code\u003e is boolean.\u003c/p\u003e\n\u003cp\u003eThis rule detects statements that could be simplified with a simple \u003ccode\u003eif / else\u003c/code\u003e. That is when there is at most one \u003ccode\u003ecase\u003c/code\u003e,\nnot counting those that fall through to a \u003ccode\u003edefault\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThe following code:\u003c/p\u003e\n\u003cpre\u003e\nswitch (variable) {\n  case 0:\n    doSomething();\n    break;\n  case 1:\n  case 2:\n  default:\n    doSomethingElse();\n    break;\n}\n\u003c/pre\u003e\n\u003cp\u003eWould be more readable that way:\u003c/p\u003e\n\u003cpre\u003e\nif (variable \u003d\u003d 0) {\n  doSomething();\n} else {\n  doSomethingElse();\n}\n\u003c/pre\u003e\n\u003cp\u003eWhile the following snippets don’t trigger the rule because using \u003ccode\u003eif\u003c/code\u003e would not improve their readability:\u003c/p\u003e\n\u003cpre\u003e\nswitch (variable) {\n  case 0:\n  case 1: // Would need a less readable check in an `if`\n    doSomething();\n    break;\n}\n\nswitch (variable) {\n  case 0:\n    doSomething();\n    break;\n  case 1: // Would require introducing `else if`\n    doSomethingElse();\n    break;\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2012, 16.6 - Every switch statement shall have at least two switch-clauses \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "bad-practice",
      "based-on-misra"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S1543",
    "name": "Macro names should comply with a naming convention",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "IDENTIFIABLE",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eSharing some naming conventions is a key point to make it possible for a team to efficiently collaborate. This rule allows to check that all macro\nnames match a provided regular expression.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#define foo // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#define FOO\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eSharing some naming conventions is a key point to make it possible for a team to efficiently collaborate. This rule allows to check that all macro\nnames match a provided regular expression.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#define foo // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#define FOO\n\u003c/pre\u003e"
      }
    ],
    "params": {
      "format": {
        "key": "format",
        "name": "format",
        "description": "POSIX regular expression used to check the macro names against.",
        "defaultValue": "^[A-Z][A-Z0-9_]*$",
        "type": "STRING",
        "multiple": false,
        "possibleValues": []
      }
    },
    "defaultParams": {
      "format": "^[A-Z][A-Z0-9_]*$"
    },
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "convention",
      "preprocessor"
    ],
    "deprecatedKeys": [
      "c:PPMacroName"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S2754",
    "name": "Declarations should not be empty",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eEmpty declarations are cruft; they (may) compile, but they violate the language standards, don’t contribute anything of value, and clutter up the\nprogram. Like cobwebs, they should be swept away.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint;  // Noncompliant\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e ISO/IEC 9899:2011, 6.7p2 \u003c/li\u003e\n  \u003cli\u003e ISO/IEC 14882:2011, 7p3. \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/5dUxBQ\"\u003eCERT, MSC12-C.\u003c/a\u003e - Detect and remove code that has no effect or is never executed\n  \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eEmpty declarations are cruft; they (may) compile, but they violate the language standards, don’t contribute anything of value, and clutter up the\nprogram. Like cobwebs, they should be swept away.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint;  // Noncompliant\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e ISO/IEC 9899:2011, 6.7p2 \u003c/li\u003e\n  \u003cli\u003e ISO/IEC 14882:2011, 7p3. \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/5dUxBQ\"\u003eCERT, MSC12-C.\u003c/a\u003e - Detect and remove code that has no effect or is never executed\n  \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "cert",
      "unused"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S2753",
    "name": "Values of different \"enum\" types should not be compared",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eJust as comparing apples and oranges is seen as a classic folly, comparing values from different enumerations against each other or converting them\ninto one another is nonsensical. True, at root \u003ccode\u003eenum\u003c/code\u003es are simply named numbers, and it’s certainly valid to compare numbers. But an added\nlayer of meaning is created by an \u003ccode\u003eenum\u003c/code\u003e, one that goes beyond simple numerical values.\u003c/p\u003e\n\u003cp\u003eIgnoring that extra layer of meaning is at best a trap for maintainers, who are likely to be hopelessly confused by the code. At worst, it is a\nbug, which will lead to unexpected results.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nenum apple {BRAEBURN, FUJI, GRANNY_SMITH, RED_DELICIOUS};\nenum orange {BLOOD, NAVEL, BITTER, BERGAMOT, MANDARIN};\n\nvoid makeCider(apple v);\n\nbool fun(apple v1, orange v2) {\n  makeCider((apple)v2); // Noncompliant\n  return v1 !\u003d v2;  // Noncompliant\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eJust as comparing apples and oranges is seen as a classic folly, comparing values from different enumerations against each other or converting them\ninto one another is nonsensical. True, at root \u003ccode\u003eenum\u003c/code\u003es are simply named numbers, and it’s certainly valid to compare numbers. But an added\nlayer of meaning is created by an \u003ccode\u003eenum\u003c/code\u003e, one that goes beyond simple numerical values.\u003c/p\u003e\n\u003cp\u003eIgnoring that extra layer of meaning is at best a trap for maintainers, who are likely to be hopelessly confused by the code. At worst, it is a\nbug, which will lead to unexpected results.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nenum apple {BRAEBURN, FUJI, GRANNY_SMITH, RED_DELICIOUS};\nenum orange {BLOOD, NAVEL, BITTER, BERGAMOT, MANDARIN};\n\nvoid makeCider(apple v);\n\nbool fun(apple v1, orange v2) {\n  makeCider((apple)v2); // Noncompliant\n  return v1 !\u003d v2;  // Noncompliant\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S108",
    "name": "Nested blocks of code should not be left empty",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eAn empty code block is confusing. It will require some effort from maintainers to determine if it is intentional or indicates the implementation is\nincomplete.\u003c/p\u003e\n\u003cpre\u003e\nvoid foo()\n{\n  int x;\n  if (x \u003d\u003d 42)\n  // Noncompliant - the following nested block is empty\n  {\n  }\n  else\n  {\n    doSomething();\n  }\n}\n\u003c/pre\u003e\n\u003cp\u003eRemoving or filling the empty code blocks takes away ambiguity and generally results in a more straightforward and less surprising code.\u003c/p\u003e\n\u003cpre\u003e\nvoid foo()\n{\n  int x;\n  if (x !\u003d 42)\n  {\n    doSomething();\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e The rule ignores code blocks that contain comments. \u003c/li\u003e\n  \u003cli\u003e Functions are not nested blocks, so they can be empty. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\nvoid bar()\n// Compliant - functions are not nested blocks\n{\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eAn empty code block is confusing. It will require some effort from maintainers to determine if it is intentional or indicates the implementation is\nincomplete.\u003c/p\u003e\n\u003cpre\u003e\nvoid foo()\n{\n  int x;\n  if (x \u003d\u003d 42)\n  // Noncompliant - the following nested block is empty\n  {\n  }\n  else\n  {\n    doSomething();\n  }\n}\n\u003c/pre\u003e\n\u003cp\u003eRemoving or filling the empty code blocks takes away ambiguity and generally results in a more straightforward and less surprising code.\u003c/p\u003e\n\u003cpre\u003e\nvoid foo()\n{\n  int x;\n  if (x !\u003d 42)\n  {\n    doSomething();\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e The rule ignores code blocks that contain comments. \u003c/li\u003e\n  \u003cli\u003e Functions are not nested blocks, so they can be empty. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\nvoid bar()\n// Compliant - functions are not nested blocks\n{\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "suspicious"
    ],
    "deprecatedKeys": [
      "c:EmptyCompoundStatement"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S109",
    "name": "Magic numbers should not be used",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003cp\u003eA magic number is a hard-coded numerical value that may lack context or meaning. They should not be used because they can make the code less\nreadable and maintainable.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eMagic numbers make the code more complex to understand as it requires the reader to have knowledge about the global context to understand the\nnumber itself. Their usage may seem obvious when writing the code, but it may not be the case for another developer or later once the context faded\naway. -1, 0, and 1 are not considered magic numbers.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eReplacing them with a constant allows us to provide a meaningful name associated with the value. Instead of adding complexity to the code, it\nbrings clarity and helps to understand the context and the global meaning.\u003c/p\u003e\n\u003cp\u003eThis is classically done by using a constant (\u003ccode\u003econstexpr\u003c/code\u003e or \u003ccode\u003econst\u003c/code\u003e if your compiler does not support \u003ccode\u003econstexpr\u003c/code\u003e\nyet) or an enumeration. Note that since C++20, some well-known mathematical constants, such as pi, are defined in the\nheader\u0026nbsp;\u003ccode\u003e\u0026lt;numbers\u0026gt;\u003c/code\u003e, and should be preferred over defining your own version (see S6164).\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid doSomething(int var) {\n  for (int i \u003d 0; i \u0026lt; 42; i++) { // Noncompliant - 42 is a magic number\n    // ...\n  }\n\n  if (42 \u003d\u003d var) { // Noncompliant - magic number\n    // ...\n  }\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nenum Status {\n  STATUS_OK \u003d 0,\n  STATUS_ERROR \u003d 42\n};\n\nvoid doSomething(Status var) {\n  constexpr int maxIterations \u003d 42; // Compliant - in a declaration\n  for (int i \u003d 0; i \u0026lt; maxIterations; i++) { // Compliant - 0 is excluded, and maxIterations is a named constant\n    // ...\n  }\n\n  if (STATUS_OK \u003d\u003d var) { // Compliant - number comes from an enum\n    // ...\n  }\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eA magic number is a hard-coded numerical value that may lack context or meaning. They should not be used because they can make the code less\nreadable and maintainable.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eMagic numbers make the code more complex to understand as it requires the reader to have knowledge about the global context to understand the\nnumber itself. Their usage may seem obvious when writing the code, but it may not be the case for another developer or later once the context faded\naway. -1, 0, and 1 are not considered magic numbers.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eReplacing them with a constant allows us to provide a meaningful name associated with the value. Instead of adding complexity to the code, it\nbrings clarity and helps to understand the context and the global meaning.\u003c/p\u003e\n\u003cp\u003eThis is classically done by using a constant (\u003ccode\u003econstexpr\u003c/code\u003e or \u003ccode\u003econst\u003c/code\u003e if your compiler does not support \u003ccode\u003econstexpr\u003c/code\u003e\nyet) or an enumeration. Note that since C++20, some well-known mathematical constants, such as pi, are defined in the\nheader\u0026nbsp;\u003ccode\u003e\u0026lt;numbers\u0026gt;\u003c/code\u003e, and should be preferred over defining your own version (see S6164).\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid doSomething(int var) {\n  for (int i \u003d 0; i \u0026lt; 42; i++) { // Noncompliant - 42 is a magic number\n    // ...\n  }\n\n  if (42 \u003d\u003d var) { // Noncompliant - magic number\n    // ...\n  }\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nenum Status {\n  STATUS_OK \u003d 0,\n  STATUS_ERROR \u003d 42\n};\n\nvoid doSomething(Status var) {\n  constexpr int maxIterations \u003d 42; // Compliant - in a declaration\n  for (int i \u003d 0; i \u0026lt; maxIterations; i++) { // Compliant - 0 is excluded, and maxIterations is a named constant\n    // ...\n  }\n\n  if (STATUS_OK \u003d\u003d var) { // Compliant - number comes from an enum\n    // ...\n  }\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "brain-overload"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S107",
    "name": "Functions should not have too many parameters",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "FOCUSED",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eFunctions with a long parameter list are difficult to use, as maintainers must figure out the role of each parameter and keep track of their\nposition.\u003c/p\u003e\n\u003cpre\u003e\nvoid setCoordinates(int x1, int y1, int z1, int x2, int y2, int z2) { // Noncompliant\n    // ...\n}\n\u003c/pre\u003e\n\u003cp\u003eThe solution can be to:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Split the function into smaller ones \u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\n// Each function does a part of what the original setCoordinates function was doing, so confusion risks are lower\nvoid setOrigin(int x, int y, int z) {\n   // ...\n}\n\nvoid setSize(int width, int height, int depth) {\n   // ...\n}\n\u003c/pre\u003e\n\u003cul\u003e\n  \u003cli\u003e Find a better data structure for the parameters that group data in a way that makes sense for the specific application domain \u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\nstruct Point {  // In geometry, Point is a logical structure to group data\n    int x;\n    int y;\n    int z;\n};\n\nvoid setCoordinates(Point p1, Point p2) {\n    // ...\n}\n\u003c/pre\u003e\n\u003cp\u003eThis rule raises an issue when a function has more parameters than the provided threshold.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#i23-keep-the-number-of-function-arguments-low\"\u003eI.23: Keep the\n  number of function arguments low\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eFunctions with a long parameter list are difficult to use, as maintainers must figure out the role of each parameter and keep track of their\nposition.\u003c/p\u003e\n\u003cpre\u003e\nvoid setCoordinates(int x1, int y1, int z1, int x2, int y2, int z2) { // Noncompliant\n    // ...\n}\n\u003c/pre\u003e\n\u003cp\u003eThe solution can be to:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Split the function into smaller ones \u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\n// Each function does a part of what the original setCoordinates function was doing, so confusion risks are lower\nvoid setOrigin(int x, int y, int z) {\n   // ...\n}\n\nvoid setSize(int width, int height, int depth) {\n   // ...\n}\n\u003c/pre\u003e\n\u003cul\u003e\n  \u003cli\u003e Find a better data structure for the parameters that group data in a way that makes sense for the specific application domain \u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\nstruct Point {  // In geometry, Point is a logical structure to group data\n    int x;\n    int y;\n    int z;\n};\n\nvoid setCoordinates(Point p1, Point p2) {\n    // ...\n}\n\u003c/pre\u003e\n\u003cp\u003eThis rule raises an issue when a function has more parameters than the provided threshold.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#i23-keep-the-number-of-function-arguments-low\"\u003eI.23: Keep the\n  number of function arguments low\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {
      "max": {
        "key": "max",
        "name": "max",
        "description": "Maximum authorized number of parameters",
        "defaultValue": "7",
        "type": "INTEGER",
        "multiple": false,
        "possibleValues": []
      }
    },
    "defaultParams": {
      "max": "7"
    },
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "brain-overload"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S104",
    "name": "Files should not have too many lines of code",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "FOCUSED",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhen a source file grows too much, it can accumulate numerous responsibilities and become challenging to understand and maintain.\u003c/p\u003e\n\u003cp\u003eAbove a specific threshold, refactor the file into smaller files whose code focuses on well-defined tasks. Those smaller files will be easier to\nunderstand and test.\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhen a source file grows too much, it can accumulate numerous responsibilities and become challenging to understand and maintain.\u003c/p\u003e\n\u003cp\u003eAbove a specific threshold, refactor the file into smaller files whose code focuses on well-defined tasks. Those smaller files will be easier to\nunderstand and test.\u003c/p\u003e"
      }
    ],
    "params": {
      "maximumFileLocThreshold": {
        "key": "maximumFileLocThreshold",
        "name": "maximumFileLocThreshold",
        "description": "The maximum authorized lines",
        "defaultValue": "1000",
        "type": "INTEGER",
        "multiple": false,
        "possibleValues": []
      }
    },
    "defaultParams": {
      "maximumFileLocThreshold": "1000"
    },
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "brain-overload"
    ],
    "deprecatedKeys": [
      "c:FileLoc"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:M23_218",
    "name": "The standard \"header file\" \"\u003ccsetjmp\u003e\" shall not be used",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 21.10.2\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eIn addition, none of the facilities that are specified as being provided by \u003ccode\u003e\u0026lt;csetjmp\u0026gt;\u003c/code\u003e shall be used.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e use of \u003ccode\u003e\u0026lt;setjmp.h\u0026gt;\u003c/code\u003e and the facilities it provides are also prohibited by this rule.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eThe use of \u003ccode\u003esetjmp\u003c/code\u003e and \u003ccode\u003elongjmp\u003c/code\u003e allow the normal function return mechanisms to be bypassed. Their use may result in\n\u003cem\u003eundefined\u003c/em\u003e and \u003cem\u003eunspecified behaviour\u003c/em\u003e. For example, it is \u003cem\u003eundefined behaviour\u003c/em\u003e if \u003ccode\u003elongjmp\u003c/code\u003e results in the omission\nof non-trivial object destruction.\u003c/p\u003e\n\u003cp\u003eSafety standards, such as IEC\u0026nbsp;61508\u0026nbsp; (Part 6, Table 6), encourage the use of the \"single-entry single-exit\" principle as part of the\n\"modular approach\". Unstructured languages, such as assembly, allow jumps between arbitrary points in a program, violating this principle. C++, with\nits concept of functions and the corresponding calling mechanism, enforces the \"single-entry single-exit\" principle through its language definition —\nfor example, multiple return statements within a function all return to the call site.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e the C++ Standard states that aspects of the behaviour associated with these facilities are defined in the related version of\nISO\u0026nbsp;9899\u0026nbsp;.\u003c/p\u003e\n\u003ch3\u003eGlossary\u003c/h3\u003e\n\u003ch4\u003e[1] Header file\u003c/h4\u003e\n\u003cp\u003eA \u003cem\u003eheader file\u003c/em\u003e is considered to be any file that is included during preprocessing (for example via the \u003ccode\u003e#include\u003c/code\u003e directive),\nregardless of its name or suffix.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003e{rule:c:S982} targets the same defect as this rule but for a non-mission-critical context.\u003c/p\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/ktYxBQ\"\u003eCERT, MSC22-C.\u003c/a\u003e - Use the setjmp(), longjmp() facility securely \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/nHs-BQ\"\u003eCERT, ERR52-CPP.\u003c/a\u003e - Do not use setjmp() or longjmp() \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 21.10.2\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eIn addition, none of the facilities that are specified as being provided by \u003ccode\u003e\u0026lt;csetjmp\u0026gt;\u003c/code\u003e shall be used.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e use of \u003ccode\u003e\u0026lt;setjmp.h\u0026gt;\u003c/code\u003e and the facilities it provides are also prohibited by this rule.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eThe use of \u003ccode\u003esetjmp\u003c/code\u003e and \u003ccode\u003elongjmp\u003c/code\u003e allow the normal function return mechanisms to be bypassed. Their use may result in\n\u003cem\u003eundefined\u003c/em\u003e and \u003cem\u003eunspecified behaviour\u003c/em\u003e. For example, it is \u003cem\u003eundefined behaviour\u003c/em\u003e if \u003ccode\u003elongjmp\u003c/code\u003e results in the omission\nof non-trivial object destruction.\u003c/p\u003e\n\u003cp\u003eSafety standards, such as IEC\u0026nbsp;61508\u0026nbsp; (Part 6, Table 6), encourage the use of the \"single-entry single-exit\" principle as part of the\n\"modular approach\". Unstructured languages, such as assembly, allow jumps between arbitrary points in a program, violating this principle. C++, with\nits concept of functions and the corresponding calling mechanism, enforces the \"single-entry single-exit\" principle through its language definition —\nfor example, multiple return statements within a function all return to the call site.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e the C++ Standard states that aspects of the behaviour associated with these facilities are defined in the related version of\nISO\u0026nbsp;9899\u0026nbsp;.\u003c/p\u003e\n\u003ch3\u003eGlossary\u003c/h3\u003e\n\u003ch4\u003e[1] Header file\u003c/h4\u003e\n\u003cp\u003eA \u003cem\u003eheader file\u003c/em\u003e is considered to be any file that is included during preprocessing (for example via the \u003ccode\u003e#include\u003c/code\u003e directive),\nregardless of its name or suffix.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003e{rule:c:S982} targets the same defect as this rule but for a non-mission-critical context.\u003c/p\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/ktYxBQ\"\u003eCERT, MSC22-C.\u003c/a\u003e - Use the setjmp(), longjmp() facility securely \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/nHs-BQ\"\u003eCERT, ERR52-CPP.\u003c/a\u003e - Do not use setjmp() or longjmp() \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "misra-c++2023",
      "misra-required",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S105",
    "name": "Tabulation characters should not be used",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "FORMATTED",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe tab width can differ from one development environment to another. Using tabs may require other developers to configure their environment (text\neditor, preferences, etc.) to read source code.\u003c/p\u003e\n\u003cp\u003eThat is why using spaces is preferable.\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe tab width can differ from one development environment to another. Using tabs may require other developers to configure their environment (text\neditor, preferences, etc.) to read source code.\u003c/p\u003e\n\u003cp\u003eThat is why using spaces is preferable.\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "convention"
    ],
    "deprecatedKeys": [
      "c:TabCharacter"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S5570",
    "name": "Arguments evaluation order should not be relied on",
    "defaultSeverity": "CRITICAL",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eArguments evaluation order in a function call is not specified:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Before C++17, the evaluation of each argument was unsequenced with the evaluation of other arguments, which can lead to undefined behavior if\n  the same value is modified in several arguments, \u003c/li\u003e\n  \u003cli\u003e After C++17, it is sequenced, but in an unspecified order: the behavior is not longer undefined, but the values passed to the function will be\n  non portable. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eBoth cases should be avoided, because the code will probably not be what was expected.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid f(int i, int j);\n\nvoid g() {\n  int i \u003d 0;\n  f(++i, ++i); // Noncompliant, the call could either be f(1,2) or f(2,1) (since C++17) or undefined behavior (before C++17)\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThis rule does not apply to overloaded operators because they respect the sequencing order rules of the operator they overload (since C++17).\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es44-dont-depend-on-order-of-evaluation-of-function-arguments\"\u003eES.44: Don’t depend on order of evaluation of function arguments\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/eval_order\"\u003ecppreference.com - order of evaluation\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eArguments evaluation order in a function call is not specified:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Before C++17, the evaluation of each argument was unsequenced with the evaluation of other arguments, which can lead to undefined behavior if\n  the same value is modified in several arguments, \u003c/li\u003e\n  \u003cli\u003e After C++17, it is sequenced, but in an unspecified order: the behavior is not longer undefined, but the values passed to the function will be\n  non portable. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eBoth cases should be avoided, because the code will probably not be what was expected.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid f(int i, int j);\n\nvoid g() {\n  int i \u003d 0;\n  f(++i, ++i); // Noncompliant, the call could either be f(1,2) or f(2,1) (since C++17) or undefined behavior (before C++17)\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThis rule does not apply to overloaded operators because they respect the sequencing order rules of the operator they overload (since C++17).\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es44-dont-depend-on-order-of-evaluation-of-function-arguments\"\u003eES.44: Don’t depend on order of evaluation of function arguments\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/eval_order\"\u003ecppreference.com - order of evaluation\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "cppcoreguidelines",
      "lock-in",
      "unpredictable"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S103",
    "name": "Lines should not be too long",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "FORMATTED",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eScrolling horizontally to see a full line of code lowers the code readability.\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eScrolling horizontally to see a full line of code lowers the code readability.\u003c/p\u003e"
      }
    ],
    "params": {
      "maximumLineLength": {
        "key": "maximumLineLength",
        "name": "maximumLineLength",
        "description": "The maximum authorized line length",
        "defaultValue": "80",
        "type": "INTEGER",
        "multiple": false,
        "possibleValues": []
      }
    },
    "defaultParams": {
      "maximumLineLength": "80"
    },
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "convention"
    ],
    "deprecatedKeys": [
      "c:LineLength"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S909",
    "name": "\"continue\" should not be used",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003econtinue\u003c/code\u003e is an unstructured control flow statement. It makes code less testable, less readable and less maintainable. Structured\ncontrol flow statements such as \u003ccode\u003eif\u003c/code\u003e should be used instead.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint i;\nfor (i \u003d 0; i \u0026lt; 10; i++) {\n  if (i \u003d\u003d 5) {\n    continue;  /* Noncompliant */\n  }\n  printf(\"i \u003d %d\\n\", i);\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint i;\nfor (i \u003d 0; i \u0026lt; 10; i++) {\n  if (i !\u003d 5) {\n    printf(\"i \u003d %d\\n\", i);\n  }\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 14.5 - The continue statement shall not be used. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003ccode\u003econtinue\u003c/code\u003e is an unstructured control flow statement. It makes code less testable, less readable and less maintainable. Structured\ncontrol flow statements such as \u003ccode\u003eif\u003c/code\u003e should be used instead.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint i;\nfor (i \u003d 0; i \u0026lt; 10; i++) {\n  if (i \u003d\u003d 5) {\n    continue;  /* Noncompliant */\n  }\n  printf(\"i \u003d %d\\n\", i);\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint i;\nfor (i \u003d 0; i \u0026lt; 10; i++) {\n  if (i !\u003d 5) {\n    printf(\"i \u003d %d\\n\", i);\n  }\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 14.5 - The continue statement shall not be used. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "bad-practice",
      "based-on-misra"
    ],
    "deprecatedKeys": [
      "c:ContinueUsage"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S907",
    "name": "\"goto\" statement should not be used",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003egoto\u003c/code\u003e is an unstructured control flow statement. It makes code less readable and maintainable. Structured control flow statements such\nas \u003ccode\u003eif\u003c/code\u003e, \u003ccode\u003efor\u003c/code\u003e, \u003ccode\u003ewhile\u003c/code\u003e, \u003ccode\u003econtinue\u003c/code\u003e or \u003ccode\u003ebreak\u003c/code\u003e should be used instead.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint i \u003d 0;\nloop:\n  printf(\"i \u003d %d\\n\", i);\n  i++;\n  if (i \u0026lt; 10){\n    goto loop; // Noncompliant\n  }\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nfor (int i \u003d 0; i \u0026lt; 10; i++) {\n  printf(\"i \u003d %d\\n\", i);\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 14.4 - The goto statement shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 15.1 - The goto statement should not be used \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es76-avoid-goto\"\u003eES.76: Avoid\n  \u003ccode\u003egoto\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003ccode\u003egoto\u003c/code\u003e is an unstructured control flow statement. It makes code less readable and maintainable. Structured control flow statements such\nas \u003ccode\u003eif\u003c/code\u003e, \u003ccode\u003efor\u003c/code\u003e, \u003ccode\u003ewhile\u003c/code\u003e, \u003ccode\u003econtinue\u003c/code\u003e or \u003ccode\u003ebreak\u003c/code\u003e should be used instead.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint i \u003d 0;\nloop:\n  printf(\"i \u003d %d\\n\", i);\n  i++;\n  if (i \u0026lt; 10){\n    goto loop; // Noncompliant\n  }\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nfor (int i \u003d 0; i \u0026lt; 10; i++) {\n  printf(\"i \u003d %d\\n\", i);\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 14.4 - The goto statement shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 15.1 - The goto statement should not be used \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es76-avoid-goto\"\u003eES.76: Avoid\n  \u003ccode\u003egoto\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "based-on-misra",
      "brain-overload"
    ],
    "deprecatedKeys": [
      "c:GotoUsage"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:M23_210",
    "name": "The \"#include\" directive shall be followed by either a \"\u003cfilename\u003e\" or  \"\"filename\"\" sequence",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 19.2.2\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eThis rule applies after macro replacement has been performed.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003e\u003cem\u003eUndefined behaviour\u003c/em\u003e occurs if a \u003ccode\u003e#include\u003c/code\u003e directive does not use one of the following forms:\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;filename\u0026gt;\n#include \"filename\"\n\u003c/pre\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;filename.h\u0026gt;         // Compliant\n#include \"filename.h\"         // Compliant\n#include \"./include/cpu.h\"    // Compliant - filename may include a path\n#include another.h            // Non-compliant\n\n#define HEADER \"filename.h\"\n#include HEADER               // Compliant\n#define FILENAME file2.h\n#include FILENAME             // Non-compliant\n\n#define BASE \"base\"\n#define EXT  \".ext\"\n#include BASE EXT             // Non-compliant - expands to an invalid form\n                              //   #include \"base\" \".ext\"\n                              // - string concatenation occurs after preprocessing\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003e{rule:c:S956} targets the same defect as this rule but for a non-mission-critical context.\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 19.2.2\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eThis rule applies after macro replacement has been performed.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003e\u003cem\u003eUndefined behaviour\u003c/em\u003e occurs if a \u003ccode\u003e#include\u003c/code\u003e directive does not use one of the following forms:\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;filename\u0026gt;\n#include \"filename\"\n\u003c/pre\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;filename.h\u0026gt;         // Compliant\n#include \"filename.h\"         // Compliant\n#include \"./include/cpu.h\"    // Compliant - filename may include a path\n#include another.h            // Non-compliant\n\n#define HEADER \"filename.h\"\n#include HEADER               // Compliant\n#define FILENAME file2.h\n#include FILENAME             // Non-compliant\n\n#define BASE \"base\"\n#define EXT  \".ext\"\n#include BASE EXT             // Non-compliant - expands to an invalid form\n                              //   #include \"base\" \".ext\"\n                              // - string concatenation occurs after preprocessing\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003e{rule:c:S956} targets the same defect as this rule but for a non-mission-critical context.\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "convention",
      "misra-c++2023",
      "misra-required"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:M23_331",
    "name": "Functions with \"limited visibility\" should be \"used\" at least once",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 0.2.4\u003c/p\u003e\n\u003cp\u003eCategory: Advisory\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,System\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eA function has \u003cem\u003elimited visibility\u003c/em\u003e if it:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Is declared in an anonymous namespace; or \u003c/li\u003e\n  \u003cli\u003e Is a member of a class in an anonymous namespace; or \u003c/li\u003e\n  \u003cli\u003e Has namespace scope and is declared \u003ccode\u003estatic\u003c/code\u003e; or \u003c/li\u003e\n  \u003cli\u003e Is a \u003ccode\u003eprivate\u003c/code\u003e, non-\u003ccode\u003evirtual\u003c/code\u003e member. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eA function is \u003cem\u003eused\u003c/em\u003e [1] when:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Its address is taken (including by reference); or \u003c/li\u003e\n  \u003cli\u003e It is called; or \u003c/li\u003e\n  \u003cli\u003e It is an operand of an expression in an unevaluated context; or \u003c/li\u003e\n  \u003cli\u003e Another function in the same overload set is \u003cem\u003eused\u003c/em\u003e [1]. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis rule does not apply to:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003cem\u003eSpecial member functions\u003c/em\u003e; \u003c/li\u003e\n  \u003cli\u003e Functions defined as \u003ccode\u003e\u003d delete\u003c/code\u003e. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eFunctions with \u003cem\u003elimited visibility\u003c/em\u003e are not generally used within an extensible API. If they are present but remain unused, then there may\nbe an issue in the software design.\u003c/p\u003e\n\u003cp\u003eUnused functions in an overload set are acceptable as it allows the set to be internally consistent.\u003c/p\u003e\n\u003ch3\u003eException\u003c/h3\u003e\n\u003cp\u003eFunctions that have at least one \u003cem\u003edeclaration\u003c/em\u003e [2] with the \u003ccode\u003e[[maybe_unused]]\u003c/code\u003e attribute are permitted to be unused as the intent\nis explicit.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nstruct Foo\n{\n  int32_t m1()                      // Public - rule does not apply\n  {\n    return -1;\n  }\n\n  static int32_t m2()               // Class scope - rule does not apply\n  {\n    return 42;\n  }\n\n  Foo()\n  {\n    m3();\n  }\n\nprivate:\n  void m3() { }                     // Compliant - called\n  void m4() { }                     // Non-compliant - not used\n  void m5() { }                     // Compliant - used by a friend\n\n  friend void ( *f4() )();\n\nprotected:\n  void m6() { }                     // Protected - rule does not apply\n};\n\nstatic void f1() { }                // Non-compliant - not used\n\nnamespace\n{\n  void f2() { }                     // Non-compliant - not used\n}\n\nstatic void f3() { }                // Compliant - address taken in f4()\n\nvoid ( *f4() )()                    // Rule does not apply - visibility not limited\n{\n  Foo bar;\n\n  bar.m5();\n\n  return \u0026amp;f3;\n}\n\nnamespace A\n{\n  struct C1 {};\n  static void swap( C1 \u0026amp;, C1 \u0026amp; );   // Compliant - overload set for call in f5\n}\n\nnamespace B\n{\n  struct C2 {};\n  static void swap( C2 \u0026amp;, C2 \u0026amp; );   // Non-compliant\n}\n\nnamespace\n{\n  template\u0026lt; typename T \u0026gt;\n  void swap( T \u0026amp;, T \u0026amp; );            // Compliant - overload set for call in f5\n}\n\nvoid f5( A::C1 c1, A::C1 c2 )       // Rule does not apply - visibility not limited\n{\n  swap( c1, c2 );\n}\n\u003c/pre\u003e\n\u003ch3\u003eGlossary\u003c/h3\u003e\n\u003ch4\u003e[1] Use / used / using\u003c/h4\u003e\n\u003cp\u003eAn object is \u003cem\u003eused\u003c/em\u003e if:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e It is the subject of a cast; or \u003c/li\u003e\n  \u003cli\u003e It is explicitly initialized at declaration time; or \u003c/li\u003e\n  \u003cli\u003e It is an operand in an expression; or \u003c/li\u003e\n  \u003cli\u003e It is referenced. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eA function is \u003cem\u003eused\u003c/em\u003e as defined in {rule:c:M23_331}: MISRA C++ 2023 Rule\u0026nbsp;0.2.4.\u003c/p\u003e\n\u003cp\u003eA type is \u003cem\u003eused\u003c/em\u003e as defined in MISRA C++ 2023 Rule\u0026nbsp;0.2.3 (Types with \u003cem\u003elimited visibility\u003c/em\u003e should be \u003cem\u003eused\u003c/em\u003e at least\nonce).\u003c/p\u003e\n\u003ch4\u003e[2] Declaration\u003c/h4\u003e\n\u003cp\u003eA \u003cem\u003edeclaration\u003c/em\u003e introduces the name of an \u003cem\u003eentity\u003c/em\u003e into a \u003cem\u003etranslation unit\u003c/em\u003e (see [basic.def]/1).\u003c/p\u003e\n\u003cp\u003eAn \u003cem\u003eentity\u003c/em\u003e may be \u003cem\u003edeclared\u003c/em\u003e several times. The first \u003cem\u003edeclaration\u003c/em\u003e of an \u003cem\u003eentity\u003c/em\u003e in a \u003cem\u003etranslation unit\u003c/em\u003e is\ncalled an \u003cem\u003eintroduction\u003c/em\u003e [3]. All subsequent \u003cem\u003edeclarations\u003c/em\u003e are called \u003cem\u003eredeclarations\u003c/em\u003e [4].\u003c/p\u003e\n\u003cp\u003eA \u003cem\u003edefinition\u003c/em\u003e [5] is a \u003cem\u003edeclaration\u003c/em\u003e, as described in [basic.def]/2.\u003c/p\u003e\n\u003ch4\u003e[3] Introduction\u003c/h4\u003e\n\u003cp\u003eSee \u003cem\u003edeclaration\u003c/em\u003e [2].\u003c/p\u003e\n\u003ch4\u003e[4] Redeclaration\u003c/h4\u003e\n\u003cp\u003eSee \u003cem\u003edeclaration\u003c/em\u003e [2].\u003c/p\u003e\n\u003ch4\u003e[5] Definition\u003c/h4\u003e\n\u003cp\u003eSee \u003cem\u003edeclaration\u003c/em\u003e [2].\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003e{rule:c:S1144} targets the same defect as this rule but for a non-mission-critical context.\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 0.2.4\u003c/p\u003e\n\u003cp\u003eCategory: Advisory\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,System\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eA function has \u003cem\u003elimited visibility\u003c/em\u003e if it:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Is declared in an anonymous namespace; or \u003c/li\u003e\n  \u003cli\u003e Is a member of a class in an anonymous namespace; or \u003c/li\u003e\n  \u003cli\u003e Has namespace scope and is declared \u003ccode\u003estatic\u003c/code\u003e; or \u003c/li\u003e\n  \u003cli\u003e Is a \u003ccode\u003eprivate\u003c/code\u003e, non-\u003ccode\u003evirtual\u003c/code\u003e member. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eA function is \u003cem\u003eused\u003c/em\u003e [1] when:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Its address is taken (including by reference); or \u003c/li\u003e\n  \u003cli\u003e It is called; or \u003c/li\u003e\n  \u003cli\u003e It is an operand of an expression in an unevaluated context; or \u003c/li\u003e\n  \u003cli\u003e Another function in the same overload set is \u003cem\u003eused\u003c/em\u003e [1]. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis rule does not apply to:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003cem\u003eSpecial member functions\u003c/em\u003e; \u003c/li\u003e\n  \u003cli\u003e Functions defined as \u003ccode\u003e\u003d delete\u003c/code\u003e. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eFunctions with \u003cem\u003elimited visibility\u003c/em\u003e are not generally used within an extensible API. If they are present but remain unused, then there may\nbe an issue in the software design.\u003c/p\u003e\n\u003cp\u003eUnused functions in an overload set are acceptable as it allows the set to be internally consistent.\u003c/p\u003e\n\u003ch3\u003eException\u003c/h3\u003e\n\u003cp\u003eFunctions that have at least one \u003cem\u003edeclaration\u003c/em\u003e [2] with the \u003ccode\u003e[[maybe_unused]]\u003c/code\u003e attribute are permitted to be unused as the intent\nis explicit.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nstruct Foo\n{\n  int32_t m1()                      // Public - rule does not apply\n  {\n    return -1;\n  }\n\n  static int32_t m2()               // Class scope - rule does not apply\n  {\n    return 42;\n  }\n\n  Foo()\n  {\n    m3();\n  }\n\nprivate:\n  void m3() { }                     // Compliant - called\n  void m4() { }                     // Non-compliant - not used\n  void m5() { }                     // Compliant - used by a friend\n\n  friend void ( *f4() )();\n\nprotected:\n  void m6() { }                     // Protected - rule does not apply\n};\n\nstatic void f1() { }                // Non-compliant - not used\n\nnamespace\n{\n  void f2() { }                     // Non-compliant - not used\n}\n\nstatic void f3() { }                // Compliant - address taken in f4()\n\nvoid ( *f4() )()                    // Rule does not apply - visibility not limited\n{\n  Foo bar;\n\n  bar.m5();\n\n  return \u0026amp;f3;\n}\n\nnamespace A\n{\n  struct C1 {};\n  static void swap( C1 \u0026amp;, C1 \u0026amp; );   // Compliant - overload set for call in f5\n}\n\nnamespace B\n{\n  struct C2 {};\n  static void swap( C2 \u0026amp;, C2 \u0026amp; );   // Non-compliant\n}\n\nnamespace\n{\n  template\u0026lt; typename T \u0026gt;\n  void swap( T \u0026amp;, T \u0026amp; );            // Compliant - overload set for call in f5\n}\n\nvoid f5( A::C1 c1, A::C1 c2 )       // Rule does not apply - visibility not limited\n{\n  swap( c1, c2 );\n}\n\u003c/pre\u003e\n\u003ch3\u003eGlossary\u003c/h3\u003e\n\u003ch4\u003e[1] Use / used / using\u003c/h4\u003e\n\u003cp\u003eAn object is \u003cem\u003eused\u003c/em\u003e if:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e It is the subject of a cast; or \u003c/li\u003e\n  \u003cli\u003e It is explicitly initialized at declaration time; or \u003c/li\u003e\n  \u003cli\u003e It is an operand in an expression; or \u003c/li\u003e\n  \u003cli\u003e It is referenced. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eA function is \u003cem\u003eused\u003c/em\u003e as defined in {rule:c:M23_331}: MISRA C++ 2023 Rule\u0026nbsp;0.2.4.\u003c/p\u003e\n\u003cp\u003eA type is \u003cem\u003eused\u003c/em\u003e as defined in MISRA C++ 2023 Rule\u0026nbsp;0.2.3 (Types with \u003cem\u003elimited visibility\u003c/em\u003e should be \u003cem\u003eused\u003c/em\u003e at least\nonce).\u003c/p\u003e\n\u003ch4\u003e[2] Declaration\u003c/h4\u003e\n\u003cp\u003eA \u003cem\u003edeclaration\u003c/em\u003e introduces the name of an \u003cem\u003eentity\u003c/em\u003e into a \u003cem\u003etranslation unit\u003c/em\u003e (see [basic.def]/1).\u003c/p\u003e\n\u003cp\u003eAn \u003cem\u003eentity\u003c/em\u003e may be \u003cem\u003edeclared\u003c/em\u003e several times. The first \u003cem\u003edeclaration\u003c/em\u003e of an \u003cem\u003eentity\u003c/em\u003e in a \u003cem\u003etranslation unit\u003c/em\u003e is\ncalled an \u003cem\u003eintroduction\u003c/em\u003e [3]. All subsequent \u003cem\u003edeclarations\u003c/em\u003e are called \u003cem\u003eredeclarations\u003c/em\u003e [4].\u003c/p\u003e\n\u003cp\u003eA \u003cem\u003edefinition\u003c/em\u003e [5] is a \u003cem\u003edeclaration\u003c/em\u003e, as described in [basic.def]/2.\u003c/p\u003e\n\u003ch4\u003e[3] Introduction\u003c/h4\u003e\n\u003cp\u003eSee \u003cem\u003edeclaration\u003c/em\u003e [2].\u003c/p\u003e\n\u003ch4\u003e[4] Redeclaration\u003c/h4\u003e\n\u003cp\u003eSee \u003cem\u003edeclaration\u003c/em\u003e [2].\u003c/p\u003e\n\u003ch4\u003e[5] Definition\u003c/h4\u003e\n\u003cp\u003eSee \u003cem\u003edeclaration\u003c/em\u003e [2].\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003e{rule:c:S1144} targets the same defect as this rule but for a non-mission-critical context.\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "misra-advisory",
      "misra-c++2023",
      "unused"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S905",
    "name": "Non-empty statements should change control flow or have at least one side-effect",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003cp\u003eStatements with no side effects and no change of control flow do not contribute to the functionality of the code and can indicate a programming\nerror.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhen writing code, it is important to ensure that each statement serves a purpose and contributes to the overall functionality of the program. When\nthey have no side effects or do not change the control flow, they can either indicate a programming error or be redundant:\u003c/p\u003e\n\u003col\u003e\n  \u003cli\u003e The code does not behave as intended: The statements are expected to have an effect but they do not. This can be caused by mistyping,\n  copy-and-paste errors, etc. \u003c/li\u003e\n  \u003cli\u003e The statements are residual after a refactoring. \u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThe rule does not raise an issue on statements containing only a semicolon (\u003ccode\u003e;\u003c/code\u003e).\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eIdentify statements that do not contribute to the functionality of the code and verify if they are intended to be part of the logic. If they are,\nthere is a bug to be fixed. If they are not, then they are redundant and should be removed.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nint add(int a, int b) {\n  int result \u003d 0;\n  a + b; // Noncompliant: no side effect, hides a bug, the developer likely accidentally duplicated the line\n  return result;\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\nint mul(int a, int b) {\n  int result \u003d 1;\n  result \u003d\u003d a; // Noncompliant: no side effect, hides a bug, the developer intended to assign\n  result *\u003d b;\n  return result;\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"noncompliant\"\u003e\nint sub(int a, int b) {\n  int result \u003d a - b;\n  a - b; // Noncompliant: no side effect, there is no underlying bug, but the statement is useless\n  return result;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nint add(int a, int b) {\n  int result \u003d a + b;\n  return result;\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\nint mul(int a, int b) {\n  int result \u003d 1;\n  result \u003d a;\n  result *\u003d b;\n  return result;\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"compliant\"\u003e\nint sub(int a, int b) {\n  int result \u003d a - b;\n  return result;\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/482\"\u003e482 Comparing instead of Assigning\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/5dUxBQ\"\u003eMSC12-C. Detect and remove code that has no effect or is never executed\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 14.2 - All non-null statements shall either have at least one side-effect however executed or cause control flow to change. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:c:S1116} - Empty statements should be removed \u003c/li\u003e\n  \u003cli\u003e {rule:c:S1854} - Unused assignments should be removed \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eStatements with no side effects and no change of control flow do not contribute to the functionality of the code and can indicate a programming\nerror.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhen writing code, it is important to ensure that each statement serves a purpose and contributes to the overall functionality of the program. When\nthey have no side effects or do not change the control flow, they can either indicate a programming error or be redundant:\u003c/p\u003e\n\u003col\u003e\n  \u003cli\u003e The code does not behave as intended: The statements are expected to have an effect but they do not. This can be caused by mistyping,\n  copy-and-paste errors, etc. \u003c/li\u003e\n  \u003cli\u003e The statements are residual after a refactoring. \u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThe rule does not raise an issue on statements containing only a semicolon (\u003ccode\u003e;\u003c/code\u003e).\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eIdentify statements that do not contribute to the functionality of the code and verify if they are intended to be part of the logic. If they are,\nthere is a bug to be fixed. If they are not, then they are redundant and should be removed.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nint add(int a, int b) {\n  int result \u003d 0;\n  a + b; // Noncompliant: no side effect, hides a bug, the developer likely accidentally duplicated the line\n  return result;\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\nint mul(int a, int b) {\n  int result \u003d 1;\n  result \u003d\u003d a; // Noncompliant: no side effect, hides a bug, the developer intended to assign\n  result *\u003d b;\n  return result;\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"noncompliant\"\u003e\nint sub(int a, int b) {\n  int result \u003d a - b;\n  a - b; // Noncompliant: no side effect, there is no underlying bug, but the statement is useless\n  return result;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nint add(int a, int b) {\n  int result \u003d a + b;\n  return result;\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\nint mul(int a, int b) {\n  int result \u003d 1;\n  result \u003d a;\n  result *\u003d b;\n  return result;\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"compliant\"\u003e\nint sub(int a, int b) {\n  int result \u003d a - b;\n  return result;\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/482\"\u003e482 Comparing instead of Assigning\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/5dUxBQ\"\u003eMSC12-C. Detect and remove code that has no effect or is never executed\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 14.2 - All non-null statements shall either have at least one side-effect however executed or cause control flow to change. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:c:S1116} - Empty statements should be removed \u003c/li\u003e\n  \u003cli\u003e {rule:c:S1854} - Unused assignments should be removed \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "based-on-misra",
      "cwe",
      "unused"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:M23_212",
    "name": "The \"#\" and \"##\" preprocessor operators should not be used",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 19.3.1\u003c/p\u003e\n\u003cp\u003eCategory: Advisory\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eThe order of evaluation associated with multiple \u003ccode\u003e#\u003c/code\u003e, multiple \u003ccode\u003e##\u003c/code\u003e or a mix of \u003ccode\u003e#\u003c/code\u003e and \u003ccode\u003e##\u003c/code\u003e\npreprocessor operators is unspecified. It is therefore not always possible to predict the result of macro expansion.\u003c/p\u003e\n\u003cp\u003eThe use of the \u003ccode\u003e##\u003c/code\u003e operator can result in code that is hard to understand.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e MISRA C++ 2023 Rule\u0026nbsp;4.1.3 (There shall be no occurrence of \u003cem\u003eundefined\u003c/em\u003e or \u003cem\u003ecritical unspecified\nbehaviour\u003c/em\u003e) covers the \u003cem\u003eundefined behaviour\u003c/em\u003e that arises if either:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The result of a \u003ccode\u003e#\u003c/code\u003e operator is not a valid string literal; or \u003c/li\u003e\n  \u003cli\u003e The result of a \u003ccode\u003e##\u003c/code\u003e operator is not a valid preprocessing token. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:c:S968} targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2023 Rule\u0026nbsp;4.1.3 - There shall be no occurrence of \u003cem\u003eundefined\u003c/em\u003e or \u003cem\u003ecritical unspecified behaviour\u003c/em\u003e \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2023 Rule\u0026nbsp;19.3.2 - A macro parameter immediately following a \u003ccode\u003e#\u003c/code\u003e operator shall not be immediately followed by a\n  \u003ccode\u003e##\u003c/code\u003e operator \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2023 Rule\u0026nbsp;19.3.3 - The argument to a \u003cem\u003emixed-use macro parameter\u003c/em\u003e shall not be subject to further expansion \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 19.3.1\u003c/p\u003e\n\u003cp\u003eCategory: Advisory\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eThe order of evaluation associated with multiple \u003ccode\u003e#\u003c/code\u003e, multiple \u003ccode\u003e##\u003c/code\u003e or a mix of \u003ccode\u003e#\u003c/code\u003e and \u003ccode\u003e##\u003c/code\u003e\npreprocessor operators is unspecified. It is therefore not always possible to predict the result of macro expansion.\u003c/p\u003e\n\u003cp\u003eThe use of the \u003ccode\u003e##\u003c/code\u003e operator can result in code that is hard to understand.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e MISRA C++ 2023 Rule\u0026nbsp;4.1.3 (There shall be no occurrence of \u003cem\u003eundefined\u003c/em\u003e or \u003cem\u003ecritical unspecified\nbehaviour\u003c/em\u003e) covers the \u003cem\u003eundefined behaviour\u003c/em\u003e that arises if either:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The result of a \u003ccode\u003e#\u003c/code\u003e operator is not a valid string literal; or \u003c/li\u003e\n  \u003cli\u003e The result of a \u003ccode\u003e##\u003c/code\u003e operator is not a valid preprocessing token. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:c:S968} targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2023 Rule\u0026nbsp;4.1.3 - There shall be no occurrence of \u003cem\u003eundefined\u003c/em\u003e or \u003cem\u003ecritical unspecified behaviour\u003c/em\u003e \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2023 Rule\u0026nbsp;19.3.2 - A macro parameter immediately following a \u003ccode\u003e#\u003c/code\u003e operator shall not be immediately followed by a\n  \u003ccode\u003e##\u003c/code\u003e operator \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2023 Rule\u0026nbsp;19.3.3 - The argument to a \u003cem\u003emixed-use macro parameter\u003c/em\u003e shall not be subject to further expansion \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "lock-in",
      "misra-advisory",
      "misra-c++2023"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S1656",
    "name": "Variables should not be self-assigned",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThere is no reason to re-assign a variable to itself. Either this statement is redundant and should be removed, or the re-assignment is a mistake\nand some other value or variable was intended for the assignment instead.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid setValue(int value) {\n  value \u003d value;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid setValue(int value) {\n  this-\u0026gt;value \u003d value;\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/5dUxBQ\"\u003eCERT, MSC12-C.\u003c/a\u003e - Detect and remove code that has no effect or is never executed\n  \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThere is no reason to re-assign a variable to itself. Either this statement is redundant and should be removed, or the re-assignment is a mistake\nand some other value or variable was intended for the assignment instead.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid setValue(int value) {\n  value \u003d value;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid setValue(int value) {\n  this-\u0026gt;value \u003d value;\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/5dUxBQ\"\u003eCERT, MSC12-C.\u003c/a\u003e - Detect and remove code that has no effect or is never executed\n  \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "cert"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S3715",
    "name": "GNU extensions should not be used",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eProprietary compiler extensions can be handy, but they commit you to always using that compiler. This rule raises an issue when GNU extensions are\nused, such as:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Ternary operator with omitted second operand \u003c/li\u003e\n  \u003cli\u003e Case ranges in switch statements \u003c/li\u003e\n  \u003cli\u003e Expression statements, i.e. code blocks producing value \u003c/li\u003e\n  \u003cli\u003e Index range in array initializers \u003c/li\u003e\n  \u003cli\u003e A array initializer without \u003ccode\u003e\u003d\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e A structure member initializer with a colon \u003c/li\u003e\n  \u003cli\u003e Decimal floating points numbers \u003ccode\u003e_Decimal32\u003c/code\u003e, \u003ccode\u003e_Decimal64\u003c/code\u003e, and \u003ccode\u003e_Decimal128\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e Structures and union without named data members \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstruct S {\n  int f;\n};\n\nstruct S s[] \u003d {\n  [0] { // Noncompliant\n    f : 0 // Noncompliant\n  }\n  [1 ... 3] \u003d { // CHECK :8 :11 S3715:use of GNU array range extension\n    .f \u003d 2\n  }\n};\n\nint fun(int p) {\n  switch (p) {\n    case 0 ... 1: // Noncompliant\n      do_the_thing();\n      break;\n    case 2:\n      //...\n  }\n\n  p \u003d ({ // Noncompliant\n    int a \u003d 10, b \u003d 20;\n    (a * b) + 10;\n  });\n\n  return p ?: 0; // Noncompliant\n}\n\n_Decimal32 d32; // Noncompliant\n\nstruct Empty {}; // Noncompliant in C\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstruct S {\n  int f;\n};\n\nstruct S s[] \u003d {\n  [0] \u003d {\n    .f \u003d 0\n  },\n  [1] \u003d {\n    .f \u003d 2\n  }\n  [2] \u003d {\n    .f \u003d 2\n  },\n  [3] \u003d {\n    .f \u003d 2\n  }\n\n};\n\nint fun(int p) {\n  switch (p) {\n    case 0:\n    case 1:\n      do_the_thing();\n      break;\n    case 2:\n      //...\n  }\n\n  int a \u003d 10, b \u003d 20;\n  p \u003d (a * b) + 10;\n\n  return p ? p: 0;\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eProprietary compiler extensions can be handy, but they commit you to always using that compiler. This rule raises an issue when GNU extensions are\nused, such as:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Ternary operator with omitted second operand \u003c/li\u003e\n  \u003cli\u003e Case ranges in switch statements \u003c/li\u003e\n  \u003cli\u003e Expression statements, i.e. code blocks producing value \u003c/li\u003e\n  \u003cli\u003e Index range in array initializers \u003c/li\u003e\n  \u003cli\u003e A array initializer without \u003ccode\u003e\u003d\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e A structure member initializer with a colon \u003c/li\u003e\n  \u003cli\u003e Decimal floating points numbers \u003ccode\u003e_Decimal32\u003c/code\u003e, \u003ccode\u003e_Decimal64\u003c/code\u003e, and \u003ccode\u003e_Decimal128\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e Structures and union without named data members \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstruct S {\n  int f;\n};\n\nstruct S s[] \u003d {\n  [0] { // Noncompliant\n    f : 0 // Noncompliant\n  }\n  [1 ... 3] \u003d { // CHECK :8 :11 S3715:use of GNU array range extension\n    .f \u003d 2\n  }\n};\n\nint fun(int p) {\n  switch (p) {\n    case 0 ... 1: // Noncompliant\n      do_the_thing();\n      break;\n    case 2:\n      //...\n  }\n\n  p \u003d ({ // Noncompliant\n    int a \u003d 10, b \u003d 20;\n    (a * b) + 10;\n  });\n\n  return p ?: 0; // Noncompliant\n}\n\n_Decimal32 d32; // Noncompliant\n\nstruct Empty {}; // Noncompliant in C\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstruct S {\n  int f;\n};\n\nstruct S s[] \u003d {\n  [0] \u003d {\n    .f \u003d 0\n  },\n  [1] \u003d {\n    .f \u003d 2\n  }\n  [2] \u003d {\n    .f \u003d 2\n  },\n  [3] \u003d {\n    .f \u003d 2\n  }\n\n};\n\nint fun(int p) {\n  switch (p) {\n    case 0:\n    case 1:\n      do_the_thing();\n      break;\n    case 2:\n      //...\n  }\n\n  int a \u003d 10, b \u003d 20;\n  p \u003d (a * b) + 10;\n\n  return p ? p: 0;\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "gnu",
      "lock-in",
      "obsolete"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S1659",
    "name": "Multiple variables should not be declared on the same line",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "FORMATTED",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eDeclaring multiple variables or members on the same line hinders readability. Moreover, as soon as they contain references, pointers, or\nassignments, they become confusing for maintainers.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when a declaration declares multiple variables or members.\u003c/p\u003e\n\u003cpre\u003e\nint i1, j1; // Noncompliant\nint i2, *j2; // Noncompliant\nint *i3,\n    \u0026amp;j3 \u003d i2; // Noncompliant\n\u003c/pre\u003e\n\u003cp\u003eGiving each declaration its own line makes the code more maintainable.\u003c/p\u003e\n\u003cpre\u003e\nint i1;\nint j1;\nint i2;\nint *j2;\nint *i3;\nint \u0026amp;j3 \u003d i2;\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/EtcxBQ\"\u003eCERT, DCL04-C.\u003c/a\u003e - Do not declare more than one variable per declaration \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 8-0-1 - An init-declarator-list or a member-declarator-list shall consist of a single init-declarator or member-declarator\n  respectively \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es10-declare-one-name-only-per-declaration\"\u003eES.10: Declare one\n  name (only) per declaration\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eDeclaring multiple variables or members on the same line hinders readability. Moreover, as soon as they contain references, pointers, or\nassignments, they become confusing for maintainers.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when a declaration declares multiple variables or members.\u003c/p\u003e\n\u003cpre\u003e\nint i1, j1; // Noncompliant\nint i2, *j2; // Noncompliant\nint *i3,\n    \u0026amp;j3 \u003d i2; // Noncompliant\n\u003c/pre\u003e\n\u003cp\u003eGiving each declaration its own line makes the code more maintainable.\u003c/p\u003e\n\u003cpre\u003e\nint i1;\nint j1;\nint i2;\nint *j2;\nint *i3;\nint \u0026amp;j3 \u003d i2;\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/EtcxBQ\"\u003eCERT, DCL04-C.\u003c/a\u003e - Do not declare more than one variable per declaration \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 8-0-1 - An init-declarator-list or a member-declarator-list shall consist of a single init-declarator or member-declarator\n  respectively \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es10-declare-one-name-only-per-declaration\"\u003eES.10: Declare one\n  name (only) per declaration\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "based-on-misra",
      "cert",
      "convention"
    ],
    "deprecatedKeys": [
      "c:SingleDeclarationPerStatement"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S2068",
    "name": "Hard-coded credentials are security-sensitive",
    "defaultSeverity": "BLOCKER",
    "type": "SECURITY_HOTSPOT",
    "cleanCodeAttribute": "TRUSTWORTHY",
    "defaultImpacts": {
      "SECURITY": "HIGH"
    },
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eBecause it is easy to extract strings from an application source code or binary, credentials should not be hard-coded. This is particularly true\nfor applications that are distributed or that are open-source.\u003c/p\u003e\n\u003cp\u003eIn the past, it has led to the following vulnerabilities:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"http://cve.mitre.org/cgi-bin/cvename.cgi?name\u003dCVE-2019-13466\"\u003eCVE-2019-13466\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"http://cve.mitre.org/cgi-bin/cvename.cgi?name\u003dCVE-2018-15389\"\u003eCVE-2018-15389\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eCredentials should be stored outside of the code in a configuration file, a database, or a management service for secrets.\u003c/p\u003e\n\u003cp\u003eThis rule looks for hard-coded credentials in variable names that match any of the patterns from the provided list.\u003c/p\u003e"
      },
      {
        "key": "assess_the_problem",
        "htmlContent": "\u003ch2\u003eAsk Yourself Whether\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e Credentials allow access to a sensitive component like a database, a file storage, an API or a service. \u003c/li\u003e\n  \u003cli\u003e Credentials are used in production environments. \u003c/li\u003e\n  \u003cli\u003e Application re-distribution is required before updating the credentials. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere is a risk if you answered yes to any of those questions.\u003c/p\u003e\n\u003ch2\u003eSensitive Code Example\u003c/h2\u003e\n\u003cpre\u003e\ndbi_conn conn \u003d dbi_conn_new(\"mysql\");\nstring password \u003d \"secret\"; // Sensitive\ndbi_conn_set_option(conn, \"password\", password.c_str());\n\u003c/pre\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003ch2\u003eRecommended Secure Coding Practices\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e Store the credentials in a configuration file that is not pushed to the code repository. \u003c/li\u003e\n  \u003cli\u003e Store the credentials in a database. \u003c/li\u003e\n  \u003cli\u003e Use your cloud provider’s service for managing secrets. \u003c/li\u003e\n  \u003cli\u003e If a password has been disclosed through the source code: change it. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eCompliant Solution\u003c/h2\u003e\n\u003cpre\u003e\ndbi_conn conn \u003d dbi_conn_new(\"mysql\");\nstring password \u003d getDatabasePassword(); // Compliant\ndbi_conn_set_option(conn, \"password\", password.c_str()); // Compliant\n\u003c/pre\u003e\n\u003ch2\u003eSee\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures/\"\u003eOWASP Top 10 2021 Category A7\u003c/a\u003e - Identification and\n  Authentication Failures \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/www-project-top-ten/2017/A2_2017-Broken_Authentication\"\u003eOWASP Top 10 2017 Category A2\u003c/a\u003e - Broken Authentication\n  \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/798\"\u003eMITRE, CWE-798\u003c/a\u003e - Use of Hard-coded Credentials \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/259\"\u003eMITRE, CWE-259\u003c/a\u003e - Use of Hard-coded Password \u003c/li\u003e\n  \u003cli\u003e Derived from FindSecBugs rule \u003ca href\u003d\"https://h3xstream.github.io/find-sec-bugs/bugs.htm#HARD_CODE_PASSWORD\"\u003eHard Coded Password\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "cert",
      "cwe"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": [],
    "vulnerabilityProbability": "HIGH"
  },
  {
    "key": "c:S5332",
    "name": "Using clear-text protocols is security-sensitive",
    "defaultSeverity": "CRITICAL",
    "type": "SECURITY_HOTSPOT",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "SECURITY": "HIGH"
    },
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eClear-text protocols such as \u003ccode\u003eftp\u003c/code\u003e, \u003ccode\u003etelnet\u003c/code\u003e, or \u003ccode\u003ehttp\u003c/code\u003e lack encryption of transported data, as well as the\ncapability to build an authenticated connection. It means that an attacker able to sniff traffic from the network can read, modify, or corrupt the\ntransported content. These protocols are not secure as they expose applications to an extensive range of risks:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e sensitive data exposure \u003c/li\u003e\n  \u003cli\u003e traffic redirected to a malicious endpoint \u003c/li\u003e\n  \u003cli\u003e malware-infected software update or installer \u003c/li\u003e\n  \u003cli\u003e execution of client-side code \u003c/li\u003e\n  \u003cli\u003e corruption of critical information \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eEven in the context of isolated networks like offline environments or segmented cloud environments, the insider threat exists. Thus, attacks\ninvolving communications being sniffed or tampered with can still happen.\u003c/p\u003e\n\u003cp\u003eFor example, attackers could successfully compromise prior security layers by:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e bypassing isolation mechanisms \u003c/li\u003e\n  \u003cli\u003e compromising a component of the network \u003c/li\u003e\n  \u003cli\u003e getting the credentials of an internal IAM account (either from a service account or an actual person) \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn such cases, encrypting communications would decrease the chances of attackers to successfully leak data or steal credentials from other network\ncomponents. By layering various security practices (segmentation and encryption, for example), the application will follow the\n\u003cem\u003edefense-in-depth\u003c/em\u003e principle.\u003c/p\u003e\n\u003cp\u003eNote that using the \u003ccode\u003ehttp\u003c/code\u003e protocol is being deprecated by \u003ca\nhref\u003d\"https://blog.mozilla.org/security/2015/04/30/deprecating-non-secure-http\"\u003emajor web browsers\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eIn the past, it has led to the following vulnerabilities:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://nvd.nist.gov/vuln/detail/CVE-2019-6169\"\u003eCVE-2019-6169\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://nvd.nist.gov/vuln/detail/CVE-2019-12327\"\u003eCVE-2019-12327\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://nvd.nist.gov/vuln/detail/CVE-2019-11065\"\u003eCVE-2019-11065\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eExceptions\u003c/h2\u003e\n\u003cp\u003eNo issue is reported for the following cases because they are not considered sensitive:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Insecure protocol scheme followed by loopback addresses like 127.0.0.1 or \u003ccode\u003elocalhost\u003c/code\u003e. \u003c/li\u003e\n\u003c/ul\u003e"
      },
      {
        "key": "assess_the_problem",
        "htmlContent": "\u003ch2\u003eAsk Yourself Whether\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e Application data needs to be protected against falsifications or leaks when transiting over the network. \u003c/li\u003e\n  \u003cli\u003e Application data transits over an untrusted network. \u003c/li\u003e\n  \u003cli\u003e Compliance rules require the service to encrypt data in transit. \u003c/li\u003e\n  \u003cli\u003e Your application renders web pages with a relaxed mixed content policy. \u003c/li\u003e\n  \u003cli\u003e OS-level protections against clear-text traffic are deactivated. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere is a risk if you answered yes to any of those questions.\u003c/p\u003e\n\u003ch2\u003eSensitive Code Example\u003c/h2\u003e\n\u003cpre\u003e\nchar* http_url \u003d \"http://example.com\"; // Sensitive\nchar* ftp_url \u003d \"ftp://anonymous@example.com\"; // Sensitive\nchar* telnet_url \u003d \"telnet://anonymous@example.com\"; // Sensitive\n\u003c/pre\u003e\n\u003cpre\u003e\n#include \u0026lt;curl/curl.h\u0026gt;\n\nCURL *curl_ftp \u003d curl_easy_init();\ncurl_easy_setopt(curl_ftp, CURLOPT_URL, \"ftp://example.com/\"); // Sensitive\n\nCURL *curl_smtp \u003d curl_easy_init();\ncurl_easy_setopt(curl_smtp, CURLOPT_URL, \"smtp://example.com:587\"); // Sensitive\n\u003c/pre\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003ch2\u003eRecommended Secure Coding Practices\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e Make application data transit over a secure, authenticated and encrypted protocol like TLS or SSH. Here are a few alternatives to the most\n  common clear-text protocols:\n    \u003cul\u003e\n      \u003cli\u003e Use \u003ccode\u003essh\u003c/code\u003e as an alternative to \u003ccode\u003etelnet\u003c/code\u003e. \u003c/li\u003e\n      \u003cli\u003e Use \u003ccode\u003esftp\u003c/code\u003e, \u003ccode\u003escp\u003c/code\u003e, or \u003ccode\u003eftps\u003c/code\u003e instead of \u003ccode\u003eftp\u003c/code\u003e. \u003c/li\u003e\n      \u003cli\u003e Use \u003ccode\u003ehttps\u003c/code\u003e instead of \u003ccode\u003ehttp\u003c/code\u003e. \u003c/li\u003e\n      \u003cli\u003e Use \u003ccode\u003eSMTP\u003c/code\u003e over \u003ccode\u003eSSL/TLS\u003c/code\u003e or \u003ccode\u003eSMTP\u003c/code\u003e with \u003ccode\u003eSTARTTLS\u003c/code\u003e instead of clear-text SMTP. \u003c/li\u003e\n    \u003c/ul\u003e  \u003c/li\u003e\n  \u003cli\u003e Enable encryption of cloud components communications whenever it is possible. \u003c/li\u003e\n  \u003cli\u003e Configure your application to block mixed content when rendering web pages. \u003c/li\u003e\n  \u003cli\u003e If available, enforce OS-level deactivation of all clear-text traffic. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIt is recommended to secure all transport channels, even on local networks, as it can take a single non-secure connection to compromise an entire\napplication or system.\u003c/p\u003e\n\u003ch2\u003eCompliant Solution\u003c/h2\u003e\n\u003cpre\u003e\nchar* https_url \u003d \"https://example.com\";\nchar* sftp_url \u003d \"sftp://anonymous@example.com\";\nchar* ssh_url \u003d \"ssh://anonymous@example.com\";\n\u003c/pre\u003e\n\u003cpre\u003e\n#include \u0026lt;curl/curl.h\u0026gt;\n\nCURL *curl_ftps \u003d curl_easy_init();\ncurl_easy_setopt(curl_ftps, CURLOPT_URL, \"ftp://example.com/\");\ncurl_easy_setopt(curl_ftps, CURLOPT_USE_SSL, CURLUSESSL_ALL); // FTP transport is done over TLS\n\nCURL *curl_smtp_tls \u003d curl_easy_init();\ncurl_easy_setopt(curl_smtp_tls, CURLOPT_URL, \"smtp://example.com:587\");\ncurl_easy_setopt(curl_smtp_tls, CURLOPT_USE_SSL, CURLUSESSL_ALL); // SMTP with STARTTLS\n\u003c/pre\u003e\n\u003ch2\u003eSee\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/Top10/A02_2021-Cryptographic_Failures/\"\u003eOWASP Top 10 2021 Category A2\u003c/a\u003e - Cryptographic Failures \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://www.owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\"\u003eOWASP Top 10 2017 Category A3\u003c/a\u003e - Sensitive Data\n  Exposure \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://mobile-security.gitbook.io/masvs/security-requirements/0x10-v5-network_communication_requirements\"\u003eMobile AppSec Verification\n  Standard\u003c/a\u003e - Network Communication Requirements \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/www-project-mobile-top-10/2016-risks/m3-insecure-communication\"\u003eOWASP Mobile Top 10 2016 Category M3\u003c/a\u003e - Insecure\n  Communication \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/200\"\u003eMITRE, CWE-200\u003c/a\u003e - Exposure of Sensitive Information to an Unauthorized Actor \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/319\"\u003eMITRE, CWE-319\u003c/a\u003e - Cleartext Transmission of Sensitive Information \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://security.googleblog.com/2016/09/moving-towards-more-secure-web.html\"\u003eGoogle, Moving towards more secure web\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://blog.mozilla.org/security/2015/04/30/deprecating-non-secure-http/\"\u003eMozilla, Deprecating non secure http\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://docs.aws.amazon.com/elasticloadbalancing/latest/application/load-balancer-listeners.html\"\u003eAWS Documentation\u003c/a\u003e - Listeners\n  for your Application Load Balancers \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesis-stream-streamencryption.html\"\u003eAWS\n  Documentation\u003c/a\u003e - Stream Encryption \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "cwe",
      "symbolic-execution"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": [],
    "vulnerabilityProbability": "LOW"
  },
  {
    "key": "c:S1772",
    "name": "Constants should come first in equality tests",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe result of the comparison is the same, regardless of whether the constant is on the left or right-hand side. But following this convention will\nhelp pinpoint the occasional error where \u003ccode\u003e\u003d\u003c/code\u003e (assignment) is substituted for \u003ccode\u003e\u003d\u003d\u003c/code\u003e (comparison).\u003c/p\u003e\n\u003cp\u003eIf the constant is on the right-hand side of the expression in such cases, the code will still compile and run - just not as expected. If the\nconstant is on the left-hand side, the error will be caught at the first attempt to compile.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nif ( var \u003d\u003d constant )\nif ( pointer \u003d\u003d NULL )\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nif ( constant \u003d\u003d var )\nif ( NULL \u003d\u003d pointer )\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe result of the comparison is the same, regardless of whether the constant is on the left or right-hand side. But following this convention will\nhelp pinpoint the occasional error where \u003ccode\u003e\u003d\u003c/code\u003e (assignment) is substituted for \u003ccode\u003e\u003d\u003d\u003c/code\u003e (comparison).\u003c/p\u003e\n\u003cp\u003eIf the constant is on the right-hand side of the expression in such cases, the code will still compile and run - just not as expected. If the\nconstant is on the left-hand side, the error will be caught at the first attempt to compile.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nif ( var \u003d\u003d constant )\nif ( pointer \u003d\u003d NULL )\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nif ( constant \u003d\u003d var )\nif ( NULL \u003d\u003d pointer )\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "convention"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S1774",
    "name": "The ternary operator should not be used",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eTernary expressions, while concise, can often lead to code that is difficult to read and understand, especially when they are nested or complex.\nPrioritizing readability fosters maintainability and reduces the likelihood of bugs. Therefore, they should be removed in favor of more explicit\ncontrol structures, such as \u003ccode\u003eif\u003c/code\u003e/\u003ccode\u003eelse\u003c/code\u003e statements, to improve the clarity and readability of the code.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre\u003e\nprintf(\"%s\", (i \u0026gt; 10 ? \"yes\" : \"no\"));  // Noncompliant\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre\u003e\nif (i \u0026gt; 10) {\n  printf(\"yes\");\n} else {\n  printf(\"no\");\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eFor C++11 mode only, the issue is not raised for ternary operators used inside \u003ccode\u003econstexpr\u003c/code\u003e functions. In C++11 such functions are\nlimited to just a return statement, so the use of a ternary operator is required in them. This restriction is lifted in later standards, and thus\nissues are raised.\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eTernary expressions, while concise, can often lead to code that is difficult to read and understand, especially when they are nested or complex.\nPrioritizing readability fosters maintainability and reduces the likelihood of bugs. Therefore, they should be removed in favor of more explicit\ncontrol structures, such as \u003ccode\u003eif\u003c/code\u003e/\u003ccode\u003eelse\u003c/code\u003e statements, to improve the clarity and readability of the code.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre\u003e\nprintf(\"%s\", (i \u0026gt; 10 ? \"yes\" : \"no\"));  // Noncompliant\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre\u003e\nif (i \u0026gt; 10) {\n  printf(\"yes\");\n} else {\n  printf(\"no\");\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eFor C++11 mode only, the issue is not raised for ternary operators used inside \u003ccode\u003econstexpr\u003c/code\u003e functions. In C++11 such functions are\nlimited to just a return statement, so the use of a ternary operator is required in them. This restriction is lifted in later standards, and thus\nissues are raised.\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "brain-overload"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S813",
    "name": "typedefs that indicate size and signedness should be used in place of the basic types",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe basic numeric types \u003ccode\u003echar\u003c/code\u003e, \u003ccode\u003eint\u003c/code\u003e, \u003ccode\u003eshort\u003c/code\u003e, \u003ccode\u003elong\u003c/code\u003e, \u003ccode\u003efloat\u003c/code\u003e, \u003ccode\u003edouble\u003c/code\u003e, and\n\u003ccode\u003elong double\u003c/code\u003e should not be used. Instead, specific-length typedefs should be. This rule helps to clarify the size of the storage, but does\nnot guarantee portability because of the asymmetric behavior of integral promotion.\u003c/p\u003e\n\u003cp\u003eNote that it is still important to understand the integer size of the implementation, and developers should be aware of the actual implementation\nof the typedefs under these definitions.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint function(unsigned short a) // Noncompliant\n{\n  // ...\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;stdint.h\u0026gt;\nint32_t function(uint16_t a) // Compliant\n{\n  // ...\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 6.3 - typedefs that indicate size and signedness should be used in place of the basic types \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 3-9-2 - typedefs that indicate size and signedness should be used in place of the basic numerical types \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe basic numeric types \u003ccode\u003echar\u003c/code\u003e, \u003ccode\u003eint\u003c/code\u003e, \u003ccode\u003eshort\u003c/code\u003e, \u003ccode\u003elong\u003c/code\u003e, \u003ccode\u003efloat\u003c/code\u003e, \u003ccode\u003edouble\u003c/code\u003e, and\n\u003ccode\u003elong double\u003c/code\u003e should not be used. Instead, specific-length typedefs should be. This rule helps to clarify the size of the storage, but does\nnot guarantee portability because of the asymmetric behavior of integral promotion.\u003c/p\u003e\n\u003cp\u003eNote that it is still important to understand the integer size of the implementation, and developers should be aware of the actual implementation\nof the typedefs under these definitions.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint function(unsigned short a) // Noncompliant\n{\n  // ...\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;stdint.h\u0026gt;\nint32_t function(uint16_t a) // Compliant\n{\n  // ...\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 6.3 - typedefs that indicate size and signedness should be used in place of the basic types \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 3-9-2 - typedefs that indicate size and signedness should be used in place of the basic numerical types \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "based-on-misra"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S139",
    "name": "Comments should not be located at the end of lines of code",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "FORMATTED",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThis rule verifies that single-line comments are not located at the ends of lines of code. The main idea behind this rule is that in order to be\nreally readable, trailing comments would have to be properly written and formatted (correct alignment, no interference with the visual structure of\nthe code, not too long to be visible) but most often, automatic code formatters would not handle this correctly: the code would end up less readable.\nComments are far better placed on the previous empty line of code, where they will always be visible and properly formatted.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\na \u003d b + c;   // This is a trailing comment that could be very very long\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n// This very long comment is better placed before the line of code\na \u003d b + c;\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThe rule will not raise an issue if the trailing comment is preceded by an opening brace, closing brace (optionally followed by a semicolon) or a\npreprocessor directive.\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThis rule verifies that single-line comments are not located at the ends of lines of code. The main idea behind this rule is that in order to be\nreally readable, trailing comments would have to be properly written and formatted (correct alignment, no interference with the visual structure of\nthe code, not too long to be visible) but most often, automatic code formatters would not handle this correctly: the code would end up less readable.\nComments are far better placed on the previous empty line of code, where they will always be visible and properly formatted.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\na \u003d b + c;   // This is a trailing comment that could be very very long\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n// This very long comment is better placed before the line of code\na \u003d b + c;\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThe rule will not raise an issue if the trailing comment is preceded by an opening brace, closing brace (optionally followed by a semicolon) or a\npreprocessor directive.\u003c/p\u003e"
      }
    ],
    "params": {
      "legalTrailingCommentPattern": {
        "key": "legalTrailingCommentPattern",
        "name": "legalTrailingCommentPattern",
        "description": "POSIX regular expression for text of trailing comments that are allowed. By default, comments containing only one word.",
        "defaultValue": "^[ \\t\\n\\r\\f\\v]*[^ \\t\\n\\r\\f\\v]+$",
        "type": "STRING",
        "multiple": false,
        "possibleValues": []
      }
    },
    "defaultParams": {
      "legalTrailingCommentPattern": "^[ \\t\\n\\r\\f\\v]*[^ \\t\\n\\r\\f\\v]+$"
    },
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "convention"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S810",
    "name": "Appropriate char types should be used for character and integer values",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThere are three distinct \u003ccode\u003echar\u003c/code\u003e types, (plain) \u003ccode\u003echar\u003c/code\u003e, \u003ccode\u003esigned char\u003c/code\u003e and \u003ccode\u003eunsigned char\u003c/code\u003e. \u003ccode\u003esigned\nchar\u003c/code\u003e and \u003ccode\u003eunsigned char\u003c/code\u003e should only be used for numeric data, and plain \u003ccode\u003echar\u003c/code\u003e should only be used for character data.\nSince it is implementation-defined, the signedness of the plain \u003ccode\u003echar\u003c/code\u003e type should not be assumed.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nsigned char a \u003d \u0027a\u0027; // Noncompliant, explicitly signed\nunsigned char b \u003d \u0027\\r\u0027; // Noncompliant, explicitly unsigned\nchar c \u003d 10; // Noncompliant\n\nunsigned char d \u003d c; // Noncompliant, d is explicitly signed while c is not\nchar e \u003d a; // Noncompliant, a is explicitly signed while e is not\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nchar a \u003d \u0027a\u0027;\nchar b \u003d \u0027\\r\u0027;\nunsigned char c \u003d 10;\nsigned char c \u003d 10;\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Since the integer value 0 is used as a sentinel for the end of a string, converting this value to char is ignored. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 6.1 - The plain char type shall be used only for the storage and use of character values \u003c/li\u003e\n  \u003cli\u003e MISRA C:2004, 6.2 - signed and unsigned char type shall be used only for the storage and use of number values \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 5-0-11 - The plain char type shall only be used for the storage and use of character values \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 5-0-12 - signed char and unsigned char type shall only be used for the storage and use of numeric values \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/AtcxBQ\"\u003eCERT, INT07-C.\u003c/a\u003e - Use only explicitly signed or unsigned char type for numeric values\n  \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/F9YxBQ\"\u003eCERT, STR00-C.\u003c/a\u003e - Represent characters using an appropriate type \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/3tYxBQ\"\u003eCERT, STR04-C.\u003c/a\u003e - Use plain char for characters in the basic character set \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThere are three distinct \u003ccode\u003echar\u003c/code\u003e types, (plain) \u003ccode\u003echar\u003c/code\u003e, \u003ccode\u003esigned char\u003c/code\u003e and \u003ccode\u003eunsigned char\u003c/code\u003e. \u003ccode\u003esigned\nchar\u003c/code\u003e and \u003ccode\u003eunsigned char\u003c/code\u003e should only be used for numeric data, and plain \u003ccode\u003echar\u003c/code\u003e should only be used for character data.\nSince it is implementation-defined, the signedness of the plain \u003ccode\u003echar\u003c/code\u003e type should not be assumed.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nsigned char a \u003d \u0027a\u0027; // Noncompliant, explicitly signed\nunsigned char b \u003d \u0027\\r\u0027; // Noncompliant, explicitly unsigned\nchar c \u003d 10; // Noncompliant\n\nunsigned char d \u003d c; // Noncompliant, d is explicitly signed while c is not\nchar e \u003d a; // Noncompliant, a is explicitly signed while e is not\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nchar a \u003d \u0027a\u0027;\nchar b \u003d \u0027\\r\u0027;\nunsigned char c \u003d 10;\nsigned char c \u003d 10;\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Since the integer value 0 is used as a sentinel for the end of a string, converting this value to char is ignored. \u003c/li\u003e\n\u003c/ul\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 6.1 - The plain char type shall be used only for the storage and use of character values \u003c/li\u003e\n  \u003cli\u003e MISRA C:2004, 6.2 - signed and unsigned char type shall be used only for the storage and use of number values \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 5-0-11 - The plain char type shall only be used for the storage and use of character values \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 5-0-12 - signed char and unsigned char type shall only be used for the storage and use of numeric values \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/AtcxBQ\"\u003eCERT, INT07-C.\u003c/a\u003e - Use only explicitly signed or unsigned char type for numeric values\n  \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/F9YxBQ\"\u003eCERT, STR00-C.\u003c/a\u003e - Represent characters using an appropriate type \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/3tYxBQ\"\u003eCERT, STR04-C.\u003c/a\u003e - Use plain char for characters in the basic character set \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "based-on-misra",
      "cert",
      "confusing"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S138",
    "name": "Functions/methods should not have too many lines",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "FOCUSED",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eA function that grows too large tends to aggregate too many responsibilities.\u003c/p\u003e\n\u003cp\u003eSuch functions inevitably become harder to understand and therefore harder to maintain.\u003c/p\u003e\n\u003cp\u003eAbove a specific threshold, it is strongly advised to refactor into smaller functions which focus on well-defined tasks.\u003c/p\u003e\n\u003cp\u003eThose smaller functions will not only be easier to understand, but also probably easier to test.\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eA function that grows too large tends to aggregate too many responsibilities.\u003c/p\u003e\n\u003cp\u003eSuch functions inevitably become harder to understand and therefore harder to maintain.\u003c/p\u003e\n\u003cp\u003eAbove a specific threshold, it is strongly advised to refactor into smaller functions which focus on well-defined tasks.\u003c/p\u003e\n\u003cp\u003eThose smaller functions will not only be easier to understand, but also probably easier to test.\u003c/p\u003e"
      }
    ],
    "params": {
      "max": {
        "key": "max",
        "name": "max",
        "description": "Maximum authorized lines in a function",
        "defaultValue": "100",
        "type": "INTEGER",
        "multiple": false,
        "possibleValues": []
      }
    },
    "defaultParams": {
      "max": "100"
    },
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "brain-overload"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S930",
    "name": "The number of arguments passed to a function should match the number of parameters",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThis problem is completely avoided by the use of function prototypes. See MISRA C:2004 Rule 8.1. This rule is retained since compilers may not flag\nthis constraint error.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 16.6 - The number of arguments passed to a function shall match the number of parameters. \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/628\"\u003eMITRE, CWE-628\u003c/a\u003e - Function Call with Incorrectly Specified Arguments \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/7NYxBQ\"\u003eCERT, DCL07-C.\u003c/a\u003e - Include the appropriate type information in function declarators\n  \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/49UxBQ\"\u003eCERT, EXP37-C.\u003c/a\u003e - Call functions with the correct number and type of arguments \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThis problem is completely avoided by the use of function prototypes. See MISRA C:2004 Rule 8.1. This rule is retained since compilers may not flag\nthis constraint error.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 16.6 - The number of arguments passed to a function shall match the number of parameters. \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/628\"\u003eMITRE, CWE-628\u003c/a\u003e - Function Call with Incorrectly Specified Arguments \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/7NYxBQ\"\u003eCERT, DCL07-C.\u003c/a\u003e - Include the appropriate type information in function declarators\n  \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/49UxBQ\"\u003eCERT, EXP37-C.\u003c/a\u003e - Call functions with the correct number and type of arguments \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "based-on-misra",
      "cert",
      "cwe"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S4790",
    "name": "Using weak hashing algorithms is security-sensitive",
    "defaultSeverity": "CRITICAL",
    "type": "SECURITY_HOTSPOT",
    "cleanCodeAttribute": "TRUSTWORTHY",
    "defaultImpacts": {
      "SECURITY": "HIGH"
    },
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eCryptographic hash algorithms such as \u003ccode\u003eMD2\u003c/code\u003e, \u003ccode\u003eMD4\u003c/code\u003e, \u003ccode\u003eMD5\u003c/code\u003e, \u003ccode\u003eMD6\u003c/code\u003e, \u003ccode\u003eHAVAL-128\u003c/code\u003e,\n\u003ccode\u003eHMAC-MD5\u003c/code\u003e, \u003ccode\u003eDSA\u003c/code\u003e (which uses \u003ccode\u003eSHA-1\u003c/code\u003e), \u003ccode\u003eRIPEMD\u003c/code\u003e, \u003ccode\u003eRIPEMD-128\u003c/code\u003e, \u003ccode\u003eRIPEMD-160\u003c/code\u003e,\n\u003ccode\u003eHMACRIPEMD160\u003c/code\u003e and \u003ccode\u003eSHA-1\u003c/code\u003e are no longer considered secure, because it is possible to have \u003ccode\u003ecollisions\u003c/code\u003e (little\ncomputational effort is enough to find two or more different inputs that produce the same hash).\u003c/p\u003e"
      },
      {
        "key": "assess_the_problem",
        "htmlContent": "\u003ch2\u003eAsk Yourself Whether\u003c/h2\u003e\n\u003cp\u003eThe hashed value is used in a security context like:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e User-password storage. \u003c/li\u003e\n  \u003cli\u003e Security token generation (used to confirm e-mail when registering on a website, reset password, etc …​). \u003c/li\u003e\n  \u003cli\u003e To compute some message integrity. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere is a risk if you answered yes to any of those questions.\u003c/p\u003e\n\u003ch2\u003eSensitive Code Example\u003c/h2\u003e\n\u003cpre\u003e\n#include \u0026lt;botan/hash.h\u0026gt;\n// ...\n\nBotan::secure_vector\u0026lt;uint8_t\u0026gt; f(std::string input){\n    std::unique_ptr\u0026lt;Botan::HashFunction\u0026gt; hash(Botan::HashFunction::create(\"MD5\")); // Sensitive\n    return hash-\u0026gt;process(input);\n}\n\u003c/pre\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003ch2\u003eRecommended Secure Coding Practices\u003c/h2\u003e\n\u003cp\u003eSafer alternatives, such as \u003ccode\u003eSHA-256\u003c/code\u003e, \u003ccode\u003eSHA-512\u003c/code\u003e, \u003ccode\u003eSHA-3\u003c/code\u003e are recommended, and for password hashing, it’s even\nbetter to use algorithms that do not compute too \"quickly\", like \u003ccode\u003ebcrypt\u003c/code\u003e, \u003ccode\u003escrypt\u003c/code\u003e, \u003ccode\u003eargon2\u003c/code\u003e or \u003ccode\u003epbkdf2\u003c/code\u003e\nbecause it slows down \u003ccode\u003ebrute force attacks\u003c/code\u003e.\u003c/p\u003e\n\u003ch2\u003eCompliant Solution\u003c/h2\u003e\n\u003cpre\u003e\n#include \u0026lt;botan/hash.h\u0026gt;\n// ...\n\nBotan::secure_vector\u0026lt;uint8_t\u0026gt; f(std::string input){\n    std::unique_ptr\u0026lt;Botan::HashFunction\u0026gt; hash(Botan::HashFunction::create(\"SHA-512\")); // Compliant\n    return hash-\u0026gt;process(input);\n}\n\u003c/pre\u003e\n\u003ch2\u003eSee\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/Top10/A02_2021-Cryptographic_Failures/\"\u003eOWASP Top 10 2021 Category A2\u003c/a\u003e - Cryptographic Failures \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://www.owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\"\u003eOWASP Top 10 2017 Category A3\u003c/a\u003e - Sensitive Data\n  Exposure \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration\"\u003eOWASP Top 10 2017 Category A6\u003c/a\u003e - Security\n  Misconfiguration \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://mobile-security.gitbook.io/masvs/security-requirements/0x08-v3-cryptography_verification_requirements\"\u003eMobile AppSec\n  Verification Standard\u003c/a\u003e - Cryptography Requirements \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/www-project-mobile-top-10/2016-risks/m5-insufficient-cryptography\"\u003eOWASP Mobile Top 10 2016 Category M5\u003c/a\u003e -\n  Insufficient Cryptography \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/1240\"\u003eMITRE, CWE-1240\u003c/a\u003e - Use of a Risky Cryptographic Primitive \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "cwe"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": [],
    "vulnerabilityProbability": "LOW"
  },
  {
    "key": "c:S818",
    "name": "Literal suffix \"L\" for long integers shall be upper case",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "IDENTIFIABLE",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eUsing upper case literal suffixes removes the potential ambiguity between \"1\" (digit 1) and \"l\" (letter el) for declaring literals.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nconst int        a \u003d 0u;      // Noncompliant\nconst int        b \u003d 0l;      // Noncompliant\nconst int        c \u003d 0Ul;     // Noncompliant\nconst int        d \u003d 0x12bu;  // Noncompliant\nconst float      m \u003d 1.2f;    // Noncompliant\nconst float      n \u003d 1.2l;    // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nconst int        a \u003d 0U;\nconst int        b \u003d 0L;\nconst int        c \u003d 0UL;\nconst int        d \u003d 0x12bU;\nconst float      m \u003d 1.2F;\nconst float      n \u003d 1.2L;\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 2-13-4 - Literal suffixes shall be upper case \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 7.3 - The lowercase character \"l\" shall not be used in a literal suffix \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/cdYxBQ\"\u003eCERT DCL16-C.\u003c/a\u003e - Use \"L,\" not \"l,\" to indicate a long value \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eUsing upper case literal suffixes removes the potential ambiguity between \"1\" (digit 1) and \"l\" (letter el) for declaring literals.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nconst int        a \u003d 0u;      // Noncompliant\nconst int        b \u003d 0l;      // Noncompliant\nconst int        c \u003d 0Ul;     // Noncompliant\nconst int        d \u003d 0x12bu;  // Noncompliant\nconst float      m \u003d 1.2f;    // Noncompliant\nconst float      n \u003d 1.2l;    // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nconst int        a \u003d 0U;\nconst int        b \u003d 0L;\nconst int        c \u003d 0UL;\nconst int        d \u003d 0x12bU;\nconst float      m \u003d 1.2F;\nconst float      n \u003d 1.2L;\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 2-13-4 - Literal suffixes shall be upper case \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 7.3 - The lowercase character \"l\" shall not be used in a literal suffix \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/cdYxBQ\"\u003eCERT DCL16-C.\u003c/a\u003e - Use \"L,\" not \"l,\" to indicate a long value \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "based-on-misra",
      "cert",
      "convention",
      "pitfall"
    ],
    "deprecatedKeys": [
      "c:LiteralSuffix"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S819",
    "name": "Functions should be declared explicitly",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe use of prototypes enables the compiler to check the integrity of function definitions and calls. Without prototypes the compiler is not obliged\nto pick up certain errors in function calls (e.g. different number of arguments from the function body, mismatch in types of arguments between call\nand definition). Function interfaces have been shown to be a cause of considerable problems, and therefore this rule is considered very important.\u003c/p\u003e\n\u003cp\u003eThe recommended method of implementing function prototypes for external functions is to declare the function (i.e. give the function prototype) in\na header file, and then include the header file in all those code files that need the prototype (see MISRA C 2004, Rule 8.8).\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid example() {\n  fun(); // Noncompliant\n}\n\nvoid fun() {\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid fun();\n\nvoid example() {\n  fun();\n}\n\nvoid fun() {\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 8.1 - Functions shall have prototype declarations and the prototype shall be visible at both the function definition and call\n  \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 17.3 - A function shall not be declared implicitly \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/7NYxBQ\"\u003eCERT, DCL07-C.\u003c/a\u003e - Include the appropriate type information in function declarators\n  \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/8NUxBQ\"\u003eCERT, DCL31-C.\u003c/a\u003e - Declare identifiers before using them \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe use of prototypes enables the compiler to check the integrity of function definitions and calls. Without prototypes the compiler is not obliged\nto pick up certain errors in function calls (e.g. different number of arguments from the function body, mismatch in types of arguments between call\nand definition). Function interfaces have been shown to be a cause of considerable problems, and therefore this rule is considered very important.\u003c/p\u003e\n\u003cp\u003eThe recommended method of implementing function prototypes for external functions is to declare the function (i.e. give the function prototype) in\na header file, and then include the header file in all those code files that need the prototype (see MISRA C 2004, Rule 8.8).\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid example() {\n  fun(); // Noncompliant\n}\n\nvoid fun() {\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid fun();\n\nvoid example() {\n  fun();\n}\n\nvoid fun() {\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 8.1 - Functions shall have prototype declarations and the prototype shall be visible at both the function definition and call\n  \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 17.3 - A function shall not be declared implicitly \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/7NYxBQ\"\u003eCERT, DCL07-C.\u003c/a\u003e - Include the appropriate type information in function declarators\n  \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/8NUxBQ\"\u003eCERT, DCL31-C.\u003c/a\u003e - Declare identifiers before using them \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "bad-practice",
      "based-on-misra",
      "cert"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S817",
    "name": "String literals with different prefixes should not be concatenated",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eConcatenation of wide and narrow string literals has not always been supported in C or C++, and even when supported, the meaning may be unclear to\nthe reader. Concatenation of string literals with different encodings is only conditionally supported, and may be removed in a future version of the\nlanguage.\u003c/p\u003e\n\u003cp\u003eTherefore, only string literals with the same prefix should be concatenated together.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nwchar_t n_array[] \u003d \"Hello\" L\"World\";     // Noncompliant\nwchar_t w_array[] \u003d L\"Hello\" \"World\";     // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nchar_t n_array[] \u003d \"Hello\" \"World\";     // Compliant\nwchar_t w_array[] \u003d L\"Hello\" L\"World\";\t// Compliant\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 2-13-5 - Narrow and wide string literals shall not be concatenated. \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/WdYxBQ\"\u003eCERT STR10-C.\u003c/a\u003e - Do not concatenate different type of string literals \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eConcatenation of wide and narrow string literals has not always been supported in C or C++, and even when supported, the meaning may be unclear to\nthe reader. Concatenation of string literals with different encodings is only conditionally supported, and may be removed in a future version of the\nlanguage.\u003c/p\u003e\n\u003cp\u003eTherefore, only string literals with the same prefix should be concatenated together.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nwchar_t n_array[] \u003d \"Hello\" L\"World\";     // Noncompliant\nwchar_t w_array[] \u003d L\"Hello\" \"World\";     // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nchar_t n_array[] \u003d \"Hello\" \"World\";     // Compliant\nwchar_t w_array[] \u003d L\"Hello\" L\"World\";\t// Compliant\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 2-13-5 - Narrow and wide string literals shall not be concatenated. \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/WdYxBQ\"\u003eCERT STR10-C.\u003c/a\u003e - Do not concatenate different type of string literals \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "based-on-misra",
      "cert"
    ],
    "deprecatedKeys": [
      "c:NarrowAndWideStringConcat"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S814",
    "name": "Bit fields should be declared with appropriate types",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eSome types are not very well suited for use in a bit-field, because their behavior is implementation-defined. When defining a bit-field, you should\nstick to the following safe and portable types:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e In C: \u003ccode\u003esigned short\u003c/code\u003e, \u003ccode\u003eunsigned short\u003c/code\u003e, \u003ccode\u003esigned char\u003c/code\u003e, \u003ccode\u003eunsigned char\u003c/code\u003e, \u003ccode\u003esigned int\u003c/code\u003e,\n  \u003ccode\u003eunsigned int\u003c/code\u003e or \u003ccode\u003e_Bool\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e In C++ before C++14: all enumerated types, as well as\u0026nbsp;\u003ccode\u003esigned short\u003c/code\u003e, \u003ccode\u003eunsigned short\u003c/code\u003e, \u003ccode\u003esigned char\u003c/code\u003e,\n  \u003ccode\u003eunsigned char\u003c/code\u003e, \u003ccode\u003esigned int\u003c/code\u003e, \u003ccode\u003eunsigned int\u003c/code\u003e, \u003ccode\u003esigned long\u003c/code\u003e, \u003ccode\u003eunsigned long\u003c/code\u003e, \u003ccode\u003esigned\n  long long\u003c/code\u003e, \u003ccode\u003eunsigned long long\u003c/code\u003e\u003ccode\u003e\u0026nbsp;or bool\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e In C++ starting at C++14: all enumerated and integral types \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n// Assuming we are in C\nint b:3; // Noncompliant - may have the range of values 0..7 or -4..3\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nunsigned int b:3;\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 6.4 - Bit fields shall only be defined to be of type \u003cem\u003eunsigned int\u003c/em\u003e or \u003cem\u003esigned int\u003c/em\u003e. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 9-6-2 - Bit-fields shall be either \u003cem\u003ebool\u003c/em\u003e type or an explicitly \u003cem\u003eunsigned\u003c/em\u003e or \u003cem\u003esigned\u003c/em\u003e integral type.\n  \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 6.1 - Bit-fields shall only be declared with an appropriate type \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/VNYxBQ\"\u003eCERT, INT12-C.\u003c/a\u003e - Do not make assumptions about the type of a plain int bit-field\n  when used in an expression \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eSome types are not very well suited for use in a bit-field, because their behavior is implementation-defined. When defining a bit-field, you should\nstick to the following safe and portable types:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e In C: \u003ccode\u003esigned short\u003c/code\u003e, \u003ccode\u003eunsigned short\u003c/code\u003e, \u003ccode\u003esigned char\u003c/code\u003e, \u003ccode\u003eunsigned char\u003c/code\u003e, \u003ccode\u003esigned int\u003c/code\u003e,\n  \u003ccode\u003eunsigned int\u003c/code\u003e or \u003ccode\u003e_Bool\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e In C++ before C++14: all enumerated types, as well as\u0026nbsp;\u003ccode\u003esigned short\u003c/code\u003e, \u003ccode\u003eunsigned short\u003c/code\u003e, \u003ccode\u003esigned char\u003c/code\u003e,\n  \u003ccode\u003eunsigned char\u003c/code\u003e, \u003ccode\u003esigned int\u003c/code\u003e, \u003ccode\u003eunsigned int\u003c/code\u003e, \u003ccode\u003esigned long\u003c/code\u003e, \u003ccode\u003eunsigned long\u003c/code\u003e, \u003ccode\u003esigned\n  long long\u003c/code\u003e, \u003ccode\u003eunsigned long long\u003c/code\u003e\u003ccode\u003e\u0026nbsp;or bool\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e In C++ starting at C++14: all enumerated and integral types \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n// Assuming we are in C\nint b:3; // Noncompliant - may have the range of values 0..7 or -4..3\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nunsigned int b:3;\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 6.4 - Bit fields shall only be defined to be of type \u003cem\u003eunsigned int\u003c/em\u003e or \u003cem\u003esigned int\u003c/em\u003e. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 9-6-2 - Bit-fields shall be either \u003cem\u003ebool\u003c/em\u003e type or an explicitly \u003cem\u003eunsigned\u003c/em\u003e or \u003cem\u003esigned\u003c/em\u003e integral type.\n  \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 6.1 - Bit-fields shall only be declared with an appropriate type \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/VNYxBQ\"\u003eCERT, INT12-C.\u003c/a\u003e - Do not make assumptions about the type of a plain int bit-field\n  when used in an expression \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "based-on-misra",
      "cert",
      "lock-in"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S935",
    "name": "Function exit paths should have appropriate return values",
    "defaultSeverity": "CRITICAL",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhen a function does not return an appropriate value, it causes the program to have an undefined behavior. For example, if a function is supposed\nto return a value indicating whether a file was successfully opened but does not return any value, the program may continue to execute as if the file\nwas opened successfully, even though it was not. This can lead to data corruption or other issues that are difficult to diagnose.\u003c/p\u003e\n\u003cp\u003eFunctions with a void return type are not expected to return any value. If they do, it may indicate a programming error.\u003c/p\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThe rule does not raise an issue:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e when the \u003ccode\u003ereturn\u003c/code\u003e statement of a \u003ccode\u003evoid\u003c/code\u003e function is a \u003ccode\u003evoid\u003c/code\u003e expression. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\nvoid foo() {\n  // ...\n}\n\nvoid bar() {\n  return foo(); // Compliant by exception\n}\n\u003c/pre\u003e\n\u003cul\u003e\n  \u003cli\u003e for coroutines, introduced in C++20. Coroutines always declare coroutine objects as return types, but the compiler implicitly creates the\n  returned object. The coroutine body never contains a \u003ccode\u003ereturn\u003c/code\u003e statement, as it is disallowed: if a coroutine returns a value, it will use\n  \u003ccode\u003eco_return\u003c/code\u003e. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nint my_func(int a) {\n  if (a \u0026gt; 100) {\n    return; // Noncompliant\n  }\n\n  // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nint my_func(int a) {\n  if (a \u0026gt; 100) {\n    return a;\n  }\n\n  if (a \u0026gt; 80) {\n    throw new Exception();\n  }\n\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 16.8 - All exit paths from a function with non-void return type shall have an explicit return statement with an expression \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 8-4-3 - All exit paths from a function with non-void return type shall have an explicit return statement with an expression\n  \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 17.4 - All exit paths from a function with non-void return type shall have an explicit return statement with an expression \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/394\"\u003eMITRE, CWE-394\u003c/a\u003e - Unexpected Status Code or Return Value \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/m9YxBQ\"\u003eCERT, MSC37-C.\u003c/a\u003e - Ensure that control never reaches the end of a non-void function\n  \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/EXs-BQ\"\u003eCERT, MSC52-CPP.\u003c/a\u003e - Value-returning functions must return a value from all exit paths\n  \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/Cns-BQ\"\u003eCERT, MSC53-CPP.\u003c/a\u003e - Do not return from a function declared [[noreturn]] \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e S6369 - Coroutine should have co_return on each execution path or provide return_void \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhen a function does not return an appropriate value, it causes the program to have an undefined behavior. For example, if a function is supposed\nto return a value indicating whether a file was successfully opened but does not return any value, the program may continue to execute as if the file\nwas opened successfully, even though it was not. This can lead to data corruption or other issues that are difficult to diagnose.\u003c/p\u003e\n\u003cp\u003eFunctions with a void return type are not expected to return any value. If they do, it may indicate a programming error.\u003c/p\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThe rule does not raise an issue:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e when the \u003ccode\u003ereturn\u003c/code\u003e statement of a \u003ccode\u003evoid\u003c/code\u003e function is a \u003ccode\u003evoid\u003c/code\u003e expression. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\nvoid foo() {\n  // ...\n}\n\nvoid bar() {\n  return foo(); // Compliant by exception\n}\n\u003c/pre\u003e\n\u003cul\u003e\n  \u003cli\u003e for coroutines, introduced in C++20. Coroutines always declare coroutine objects as return types, but the compiler implicitly creates the\n  returned object. The coroutine body never contains a \u003ccode\u003ereturn\u003c/code\u003e statement, as it is disallowed: if a coroutine returns a value, it will use\n  \u003ccode\u003eco_return\u003c/code\u003e. \u003c/li\u003e\n\u003c/ul\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nint my_func(int a) {\n  if (a \u0026gt; 100) {\n    return; // Noncompliant\n  }\n\n  // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nint my_func(int a) {\n  if (a \u0026gt; 100) {\n    return a;\n  }\n\n  if (a \u0026gt; 80) {\n    throw new Exception();\n  }\n\n  return 0;\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 16.8 - All exit paths from a function with non-void return type shall have an explicit return statement with an expression \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 8-4-3 - All exit paths from a function with non-void return type shall have an explicit return statement with an expression\n  \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 17.4 - All exit paths from a function with non-void return type shall have an explicit return statement with an expression \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/394\"\u003eMITRE, CWE-394\u003c/a\u003e - Unexpected Status Code or Return Value \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/m9YxBQ\"\u003eCERT, MSC37-C.\u003c/a\u003e - Ensure that control never reaches the end of a non-void function\n  \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/EXs-BQ\"\u003eCERT, MSC52-CPP.\u003c/a\u003e - Value-returning functions must return a value from all exit paths\n  \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/Cns-BQ\"\u003eCERT, MSC53-CPP.\u003c/a\u003e - Do not return from a function declared [[noreturn]] \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e S6369 - Coroutine should have co_return on each execution path or provide return_void \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "based-on-misra",
      "cert",
      "cwe"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S936",
    "name": "Function names should be used either as a call with a parameter list or with the \"\u0026\" operator",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eUsing a \"bald\" function name is likely a bug. Rather than testing the return value of a function with a \u003ccode\u003evoid\u003c/code\u003e parameter list, it\nimplicitly retrieves the address of that function in memory. If that’s truly what’s intended, then it should be made explicit with the use of the\n\u003ccode\u003e\u0026amp;\u003c/code\u003e (address-of) operator. If it’s not, then a parameter list (even an empty one) should be added after the function name.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nint func(void) {\n  // ...\n}\n\nvoid f2(int a, int b) {\n  // ...\n  if (func) {  // Noncompliant: tests that the memory address of func() is non-null\n    //...\n  }\n  // ...\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nint func(void) {\n  // ...\n}\n\nvoid f2(int a, int b) {\n  // ...\n  if (func()) {  // Compliant: tests that the return value of func() \u0026gt; 0\n    //...\n  }\n  // ...\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eCallback functions are a common occurrence and are usually not passed with a preceding \u003ccode\u003e\u0026amp;\u003c/code\u003e. However, there is little ambiguity, so\nthis rule ignores function identifiers when used as a parameter of a function call.\u003c/p\u003e\n\u003cpre\u003e\nvoid foo() {\n  // ...\n}\n\nregisterEvent(AnEvent, foo); // Compliant by exception\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 16.9 - A function identifier shall only be used with either a preceding \u0026amp;, or with a parenthesized parameter list, which may\n  be empty. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 8-4-4 - A function identifier shall only be used to call the function or it shall be preceded by \u0026amp;. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eUsing a \"bald\" function name is likely a bug. Rather than testing the return value of a function with a \u003ccode\u003evoid\u003c/code\u003e parameter list, it\nimplicitly retrieves the address of that function in memory. If that’s truly what’s intended, then it should be made explicit with the use of the\n\u003ccode\u003e\u0026amp;\u003c/code\u003e (address-of) operator. If it’s not, then a parameter list (even an empty one) should be added after the function name.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nint func(void) {\n  // ...\n}\n\nvoid f2(int a, int b) {\n  // ...\n  if (func) {  // Noncompliant: tests that the memory address of func() is non-null\n    //...\n  }\n  // ...\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nint func(void) {\n  // ...\n}\n\nvoid f2(int a, int b) {\n  // ...\n  if (func()) {  // Compliant: tests that the return value of func() \u0026gt; 0\n    //...\n  }\n  // ...\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eCallback functions are a common occurrence and are usually not passed with a preceding \u003ccode\u003e\u0026amp;\u003c/code\u003e. However, there is little ambiguity, so\nthis rule ignores function identifiers when used as a parameter of a function call.\u003c/p\u003e\n\u003cpre\u003e\nvoid foo() {\n  // ...\n}\n\nregisterEvent(AnEvent, foo); // Compliant by exception\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 16.9 - A function identifier shall only be used with either a preceding \u0026amp;, or with a parenthesized parameter list, which may\n  be empty. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 8-4-4 - A function identifier shall only be used to call the function or it shall be preceded by \u0026amp;. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "based-on-misra",
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S3584",
    "name": "Dynamically allocated memory should be released",
    "defaultSeverity": "BLOCKER",
    "type": "BUG",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003cp\u003eMemory allocated dynamically with \u003ccode\u003ecalloc\u003c/code\u003e, \u003ccode\u003emalloc\u003c/code\u003e, \u003ccode\u003erealloc\u003c/code\u003e, or \u003ccode\u003enew\u003c/code\u003e should be released when it is\nnot needed anymore. Failure to do so will result in a memory leak that could severely hinder application performance or abort it or the entire host\nmachine.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eMemory is a limited resource shared between all the applications running on the same host machine.\u003c/p\u003e\n\u003cp\u003eC and C++ do not automatically reclaim unused memory. The developer has to release the memory claimed for their application that is no longer\nneeded. Unlike the stack that automatically allocates local variables on a function call and deallocates them on a function return, the heap offers no\nautomatic memory management. The developer has to make sure to deallocate the memory they allocate dynamically on the heap.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when memory is allocated dynamically and not freed within the same function.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eNeglecting to free the memory leads to a memory leak.\u003c/p\u003e\n\u003cp\u003eThe application that leaks memory will consume more and more of it over time, eventually claiming all the memory available on the host machine.\nWhen this happens and the system runs out of memory, it typically does one of the following:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The operating system (if any) terminates the application. \u003c/li\u003e\n  \u003cli\u003e The operating system (if any) terminates some other application, and the problem reoccurs when the reclaimed memory gets used up by the leaking\n  application. \u003c/li\u003e\n  \u003cli\u003e The operating system (if any) starts offloading some of the memory pages to disk and slows down some memory accesses by orders of magnitude.\n  \u003c/li\u003e\n  \u003cli\u003e The entire system crashes as a whole and reboots automatically or hangs waiting for a manual reboot. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eMoreover, memory leaks can help an attacker to take over the system. An attacker could use a memory leak to fill the memory with malicious code.\nThis facilitates remote code execution through another chained vulnerability.\u003c/p\u003e\n\u003cp\u003eEven if the attacker cannot take over the system she can intentionally trigger the condition leading to a memory leak to make use of the issue\nabove and cause denial-of-service (DoS) of the system.\u003c/p\u003e\n\u003cp\u003eA memory leak can have a significant impact on the energy footprint of an application.\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e If an application demands more memory than necessary, the user will have to install more memory banks than necessary. Each memory bank consumes\n  additional power. \u003c/li\u003e\n  \u003cli\u003e As the application continues to reserve more and more memory, it places an increased load on the memory management subsystem. This increased\n  load can lead to a larger computation demand, which in turn translates to higher power consumption by the CPU. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eFinally, memory leaks degrade the user experience. The user often experiences a system slowdown caused by the uncontrolled memory use of an\napplication. Delayed response time, system freezes, and crashes degrade the user experience and discourage the further use of the application.\u003c/p\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eIf a function \u003ccode\u003ereturn\u003c/code\u003es a pointer to the caller or stores it in an external structure, this pointer is said to \u003cem\u003eescape\u003c/em\u003e (it is\nnow accessible outside of function, and no longer local to it). This includes storing the pointer in a static or global variable, passing it to a\nfunction that can potentially do that, or returning the pointer directly or as part of an aggregate object.\u003c/p\u003e\n\u003cp\u003eThe memory pointed to by an escaping pointer might be used somewhere else in the program. For that reason, the analyzer cannot proclaim a leak for\nan escaping pointer by only looking at a function scope.\u003c/p\u003e\n\u003cp\u003eWhile in some cases the leak might be detectable in the scope of a caller, in others, the analyzer would need to simulate the entire program to\nverify that the memory is not used anywhere, which is not feasible.\u003c/p\u003e\n\u003cp\u003eFor this technical reason, this rule often ignores escaping pointers.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eAsk yourself whether you need to allocate memory on the heap. If your object is small enough, in many cases allocating it as a local variable on\nthe stack is a better choice as it simplifies memory management.\u003c/p\u003e\n\u003cp\u003eIf you do need to allocate it on the heap, the direct fix for a memory leak is to make sure you always deallocate memory.\u003c/p\u003e\n\u003cp\u003eIn C++ you should use RAII (resource acquisition is initialization) idiom. See \u003ca href\u003d\"#_going_the_extra_mile\"\u003eGoing the extra mile\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eAlternatively, you have to manually make sure that every exit of the scope of the pointer to the allocated memory is prepended by the deallocation\nof that pointer.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nbool fire(Point pos, Direction dir, State const\u0026amp; s) {\n  Bullet *bullet \u003d new Bullet{pos, dir};\n  if (auto affected \u003d bullet-\u0026gt;hitAnyone(s)) {\n    affected-\u0026gt;takeHit();\n    return true; // Noncompliant, the memory pointed to by bullet is not deleted\n  }\n  delete bullet;\n  return false;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eUse a local object\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nbool fire(Point pos, Direction dir, State const\u0026amp; s) {\n  Bullet bullet{pos, dir};\n  if (auto affected \u003d bullet.hitAnyone(s)) {\n    affected-\u0026gt;takeHit();\n    return true; // Compliant: bullet is destroyed and deallocated automatically\n  }\n  return false; // Compliant: bullet is destroyed and deallocated automatically\n}\n\u003c/pre\u003e\n\u003cp\u003eIf you cannot use RAII or a local object, manually make sure memory is freed on every exit of the scope of the pointer.\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\nint fun() {\n  char* name \u003d (char *) malloc (size);\n  if (!name) {\n    return 1;\n  }\n  if (condition()) {\n    return 2; // Noncompliant: memory pointed to by \"name\" has not been released\n  }\n  // ...\n  return 0; // Noncompliant: memory pointed to by \"name\" has not been released\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\nint fun() {\n  char* name \u003d (char *) malloc (size);\n  if (!name) {\n    return 1; // Memory wasn\u0027t allocated, no need to free it\n  }\n  if (condition()) {\n    free(name);\n    return 2; // Compliant: memory is freed\n  }\n  // ...\n  free(name);\n  return 0; // Compliant: memory is freed\n}\n\u003c/pre\u003e\n\u003ch3\u003ePitfalls\u003c/h3\u003e\n\u003cp\u003eNote that the execution can exit the scope in different ways:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003ereturn\u003c/code\u003e from the function \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003ebreak\u003c/code\u003e from a \u003ccode\u003eswitch\u003c/code\u003e statement or a loop \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003egoto\u003c/code\u003e out of a code block (compound statement) \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003ethrow\u003c/code\u003e a C++ exception \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003eco_return\u003c/code\u003e from an C++ coroutine \u003c/li\u003e\n  \u003cli\u003e End of the scope (\u003ccode\u003e}\u003c/code\u003e) \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn the following example, even though the function frees memory before the explicit \u003ccode\u003ereturn\u003c/code\u003e, the memory remains allocated when the\nexecution leaves the \u003ccode\u003ewhile\u003c/code\u003e body via many other ways.\u003c/p\u003e\n\u003cpre\u003e\nvoid fire(Point pos, Direction dir, State const\u0026amp; s) {\n  while (condition()) {\n    Bullet *bullet \u003d new Bullet{pos, dir};\n    if (bullet-\u0026gt;misfired()) break; // Noncompliant: memory is not freed\n    if (!condition()) {\n      delete bullet;\n      return;\n    }\n    // Noncompliant: memory is not freed\n    if (s.tooManyBullets()) throw Exception(\"Too many bullets\");\n    if (bullet-\u0026gt;timeIsUp(s)) goto end; // Noncompliant: memory is not freed\n  } // Noncompliant: at the end of iteration bullet leaks\n\nend: // Memory allocated in the loop is not freed\n  std::cout \u0026lt;\u0026lt;\"Bullet is lost\\n\";\n}\n\u003c/pre\u003e\n\u003cp\u003eThis is why it is very difficult to avoid leaks when managing memory manually.\u003c/p\u003e\n\u003ch3\u003eGoing the extra mile\u003c/h3\u003e\n\u003cp\u003eIn C++, manually allocating and deallocating memory is considered a code smell.\u003c/p\u003e\n\u003cp\u003eIt is recommended to follow the \u003cem\u003eRAII\u003c/em\u003e idiom and create a class that manages the memory by allocating it when the object is constructed and\nfreeing it when it is destroyed. Furthermore, copy and move operations on such objects are designed such that this object can be passed by value\nbetween functions (either as an argument or by being returned) in place of raw pointers.\u003c/p\u003e\n\u003cp\u003eDepending on the type, passing an \u003cem\u003eRAII\u003c/em\u003e object operations may either:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Allocate a new block of memory and copy the elements (\u003ccode\u003estd::vector\u003c/code\u003e). \u003c/li\u003e\n  \u003cli\u003e Transfer ownership of the memory to constructed object (\u003ccode\u003estd::unique_ptr\u003c/code\u003e). \u003c/li\u003e\n  \u003cli\u003e Use shared ownership and free memory when the last object is destroyed (\u003ccode\u003estd::shared_ptr\u003c/code\u003e). \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe RAII object will take care of the deallocation of the memory when it is no longer used.\u003c/p\u003e\n\u003cp\u003eTo correct the noncompliant example, use \u003ccode\u003estd::unique_ptr\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\nbool fire(Point pos, Direction dir, State const\u0026amp; s) {\n  auto bullet \u003d std::make_unique\u0026lt;Bullet\u0026gt;(pos, dir);\n  if (auto affected \u003d bullet-\u0026gt;hitAnything(s)) {\n    affected-\u0026gt;takeHit();\n    return true; // Compliant: unique_ptr\u0026lt;Bullet\u0026gt; automatically frees memory\n  }\n  return false; // Compliant: unique_ptr\u0026lt;Bullet\u0026gt; automatically frees memory\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Wikipedia - \u003ca href\u003d\"https://en.wikipedia.org/wiki/Memory_leak\"\u003eMemory leak\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/raii\"\u003eRAII\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/401\"\u003e401 Improper Release of Memory Before Removing Last Reference (\u0027Memory Leak\u0027)\u003c/a\u003e\n  \u003c/li\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/FtYxBQ\"\u003eMEM00-C. Allocate and free memory in the same module, at the same level of\n  abstraction\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/GNYxBQ\"\u003eMEM31-C. Free dynamically allocated memory when no longer needed\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e S5025 discourages manual memory management, which helps to avoid memory leaks. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eMemory allocated dynamically with \u003ccode\u003ecalloc\u003c/code\u003e, \u003ccode\u003emalloc\u003c/code\u003e, \u003ccode\u003erealloc\u003c/code\u003e, or \u003ccode\u003enew\u003c/code\u003e should be released when it is\nnot needed anymore. Failure to do so will result in a memory leak that could severely hinder application performance or abort it or the entire host\nmachine.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eMemory is a limited resource shared between all the applications running on the same host machine.\u003c/p\u003e\n\u003cp\u003eC and C++ do not automatically reclaim unused memory. The developer has to release the memory claimed for their application that is no longer\nneeded. Unlike the stack that automatically allocates local variables on a function call and deallocates them on a function return, the heap offers no\nautomatic memory management. The developer has to make sure to deallocate the memory they allocate dynamically on the heap.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when memory is allocated dynamically and not freed within the same function.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eNeglecting to free the memory leads to a memory leak.\u003c/p\u003e\n\u003cp\u003eThe application that leaks memory will consume more and more of it over time, eventually claiming all the memory available on the host machine.\nWhen this happens and the system runs out of memory, it typically does one of the following:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The operating system (if any) terminates the application. \u003c/li\u003e\n  \u003cli\u003e The operating system (if any) terminates some other application, and the problem reoccurs when the reclaimed memory gets used up by the leaking\n  application. \u003c/li\u003e\n  \u003cli\u003e The operating system (if any) starts offloading some of the memory pages to disk and slows down some memory accesses by orders of magnitude.\n  \u003c/li\u003e\n  \u003cli\u003e The entire system crashes as a whole and reboots automatically or hangs waiting for a manual reboot. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eMoreover, memory leaks can help an attacker to take over the system. An attacker could use a memory leak to fill the memory with malicious code.\nThis facilitates remote code execution through another chained vulnerability.\u003c/p\u003e\n\u003cp\u003eEven if the attacker cannot take over the system she can intentionally trigger the condition leading to a memory leak to make use of the issue\nabove and cause denial-of-service (DoS) of the system.\u003c/p\u003e\n\u003cp\u003eA memory leak can have a significant impact on the energy footprint of an application.\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e If an application demands more memory than necessary, the user will have to install more memory banks than necessary. Each memory bank consumes\n  additional power. \u003c/li\u003e\n  \u003cli\u003e As the application continues to reserve more and more memory, it places an increased load on the memory management subsystem. This increased\n  load can lead to a larger computation demand, which in turn translates to higher power consumption by the CPU. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eFinally, memory leaks degrade the user experience. The user often experiences a system slowdown caused by the uncontrolled memory use of an\napplication. Delayed response time, system freezes, and crashes degrade the user experience and discourage the further use of the application.\u003c/p\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eIf a function \u003ccode\u003ereturn\u003c/code\u003es a pointer to the caller or stores it in an external structure, this pointer is said to \u003cem\u003eescape\u003c/em\u003e (it is\nnow accessible outside of function, and no longer local to it). This includes storing the pointer in a static or global variable, passing it to a\nfunction that can potentially do that, or returning the pointer directly or as part of an aggregate object.\u003c/p\u003e\n\u003cp\u003eThe memory pointed to by an escaping pointer might be used somewhere else in the program. For that reason, the analyzer cannot proclaim a leak for\nan escaping pointer by only looking at a function scope.\u003c/p\u003e\n\u003cp\u003eWhile in some cases the leak might be detectable in the scope of a caller, in others, the analyzer would need to simulate the entire program to\nverify that the memory is not used anywhere, which is not feasible.\u003c/p\u003e\n\u003cp\u003eFor this technical reason, this rule often ignores escaping pointers.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eAsk yourself whether you need to allocate memory on the heap. If your object is small enough, in many cases allocating it as a local variable on\nthe stack is a better choice as it simplifies memory management.\u003c/p\u003e\n\u003cp\u003eIf you do need to allocate it on the heap, the direct fix for a memory leak is to make sure you always deallocate memory.\u003c/p\u003e\n\u003cp\u003eIn C++ you should use RAII (resource acquisition is initialization) idiom. See \u003ca href\u003d\"#_going_the_extra_mile\"\u003eGoing the extra mile\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eAlternatively, you have to manually make sure that every exit of the scope of the pointer to the allocated memory is prepended by the deallocation\nof that pointer.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nbool fire(Point pos, Direction dir, State const\u0026amp; s) {\n  Bullet *bullet \u003d new Bullet{pos, dir};\n  if (auto affected \u003d bullet-\u0026gt;hitAnyone(s)) {\n    affected-\u0026gt;takeHit();\n    return true; // Noncompliant, the memory pointed to by bullet is not deleted\n  }\n  delete bullet;\n  return false;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eUse a local object\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nbool fire(Point pos, Direction dir, State const\u0026amp; s) {\n  Bullet bullet{pos, dir};\n  if (auto affected \u003d bullet.hitAnyone(s)) {\n    affected-\u0026gt;takeHit();\n    return true; // Compliant: bullet is destroyed and deallocated automatically\n  }\n  return false; // Compliant: bullet is destroyed and deallocated automatically\n}\n\u003c/pre\u003e\n\u003cp\u003eIf you cannot use RAII or a local object, manually make sure memory is freed on every exit of the scope of the pointer.\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\nint fun() {\n  char* name \u003d (char *) malloc (size);\n  if (!name) {\n    return 1;\n  }\n  if (condition()) {\n    return 2; // Noncompliant: memory pointed to by \"name\" has not been released\n  }\n  // ...\n  return 0; // Noncompliant: memory pointed to by \"name\" has not been released\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\nint fun() {\n  char* name \u003d (char *) malloc (size);\n  if (!name) {\n    return 1; // Memory wasn\u0027t allocated, no need to free it\n  }\n  if (condition()) {\n    free(name);\n    return 2; // Compliant: memory is freed\n  }\n  // ...\n  free(name);\n  return 0; // Compliant: memory is freed\n}\n\u003c/pre\u003e\n\u003ch3\u003ePitfalls\u003c/h3\u003e\n\u003cp\u003eNote that the execution can exit the scope in different ways:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003ereturn\u003c/code\u003e from the function \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003ebreak\u003c/code\u003e from a \u003ccode\u003eswitch\u003c/code\u003e statement or a loop \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003egoto\u003c/code\u003e out of a code block (compound statement) \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003ethrow\u003c/code\u003e a C++ exception \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003eco_return\u003c/code\u003e from an C++ coroutine \u003c/li\u003e\n  \u003cli\u003e End of the scope (\u003ccode\u003e}\u003c/code\u003e) \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn the following example, even though the function frees memory before the explicit \u003ccode\u003ereturn\u003c/code\u003e, the memory remains allocated when the\nexecution leaves the \u003ccode\u003ewhile\u003c/code\u003e body via many other ways.\u003c/p\u003e\n\u003cpre\u003e\nvoid fire(Point pos, Direction dir, State const\u0026amp; s) {\n  while (condition()) {\n    Bullet *bullet \u003d new Bullet{pos, dir};\n    if (bullet-\u0026gt;misfired()) break; // Noncompliant: memory is not freed\n    if (!condition()) {\n      delete bullet;\n      return;\n    }\n    // Noncompliant: memory is not freed\n    if (s.tooManyBullets()) throw Exception(\"Too many bullets\");\n    if (bullet-\u0026gt;timeIsUp(s)) goto end; // Noncompliant: memory is not freed\n  } // Noncompliant: at the end of iteration bullet leaks\n\nend: // Memory allocated in the loop is not freed\n  std::cout \u0026lt;\u0026lt;\"Bullet is lost\\n\";\n}\n\u003c/pre\u003e\n\u003cp\u003eThis is why it is very difficult to avoid leaks when managing memory manually.\u003c/p\u003e\n\u003ch3\u003eGoing the extra mile\u003c/h3\u003e\n\u003cp\u003eIn C++, manually allocating and deallocating memory is considered a code smell.\u003c/p\u003e\n\u003cp\u003eIt is recommended to follow the \u003cem\u003eRAII\u003c/em\u003e idiom and create a class that manages the memory by allocating it when the object is constructed and\nfreeing it when it is destroyed. Furthermore, copy and move operations on such objects are designed such that this object can be passed by value\nbetween functions (either as an argument or by being returned) in place of raw pointers.\u003c/p\u003e\n\u003cp\u003eDepending on the type, passing an \u003cem\u003eRAII\u003c/em\u003e object operations may either:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Allocate a new block of memory and copy the elements (\u003ccode\u003estd::vector\u003c/code\u003e). \u003c/li\u003e\n  \u003cli\u003e Transfer ownership of the memory to constructed object (\u003ccode\u003estd::unique_ptr\u003c/code\u003e). \u003c/li\u003e\n  \u003cli\u003e Use shared ownership and free memory when the last object is destroyed (\u003ccode\u003estd::shared_ptr\u003c/code\u003e). \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe RAII object will take care of the deallocation of the memory when it is no longer used.\u003c/p\u003e\n\u003cp\u003eTo correct the noncompliant example, use \u003ccode\u003estd::unique_ptr\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\nbool fire(Point pos, Direction dir, State const\u0026amp; s) {\n  auto bullet \u003d std::make_unique\u0026lt;Bullet\u0026gt;(pos, dir);\n  if (auto affected \u003d bullet-\u0026gt;hitAnything(s)) {\n    affected-\u0026gt;takeHit();\n    return true; // Compliant: unique_ptr\u0026lt;Bullet\u0026gt; automatically frees memory\n  }\n  return false; // Compliant: unique_ptr\u0026lt;Bullet\u0026gt; automatically frees memory\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Wikipedia - \u003ca href\u003d\"https://en.wikipedia.org/wiki/Memory_leak\"\u003eMemory leak\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/raii\"\u003eRAII\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/401\"\u003e401 Improper Release of Memory Before Removing Last Reference (\u0027Memory Leak\u0027)\u003c/a\u003e\n  \u003c/li\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/FtYxBQ\"\u003eMEM00-C. Allocate and free memory in the same module, at the same level of\n  abstraction\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/GNYxBQ\"\u003eMEM31-C. Free dynamically allocated memory when no longer needed\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e S5025 discourages manual memory management, which helps to avoid memory leaks. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "cert",
      "cwe",
      "denial-of-service",
      "leak",
      "symbolic-execution"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S3222",
    "name": "Label names should comply with a naming convention",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "IDENTIFIABLE",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eShared coding conventions allow teams to collaborate effectively. This rule checks that labels match a provided regular expression.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cp\u003eWith default provided regular expression \u003ccode\u003e^[A-Z][A-Z0-9_]*$\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\nexit:  // Noncompliant\n  doCleanup();\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nEXIT:  // Compliant\n  doCleanup();\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eShared coding conventions allow teams to collaborate effectively. This rule checks that labels match a provided regular expression.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cp\u003eWith default provided regular expression \u003ccode\u003e^[A-Z][A-Z0-9_]*$\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\nexit:  // Noncompliant\n  doCleanup();\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nEXIT:  // Compliant\n  doCleanup();\n\u003c/pre\u003e"
      }
    ],
    "params": {
      "format": {
        "key": "format",
        "name": "format",
        "description": "POSIX regular expression used to check the label names against.",
        "defaultValue": "^[A-Z][A-Z0-9_]*$",
        "type": "STRING",
        "multiple": false,
        "possibleValues": []
      }
    },
    "defaultParams": {
      "format": "^[A-Z][A-Z0-9_]*$"
    },
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "convention"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S3588",
    "name": "Closed resources should not be accessed",
    "defaultSeverity": "BLOCKER",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003cp\u003eUsing the value of a pointer to a \u003ccode\u003eFILE\u003c/code\u003e object after the associated file is closed is undefined behavior.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eOnce a file has been closed, its corresponding \u003ccode\u003eFILE*\u003c/code\u003e typed variable becomes invalid and the stream may no longer be accessed through\nthis variable. In particular, a pointer to a \u003ccode\u003eFILE\u003c/code\u003e object may not be passed to \u003ccode\u003efclose\u003c/code\u003e more than once.\u003c/p\u003e\n\u003cp\u003eUsing the value of a pointer to a \u003ccode\u003eFILE\u003c/code\u003e object after the associated file is closed results in undefined behavior.\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n\nint process_file(int print) {\n  FILE *f \u003d fopen(\"example.txt\", \"r\");\n  if (!f) {\n    perror(\"fopen() failed\");\n    return 1;\n  }\n\n  if (print) {\n    char buffer[256];\n    while (fgets(buffer, 256, f)) {\n      printf(\"%s\", buffer);\n    }\n    fclose(f);\n  }\n\n  // Further processing ...\n\n  fclose(f); // Noncompliant: file associated with `f` might already be closed.\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch2\u003eWhat is the potential impact?\u003c/h2\u003e\n\u003cp\u003eIf a pointer to a \u003ccode\u003eFILE\u003c/code\u003e object is used after the associated file is closed, the behavior of the application is undefined.\u003c/p\u003e\n\u003cp\u003eWhen a program comprises undefined behavior, the compiler no longer needs to adhere to the language standard, and the program has no meaning\nassigned to it. The application might just crash, but in the worst case, the application may appear to execute correctly, while losing data or\nproducing incorrect results.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eDo not use the value of a pointer to a \u003ccode\u003eFILE\u003c/code\u003e object after the associated file has been closed.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n\nint process_file(int print) {\n  FILE *f \u003d fopen(\"example.txt\", \"r\");\n  if (!f) {\n    perror(\"fopen() failed\");\n    return 1;\n  }\n\n  if (print) {\n    char buffer[256];\n    while (fgets(buffer, 256, f)) {\n      printf(\"%s\", buffer);\n    }\n    fclose(f);\n  }\n\n  fclose(f); // Noncompliant: file associated with `f` might already be closed.\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n\nint process_file(int print) {\n  FILE *f \u003d fopen(\"example.txt\", \"r\");\n  if (!f) {\n    perror(\"fopen() failed\");\n    return 1;\n  }\n\n  if (print) {\n    char buffer[256];\n    while (fgets(buffer, 256, f)) {\n      printf(\"%s\", buffer);\n    }\n  }\n\n  if (fclose(f) \u003d\u003d EOF) { // Compliant: file associated with `f` is closed only once.\n    return 1;\n  }\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch3\u003eGoing the extra mile\u003c/h3\u003e\n\u003cp\u003eUsing C++\u0027s \u003cem\u003eRAII\u003c/em\u003e idiom can mitigate these \"double-close\" issues.\u003c/p\u003e\n\u003cp\u003eFollowing this idiom, one would create a class that manages the underlying file by opening it when the object is constructed and closing it when\nthe object is destroyed, effectively using a constructor-destructor pair as a \"do-undo\"-mechanism.\u003c/p\u003e\n\u003cp\u003eAn exemplary class that manages a pointer to a file is shown in what follows.\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;cstdio\u0026gt;\n#include \u0026lt;fstream\u0026gt;\n#include \u0026lt;string\u0026gt;\n#include \u0026lt;utility\u0026gt;\n\n// Although `std::fstream` should be preferred, if available, a file stream\n// managed by this `File` class cannot suffer from \"double-close\" issues.\nclass File {\n  FILE *f;\n\npublic:\n  // Opens file stream on construction.\n  File(std::string const \u0026amp;path, std::string const \u0026amp;modes)\n      : f(fopen(path.c_str(), modes.c_str())) {\n    if (!f) {\n      throw std::ios_base::failure(\"fopen() failed\");\n    }\n  }\n  // Will close the file stream upon destruction.\n  ~File() {\n    // Here we are fine with `std::terminate` being called here in case `close`\n    // throws and exception.\n    close();\n  }\n  // Allow only one owner of a file, disallow copy operations.\n  File(const File \u0026amp;other) \u003d delete;\n  File \u0026amp;operator\u003d(const File \u0026amp;other) \u003d delete;\n  // Moving a file to a different scope shall be allowed.\n  File(File \u0026amp;\u0026amp;other) : f(std::exchange(other.f, nullptr)) {}\n  File \u0026amp;operator\u003d(File \u0026amp;\u0026amp;other) {\n    if (this !\u003d \u0026amp;other) {\n      // In case of non-self-assignment, close the currently managed file and\n      // \"steal\" the other\u0027s file.\n      close();\n      f \u003d std::exchange(other.f, nullptr);\n    }\n    return *this;\n  }\n  // Allow file to be closed explicitly.\n  void close() {\n    if (f !\u003d nullptr \u0026amp;\u0026amp; fclose(std::exchange(f, nullptr)) \u003d\u003d EOF) {\n      throw std::ios_base::failure(\"fclose() failed\");\n    }\n  }\n  // Allow access to underlying file via `f`.\n  FILE *handle() { return f; }\n  // Release `f`, i.e., stop managing it.\n  FILE *release() { return std::exchange(f, nullptr); }\n};\n\nvoid file_user() {\n  File fh{\"example.txt\", \"r\"};\n  FILE *f \u003d fh.handle();\n  // Use `f` for the desired file operation(s).\n  //\n  // The file stream managed by `fh` will be automatically closed when `fh` goes\n  // out of scope at the end of this function.\n}\n\u003c/pre\u003e\n\u003cp\u003eWith the design shown above, it is still possible to \"double-close\" a file by passing the raw \u003ccode\u003eFILE\u003c/code\u003e pointer obtained by a call to\n\u003ccode\u003eFile::handle\u003c/code\u003e to \u003ccode\u003efclose\u003c/code\u003e (e.g. \u003ccode\u003efclose(f.handle())\u003c/code\u003e). However, this design reduces the risk of such occurrence by\neliminating the need for manually closing files. If even the reduced possibility of \"double-close\" is still a concern, the function member\n\u003ccode\u003eFile::handle\u003c/code\u003e should be removed and any required file operations should be wrapped by the \u003ccode\u003eFile\u003c/code\u003e class.\u003c/p\u003e\n\u003cp\u003eIf falling back to low-level file operations is not necessary, one should prefer \u003ccode\u003estd::fstream\u003c/code\u003e.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/QdUxBQ\"\u003eFIO46-C. Do not access a closed file\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:c:S3520} addresses \"double-free\" memory issues \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eUsing the value of a pointer to a \u003ccode\u003eFILE\u003c/code\u003e object after the associated file is closed is undefined behavior.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eOnce a file has been closed, its corresponding \u003ccode\u003eFILE*\u003c/code\u003e typed variable becomes invalid and the stream may no longer be accessed through\nthis variable. In particular, a pointer to a \u003ccode\u003eFILE\u003c/code\u003e object may not be passed to \u003ccode\u003efclose\u003c/code\u003e more than once.\u003c/p\u003e\n\u003cp\u003eUsing the value of a pointer to a \u003ccode\u003eFILE\u003c/code\u003e object after the associated file is closed results in undefined behavior.\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n\nint process_file(int print) {\n  FILE *f \u003d fopen(\"example.txt\", \"r\");\n  if (!f) {\n    perror(\"fopen() failed\");\n    return 1;\n  }\n\n  if (print) {\n    char buffer[256];\n    while (fgets(buffer, 256, f)) {\n      printf(\"%s\", buffer);\n    }\n    fclose(f);\n  }\n\n  // Further processing ...\n\n  fclose(f); // Noncompliant: file associated with `f` might already be closed.\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch2\u003eWhat is the potential impact?\u003c/h2\u003e\n\u003cp\u003eIf a pointer to a \u003ccode\u003eFILE\u003c/code\u003e object is used after the associated file is closed, the behavior of the application is undefined.\u003c/p\u003e\n\u003cp\u003eWhen a program comprises undefined behavior, the compiler no longer needs to adhere to the language standard, and the program has no meaning\nassigned to it. The application might just crash, but in the worst case, the application may appear to execute correctly, while losing data or\nproducing incorrect results.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eDo not use the value of a pointer to a \u003ccode\u003eFILE\u003c/code\u003e object after the associated file has been closed.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n\nint process_file(int print) {\n  FILE *f \u003d fopen(\"example.txt\", \"r\");\n  if (!f) {\n    perror(\"fopen() failed\");\n    return 1;\n  }\n\n  if (print) {\n    char buffer[256];\n    while (fgets(buffer, 256, f)) {\n      printf(\"%s\", buffer);\n    }\n    fclose(f);\n  }\n\n  fclose(f); // Noncompliant: file associated with `f` might already be closed.\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n\nint process_file(int print) {\n  FILE *f \u003d fopen(\"example.txt\", \"r\");\n  if (!f) {\n    perror(\"fopen() failed\");\n    return 1;\n  }\n\n  if (print) {\n    char buffer[256];\n    while (fgets(buffer, 256, f)) {\n      printf(\"%s\", buffer);\n    }\n  }\n\n  if (fclose(f) \u003d\u003d EOF) { // Compliant: file associated with `f` is closed only once.\n    return 1;\n  }\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch3\u003eGoing the extra mile\u003c/h3\u003e\n\u003cp\u003eUsing C++\u0027s \u003cem\u003eRAII\u003c/em\u003e idiom can mitigate these \"double-close\" issues.\u003c/p\u003e\n\u003cp\u003eFollowing this idiom, one would create a class that manages the underlying file by opening it when the object is constructed and closing it when\nthe object is destroyed, effectively using a constructor-destructor pair as a \"do-undo\"-mechanism.\u003c/p\u003e\n\u003cp\u003eAn exemplary class that manages a pointer to a file is shown in what follows.\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;cstdio\u0026gt;\n#include \u0026lt;fstream\u0026gt;\n#include \u0026lt;string\u0026gt;\n#include \u0026lt;utility\u0026gt;\n\n// Although `std::fstream` should be preferred, if available, a file stream\n// managed by this `File` class cannot suffer from \"double-close\" issues.\nclass File {\n  FILE *f;\n\npublic:\n  // Opens file stream on construction.\n  File(std::string const \u0026amp;path, std::string const \u0026amp;modes)\n      : f(fopen(path.c_str(), modes.c_str())) {\n    if (!f) {\n      throw std::ios_base::failure(\"fopen() failed\");\n    }\n  }\n  // Will close the file stream upon destruction.\n  ~File() {\n    // Here we are fine with `std::terminate` being called here in case `close`\n    // throws and exception.\n    close();\n  }\n  // Allow only one owner of a file, disallow copy operations.\n  File(const File \u0026amp;other) \u003d delete;\n  File \u0026amp;operator\u003d(const File \u0026amp;other) \u003d delete;\n  // Moving a file to a different scope shall be allowed.\n  File(File \u0026amp;\u0026amp;other) : f(std::exchange(other.f, nullptr)) {}\n  File \u0026amp;operator\u003d(File \u0026amp;\u0026amp;other) {\n    if (this !\u003d \u0026amp;other) {\n      // In case of non-self-assignment, close the currently managed file and\n      // \"steal\" the other\u0027s file.\n      close();\n      f \u003d std::exchange(other.f, nullptr);\n    }\n    return *this;\n  }\n  // Allow file to be closed explicitly.\n  void close() {\n    if (f !\u003d nullptr \u0026amp;\u0026amp; fclose(std::exchange(f, nullptr)) \u003d\u003d EOF) {\n      throw std::ios_base::failure(\"fclose() failed\");\n    }\n  }\n  // Allow access to underlying file via `f`.\n  FILE *handle() { return f; }\n  // Release `f`, i.e., stop managing it.\n  FILE *release() { return std::exchange(f, nullptr); }\n};\n\nvoid file_user() {\n  File fh{\"example.txt\", \"r\"};\n  FILE *f \u003d fh.handle();\n  // Use `f` for the desired file operation(s).\n  //\n  // The file stream managed by `fh` will be automatically closed when `fh` goes\n  // out of scope at the end of this function.\n}\n\u003c/pre\u003e\n\u003cp\u003eWith the design shown above, it is still possible to \"double-close\" a file by passing the raw \u003ccode\u003eFILE\u003c/code\u003e pointer obtained by a call to\n\u003ccode\u003eFile::handle\u003c/code\u003e to \u003ccode\u003efclose\u003c/code\u003e (e.g. \u003ccode\u003efclose(f.handle())\u003c/code\u003e). However, this design reduces the risk of such occurrence by\neliminating the need for manually closing files. If even the reduced possibility of \"double-close\" is still a concern, the function member\n\u003ccode\u003eFile::handle\u003c/code\u003e should be removed and any required file operations should be wrapped by the \u003ccode\u003eFile\u003c/code\u003e class.\u003c/p\u003e\n\u003cp\u003eIf falling back to low-level file operations is not necessary, one should prefer \u003ccode\u003estd::fstream\u003c/code\u003e.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/QdUxBQ\"\u003eFIO46-C. Do not access a closed file\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:c:S3520} addresses \"double-free\" memory issues \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "cert",
      "symbolic-execution"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S2259",
    "name": "Null pointers should not be dereferenced",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003cp\u003eDereferencing a null pointer results in undefined behavior.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eA pointer to null, also known as a null pointer, is created by initializing a pointer object to \u003ccode\u003e0\u003c/code\u003e, \u003ccode\u003eNULL\u003c/code\u003e, or in the case\nof C++ \u003ccode\u003enullptr\u003c/code\u003e. A null pointer does neither point to an object nor to valid memory, and as a consequence dereferencing or accessing the\nmemory pointed by such a pointer is undefined behavior.\u003c/p\u003e\n\u003cpre\u003e\nint deref() {\n  int* ptr \u003d 0;\n  return *ptr; // Noncompliant: deference of a null pointer\n}\n\u003c/pre\u003e\n\u003cp\u003eIn addition to using the \u003ccode\u003e*\u003c/code\u003e operator, accessing a member of a structure (using \u003ccode\u003e→\u003c/code\u003e) or an element of an array (using\n\u003ccode\u003e[]\u003c/code\u003e) also leads to dereference of the pointer, and causes undefined behavior if performed on a pointer to null.\u003c/p\u003e\n\u003cpre\u003e\nint subscript() {\n  int* ptr \u003d 0;\n  return ptr[2]; // Noncompliant: subscript operator used on null pointer\n}\n\u003c/pre\u003e\n\u003cpre\u003e\nstruct Aggregate {\n  int x;\n  int y;\n};\n\nint memberAccess() {\n  struct Aggregate* ptr \u003d 0;\n  return ptr-\u0026gt;x; // Noncompliant: member access on a null pointer\n}\n\u003c/pre\u003e\n\u003cp\u003eFinally, invoking a function pointer that holds a null value, dereferences the pointer, and too results in undefined behavior.\u003c/p\u003e\n\u003cpre\u003e\nvoid call() {\n  void (*func)(int) \u003d NULL; // func is a pointer to a function\n  func(10); // Noncompliant: the invocation of a null function pointer\n}\n\u003c/pre\u003e\n\u003ch2\u003eWhat is the potential impact?\u003c/h2\u003e\n\u003cp\u003eThe behavior of a program that dereferences a null pointer is undefined. In that case, the compiler no longer needs to adhere to the language\nstandard and the program has no meaning assigned to it.\u003c/p\u003e\n\u003cp\u003eIn practice, dereferencing a null pointer may lead to program crashes, or the application may appear to execute correctly while losing data or\nproducing incorrect results.\u003c/p\u003e\n\u003cp\u003eBesides affecting the application’s availability, null pointer dereferences may lead to code execution, in rare circumstances. If null is\nequivalent to the \u003ccode\u003e0x0\u003c/code\u003e memory address that can be accessed by privileged code, writing, and reading memory is possible, which compromises\nthe integrity and confidentiality of the application.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eEnsure that any pointer that is dereferenced by the program \u003cem\u003eis not\u003c/em\u003e null.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nchar *p1 \u003d ... ;\nif (p1 \u003d\u003d NULL \u0026amp;\u0026amp; *p1 \u003d\u003d \u0027\\t\u0027) { // Noncompliant: p1 will be dereferenced IFF it is null\n  // ...\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nchar *p1 \u003d ... ;\nif (p1 !\u003d NULL \u0026amp;\u0026amp; *p1 \u003d\u003d \u0027\\t\u0027) { // Compliant: *p1 cannot be evaluated if p1 is NULL\n  // ...\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\nchar *p2 \u003d ... ;\nif (p2 !\u003d NULL) {\n    // ...\n}\np2[2] \u003d \u0027\\t\u0027; // Noncompliant: potential null-dereference\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\nchar *p2 \u003d ... ;\nif (p2 !\u003d NULL) {\n    // ...\n  p2[2] \u003d \u0027\\t\u0027; // Compliant: p2 is known to be non-null\n}\n\u003c/pre\u003e\n\u003ch3\u003eGoing the extra mile\u003c/h3\u003e\n\u003cp\u003eIn C++, it is preferred to use reference parameters (\u003ccode\u003eType const\u0026amp;\u003c/code\u003e or \u003ccode\u003eType\u0026amp;\u003c/code\u003e), or pass objects by value\n(\u003ccode\u003eType\u003c/code\u003e), instead of a pointer (\u003ccode\u003eType const*\u003c/code\u003e or \u003ccode\u003eType*\u003c/code\u003e), if the argument is expected to never be null.\u003c/p\u003e\n\u003cpre\u003e\n// Precondition: graph !\u003d null\nbool isDAG(Graph const* graph);\n\u003c/pre\u003e\n\u003cp\u003eThe preferred signature would be:\u003c/p\u003e\n\u003cpre\u003e\nbool isDAG(Graph const\u0026amp; graph);\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/QdcxBQ\"\u003eEXP34-C.Do not dereference null pointers\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/476\"\u003e476 NULL Pointer Dereference\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f16-for-in-parameters-pass-cheaply-copied-types-by-value-and-others-by-reference-to-const\"\u003eF.16: For \"in\" parameters, pass cheaply-copied types by value and others by reference to \u003ccode\u003econst\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f17-for-in-out-parameters-pass-by-reference-to-non-const\"\u003eF.17:\n  For \"in-out\" parameters, pass by reference to non-\u003ccode\u003econst\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:c:S3807} detects calls to C library functions that require valid, non-null pointers with null pointer arguments \u003c/li\u003e\n  \u003cli\u003e {rule:c:S2637} detects uses of null pointers as arguments for parameters that are annotated with \u003ccode\u003enonnull\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eDereferencing a null pointer results in undefined behavior.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eA pointer to null, also known as a null pointer, is created by initializing a pointer object to \u003ccode\u003e0\u003c/code\u003e, \u003ccode\u003eNULL\u003c/code\u003e, or in the case\nof C++ \u003ccode\u003enullptr\u003c/code\u003e. A null pointer does neither point to an object nor to valid memory, and as a consequence dereferencing or accessing the\nmemory pointed by such a pointer is undefined behavior.\u003c/p\u003e\n\u003cpre\u003e\nint deref() {\n  int* ptr \u003d 0;\n  return *ptr; // Noncompliant: deference of a null pointer\n}\n\u003c/pre\u003e\n\u003cp\u003eIn addition to using the \u003ccode\u003e*\u003c/code\u003e operator, accessing a member of a structure (using \u003ccode\u003e→\u003c/code\u003e) or an element of an array (using\n\u003ccode\u003e[]\u003c/code\u003e) also leads to dereference of the pointer, and causes undefined behavior if performed on a pointer to null.\u003c/p\u003e\n\u003cpre\u003e\nint subscript() {\n  int* ptr \u003d 0;\n  return ptr[2]; // Noncompliant: subscript operator used on null pointer\n}\n\u003c/pre\u003e\n\u003cpre\u003e\nstruct Aggregate {\n  int x;\n  int y;\n};\n\nint memberAccess() {\n  struct Aggregate* ptr \u003d 0;\n  return ptr-\u0026gt;x; // Noncompliant: member access on a null pointer\n}\n\u003c/pre\u003e\n\u003cp\u003eFinally, invoking a function pointer that holds a null value, dereferences the pointer, and too results in undefined behavior.\u003c/p\u003e\n\u003cpre\u003e\nvoid call() {\n  void (*func)(int) \u003d NULL; // func is a pointer to a function\n  func(10); // Noncompliant: the invocation of a null function pointer\n}\n\u003c/pre\u003e\n\u003ch2\u003eWhat is the potential impact?\u003c/h2\u003e\n\u003cp\u003eThe behavior of a program that dereferences a null pointer is undefined. In that case, the compiler no longer needs to adhere to the language\nstandard and the program has no meaning assigned to it.\u003c/p\u003e\n\u003cp\u003eIn practice, dereferencing a null pointer may lead to program crashes, or the application may appear to execute correctly while losing data or\nproducing incorrect results.\u003c/p\u003e\n\u003cp\u003eBesides affecting the application’s availability, null pointer dereferences may lead to code execution, in rare circumstances. If null is\nequivalent to the \u003ccode\u003e0x0\u003c/code\u003e memory address that can be accessed by privileged code, writing, and reading memory is possible, which compromises\nthe integrity and confidentiality of the application.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eEnsure that any pointer that is dereferenced by the program \u003cem\u003eis not\u003c/em\u003e null.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nchar *p1 \u003d ... ;\nif (p1 \u003d\u003d NULL \u0026amp;\u0026amp; *p1 \u003d\u003d \u0027\\t\u0027) { // Noncompliant: p1 will be dereferenced IFF it is null\n  // ...\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nchar *p1 \u003d ... ;\nif (p1 !\u003d NULL \u0026amp;\u0026amp; *p1 \u003d\u003d \u0027\\t\u0027) { // Compliant: *p1 cannot be evaluated if p1 is NULL\n  // ...\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\nchar *p2 \u003d ... ;\nif (p2 !\u003d NULL) {\n    // ...\n}\np2[2] \u003d \u0027\\t\u0027; // Noncompliant: potential null-dereference\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\nchar *p2 \u003d ... ;\nif (p2 !\u003d NULL) {\n    // ...\n  p2[2] \u003d \u0027\\t\u0027; // Compliant: p2 is known to be non-null\n}\n\u003c/pre\u003e\n\u003ch3\u003eGoing the extra mile\u003c/h3\u003e\n\u003cp\u003eIn C++, it is preferred to use reference parameters (\u003ccode\u003eType const\u0026amp;\u003c/code\u003e or \u003ccode\u003eType\u0026amp;\u003c/code\u003e), or pass objects by value\n(\u003ccode\u003eType\u003c/code\u003e), instead of a pointer (\u003ccode\u003eType const*\u003c/code\u003e or \u003ccode\u003eType*\u003c/code\u003e), if the argument is expected to never be null.\u003c/p\u003e\n\u003cpre\u003e\n// Precondition: graph !\u003d null\nbool isDAG(Graph const* graph);\n\u003c/pre\u003e\n\u003cp\u003eThe preferred signature would be:\u003c/p\u003e\n\u003cpre\u003e\nbool isDAG(Graph const\u0026amp; graph);\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/QdcxBQ\"\u003eEXP34-C.Do not dereference null pointers\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/476\"\u003e476 NULL Pointer Dereference\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f16-for-in-parameters-pass-cheaply-copied-types-by-value-and-others-by-reference-to-const\"\u003eF.16: For \"in\" parameters, pass cheaply-copied types by value and others by reference to \u003ccode\u003econst\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f17-for-in-out-parameters-pass-by-reference-to-non-const\"\u003eF.17:\n  For \"in-out\" parameters, pass by reference to non-\u003ccode\u003econst\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:c:S3807} detects calls to C library functions that require valid, non-null pointers with null pointer arguments \u003c/li\u003e\n  \u003cli\u003e {rule:c:S2637} detects uses of null pointers as arguments for parameters that are annotated with \u003ccode\u003enonnull\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "cert",
      "cwe",
      "symbolic-execution"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S922",
    "name": "Evaluation of the operand to the sizeof operator shall not contain side effects",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThis rule is a strict implementation of a MISRA (Motor Industry Software Reliability Association) rule. MISRA defines best practices for developing\nsafety-critical software. You can learn more about this rule in the MISRA documents referenced below.\u003c/p\u003e\n\u003cp\u003eIf you are not concerned with MISRA compliance or with safety-critical software, you might consider using rule {rule:c:S3135} instead ; it\ntargets the same kind of issue for general-purpose software.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C 2004, 12.3 - The sizeof operator shall not be used on expressions that contain side effects. \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2008, 5-3-4 - Evaluation of the operand to the sizeof operator shall not contain side effects. \u003c/li\u003e\n  \u003cli\u003e MISRA C 2012, 13.6 - The operand of the sizeof operator shall not contain any expression which has potential side effects \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThis rule is a strict implementation of a MISRA (Motor Industry Software Reliability Association) rule. MISRA defines best practices for developing\nsafety-critical software. You can learn more about this rule in the MISRA documents referenced below.\u003c/p\u003e\n\u003cp\u003eIf you are not concerned with MISRA compliance or with safety-critical software, you might consider using rule {rule:c:S3135} instead ; it\ntargets the same kind of issue for general-purpose software.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C 2004, 12.3 - The sizeof operator shall not be used on expressions that contain side effects. \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2008, 5-3-4 - Evaluation of the operand to the sizeof operator shall not contain side effects. \u003c/li\u003e\n  \u003cli\u003e MISRA C 2012, 13.6 - The operand of the sizeof operator shall not contain any expression which has potential side effects \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "misra-c++2008"
    ],
    "deprecatedKeys": [
      "c:SideEffectInSizeOf"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S802",
    "name": "\"typedef\" names should be unique identifiers",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eReusing a \u003ccode\u003etypedef\u003c/code\u003e name either as another \u003ccode\u003etypedef\u003c/code\u003e name or for any other purpose may lead to developer confusion.\u003c/p\u003e\n\u003cp\u003eThe same \u003ccode\u003etypedef\u003c/code\u003e shall not be duplicated anywhere in the project, even if the declarations are identical.\u003c/p\u003e\n\u003cp\u003eNote that where the type definition is made in a header file, and that header file is included in multiple source files, this rule is not\nviolated.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n{\n  typedef unsigned char uint8_t;\n}\n\n{\n  typedef unsigned char uint8_t; // Noncompliant, redefinition\n}\n\n{\n  unsigned char uint8_t; // Noncompliant, reuse of uint8_t for another purpose\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\ntypedef unsigned char uint8_t;\n{\n}\n\n{\n}\n\n{\n  unsigned char myChar;\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 5.3 - A typedef name shall be a unique identifier. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 2-10-3 - A typedef name (including qualification, if any) shall be a unique identifier. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eReusing a \u003ccode\u003etypedef\u003c/code\u003e name either as another \u003ccode\u003etypedef\u003c/code\u003e name or for any other purpose may lead to developer confusion.\u003c/p\u003e\n\u003cp\u003eThe same \u003ccode\u003etypedef\u003c/code\u003e shall not be duplicated anywhere in the project, even if the declarations are identical.\u003c/p\u003e\n\u003cp\u003eNote that where the type definition is made in a header file, and that header file is included in multiple source files, this rule is not\nviolated.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n{\n  typedef unsigned char uint8_t;\n}\n\n{\n  typedef unsigned char uint8_t; // Noncompliant, redefinition\n}\n\n{\n  unsigned char uint8_t; // Noncompliant, reuse of uint8_t for another purpose\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\ntypedef unsigned char uint8_t;\n{\n}\n\n{\n}\n\n{\n  unsigned char myChar;\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 5.3 - A typedef name shall be a unique identifier. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 2-10-3 - A typedef name (including qualification, if any) shall be a unique identifier. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "based-on-misra",
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S923",
    "name": "Functions should not be defined with a variable number of arguments",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003ePassing arguments via an ellipsis bypasses the type checking performed by the compiler. Additionally, passing an argument with non-POD class type\nleads to undefined behavior. Note that the rule specifies \"defined\" (and not \"declared\") so as to permit the use of existing library functions.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid MyPrintf ( char_t * pFormat, ... )\t// Noncompliant\n{\n  // ...\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 16.1 - Functions shall not be defined with a variable number of arguments. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 8-4-1 - Functions shall not be defined using the ellipsis notation. \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/5ns-BQ\"\u003eCERT, DCL50-CPP.\u003c/a\u003e - Do not define a C-style variadic function \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#-es34-dont-define-a-c-style-variadic-function\"\u003eES.34: Don’t\n  define a (C-style) variadic function\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f55-dont-use-va_arg-arguments\"\u003eF.55: Don’t use\n  \u003ccode\u003eva_arg\u003c/code\u003e arguments\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003ePassing arguments via an ellipsis bypasses the type checking performed by the compiler. Additionally, passing an argument with non-POD class type\nleads to undefined behavior. Note that the rule specifies \"defined\" (and not \"declared\") so as to permit the use of existing library functions.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid MyPrintf ( char_t * pFormat, ... )\t// Noncompliant\n{\n  // ...\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 16.1 - Functions shall not be defined with a variable number of arguments. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 8-4-1 - Functions shall not be defined using the ellipsis notation. \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/5ns-BQ\"\u003eCERT, DCL50-CPP.\u003c/a\u003e - Do not define a C-style variadic function \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#-es34-dont-define-a-c-style-variadic-function\"\u003eES.34: Don’t\n  define a (C-style) variadic function\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f55-dont-use-va_arg-arguments\"\u003eF.55: Don’t use\n  \u003ccode\u003eva_arg\u003c/code\u003e arguments\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "cert",
      "misra-c++2008",
      "misra-c2004",
      "pitfall"
    ],
    "deprecatedKeys": [
      "c:FunctionEllipsis"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S128",
    "name": "Switch cases should end with an unconditional \"break\" statement",
    "defaultSeverity": "BLOCKER",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhen the execution is not explicitly terminated at the end of a switch case, it continues to execute the statements of the following case. While\nthis is sometimes intentional, it often is a mistake which leads to unexpected behavior.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nswitch (myVariable) {\n  case 1:\n    foo();\n    break;\n  case 2:  // Both \u0027doSomething()\u0027 and \u0027doSomethingElse()\u0027 will be executed. Is it on purpose ?\n    doSomething();\n  default:\n    doSomethingElse();\n    break;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nswitch (myVariable) {\n  case 1:\n    foo();\n    break;\n  case 2:\n    doSomething();\n    break;\n  default:\n    doSomethingElse();\n    break;\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThis rule is relaxed in the following cases:\u003c/p\u003e\n\u003cpre\u003e\nswitch (myVariable) {\n  case 0:                                // Empty case used to specify the same behavior for a group of cases.\n  case 1:\n    doSomething();\n    break;\n  case 2:                                // Use of return statement\n    return;\n  case 3:                                // Use of throw statement\n    throw 1;\n  case 4:                                // Use of an attribute to make explicit the fact that we want to fall through the next case\n    doSomething();\n    [[fallthrough]];\n  case 5:                                // Use of continue statement, if the switch is inside a loop\n    continue;\n  default:                               // For the last case, use of break statement is optional\n    doSomethingElse();\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 15.0 - The MISRA C \u003cem\u003eswitch\u003c/em\u003e syntax shall be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2004, 15.2 - An unconditional break statement shall terminate every non-empty switch clause \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 6-4-3 - A switch statement shall be a well-formed switch statement. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 6-4-5 - An unconditional throw or break statement shall terminate every non-empty switch-clause \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 16.1 - All switch statements shall be well-formed \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 16.3 - An unconditional break statement shall terminate every switch-clause \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/484\"\u003eMITRE, CWE-484\u003c/a\u003e - Omitted Break Statement in Switch \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/ldYxBQ\"\u003eCERT, MSC17-C.\u003c/a\u003e - Finish every set of statements associated with a case label with a\n  break statement \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhen the execution is not explicitly terminated at the end of a switch case, it continues to execute the statements of the following case. While\nthis is sometimes intentional, it often is a mistake which leads to unexpected behavior.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nswitch (myVariable) {\n  case 1:\n    foo();\n    break;\n  case 2:  // Both \u0027doSomething()\u0027 and \u0027doSomethingElse()\u0027 will be executed. Is it on purpose ?\n    doSomething();\n  default:\n    doSomethingElse();\n    break;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nswitch (myVariable) {\n  case 1:\n    foo();\n    break;\n  case 2:\n    doSomething();\n    break;\n  default:\n    doSomethingElse();\n    break;\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThis rule is relaxed in the following cases:\u003c/p\u003e\n\u003cpre\u003e\nswitch (myVariable) {\n  case 0:                                // Empty case used to specify the same behavior for a group of cases.\n  case 1:\n    doSomething();\n    break;\n  case 2:                                // Use of return statement\n    return;\n  case 3:                                // Use of throw statement\n    throw 1;\n  case 4:                                // Use of an attribute to make explicit the fact that we want to fall through the next case\n    doSomething();\n    [[fallthrough]];\n  case 5:                                // Use of continue statement, if the switch is inside a loop\n    continue;\n  default:                               // For the last case, use of break statement is optional\n    doSomethingElse();\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 15.0 - The MISRA C \u003cem\u003eswitch\u003c/em\u003e syntax shall be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2004, 15.2 - An unconditional break statement shall terminate every non-empty switch clause \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 6-4-3 - A switch statement shall be a well-formed switch statement. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 6-4-5 - An unconditional throw or break statement shall terminate every non-empty switch-clause \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 16.1 - All switch statements shall be well-formed \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 16.3 - An unconditional break statement shall terminate every switch-clause \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/484\"\u003eMITRE, CWE-484\u003c/a\u003e - Omitted Break Statement in Switch \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/ldYxBQ\"\u003eCERT, MSC17-C.\u003c/a\u003e - Finish every set of statements associated with a case label with a\n  break statement \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "based-on-misra",
      "cert",
      "cwe",
      "suspicious"
    ],
    "deprecatedKeys": [
      "c:NonEmptyCaseWithoutBreak"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S920",
    "name": "Switch statement conditions should not have essentially boolean type",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhen there is only a single condition to test, you have the option of using either a \u003ccode\u003eswitch\u003c/code\u003e statement or an \u003ccode\u003eif\u003c/code\u003e-\u003ccode\u003eelse\nif\u003c/code\u003e-\u003ccode\u003eelse\u003c/code\u003e statement. For a larger set of potential values, a \u003ccode\u003eswitch\u003c/code\u003e can be easier to read, but when the condition being\ntested is essentially boolean, then an \u003ccode\u003eif\u003c/code\u003e/\u003ccode\u003eelse\u003c/code\u003e statement should be used instead.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n_Bool b \u003d p \u0026gt; 0;\nswitch (b) { // Noncompliant\n...\n}\nswitch (x \u003d\u003d 0) { // Noncompliant\n...\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n_Bool b \u003d p \u0026gt; 0;\nif (b) {\n...\n} else {\n...\n}\nif (x \u003d\u003d 0) {\n...\n} else {\n...\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 15.4 - A switch expression shall not represent a value that is effectively Boolean \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2008, 6-4-7 - The condition of a switch statement shall not have bool type \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 16.7 - A switch-expression shall not have essentially Boolean type \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhen there is only a single condition to test, you have the option of using either a \u003ccode\u003eswitch\u003c/code\u003e statement or an \u003ccode\u003eif\u003c/code\u003e-\u003ccode\u003eelse\nif\u003c/code\u003e-\u003ccode\u003eelse\u003c/code\u003e statement. For a larger set of potential values, a \u003ccode\u003eswitch\u003c/code\u003e can be easier to read, but when the condition being\ntested is essentially boolean, then an \u003ccode\u003eif\u003c/code\u003e/\u003ccode\u003eelse\u003c/code\u003e statement should be used instead.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n_Bool b \u003d p \u0026gt; 0;\nswitch (b) { // Noncompliant\n...\n}\nswitch (x \u003d\u003d 0) { // Noncompliant\n...\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n_Bool b \u003d p \u0026gt; 0;\nif (b) {\n...\n} else {\n...\n}\nif (x \u003d\u003d 0) {\n...\n} else {\n...\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 15.4 - A switch expression shall not represent a value that is effectively Boolean \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2008, 6-4-7 - The condition of a switch statement shall not have bool type \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 16.7 - A switch-expression shall not have essentially Boolean type \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "misra-c++2008",
      "misra-c2004",
      "misra-c2012"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S126",
    "name": "\"if ... else if\" constructs should end with \"else\" clauses",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThis rule applies whenever an \u003ccode\u003eif\u003c/code\u003e statement is followed by one or more \u003ccode\u003eelse if\u003c/code\u003e statements; the final \u003ccode\u003eelse if\u003c/code\u003e\nshould be followed by an \u003ccode\u003eelse\u003c/code\u003e statement.\u003c/p\u003e\n\u003cp\u003eThe requirement for a final \u003ccode\u003eelse\u003c/code\u003e statement is defensive programming.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003eelse\u003c/code\u003e statement should either take appropriate action or contain a suitable comment as to why no action is taken. This is\nconsistent with the requirement to have a final \u003ccode\u003edefault\u003c/code\u003e clause in a \u003ccode\u003eswitch\u003c/code\u003e statement.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nif (x \u003d\u003d 0) {\n  doSomething();\n} else if (x \u003d\u003d 1) {\n  doSomethingElse();\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nif (x \u003d\u003d 0) {\n  doSomething();\n} else if (x \u003d\u003d 1) {\n  doSomethingElse();\n} else {\n  error();\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eWhen all branches of an \u003ccode\u003eif\u003c/code\u003e-\u003ccode\u003eelse if\u003c/code\u003e end with \u003ccode\u003ereturn\u003c/code\u003e, \u003ccode\u003ebreak\u003c/code\u003e or \u003ccode\u003ethrow\u003c/code\u003e, the code that\ncomes after the \u003ccode\u003eif\u003c/code\u003e implicitly behaves as if it was in an \u003ccode\u003eelse\u003c/code\u003e clause. This rule will therefore ignore that case.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 14.10 - All if…​else if constructs shall be terminated with an else clause. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 6-4-2 - All if…​else if constructs shall be terminated with an else clause. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 15.7 - All if…​else if constructs shall be terminated with an else statement \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/RtYxBQ\"\u003eCERT, MSC01-C.\u003c/a\u003e - Strive for logical completeness \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThis rule applies whenever an \u003ccode\u003eif\u003c/code\u003e statement is followed by one or more \u003ccode\u003eelse if\u003c/code\u003e statements; the final \u003ccode\u003eelse if\u003c/code\u003e\nshould be followed by an \u003ccode\u003eelse\u003c/code\u003e statement.\u003c/p\u003e\n\u003cp\u003eThe requirement for a final \u003ccode\u003eelse\u003c/code\u003e statement is defensive programming.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003eelse\u003c/code\u003e statement should either take appropriate action or contain a suitable comment as to why no action is taken. This is\nconsistent with the requirement to have a final \u003ccode\u003edefault\u003c/code\u003e clause in a \u003ccode\u003eswitch\u003c/code\u003e statement.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nif (x \u003d\u003d 0) {\n  doSomething();\n} else if (x \u003d\u003d 1) {\n  doSomethingElse();\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nif (x \u003d\u003d 0) {\n  doSomething();\n} else if (x \u003d\u003d 1) {\n  doSomethingElse();\n} else {\n  error();\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eWhen all branches of an \u003ccode\u003eif\u003c/code\u003e-\u003ccode\u003eelse if\u003c/code\u003e end with \u003ccode\u003ereturn\u003c/code\u003e, \u003ccode\u003ebreak\u003c/code\u003e or \u003ccode\u003ethrow\u003c/code\u003e, the code that\ncomes after the \u003ccode\u003eif\u003c/code\u003e implicitly behaves as if it was in an \u003ccode\u003eelse\u003c/code\u003e clause. This rule will therefore ignore that case.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 14.10 - All if…​else if constructs shall be terminated with an else clause. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 6-4-2 - All if…​else if constructs shall be terminated with an else clause. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 15.7 - All if…​else if constructs shall be terminated with an else statement \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/RtYxBQ\"\u003eCERT, MSC01-C.\u003c/a\u003e - Strive for logical completeness \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "based-on-misra",
      "cert"
    ],
    "deprecatedKeys": [
      "c:ElseIfWithoutElse"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S127",
    "name": "\"for\" loop stop conditions should be invariant",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eA \u003ccode\u003efor\u003c/code\u003e loop stop condition should test the loop counter against an invariant value (i.e. one that is true at both the beginning and\nending of every loop iteration). Ideally, this means that the stop condition is set to a local variable just before the loop begins.\u003c/p\u003e\n\u003cp\u003eStop conditions that are not invariant are slightly less efficient, as well as being difficult to understand and maintain, and likely lead to the\nintroduction of errors in the future.\u003c/p\u003e\n\u003cp\u003eThis rule tracks three types of non-invariant stop conditions:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e When the loop counters are updated in the body of the \u003ccode\u003efor\u003c/code\u003e loop \u003c/li\u003e\n  \u003cli\u003e When the stop condition depend upon a method call \u003c/li\u003e\n  \u003cli\u003e When the stop condition depends on an object property, since such properties could change during the execution of the loop. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nfor (int i \u003d 0; i \u0026lt; 10; i++) {\n  ...\n  i \u003d i - 1; // Noncompliant\n  ...\n}\n\nfor (int i \u003d 0; i \u0026lt; getMaximumNumber(); i++) {  // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nfor (int i \u003d 0; i \u0026lt; 10; i++) {\n  ...\n}\nint stopCondition \u003d getMaximumNumber();\nfor (int i \u003d 0; i \u0026lt; stopCondition; i++) {\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 13.6 - Numeric variables being used within a \u003cem\u003efor\u003c/em\u003e loop for iteration counting shall not be modified in the body of the\n  loop. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 6-5-3 - The \u003cem\u003eloop-counter\u003c/em\u003e shall not be modified within \u003cem\u003econdition\u003c/em\u003e or \u003cem\u003estatement\u003c/em\u003e. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eA \u003ccode\u003efor\u003c/code\u003e loop stop condition should test the loop counter against an invariant value (i.e. one that is true at both the beginning and\nending of every loop iteration). Ideally, this means that the stop condition is set to a local variable just before the loop begins.\u003c/p\u003e\n\u003cp\u003eStop conditions that are not invariant are slightly less efficient, as well as being difficult to understand and maintain, and likely lead to the\nintroduction of errors in the future.\u003c/p\u003e\n\u003cp\u003eThis rule tracks three types of non-invariant stop conditions:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e When the loop counters are updated in the body of the \u003ccode\u003efor\u003c/code\u003e loop \u003c/li\u003e\n  \u003cli\u003e When the stop condition depend upon a method call \u003c/li\u003e\n  \u003cli\u003e When the stop condition depends on an object property, since such properties could change during the execution of the loop. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nfor (int i \u003d 0; i \u0026lt; 10; i++) {\n  ...\n  i \u003d i - 1; // Noncompliant\n  ...\n}\n\nfor (int i \u003d 0; i \u0026lt; getMaximumNumber(); i++) {  // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nfor (int i \u003d 0; i \u0026lt; 10; i++) {\n  ...\n}\nint stopCondition \u003d getMaximumNumber();\nfor (int i \u003d 0; i \u0026lt; stopCondition; i++) {\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 13.6 - Numeric variables being used within a \u003cem\u003efor\u003c/em\u003e loop for iteration counting shall not be modified in the body of the\n  loop. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 6-5-3 - The \u003cem\u003eloop-counter\u003c/em\u003e shall not be modified within \u003cem\u003econdition\u003c/em\u003e or \u003cem\u003estatement\u003c/em\u003e. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "based-on-misra",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S1151",
    "name": "\"switch case\" clauses should not have too many lines of code",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "FOCUSED",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003eswitch\u003c/code\u003e statement should be used only to clearly define some new branches in the control flow. As soon as a \u003ccode\u003ecase\u003c/code\u003e\nclause contains too many statements this highly decreases the readability of the overall control flow statement. In such case, the content of\n\u003ccode\u003ecase\u003c/code\u003e clause should be extracted in a dedicated function.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cp\u003eWith the default threshold of 5:\u003c/p\u003e\n\u003cpre\u003e\nswitch (myVariable) {\n  case 0: // 6 lines till next case\n    methodCall1(\"\");\n    methodCall2(\"\");\n    methodCall3(\"\");\n    methodCall4(\"\");\n    methodCall5(\"\");\n    break;\n  case 1:\n  // ...\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nswitch (myVariable) {\n  case 0: // Compliant: 2 lines\n    doSomething();\n    break;\n  case 1: // Compliant: 5 lines till next case. Curly braces after a case are not counted if they contain the entire case body\n   {\n     methodCall1(\"\");\n     methodCall2(\"\");\n     methodCall3(\"\");\n     methodCall4(\"\");\n     break;\n   }\n   case 2:\n  // ...\n}\n// ...\nvoid doSomething(){\n    methodCall1(\"\");\n    methodCall2(\"\");\n    methodCall3(\"\");\n    methodCall4(\"\");\n    methodCall5(\"\");\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe \u003ccode\u003eswitch\u003c/code\u003e statement should be used only to clearly define some new branches in the control flow. As soon as a \u003ccode\u003ecase\u003c/code\u003e\nclause contains too many statements this highly decreases the readability of the overall control flow statement. In such case, the content of\n\u003ccode\u003ecase\u003c/code\u003e clause should be extracted in a dedicated function.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cp\u003eWith the default threshold of 5:\u003c/p\u003e\n\u003cpre\u003e\nswitch (myVariable) {\n  case 0: // 6 lines till next case\n    methodCall1(\"\");\n    methodCall2(\"\");\n    methodCall3(\"\");\n    methodCall4(\"\");\n    methodCall5(\"\");\n    break;\n  case 1:\n  // ...\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nswitch (myVariable) {\n  case 0: // Compliant: 2 lines\n    doSomething();\n    break;\n  case 1: // Compliant: 5 lines till next case. Curly braces after a case are not counted if they contain the entire case body\n   {\n     methodCall1(\"\");\n     methodCall2(\"\");\n     methodCall3(\"\");\n     methodCall4(\"\");\n     break;\n   }\n   case 2:\n  // ...\n}\n// ...\nvoid doSomething(){\n    methodCall1(\"\");\n    methodCall2(\"\");\n    methodCall3(\"\");\n    methodCall4(\"\");\n    methodCall5(\"\");\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {
      "max": {
        "key": "max",
        "name": "max",
        "description": "Maximum Number of Lines",
        "defaultValue": "5",
        "type": "INTEGER",
        "multiple": false,
        "possibleValues": []
      }
    },
    "defaultParams": {
      "max": "5"
    },
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "brain-overload"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S125",
    "name": "Sections of code should not be commented out",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eCommented-out code distracts the focus from the actual executed code. It creates a noise that increases maintenance code. And because it is never\nexecuted, it quickly becomes out of date and invalid.\u003c/p\u003e\n\u003cp\u003eCommented-out code should be deleted and can be retrieved from source control history if required.\u003c/p\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThis rule does not apply to code documentation using Doxygen, QDoc, markdown, or HTML tags.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 2.4 - Sections of code should not be \"commented out\". \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 2-7-2 - Sections of code shall not be \"commented out\" using C-style comments. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 2-7-3 - Sections of code should not be \"commented out\" using C++ comments. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, Dir. 4.4 - Sections of code should not be \"commented out\" \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eCommented-out code distracts the focus from the actual executed code. It creates a noise that increases maintenance code. And because it is never\nexecuted, it quickly becomes out of date and invalid.\u003c/p\u003e\n\u003cp\u003eCommented-out code should be deleted and can be retrieved from source control history if required.\u003c/p\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThis rule does not apply to code documentation using Doxygen, QDoc, markdown, or HTML tags.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 2.4 - Sections of code should not be \"commented out\". \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 2-7-2 - Sections of code shall not be \"commented out\" using C-style comments. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 2-7-3 - Sections of code should not be \"commented out\" using C++ comments. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, Dir. 4.4 - Sections of code should not be \"commented out\" \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "based-on-misra",
      "unused"
    ],
    "deprecatedKeys": [
      "c:CommentedCode"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S1707",
    "name": "Track \"TODO\" and \"FIXME\" comments that do not contain a reference to a person",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eTODO and FIXME comments are typically intended to be short-lived; they are placeholders and reminders that programmers leave for themselves.\nUnfortunately, even with the best of intentions, those comments are not always acted on and removed in a timely manner. Thus, they can become\nmysterious, lingering cruft in a code base, reducing both readability and understand-ability.\u003c/p\u003e\n\u003cp\u003eThis rule flags all FIXME and TODO comments that do not have an attribution matching the specified regular expression immediately after the FIXME\nor TODO. Ideally, such comments will also contain information about what needs to be fixed or done, but this rule does not enforce that.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cp\u003eUsing the default regular expression: \u003ccode\u003e[ ]*\\([ _a-zA-Z0-9@.]+\\)\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\n// TODO\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n// TODO(ganncamp) per the business partners, more checks needed\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eTODO and FIXME comments are typically intended to be short-lived; they are placeholders and reminders that programmers leave for themselves.\nUnfortunately, even with the best of intentions, those comments are not always acted on and removed in a timely manner. Thus, they can become\nmysterious, lingering cruft in a code base, reducing both readability and understand-ability.\u003c/p\u003e\n\u003cp\u003eThis rule flags all FIXME and TODO comments that do not have an attribution matching the specified regular expression immediately after the FIXME\nor TODO. Ideally, such comments will also contain information about what needs to be fixed or done, but this rule does not enforce that.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cp\u003eUsing the default regular expression: \u003ccode\u003e[ ]*\\([ _a-zA-Z0-9@.]+\\)\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\n// TODO\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n// TODO(ganncamp) per the business partners, more checks needed\n\u003c/pre\u003e"
      }
    ],
    "params": {
      "pattern": {
        "key": "pattern",
        "name": "pattern",
        "description": "A POSIX regular expression defining the pattern that should be present after \"TODO\" or \"FIXME\"",
        "defaultValue": "[ ]*\\([ _a-zA-Z0-9@.]+\\)",
        "type": "STRING",
        "multiple": false,
        "possibleValues": []
      }
    },
    "defaultParams": {
      "pattern": "[ ]*\\([ _a-zA-Z0-9@.]+\\)"
    },
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "convention"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S929",
    "name": "Functions without parameters should be declared with parameter type \"void\"",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThere is a real, functional difference between a function with an empty parameter list and one with an explicitly \u003ccode\u003evoid\u003c/code\u003e parameter list:\nIt is possible to pass parameters to a function with an empty list; the compiler won’t complain. That is not the case for a function with a\n\u003ccode\u003evoid\u003c/code\u003e list. Thus, it is possible, and even easy to invoke empty-list functions incorrectly without knowing it, and thereby introduce the\nkind of subtle bug that can be very difficult to track down.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid myfunc ();  // Noncompliant\n\n//...\n\nvoid otherFunc() {\n  int a \u003d 4;\n  //...\n  myfunc(a); // Compiler allows this\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid myfunc ( void );\n\n//...\n\nvoid otherFunc() {\n  int a \u003d 4;\n  //...\n  myfunc(a); // Compiler error!\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 16.5 - Functions with no parameters shall be declared with parameter type void \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/t9YxBQ\"\u003eCERT, DCL20-C.\u003c/a\u003e - Explicitly specify void when a function accepts no arguments \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThere is a real, functional difference between a function with an empty parameter list and one with an explicitly \u003ccode\u003evoid\u003c/code\u003e parameter list:\nIt is possible to pass parameters to a function with an empty list; the compiler won’t complain. That is not the case for a function with a\n\u003ccode\u003evoid\u003c/code\u003e list. Thus, it is possible, and even easy to invoke empty-list functions incorrectly without knowing it, and thereby introduce the\nkind of subtle bug that can be very difficult to track down.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid myfunc ();  // Noncompliant\n\n//...\n\nvoid otherFunc() {\n  int a \u003d 4;\n  //...\n  myfunc(a); // Compiler allows this\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid myfunc ( void );\n\n//...\n\nvoid otherFunc() {\n  int a \u003d 4;\n  //...\n  myfunc(a); // Compiler error!\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 16.5 - Functions with no parameters shall be declared with parameter type void \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/t9YxBQ\"\u003eCERT, DCL20-C.\u003c/a\u003e - Explicitly specify void when a function accepts no arguments \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "based-on-misra",
      "cert",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S926",
    "name": "Parameters in a function prototype should be named",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "IDENTIFIABLE",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eNaming the parameters in a function prototype helps identify how they’ll be used by the function, thereby acting as a thin layer of documentation\nfor the function.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid divide (int, int);\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid divide (int numerator, int denominator);\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 16.3 - Identifiers shall be given for all of the parameters in a function prototype declaration \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 8.2 - Function types shall be in prototype form with named parameters \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eNaming the parameters in a function prototype helps identify how they’ll be used by the function, thereby acting as a thin layer of documentation\nfor the function.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid divide (int, int);\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid divide (int numerator, int denominator);\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 16.3 - Identifiers shall be given for all of the parameters in a function prototype declaration \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 8.2 - Function types shall be in prototype form with named parameters \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "based-on-misra"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S924",
    "name": "Loops should not have more than one \"break\" or \"goto\" statement",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eRestricting the number of exits from a loop is done in the interests of good structured programming. One \u003ccode\u003ebreak\u003c/code\u003e or \u003ccode\u003egoto\u003c/code\u003e\nstatement is acceptable in a loop since this allows, for example, for dual-outcome loops or optimal coding.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cp\u003eWith the default threshold of 1:\u003c/p\u003e\n\u003cpre\u003e\nfor (int i \u003d 0; i \u0026lt; 10; i++) {\n  if (...) {\n    break;      //  Compliant\n  }\n  else if (...) {\n    break;      //  Non-compliant - second jump from loop\n  }\n  else {\n    ...\n  }\n}\nwhile (...) {\n  if (...) {\n    break;      // Compliant\n  }\n  if (...) {\n    break;      // Non-compliant - second jump from loop\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nfor (int i \u003d 0; i \u0026lt; 10; i++) {\n  if (...) {\n    break;      //  Compliant\n  }\n}\nwhile (...) {\n  if (...) {\n    break;    // Compliant\n  }\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 14.6 - For any iteration statement there shall be at most one break statement used for loop termination. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 6-6-4 - For any iteration statement there shall be no more than one break or goto statement used for loop termination. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 15.4 - There should be no more than one break or goto statement used to terminate any iteration statement \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eRestricting the number of exits from a loop is done in the interests of good structured programming. One \u003ccode\u003ebreak\u003c/code\u003e or \u003ccode\u003egoto\u003c/code\u003e\nstatement is acceptable in a loop since this allows, for example, for dual-outcome loops or optimal coding.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cp\u003eWith the default threshold of 1:\u003c/p\u003e\n\u003cpre\u003e\nfor (int i \u003d 0; i \u0026lt; 10; i++) {\n  if (...) {\n    break;      //  Compliant\n  }\n  else if (...) {\n    break;      //  Non-compliant - second jump from loop\n  }\n  else {\n    ...\n  }\n}\nwhile (...) {\n  if (...) {\n    break;      // Compliant\n  }\n  if (...) {\n    break;      // Non-compliant - second jump from loop\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nfor (int i \u003d 0; i \u0026lt; 10; i++) {\n  if (...) {\n    break;      //  Compliant\n  }\n}\nwhile (...) {\n  if (...) {\n    break;    // Compliant\n  }\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 14.6 - For any iteration statement there shall be at most one break statement used for loop termination. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 6-6-4 - For any iteration statement there shall be no more than one break or goto statement used for loop termination. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 15.4 - There should be no more than one break or goto statement used to terminate any iteration statement \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {
      "maxNumberOfTerminationStatements": {
        "key": "maxNumberOfTerminationStatements",
        "name": "maxNumberOfTerminationStatements",
        "description": "Maximum authorized number of break/goto statements",
        "defaultValue": "1",
        "type": "INTEGER",
        "multiple": false,
        "possibleValues": []
      }
    },
    "defaultParams": {
      "maxNumberOfTerminationStatements": "1"
    },
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "based-on-misra",
      "confusing"
    ],
    "deprecatedKeys": [
      "c:SingleGotoOrBreakPerIteration"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S925",
    "name": "Recursion should not be used",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eRecursion is a powerful tool, but it can be tricky to get right. Getting it wrong can lead to stack overflow errors and cause system problems. Even\nwhen you do get it right, recursive code can be difficult to understand, perhaps leading to maintenance problems in the future. Therefore recursion\nshould be avoided in general and used only with due deliberation and caution when it is strictly necessary.\u003c/p\u003e\n\u003cp\u003eThis rule checks for direct recursion (when a function calls itself).\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint pow(int num, int exponent) {\n  if (exponent \u0026gt; 1) {\n    num \u003d num * pow(num, exponent-1);  // Noncompliant; direct recursion\n  }\n  return num;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint pow(int num, int exponent) {\n  int val \u003d num;\n  while (exponent \u0026gt; 0) {\n    val *\u003d num;\n    --exponent;\n  }\n  return val;\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 16.2 - Functions shall not call themselves, either directly or indirectly. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 7-5-4 - Functions should not call themselves, either directly or indirectly. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 17.2 - Functions shall not call themselves, either directly or indirectly \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eRecursion is a powerful tool, but it can be tricky to get right. Getting it wrong can lead to stack overflow errors and cause system problems. Even\nwhen you do get it right, recursive code can be difficult to understand, perhaps leading to maintenance problems in the future. Therefore recursion\nshould be avoided in general and used only with due deliberation and caution when it is strictly necessary.\u003c/p\u003e\n\u003cp\u003eThis rule checks for direct recursion (when a function calls itself).\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint pow(int num, int exponent) {\n  if (exponent \u0026gt; 1) {\n    num \u003d num * pow(num, exponent-1);  // Noncompliant; direct recursion\n  }\n  return num;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint pow(int num, int exponent) {\n  int val \u003d num;\n  while (exponent \u0026gt; 0) {\n    val *\u003d num;\n    --exponent;\n  }\n  return val;\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 16.2 - Functions shall not call themselves, either directly or indirectly. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 7-5-4 - Functions should not call themselves, either directly or indirectly. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 17.2 - Functions shall not call themselves, either directly or indirectly \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "bad-practice",
      "based-on-misra",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S1831",
    "name": "\"static\" should not be used for the size of an array parameter",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eTheoretically, the use of the \u003ccode\u003estatic\u003c/code\u003e keyword on the size of an array parameter means you can assume that only arrays of at least that\nsize will be passed as arguments to the function. I.e. a function parameter of \u003ccode\u003eint my_array[static 10]\u003c/code\u003e means that \u003ccode\u003emy_array\u003c/code\u003e\nwill always be \u003cem\u003eat least\u003c/em\u003e 10 elements long. If it is not, the behavior is undefined.\u003c/p\u003e\n\u003cp\u003eIn practice, the use of \u003ccode\u003estatic\u003c/code\u003e on the size of an array parameter means the compiler might issue a warning if a noncompliant array is\npassed to the function - a warning that might or might not be ignored. Therefore, in practice the use of \u003ccode\u003estatic\u003c/code\u003e on an array parameter’s\nsize merely lends a false sense of security, and \u003ccode\u003estatic\u003c/code\u003e should not be used in this context.\u003c/p\u003e\n\u003cp\u003eNote that for some compiler/processor combinations, more efficient code can be generated when \u003ccode\u003estatic\u003c/code\u003e is used, but these combinations\nare limited, and the benefit does not outweigh the cost.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint total (int size, int my_array[static 10]) {...}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint total (int size, int my_array[10]) {...}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2012, 17.6 - The declaration of an array parameter shall not contain the static keyword between the [] \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eTheoretically, the use of the \u003ccode\u003estatic\u003c/code\u003e keyword on the size of an array parameter means you can assume that only arrays of at least that\nsize will be passed as arguments to the function. I.e. a function parameter of \u003ccode\u003eint my_array[static 10]\u003c/code\u003e means that \u003ccode\u003emy_array\u003c/code\u003e\nwill always be \u003cem\u003eat least\u003c/em\u003e 10 elements long. If it is not, the behavior is undefined.\u003c/p\u003e\n\u003cp\u003eIn practice, the use of \u003ccode\u003estatic\u003c/code\u003e on the size of an array parameter means the compiler might issue a warning if a noncompliant array is\npassed to the function - a warning that might or might not be ignored. Therefore, in practice the use of \u003ccode\u003estatic\u003c/code\u003e on an array parameter’s\nsize merely lends a false sense of security, and \u003ccode\u003estatic\u003c/code\u003e should not be used in this context.\u003c/p\u003e\n\u003cp\u003eNote that for some compiler/processor combinations, more efficient code can be generated when \u003ccode\u003estatic\u003c/code\u003e is used, but these combinations\nare limited, and the benefit does not outweigh the cost.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint total (int size, int my_array[static 10]) {...}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint total (int size, int my_array[10]) {...}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2012, 17.6 - The declaration of an array parameter shall not contain the static keyword between the [] \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "based-on-misra",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S5639",
    "name": "Track comments matching a regular expression",
    "defaultSeverity": "INFO",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThis rule will be triggered when a comment matches one of the given regular expressions.\u003c/p\u003e\n\u003cp\u003eFor example, the following configuration raises issues for two different situations, each line contains a message followed by a POSIX regular\nexpression separated by a pipe \u003ccode\u003e|\u003c/code\u003e character.\u003c/p\u003e\n\u003cpre\u003e\nThis comment should be reviewed.|.*REVIEW.*\nDo not hardcode passwords.|.*(123456|password).*\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThis rule will be triggered when a comment matches one of the given regular expressions.\u003c/p\u003e\n\u003cp\u003eFor example, the following configuration raises issues for two different situations, each line contains a message followed by a POSIX regular\nexpression separated by a pipe \u003ccode\u003e|\u003c/code\u003e character.\u003c/p\u003e\n\u003cpre\u003e\nThis comment should be reviewed.|.*REVIEW.*\nDo not hardcode passwords.|.*(123456|password).*\n\u003c/pre\u003e"
      }
    ],
    "params": {
      "regularExpressionsToDetect": {
        "key": "regularExpressionsToDetect",
        "name": "regularExpressionsToDetect",
        "description": "Line separated list of strings with the format (see description for an example): message|POSIX regular expression",
        "type": "TEXT",
        "multiple": false,
        "possibleValues": []
      }
    },
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S1836",
    "name": "\"restrict\" should not be used",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003erestrict\u003c/code\u003e type qualifier is a guarantee by the programmer that there are no other pointers with access to the referenced object and\nthat the object does not overlap with any other object in memory. Its use may allow the compiler to generate more efficient byte code.\u003c/p\u003e\n\u003cp\u003eHowever, this is a tricky language feature to use correctly, and there is a significant risk of unexpected program behavior if\n\u003ccode\u003erestrict\u003c/code\u003e is misused. Therefore, \u003ccode\u003erestrict\u003c/code\u003e should not be used.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid user_copy (\n  void * restrict p,  // Noncompliant parameter\n  void * restrict q,  // Noncompliant parameter\n  size_t n\n) {\n  // ...\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/N9UxBQ\"\u003eEXP43-C. - Avoid undefined behavior when using restrict-qualified pointers\u003c/a\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2012, 8.14 - The restrict type qualifier shall not be used \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe \u003ccode\u003erestrict\u003c/code\u003e type qualifier is a guarantee by the programmer that there are no other pointers with access to the referenced object and\nthat the object does not overlap with any other object in memory. Its use may allow the compiler to generate more efficient byte code.\u003c/p\u003e\n\u003cp\u003eHowever, this is a tricky language feature to use correctly, and there is a significant risk of unexpected program behavior if\n\u003ccode\u003erestrict\u003c/code\u003e is misused. Therefore, \u003ccode\u003erestrict\u003c/code\u003e should not be used.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid user_copy (\n  void * restrict p,  // Noncompliant parameter\n  void * restrict q,  // Noncompliant parameter\n  size_t n\n) {\n  // ...\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/N9UxBQ\"\u003eEXP43-C. - Avoid undefined behavior when using restrict-qualified pointers\u003c/a\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2012, 8.14 - The restrict type qualifier shall not be used \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "based-on-misra",
      "cert"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S2806",
    "name": "Bit fields should not be used",
    "defaultSeverity": "BLOCKER",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe real need for bit fields is narrow and highly specialized. Previously, they were used to save memory, but that’s less a concern in modern\nsystems than are the extra instructions required to interact with them. Today, they may be needed in direct hardware interaction, but since their\nbehavior is platform-dependent, getting them right can be tricky, and since their use is increasingly rare these days, they’re likely to confuse\nmaintainers. For these reasons, it’s simpler and more performant to use another field type instead of bit fields.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nunsigned int b1 : 3;  // Noncompliant\nunsigned char b2 : 3;  // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nunsigned int b1;\nunsigned char b2;\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe real need for bit fields is narrow and highly specialized. Previously, they were used to save memory, but that’s less a concern in modern\nsystems than are the extra instructions required to interact with them. Today, they may be needed in direct hardware interaction, but since their\nbehavior is platform-dependent, getting them right can be tricky, and since their use is increasingly rare these days, they’re likely to confuse\nmaintainers. For these reasons, it’s simpler and more performant to use another field type instead of bit fields.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nunsigned int b1 : 3;  // Noncompliant\nunsigned char b2 : 3;  // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nunsigned int b1;\nunsigned char b2;\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "performance",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:M23_083",
    "name": "The \"declaration\" of an object should contain no more than two levels of pointer indirection",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 11.3.2\u003c/p\u003e\n\u003cp\u003eCategory: Advisory\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eAny \u003cem\u003etypedef-name\u003c/em\u003e appearing in a \u003cem\u003edeclaration\u003c/em\u003e [1] is treated as if it were replaced by the type that it denotes.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e the pointer decay that occurs when declaring a function parameter of array type introduces a level of pointer\nindirection.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eUse of more than two levels of indirection can seriously impair the ability to understand the behaviour of the code, and therefore should be\navoided.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\ntypedef int8_t * INTPTR1;\nusing INTPTR2 \u003d int8_t *;\n\n\nstruct s\n{\n  int8_t *   s1;                                // Compliant\n  int8_t **  s2;                                // Compliant\n  int8_t *** s3;                                // Non-compliant\n};\n\nstruct s *   ps1;                               // Compliant\nstruct s **  ps2;                               // Compliant\nstruct s *** ps3;                               // Non-compliant\n\nint8_t **  (   *pfunc1 )();                     // Compliant\nint8_t **  (  **pfunc2 )();                     // Compliant\nint8_t **  ( ***pfunc3 )();                     // Non-compliant\nint8_t *** (  **pfunc4 )();                     // Non-compliant\n\nvoid function( int8_t  *   par1,                // Compliant\n               int8_t  **  par2,                // Compliant\n               int8_t  *** par3,                // Non-compliant\n               INTPTR1 *   par4,                // Compliant\n               INTPTR1 *   const * const par5,  // Non-compliant\n               int8_t  *   par6[],              // Compliant\n               int8_t  **  par7[],              // Non-compliant\n               int8_t  ** \u0026amp;par8)                // Compliant\n\n{\n   int8_t  *   ptr1;                            // Compliant\n   int8_t  **  ptr2;                            // Compliant\n   int8_t  *** ptr3;                            // Non-compliant\n   INTPTR2 *   ptr4;                            // Compliant\n   INTPTR2 *   const * const ptr5;              // Non-compliant\n   int8_t  *   ptr6[ 10 ];                      // Compliant\n   int8_t  **  ptr7[ 10 ];                      // Compliant\n}\n\u003c/pre\u003e\n\u003cp\u003eExplanation of types:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003epar1\u003c/code\u003e and \u003ccode\u003eptr1\u003c/code\u003e are of type pointer to \u003ccode\u003eint8_t\u003c/code\u003e. \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003epar2\u003c/code\u003e and \u003ccode\u003eptr2\u003c/code\u003e are of type pointer to pointer to \u003ccode\u003eint8_t\u003c/code\u003e. \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003epar3\u003c/code\u003e and \u003ccode\u003eptr3\u003c/code\u003e are of type pointer to a pointer to a pointer to \u003ccode\u003eint8_t\u003c/code\u003e. This is three levels and is\n  non-compliant. \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003epar4\u003c/code\u003e and \u003ccode\u003eptr4\u003c/code\u003e are expanded to a type of pointer to a pointer to \u003ccode\u003eint8_t\u003c/code\u003e. \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003epar5\u003c/code\u003e and \u003ccode\u003eptr5\u003c/code\u003e are expanded to a type of const pointer to a const pointer to a pointer to \u003ccode\u003eint8_t\u003c/code\u003e. This is\n  three levels and is non-compliant. \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003epar6\u003c/code\u003e is of type pointer to pointer to \u003ccode\u003eint8_t\u003c/code\u003e because arrays are converted to a pointer to the initial element of the\n  array. \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003eptr6\u003c/code\u003e is of type array of pointers to \u003ccode\u003eint8_t\u003c/code\u003e. \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003epar7\u003c/code\u003e is of type pointer to pointer to pointer to \u003ccode\u003eint8_t\u003c/code\u003e because arrays are converted to a pointer to the initial\n  element of the array. This is three levels and is non-compliant. \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003eptr7\u003c/code\u003e is of type array of pointer to pointer to \u003ccode\u003eint8_t\u003c/code\u003e. This is compliant. \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003epar8\u003c/code\u003e is of type reference to pointer to pointer to \u003ccode\u003eint8_t\u003c/code\u003e. This is compliant. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eGlossary\u003c/h3\u003e\n\u003ch4\u003e[1] Declaration\u003c/h4\u003e\n\u003cp\u003eA \u003cem\u003edeclaration\u003c/em\u003e introduces the name of an \u003cem\u003eentity\u003c/em\u003e into a \u003cem\u003etranslation unit\u003c/em\u003e (see [basic.def]/1).\u003c/p\u003e\n\u003cp\u003eAn \u003cem\u003eentity\u003c/em\u003e may be \u003cem\u003edeclared\u003c/em\u003e several times. The first \u003cem\u003edeclaration\u003c/em\u003e of an \u003cem\u003eentity\u003c/em\u003e in a \u003cem\u003etranslation unit\u003c/em\u003e is\ncalled an \u003cem\u003eintroduction\u003c/em\u003e [2]. All subsequent \u003cem\u003edeclarations\u003c/em\u003e are called \u003cem\u003eredeclarations\u003c/em\u003e [3].\u003c/p\u003e\n\u003cp\u003eA \u003cem\u003edefinition\u003c/em\u003e [4] is a \u003cem\u003edeclaration\u003c/em\u003e, as described in [basic.def]/2.\u003c/p\u003e\n\u003ch4\u003e[2] Introduction\u003c/h4\u003e\n\u003cp\u003eSee \u003cem\u003edeclaration\u003c/em\u003e [1].\u003c/p\u003e\n\u003ch4\u003e[3] Redeclaration\u003c/h4\u003e\n\u003cp\u003eSee \u003cem\u003edeclaration\u003c/em\u003e [1].\u003c/p\u003e\n\u003ch4\u003e[4] Definition\u003c/h4\u003e\n\u003cp\u003eSee \u003cem\u003edeclaration\u003c/em\u003e [1].\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003e{rule:c:S943} targets the same defect as this rule but for a non-mission-critical context.\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 11.3.2\u003c/p\u003e\n\u003cp\u003eCategory: Advisory\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eAny \u003cem\u003etypedef-name\u003c/em\u003e appearing in a \u003cem\u003edeclaration\u003c/em\u003e [1] is treated as if it were replaced by the type that it denotes.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e the pointer decay that occurs when declaring a function parameter of array type introduces a level of pointer\nindirection.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eUse of more than two levels of indirection can seriously impair the ability to understand the behaviour of the code, and therefore should be\navoided.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\ntypedef int8_t * INTPTR1;\nusing INTPTR2 \u003d int8_t *;\n\n\nstruct s\n{\n  int8_t *   s1;                                // Compliant\n  int8_t **  s2;                                // Compliant\n  int8_t *** s3;                                // Non-compliant\n};\n\nstruct s *   ps1;                               // Compliant\nstruct s **  ps2;                               // Compliant\nstruct s *** ps3;                               // Non-compliant\n\nint8_t **  (   *pfunc1 )();                     // Compliant\nint8_t **  (  **pfunc2 )();                     // Compliant\nint8_t **  ( ***pfunc3 )();                     // Non-compliant\nint8_t *** (  **pfunc4 )();                     // Non-compliant\n\nvoid function( int8_t  *   par1,                // Compliant\n               int8_t  **  par2,                // Compliant\n               int8_t  *** par3,                // Non-compliant\n               INTPTR1 *   par4,                // Compliant\n               INTPTR1 *   const * const par5,  // Non-compliant\n               int8_t  *   par6[],              // Compliant\n               int8_t  **  par7[],              // Non-compliant\n               int8_t  ** \u0026amp;par8)                // Compliant\n\n{\n   int8_t  *   ptr1;                            // Compliant\n   int8_t  **  ptr2;                            // Compliant\n   int8_t  *** ptr3;                            // Non-compliant\n   INTPTR2 *   ptr4;                            // Compliant\n   INTPTR2 *   const * const ptr5;              // Non-compliant\n   int8_t  *   ptr6[ 10 ];                      // Compliant\n   int8_t  **  ptr7[ 10 ];                      // Compliant\n}\n\u003c/pre\u003e\n\u003cp\u003eExplanation of types:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003epar1\u003c/code\u003e and \u003ccode\u003eptr1\u003c/code\u003e are of type pointer to \u003ccode\u003eint8_t\u003c/code\u003e. \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003epar2\u003c/code\u003e and \u003ccode\u003eptr2\u003c/code\u003e are of type pointer to pointer to \u003ccode\u003eint8_t\u003c/code\u003e. \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003epar3\u003c/code\u003e and \u003ccode\u003eptr3\u003c/code\u003e are of type pointer to a pointer to a pointer to \u003ccode\u003eint8_t\u003c/code\u003e. This is three levels and is\n  non-compliant. \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003epar4\u003c/code\u003e and \u003ccode\u003eptr4\u003c/code\u003e are expanded to a type of pointer to a pointer to \u003ccode\u003eint8_t\u003c/code\u003e. \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003epar5\u003c/code\u003e and \u003ccode\u003eptr5\u003c/code\u003e are expanded to a type of const pointer to a const pointer to a pointer to \u003ccode\u003eint8_t\u003c/code\u003e. This is\n  three levels and is non-compliant. \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003epar6\u003c/code\u003e is of type pointer to pointer to \u003ccode\u003eint8_t\u003c/code\u003e because arrays are converted to a pointer to the initial element of the\n  array. \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003eptr6\u003c/code\u003e is of type array of pointers to \u003ccode\u003eint8_t\u003c/code\u003e. \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003epar7\u003c/code\u003e is of type pointer to pointer to pointer to \u003ccode\u003eint8_t\u003c/code\u003e because arrays are converted to a pointer to the initial\n  element of the array. This is three levels and is non-compliant. \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003eptr7\u003c/code\u003e is of type array of pointer to pointer to \u003ccode\u003eint8_t\u003c/code\u003e. This is compliant. \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003epar8\u003c/code\u003e is of type reference to pointer to pointer to \u003ccode\u003eint8_t\u003c/code\u003e. This is compliant. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eGlossary\u003c/h3\u003e\n\u003ch4\u003e[1] Declaration\u003c/h4\u003e\n\u003cp\u003eA \u003cem\u003edeclaration\u003c/em\u003e introduces the name of an \u003cem\u003eentity\u003c/em\u003e into a \u003cem\u003etranslation unit\u003c/em\u003e (see [basic.def]/1).\u003c/p\u003e\n\u003cp\u003eAn \u003cem\u003eentity\u003c/em\u003e may be \u003cem\u003edeclared\u003c/em\u003e several times. The first \u003cem\u003edeclaration\u003c/em\u003e of an \u003cem\u003eentity\u003c/em\u003e in a \u003cem\u003etranslation unit\u003c/em\u003e is\ncalled an \u003cem\u003eintroduction\u003c/em\u003e [2]. All subsequent \u003cem\u003edeclarations\u003c/em\u003e are called \u003cem\u003eredeclarations\u003c/em\u003e [3].\u003c/p\u003e\n\u003cp\u003eA \u003cem\u003edefinition\u003c/em\u003e [4] is a \u003cem\u003edeclaration\u003c/em\u003e, as described in [basic.def]/2.\u003c/p\u003e\n\u003ch4\u003e[2] Introduction\u003c/h4\u003e\n\u003cp\u003eSee \u003cem\u003edeclaration\u003c/em\u003e [1].\u003c/p\u003e\n\u003ch4\u003e[3] Redeclaration\u003c/h4\u003e\n\u003cp\u003eSee \u003cem\u003edeclaration\u003c/em\u003e [1].\u003c/p\u003e\n\u003ch4\u003e[4] Definition\u003c/h4\u003e\n\u003cp\u003eSee \u003cem\u003edeclaration\u003c/em\u003e [1].\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003e{rule:c:S943} targets the same defect as this rule but for a non-mission-critical context.\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "misra-advisory",
      "misra-c++2023",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S134",
    "name": "Control flow statements \"if\", \"for\", \"while\", \"switch\" and \"try\" should not be nested too deeply",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "FOCUSED",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eNested control flow statements \u003ccode\u003eif\u003c/code\u003e, \u003ccode\u003efor\u003c/code\u003e, \u003ccode\u003edo\u003c/code\u003e, \u003ccode\u003ewhile\u003c/code\u003e, \u003ccode\u003eswitch\u003c/code\u003e and \u003ccode\u003etry\u003c/code\u003e are\noften key ingredients in creating what’s known as \"Spaghetti code\". This code smell can make your program difficult to understand and maintain.\u003c/p\u003e\n\u003cp\u003eWhen numerous control structures are placed inside one another, the code becomes a tangled, complex web. This significantly reduces the code’s\nreadability and maintainability, and it also complicates the testing process.\u003c/p\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eEach use of a macro containing control flow statements is counted as one nesting level, even if the macro contains more than one control flow\nstatement.\u003c/p\u003e\n\u003cpre\u003e\n  #define FOREACH(V,ARR) if(ARR!\u003dnullptr) for(int V\u003d0; V\u0026lt;(sizeof(ARR)/sizeof(ARR[0])); V++)\n\n  if (condition1) {       // Compliant; depth \u003d 1\n    if (condition2) {     // Compliant; depth \u003d 2\n      FOREACH(i, arr) {     // Compliant; depth \u003d 3 (not 4)\n        if (condition3) {   // Noncompliant; depth \u003d 4\n          /* ... */\n        }\n      }\n    }\n  }\n\u003c/pre\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003cp\u003eThe following example demonstrates the behavior of the rule with the default threshold of 3 levels of nesting and one of the potential ways to fix\nthe code smell by introducing guard clauses:\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nif (condition1) {                  // Compliant - depth \u003d 1\n  /* ... */\n  if (condition2) {                // Compliant - depth \u003d 2\n    /* ... */\n    for (int i \u003d 0; i \u0026lt; 10; i++) {  // Compliant - depth \u003d 3\n      /* ... */\n      if (condition4) {            // Noncompliant - depth \u003d 4, which exceeds the limit\n        if (condition5) {          // Depth \u003d 5, exceeding the limit, but issues are only reported on depth \u003d 4\n          /* ... */\n        }\n        return;\n      }\n    }\n  }\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nif (!condition1) {\n  return;\n}\n/* ... */\nif (!condition2) {\n  return;\n}\nfor (int i \u003d 0; i \u0026lt; 10; i++) {\n  /* ... */\n  if (condition4) {\n    if (condition5) {\n      /* ... */\n    }\n    return;\n  }\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Guard_(computer_science)\"\u003eGuard clauses in programming\u003c/a\u003e - one of the approaches to reducing the depth\n  of nesting \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eNested control flow statements \u003ccode\u003eif\u003c/code\u003e, \u003ccode\u003efor\u003c/code\u003e, \u003ccode\u003edo\u003c/code\u003e, \u003ccode\u003ewhile\u003c/code\u003e, \u003ccode\u003eswitch\u003c/code\u003e and \u003ccode\u003etry\u003c/code\u003e are\noften key ingredients in creating what’s known as \"Spaghetti code\". This code smell can make your program difficult to understand and maintain.\u003c/p\u003e\n\u003cp\u003eWhen numerous control structures are placed inside one another, the code becomes a tangled, complex web. This significantly reduces the code’s\nreadability and maintainability, and it also complicates the testing process.\u003c/p\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eEach use of a macro containing control flow statements is counted as one nesting level, even if the macro contains more than one control flow\nstatement.\u003c/p\u003e\n\u003cpre\u003e\n  #define FOREACH(V,ARR) if(ARR!\u003dnullptr) for(int V\u003d0; V\u0026lt;(sizeof(ARR)/sizeof(ARR[0])); V++)\n\n  if (condition1) {       // Compliant; depth \u003d 1\n    if (condition2) {     // Compliant; depth \u003d 2\n      FOREACH(i, arr) {     // Compliant; depth \u003d 3 (not 4)\n        if (condition3) {   // Noncompliant; depth \u003d 4\n          /* ... */\n        }\n      }\n    }\n  }\n\u003c/pre\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eThe following example demonstrates the behavior of the rule with the default threshold of 3 levels of nesting and one of the potential ways to fix\nthe code smell by introducing guard clauses:\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nif (condition1) {                  // Compliant - depth \u003d 1\n  /* ... */\n  if (condition2) {                // Compliant - depth \u003d 2\n    /* ... */\n    for (int i \u003d 0; i \u0026lt; 10; i++) {  // Compliant - depth \u003d 3\n      /* ... */\n      if (condition4) {            // Noncompliant - depth \u003d 4, which exceeds the limit\n        if (condition5) {          // Depth \u003d 5, exceeding the limit, but issues are only reported on depth \u003d 4\n          /* ... */\n        }\n        return;\n      }\n    }\n  }\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nif (!condition1) {\n  return;\n}\n/* ... */\nif (!condition2) {\n  return;\n}\nfor (int i \u003d 0; i \u0026lt; 10; i++) {\n  /* ... */\n  if (condition4) {\n    if (condition5) {\n      /* ... */\n    }\n    return;\n  }\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Guard_(computer_science)\"\u003eGuard clauses in programming\u003c/a\u003e - one of the approaches to reducing the depth\n  of nesting \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {
      "max": {
        "key": "max",
        "name": "max",
        "description": "Maximum allowed control flow statement nesting depth.",
        "defaultValue": "3",
        "type": "INTEGER",
        "multiple": false,
        "possibleValues": []
      }
    },
    "defaultParams": {
      "max": "3"
    },
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "brain-overload"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S131",
    "name": "\"switch\" statements should have \"default\" clauses",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe requirement for a final \u003ccode\u003edefault\u003c/code\u003e clause is defensive programming. The clause should either take appropriate action, or contain a\nsuitable comment as to why no action is taken. When the \u003ccode\u003eswitch\u003c/code\u003e covers all current values of an \u003ccode\u003eenum\u003c/code\u003e - and especially when it\ndoesn’t - a \u003ccode\u003edefault\u003c/code\u003e case should still be used because there is no guarantee that the \u003ccode\u003eenum\u003c/code\u003e won’t be extended.\u003c/p\u003e\n\u003cp\u003eNote that there is a more nuanced version of this rule: {rule:c:S3562}. Use this rule if you want to require a \u003ccode\u003edefault\u003c/code\u003e case for\nevery \u003ccode\u003eswitch\u003c/code\u003e even if it already handles all enumerators of an \u003ccode\u003eenum\u003c/code\u003e. Otherwise, use {rule:c:S3562}.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nswitch (param) { // Noncompliant - default clause is missing\n  case 0:\n    doSomething();\n    break;\n  case 1:\n    doSomethingElse();\n    break;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nswitch (param) {\n  case 0:\n    doSomething();\n    break;\n  case 1:\n    doSomethingElse();\n    break;\n  default:\n    doDefault();\n    break;\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 15.0 - The MISRA C \u003cem\u003eswitch\u003c/em\u003e syntax shall be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2004, 15.3 - The final clause of a switch statement shall be the default clause \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 6-4-3 - A switch statement shall be a well-formed switch statement. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 6-4-6 - The final clause of a switch statement shall be the default-clause \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 16.1 - All switch statements shall be well-formed \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 16.4 - Every \u003cem\u003eswitch\u003c/em\u003e statement shall have a \u003cem\u003edefault\u003c/em\u003e label \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 16.5 - A \u003cem\u003edefault\u003c/em\u003e label shall appear as either the first or the last \u003cem\u003eswitch label\u003c/em\u003e of a \u003cem\u003eswitch\u003c/em\u003e statement\n  \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/478\"\u003eMITRE, CWE-478\u003c/a\u003e - Missing Default Case in Switch Statement \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/RtYxBQ\"\u003eCERT, MSC01-C.\u003c/a\u003e - Strive for logical completeness \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:c:S3562} \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe requirement for a final \u003ccode\u003edefault\u003c/code\u003e clause is defensive programming. The clause should either take appropriate action, or contain a\nsuitable comment as to why no action is taken. When the \u003ccode\u003eswitch\u003c/code\u003e covers all current values of an \u003ccode\u003eenum\u003c/code\u003e - and especially when it\ndoesn’t - a \u003ccode\u003edefault\u003c/code\u003e case should still be used because there is no guarantee that the \u003ccode\u003eenum\u003c/code\u003e won’t be extended.\u003c/p\u003e\n\u003cp\u003eNote that there is a more nuanced version of this rule: {rule:c:S3562}. Use this rule if you want to require a \u003ccode\u003edefault\u003c/code\u003e case for\nevery \u003ccode\u003eswitch\u003c/code\u003e even if it already handles all enumerators of an \u003ccode\u003eenum\u003c/code\u003e. Otherwise, use {rule:c:S3562}.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nswitch (param) { // Noncompliant - default clause is missing\n  case 0:\n    doSomething();\n    break;\n  case 1:\n    doSomethingElse();\n    break;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nswitch (param) {\n  case 0:\n    doSomething();\n    break;\n  case 1:\n    doSomethingElse();\n    break;\n  default:\n    doDefault();\n    break;\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 15.0 - The MISRA C \u003cem\u003eswitch\u003c/em\u003e syntax shall be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2004, 15.3 - The final clause of a switch statement shall be the default clause \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 6-4-3 - A switch statement shall be a well-formed switch statement. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 6-4-6 - The final clause of a switch statement shall be the default-clause \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 16.1 - All switch statements shall be well-formed \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 16.4 - Every \u003cem\u003eswitch\u003c/em\u003e statement shall have a \u003cem\u003edefault\u003c/em\u003e label \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 16.5 - A \u003cem\u003edefault\u003c/em\u003e label shall appear as either the first or the last \u003cem\u003eswitch label\u003c/em\u003e of a \u003cem\u003eswitch\u003c/em\u003e statement\n  \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/478\"\u003eMITRE, CWE-478\u003c/a\u003e - Missing Default Case in Switch Statement \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/RtYxBQ\"\u003eCERT, MSC01-C.\u003c/a\u003e - Strive for logical completeness \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:c:S3562} \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "based-on-misra",
      "cert",
      "cwe"
    ],
    "deprecatedKeys": [
      "c:SwitchWithoutDefault"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S2123",
    "name": "Values should not be uselessly incremented",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eA value that is incremented or decremented and then not stored is at best wasted code and at worst a bug.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint pickNumber() {\n  int i \u003d 0;\n  int j \u003d 0;\n\n  i \u003d i++; // Noncompliant; i is still zero\n\n  return j++; // Noncompliant; 0 returned\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint pickNumber() {\n  int i \u003d 0;\n  int j \u003d 0;\n\n  i++;\n  return ++j;\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eA value that is incremented or decremented and then not stored is at best wasted code and at worst a bug.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint pickNumber() {\n  int i \u003d 0;\n  int j \u003d 0;\n\n  i \u003d i++; // Noncompliant; i is still zero\n\n  return j++; // Noncompliant; 0 returned\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint pickNumber() {\n  int i \u003d 0;\n  int j \u003d 0;\n\n  i++;\n  return ++j;\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "unused"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S1036",
    "name": "Control should not be transferred into a complex logic block using a \"goto\" or a \"switch\" statement",
    "defaultSeverity": "BLOCKER",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eHaving a \u003ccode\u003eswitch\u003c/code\u003e and its cases wholly encompassed by a control structure such as a \u003ccode\u003etry\u003c/code\u003e, \u003ccode\u003e@try\u003c/code\u003e,\n\u003ccode\u003ecatch\u003c/code\u003e, \u003ccode\u003e@catch\u003c/code\u003e, or a loop is perfectly acceptable. (\u003ccode\u003etry\u003c/code\u003e and \u003ccode\u003ecatch\u003c/code\u003e are used hereafter to refer to\nboth variants.) It is also acceptable to have a \u003ccode\u003egoto\u003c/code\u003e and its target label wholly encompassed in a control structure.\u003c/p\u003e\n\u003cp\u003eWhat is not acceptable is using a \u003ccode\u003egoto\u003c/code\u003e or \u003ccode\u003ecase\u003c/code\u003e to suddenly jump into the body of a \u003ccode\u003etry\u003c/code\u003e, \u003ccode\u003ecatch\u003c/code\u003e,\nObjective-C \u003ccode\u003e@finally\u003c/code\u003e, or loop structure. Tangling labels or \u003ccode\u003eswitch\u003c/code\u003e blocks with other control structures results in code that\nis difficult, if not impossible to understand. More importantly, when it compiles (some of these constructs won’t compile under ISO-conformant\ncompilers), it can lead to unexpected results. Therefore this usage should be strictly avoided.\u003c/p\u003e\n\u003cp\u003eThis C++ code sample, which is also applicable to Objective-C if \u003ccode\u003etry\u003c/code\u003e and \u003ccode\u003ecatch\u003c/code\u003e are converted to \u003ccode\u003e@try\u003c/code\u003e and\n\u003ccode\u003e@catch\u003c/code\u003e, demonstrates jumping into a \u003ccode\u003eswitch\u003c/code\u003e and into a \u003ccode\u003etry\u003c/code\u003e and \u003ccode\u003ecatch\u003c/code\u003e :\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid f ( int32_t i )\n{\n  if ( 10 \u003d\u003d i )\n  {\n    goto Label_10; // Noncompliant; goto transfers control into try block\n  }\n\n  if ( 11 \u003d\u003d i )\n  {\n    goto Label_11; // Noncompliant; goto transfers control into catch block\n  }\n\n  switch ( i )\n  {\n    case 1:\n      try\n      {\n        Label_10:\n        case 2:  // Noncompliant; switch transfers control into try block\n          // Action\n          break;\n      }\n      catch ( ... )\n      {\n        Label_11:\n        case 3: // Noncompliant; switch transfers control into catch block\n          // Action\n          break;\n      }\n      break;\n    default:\n    {\n      // Default Action\n      break;\n    }\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid f ( int32_t i )\n{\n  switch ( i )\n  {\n    case 1:\n    case 2:\n      // Action\n      break;\n    case 3:\n      // Action\n      break;\n    case 10:\n\n    default:\n    {\n      // Default Action\n      break;\n    }\n  }\n\n  try\n  {\n    if ( 2 \u003d\u003d i || 10 \u003d\u003d i)\n    {\n      // Action\n    }\n  }\n  catch ( ... )\n  {\n    if (3 \u003d\u003d i || 11 \u003d\u003d i)\n    {\n      // Action\n    }\n  }\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 15-0-3 - Control shall not be transferred into a try or catch block using goto or switch statement \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/zdYxBQ\"\u003eCERT, MSC20-C.\u003c/a\u003e - Do not use a switch statement to transfer control into a complex\n  block \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eHaving a \u003ccode\u003eswitch\u003c/code\u003e and its cases wholly encompassed by a control structure such as a \u003ccode\u003etry\u003c/code\u003e, \u003ccode\u003e@try\u003c/code\u003e,\n\u003ccode\u003ecatch\u003c/code\u003e, \u003ccode\u003e@catch\u003c/code\u003e, or a loop is perfectly acceptable. (\u003ccode\u003etry\u003c/code\u003e and \u003ccode\u003ecatch\u003c/code\u003e are used hereafter to refer to\nboth variants.) It is also acceptable to have a \u003ccode\u003egoto\u003c/code\u003e and its target label wholly encompassed in a control structure.\u003c/p\u003e\n\u003cp\u003eWhat is not acceptable is using a \u003ccode\u003egoto\u003c/code\u003e or \u003ccode\u003ecase\u003c/code\u003e to suddenly jump into the body of a \u003ccode\u003etry\u003c/code\u003e, \u003ccode\u003ecatch\u003c/code\u003e,\nObjective-C \u003ccode\u003e@finally\u003c/code\u003e, or loop structure. Tangling labels or \u003ccode\u003eswitch\u003c/code\u003e blocks with other control structures results in code that\nis difficult, if not impossible to understand. More importantly, when it compiles (some of these constructs won’t compile under ISO-conformant\ncompilers), it can lead to unexpected results. Therefore this usage should be strictly avoided.\u003c/p\u003e\n\u003cp\u003eThis C++ code sample, which is also applicable to Objective-C if \u003ccode\u003etry\u003c/code\u003e and \u003ccode\u003ecatch\u003c/code\u003e are converted to \u003ccode\u003e@try\u003c/code\u003e and\n\u003ccode\u003e@catch\u003c/code\u003e, demonstrates jumping into a \u003ccode\u003eswitch\u003c/code\u003e and into a \u003ccode\u003etry\u003c/code\u003e and \u003ccode\u003ecatch\u003c/code\u003e :\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid f ( int32_t i )\n{\n  if ( 10 \u003d\u003d i )\n  {\n    goto Label_10; // Noncompliant; goto transfers control into try block\n  }\n\n  if ( 11 \u003d\u003d i )\n  {\n    goto Label_11; // Noncompliant; goto transfers control into catch block\n  }\n\n  switch ( i )\n  {\n    case 1:\n      try\n      {\n        Label_10:\n        case 2:  // Noncompliant; switch transfers control into try block\n          // Action\n          break;\n      }\n      catch ( ... )\n      {\n        Label_11:\n        case 3: // Noncompliant; switch transfers control into catch block\n          // Action\n          break;\n      }\n      break;\n    default:\n    {\n      // Default Action\n      break;\n    }\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid f ( int32_t i )\n{\n  switch ( i )\n  {\n    case 1:\n    case 2:\n      // Action\n      break;\n    case 3:\n      // Action\n      break;\n    case 10:\n\n    default:\n    {\n      // Default Action\n      break;\n    }\n  }\n\n  try\n  {\n    if ( 2 \u003d\u003d i || 10 \u003d\u003d i)\n    {\n      // Action\n    }\n  }\n  catch ( ... )\n  {\n    if (3 \u003d\u003d i || 11 \u003d\u003d i)\n    {\n      // Action\n    }\n  }\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 15-0-3 - Control shall not be transferred into a try or catch block using goto or switch statement \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/zdYxBQ\"\u003eCERT, MSC20-C.\u003c/a\u003e - Do not use a switch statement to transfer control into a complex\n  block \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "cert",
      "lock-in",
      "misra-c++2008",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S2245",
    "name": "Using pseudorandom number generators (PRNGs) is security-sensitive",
    "defaultSeverity": "CRITICAL",
    "type": "SECURITY_HOTSPOT",
    "cleanCodeAttribute": "TRUSTWORTHY",
    "defaultImpacts": {
      "SECURITY": "HIGH"
    },
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eUsing pseudorandom number generators (PRNGs) is security-sensitive. For example, it has led in the past to the following vulnerabilities:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"http://cve.mitre.org/cgi-bin/cvename.cgi?name\u003dCVE-2013-6386\"\u003eCVE-2013-6386\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"http://cve.mitre.org/cgi-bin/cvename.cgi?name\u003dCVE-2006-3419\"\u003eCVE-2006-3419\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"http://cve.mitre.org/cgi-bin/cvename.cgi?name\u003dCVE-2008-4102\"\u003eCVE-2008-4102\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWhen software generates predictable values in a context requiring unpredictability, it may be possible for an attacker to guess the next value that\nwill be generated, and use this guess to impersonate another user or access sensitive information.\u003c/p\u003e\n\u003cp\u003eAs the functions rely on a pseudorandom number generator, they should not be used for security-critical applications or for protecting sensitive\ndata.\u003c/p\u003e"
      },
      {
        "key": "assess_the_problem",
        "htmlContent": "\u003ch2\u003eAsk Yourself Whether\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e the code using the generated value requires it to be unpredictable. It is the case for all encryption mechanisms or when a secret value, such\n  as a password, is hashed. \u003c/li\u003e\n  \u003cli\u003e the function you use generates a value which can be predicted (pseudo-random). \u003c/li\u003e\n  \u003cli\u003e the generated value is used multiple times. \u003c/li\u003e\n  \u003cli\u003e an attacker can access the generated value. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere is a risk if you answered yes to any of those questions.\u003c/p\u003e\n\u003ch2\u003eSensitive Code Example\u003c/h2\u003e\n\u003cpre\u003e\n#include \u0026lt;random\u0026gt;\n// ...\n\nvoid f() {\n  int random_int \u003d std::rand(); // Sensitive\n}\n\u003c/pre\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003ch2\u003eRecommended Secure Coding Practices\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e Use functions which rely on a strong random number generator such as \u003ccode\u003erandombytes_uniform()\u003c/code\u003e or \u003ccode\u003erandombytes_buf()\u003c/code\u003e from\n  \u003ccode\u003elibsodium\u003c/code\u003e, or \u003ccode\u003erandomize()\u003c/code\u003e from Botan. \u003c/li\u003e\n  \u003cli\u003e Use the generated random values only once. \u003c/li\u003e\n  \u003cli\u003e You should not expose the generated random value. If you have to store it, make sure that the database or file is secure. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eCompliant Solution\u003c/h2\u003e\n\u003cpre\u003e\n#include \u0026lt;sodium.h\u0026gt;\n#include \u0026lt;botan/system_rng.h\u0026gt;\n// ...\n\nvoid f() {\n  char random_chars[10];\n  randombytes_buf(random_chars, 10); // Compliant\n  uint32_t random_int \u003d randombytes_uniform(10); // Compliant\n\n  uint8_t random_chars[10];\n  Botan::System_RNG system;\n  system.randomize(random_chars, 10); // Compliant\n}\n\u003c/pre\u003e\n\u003ch2\u003eSee\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/Top10/A02_2021-Cryptographic_Failures/\"\u003eOWASP Top 10 2021 Category A2\u003c/a\u003e - Cryptographic Failures \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://www.owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\"\u003eOWASP Top 10 2017 Category A3\u003c/a\u003e - Sensitive Data\n  Exposure \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://mobile-security.gitbook.io/masvs/security-requirements/0x08-v3-cryptography_verification_requirements\"\u003eMobile AppSec\n  Verification Standard\u003c/a\u003e - Cryptography Requirements \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/www-project-mobile-top-10/2016-risks/m5-insufficient-cryptography\"\u003eOWASP Mobile Top 10 2016 Category M5\u003c/a\u003e -\n  Insufficient Cryptography \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/338\"\u003eMITRE, CWE-338\u003c/a\u003e - Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)\n  \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/330\"\u003eMITRE, CWE-330\u003c/a\u003e - Use of Insufficiently Random Values \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/326\"\u003eMITRE, CWE-326\u003c/a\u003e - Inadequate Encryption Strength \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/1241\"\u003eMITRE, CWE-1241\u003c/a\u003e - Use of Predictable Algorithm in Random Number Generator \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/UNcxBQ\"\u003eCERT, MSC30-C.\u003c/a\u003e - Do not use the rand() function for generating pseudorandom numbers\n  \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/2ns-BQ\"\u003eCERT, MSC50-CPP.\u003c/a\u003e - Do not use std::rand() for generating pseudorandom numbers \u003c/li\u003e\n  \u003cli\u003e Derived from FindSecBugs rule \u003ca href\u003d\"https://h3xstream.github.io/find-sec-bugs/bugs.htm#PREDICTABLE_RANDOM\"\u003ePredictable Pseudo Random Number\n  Generator\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "cert",
      "cwe"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": [],
    "vulnerabilityProbability": "MEDIUM"
  },
  {
    "key": "c:S4426",
    "name": "Cryptographic keys should be robust",
    "defaultSeverity": "CRITICAL",
    "type": "VULNERABILITY",
    "cleanCodeAttribute": "TRUSTWORTHY",
    "defaultImpacts": {
      "SECURITY": "HIGH"
    },
    "description": "\u003cp\u003eThis vulnerability exposes encrypted data to attacks whose goal is to recover the plaintext.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eEncryption algorithms are essential for protecting sensitive information and ensuring secure communications in a variety of domains. They are used\nfor several important reasons:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Confidentiality, privacy, and intellectual property protection \u003c/li\u003e\n  \u003cli\u003e Security during transmission or on storage devices \u003c/li\u003e\n  \u003cli\u003e Data integrity, general trust, and authentication \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWhen selecting encryption algorithms, tools, or combinations, you should also consider two things:\u003c/p\u003e\n\u003col\u003e\n  \u003cli\u003e No encryption is unbreakable. \u003c/li\u003e\n  \u003cli\u003e The strength of an encryption algorithm is usually measured by the effort required to crack it within a reasonable time frame. \u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eIn today’s cryptography, the length of the \u003cstrong\u003ekey\u003c/strong\u003e directly affects the security level of cryptographic algorithms.\u003c/p\u003e\n\u003cp\u003eNote that depending on the algorithm, the term \u003cstrong\u003ekey\u003c/strong\u003e refers to a different mathematical property. For example:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e For RSA, the key is the product of two large prime numbers, also called the \u003cstrong\u003emodulus\u003c/strong\u003e. \u003c/li\u003e\n  \u003cli\u003e For AES and Elliptic Curve Cryptography (ECC), the key is only a sequence of randomly generated bytes.\n    \u003cul\u003e\n      \u003cli\u003e In some cases, AES keys are derived from a master key or a passphrase using a Key Derivation Function (KDF) like PBKDF2 (Password-Based Key\n      Derivation Function 2) \u003c/li\u003e\n    \u003c/ul\u003e  \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIf an application uses a key that is considered short and \u003cstrong\u003einsecure\u003c/strong\u003e, the encrypted data is exposed to attacks aimed at getting at\nthe plaintext.\u003c/p\u003e\n\u003cp\u003eIn general, it is best practice to expect a breach: that a user or organization with malicious intent will perform cryptographic attacks on this\ndata after obtaining it by other means.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eAfter retrieving encrypted data and performing cryptographic attacks on it on a given timeframe, attackers can recover the plaintext that\nencryption was supposed to protect.\u003c/p\u003e\n\u003cp\u003eDepending on the recovered data, the impact may vary.\u003c/p\u003e\n\u003cp\u003eBelow are some real-world scenarios that illustrate the potential impact of an attacker exploiting the vulnerability.\u003c/p\u003e\n\u003ch4\u003eAdditional attack surface\u003c/h4\u003e\n\u003cp\u003eBy modifying the plaintext of the encrypted message, an attacker may be able to trigger additional vulnerabilities in the code. An attacker can\nfurther exploit a system to obtain more information.\u003cbr\u003e Encrypted values are often considered trustworthy because it would not be possible for a\nthird party to modify them under normal circumstances.\u003c/p\u003e\n\u003ch4\u003eBreach of confidentiality and privacy\u003c/h4\u003e\n\u003cp\u003eWhen encrypted data contains personal or sensitive information, its retrieval by an attacker can lead to privacy violations, identity theft,\nfinancial loss, reputational damage, or unauthorized access to confidential systems.\u003c/p\u003e\n\u003cp\u003eIn this scenario, the company, its employees, users, and partners could be seriously affected.\u003c/p\u003e\n\u003cp\u003eThe impact is twofold, as data breaches and exposure of encrypted data can undermine trust in the organization, as customers, clients and\nstakeholders may lose confidence in the organization’s ability to protect their sensitive data.\u003c/p\u003e\n\u003ch4\u003eLegal and compliance issues\u003c/h4\u003e\n\u003cp\u003eIn many industries and locations, there are legal and compliance requirements to protect sensitive data. If encrypted data is compromised and the\nplaintext can be recovered, companies face legal consequences, penalties, or violations of privacy laws.\u003c/p\u003e\n\u003ch2\u003eHow to fix it in Botan\u003c/h2\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003cp\u003eThe following code examples either explicitly or implicitly generate keys. Note that there are differences in the size of the keys depending on the\nalgorithm.\u003c/p\u003e\n\u003cp\u003eDue to the mathematical properties of the algorithms, the security requirements for the key size vary depending on the algorithm.\u003cbr\u003e For example,\na 256-bit ECC key provides about the same level of security as a 3072-bit RSA key and a 128-bit symmetric key.\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cp\u003eHere is an example of a private key generation with RSA:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;botan/pubkey.h\u0026gt;\n#include \u0026lt;botan/rng.h\u0026gt;\n#include \u0026lt;botan/rsa.h\u0026gt;\n\nvoid encrypt() {\n    std::unique_ptr\u0026lt;Botan::RandomNumberGenerator\u0026gt;   rng(new Botan::System_RNG);\n    Botan::RSA_PrivateKey                           rsaKey(*rng, 1024); // Noncompliant\n}\n\u003c/pre\u003e\n\u003cp\u003eHere is an example with the generation of a key as part of a Discrete Logarithmic (DL) group, a Digital Signature Algorithm (DSA) parameter:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;botan/dl_group.h\u0026gt;\n\nvoid encrypt() {\n    Botan::DL_Group(\"dsa/botan/1024\"); // Noncompliant\n}\n\u003c/pre\u003e\n\u003cp\u003eHere is an example of an Elliptic Curve (EC) initialization. It implicitly generates a private key whose size is indicated in the algorithm\nname:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;botan/ec_group.h\u0026gt;\n\nvoid encrypt() {\n    Botan::EC_Group(\"secp160k1\"); // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;botan/pubkey.h\u0026gt;\n#include \u0026lt;botan/rng.h\u0026gt;\n#include \u0026lt;botan/rsa.h\u0026gt;\n\nvoid encrypt() {\n    std::unique_ptr\u0026lt;Botan::RandomNumberGenerator\u0026gt;   rng(new Botan::System_RNG);\n    Botan::RSA_PrivateKey                           rsaKey(*rng, 2048);\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;botan/dl_group.h\u0026gt;\n\nvoid encrypt() {\n    Botan::DL_Group(\"dsa/botan/2048\");\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;botan/ec_group.h\u0026gt;\n\nvoid encrypt() {\n    Botan::EC_Group(\"secp224k1\");\n}\n\u003c/pre\u003e\n\u003ch3\u003eHow does this work?\u003c/h3\u003e\n\u003cp\u003eAs a rule of thumb, use the cryptographic algorithms and mechanisms that are considered strong by the cryptographic community.\u003c/p\u003e\n\u003cp\u003eThe appropriate choices are the following.\u003c/p\u003e\n\u003ch4\u003eRSA (Rivest-Shamir-Adleman) and DSA (Digital Signature Algorithm)\u003c/h4\u003e\n\u003cp\u003eThe security of these algorithms depends on the difficulty of attacks attempting to solve their underlying mathematical problem.\u003c/p\u003e\n\u003cp\u003eIn general, a minimum key size of \u003cstrong\u003e2048\u003c/strong\u003e bits is recommended for both.\u003c/p\u003e\n\u003ch4\u003eAES (Advanced Encryption Standard)\u003c/h4\u003e\n\u003cp\u003eAES supports three key sizes: 128 bits, 192 bits and 256 bits. The security of the AES algorithm is based on the computational complexity of trying\nall possible keys.\u003cbr\u003e A larger key size increases the number of possible keys and makes exhaustive search attacks computationally infeasible.\nTherefore, a 256-bit key provides a higher level of security than a 128-bit or 192-bit key.\u003c/p\u003e\n\u003cp\u003eCurrently, a minimum key size of \u003cstrong\u003e128 bits\u003c/strong\u003e is recommended for AES.\u003c/p\u003e\n\u003ch4\u003eElliptic Curve Cryptography (ECC)\u003c/h4\u003e\n\u003cp\u003eElliptic curve cryptography is also used in various algorithms, such as ECDSA, ECDH, or ECMQV. The length of keys generated with elliptic curve\nalgorithms are mentioned directly in their names. For example, \u003ccode\u003esecp256k1\u003c/code\u003e generates a 256-bits long private key.\u003c/p\u003e\n\u003cp\u003eCurrently, a minimum key size of \u003cstrong\u003e224 bits\u003c/strong\u003e is recommended for EC algorithms.\u003c/p\u003e\n\u003ch3\u003eGoing the extra mile\u003c/h3\u003e\n\u003ch4\u003ePre-Quantum Cryptography\u003c/h4\u003e\n\u003cp\u003eEncrypted data and communications recorded today could be decrypted in the future by an attack from a quantum computer.\u003cbr\u003e It is important to keep\nin mind that NIST-approved digital signature schemes, key agreement, and key transport may need to be replaced with secure quantum-resistant (or\n\"post-quantum\") counterpart.\u003c/p\u003e\n\u003cp\u003eThus, if data is to remain secure beyond 2030, proactive measures should be taken now to ensure its safety.\u003c/p\u003e\n\u003cp\u003e\u003ca href\u003d\"https://www.enisa.europa.eu/publications/post-quantum-cryptography-current-state-and-quantum-mitigation\"\u003eLearn more here\u003c/a\u003e.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eArticles \u0026amp; blog posts\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://learn.microsoft.com/en-us/dotnet/standard/security/vulnerabilities-cbc-mode\"\u003eMicrosoft, Timing vulnerabilities with CBC-mode\n  symmetric decryption using padding\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Padding_oracle_attack\"\u003eWikipedia, Padding Oracle Attack\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Chosen-ciphertext_attack\"\u003eWikipedia, Chosen-Ciphertext Attack\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Chosen-plaintext_attack\"\u003eWikipedia, Chosen-Plaintext Attack\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Semantic_security\"\u003eWikipedia, Semantically Secure Cryptosystems\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Optimal_asymmetric_encryption_padding\"\u003eWikipedia, OAEP\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Galois/Counter_Mode\"\u003eWikipedia, Galois/Counter Mode\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/Top10/A02_2021-Cryptographic_Failures/\"\u003eOWASP Top 10 2021 Category A2\u003c/a\u003e - Cryptographic Failures \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://www.owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\"\u003eOWASP Top 10 2017 Category A3\u003c/a\u003e - Sensitive Data\n  Exposure \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration\"\u003eOWASP Top 10 2017 Category A6\u003c/a\u003e - Security\n  Misconfiguration \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://mobile-security.gitbook.io/masvs/security-requirements/0x08-v3-cryptography_verification_requirements\"\u003eMobile AppSec\n  Verification Standard\u003c/a\u003e - Cryptography Requirements \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/www-project-mobile-top-10/2016-risks/m5-insufficient-cryptography\"\u003eOWASP Mobile Top 10 2016 Category M5\u003c/a\u003e -\n  Insufficient Cryptography \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf\"\u003eNIST 800-131A\u003c/a\u003e - Recommendation for Transitioning the\n  Use of Cryptographic Algorithms and Key Lengths* \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/326\"\u003eMITRE, CWE-326\u003c/a\u003e - Inadequate Encryption\n  Strength \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/327\"\u003eMITRE, CWE-327\u003c/a\u003e - Use of a Broken or Risky Cryptographic Algorithm \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/hDdGBQ\"\u003eCERT, MSC61-J.\u003c/a\u003e - Do not use insecure or weak cryptographic algorithms \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eThis vulnerability exposes encrypted data to attacks whose goal is to recover the plaintext.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eEncryption algorithms are essential for protecting sensitive information and ensuring secure communications in a variety of domains. They are used\nfor several important reasons:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Confidentiality, privacy, and intellectual property protection \u003c/li\u003e\n  \u003cli\u003e Security during transmission or on storage devices \u003c/li\u003e\n  \u003cli\u003e Data integrity, general trust, and authentication \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWhen selecting encryption algorithms, tools, or combinations, you should also consider two things:\u003c/p\u003e\n\u003col\u003e\n  \u003cli\u003e No encryption is unbreakable. \u003c/li\u003e\n  \u003cli\u003e The strength of an encryption algorithm is usually measured by the effort required to crack it within a reasonable time frame. \u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eIn today’s cryptography, the length of the \u003cstrong\u003ekey\u003c/strong\u003e directly affects the security level of cryptographic algorithms.\u003c/p\u003e\n\u003cp\u003eNote that depending on the algorithm, the term \u003cstrong\u003ekey\u003c/strong\u003e refers to a different mathematical property. For example:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e For RSA, the key is the product of two large prime numbers, also called the \u003cstrong\u003emodulus\u003c/strong\u003e. \u003c/li\u003e\n  \u003cli\u003e For AES and Elliptic Curve Cryptography (ECC), the key is only a sequence of randomly generated bytes.\n    \u003cul\u003e\n      \u003cli\u003e In some cases, AES keys are derived from a master key or a passphrase using a Key Derivation Function (KDF) like PBKDF2 (Password-Based Key\n      Derivation Function 2) \u003c/li\u003e\n    \u003c/ul\u003e  \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIf an application uses a key that is considered short and \u003cstrong\u003einsecure\u003c/strong\u003e, the encrypted data is exposed to attacks aimed at getting at\nthe plaintext.\u003c/p\u003e\n\u003cp\u003eIn general, it is best practice to expect a breach: that a user or organization with malicious intent will perform cryptographic attacks on this\ndata after obtaining it by other means.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eAfter retrieving encrypted data and performing cryptographic attacks on it on a given timeframe, attackers can recover the plaintext that\nencryption was supposed to protect.\u003c/p\u003e\n\u003cp\u003eDepending on the recovered data, the impact may vary.\u003c/p\u003e\n\u003cp\u003eBelow are some real-world scenarios that illustrate the potential impact of an attacker exploiting the vulnerability.\u003c/p\u003e\n\u003ch4\u003eAdditional attack surface\u003c/h4\u003e\n\u003cp\u003eBy modifying the plaintext of the encrypted message, an attacker may be able to trigger additional vulnerabilities in the code. An attacker can\nfurther exploit a system to obtain more information.\u003cbr\u003e Encrypted values are often considered trustworthy because it would not be possible for a\nthird party to modify them under normal circumstances.\u003c/p\u003e\n\u003ch4\u003eBreach of confidentiality and privacy\u003c/h4\u003e\n\u003cp\u003eWhen encrypted data contains personal or sensitive information, its retrieval by an attacker can lead to privacy violations, identity theft,\nfinancial loss, reputational damage, or unauthorized access to confidential systems.\u003c/p\u003e\n\u003cp\u003eIn this scenario, the company, its employees, users, and partners could be seriously affected.\u003c/p\u003e\n\u003cp\u003eThe impact is twofold, as data breaches and exposure of encrypted data can undermine trust in the organization, as customers, clients and\nstakeholders may lose confidence in the organization’s ability to protect their sensitive data.\u003c/p\u003e\n\u003ch4\u003eLegal and compliance issues\u003c/h4\u003e\n\u003cp\u003eIn many industries and locations, there are legal and compliance requirements to protect sensitive data. If encrypted data is compromised and the\nplaintext can be recovered, companies face legal consequences, penalties, or violations of privacy laws.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eThe following code examples either explicitly or implicitly generate keys. Note that there are differences in the size of the keys depending on the\nalgorithm.\u003c/p\u003e\n\u003cp\u003eDue to the mathematical properties of the algorithms, the security requirements for the key size vary depending on the algorithm.\u003cbr\u003e For example,\na 256-bit ECC key provides about the same level of security as a 3072-bit RSA key and a 128-bit symmetric key.\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cp\u003eHere is an example of a private key generation with RSA:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;botan/pubkey.h\u0026gt;\n#include \u0026lt;botan/rng.h\u0026gt;\n#include \u0026lt;botan/rsa.h\u0026gt;\n\nvoid encrypt() {\n    std::unique_ptr\u0026lt;Botan::RandomNumberGenerator\u0026gt;   rng(new Botan::System_RNG);\n    Botan::RSA_PrivateKey                           rsaKey(*rng, 1024); // Noncompliant\n}\n\u003c/pre\u003e\n\u003cp\u003eHere is an example with the generation of a key as part of a Discrete Logarithmic (DL) group, a Digital Signature Algorithm (DSA) parameter:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;botan/dl_group.h\u0026gt;\n\nvoid encrypt() {\n    Botan::DL_Group(\"dsa/botan/1024\"); // Noncompliant\n}\n\u003c/pre\u003e\n\u003cp\u003eHere is an example of an Elliptic Curve (EC) initialization. It implicitly generates a private key whose size is indicated in the algorithm\nname:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;botan/ec_group.h\u0026gt;\n\nvoid encrypt() {\n    Botan::EC_Group(\"secp160k1\"); // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;botan/pubkey.h\u0026gt;\n#include \u0026lt;botan/rng.h\u0026gt;\n#include \u0026lt;botan/rsa.h\u0026gt;\n\nvoid encrypt() {\n    std::unique_ptr\u0026lt;Botan::RandomNumberGenerator\u0026gt;   rng(new Botan::System_RNG);\n    Botan::RSA_PrivateKey                           rsaKey(*rng, 2048);\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;botan/dl_group.h\u0026gt;\n\nvoid encrypt() {\n    Botan::DL_Group(\"dsa/botan/2048\");\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;botan/ec_group.h\u0026gt;\n\nvoid encrypt() {\n    Botan::EC_Group(\"secp224k1\");\n}\n\u003c/pre\u003e\n\u003ch3\u003eHow does this work?\u003c/h3\u003e\n\u003cp\u003eAs a rule of thumb, use the cryptographic algorithms and mechanisms that are considered strong by the cryptographic community.\u003c/p\u003e\n\u003cp\u003eThe appropriate choices are the following.\u003c/p\u003e\n\u003ch4\u003eRSA (Rivest-Shamir-Adleman) and DSA (Digital Signature Algorithm)\u003c/h4\u003e\n\u003cp\u003eThe security of these algorithms depends on the difficulty of attacks attempting to solve their underlying mathematical problem.\u003c/p\u003e\n\u003cp\u003eIn general, a minimum key size of \u003cstrong\u003e2048\u003c/strong\u003e bits is recommended for both.\u003c/p\u003e\n\u003ch4\u003eAES (Advanced Encryption Standard)\u003c/h4\u003e\n\u003cp\u003eAES supports three key sizes: 128 bits, 192 bits and 256 bits. The security of the AES algorithm is based on the computational complexity of trying\nall possible keys.\u003cbr\u003e A larger key size increases the number of possible keys and makes exhaustive search attacks computationally infeasible.\nTherefore, a 256-bit key provides a higher level of security than a 128-bit or 192-bit key.\u003c/p\u003e\n\u003cp\u003eCurrently, a minimum key size of \u003cstrong\u003e128 bits\u003c/strong\u003e is recommended for AES.\u003c/p\u003e\n\u003ch4\u003eElliptic Curve Cryptography (ECC)\u003c/h4\u003e\n\u003cp\u003eElliptic curve cryptography is also used in various algorithms, such as ECDSA, ECDH, or ECMQV. The length of keys generated with elliptic curve\nalgorithms are mentioned directly in their names. For example, \u003ccode\u003esecp256k1\u003c/code\u003e generates a 256-bits long private key.\u003c/p\u003e\n\u003cp\u003eCurrently, a minimum key size of \u003cstrong\u003e224 bits\u003c/strong\u003e is recommended for EC algorithms.\u003c/p\u003e\n\u003ch3\u003eGoing the extra mile\u003c/h3\u003e\n\u003ch4\u003ePre-Quantum Cryptography\u003c/h4\u003e\n\u003cp\u003eEncrypted data and communications recorded today could be decrypted in the future by an attack from a quantum computer.\u003cbr\u003e It is important to keep\nin mind that NIST-approved digital signature schemes, key agreement, and key transport may need to be replaced with secure quantum-resistant (or\n\"post-quantum\") counterpart.\u003c/p\u003e\n\u003cp\u003eThus, if data is to remain secure beyond 2030, proactive measures should be taken now to ensure its safety.\u003c/p\u003e\n\u003cp\u003e\u003ca href\u003d\"https://www.enisa.europa.eu/publications/post-quantum-cryptography-current-state-and-quantum-mitigation\"\u003eLearn more here\u003c/a\u003e.\u003c/p\u003e",
        "context": {
          "key": "botan",
          "displayName": "Botan"
        }
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cp\u003eHere is an example of a private key generation with RSA:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"21\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;cryptopp/rsa.h\u0026gt;\n#include \u0026lt;cryptopp/rng.h\u0026gt;\n\nvoid encrypt() {\n    CryptoPP::AutoSeededRandomPool  rng;\n    CryptoPP::InvertibleRSAFunction rsa_trapdoor;\n\n    rsa_trapdoor.GenerateRandomWithKeySize(rng, 1024); // Noncompliant\n}\n\u003c/pre\u003e\n\u003cp\u003eHere is an example of a key generation with the Digital Signature Algorithm (DSA):\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"22\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;cryptopp/dsa.h\u0026gt;\n#include \u0026lt;cryptopp/rng.h\u0026gt;\n\ncryptopp::autoseededrandompool rng;\ncryptopp::dsa::privatekey      dsa_private_key;\n\ndsa_private_key.GenerateRandomWithKeySize(rng, 1024); // Noncompliant\n\u003c/pre\u003e\n\u003cp\u003eHere is an example of a key generation with Diffie-Hellman:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"23\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;cryptopp/dh.h\u0026gt;\n#include \u0026lt;cryptopp/rng.h\u0026gt;\n\ncryptopp::autoseededrandompool rng;\nCryptoPP::DH                   dh;\n\ndh.AccessGroupParameters().GenerateRandomWithKeySize(rng, 1024); // Noncompliant\n\u003c/pre\u003e\n\u003cp\u003eHere is an example of an Elliptic Curve (EC) initialization. It implicitly generates a private key whose size is indicated in the algorithm\nname:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"24\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;cryptopp/osrng.h\u0026gt;\n\nvoid ecnrypt() {\n    CryptoPP::ASN1::secp112r1(); // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"21\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;cryptopp/rsa.h\u0026gt;\n#include \u0026lt;cryptopp/rng.h\u0026gt;\n\nvoid encrypt() {\n    CryptoPP::AutoSeededRandomPool  rng;\n    CryptoPP::InvertibleRSAFunction rsa_trapdoor;\n\n    rsa_trapdoor.GenerateRandomWithKeySize(rng, 2048);\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"22\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;cryptopp/dsa.h\u0026gt;\n#include \u0026lt;cryptopp/rng.h\u0026gt;\n\ncryptopp::autoseededrandompool rng;\ncryptopp::dsa::privatekey      dsa_private_key;\n\ndsa_private_key.GenerateRandomWithKeySize(rng, 2048);\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"23\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;cryptopp/dh.h\u0026gt;\n#include \u0026lt;cryptopp/rng.h\u0026gt;\n\ncryptopp::autoseededrandompool rng;\nCryptoPP::DH                   dh;\n\ndh.AccessGroupParameters().GenerateRandomWithKeySize(rng, 2048);\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"24\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;cryptopp/osrng.h\u0026gt;\n\nvoid ecnrypt() {\n    CryptoPP::ASN1::secp256r1();\n}\n\u003c/pre\u003e\n\u003ch3\u003eHow does this work?\u003c/h3\u003e\n\u003cp\u003eAs a rule of thumb, use the cryptographic algorithms and mechanisms that are considered strong by the cryptographic community.\u003c/p\u003e\n\u003cp\u003eThe appropriate choices are the following.\u003c/p\u003e\n\u003ch4\u003eRSA (Rivest-Shamir-Adleman) and DSA (Digital Signature Algorithm)\u003c/h4\u003e\n\u003cp\u003eThe security of these algorithms depends on the difficulty of attacks attempting to solve their underlying mathematical problem.\u003c/p\u003e\n\u003cp\u003eIn general, a minimum key size of \u003cstrong\u003e2048\u003c/strong\u003e bits is recommended for both.\u003c/p\u003e\n\u003ch4\u003eAES (Advanced Encryption Standard)\u003c/h4\u003e\n\u003cp\u003eAES supports three key sizes: 128 bits, 192 bits and 256 bits. The security of the AES algorithm is based on the computational complexity of trying\nall possible keys.\u003cbr\u003e A larger key size increases the number of possible keys and makes exhaustive search attacks computationally infeasible.\nTherefore, a 256-bit key provides a higher level of security than a 128-bit or 192-bit key.\u003c/p\u003e\n\u003cp\u003eCurrently, a minimum key size of \u003cstrong\u003e128 bits\u003c/strong\u003e is recommended for AES.\u003c/p\u003e\n\u003ch4\u003eElliptic Curve Cryptography (ECC)\u003c/h4\u003e\n\u003cp\u003eElliptic curve cryptography is also used in various algorithms, such as ECDSA, ECDH, or ECMQV. The length of keys generated with elliptic curve\nalgorithms are mentioned directly in their names. For example, \u003ccode\u003esecp256k1\u003c/code\u003e generates a 256-bits long private key.\u003c/p\u003e\n\u003cp\u003eCurrently, a minimum key size of \u003cstrong\u003e224 bits\u003c/strong\u003e is recommended for EC algorithms.\u003c/p\u003e\n\u003ch3\u003eGoing the extra mile\u003c/h3\u003e\n\u003ch4\u003ePre-Quantum Cryptography\u003c/h4\u003e\n\u003cp\u003eEncrypted data and communications recorded today could be decrypted in the future by an attack from a quantum computer.\u003cbr\u003e It is important to keep\nin mind that NIST-approved digital signature schemes, key agreement, and key transport may need to be replaced with secure quantum-resistant (or\n\"post-quantum\") counterpart.\u003c/p\u003e\n\u003cp\u003eThus, if data is to remain secure beyond 2030, proactive measures should be taken now to ensure its safety.\u003c/p\u003e\n\u003cp\u003e\u003ca href\u003d\"https://www.enisa.europa.eu/publications/post-quantum-cryptography-current-state-and-quantum-mitigation\"\u003eLearn more here\u003c/a\u003e.\u003c/p\u003e",
        "context": {
          "key": "cryptopp",
          "displayName": "CryptoPP"
        }
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eThe following code examples either explicitly or implicitly generate keys. Note that there are differences in the size of the keys depending on the\nalgorithm.\u003c/p\u003e\n\u003cp\u003eDue to the mathematical properties of the algorithms, the security requirements for the key size vary depending on the algorithm.\u003cbr\u003e For example,\na 256-bit ECC key provides about the same level of security as a 3072-bit RSA key and a 128-bit symmetric key.\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cp\u003eHere is an example of a private key generation with RSA:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"31\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;openssl/rsa.h\u0026gt;\n\nvoid encrypt() {\n    RSA* rsa_key_pair \u003d RSA_new();\n    BIGNUM* exponent  \u003d BSA_new();\n\n    BN_set_word(exponent, RSA_F4);\n    RSA_generate_key_ex(rsa_key_pair, 1024, exponent, NULL); // Noncompliant\n}\n\u003c/pre\u003e\n\u003cp\u003eHere is an example of a key generation with the Digital Signature Algorithm (DSA):\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"32\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;openssl/dsa.h\u0026gt;\n\nvoid encrypt() {\n    DSA* dsa_params \u003d DSA_new();\n    DSA_generate_parameters_ex(dsa_params, 1024, NULL, 0, NULL, NULL, NULL); // Noncompliant\n}\n\u003c/pre\u003e\n\u003cp\u003eHere is an example of a key generation with Diffie-Hellman:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"33\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;openssl/dh.h\u0026gt;\n\nvoid encrypt() {\n    DH* dh_params \u003d DH_new();\n    DH_generate_parameters_ex(dh_params, 1024, DH_GENERATOR_2, NULL); // Noncompliant\n}\n\u003c/pre\u003e\n\u003cp\u003eHere is an example of an Elliptic Curve (EC) initialization. It implicitly generates a private key whose size is indicated in the algorithm\nname:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"34\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;botan/ec_group.h\u0026gt;\n\nvoid encrypt() {\n    EC_KEY* ec_key \u003d EC_KEY_new_by_curve_name(NID_secp112r1); // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"31\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;openssl/rsa.h\u0026gt;\n\nvoid encrypt() {\n    RSA* rsa_key_pair \u003d RSA_new();\n    BIGNUM* exponent  \u003d BSA_new();\n\n    BN_set_word(exponent, RSA_F4);\n    RSA_generate_key_ex(rsa_key_pair, 2048, exponent, NULL);\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"32\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;openssl/dsa.h\u0026gt;\n\nvoid encrypt() {\n    DSA* dsa_params \u003d DSA_new();\n    DSA_generate_parameters_ex(dsa_params, 2048, NULL, 0, NULL, NULL, NULL);\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"33\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;openssl/dh.h\u0026gt;\n\nvoid encrypt() {\n    DH* dh_params \u003d DH_new();\n    DH_generate_parameters_ex(dh_params, 2048, DH_GENERATOR_2, NULL);\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"34\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;botan/ec_group.h\u0026gt;\n\nvoid encrypt() {\n    EC_KEY* ec_key \u003d EC_KEY_new_by_curve_name(NID_secp224r1);\n}\n\u003c/pre\u003e\n\u003ch3\u003eHow does this work?\u003c/h3\u003e\n\u003cp\u003eAs a rule of thumb, use the cryptographic algorithms and mechanisms that are considered strong by the cryptographic community.\u003c/p\u003e\n\u003cp\u003eThe appropriate choices are the following.\u003c/p\u003e\n\u003ch4\u003eRSA (Rivest-Shamir-Adleman) and DSA (Digital Signature Algorithm)\u003c/h4\u003e\n\u003cp\u003eThe security of these algorithms depends on the difficulty of attacks attempting to solve their underlying mathematical problem.\u003c/p\u003e\n\u003cp\u003eIn general, a minimum key size of \u003cstrong\u003e2048\u003c/strong\u003e bits is recommended for both.\u003c/p\u003e\n\u003ch4\u003eAES (Advanced Encryption Standard)\u003c/h4\u003e\n\u003cp\u003eAES supports three key sizes: 128 bits, 192 bits and 256 bits. The security of the AES algorithm is based on the computational complexity of trying\nall possible keys.\u003cbr\u003e A larger key size increases the number of possible keys and makes exhaustive search attacks computationally infeasible.\nTherefore, a 256-bit key provides a higher level of security than a 128-bit or 192-bit key.\u003c/p\u003e\n\u003cp\u003eCurrently, a minimum key size of \u003cstrong\u003e128 bits\u003c/strong\u003e is recommended for AES.\u003c/p\u003e\n\u003ch4\u003eElliptic Curve Cryptography (ECC)\u003c/h4\u003e\n\u003cp\u003eElliptic curve cryptography is also used in various algorithms, such as ECDSA, ECDH, or ECMQV. The length of keys generated with elliptic curve\nalgorithms are mentioned directly in their names. For example, \u003ccode\u003esecp256k1\u003c/code\u003e generates a 256-bits long private key.\u003c/p\u003e\n\u003cp\u003eCurrently, a minimum key size of \u003cstrong\u003e224 bits\u003c/strong\u003e is recommended for EC algorithms.\u003c/p\u003e\n\u003ch3\u003eGoing the extra mile\u003c/h3\u003e\n\u003ch4\u003ePre-Quantum Cryptography\u003c/h4\u003e\n\u003cp\u003eEncrypted data and communications recorded today could be decrypted in the future by an attack from a quantum computer.\u003cbr\u003e It is important to keep\nin mind that NIST-approved digital signature schemes, key agreement, and key transport may need to be replaced with secure quantum-resistant (or\n\"post-quantum\") counterpart.\u003c/p\u003e\n\u003cp\u003eThus, if data is to remain secure beyond 2030, proactive measures should be taken now to ensure its safety.\u003c/p\u003e\n\u003cp\u003e\u003ca href\u003d\"https://www.enisa.europa.eu/publications/post-quantum-cryptography-current-state-and-quantum-mitigation\"\u003eLearn more here\u003c/a\u003e.\u003c/p\u003e",
        "context": {
          "key": "openssl",
          "displayName": "OpenSSL"
        }
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eArticles \u0026amp; blog posts\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://learn.microsoft.com/en-us/dotnet/standard/security/vulnerabilities-cbc-mode\"\u003eMicrosoft, Timing vulnerabilities with CBC-mode\n  symmetric decryption using padding\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Padding_oracle_attack\"\u003eWikipedia, Padding Oracle Attack\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Chosen-ciphertext_attack\"\u003eWikipedia, Chosen-Ciphertext Attack\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Chosen-plaintext_attack\"\u003eWikipedia, Chosen-Plaintext Attack\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Semantic_security\"\u003eWikipedia, Semantically Secure Cryptosystems\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Optimal_asymmetric_encryption_padding\"\u003eWikipedia, OAEP\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Galois/Counter_Mode\"\u003eWikipedia, Galois/Counter Mode\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/Top10/A02_2021-Cryptographic_Failures/\"\u003eOWASP Top 10 2021 Category A2\u003c/a\u003e - Cryptographic Failures \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://www.owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\"\u003eOWASP Top 10 2017 Category A3\u003c/a\u003e - Sensitive Data\n  Exposure \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration\"\u003eOWASP Top 10 2017 Category A6\u003c/a\u003e - Security\n  Misconfiguration \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://mobile-security.gitbook.io/masvs/security-requirements/0x08-v3-cryptography_verification_requirements\"\u003eMobile AppSec\n  Verification Standard\u003c/a\u003e - Cryptography Requirements \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/www-project-mobile-top-10/2016-risks/m5-insufficient-cryptography\"\u003eOWASP Mobile Top 10 2016 Category M5\u003c/a\u003e -\n  Insufficient Cryptography \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf\"\u003eNIST 800-131A\u003c/a\u003e - Recommendation for Transitioning the\n  Use of Cryptographic Algorithms and Key Lengths* \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/326\"\u003eMITRE, CWE-326\u003c/a\u003e - Inadequate Encryption\n  Strength \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/327\"\u003eMITRE, CWE-327\u003c/a\u003e - Use of a Broken or Risky Cryptographic Algorithm \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/hDdGBQ\"\u003eCERT, MSC61-J.\u003c/a\u003e - Do not use insecure or weak cryptographic algorithms \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "cwe",
      "privacy"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S3458",
    "name": "Empty \"case\" clauses that fall through to the \"default\" should be omitted",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eEmpty \u003ccode\u003ecase\u003c/code\u003e clauses that fall through to the default are useless. Whether or not such a \u003ccode\u003ecase\u003c/code\u003e is present, the\n\u003ccode\u003edefault\u003c/code\u003e clause will be invoked. Such \u003ccode\u003ecase\u003c/code\u003es simply clutter the code, and should be removed.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nswitch(ch)\n{\n  case \u0027a\u0027 :\n    handleA();\n    break;\n  case \u0027b\u0027 :\n    handleB();\n    break;\n  case \u0027c\u0027 :  // Noncompliant\n  default:\n    handleTheRest();\n    break;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nswitch(ch)\n{\n  case \u0027a\u0027 :\n    handleA();\n    break;\n  case \u0027b\u0027 :\n    handleB();\n    break;\n  default:\n    handleTheRest();\n    break;\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eEmpty \u003ccode\u003ecase\u003c/code\u003e clauses that fall through to the default are useless. Whether or not such a \u003ccode\u003ecase\u003c/code\u003e is present, the\n\u003ccode\u003edefault\u003c/code\u003e clause will be invoked. Such \u003ccode\u003ecase\u003c/code\u003es simply clutter the code, and should be removed.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nswitch(ch)\n{\n  case \u0027a\u0027 :\n    handleA();\n    break;\n  case \u0027b\u0027 :\n    handleB();\n    break;\n  case \u0027c\u0027 :  // Noncompliant\n  default:\n    handleTheRest();\n    break;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nswitch(ch)\n{\n  case \u0027a\u0027 :\n    handleA();\n    break;\n  case \u0027b\u0027 :\n    handleB();\n    break;\n  default:\n    handleTheRest();\n    break;\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "clumsy",
      "finding"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S4423",
    "name": "Weak SSL/TLS protocols should not be used",
    "defaultSeverity": "CRITICAL",
    "type": "VULNERABILITY",
    "cleanCodeAttribute": "TRUSTWORTHY",
    "defaultImpacts": {
      "SECURITY": "HIGH"
    },
    "description": "\u003cp\u003eThis vulnerability exposes encrypted data to a number of attacks whose goal is to recover the plaintext.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eEncryption algorithms are essential for protecting sensitive information and ensuring secure communications in a variety of domains. They are used\nfor several important reasons:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Confidentiality, privacy, and intellectual property protection \u003c/li\u003e\n  \u003cli\u003e Security during transmission or on storage devices \u003c/li\u003e\n  \u003cli\u003e Data integrity, general trust, and authentication \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWhen selecting encryption algorithms, tools, or combinations, you should also consider two things:\u003c/p\u003e\n\u003col\u003e\n  \u003cli\u003e No encryption is unbreakable. \u003c/li\u003e\n  \u003cli\u003e The strength of an encryption algorithm is usually measured by the effort required to crack it within a reasonable time frame. \u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eFor these reasons, as soon as cryptography is included in a project, it is important to choose encryption algorithms that are considered strong and\nsecure by the cryptography community.\u003c/p\u003e\n\u003cp\u003eTo provide communication security over a network, SSL and TLS are generally used. However, it is important to note that the following protocols are\nall considered weak by the cryptographic community, and are officially deprecated:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e SSL versions 1.0, 2.0 and 3.0 \u003c/li\u003e\n  \u003cli\u003e TLS versions 1.0 and 1.1 \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWhen these unsecured protocols are used, it is best practice to expect a breach: that a user or organization with malicious intent will perform\nmathematical attacks on this data after obtaining it by other means.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eAfter retrieving encrypted data and performing cryptographic attacks on it on a given timeframe, attackers can recover the plaintext that\nencryption was supposed to protect.\u003c/p\u003e\n\u003cp\u003eDepending on the recovered data, the impact may vary.\u003c/p\u003e\n\u003cp\u003eBelow are some real-world scenarios that illustrate the potential impact of an attacker exploiting the vulnerability.\u003c/p\u003e\n\u003ch4\u003eAdditional attack surface\u003c/h4\u003e\n\u003cp\u003eBy modifying the plaintext of the encrypted message, an attacker may be able to trigger additional vulnerabilities in the code. An attacker can\nfurther exploit a system to obtain more information.\u003cbr\u003e Encrypted values are often considered trustworthy because it would not be possible for a\nthird party to modify them under normal circumstances.\u003c/p\u003e\n\u003ch4\u003eBreach of confidentiality and privacy\u003c/h4\u003e\n\u003cp\u003eWhen encrypted data contains personal or sensitive information, its retrieval by an attacker can lead to privacy violations, identity theft,\nfinancial loss, reputational damage, or unauthorized access to confidential systems.\u003c/p\u003e\n\u003cp\u003eIn this scenario, the company, its employees, users, and partners could be seriously affected.\u003c/p\u003e\n\u003cp\u003eThe impact is twofold, as data breaches and exposure of encrypted data can undermine trust in the organization, as customers, clients and\nstakeholders may lose confidence in the organization’s ability to protect their sensitive data.\u003c/p\u003e\n\u003ch4\u003eLegal and compliance issues\u003c/h4\u003e\n\u003cp\u003eIn many industries and locations, there are legal and compliance requirements to protect sensitive data. If encrypted data is compromised and the\nplaintext can be recovered, companies face legal consequences, penalties, or violations of privacy laws.\u003c/p\u003e\n\u003ch2\u003eHow to fix it in cURL\u003c/h2\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003cp\u003eThe following code samples attempt to create an HTTP request.\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cp\u003eThis sample uses Curl’s default TLS algorithms, which are weak cryptographical algorithms: TLSv1.0 and LTSv1.1.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"11\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;curl/curl.h\u0026gt;\n\nvoid encrypt() {\n    CURL *curl;\n    curl_global_init(CURL_GLOBAL_DEFAULT);\n\n    curl \u003d curl_easy_init();                                      // Noncompliant\n    curl_easy_setopt(curl, CURLOPT_URL, \"https://example.com/\");\n\n    curl_easy_perform(curl);\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"11\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;curl/curl.h\u0026gt;\n\nvoid encrypt() {\n    CURL *curl;\n    curl_global_init(CURL_GLOBAL_DEFAULT);\n\n    curl \u003d curl_easy_init();\n    curl_easy_setopt(curl, CURLOPT_URL, \"https://example.com/\");\n    curl_easy_setopt(curl, CURLOPT_SSLVERSION, CURL_SSLVERSION_TLSv1_2);\n\n    curl_easy_perform(curl);\n}\n\u003c/pre\u003e\n\u003ch3\u003eHow does this work?\u003c/h3\u003e\n\u003cp\u003eAs a rule of thumb, by default you should use the cryptographic algorithms and mechanisms that are considered strong by the cryptographic\ncommunity.\u003c/p\u003e\n\u003cp\u003eThe best choices at the moment are the following.\u003c/p\u003e\n\u003ch4\u003eUse TLS v1.2 or TLS v1.3\u003c/h4\u003e\n\u003cp\u003eEven though TLS V1.3 is available, using TLS v1.2 is still considered good and secure practice by the cryptography community.\u003cbr\u003e\u003c/p\u003e\n\u003cp\u003eThe use of TLS v1.2 ensures compatibility with a wide range of platforms and enables seamless communication between different systems that do not\nyet have TLS v1.3 support.\u003c/p\u003e\n\u003cp\u003eThe only drawback depends on whether the framework used is outdated: its TLS v1.2 settings may enable older and insecure cipher suites that are\ndeprecated as insecure.\u003c/p\u003e\n\u003cp\u003eOn the other hand, TLS v1.3 removes support for older and weaker cryptographic algorithms, eliminates known vulnerabilities from previous TLS\nversions, and improves performance.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eArticles \u0026amp; blog posts\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Padding_oracle_attack\"\u003eWikipedia, Padding Oracle Attack\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Chosen-ciphertext_attack\"\u003eWikipedia, Chosen-Ciphertext Attack\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Chosen-plaintext_attack\"\u003eWikipedia, Chosen-Plaintext Attack\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Semantic_security\"\u003eWikipedia, Semantically Secure Cryptosystems\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Optimal_asymmetric_encryption_padding\"\u003eWikipedia, OAEP\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Galois/Counter_Mode\"\u003eWikipedia, Galois/Counter Mode\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/Top10/A02_2021-Cryptographic_Failures/\"\u003eOWASP Top 10 2021 Category A2\u003c/a\u003e - Cryptographic Failures \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration\"\u003eOWASP Top 10 2017 Category A6\u003c/a\u003e - Security\n  Misconfiguration \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/327\"\u003eMITRE, CWE-327\u003c/a\u003e - Use of a Broken or Risky Cryptographic Algorithm \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eThis vulnerability exposes encrypted data to a number of attacks whose goal is to recover the plaintext.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eEncryption algorithms are essential for protecting sensitive information and ensuring secure communications in a variety of domains. They are used\nfor several important reasons:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Confidentiality, privacy, and intellectual property protection \u003c/li\u003e\n  \u003cli\u003e Security during transmission or on storage devices \u003c/li\u003e\n  \u003cli\u003e Data integrity, general trust, and authentication \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWhen selecting encryption algorithms, tools, or combinations, you should also consider two things:\u003c/p\u003e\n\u003col\u003e\n  \u003cli\u003e No encryption is unbreakable. \u003c/li\u003e\n  \u003cli\u003e The strength of an encryption algorithm is usually measured by the effort required to crack it within a reasonable time frame. \u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eFor these reasons, as soon as cryptography is included in a project, it is important to choose encryption algorithms that are considered strong and\nsecure by the cryptography community.\u003c/p\u003e\n\u003cp\u003eTo provide communication security over a network, SSL and TLS are generally used. However, it is important to note that the following protocols are\nall considered weak by the cryptographic community, and are officially deprecated:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e SSL versions 1.0, 2.0 and 3.0 \u003c/li\u003e\n  \u003cli\u003e TLS versions 1.0 and 1.1 \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWhen these unsecured protocols are used, it is best practice to expect a breach: that a user or organization with malicious intent will perform\nmathematical attacks on this data after obtaining it by other means.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eAfter retrieving encrypted data and performing cryptographic attacks on it on a given timeframe, attackers can recover the plaintext that\nencryption was supposed to protect.\u003c/p\u003e\n\u003cp\u003eDepending on the recovered data, the impact may vary.\u003c/p\u003e\n\u003cp\u003eBelow are some real-world scenarios that illustrate the potential impact of an attacker exploiting the vulnerability.\u003c/p\u003e\n\u003ch4\u003eAdditional attack surface\u003c/h4\u003e\n\u003cp\u003eBy modifying the plaintext of the encrypted message, an attacker may be able to trigger additional vulnerabilities in the code. An attacker can\nfurther exploit a system to obtain more information.\u003cbr\u003e Encrypted values are often considered trustworthy because it would not be possible for a\nthird party to modify them under normal circumstances.\u003c/p\u003e\n\u003ch4\u003eBreach of confidentiality and privacy\u003c/h4\u003e\n\u003cp\u003eWhen encrypted data contains personal or sensitive information, its retrieval by an attacker can lead to privacy violations, identity theft,\nfinancial loss, reputational damage, or unauthorized access to confidential systems.\u003c/p\u003e\n\u003cp\u003eIn this scenario, the company, its employees, users, and partners could be seriously affected.\u003c/p\u003e\n\u003cp\u003eThe impact is twofold, as data breaches and exposure of encrypted data can undermine trust in the organization, as customers, clients and\nstakeholders may lose confidence in the organization’s ability to protect their sensitive data.\u003c/p\u003e\n\u003ch4\u003eLegal and compliance issues\u003c/h4\u003e\n\u003cp\u003eIn many industries and locations, there are legal and compliance requirements to protect sensitive data. If encrypted data is compromised and the\nplaintext can be recovered, companies face legal consequences, penalties, or violations of privacy laws.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eThe following code samples attempt to create an HTTP request.\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cp\u003eThis sample uses Curl’s default TLS algorithms, which are weak cryptographical algorithms: TLSv1.0 and LTSv1.1.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"11\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;curl/curl.h\u0026gt;\n\nvoid encrypt() {\n    CURL *curl;\n    curl_global_init(CURL_GLOBAL_DEFAULT);\n\n    curl \u003d curl_easy_init();                                      // Noncompliant\n    curl_easy_setopt(curl, CURLOPT_URL, \"https://example.com/\");\n\n    curl_easy_perform(curl);\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"11\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;curl/curl.h\u0026gt;\n\nvoid encrypt() {\n    CURL *curl;\n    curl_global_init(CURL_GLOBAL_DEFAULT);\n\n    curl \u003d curl_easy_init();\n    curl_easy_setopt(curl, CURLOPT_URL, \"https://example.com/\");\n    curl_easy_setopt(curl, CURLOPT_SSLVERSION, CURL_SSLVERSION_TLSv1_2);\n\n    curl_easy_perform(curl);\n}\n\u003c/pre\u003e\n\u003ch3\u003eHow does this work?\u003c/h3\u003e\n\u003cp\u003eAs a rule of thumb, by default you should use the cryptographic algorithms and mechanisms that are considered strong by the cryptographic\ncommunity.\u003c/p\u003e\n\u003cp\u003eThe best choices at the moment are the following.\u003c/p\u003e\n\u003ch4\u003eUse TLS v1.2 or TLS v1.3\u003c/h4\u003e\n\u003cp\u003eEven though TLS V1.3 is available, using TLS v1.2 is still considered good and secure practice by the cryptography community.\u003cbr\u003e\u003c/p\u003e\n\u003cp\u003eThe use of TLS v1.2 ensures compatibility with a wide range of platforms and enables seamless communication between different systems that do not\nyet have TLS v1.3 support.\u003c/p\u003e\n\u003cp\u003eThe only drawback depends on whether the framework used is outdated: its TLS v1.2 settings may enable older and insecure cipher suites that are\ndeprecated as insecure.\u003c/p\u003e\n\u003cp\u003eOn the other hand, TLS v1.3 removes support for older and weaker cryptographic algorithms, eliminates known vulnerabilities from previous TLS\nversions, and improves performance.\u003c/p\u003e",
        "context": {
          "key": "curl",
          "displayName": "cURL"
        }
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eThe following code samples attempt to create an OpenSSL TLS Client.\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cp\u003eThis sample uses OpenSSL’s default TLS algorithms, which are weak cryptographical algorithms (TLSv1.0 and LTSv1.1).\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"21\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;openssl/ssl.h\u0026gt;\n\nvoid encrypt() {\n    const SSL_METHOD *method \u003d TLS_method();        // Noncompliant\n    SSL_CTX *ctx             \u003d SSL_CTX_new(method);\n\n    SSL *ssl \u003d SSL_new(ctx);\n    SSL_connect(ssl);\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"21\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;openssl/ssl.h\u0026gt;\n\nvoid encrypt() {\n    const SSL_METHOD *method \u003d TLS_method();\n    SSL_CTX *ctx             \u003d SSL_CTX_new(method);\n\n    SSL_CTX_set_min_proto_version(ctx, TLS1_2_VERSION);\n\n    SSL *ssl \u003d SSL_new(ctx);\n    SSL_connect(ssl);\n}\n\u003c/pre\u003e\n\u003ch3\u003eHow does this work?\u003c/h3\u003e\n\u003cp\u003eAs a rule of thumb, by default you should use the cryptographic algorithms and mechanisms that are considered strong by the cryptographic\ncommunity.\u003c/p\u003e\n\u003cp\u003eThe best choices at the moment are the following.\u003c/p\u003e\n\u003ch4\u003eUse TLS v1.2 or TLS v1.3\u003c/h4\u003e\n\u003cp\u003eEven though TLS V1.3 is available, using TLS v1.2 is still considered good and secure practice by the cryptography community.\u003cbr\u003e\u003c/p\u003e\n\u003cp\u003eThe use of TLS v1.2 ensures compatibility with a wide range of platforms and enables seamless communication between different systems that do not\nyet have TLS v1.3 support.\u003c/p\u003e\n\u003cp\u003eThe only drawback depends on whether the framework used is outdated: its TLS v1.2 settings may enable older and insecure cipher suites that are\ndeprecated as insecure.\u003c/p\u003e\n\u003cp\u003eOn the other hand, TLS v1.3 removes support for older and weaker cryptographic algorithms, eliminates known vulnerabilities from previous TLS\nversions, and improves performance.\u003c/p\u003e",
        "context": {
          "key": "openssl",
          "displayName": "OpenSSL"
        }
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eThe following code samples attempt to create a Botan TLS Client.\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cp\u003eThis sample uses Botan’s default TLS algorithms, which are weak cryptographical algorithms (TLSv1.0 and DLTv1.0).\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;botan/tls_client.h\u0026gt;\n#include \u0026lt;botan/tls_callbacks.h\u0026gt;\n#include \u0026lt;botan/tls_session_manager.h\u0026gt;\n#include \u0026lt;botan/tls_policy.h\u0026gt;\n#include \u0026lt;botan/auto_rng.h\u0026gt;\n#include \u0026lt;botan/certstor.h\u0026gt;\n#include \u0026lt;botan/certstor_system.h\u0026gt;\n\nclass Custom_Callbacks   : public Botan::TLS::Callbacks { };\nclass Custom_Credentials : public Botan::Credentials_Manager { };\n\nvoid encrypt() {\n    Custom_Callbacks      callbacks;\n    Botan::AutoSeeded_RNG rng;\n    Custom_Credentials    creds;\n    Botan::TLS::Policy    policy; // Noncompliant\n\n    Botan::TLS::Session_Manager_In_Memory session_mgr(rng);\n    Botan::TLS::Client client(callbacks, session_mgr, creds, policy, rng,\n                              Botan::TLS::Server_Information(\"example.com\", 443),\n                              Botan::TLS::Protocol_Version::TLS_V12);\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eThis sample uses the \"Strict\" Botan TLS Policy, whose minimal versions are strong cryptographical algorithms (TLSv1.2 and TLSv1.2).\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;botan/tls_client.h\u0026gt;\n#include \u0026lt;botan/tls_callbacks.h\u0026gt;\n#include \u0026lt;botan/tls_session_manager.h\u0026gt;\n#include \u0026lt;botan/tls_policy.h\u0026gt;\n#include \u0026lt;botan/auto_rng.h\u0026gt;\n#include \u0026lt;botan/certstor.h\u0026gt;\n#include \u0026lt;botan/certstor_system.h\u0026gt;\n\nclass Custom_Callbacks   : public Botan::TLS::Callbacks { };\nclass Custom_Credentials : public Botan::Credentials_Manager { };\n\nvoid encrypt() {\n    Custom_Callbacks          callbacks;\n    Botan::AutoSeeded_RNG     rng;\n    Custom_Credentials        creds;\n    Botan::TLS::Strict_Policy policy;\n\n    Botan::TLS::Session_Manager_In_Memory session_mgr(rng);\n    Botan::TLS::Client client(callbacks, session_mgr, creds, policy, rng,\n                              Botan::TLS::Server_Information(\"example.com\", 443),\n                              Botan::TLS::Protocol_Version::TLS_V12);\n}\n\u003c/pre\u003e\n\u003ch3\u003eHow does this work?\u003c/h3\u003e\n\u003cp\u003eAs a rule of thumb, by default you should use the cryptographic algorithms and mechanisms that are considered strong by the cryptographic\ncommunity.\u003c/p\u003e\n\u003cp\u003eThe best choices at the moment are the following.\u003c/p\u003e\n\u003ch4\u003eUse TLS v1.2 or TLS v1.3\u003c/h4\u003e\n\u003cp\u003eEven though TLS V1.3 is available, using TLS v1.2 is still considered good and secure practice by the cryptography community.\u003cbr\u003e\u003c/p\u003e\n\u003cp\u003eThe use of TLS v1.2 ensures compatibility with a wide range of platforms and enables seamless communication between different systems that do not\nyet have TLS v1.3 support.\u003c/p\u003e\n\u003cp\u003eThe only drawback depends on whether the framework used is outdated: its TLS v1.2 settings may enable older and insecure cipher suites that are\ndeprecated as insecure.\u003c/p\u003e\n\u003cp\u003eOn the other hand, TLS v1.3 removes support for older and weaker cryptographic algorithms, eliminates known vulnerabilities from previous TLS\nversions, and improves performance.\u003c/p\u003e",
        "context": {
          "key": "botan",
          "displayName": "Botan"
        }
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eArticles \u0026amp; blog posts\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Padding_oracle_attack\"\u003eWikipedia, Padding Oracle Attack\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Chosen-ciphertext_attack\"\u003eWikipedia, Chosen-Ciphertext Attack\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Chosen-plaintext_attack\"\u003eWikipedia, Chosen-Plaintext Attack\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Semantic_security\"\u003eWikipedia, Semantically Secure Cryptosystems\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Optimal_asymmetric_encryption_padding\"\u003eWikipedia, OAEP\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Galois/Counter_Mode\"\u003eWikipedia, Galois/Counter Mode\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/Top10/A02_2021-Cryptographic_Failures/\"\u003eOWASP Top 10 2021 Category A2\u003c/a\u003e - Cryptographic Failures \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration\"\u003eOWASP Top 10 2017 Category A6\u003c/a\u003e - Security\n  Misconfiguration \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/327\"\u003eMITRE, CWE-327\u003c/a\u003e - Use of a Broken or Risky Cryptographic Algorithm \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "cwe",
      "privacy",
      "symbolic-execution"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S3457",
    "name": "Format strings should be used correctly",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eprintf\u003c/code\u003e format strings contain placeholders, represented by special characters such as \u003ccode\u003e%s\u003c/code\u003e. These placeholders are\ninterpreted at runtime rather than validated by the compiler. Using incorrect placeholders or with inappropriate arguments can result in the wrong\nstring being created or undefined behavior.\u003c/p\u003e\n\u003cp\u003eStarting with C++20, \u003ccode\u003estd::format\u003c/code\u003e should be preferred: it is more readable and validated at compile-time, making it more secure. Rule\nS6494 covers that. Furthermore, C++23 provides \u003ccode\u003estd::print\u003c/code\u003e, which is similar to \u003ccode\u003estd::format\u003c/code\u003e but directly prints\nits output instead of generating a \u003ccode\u003estd::string\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003e{rule:c:S2275} covers errors leading to undefined behavior.\u003cbr\u003e This rule is about errors that produce an unexpected string.\u003c/p\u003e\n\u003cp\u003eThese problems are detected when the format string is a string literal:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Every argument should be used: \u003cpre\u003e\nprintf(\"Numbers: %d\", 1, 2); // Noncompliant: the second argument \"2\" is unused\n\u003c/pre\u003e  You should either remove the extra arguments or add the relevant placeholders.  \u003c/li\u003e\n  \u003cli\u003e The formatting flags \u003ccode\u003e0\u003c/code\u003e and \u003ccode\u003e-\u003c/code\u003e are mutually exclusive: \u003cpre\u003e\nprintf(\"Number: %0-10f\", 1.2); // Noncompliant: flag \"0\" is ignored because of \"-\"\n\u003c/pre\u003e  When \u003ccode\u003e0\u003c/code\u003e is used, the number is right-aligned with leading \u003ccode\u003e0\u003c/code\u003es. The flag \u003ccode\u003e-\u003c/code\u003e aligns the number to the left. Consequently, zero \u003ccode\u003e0\u003c/code\u003e would be used when using both flags, thus making the \u003ccode\u003e0\u003c/code\u003e flag useless.   You should choose which flags make sense in your use case and remove the other.  \u003c/li\u003e\n  \u003cli\u003e The formatting flags \u003ccode\u003e␣\u003c/code\u003e (space) and \u003ccode\u003e+\u003c/code\u003e are mutually exclusive: \u003cpre\u003e\nprintf(\"Number: % +f\", 1.2); // Noncompliant: flag \" \" is ignored because of \"+\"\n\u003c/pre\u003e  Both the space and the \u003ccode\u003e+\u003c/code\u003e flags change when the sign character is printed. They are, therefore, incompatible with one another.   You should decide which one is appropriate in your case and remove the other.  \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/io/c/fprintf\"\u003e\u003ccode\u003eprintf\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/utility/format/format\"\u003e\u003ccode\u003estd::format\u003c/code\u003e from C++20\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/io/print\"\u003e\u003ccode\u003estd::print\u003c/code\u003e from C++23\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/J9YxBQ\"\u003eCERT, FIO47-C.\u003c/a\u003e - Use valid format strings \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e S6494 - C++ formatting functions should be used instead of C printf-like functions \u003c/li\u003e\n  \u003cli\u003e {rule:c:S2275} - Printf-style format strings should not lead to unexpected behavior at runtime \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003ccode\u003eprintf\u003c/code\u003e format strings contain placeholders, represented by special characters such as \u003ccode\u003e%s\u003c/code\u003e. These placeholders are\ninterpreted at runtime rather than validated by the compiler. Using incorrect placeholders or with inappropriate arguments can result in the wrong\nstring being created or undefined behavior.\u003c/p\u003e\n\u003cp\u003eStarting with C++20, \u003ccode\u003estd::format\u003c/code\u003e should be preferred: it is more readable and validated at compile-time, making it more secure. Rule\nS6494 covers that. Furthermore, C++23 provides \u003ccode\u003estd::print\u003c/code\u003e, which is similar to \u003ccode\u003estd::format\u003c/code\u003e but directly prints\nits output instead of generating a \u003ccode\u003estd::string\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003e{rule:c:S2275} covers errors leading to undefined behavior.\u003cbr\u003e This rule is about errors that produce an unexpected string.\u003c/p\u003e\n\u003cp\u003eThese problems are detected when the format string is a string literal:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Every argument should be used: \u003cpre\u003e\nprintf(\"Numbers: %d\", 1, 2); // Noncompliant: the second argument \"2\" is unused\n\u003c/pre\u003e  You should either remove the extra arguments or add the relevant placeholders.  \u003c/li\u003e\n  \u003cli\u003e The formatting flags \u003ccode\u003e0\u003c/code\u003e and \u003ccode\u003e-\u003c/code\u003e are mutually exclusive: \u003cpre\u003e\nprintf(\"Number: %0-10f\", 1.2); // Noncompliant: flag \"0\" is ignored because of \"-\"\n\u003c/pre\u003e  When \u003ccode\u003e0\u003c/code\u003e is used, the number is right-aligned with leading \u003ccode\u003e0\u003c/code\u003es. The flag \u003ccode\u003e-\u003c/code\u003e aligns the number to the left. Consequently, zero \u003ccode\u003e0\u003c/code\u003e would be used when using both flags, thus making the \u003ccode\u003e0\u003c/code\u003e flag useless.   You should choose which flags make sense in your use case and remove the other.  \u003c/li\u003e\n  \u003cli\u003e The formatting flags \u003ccode\u003e␣\u003c/code\u003e (space) and \u003ccode\u003e+\u003c/code\u003e are mutually exclusive: \u003cpre\u003e\nprintf(\"Number: % +f\", 1.2); // Noncompliant: flag \" \" is ignored because of \"+\"\n\u003c/pre\u003e  Both the space and the \u003ccode\u003e+\u003c/code\u003e flags change when the sign character is printed. They are, therefore, incompatible with one another.   You should decide which one is appropriate in your case and remove the other.  \u003c/li\u003e\n\u003c/ul\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/io/c/fprintf\"\u003e\u003ccode\u003eprintf\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/utility/format/format\"\u003e\u003ccode\u003estd::format\u003c/code\u003e from C++20\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/io/print\"\u003e\u003ccode\u003estd::print\u003c/code\u003e from C++23\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/J9YxBQ\"\u003eCERT, FIO47-C.\u003c/a\u003e - Use valid format strings \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e S6494 - C++ formatting functions should be used instead of C printf-like functions \u003c/li\u003e\n  \u003cli\u003e {rule:c:S2275} - Printf-style format strings should not lead to unexpected behavior at runtime \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "cert",
      "confusing"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S834",
    "name": "Array declarations should include an explicit size specification",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eIt is possible to declare an array without explicitly specifying its size, but using an explicit size declaration is clearer, and is therefore\npreferred.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint arr1 [ ];  // Noncompliant; nothing specified\nint arr2 [ ] \u003d { [0] \u003d 1, [12] \u003d 36, [4] \u003d 93 }; // Noncompliant; highest index determines size. May be difficult to spot\nint pirate [ ] \u003d { 2, 4, 8, 42, 501, 90210, 7, 1776 }; // Noncompliant; size is implicit, not explicit\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint arr1 [10];\nint arr2 [13] \u003d { [0] \u003d 1, [12] \u003d 36, [4] \u003d 93 };\nint pirate [10] \u003d { 2, 4, 8, 42, 501, 90210, 7, 1776 }; // Implicitly-assigned size was 8. Desired size was 10.\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 8.12 - When an array is declared with external linkage, its size shall be stated explicitly or defined implicitly by\n  initialisation \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 3-1-3 - When an array is declared, its size shall either be stated explicitly or defined implicitly by initialization \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 8.11 - When an array with external linkage is declared, its size should be explicitely specified \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 9.5 - Where designated initializers are used to initialize an array object the size of the array shall be specified explicitly\n  \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/6dUxBQ\"\u003eCERT, ARR02-C.\u003c/a\u003e - Explicitly specify array bounds, even if implicitly defined by an\n  initializer \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eIt is possible to declare an array without explicitly specifying its size, but using an explicit size declaration is clearer, and is therefore\npreferred.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint arr1 [ ];  // Noncompliant; nothing specified\nint arr2 [ ] \u003d { [0] \u003d 1, [12] \u003d 36, [4] \u003d 93 }; // Noncompliant; highest index determines size. May be difficult to spot\nint pirate [ ] \u003d { 2, 4, 8, 42, 501, 90210, 7, 1776 }; // Noncompliant; size is implicit, not explicit\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint arr1 [10];\nint arr2 [13] \u003d { [0] \u003d 1, [12] \u003d 36, [4] \u003d 93 };\nint pirate [10] \u003d { 2, 4, 8, 42, 501, 90210, 7, 1776 }; // Implicitly-assigned size was 8. Desired size was 10.\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 8.12 - When an array is declared with external linkage, its size shall be stated explicitly or defined implicitly by\n  initialisation \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 3-1-3 - When an array is declared, its size shall either be stated explicitly or defined implicitly by initialization \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 8.11 - When an array with external linkage is declared, its size should be explicitely specified \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 9.5 - Where designated initializers are used to initialize an array object the size of the array shall be specified explicitly\n  \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/6dUxBQ\"\u003eCERT, ARR02-C.\u003c/a\u003e - Explicitly specify array bounds, even if implicitly defined by an\n  initializer \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "based-on-misra",
      "cert"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S955",
    "name": "Non-standard characters should not occur in header file names in \"#include\" directives",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003e#include\u003c/code\u003e directive allows you to include header files in your code by enclosing the file names in either double quotes\n(\u003ccode\u003e\"\u003c/code\u003e) or angle brackets (\u003ccode\u003e\u0026lt;\u003c/code\u003e and \u003ccode\u003e\u0026gt;\u003c/code\u003e). However, using:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003e\u0027\u003c/code\u003e, \u003ccode\u003e\\\u003c/code\u003e or \u003ccode\u003e/*\u003c/code\u003e characters between the double quotes (for example: \u003ccode\u003e#include \"dir\\foo.h\"\u003c/code\u003e) \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003e\u0027\u003c/code\u003e, \u003ccode\u003e\\\u003c/code\u003e, \u003ccode\u003e\"\u003c/code\u003e or \u003ccode\u003e/*\u003c/code\u003e characters between the angle brackets (for example: \u003ccode\u003e#include\n  \u0026lt;\"foo\"\u0026gt;\u003c/code\u003e) \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003ein the header names may or may not be supported, and the behavior will depend on the specific implementation.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 19.2 - Non-standard characters should not occur in header file names in #include directives. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 16-2-4 - The \u0027, \", /* or // characters shall not occur in a header file name. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 16-2-5 - The \\ character should not occur in a header file name. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 20.2 - The \u0027, \" or \\ characters and the /* or // character sequences shall not occur in a header file name \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe \u003ccode\u003e#include\u003c/code\u003e directive allows you to include header files in your code by enclosing the file names in either double quotes\n(\u003ccode\u003e\"\u003c/code\u003e) or angle brackets (\u003ccode\u003e\u0026lt;\u003c/code\u003e and \u003ccode\u003e\u0026gt;\u003c/code\u003e). However, using:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003e\u0027\u003c/code\u003e, \u003ccode\u003e\\\u003c/code\u003e or \u003ccode\u003e/*\u003c/code\u003e characters between the double quotes (for example: \u003ccode\u003e#include \"dir\\foo.h\"\u003c/code\u003e) \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003e\u0027\u003c/code\u003e, \u003ccode\u003e\\\u003c/code\u003e, \u003ccode\u003e\"\u003c/code\u003e or \u003ccode\u003e/*\u003c/code\u003e characters between the angle brackets (for example: \u003ccode\u003e#include\n  \u0026lt;\"foo\"\u0026gt;\u003c/code\u003e) \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003ein the header names may or may not be supported, and the behavior will depend on the specific implementation.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 19.2 - Non-standard characters should not occur in header file names in #include directives. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 16-2-4 - The \u0027, \", /* or // characters shall not occur in a header file name. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 16-2-5 - The \\ character should not occur in a header file name. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 20.2 - The \u0027, \" or \\ characters and the /* or // character sequences shall not occur in a header file name \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "based-on-misra"
    ],
    "deprecatedKeys": [
      "c:PPIncludeNonStandardCharacters"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S835",
    "name": "Braces should be used to indicate and match the structure in the non-zero initialization of arrays and structures",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "FORMATTED",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eISO/IEC 14882:2003 [1] requires initializer lists for arrays, structures and union types to be enclosed in a single pair of braces (though the\nbehaviour if this is not done is undefined). The rule given here goes further in requiring the use of additional braces to indicate nested\nstructures.\u003c/p\u003e\n\u003cp\u003eThis forces the developer to explicitly consider and demonstrate the order in which elements of complex data types are initialized (e.g.\nmulti-dimensional arrays).\u003c/p\u003e\n\u003cp\u003eThe zero initialization of arrays or structures shall only be applied at the top level.\u003c/p\u003e\n\u003cp\u003eThe non-zero initialization of arrays or structures requires an explicit initializer for each element.\u003c/p\u003e\n\u003cp\u003eA similar principle applies to structures, and nested combinations of structures, arrays and other types.\u003c/p\u003e\n\u003cp\u003eNote also that all the elements of arrays or structures can be initialized (to zero or NULL) by giving an explicit initializer for the first\nelement only. If this method of initialization is chosen then the first element should be initialized to zero (or NULL), and nested braces need not be\nused.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint a1[3][2] \u003d { 1, 2, 3, 4, 5, 6 }; // Noncompliant\nint a2[5] \u003d { 1, 2, 3 }; // Noncompliant, partial initialization\nint a3[2][2] \u003d { { }, { 1, 2 } }; // Noncompliant, zero initialization at sub-level\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint a1[3][2] \u003d { { 1, 2 }, { 3, 4 }, { 5, 6 } }; // Compliant\nint a2[5] \u003d { 1, 2, 3, 0, 0 }; // Compliant, Non-zero initialization\nint a2[5] \u003d { 0 }; // Compliant, zero initialization\nint a3[2][2] \u003d { }; // Compliant, zero initialization\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 9.2 - Braces shall be used to indicate and match the structure in the non-zero initialization of arrays and structures. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 8-5-2 - Braces shall be used to indicate and match the structure in the nonzero initialization of arrays and structures. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 9.2 - The initializer of an aggregate or union shall be enclosed in braces. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 9.3 - Arrays shall not be partially initialized. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eISO/IEC 14882:2003 [1] requires initializer lists for arrays, structures and union types to be enclosed in a single pair of braces (though the\nbehaviour if this is not done is undefined). The rule given here goes further in requiring the use of additional braces to indicate nested\nstructures.\u003c/p\u003e\n\u003cp\u003eThis forces the developer to explicitly consider and demonstrate the order in which elements of complex data types are initialized (e.g.\nmulti-dimensional arrays).\u003c/p\u003e\n\u003cp\u003eThe zero initialization of arrays or structures shall only be applied at the top level.\u003c/p\u003e\n\u003cp\u003eThe non-zero initialization of arrays or structures requires an explicit initializer for each element.\u003c/p\u003e\n\u003cp\u003eA similar principle applies to structures, and nested combinations of structures, arrays and other types.\u003c/p\u003e\n\u003cp\u003eNote also that all the elements of arrays or structures can be initialized (to zero or NULL) by giving an explicit initializer for the first\nelement only. If this method of initialization is chosen then the first element should be initialized to zero (or NULL), and nested braces need not be\nused.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint a1[3][2] \u003d { 1, 2, 3, 4, 5, 6 }; // Noncompliant\nint a2[5] \u003d { 1, 2, 3 }; // Noncompliant, partial initialization\nint a3[2][2] \u003d { { }, { 1, 2 } }; // Noncompliant, zero initialization at sub-level\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint a1[3][2] \u003d { { 1, 2 }, { 3, 4 }, { 5, 6 } }; // Compliant\nint a2[5] \u003d { 1, 2, 3, 0, 0 }; // Compliant, Non-zero initialization\nint a2[5] \u003d { 0 }; // Compliant, zero initialization\nint a3[2][2] \u003d { }; // Compliant, zero initialization\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 9.2 - Braces shall be used to indicate and match the structure in the non-zero initialization of arrays and structures. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 8-5-2 - Braces shall be used to indicate and match the structure in the nonzero initialization of arrays and structures. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 9.2 - The initializer of an aggregate or union shall be enclosed in braces. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 9.3 - Arrays shall not be partially initialized. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "based-on-misra"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S956",
    "name": "\"#include\" directives should be followed by either \u003cfilename\u003e or \"filename\" sequences",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003e#include\u003c/code\u003e directive is a preprocessor directive that tells the compiler to insert the contents of a file in the source code.\u003c/p\u003e\n\u003cp\u003eHowever, the standard only allows the \u003ccode\u003e#include\u003c/code\u003e directive to be followed by angle brackets (\u003ccode\u003e\u0026lt;filename.h\u0026gt;\u003c/code\u003e) or double\nquotes (\u003ccode\u003e\"filename.h\"\u003c/code\u003e).\u003c/p\u003e\n\u003cp\u003eIf the \u003ccode\u003e#include\u003c/code\u003e directive contains macro names, the result of their expansion must also follow this rule:\u003c/p\u003e\n\u003cpre\u003e\n#define HEADER \"filename.h\"\n#include HEADER // Compliant\n\u003c/pre\u003e\n\u003cp\u003eThe behavior is undefined if neither angle brackets nor double quotes follow the \u003ccode\u003e#include\u003c/code\u003e directive.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 19.3 - The #include directive shall be followed by either a \u0026lt;filename\u0026gt; or \"filename\" sequence. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 16-2-6 - The #include directive shall be followed by either a \u0026lt;filename\u0026gt; or \"filename\" sequence. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 20.3 - The #include directive shall be followed by either a \u0026lt;filename\u0026gt; or \"filename\" sequence \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe \u003ccode\u003e#include\u003c/code\u003e directive is a preprocessor directive that tells the compiler to insert the contents of a file in the source code.\u003c/p\u003e\n\u003cp\u003eHowever, the standard only allows the \u003ccode\u003e#include\u003c/code\u003e directive to be followed by angle brackets (\u003ccode\u003e\u0026lt;filename.h\u0026gt;\u003c/code\u003e) or double\nquotes (\u003ccode\u003e\"filename.h\"\u003c/code\u003e).\u003c/p\u003e\n\u003cp\u003eIf the \u003ccode\u003e#include\u003c/code\u003e directive contains macro names, the result of their expansion must also follow this rule:\u003c/p\u003e\n\u003cpre\u003e\n#define HEADER \"filename.h\"\n#include HEADER // Compliant\n\u003c/pre\u003e\n\u003cp\u003eThe behavior is undefined if neither angle brackets nor double quotes follow the \u003ccode\u003e#include\u003c/code\u003e directive.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 19.3 - The #include directive shall be followed by either a \u0026lt;filename\u0026gt; or \"filename\" sequence. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 16-2-6 - The #include directive shall be followed by either a \u0026lt;filename\u0026gt; or \"filename\" sequence. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 20.3 - The #include directive shall be followed by either a \u0026lt;filename\u0026gt; or \"filename\" sequence \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "based-on-misra"
    ],
    "deprecatedKeys": [
      "c:PPBadIncludeForm"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S953",
    "name": "Unions should not be used",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe use of unions to access an object in different ways may result in the data being misinterpreted. Therefore, this rule prohibits the use of\nunions for any purpose.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nunion U1 { // Noncompliant\n    float j;\n    int i;\n};\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 18.4 - Unions shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 9-5-1 - Unions shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 19.2 - The union keyword should not be used \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe use of unions to access an object in different ways may result in the data being misinterpreted. Therefore, this rule prohibits the use of\nunions for any purpose.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nunion U1 { // Noncompliant\n    float j;\n    int i;\n};\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 18.4 - Unions shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 9-5-1 - Unions shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 19.2 - The union keyword should not be used \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "based-on-misra"
    ],
    "deprecatedKeys": [
      "c:Union"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S833",
    "name": "If a function has internal linkage then all re-declarations shall include the static storage class specifer",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThis rule is a strict implementation of a MISRA (Motor Industry Software Reliability Association) rule. MISRA defines best practices for developing\nsafety-critical software. You can learn more about this rule in the MISRA documents referenced below.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++ 2008, 3-3-2 \u003c/li\u003e\n  \u003cli\u003e MISRA C 2004, 8.11 \u003c/li\u003e\n  \u003cli\u003e MISRA C 2012, 8.8 \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThis rule is a strict implementation of a MISRA (Motor Industry Software Reliability Association) rule. MISRA defines best practices for developing\nsafety-critical software. You can learn more about this rule in the MISRA documents referenced below.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C++ 2008, 3-3-2 \u003c/li\u003e\n  \u003cli\u003e MISRA C 2004, 8.11 \u003c/li\u003e\n  \u003cli\u003e MISRA C 2012, 8.8 \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "misra-c++2008",
      "misra-c2004",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S954",
    "name": "#include directives in a file should only be preceded by other preprocessor directives or comments",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eTo aid code readability, all the \u003ccode\u003e#include\u003c/code\u003e directives in a particular code file should be grouped together near the top of the file.\nThe only items which may precede an \u003ccode\u003e#include\u003c/code\u003e in a file are other preprocessor directives or comments.\u003c/p\u003e\n\u003cp\u003eAdditionally, an \u003ccode\u003e#include\u003c/code\u003e may appear within an \u003ccode\u003eextern \"C\"\u003c/code\u003e block, this can be used for instance to include a C file from a\nC++ file.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;h1.h\u0026gt; /* Compliant */\nint32_t i;\n#include \u0026lt;f2.h\u0026gt; /* Noncompliant */\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;h1.h\u0026gt;\n#include \u0026lt;f2.h\u0026gt;\nextern \"C\" {\n#include \u0026lt;f3.h\u0026gt;\n}\n\nint32_t i;\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 19.1 - #include statements in a file should only be preceded by other preprocessor directives or comments. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 16-0-1 - #include directives in a file shall only be preceded by other preprocessor directives or comments. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 20.1 - #include directives should only be preceded by preprocessor directives or comments \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eTo aid code readability, all the \u003ccode\u003e#include\u003c/code\u003e directives in a particular code file should be grouped together near the top of the file.\nThe only items which may precede an \u003ccode\u003e#include\u003c/code\u003e in a file are other preprocessor directives or comments.\u003c/p\u003e\n\u003cp\u003eAdditionally, an \u003ccode\u003e#include\u003c/code\u003e may appear within an \u003ccode\u003eextern \"C\"\u003c/code\u003e block, this can be used for instance to include a C file from a\nC++ file.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;h1.h\u0026gt; /* Compliant */\nint32_t i;\n#include \u0026lt;f2.h\u0026gt; /* Noncompliant */\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;h1.h\u0026gt;\n#include \u0026lt;f2.h\u0026gt;\nextern \"C\" {\n#include \u0026lt;f3.h\u0026gt;\n}\n\nint32_t i;\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 19.1 - #include statements in a file should only be preceded by other preprocessor directives or comments. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 16-0-1 - #include directives in a file shall only be preceded by other preprocessor directives or comments. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 20.1 - #include directives should only be preceded by preprocessor directives or comments \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "confusing",
      "misra-c++2008",
      "misra-c2004",
      "misra-c2012"
    ],
    "deprecatedKeys": [
      "c:PPIncludeNotAtTop"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S5782",
    "name": "POSIX functions should not be called with arguments that trigger buffer overflows",
    "defaultSeverity": "BLOCKER",
    "type": "VULNERABILITY",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "SECURITY": "HIGH",
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003cp\u003eSome POSIX functions take one argument that is a buffer and another one that represents the size of the buffer. It is up to the developer to make\nsure the two arguments do match and that the size argument does not exceed the buffer’s size.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhen the size argument exceeds the actual size of the buffer, the memory management functions will either read or write data past the buffer memory\nboundary into adjacent memory. Because the memory might be uninitialized or contain other pieces of data, the behavior of the affected function can\nnot be predicted and will likely trigger bugs.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eBuffer boundaries violations can lead to serious security issues.\u003c/p\u003e\n\u003ch4\u003eInformation disclosure\u003c/h4\u003e\n\u003cp\u003eIn some scenarios, insecure functions can lead to information disclosure. For instance, if an attacker can cause a buffer overread, they might be\nable to disclose data in memory that they’re not supposed to have access to. This could potentially allow them to access sensitive information, such\nas passwords or encryption keys. An example of a buffer overread is provided with the Heartbleed vulnerability. \u003d\u003d\u003d\u003d Code execution\u003c/p\u003e\n\u003cp\u003eIn some cases, an attacker can craft input in a way that allows them to gain unauthorized access to your system. For example, they might be able to\noverwrite a function’s return address in memory, causing your program to execute code of the attacker’s choosing. This could potentially give the\nattacker full control over your system.\u003c/p\u003e\n\u003ch4\u003eDenial of service\u003c/h4\u003e\n\u003cp\u003eIf an attacker can trigger a buffer overflow by providing oversized input, it can cause the program to crash. If the attacker repeats this process,\nit can continually disrupt the service, denying access to other users. This can be particularly damaging for services that require high availability,\nsuch as online platforms or databases.\u003c/p\u003e\n\u003cp\u003eIn some cases, the input might cause the program to enter an infinite loop or consume excessive memory, slowing down the system or even causing it\nto become unresponsive. This type of attack is known as a resource exhaustion DoS attack.\u003c/p\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eFunctions related to sockets using the type \u003ccode\u003esocklen_t\u003c/code\u003e are not checked. This is because these functions are using a C-style polymorphic\npattern using \u003ccode\u003eunion\u003c/code\u003e. It relies on a mismatch between allocated memory and sizes of structures and it creates false positives.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003cp\u003eIn the following code example, \u003ccode\u003ememchr\u003c/code\u003e is used to find the first occurrence of the \u003ccode\u003e@\u003c/code\u003e character in a buffer,\n\u003ccode\u003earray\u003c/code\u003e. The second argument does not match the size of this buffer, so it may find an occurrence of the character after the end of the\nbuffer and read data it is not supposed to. If the returned \u003ccode\u003epos\u003c/code\u003e pointer is later used to write characters, this could unexpectedly\noverwrite data.\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nchar array[10];\ninitialize(array);\nchar *pos \u003d memchr(array, \u0027@\u0027, 42); // Noncompliant\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nchar array[10];\ninitialize(array);\nchar *pos \u003d memchr(array, \u0027@\u0027, sizeof(array));\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eArticles \u0026amp; blog posts\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Heartbleed - \u003ca href\u003d\"https://heartbleed.com/\"\u003eThe Heartbleed Bug\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e OWASP - \u003ca href\u003d\"https://owasp.org/Top10/A06_2021-Vulnerable_and_Outdated_Components/\"\u003eTop 10 2021 - A06 - Vulnerable and Outdated\n  Components\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e OWASP - \u003ca href\u003d\"https://owasp.org/www-project-top-ten/2017/A9_2017-Using_Components_with_Known_Vulnerabilities\"\u003eOWASP Top 10 2017 Category A9\n  - Using Components with Known Vulnerabilities\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/119\"\u003eCWE-119 - Improper Restriction of Operations within the Bounds of a Memory\n  Buffer\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/131\"\u003eCWE-131 - Incorrect Calculation of Buffer Size\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/788\"\u003eCWE-788 - Access of Memory Location After End of Buffer\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/wtYxBQ\"\u003eARR30-C. - Do not form or use out-of-bounds pointers or array subscripts\u003c/a\u003e\n  \u003c/li\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/i3w-BQ\"\u003eSTR50-CPP. - Guarantee that storage for strings has sufficient space for\n  character data and the null terminator\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eSome POSIX functions take one argument that is a buffer and another one that represents the size of the buffer. It is up to the developer to make\nsure the two arguments do match and that the size argument does not exceed the buffer’s size.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhen the size argument exceeds the actual size of the buffer, the memory management functions will either read or write data past the buffer memory\nboundary into adjacent memory. Because the memory might be uninitialized or contain other pieces of data, the behavior of the affected function can\nnot be predicted and will likely trigger bugs.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eBuffer boundaries violations can lead to serious security issues.\u003c/p\u003e\n\u003ch4\u003eInformation disclosure\u003c/h4\u003e\n\u003cp\u003eIn some scenarios, insecure functions can lead to information disclosure. For instance, if an attacker can cause a buffer overread, they might be\nable to disclose data in memory that they’re not supposed to have access to. This could potentially allow them to access sensitive information, such\nas passwords or encryption keys. An example of a buffer overread is provided with the Heartbleed vulnerability. \u003d\u003d\u003d\u003d Code execution\u003c/p\u003e\n\u003cp\u003eIn some cases, an attacker can craft input in a way that allows them to gain unauthorized access to your system. For example, they might be able to\noverwrite a function’s return address in memory, causing your program to execute code of the attacker’s choosing. This could potentially give the\nattacker full control over your system.\u003c/p\u003e\n\u003ch4\u003eDenial of service\u003c/h4\u003e\n\u003cp\u003eIf an attacker can trigger a buffer overflow by providing oversized input, it can cause the program to crash. If the attacker repeats this process,\nit can continually disrupt the service, denying access to other users. This can be particularly damaging for services that require high availability,\nsuch as online platforms or databases.\u003c/p\u003e\n\u003cp\u003eIn some cases, the input might cause the program to enter an infinite loop or consume excessive memory, slowing down the system or even causing it\nto become unresponsive. This type of attack is known as a resource exhaustion DoS attack.\u003c/p\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eFunctions related to sockets using the type \u003ccode\u003esocklen_t\u003c/code\u003e are not checked. This is because these functions are using a C-style polymorphic\npattern using \u003ccode\u003eunion\u003c/code\u003e. It relies on a mismatch between allocated memory and sizes of structures and it creates false positives.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eIn the following code example, \u003ccode\u003ememchr\u003c/code\u003e is used to find the first occurrence of the \u003ccode\u003e@\u003c/code\u003e character in a buffer,\n\u003ccode\u003earray\u003c/code\u003e. The second argument does not match the size of this buffer, so it may find an occurrence of the character after the end of the\nbuffer and read data it is not supposed to. If the returned \u003ccode\u003epos\u003c/code\u003e pointer is later used to write characters, this could unexpectedly\noverwrite data.\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nchar array[10];\ninitialize(array);\nchar *pos \u003d memchr(array, \u0027@\u0027, 42); // Noncompliant\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nchar array[10];\ninitialize(array);\nchar *pos \u003d memchr(array, \u0027@\u0027, sizeof(array));\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eArticles \u0026amp; blog posts\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Heartbleed - \u003ca href\u003d\"https://heartbleed.com/\"\u003eThe Heartbleed Bug\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e OWASP - \u003ca href\u003d\"https://owasp.org/Top10/A06_2021-Vulnerable_and_Outdated_Components/\"\u003eTop 10 2021 - A06 - Vulnerable and Outdated\n  Components\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e OWASP - \u003ca href\u003d\"https://owasp.org/www-project-top-ten/2017/A9_2017-Using_Components_with_Known_Vulnerabilities\"\u003eOWASP Top 10 2017 Category A9\n  - Using Components with Known Vulnerabilities\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/119\"\u003eCWE-119 - Improper Restriction of Operations within the Bounds of a Memory\n  Buffer\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/131\"\u003eCWE-131 - Incorrect Calculation of Buffer Size\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/788\"\u003eCWE-788 - Access of Memory Location After End of Buffer\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/wtYxBQ\"\u003eARR30-C. - Do not form or use out-of-bounds pointers or array subscripts\u003c/a\u003e\n  \u003c/li\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/i3w-BQ\"\u003eSTR50-CPP. - Guarantee that storage for strings has sufficient space for\n  character data and the null terminator\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "cert",
      "cwe",
      "symbolic-execution"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S2393",
    "name": "The \"\u003cstdlib.h\u003e\" functions \"bsearch\" and \"qsort\" should not be used",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe identifiers \u003ccode\u003ebsearch\u003c/code\u003e and \u003ccode\u003eqsort\u003c/code\u003e shall not be used and no macro with one of these names shall be expanded.\u003c/p\u003e\n\u003cp\u003eThese two functions take as arguments a caller-defined comparison function. If the comparison function does not behave consistently when comparing\nelements, or if it modifies any of the elements, the behavior is undefined.\u003c/p\u003e\n\u003cp\u003eNote: the unspecified behavior, which relates to the treatment of elements that compare as equal, can be avoided by ensuring that the comparison\nfunction never returns 0. When two elements are otherwise equal, the comparison function could return a value that indicates their relative order in\nthe initial array.\u003c/p\u003e\n\u003cp\u003eFurther, the implementation of \u003ccode\u003eqsort\u003c/code\u003e is likely to be recursive and will therefore place unknown demands on stack resources. This is of\nconcern in embedded systems because the stack is likely to have a fixed, often small, size.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2012, 21.9 - The library functions \u003ccode\u003ebsearch\u003c/code\u003e and \u003ccode\u003eqsort\u003c/code\u003e of \u003ccode\u003e\u0026lt;stdlib.h\u0026gt;\u003c/code\u003e shall not be used.\n  \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe identifiers \u003ccode\u003ebsearch\u003c/code\u003e and \u003ccode\u003eqsort\u003c/code\u003e shall not be used and no macro with one of these names shall be expanded.\u003c/p\u003e\n\u003cp\u003eThese two functions take as arguments a caller-defined comparison function. If the comparison function does not behave consistently when comparing\nelements, or if it modifies any of the elements, the behavior is undefined.\u003c/p\u003e\n\u003cp\u003eNote: the unspecified behavior, which relates to the treatment of elements that compare as equal, can be avoided by ensuring that the comparison\nfunction never returns 0. When two elements are otherwise equal, the comparison function could return a value that indicates their relative order in\nthe initial array.\u003c/p\u003e\n\u003cp\u003eFurther, the implementation of \u003ccode\u003eqsort\u003c/code\u003e is likely to be recursive and will therefore place unknown demands on stack resources. This is of\nconcern in embedded systems because the stack is likely to have a fixed, often small, size.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2012, 21.9 - The library functions \u003ccode\u003ebsearch\u003c/code\u003e and \u003ccode\u003eqsort\u003c/code\u003e of \u003ccode\u003e\u0026lt;stdlib.h\u0026gt;\u003c/code\u003e shall not be used.\n  \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "based-on-misra",
      "unpredictable"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S950",
    "name": "Structure and union types should be complete at the end of a translation unit",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eA complete declaration of the structure or union shall be included within any translation unit that refers to that structure. See section 6.1.2.5\nof ISO 9899:1990 [2] for a full description of incomplete types.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstruct tnode * pt; // tnode is incomplete\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstruct tnode * pt; // tnode is incomplete at this point\nstruct tnode\n{\n  int count;\n  struct tnode * left;\n  struct tnode * right;\n}; // type tnode is now complete\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 18.1 - All structure and union types shall be complete at the end of a translation unit. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eA complete declaration of the structure or union shall be included within any translation unit that refers to that structure. See section 6.1.2.5\nof ISO 9899:1990 [2] for a full description of incomplete types.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstruct tnode * pt; // tnode is incomplete\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstruct tnode * pt; // tnode is incomplete at this point\nstruct tnode\n{\n  int count;\n  struct tnode * left;\n  struct tnode * right;\n}; // type tnode is now complete\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 18.1 - All structure and union types shall be complete at the end of a translation unit. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "based-on-misra"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:M23_403",
    "name": "The \"goto\" statement should not be used",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 9.6.1\u003c/p\u003e\n\u003cp\u003eCategory: Advisory\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eThe use of \u003ccode\u003egoto\u003c/code\u003e is usually regarded as bad programming practice as it can lead to code that is difficult to understand and analyse.\nRestructuring code to avoid its use generally leads to code that has a lower level of complexity.\u003c/p\u003e\n\u003cp\u003eIf this advice is not followed, {rule:c:M23_126}: MISRA C++ 2023 Rule\u0026nbsp;9.6.3 ensure that the use of \u003ccode\u003egoto\u003c/code\u003e does not result in code\nthat is considered to be unstructured.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:c:S907} targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2023 Rule\u0026nbsp;9.6.2 - A \u003ccode\u003egoto\u003c/code\u003e statement shall reference a label in a surrounding block \u003c/li\u003e\n  \u003cli\u003e {rule:c:M23_126}: MISRA C++ 2023 Rule\u0026nbsp;9.6.3 - The \u003ccode\u003egoto\u003c/code\u003e statement shall jump to a label declared later in the function body\n  \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cp\u003e\u003ca href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/036324/CppCoreGuidelines.md#es76-avoid-goto\"\u003eC++ Core Guidelines ES.76\u003c/a\u003e: Avoid\ngoto\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 9.6.1\u003c/p\u003e\n\u003cp\u003eCategory: Advisory\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eThe use of \u003ccode\u003egoto\u003c/code\u003e is usually regarded as bad programming practice as it can lead to code that is difficult to understand and analyse.\nRestructuring code to avoid its use generally leads to code that has a lower level of complexity.\u003c/p\u003e\n\u003cp\u003eIf this advice is not followed, {rule:c:M23_126}: MISRA C++ 2023 Rule\u0026nbsp;9.6.3 ensure that the use of \u003ccode\u003egoto\u003c/code\u003e does not result in code\nthat is considered to be unstructured.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:c:S907} targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2023 Rule\u0026nbsp;9.6.2 - A \u003ccode\u003egoto\u003c/code\u003e statement shall reference a label in a surrounding block \u003c/li\u003e\n  \u003cli\u003e {rule:c:M23_126}: MISRA C++ 2023 Rule\u0026nbsp;9.6.3 - The \u003ccode\u003egoto\u003c/code\u003e statement shall jump to a label declared later in the function body\n  \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cp\u003e\u003ca href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/036324/CppCoreGuidelines.md#es76-avoid-goto\"\u003eC++ Core Guidelines ES.76\u003c/a\u003e: Avoid\ngoto\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "misra-advisory",
      "misra-c++2023"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S959",
    "name": "\"#undef\" should be used with caution",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eCode that contains many macros becomes hard to understand. This is even worse when the set of defined macros is not stable, and you have to know at\neach point what macros are defined. Therefore, \u003ccode\u003e#undef\u003c/code\u003e can decrease the readability of macros.\u003c/p\u003e\n\u003cp\u003eHowever, well-disciplined use of \u003ccode\u003e#undef\u003c/code\u003e can also improve readability, for instance when defining a macro with a limited scope: The\nmacro is \u003ccode\u003e#defined\u003c/code\u003e, used a couple of times to reduce code duplication, then immediately \u003ccode\u003e#undefed\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when a \u003ccode\u003e#undef\u003c/code\u003e undefines a macro that was defined in another file. It will also raise an issue for an\n\u003ccode\u003e#undef\u003c/code\u003e directive that tries to undefine a non-existing macro.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#ifndef MY_HDR\n#define MY_HDR\n#endif\n...\n#undef MY_HDR    /* Noncompliant */\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#define LEVEL(i) int const i \u003d #i\nLEVEL(Debug);\nLEVEL(Warning);\nLEVEL(Error);\n#undef LEVEL\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 19.6 - #undef shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 16-0-3 - #undef shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 20.5 - #undef should not be used \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eCode that contains many macros becomes hard to understand. This is even worse when the set of defined macros is not stable, and you have to know at\neach point what macros are defined. Therefore, \u003ccode\u003e#undef\u003c/code\u003e can decrease the readability of macros.\u003c/p\u003e\n\u003cp\u003eHowever, well-disciplined use of \u003ccode\u003e#undef\u003c/code\u003e can also improve readability, for instance when defining a macro with a limited scope: The\nmacro is \u003ccode\u003e#defined\u003c/code\u003e, used a couple of times to reduce code duplication, then immediately \u003ccode\u003e#undefed\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when a \u003ccode\u003e#undef\u003c/code\u003e undefines a macro that was defined in another file. It will also raise an issue for an\n\u003ccode\u003e#undef\u003c/code\u003e directive that tries to undefine a non-existing macro.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#ifndef MY_HDR\n#define MY_HDR\n#endif\n...\n#undef MY_HDR    /* Noncompliant */\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#define LEVEL(i) int const i \u003d #i\nLEVEL(Debug);\nLEVEL(Warning);\nLEVEL(Error);\n#undef LEVEL\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 19.6 - #undef shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 16-0-3 - #undef shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 20.5 - #undef should not be used \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "based-on-misra",
      "brain-overload"
    ],
    "deprecatedKeys": [
      "c:PPUndefUsage"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S836",
    "name": "Variables should be initialized before use",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003cp\u003eVariables should be initialized before their use to avoid unexpected behavior due to garbage values.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eA local variable of any built-in type (such as \u003ccode\u003eint\u003c/code\u003e, \u003ccode\u003efloat\u003c/code\u003e, and pointers), declared without an initial value is not\ninitialized to any particular value. Consequently, if no value is assigned to such a variable first, the code that uses it has no defined\nbehavior.\u003c/p\u003e\n\u003cpre\u003e\nint addition() {\n  int x;  // x is not initialized\n  return x + 10; // Noncompliant: x has grabage value\n}\n\nint dereference() {\n  int* p; // p is not initialized\n  return *p; // Noncompliant: p has garbage value\n}\n\u003c/pre\u003e\n\u003cp\u003eSimilarly, structures that simply aggregate variables of built-in types, such as arrays or \u003ccode\u003estruct\u003c/code\u003e/\u003ccode\u003eclass\u003c/code\u003e types without a\nconstructor, will not initialize their members when declared without an initializer:\u003c/p\u003e\n\u003cpre\u003e\nstruct Aggregate {\n  int i;\n  float f;\n};\n\nvoid aggregates() {\n  int* intArray[5]; // each element of array is not initializer\n  Aggregate aggr; // members aggr.i, agrr.f are not initialized\n  Aggregate aggrArray[2]; // members of each element are not initialized\n}\n\u003c/pre\u003e\n\u003cp\u003eFinally, allocating objects of builtin or such aggregates types on the heap, also does not initialize their values:\u003c/p\u003e\n\u003cpre\u003e\nvoid usingMalloc() {\n  int* intArr \u003d (int*)malloc(sizeof(int) * 10); // each of 10 allocated integers is not initialized\n}\n\u003c/pre\u003e\n\u003cp\u003eThis also applies when \u003ccode\u003enew\u003c/code\u003e is used in C++:\u003c/p\u003e\n\u003cpre\u003e\nvoid usingNew() {\n  Aggregate* aggrPtr \u003d new Aggregate; // members of allocated Aggregate are not initialized\n  Aggregate* aggrArr \u003d new Aggregate[5]; // members of each of 5 Aggregate objects are not initialized\n}\n\u003c/pre\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eUsing garbage values will cause the program to behave nondeterministically at runtime. The program may produce a different output or crash\ndepending on the run.\u003c/p\u003e\n\u003cp\u003eIn some situations, loading a variable may expose a sensitive data, such as a password that was previously stored in the same location, leading to\na vulnerability that uses such a defect as a gadget for extracting information from the instance of the program.\u003c/p\u003e\n\u003cp\u003eFinally, in C++, outside of a few exceptions related to the uses of \u003ccode\u003eunsigned char\u003c/code\u003e or \u003ccode\u003estd::byte\u003c/code\u003e, loading data from an\nuninitialized variable causes undefined behavior. This means that the compiler is not bound by the language standard anymore, and the program has no\nmeaning assigned to it. As a consequence, the impact of such a defect is not limited to the use of garbage values.\u003c/p\u003e\n\u003ch3\u003eWhy is there an issue for a class with a default constructor?\u003c/h3\u003e\n\u003cp\u003eIn C++, a class can define a default constructor invoked when an object of the given type is created. Such a constructor is called even if a\nvariable is declared without any initializer. However, if the constructor code omits the initialization of a member that itself does not have the\ndefault constructor, the member will remain uninitialized (See also S2107). And reading from it will produce a garbage value:\u003c/p\u003e\n\u003cpre\u003e\nstruct Partial {\n  // x is not initialized\n  Partial() : y(10.0) {}\n\n  int x;\n  float y;\n};\n\nint initialized() {\n  Partial p; // constructor is called\n  // or even Partial p{};\n  return p.x; // Non-compliant: reading an uninitialized variable\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThis rule does not flag the variables with static storage duration, meaning: global, static, and thread-local variables.\u003c/p\u003e\n\u003cp\u003eAll the variables with static storage duration are zero-initialized before the initializer is evaluated. As a consequence, any variable or member\nof such an object has a defined value even if no initializer is specified.\u003c/p\u003e\n\u003cpre\u003e\nint globInt;\nint globTab[10];\nAggregate globAggr;\nPartial globPart; // x member is zero-initialized\n\nint uses() {\n  static int staticInt;\n  return globInt     // Compliant: all zero-initialized\n       + globTab[2]\n       + globAggr.f\n       + globPart.x\n       + staticInt;\n}\n\u003c/pre\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eCommonly, the use of an uninitialized object is an indication of a defect in the code, where either variable initialization was skipped on some\ncode paths, or the object is used by mistake. Generally, you can address such problems by:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Initializing variables on the declaration with a valid value \u003c/li\u003e\n  \u003cli\u003e Assigning to the variable on the code path(s) that was missing initialization \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWhenever possible, it is preferable to initialize a variable with its final value on the declaration, as this eliminates the possibility of this\ndefect occurring.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nint function(int flag, int b) {\n  int a;\n  if (flag) {\n    a \u003d b;\n  }\n  return a; // Noncompliant: \"a\" has not been initialized in all paths\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eInitializing variable on all code paths:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nint function(int flag, int b) {\n  int a;\n  if (flag) {\n    a \u003d b;\n  } else {\n    a \u003d 10;\n  }\n  return a; // Compliant\n}\n\u003c/pre\u003e\n\u003cp\u003eSkipping path that leads to the read of an uninitialized value:\u003c/p\u003e\n\u003cpre\u003e\nint function(int flag, int b) {\n  int a;\n  if (flag) {\n    a \u003d b;\n  } else {\n    return 10;\n  }\n  return a; // Compliant\n}\n\u003c/pre\u003e\n\u003cp\u003eProviding a valid initial value:\u003c/p\u003e\n\u003cpre\u003e\nint function(int flag, int b) {\n  int a \u003d 10;\n  if (flag) {\n    a \u003d b;\n  }\n  return a; // Compliant\n}\n\u003c/pre\u003e\n\u003cp\u003eInitializing value in the definition:\u003c/p\u003e\n\u003cpre\u003e\nint function(int flag, int b) {\n  int const a \u003d flag ? b : 10;\n  return a; // Compliant\n}\n\u003c/pre\u003e\n\u003ch3\u003ePitfalls\u003c/h3\u003e\n\u003cp\u003eInitializing the variable to zero at the declaration is not always the right solution to fix the issue, as it may lead to logic errors if such a\nvalue is not handled correctly. For example, setting an \u003ccode\u003eage\u003c/code\u003e field of an \u003ccode\u003eEmployee\u003c/code\u003e structure may break assumptions of\nretirement handling code. Or more commonly, setting a pointer to \u003ccode\u003eNULL\u003c/code\u003e will turn dereference of an uninitialized value into a null-pointer\ndereference.\u003c/p\u003e\n\u003ch3\u003eGoing the extra mile\u003c/h3\u003e\n\u003cp\u003eWith the addition of lambdas in C++11, it is possible to initialize variables on declaration without creating a separate function to compute the\nvalue:\u003c/p\u003e\n\u003cpre\u003e\nint x \u003d [\u0026amp;] { // capture all context by reference\n  if (someCondition())\n    return computeVar1();\n  /* perform more computations */\n  return other;\n}(); // invoke the lambda immediately (right after creation)\n\u003c/pre\u003e\n\u003cp\u003eSuch pattern is referred to as an \u003cem\u003eImmediately invoked function expression\u003c/em\u003e (IIFE) or \u003cem\u003eImediately invoked lambda\u003c/em\u003e. Furthermore, with\nthe addition of structured binding in C++17, it is possible to declare multiple variables whose values are coupled:\u003c/p\u003e\n\u003cpre\u003e\nauto [px, py, pz] \u003d [\u0026amp;] {\n  if (x_dir) {\n    return std::make_tuple(1, 0, 0);\n  } else if (y_dir) {\n    return std::make_tuple(0, 1, 0);\n  } else {\n    assert(z_dir);\n    return std::make_tuple(0, 0, 1);\n  }\n}();\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/storage_duration\"\u003eStorage class specifiers\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/457\"\u003e457 Use of Uninitialized Variable\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e MISRA C:2004, 9.1 - All automatic variables shall have been assigned a value before being used. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 8-5-1 - All variables shall have a defined value before they are used. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e S2107 detects fields being left uninitialized after the invocation of a constructor \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eVariables should be initialized before their use to avoid unexpected behavior due to garbage values.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eA local variable of any built-in type (such as \u003ccode\u003eint\u003c/code\u003e, \u003ccode\u003efloat\u003c/code\u003e, and pointers), declared without an initial value is not\ninitialized to any particular value. Consequently, if no value is assigned to such a variable first, the code that uses it has no defined\nbehavior.\u003c/p\u003e\n\u003cpre\u003e\nint addition() {\n  int x;  // x is not initialized\n  return x + 10; // Noncompliant: x has grabage value\n}\n\nint dereference() {\n  int* p; // p is not initialized\n  return *p; // Noncompliant: p has garbage value\n}\n\u003c/pre\u003e\n\u003cp\u003eSimilarly, structures that simply aggregate variables of built-in types, such as arrays or \u003ccode\u003estruct\u003c/code\u003e/\u003ccode\u003eclass\u003c/code\u003e types without a\nconstructor, will not initialize their members when declared without an initializer:\u003c/p\u003e\n\u003cpre\u003e\nstruct Aggregate {\n  int i;\n  float f;\n};\n\nvoid aggregates() {\n  int* intArray[5]; // each element of array is not initializer\n  Aggregate aggr; // members aggr.i, agrr.f are not initialized\n  Aggregate aggrArray[2]; // members of each element are not initialized\n}\n\u003c/pre\u003e\n\u003cp\u003eFinally, allocating objects of builtin or such aggregates types on the heap, also does not initialize their values:\u003c/p\u003e\n\u003cpre\u003e\nvoid usingMalloc() {\n  int* intArr \u003d (int*)malloc(sizeof(int) * 10); // each of 10 allocated integers is not initialized\n}\n\u003c/pre\u003e\n\u003cp\u003eThis also applies when \u003ccode\u003enew\u003c/code\u003e is used in C++:\u003c/p\u003e\n\u003cpre\u003e\nvoid usingNew() {\n  Aggregate* aggrPtr \u003d new Aggregate; // members of allocated Aggregate are not initialized\n  Aggregate* aggrArr \u003d new Aggregate[5]; // members of each of 5 Aggregate objects are not initialized\n}\n\u003c/pre\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eUsing garbage values will cause the program to behave nondeterministically at runtime. The program may produce a different output or crash\ndepending on the run.\u003c/p\u003e\n\u003cp\u003eIn some situations, loading a variable may expose a sensitive data, such as a password that was previously stored in the same location, leading to\na vulnerability that uses such a defect as a gadget for extracting information from the instance of the program.\u003c/p\u003e\n\u003cp\u003eFinally, in C++, outside of a few exceptions related to the uses of \u003ccode\u003eunsigned char\u003c/code\u003e or \u003ccode\u003estd::byte\u003c/code\u003e, loading data from an\nuninitialized variable causes undefined behavior. This means that the compiler is not bound by the language standard anymore, and the program has no\nmeaning assigned to it. As a consequence, the impact of such a defect is not limited to the use of garbage values.\u003c/p\u003e\n\u003ch3\u003eWhy is there an issue for a class with a default constructor?\u003c/h3\u003e\n\u003cp\u003eIn C++, a class can define a default constructor invoked when an object of the given type is created. Such a constructor is called even if a\nvariable is declared without any initializer. However, if the constructor code omits the initialization of a member that itself does not have the\ndefault constructor, the member will remain uninitialized (See also S2107). And reading from it will produce a garbage value:\u003c/p\u003e\n\u003cpre\u003e\nstruct Partial {\n  // x is not initialized\n  Partial() : y(10.0) {}\n\n  int x;\n  float y;\n};\n\nint initialized() {\n  Partial p; // constructor is called\n  // or even Partial p{};\n  return p.x; // Non-compliant: reading an uninitialized variable\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThis rule does not flag the variables with static storage duration, meaning: global, static, and thread-local variables.\u003c/p\u003e\n\u003cp\u003eAll the variables with static storage duration are zero-initialized before the initializer is evaluated. As a consequence, any variable or member\nof such an object has a defined value even if no initializer is specified.\u003c/p\u003e\n\u003cpre\u003e\nint globInt;\nint globTab[10];\nAggregate globAggr;\nPartial globPart; // x member is zero-initialized\n\nint uses() {\n  static int staticInt;\n  return globInt     // Compliant: all zero-initialized\n       + globTab[2]\n       + globAggr.f\n       + globPart.x\n       + staticInt;\n}\n\u003c/pre\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eCommonly, the use of an uninitialized object is an indication of a defect in the code, where either variable initialization was skipped on some\ncode paths, or the object is used by mistake. Generally, you can address such problems by:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Initializing variables on the declaration with a valid value \u003c/li\u003e\n  \u003cli\u003e Assigning to the variable on the code path(s) that was missing initialization \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWhenever possible, it is preferable to initialize a variable with its final value on the declaration, as this eliminates the possibility of this\ndefect occurring.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nint function(int flag, int b) {\n  int a;\n  if (flag) {\n    a \u003d b;\n  }\n  return a; // Noncompliant: \"a\" has not been initialized in all paths\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eInitializing variable on all code paths:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nint function(int flag, int b) {\n  int a;\n  if (flag) {\n    a \u003d b;\n  } else {\n    a \u003d 10;\n  }\n  return a; // Compliant\n}\n\u003c/pre\u003e\n\u003cp\u003eSkipping path that leads to the read of an uninitialized value:\u003c/p\u003e\n\u003cpre\u003e\nint function(int flag, int b) {\n  int a;\n  if (flag) {\n    a \u003d b;\n  } else {\n    return 10;\n  }\n  return a; // Compliant\n}\n\u003c/pre\u003e\n\u003cp\u003eProviding a valid initial value:\u003c/p\u003e\n\u003cpre\u003e\nint function(int flag, int b) {\n  int a \u003d 10;\n  if (flag) {\n    a \u003d b;\n  }\n  return a; // Compliant\n}\n\u003c/pre\u003e\n\u003cp\u003eInitializing value in the definition:\u003c/p\u003e\n\u003cpre\u003e\nint function(int flag, int b) {\n  int const a \u003d flag ? b : 10;\n  return a; // Compliant\n}\n\u003c/pre\u003e\n\u003ch3\u003ePitfalls\u003c/h3\u003e\n\u003cp\u003eInitializing the variable to zero at the declaration is not always the right solution to fix the issue, as it may lead to logic errors if such a\nvalue is not handled correctly. For example, setting an \u003ccode\u003eage\u003c/code\u003e field of an \u003ccode\u003eEmployee\u003c/code\u003e structure may break assumptions of\nretirement handling code. Or more commonly, setting a pointer to \u003ccode\u003eNULL\u003c/code\u003e will turn dereference of an uninitialized value into a null-pointer\ndereference.\u003c/p\u003e\n\u003ch3\u003eGoing the extra mile\u003c/h3\u003e\n\u003cp\u003eWith the addition of lambdas in C++11, it is possible to initialize variables on declaration without creating a separate function to compute the\nvalue:\u003c/p\u003e\n\u003cpre\u003e\nint x \u003d [\u0026amp;] { // capture all context by reference\n  if (someCondition())\n    return computeVar1();\n  /* perform more computations */\n  return other;\n}(); // invoke the lambda immediately (right after creation)\n\u003c/pre\u003e\n\u003cp\u003eSuch pattern is referred to as an \u003cem\u003eImmediately invoked function expression\u003c/em\u003e (IIFE) or \u003cem\u003eImediately invoked lambda\u003c/em\u003e. Furthermore, with\nthe addition of structured binding in C++17, it is possible to declare multiple variables whose values are coupled:\u003c/p\u003e\n\u003cpre\u003e\nauto [px, py, pz] \u003d [\u0026amp;] {\n  if (x_dir) {\n    return std::make_tuple(1, 0, 0);\n  } else if (y_dir) {\n    return std::make_tuple(0, 1, 0);\n  } else {\n    assert(z_dir);\n    return std::make_tuple(0, 0, 1);\n  }\n}();\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/storage_duration\"\u003eStorage class specifiers\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/457\"\u003e457 Use of Uninitialized Variable\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e MISRA C:2004, 9.1 - All automatic variables shall have been assigned a value before being used. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 8-5-1 - All variables shall have a defined value before they are used. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e S2107 detects fields being left uninitialized after the invocation of a constructor \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "based-on-misra",
      "cwe",
      "symbolic-execution"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S958",
    "name": "Macros should not be #define\u0027d or #undef\u0027d within a block",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhile it is legal to place \u003ccode\u003e#define\u003c/code\u003e and \u003ccode\u003e#undef\u003c/code\u003e directives anywhere in a source file, placing them outside of the global\nnamespace is misleading since their scope is not actually restricted. This may be inconsistent with developer expectations.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nnamespace NS\n{\n  #ifndef MY_HDR\n  #define MY_HDR    /* Noncompliant */\n  #undef FOO        /* Noncompliant */\n  #endif\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#ifndef MY_HDR\n#define MY_HDR\n#undef FOO\n#endif\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 19.5 - Macros shall not be #define’d or #undef’d within a block. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 16-0-2 - Macros shall only be #define’d or #undef’d in the global namespace. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhile it is legal to place \u003ccode\u003e#define\u003c/code\u003e and \u003ccode\u003e#undef\u003c/code\u003e directives anywhere in a source file, placing them outside of the global\nnamespace is misleading since their scope is not actually restricted. This may be inconsistent with developer expectations.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nnamespace NS\n{\n  #ifndef MY_HDR\n  #define MY_HDR    /* Noncompliant */\n  #undef FOO        /* Noncompliant */\n  #endif\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#ifndef MY_HDR\n#define MY_HDR\n#undef FOO\n#endif\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 19.5 - Macros shall not be #define’d or #undef’d within a block. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 16-0-2 - Macros shall only be #define’d or #undef’d in the global namespace. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "based-on-misra",
      "pitfall"
    ],
    "deprecatedKeys": [
      "c:PPDefineOrUndefFromBlock"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:M23_400",
    "name": "An \"integer-literal\" of type \"long long\" shall not use a single \"L\" or \"l\" in any suffix",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 5.13.6\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eThis rule applies to both \u003ccode\u003esigned long long\u003c/code\u003e and \u003ccode\u003eunsigned long long\u003c/code\u003e literals.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e this rule does not apply to \u003cem\u003euser-defined-literals\u003c/em\u003e.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eA literal with a suffix that has a single \u003ccode\u003eL\u003c/code\u003e could be a \u003ccode\u003esigned\u003c/code\u003e or \u003ccode\u003eunsigned long long\u003c/code\u003e. Use of the\n\u003ccode\u003eLL\u003c/code\u003e suffix for \u003ccode\u003elong long\u003c/code\u003e literals is more explicit and less error-prone.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cp\u003eAll of the following examples assume that \u003ccode\u003elong\u003c/code\u003e is 32-bits and \u003ccode\u003elong long\u003c/code\u003e is 64-bits.\u003c/p\u003e\n\u003cpre\u003e\nauto k1 \u003d 12345678998L;        // Non-compliant\nauto k2 \u003d 12345678998UL;       // Non-compliant\nauto k3 \u003d 12345678998ull;      // Compliant\nauto k4 \u003d 0xfeeddeadbeefL;     // Non-compliant\nauto k5 \u003d 0xfeeddeadbeefLL;    // Compliant\n\u003c/pre\u003e\n\u003cp\u003eThe rule does not apply to the following as the value is not \u003ccode\u003elong long\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\nauto k6 \u003d 12345L;\nauto k7 \u003d 12345UL;\nauto k8 \u003d 0x0badc0deL;\n\u003c/pre\u003e\n\u003cp\u003eThe rule does not apply to the following as they do not have \u003ccode\u003eL\u003c/code\u003e or \u003ccode\u003el\u003c/code\u003e suffixes:\u003c/p\u003e\n\u003cpre\u003e\nauto k9 \u003d 12345678998;\nauto kA \u003d 12345678998U;\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003eMISRA C++ 2023 Rule\u0026nbsp;5.13.5 - The lowercase form of \"L\" shall not be used as the first character in a literal suffix\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 5.13.6\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eThis rule applies to both \u003ccode\u003esigned long long\u003c/code\u003e and \u003ccode\u003eunsigned long long\u003c/code\u003e literals.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e this rule does not apply to \u003cem\u003euser-defined-literals\u003c/em\u003e.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eA literal with a suffix that has a single \u003ccode\u003eL\u003c/code\u003e could be a \u003ccode\u003esigned\u003c/code\u003e or \u003ccode\u003eunsigned long long\u003c/code\u003e. Use of the\n\u003ccode\u003eLL\u003c/code\u003e suffix for \u003ccode\u003elong long\u003c/code\u003e literals is more explicit and less error-prone.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cp\u003eAll of the following examples assume that \u003ccode\u003elong\u003c/code\u003e is 32-bits and \u003ccode\u003elong long\u003c/code\u003e is 64-bits.\u003c/p\u003e\n\u003cpre\u003e\nauto k1 \u003d 12345678998L;        // Non-compliant\nauto k2 \u003d 12345678998UL;       // Non-compliant\nauto k3 \u003d 12345678998ull;      // Compliant\nauto k4 \u003d 0xfeeddeadbeefL;     // Non-compliant\nauto k5 \u003d 0xfeeddeadbeefLL;    // Compliant\n\u003c/pre\u003e\n\u003cp\u003eThe rule does not apply to the following as the value is not \u003ccode\u003elong long\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\nauto k6 \u003d 12345L;\nauto k7 \u003d 12345UL;\nauto k8 \u003d 0x0badc0deL;\n\u003c/pre\u003e\n\u003cp\u003eThe rule does not apply to the following as they do not have \u003ccode\u003eL\u003c/code\u003e or \u003ccode\u003el\u003c/code\u003e suffixes:\u003c/p\u003e\n\u003cpre\u003e\nauto k9 \u003d 12345678998;\nauto kA \u003d 12345678998U;\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003eMISRA C++ 2023 Rule\u0026nbsp;5.13.5 - The lowercase form of \"L\" shall not be used as the first character in a literal suffix\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "misra-c++2023",
      "misra-required",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S3923",
    "name": "All branches in a conditional structure should not have exactly the same implementation",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eHaving all branches of a \u003ccode\u003eswitch\u003c/code\u003e or \u003ccode\u003eif\u003c/code\u003e chain with the same implementation indicates a problem.\u003c/p\u003e\n\u003cp\u003eIn the following code:\u003c/p\u003e\n\u003cpre\u003e\nif (b \u003d\u003d 0) {  // Noncompliant\n  doOneMoreThing();\n} else {\n  doOneMoreThing();\n}\n\nint b \u003d a \u0026gt; 12 ? 4 : 4;  // Noncompliant\n\nswitch (i) {  // Noncompliant\n  case 1:\n    doSomething();\n    break;\n  case 2:\n    doSomething();\n    break;\n  case 3:\n    doSomething();\n    break;\n  default:\n    doSomething();\n}\n\u003c/pre\u003e\n\u003cp\u003eEither there is a copy-paste error that needs fixing or an unnecessary \u003ccode\u003eswitch\u003c/code\u003e or \u003ccode\u003eif\u003c/code\u003e chain that needs removing.\u003c/p\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThis rule does not apply to \u003ccode\u003eif\u003c/code\u003e chains without \u003ccode\u003eelse\u003c/code\u003e, nor to \u003ccode\u003eswitch\u003c/code\u003e without a \u003ccode\u003edefault\u003c/code\u003e clause.\u003c/p\u003e\n\u003cpre\u003e\nif(b \u003d\u003d 0) {    //no issue, this could have been done on purpose to make the code more readable\n  doSomething();\n} else if(b \u003d\u003d 1) {\n  doSomething();\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eHaving all branches of a \u003ccode\u003eswitch\u003c/code\u003e or \u003ccode\u003eif\u003c/code\u003e chain with the same implementation indicates a problem.\u003c/p\u003e\n\u003cp\u003eIn the following code:\u003c/p\u003e\n\u003cpre\u003e\nif (b \u003d\u003d 0) {  // Noncompliant\n  doOneMoreThing();\n} else {\n  doOneMoreThing();\n}\n\nint b \u003d a \u0026gt; 12 ? 4 : 4;  // Noncompliant\n\nswitch (i) {  // Noncompliant\n  case 1:\n    doSomething();\n    break;\n  case 2:\n    doSomething();\n    break;\n  case 3:\n    doSomething();\n    break;\n  default:\n    doSomething();\n}\n\u003c/pre\u003e\n\u003cp\u003eEither there is a copy-paste error that needs fixing or an unnecessary \u003ccode\u003eswitch\u003c/code\u003e or \u003ccode\u003eif\u003c/code\u003e chain that needs removing.\u003c/p\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThis rule does not apply to \u003ccode\u003eif\u003c/code\u003e chains without \u003ccode\u003eelse\u003c/code\u003e, nor to \u003ccode\u003eswitch\u003c/code\u003e without a \u003ccode\u003edefault\u003c/code\u003e clause.\u003c/p\u003e\n\u003cpre\u003e\nif(b \u003d\u003d 0) {    //no issue, this could have been done on purpose to make the code more readable\n  doSomething();\n} else if(b \u003d\u003d 1) {\n  doSomething();\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S5308",
    "name": "Return value of \"setuid\" family of functions should always be checked",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003cp\u003eUnchecked return value of a function from the \u003ccode\u003esetuid\u003c/code\u003e-family might cause unexpected behavior and poses a security risk.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eFunctions from the \u003ccode\u003esetuid\u003c/code\u003e-family including \u003ccode\u003esetuid\u003c/code\u003e and \u003ccode\u003esetgid\u003c/code\u003e are used to change the identity of the caller\nprocess. They are used to change privileges for the subsequent actions to be executed. If a call to these functions returns an error that is not\nchecked and handled appropriately, the subsequent parts of the program will execute with unexpected privileges. This, in turn, leads to unexpected\nprogram behavior and poses a \u003cem\u003eserious\u003c/em\u003e security risk.\u003c/p\u003e\n\u003ch2\u003eWhat is the potential impact?\u003c/h2\u003e\n\u003cp\u003eFunctions for managing a program’s privileges are fairly complex and one needs to take great care to use them correctly.\u003c/p\u003e\n\u003cp\u003eFailing to correctly handle potential errors indicated by those functions\u0027 respective return values can lead to unexpected behavior. If the program\nfails to acquire more privileges to execute a privileged operation, for instance, the OS will disallow the operation and the program is likely\nterminated by the OS. However, if the program silently fails to drop its privileges, it will continue to run the subsequent operations with more\nprivileges than expected, which poses a \u003cem\u003eserious\u003c/em\u003e security risk.\u003c/p\u003e\n\u003ch2\u003eExample program that changes between privileged and unprivileged mode\u003c/h2\u003e\n\u003cp\u003eA brief example on how \u003ccode\u003esetuid\u003c/code\u003e can be used and how to correctly check its return value is given in what follows.\u003c/p\u003e\n\u003cp\u003eConsider the following example:\u003c/p\u003e\n\u003cp\u003eAssume that the program shown below has been compiled to its binary named \u003ccode\u003emy-program\u003c/code\u003e. One can change its owner to root, for\ninstance.\u003c/p\u003e\n\u003cpre\u003e\n$ sudo chown root:root my-program\n\u003c/pre\u003e\n\u003cp\u003eAfter setting the program’s setuid bit using\u003c/p\u003e\n\u003cpre\u003e\n$ sudo chmod u+s my-program\n\u003c/pre\u003e\n\u003cp\u003ethe program’s permissions may look like\u003c/p\u003e\n\u003cpre\u003e\n-rwsrwxr-x 1 root root 16416 Aug 21 15:45 my-program\n\u003c/pre\u003e\n\u003cp\u003eThe \u0027s\u0027 indicates that the executable has the setuid bit set. Notice that the program’s owner (here root) may be different from its caller.\nFunctions from the \u003ccode\u003esetuid\u003c/code\u003e-family can be used to manipulate privileges and acquire (or drop) the program owner’s privileges.\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n#include \u0026lt;sys/types.h\u0026gt;\n#include \u0026lt;unistd.h\u0026gt;\n\nstatic uid_t real_uid;\nstatic uid_t effective_uid;\n\nvoid do_setuid(void) {\n  printf(\"Try to acquire privileges\\n\");\n  int status;\n  status \u003d seteuid(effective_uid);\n  if (status \u0026lt; 0) { // Compliant: return code is checked and potential errors are handled.\n    fprintf(stderr, \"Couldn\u0027t set uid.\\n\");\n    exit(status);\n  }\n  printf(\"Set uid to %lu\\n\", (unsigned long int)effective_uid);\n}\n\nvoid undo_setuid(void) {\n  printf(\"Try to drop privileges\\n\");\n  int status;\n  status \u003d seteuid(real_uid);\n  if (status \u0026lt; 0) { // Compliant: return code is checked and potential errors are handled.\n    fprintf(stderr, \"Couldn\u0027t set uid.\\n\");\n    exit(status);\n  }\n  printf(\"Set uid to %lu\\n\", (unsigned long int)real_uid);\n}\n\nint main(void) {\n  real_uid \u003d getuid();       // Real ID of the program\u0027s caller.\n  effective_uid \u003d geteuid(); // Effective ID of the program\u0027s owner (here root).\n  // Immediately drop privileges and set effective user ID back to real user ID\n  // such that operations are performed using the real user ID for determining\n  // permissions.\n  undo_setuid();\n  // Switch back to file user ID (the owner\u0027s privileges) only if the effective\n  // ID (the privileges) is required to determine permission for privileged\n  // operations.\n  do_setuid();\n  //\n  // PERFORM PRIVILEGED OPERATION (using root privileges in this example).\n  //\n  // Drop privileges as soon as they are no longer needed.\n  undo_setuid();\n\n  // There are a multitude of operations that can be extremely dangerous if\n  // executed as root. Assume that this program would not correctly handle\n  // potential errors. In that case, the following system call poses a security\n  // risk, if dropping privileges fails. The following command recursively removes\n  // all files and directories inside the /tmp directory. If executed with root\n  // permissions, it can potentially delete important files and directories, causing\n  // system instability or data loss.\n  system(\"rm -rf /tmp/*\"); // Caution: poses a security risk if accidentally executed as root.\n}\n\u003c/pre\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eAlways check the return values of the \u003ccode\u003esetuid\u003c/code\u003e-family functions and handle any potential error appropriately.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n#include \u0026lt;sys/types.h\u0026gt;\n#include \u0026lt;unistd.h\u0026gt;\n\nstatic uid_t real_uid;\nstatic uid_t effective_uid;\n\nvoid undo_setuid(void) {\n  printf(\"Try to drop privileges\\n\");\n  // Potential failures of `seteuid` are neither checked nor handled appropriately.\n  // This function may hence silently fail to drop privileges and continues execution\n  // in a privileged mode. This poses a serious security risk!\n  seteuid(real_uid); // Noncompliant: return value is not checked.\n  printf(\"Set uid to %lu\\n\", (unsigned long int)real_uid);\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n#include \u0026lt;sys/types.h\u0026gt;\n#include \u0026lt;unistd.h\u0026gt;\n\nstatic uid_t real_uid;\nstatic uid_t effective_uid;\n\nvoid undo_setuid(void) {\n  printf(\"Try to drop privileges\\n\");\n  int status;\n  status \u003d seteuid(real_uid);\n  if (status \u0026lt; 0) { // Compliant: return code is checked and potential errors are handled.\n    fprintf(stderr, \"Couldn\u0027t set uid.\\n\");\n    exit(status);\n  }\n  printf(\"Set uid to %lu\\n\", (unsigned long int)real_uid);\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eArticles \u0026amp; blog posts\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://www.usenix.org/legacy/events/sec02/full_papers/chen/chen.pdf\"\u003eSetuid demystified\u003c/a\u003e Chen, Hao, David Wagner, and Drew Dean.\n  11th USENIX Security Symposium (USENIX Security 02). 2002. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca\n  href\u003d\"https://wiki.sei.cmu.edu/confluence/display/c/POS36-C.+Observe+correct+revocation+order+while+relinquishing+privileges\"\u003ePOS36-C. Ensure that\n  privilege relinquishment is successful\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/display/c/POS37-C.+Ensure+that+privilege+relinquishment+is+successful\"\u003ePOS37-C. Observe\n  correct revocation order while relinquishing privileges\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/252.html\"\u003e252 Unchecked Return Value\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/272.html\"\u003e272 Least Privilege Violation\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eUnchecked return value of a function from the \u003ccode\u003esetuid\u003c/code\u003e-family might cause unexpected behavior and poses a security risk.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eFunctions from the \u003ccode\u003esetuid\u003c/code\u003e-family including \u003ccode\u003esetuid\u003c/code\u003e and \u003ccode\u003esetgid\u003c/code\u003e are used to change the identity of the caller\nprocess. They are used to change privileges for the subsequent actions to be executed. If a call to these functions returns an error that is not\nchecked and handled appropriately, the subsequent parts of the program will execute with unexpected privileges. This, in turn, leads to unexpected\nprogram behavior and poses a \u003cem\u003eserious\u003c/em\u003e security risk.\u003c/p\u003e\n\u003ch2\u003eWhat is the potential impact?\u003c/h2\u003e\n\u003cp\u003eFunctions for managing a program’s privileges are fairly complex and one needs to take great care to use them correctly.\u003c/p\u003e\n\u003cp\u003eFailing to correctly handle potential errors indicated by those functions\u0027 respective return values can lead to unexpected behavior. If the program\nfails to acquire more privileges to execute a privileged operation, for instance, the OS will disallow the operation and the program is likely\nterminated by the OS. However, if the program silently fails to drop its privileges, it will continue to run the subsequent operations with more\nprivileges than expected, which poses a \u003cem\u003eserious\u003c/em\u003e security risk.\u003c/p\u003e\n\u003ch2\u003eExample program that changes between privileged and unprivileged mode\u003c/h2\u003e\n\u003cp\u003eA brief example on how \u003ccode\u003esetuid\u003c/code\u003e can be used and how to correctly check its return value is given in what follows.\u003c/p\u003e\n\u003cp\u003eConsider the following example:\u003c/p\u003e\n\u003cp\u003eAssume that the program shown below has been compiled to its binary named \u003ccode\u003emy-program\u003c/code\u003e. One can change its owner to root, for\ninstance.\u003c/p\u003e\n\u003cpre\u003e\n$ sudo chown root:root my-program\n\u003c/pre\u003e\n\u003cp\u003eAfter setting the program’s setuid bit using\u003c/p\u003e\n\u003cpre\u003e\n$ sudo chmod u+s my-program\n\u003c/pre\u003e\n\u003cp\u003ethe program’s permissions may look like\u003c/p\u003e\n\u003cpre\u003e\n-rwsrwxr-x 1 root root 16416 Aug 21 15:45 my-program\n\u003c/pre\u003e\n\u003cp\u003eThe \u0027s\u0027 indicates that the executable has the setuid bit set. Notice that the program’s owner (here root) may be different from its caller.\nFunctions from the \u003ccode\u003esetuid\u003c/code\u003e-family can be used to manipulate privileges and acquire (or drop) the program owner’s privileges.\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n#include \u0026lt;sys/types.h\u0026gt;\n#include \u0026lt;unistd.h\u0026gt;\n\nstatic uid_t real_uid;\nstatic uid_t effective_uid;\n\nvoid do_setuid(void) {\n  printf(\"Try to acquire privileges\\n\");\n  int status;\n  status \u003d seteuid(effective_uid);\n  if (status \u0026lt; 0) { // Compliant: return code is checked and potential errors are handled.\n    fprintf(stderr, \"Couldn\u0027t set uid.\\n\");\n    exit(status);\n  }\n  printf(\"Set uid to %lu\\n\", (unsigned long int)effective_uid);\n}\n\nvoid undo_setuid(void) {\n  printf(\"Try to drop privileges\\n\");\n  int status;\n  status \u003d seteuid(real_uid);\n  if (status \u0026lt; 0) { // Compliant: return code is checked and potential errors are handled.\n    fprintf(stderr, \"Couldn\u0027t set uid.\\n\");\n    exit(status);\n  }\n  printf(\"Set uid to %lu\\n\", (unsigned long int)real_uid);\n}\n\nint main(void) {\n  real_uid \u003d getuid();       // Real ID of the program\u0027s caller.\n  effective_uid \u003d geteuid(); // Effective ID of the program\u0027s owner (here root).\n  // Immediately drop privileges and set effective user ID back to real user ID\n  // such that operations are performed using the real user ID for determining\n  // permissions.\n  undo_setuid();\n  // Switch back to file user ID (the owner\u0027s privileges) only if the effective\n  // ID (the privileges) is required to determine permission for privileged\n  // operations.\n  do_setuid();\n  //\n  // PERFORM PRIVILEGED OPERATION (using root privileges in this example).\n  //\n  // Drop privileges as soon as they are no longer needed.\n  undo_setuid();\n\n  // There are a multitude of operations that can be extremely dangerous if\n  // executed as root. Assume that this program would not correctly handle\n  // potential errors. In that case, the following system call poses a security\n  // risk, if dropping privileges fails. The following command recursively removes\n  // all files and directories inside the /tmp directory. If executed with root\n  // permissions, it can potentially delete important files and directories, causing\n  // system instability or data loss.\n  system(\"rm -rf /tmp/*\"); // Caution: poses a security risk if accidentally executed as root.\n}\n\u003c/pre\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eAlways check the return values of the \u003ccode\u003esetuid\u003c/code\u003e-family functions and handle any potential error appropriately.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n#include \u0026lt;sys/types.h\u0026gt;\n#include \u0026lt;unistd.h\u0026gt;\n\nstatic uid_t real_uid;\nstatic uid_t effective_uid;\n\nvoid undo_setuid(void) {\n  printf(\"Try to drop privileges\\n\");\n  // Potential failures of `seteuid` are neither checked nor handled appropriately.\n  // This function may hence silently fail to drop privileges and continues execution\n  // in a privileged mode. This poses a serious security risk!\n  seteuid(real_uid); // Noncompliant: return value is not checked.\n  printf(\"Set uid to %lu\\n\", (unsigned long int)real_uid);\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n#include \u0026lt;sys/types.h\u0026gt;\n#include \u0026lt;unistd.h\u0026gt;\n\nstatic uid_t real_uid;\nstatic uid_t effective_uid;\n\nvoid undo_setuid(void) {\n  printf(\"Try to drop privileges\\n\");\n  int status;\n  status \u003d seteuid(real_uid);\n  if (status \u0026lt; 0) { // Compliant: return code is checked and potential errors are handled.\n    fprintf(stderr, \"Couldn\u0027t set uid.\\n\");\n    exit(status);\n  }\n  printf(\"Set uid to %lu\\n\", (unsigned long int)real_uid);\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eArticles \u0026amp; blog posts\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://www.usenix.org/legacy/events/sec02/full_papers/chen/chen.pdf\"\u003eSetuid demystified\u003c/a\u003e Chen, Hao, David Wagner, and Drew Dean.\n  11th USENIX Security Symposium (USENIX Security 02). 2002. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca\n  href\u003d\"https://wiki.sei.cmu.edu/confluence/display/c/POS36-C.+Observe+correct+revocation+order+while+relinquishing+privileges\"\u003ePOS36-C. Ensure that\n  privilege relinquishment is successful\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/display/c/POS37-C.+Ensure+that+privilege+relinquishment+is+successful\"\u003ePOS37-C. Observe\n  correct revocation order while relinquishing privileges\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/252.html\"\u003e252 Unchecked Return Value\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/272.html\"\u003e272 Least Privilege Violation\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "symbolic-execution"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S3805",
    "name": "\"#import\" should not be used",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003e#import\u003c/code\u003e comes from Objective-C and is a variant of \u003ccode\u003e#include\u003c/code\u003e. GCC does support it, but it requires the users of a header\nfile to know that it should only be included once. It is much better for the header file’s implementor to write the file so that users don’t need to\nknow this. Using a wrapper \u003ccode\u003e#ifndef\u003c/code\u003e accomplishes this goal.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#import \"foo.h\" // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#include \"foo.h\"\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003ccode\u003e#import\u003c/code\u003e comes from Objective-C and is a variant of \u003ccode\u003e#include\u003c/code\u003e. GCC does support it, but it requires the users of a header\nfile to know that it should only be included once. It is much better for the header file’s implementor to write the file so that users don’t need to\nknow this. Using a wrapper \u003ccode\u003e#ifndef\u003c/code\u003e accomplishes this goal.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#import \"foo.h\" // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#include \"foo.h\"\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S1749",
    "name": "Type specifiers should be listed in a standard order",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eShared coding conventions allow teams to collaborate efficiently. This rule checks that type specifiers always appear in the following order:\u003c/p\u003e\n\u003col\u003e\n  \u003cli\u003e \u003ccode\u003etypedef\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e type name, spelling of built-in types with more than one type-specifier:\n    \u003col\u003e\n      \u003cli\u003e signedness - \u003ccode\u003esigned\u003c/code\u003e or \u003ccode\u003eunsigned\u003c/code\u003e \u003c/li\u003e\n      \u003cli\u003e last single type-specifier or\n        \u003cul\u003e\n          \u003cli\u003e \u003ccode\u003eshort int\u003c/code\u003e \u003c/li\u003e\n          \u003cli\u003e \u003ccode\u003elong int\u003c/code\u003e \u003c/li\u003e\n          \u003cli\u003e \u003ccode\u003elong long int\u003c/code\u003e \u003c/li\u003e\n          \u003cli\u003e \u003ccode\u003elong double\u003c/code\u003e \u003c/li\u003e\n        \u003c/ul\u003e  \u003c/li\u003e\n    \u003c/ol\u003e  \u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eSince the positioning of the \u003ccode\u003econst\u003c/code\u003e keyword is controversial, this rule does not check it.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint typedef T;\n\ndouble long d;\nchar unsigned ch;\nlong signed int i;\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\ntypedef int T;\n\nlong double d;\nunsigned char ch;\nsigned long int i;\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#nl26-use-conventional-const-notation\"\u003eNL.26: Use conventional\n  \u003ccode\u003econst\u003c/code\u003e notation\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eShared coding conventions allow teams to collaborate efficiently. This rule checks that type specifiers always appear in the following order:\u003c/p\u003e\n\u003col\u003e\n  \u003cli\u003e \u003ccode\u003etypedef\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e type name, spelling of built-in types with more than one type-specifier:\n    \u003col\u003e\n      \u003cli\u003e signedness - \u003ccode\u003esigned\u003c/code\u003e or \u003ccode\u003eunsigned\u003c/code\u003e \u003c/li\u003e\n      \u003cli\u003e last single type-specifier or\n        \u003cul\u003e\n          \u003cli\u003e \u003ccode\u003eshort int\u003c/code\u003e \u003c/li\u003e\n          \u003cli\u003e \u003ccode\u003elong int\u003c/code\u003e \u003c/li\u003e\n          \u003cli\u003e \u003ccode\u003elong long int\u003c/code\u003e \u003c/li\u003e\n          \u003cli\u003e \u003ccode\u003elong double\u003c/code\u003e \u003c/li\u003e\n        \u003c/ul\u003e  \u003c/li\u003e\n    \u003c/ol\u003e  \u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eSince the positioning of the \u003ccode\u003econst\u003c/code\u003e keyword is controversial, this rule does not check it.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint typedef T;\n\ndouble long d;\nchar unsigned ch;\nlong signed int i;\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\ntypedef int T;\n\nlong double d;\nunsigned char ch;\nsigned long int i;\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#nl26-use-conventional-const-notation\"\u003eNL.26: Use conventional\n  \u003ccode\u003econst\u003c/code\u003e notation\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "cppcoreguidelines"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S3807",
    "name": "Parameter values should be appropriate",
    "defaultSeverity": "CRITICAL",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003cp\u003ePassing \u003ccode\u003eNULL\u003c/code\u003e to a C library function that requires non-null pointer arguments results in undefined behavior.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe standard C library includes a variety of functions for string and general memory manipulations. Many of these functions require valid\nparameters and when given values outside a function’s domain, the behavior is undefined. Functions like \u003ccode\u003estrlen\u003c/code\u003e, \u003ccode\u003ememset\u003c/code\u003e,\n\u003ccode\u003ememcpy\u003c/code\u003e, \u003ccode\u003eqsort\u003c/code\u003e, \u003ccode\u003efread\u003c/code\u003e, etc., for instance, require non-\u003ccode\u003eNULL\u003c/code\u003e parameters, and passing a\n\u003ccode\u003eNULL\u003c/code\u003e value introduces undefined behavior. In that case, the application may crash or, even worse, silently lose data or produce incorrect\nresults.\u003c/p\u003e\n\u003cp\u003eConsider the following code. If the pointer-typed variable \u003ccode\u003ebuf\u003c/code\u003e is \u003ccode\u003eNULL\u003c/code\u003e due to a failed memory allocation, for instance,\nthe call to \u003ccode\u003ememset()\u003c/code\u003e will cause undefined behavior.\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;string.h\u0026gt;\n\nvoid process_buffer(char *buf, size_t size) {\n  // Call to `memset()` may lead to undefined behavior, if `buf` is NULL.\n  memset(buf, 0, size);\n}\n\u003c/pre\u003e\n\u003cp\u003eSimilarly, if for some reason a \u003ccode\u003eNULL\u003c/code\u003e pointer slips through and reaches the string manipulation code shown in the following, the\napplication’s behavior is undefined.\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;string.h\u0026gt;\n\nint compare_strings(const char *str_a, const char *str_b) {\n  // Both functions `strlen()` and `strncmp()` may not receive a `NULL` pointer.\n  size_t len_a \u003d strlen(str_a);\n  size_t len_b \u003d strlen(str_b);\n  size_t min \u003d (len_a \u0026lt;\u003d len_b) ? len_a : len_b;\n  return strncmp(str_a, str_b, min);\n}\n\u003c/pre\u003e\n\u003cp\u003eHence, users have to ensure that the C standard library functions\u0027 preconditions are met and valid parameters are passed.\u003c/p\u003e\n\u003cp\u003eThe C library functions that are considered by this rule and that require non-\u003ccode\u003eNULL\u003c/code\u003e pointer parameters are listed in this rule’s\nResources section.\u003c/p\u003e\n\u003ch2\u003eWhat is the potential impact?\u003c/h2\u003e\n\u003cp\u003eIf an argument to one of the C library functions mentioned by this rule is a \u003ccode\u003eNULL\u003c/code\u003e pointer, the behavior of the application is\nundefined.\u003c/p\u003e\n\u003cp\u003eWhen a program comprises undefined behavior, the compiler no longer needs to adhere to the language standard, and the program has no meaning\nassigned to it.\u003c/p\u003e\n\u003cp\u003eDue to the resulting \u003ccode\u003eNULL\u003c/code\u003e pointer dereferences in the C library functions, the application might just crash, but in the worst case,\nthe application may appear to execute correctly, while losing data or producing incorrect results.\u003c/p\u003e\n\u003cp\u003eBesides affecting the application’s availability, \u003ccode\u003eNULL\u003c/code\u003e pointer dereferences may lead to code execution, in rare circumstances. If\n\u003ccode\u003eNULL\u003c/code\u003e is equivalent to the \u003ccode\u003e0x0\u003c/code\u003e memory address that can be accessed by privileged code, writing and reading memory is\npossible, which compromises the integrity and confidentiality of the application.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eEnsure that any pointer passed to any of the C library functions mentioned by this rule \u003cem\u003eis not\u003c/em\u003e \u003ccode\u003eNULL\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n#include \u0026lt;string.h\u0026gt;\n\nint process_string() {\n  char buffer[] \u003d \"Hello, World!\";\n  char *str \u003d (char *)malloc(sizeof(buffer));\n  if (!str) {\n    printf(\"Memory allocation failed!\\n\");\n  }\n  // Noncompliant: 1st parameter in the subsequent call to `memcpy()` might be\n  // NULL due to insufficient handling of a potentially failed memory\n  // allocation.\n  memcpy(str, buffer, sizeof(buffer));\n  // Process dynamically alloacted `str` variable.\n  // ...\n  // Free memory, if it is no longer in use.\n  free(str);\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n#include \u0026lt;string.h\u0026gt;\n\nint process_string() {\n  char buffer[] \u003d \"Hello, World!\";\n  char *str \u003d (char *)malloc(sizeof(buffer));\n  if (!str) {\n    printf(\"Memory allocation failed!\\n\");\n    return 1;\n  }\n  // Compliant: 1st parameter will always denote a non-null pointer.\n  memcpy(str, buffer, sizeof(buffer));\n  // Process dynamically alloacted `str` variable.\n  // ...\n  // Free memory, if it is no longer in use.\n  free(str);\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cp\u003eThe list of functions considered by this rule is shown in the following:\u003c/p\u003e\n\u003cpre\u003e\naio_suspend, bcmp, bcopy, bsearch, bzero, confstr, encrypt, erand48,\nexplicit_bzero, explicit_memset, fgetpwent_r, fgets, fgetws, fread, fwrite,\ngetdelim, getgrgid_r, getgrnam_r, gethostbyaddr_r, gethostbyname2_r,\ngethostbyname_r, gethostent_r, gethostname, getline, getlogin_r,\ngetnetbyaddr_r, getnetbyname_r, getnetent_r, getnetgrent_r, getopt,\ngetopt_long, getopt_long_only, getprotobyname_r, getprotobynumber_r,\ngetprotoent_r, getpwent_r, getpwnam_r, getpwuid_r, getservbyname_r,\ngetservbyport_r, getservent_r, iconv, initstate, jrand48, lcong48, lfind,\nlio_listio, lsearch, mblen, mbrlen, mbrtowc, mbsnrtowcs, mbsrtowcs,\nmbstowcs, mbtowc, memccpy, memchr, memcmp, memcpy, memmove, mempcpy,\nmemset, mq_receive, mq_send, mq_timedreceive, mq_timedsend, nrand48,\nposix_trace_event, posix_trace_trygetnext_event, pread, preadv, preadv2,\npthread_attr_setstack, pwrite, pwritev, pwritev2, qsort, qsort_r, read,\nreadlink, readlinkat, readv, realpath, recv, recvfrom, regerror, regexec,\nseed48, semop, semtimedop, send, sendto, setbuf, setbuffer, setvbuf,\nsnprintf, socketpair, std::copy (for C++), std::copy_backward (for C++),\nstpcpy, strcasecmp, strcat, strcmp, strcpy, strfmon, strfmon_l, strftime,\nstrftime_l, strlcat, strlcpy, strlen, strncasecmp, strncat, strncmp, strncpy,\nstrnlen, strsep, swab, swprintf, ttyname_r, utimes, vsnprintf, vswprintf,\nwcpncpy, wcsftime, wcslen, wcsncasecmp, wcsncasecmp_l, wcsncmp, wcsncpy,\nwcsnlen, wcsnrtombs, wcsrtombs, wcstombs, wcswidth, wcsxfrm, wcsxfrm_l,\nwmemchr, wmemcmp, wmemcpy, wmemmove, wmemcpy, wmemset, write, writev\n\u003c/pre\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/476\"\u003e476 NULL Pointer Dereference\u003c/a\u003e CERT - \u003ca\n  href\u003d\"https://wiki.sei.cmu.edu/confluence/x/QdcxBQ\"\u003eEXP34-C.Do not dereference null pointers\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:c:S2259} detects dereferences of null pointers \u003c/li\u003e\n  \u003cli\u003e {rule:c:S2637} detects uses of null pointers as arguments for parameters that are annotated with \u003ccode\u003enonnull\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003ePassing \u003ccode\u003eNULL\u003c/code\u003e to a C library function that requires non-null pointer arguments results in undefined behavior.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe standard C library includes a variety of functions for string and general memory manipulations. Many of these functions require valid\nparameters and when given values outside a function’s domain, the behavior is undefined. Functions like \u003ccode\u003estrlen\u003c/code\u003e, \u003ccode\u003ememset\u003c/code\u003e,\n\u003ccode\u003ememcpy\u003c/code\u003e, \u003ccode\u003eqsort\u003c/code\u003e, \u003ccode\u003efread\u003c/code\u003e, etc., for instance, require non-\u003ccode\u003eNULL\u003c/code\u003e parameters, and passing a\n\u003ccode\u003eNULL\u003c/code\u003e value introduces undefined behavior. In that case, the application may crash or, even worse, silently lose data or produce incorrect\nresults.\u003c/p\u003e\n\u003cp\u003eConsider the following code. If the pointer-typed variable \u003ccode\u003ebuf\u003c/code\u003e is \u003ccode\u003eNULL\u003c/code\u003e due to a failed memory allocation, for instance,\nthe call to \u003ccode\u003ememset()\u003c/code\u003e will cause undefined behavior.\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;string.h\u0026gt;\n\nvoid process_buffer(char *buf, size_t size) {\n  // Call to `memset()` may lead to undefined behavior, if `buf` is NULL.\n  memset(buf, 0, size);\n}\n\u003c/pre\u003e\n\u003cp\u003eSimilarly, if for some reason a \u003ccode\u003eNULL\u003c/code\u003e pointer slips through and reaches the string manipulation code shown in the following, the\napplication’s behavior is undefined.\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;string.h\u0026gt;\n\nint compare_strings(const char *str_a, const char *str_b) {\n  // Both functions `strlen()` and `strncmp()` may not receive a `NULL` pointer.\n  size_t len_a \u003d strlen(str_a);\n  size_t len_b \u003d strlen(str_b);\n  size_t min \u003d (len_a \u0026lt;\u003d len_b) ? len_a : len_b;\n  return strncmp(str_a, str_b, min);\n}\n\u003c/pre\u003e\n\u003cp\u003eHence, users have to ensure that the C standard library functions\u0027 preconditions are met and valid parameters are passed.\u003c/p\u003e\n\u003cp\u003eThe C library functions that are considered by this rule and that require non-\u003ccode\u003eNULL\u003c/code\u003e pointer parameters are listed in this rule’s\nResources section.\u003c/p\u003e\n\u003ch2\u003eWhat is the potential impact?\u003c/h2\u003e\n\u003cp\u003eIf an argument to one of the C library functions mentioned by this rule is a \u003ccode\u003eNULL\u003c/code\u003e pointer, the behavior of the application is\nundefined.\u003c/p\u003e\n\u003cp\u003eWhen a program comprises undefined behavior, the compiler no longer needs to adhere to the language standard, and the program has no meaning\nassigned to it.\u003c/p\u003e\n\u003cp\u003eDue to the resulting \u003ccode\u003eNULL\u003c/code\u003e pointer dereferences in the C library functions, the application might just crash, but in the worst case,\nthe application may appear to execute correctly, while losing data or producing incorrect results.\u003c/p\u003e\n\u003cp\u003eBesides affecting the application’s availability, \u003ccode\u003eNULL\u003c/code\u003e pointer dereferences may lead to code execution, in rare circumstances. If\n\u003ccode\u003eNULL\u003c/code\u003e is equivalent to the \u003ccode\u003e0x0\u003c/code\u003e memory address that can be accessed by privileged code, writing and reading memory is\npossible, which compromises the integrity and confidentiality of the application.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eEnsure that any pointer passed to any of the C library functions mentioned by this rule \u003cem\u003eis not\u003c/em\u003e \u003ccode\u003eNULL\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n#include \u0026lt;string.h\u0026gt;\n\nint process_string() {\n  char buffer[] \u003d \"Hello, World!\";\n  char *str \u003d (char *)malloc(sizeof(buffer));\n  if (!str) {\n    printf(\"Memory allocation failed!\\n\");\n  }\n  // Noncompliant: 1st parameter in the subsequent call to `memcpy()` might be\n  // NULL due to insufficient handling of a potentially failed memory\n  // allocation.\n  memcpy(str, buffer, sizeof(buffer));\n  // Process dynamically alloacted `str` variable.\n  // ...\n  // Free memory, if it is no longer in use.\n  free(str);\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n#include \u0026lt;string.h\u0026gt;\n\nint process_string() {\n  char buffer[] \u003d \"Hello, World!\";\n  char *str \u003d (char *)malloc(sizeof(buffer));\n  if (!str) {\n    printf(\"Memory allocation failed!\\n\");\n    return 1;\n  }\n  // Compliant: 1st parameter will always denote a non-null pointer.\n  memcpy(str, buffer, sizeof(buffer));\n  // Process dynamically alloacted `str` variable.\n  // ...\n  // Free memory, if it is no longer in use.\n  free(str);\n  return 0;\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cp\u003eThe list of functions considered by this rule is shown in the following:\u003c/p\u003e\n\u003cpre\u003e\naio_suspend, bcmp, bcopy, bsearch, bzero, confstr, encrypt, erand48,\nexplicit_bzero, explicit_memset, fgetpwent_r, fgets, fgetws, fread, fwrite,\ngetdelim, getgrgid_r, getgrnam_r, gethostbyaddr_r, gethostbyname2_r,\ngethostbyname_r, gethostent_r, gethostname, getline, getlogin_r,\ngetnetbyaddr_r, getnetbyname_r, getnetent_r, getnetgrent_r, getopt,\ngetopt_long, getopt_long_only, getprotobyname_r, getprotobynumber_r,\ngetprotoent_r, getpwent_r, getpwnam_r, getpwuid_r, getservbyname_r,\ngetservbyport_r, getservent_r, iconv, initstate, jrand48, lcong48, lfind,\nlio_listio, lsearch, mblen, mbrlen, mbrtowc, mbsnrtowcs, mbsrtowcs,\nmbstowcs, mbtowc, memccpy, memchr, memcmp, memcpy, memmove, mempcpy,\nmemset, mq_receive, mq_send, mq_timedreceive, mq_timedsend, nrand48,\nposix_trace_event, posix_trace_trygetnext_event, pread, preadv, preadv2,\npthread_attr_setstack, pwrite, pwritev, pwritev2, qsort, qsort_r, read,\nreadlink, readlinkat, readv, realpath, recv, recvfrom, regerror, regexec,\nseed48, semop, semtimedop, send, sendto, setbuf, setbuffer, setvbuf,\nsnprintf, socketpair, std::copy (for C++), std::copy_backward (for C++),\nstpcpy, strcasecmp, strcat, strcmp, strcpy, strfmon, strfmon_l, strftime,\nstrftime_l, strlcat, strlcpy, strlen, strncasecmp, strncat, strncmp, strncpy,\nstrnlen, strsep, swab, swprintf, ttyname_r, utimes, vsnprintf, vswprintf,\nwcpncpy, wcsftime, wcslen, wcsncasecmp, wcsncasecmp_l, wcsncmp, wcsncpy,\nwcsnlen, wcsnrtombs, wcsrtombs, wcstombs, wcswidth, wcsxfrm, wcsxfrm_l,\nwmemchr, wmemcmp, wmemcpy, wmemmove, wmemcpy, wmemset, write, writev\n\u003c/pre\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/476\"\u003e476 NULL Pointer Dereference\u003c/a\u003e CERT - \u003ca\n  href\u003d\"https://wiki.sei.cmu.edu/confluence/x/QdcxBQ\"\u003eEXP34-C.Do not dereference null pointers\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:c:S2259} detects dereferences of null pointers \u003c/li\u003e\n  \u003cli\u003e {rule:c:S2637} detects uses of null pointers as arguments for parameters that are annotated with \u003ccode\u003enonnull\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "symbolic-execution"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:M23_094",
    "name": "A cast should not convert a pointer type to an integral type",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 8.2.7\u003c/p\u003e\n\u003cp\u003eCategory: Advisory\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eCasting between a pointer and an integer type makes it harder for tools and developers to understand and reason about code behaviour. For example,\npointer tracking within tools may become unreliable when pointers are cast to integers.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e casting between pointers and integers may be unavoidable when addressing memory mapped registers or other hardware specific\nfeatures. When the advice given in this rule is not followed, the use of \u003ccode\u003estd::uintptr_t\u003c/code\u003e or \u003ccode\u003estd::intptr_t\u003c/code\u003e is required by\nMISRA C++ 2023 Rule\u0026nbsp;8.2.8 (An \u003cem\u003eobject pointer type\u003c/em\u003e shall not be cast to an integral type other than \u003ccode\u003estd::uintptr_t\u003c/code\u003e or\n\u003ccode\u003estd::intptr_t\u003c/code\u003e) as these types are guaranteed to be able to represent all possible pointer values.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cp\u003eThe following examples violate MISRA C++ 2023 Rule\u0026nbsp;8.2.8 (An \u003cem\u003eobject pointer type\u003c/em\u003e shall not be cast to an integral type other than\n\u003ccode\u003estd::uintptr_t\u003c/code\u003e or \u003ccode\u003estd::intptr_t\u003c/code\u003e):\u003c/p\u003e\n\u003cpre\u003e\nstruct S;\n\nvoid f( S * s )\n{\n  std::intptr_t p \u003d reinterpret_cast\u0026lt; std::intptr_t \u0026gt;( s );   // Non-compliant\n  std::uint8_t  q \u003d reinterpret_cast\u0026lt; std::uint8_t  \u0026gt;( s );   // Non-compliant\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e S5358 targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2023 Rule\u0026nbsp;8.2.5 - \u003ccode\u003ereinterpret_cast\u003c/code\u003e shall not be used \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2023 Rule\u0026nbsp;8.2.8 - An \u003cem\u003eobject pointer type\u003c/em\u003e shall not be cast to an integral type other than \u003ccode\u003estd::uintptr_t\u003c/code\u003e\n  or \u003ccode\u003estd::intptr_t\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 8.2.7\u003c/p\u003e\n\u003cp\u003eCategory: Advisory\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eCasting between a pointer and an integer type makes it harder for tools and developers to understand and reason about code behaviour. For example,\npointer tracking within tools may become unreliable when pointers are cast to integers.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e casting between pointers and integers may be unavoidable when addressing memory mapped registers or other hardware specific\nfeatures. When the advice given in this rule is not followed, the use of \u003ccode\u003estd::uintptr_t\u003c/code\u003e or \u003ccode\u003estd::intptr_t\u003c/code\u003e is required by\nMISRA C++ 2023 Rule\u0026nbsp;8.2.8 (An \u003cem\u003eobject pointer type\u003c/em\u003e shall not be cast to an integral type other than \u003ccode\u003estd::uintptr_t\u003c/code\u003e or\n\u003ccode\u003estd::intptr_t\u003c/code\u003e) as these types are guaranteed to be able to represent all possible pointer values.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cp\u003eThe following examples violate MISRA C++ 2023 Rule\u0026nbsp;8.2.8 (An \u003cem\u003eobject pointer type\u003c/em\u003e shall not be cast to an integral type other than\n\u003ccode\u003estd::uintptr_t\u003c/code\u003e or \u003ccode\u003estd::intptr_t\u003c/code\u003e):\u003c/p\u003e\n\u003cpre\u003e\nstruct S;\n\nvoid f( S * s )\n{\n  std::intptr_t p \u003d reinterpret_cast\u0026lt; std::intptr_t \u0026gt;( s );   // Non-compliant\n  std::uint8_t  q \u003d reinterpret_cast\u0026lt; std::uint8_t  \u0026gt;( s );   // Non-compliant\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e S5358 targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2023 Rule\u0026nbsp;8.2.5 - \u003ccode\u003ereinterpret_cast\u003c/code\u003e shall not be used \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2023 Rule\u0026nbsp;8.2.8 - An \u003cem\u003eobject pointer type\u003c/em\u003e shall not be cast to an integral type other than \u003ccode\u003estd::uintptr_t\u003c/code\u003e\n  or \u003ccode\u003estd::intptr_t\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "misra-advisory",
      "misra-c++2023"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S3806",
    "name": "\"#include\" paths should be portable",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe way an \u003ccode\u003e#include\u003c/code\u003e directive finds an actual file is implementation-defined, and in practice, it slightly differs in different\nsystems.\u003c/p\u003e\n\u003cp\u003eTherefore, a good practice is to identify the files to include in the most straightforward way possible to reduce the risk of inconsistent\nbehaviors.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The case of the file in the \u003ccode\u003e#include\u003c/code\u003e directive does not match the case of the file on the disk (the inclusion would not work on a\n  case-sensitive OS), \u003c/li\u003e\n  \u003cli\u003e The file name in the \u003ccode\u003e#include\u003c/code\u003e directive contains trailing spaces (they would be ignored on Windows but considered on Unix). \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include \"Foo.h\" // Noncompliant if the actual file name is \"foo.h\"\n#include \"bar.h \" // Noncompliant, trailing space\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe way an \u003ccode\u003e#include\u003c/code\u003e directive finds an actual file is implementation-defined, and in practice, it slightly differs in different\nsystems.\u003c/p\u003e\n\u003cp\u003eTherefore, a good practice is to identify the files to include in the most straightforward way possible to reduce the risk of inconsistent\nbehaviors.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The case of the file in the \u003ccode\u003e#include\u003c/code\u003e directive does not match the case of the file on the disk (the inclusion would not work on a\n  case-sensitive OS), \u003c/li\u003e\n  \u003cli\u003e The file name in the \u003ccode\u003e#include\u003c/code\u003e directive contains trailing spaces (they would be ignored on Windows but considered on Unix). \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include \"Foo.h\" // Noncompliant if the actual file name is \"foo.h\"\n#include \"bar.h \" // Noncompliant, trailing space\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S2275",
    "name": "Printf-style format strings should not lead to unexpected behavior at runtime",
    "defaultSeverity": "BLOCKER",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eBecause \u003ccode\u003eprintf\u003c/code\u003e format strings are interpreted at runtime, rather than validated by the compiler, they can contain errors that lead to\nunexpected behavior or runtime errors. This rule statically validates the good behavior of \u003ccode\u003eprintf\u003c/code\u003e formats.\u003c/p\u003e\n\u003cp\u003eThe related rule {rule:c:S3457} is about errors that produce an unexpected string, while this rule is about errors that will create undefined\nbehavior.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nprintf(\"%d\", 1.2); // Noncompliant, an \"int\" is expected rather than a \"double\"\nprintf(\"%d %d\", 1); // Noncompliant, the second argument is missing\nprintf(\"%0$d \", 1); // Noncompliant, arguments are numbered starting from 1\nprintf(\"%1$d %d\", 1, 2); // Noncompliant, positional and non-positional arguments can not be mixed\nprintf(\"%*d\", 1.1, 2); // Noncompliant, field width should be an integer\nprintf(\"ab\\0cd\"); // Noncompliant, format string contains null char\n\nint x;\nprintf(\"%+p\", (void*)\u0026amp;x); // Noncompliant, flag \"+\" has undefined behavior with conversion specifier \"p\"\nprintf(\"%vd\", x); //Noncompliant, conversion specifier \"v\" is not valid\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nprintf(\"%f\", 1.2); // Compliant, format is consistent with the corresponding argument\nprintf(\"%d\", 1); // Compliant, number of specifiers is consistent with number of arguments\nprintf(\"%1$d \", 1); // Compliant, number of positional argument is consistent\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThis rule will only work if the format string is provided as a string literal.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://www.securecoding.cert.org/confluence/x/wQA1\"\u003eCERT, FIO47-C.\u003c/a\u003e - Use valid format strings \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eBecause \u003ccode\u003eprintf\u003c/code\u003e format strings are interpreted at runtime, rather than validated by the compiler, they can contain errors that lead to\nunexpected behavior or runtime errors. This rule statically validates the good behavior of \u003ccode\u003eprintf\u003c/code\u003e formats.\u003c/p\u003e\n\u003cp\u003eThe related rule {rule:c:S3457} is about errors that produce an unexpected string, while this rule is about errors that will create undefined\nbehavior.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nprintf(\"%d\", 1.2); // Noncompliant, an \"int\" is expected rather than a \"double\"\nprintf(\"%d %d\", 1); // Noncompliant, the second argument is missing\nprintf(\"%0$d \", 1); // Noncompliant, arguments are numbered starting from 1\nprintf(\"%1$d %d\", 1, 2); // Noncompliant, positional and non-positional arguments can not be mixed\nprintf(\"%*d\", 1.1, 2); // Noncompliant, field width should be an integer\nprintf(\"ab\\0cd\"); // Noncompliant, format string contains null char\n\nint x;\nprintf(\"%+p\", (void*)\u0026amp;x); // Noncompliant, flag \"+\" has undefined behavior with conversion specifier \"p\"\nprintf(\"%vd\", x); //Noncompliant, conversion specifier \"v\" is not valid\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nprintf(\"%f\", 1.2); // Compliant, format is consistent with the corresponding argument\nprintf(\"%d\", 1); // Compliant, number of specifiers is consistent with number of arguments\nprintf(\"%1$d \", 1); // Compliant, number of positional argument is consistent\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThis rule will only work if the format string is provided as a string literal.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://www.securecoding.cert.org/confluence/x/wQA1\"\u003eCERT, FIO47-C.\u003c/a\u003e - Use valid format strings \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "cert"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S1065",
    "name": "Unused labels should be removed",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eIf a label is declared but not used in the program, it can be considered as dead code and should therefore be removed.\u003c/p\u003e\n\u003cp\u003eThis will improve maintainability as developers will not wonder what this label is used for.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid fun() {\n  label: doSomething();\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid fun() {\n  doSomething();\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2012, 2.6 - A function should not contain unused label declarations \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/5dUxBQ\"\u003eCERT, MSC12-C.\u003c/a\u003e - Detect and remove code that has no effect or is never executed\n  \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eIf a label is declared but not used in the program, it can be considered as dead code and should therefore be removed.\u003c/p\u003e\n\u003cp\u003eThis will improve maintainability as developers will not wonder what this label is used for.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid fun() {\n  label: doSomething();\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid fun() {\n  doSomething();\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2012, 2.6 - A function should not contain unused label declarations \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/5dUxBQ\"\u003eCERT, MSC12-C.\u003c/a\u003e - Detect and remove code that has no effect or is never executed\n  \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "based-on-misra",
      "cert",
      "unused"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S1186",
    "name": "Methods should not be empty",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eAn empty function is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty functions bring no\nfunctionality and are misleading to others as they might think the function implementation fulfills a specific and identified requirement.\u003c/p\u003e\n\u003cp\u003eThere are several reasons for a function not to have a body:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. \u003c/li\u003e\n  \u003cli\u003e It is not yet, or never will be, supported. In this case an exception should be thrown. \u003c/li\u003e\n  \u003cli\u003e The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThis rule doesn’t raise an issue for empty class constructors or destructors.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid shouldNotBeEmpty() {  // Noncompliant - method is empty\n}\n\nvoid notImplemented() {  // Noncompliant - method is empty\n}\n\nvoid emptyOnPurpose() {  // Noncompliant - method is empty\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid shouldNotBeEmpty() {\n  doSomething();\n}\n\nvoid notImplemented() {\n  throw std::logic_exception(\"notImplemented() cannot be performed because...\");\n}\n\nvoid emptyOnPurpose() {\n  // comment explaining why the method is empty\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eAn empty function is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty functions bring no\nfunctionality and are misleading to others as they might think the function implementation fulfills a specific and identified requirement.\u003c/p\u003e\n\u003cp\u003eThere are several reasons for a function not to have a body:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. \u003c/li\u003e\n  \u003cli\u003e It is not yet, or never will be, supported. In this case an exception should be thrown. \u003c/li\u003e\n  \u003cli\u003e The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThis rule doesn’t raise an issue for empty class constructors or destructors.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid shouldNotBeEmpty() {  // Noncompliant - method is empty\n}\n\nvoid notImplemented() {  // Noncompliant - method is empty\n}\n\nvoid emptyOnPurpose() {  // Noncompliant - method is empty\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid shouldNotBeEmpty() {\n  doSomething();\n}\n\nvoid notImplemented() {\n  throw std::logic_exception(\"notImplemented() cannot be performed because...\");\n}\n\nvoid emptyOnPurpose() {\n  // comment explaining why the method is empty\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S1066",
    "name": "Mergeable \"if\" statements should be combined",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eNested code - blocks of code inside blocks of code - is eventually necessary, but increases complexity. This is why keeping the code as flat as\npossible, by avoiding unnecessary nesting, is considered a good practice.\u003c/p\u003e\n\u003cp\u003eMerging \u003ccode\u003eif\u003c/code\u003e statements when possible will decrease the nesting of the code and improve its readability.\u003c/p\u003e\n\u003cp\u003eCode like\u003c/p\u003e\n\u003cpre\u003e\nif (condition1) {\n  if (condition2) {             // Noncompliant\n    /* ... */\n  }\n}\n\u003c/pre\u003e\n\u003cp\u003ewill be more readable as\u003c/p\u003e\n\u003cpre\u003e\nif (condition1 \u0026amp;\u0026amp; condition2) { // Compliant\n  /* ... */\n}\n\u003c/pre\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eIf merging the conditions seems to result in a more complex code, extracting the condition or part of it in a named function or variable is a\nbetter approach to fix readability.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre\u003e\nif (fs::exists(path)) {\n  if (fs::is_regular_file(path) || fs::is_directory(path)) { // Noncompliant\n    /* ... */\n  }\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre\u003e\nbool isFileOrDirectory(fs::path const\u0026amp; path) {\n  return fs::is_regular_file(path) || fs::is_directory(path);\n}\n\n/* ... */\n\nif (fs::exists(path) \u0026amp;\u0026amp; isFileOrDirectory(path)) { // Compliant\n  /* ... */\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eNested code - blocks of code inside blocks of code - is eventually necessary, but increases complexity. This is why keeping the code as flat as\npossible, by avoiding unnecessary nesting, is considered a good practice.\u003c/p\u003e\n\u003cp\u003eMerging \u003ccode\u003eif\u003c/code\u003e statements when possible will decrease the nesting of the code and improve its readability.\u003c/p\u003e\n\u003cp\u003eCode like\u003c/p\u003e\n\u003cpre\u003e\nif (condition1) {\n  if (condition2) {             // Noncompliant\n    /* ... */\n  }\n}\n\u003c/pre\u003e\n\u003cp\u003ewill be more readable as\u003c/p\u003e\n\u003cpre\u003e\nif (condition1 \u0026amp;\u0026amp; condition2) { // Compliant\n  /* ... */\n}\n\u003c/pre\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eIf merging the conditions seems to result in a more complex code, extracting the condition or part of it in a named function or variable is a\nbetter approach to fix readability.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre\u003e\nif (fs::exists(path)) {\n  if (fs::is_regular_file(path) || fs::is_directory(path)) { // Noncompliant\n    /* ... */\n  }\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre\u003e\nbool isFileOrDirectory(fs::path const\u0026amp; path) {\n  return fs::is_regular_file(path) || fs::is_directory(path);\n}\n\n/* ... */\n\nif (fs::exists(path) \u0026amp;\u0026amp; isFileOrDirectory(path)) { // Compliant\n  /* ... */\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "clumsy"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:M23_090",
    "name": "A cast shall not remove any \"const\" or \"volatile\" qualification from the type accessed via a pointer or by reference",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "MODULAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 8.2.3\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eUsing a cast to remove the qualification associated with the addressed type is a violation of the principle of type qualification.\u003c/p\u003e\n\u003cp\u003eSome of the problems that might arise include:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Removal of \u003ccode\u003econst\u003c/code\u003e qualification might circumvent the read-only status of an object, which may lead to \u003cem\u003eundefined behaviour\u003c/em\u003e;\n  \u003c/li\u003e\n  \u003cli\u003e Removal of \u003ccode\u003econst\u003c/code\u003e qualification might result in a hardware exception when the object is accessed; \u003c/li\u003e\n  \u003cli\u003e Removal of \u003ccode\u003evolatile\u003c/code\u003e qualification might result in accesses to an object being removed during optimization. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\n         uint16_t           x;\n         uint16_t * const   cpi \u003d \u0026amp;x;       // const pointer\n         uint16_t * const * pcpi;           // pointer to const pointer\n         uint16_t *       * ppi;\n   const uint16_t         * pci;            // pointer to const\nvolatile uint16_t         * pvi;            // pointer to volatile\n         uint16_t         * pi;\n\npi \u003d cpi;                                   // Rule does not apply - no cast\n\npi  \u003d const_cast\u0026lt; uint16_t *  \u0026gt;( pci  );    // Non-compliant\npi  \u003d const_cast\u0026lt; uint16_t *  \u0026gt;( pvi  );    // Non-compliant\nppi \u003d const_cast\u0026lt; uint16_t ** \u0026gt;( pcpi );    // Non-compliant\n\u003c/pre\u003e\n\u003cp\u003eThe following examples also violate M23_089: MISRA C++ 2023 Rule\u0026nbsp;8.2.2.\u003c/p\u003e\n\u003cpre\u003e\npi  \u003d ( uint16_t *  )pci;                   // Non-compliant\npi  \u003d ( uint16_t *  )pvi;                   // Non-compliant\nppi \u003d ( uint16_t ** )pcpi;                  // Non-compliant\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:c:S859} targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n  \u003cli\u003e M23_089: MISRA C++ 2023 Rule\u0026nbsp;8.2.2 - C-style casts and \u003cem\u003efunctional notation\u003c/em\u003e casts shall not be used \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/HNcxBQ\"\u003eCERT, EXP32-C.\u003c/a\u003e - Do not access a volatile object through a nonvolatile reference\n  \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/P9YxBQ\"\u003eCERT, EXP05-C.\u003c/a\u003e - Do not cast away a const qualification \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/AHw-BQ\"\u003eCERT, EXP55-CPP.\u003c/a\u003e - Do not access a cv-qualified object through a cv-unqualified type\n  \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/036324/CppCoreGuidelines.md#es50-dont-cast-away-const\"\u003eC++ Core Guidelines -\n  ES.50\u003c/a\u003e - Don’t cast away const. \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/036324/CppCoreGuidelines.md#prosafety-type-safety-profile\"\u003eC++ Core Guidelines -\n  Type.3\u003c/a\u003e - Don’t use const_cast to cast away const \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 8.2.3\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eUsing a cast to remove the qualification associated with the addressed type is a violation of the principle of type qualification.\u003c/p\u003e\n\u003cp\u003eSome of the problems that might arise include:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Removal of \u003ccode\u003econst\u003c/code\u003e qualification might circumvent the read-only status of an object, which may lead to \u003cem\u003eundefined behaviour\u003c/em\u003e;\n  \u003c/li\u003e\n  \u003cli\u003e Removal of \u003ccode\u003econst\u003c/code\u003e qualification might result in a hardware exception when the object is accessed; \u003c/li\u003e\n  \u003cli\u003e Removal of \u003ccode\u003evolatile\u003c/code\u003e qualification might result in accesses to an object being removed during optimization. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\n         uint16_t           x;\n         uint16_t * const   cpi \u003d \u0026amp;x;       // const pointer\n         uint16_t * const * pcpi;           // pointer to const pointer\n         uint16_t *       * ppi;\n   const uint16_t         * pci;            // pointer to const\nvolatile uint16_t         * pvi;            // pointer to volatile\n         uint16_t         * pi;\n\npi \u003d cpi;                                   // Rule does not apply - no cast\n\npi  \u003d const_cast\u0026lt; uint16_t *  \u0026gt;( pci  );    // Non-compliant\npi  \u003d const_cast\u0026lt; uint16_t *  \u0026gt;( pvi  );    // Non-compliant\nppi \u003d const_cast\u0026lt; uint16_t ** \u0026gt;( pcpi );    // Non-compliant\n\u003c/pre\u003e\n\u003cp\u003eThe following examples also violate M23_089: MISRA C++ 2023 Rule\u0026nbsp;8.2.2.\u003c/p\u003e\n\u003cpre\u003e\npi  \u003d ( uint16_t *  )pci;                   // Non-compliant\npi  \u003d ( uint16_t *  )pvi;                   // Non-compliant\nppi \u003d ( uint16_t ** )pcpi;                  // Non-compliant\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:c:S859} targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n  \u003cli\u003e M23_089: MISRA C++ 2023 Rule\u0026nbsp;8.2.2 - C-style casts and \u003cem\u003efunctional notation\u003c/em\u003e casts shall not be used \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/HNcxBQ\"\u003eCERT, EXP32-C.\u003c/a\u003e - Do not access a volatile object through a nonvolatile reference\n  \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/P9YxBQ\"\u003eCERT, EXP05-C.\u003c/a\u003e - Do not cast away a const qualification \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/AHw-BQ\"\u003eCERT, EXP55-CPP.\u003c/a\u003e - Do not access a cv-qualified object through a cv-unqualified type\n  \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/036324/CppCoreGuidelines.md#es50-dont-cast-away-const\"\u003eC++ Core Guidelines -\n  ES.50\u003c/a\u003e - Don’t cast away const. \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/036324/CppCoreGuidelines.md#prosafety-type-safety-profile\"\u003eC++ Core Guidelines -\n  Type.3\u003c/a\u003e - Don’t use const_cast to cast away const \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "misra-c++2023",
      "misra-required",
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S1067",
    "name": "Expressions should not be too complex",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "FOCUSED",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe complexity of an expression is defined by the number of \u003ccode\u003e\u0026amp;\u0026amp;\u003c/code\u003e, \u003ccode\u003e||\u003c/code\u003e and \u003ccode\u003econdition ? ifTrue : ifFalse\u003c/code\u003e\noperators it contains.\u003c/p\u003e\n\u003cp\u003eA single expression’s complexity should not become too high to keep the code readable.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cp\u003eWith the default threshold value 3.\u003c/p\u003e\n\u003cpre\u003e\nif (((condition1 \u0026amp;\u0026amp; condition2) || (condition3 \u0026amp;\u0026amp; condition4)) \u0026amp;\u0026amp; condition5) { ... }\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nif ((myFirstCondition() || mySecondCondition()) \u0026amp;\u0026amp; myLastCondition()) { ... }\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe complexity of an expression is defined by the number of \u003ccode\u003e\u0026amp;\u0026amp;\u003c/code\u003e, \u003ccode\u003e||\u003c/code\u003e and \u003ccode\u003econdition ? ifTrue : ifFalse\u003c/code\u003e\noperators it contains.\u003c/p\u003e\n\u003cp\u003eA single expression’s complexity should not become too high to keep the code readable.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cp\u003eWith the default threshold value 3.\u003c/p\u003e\n\u003cpre\u003e\nif (((condition1 \u0026amp;\u0026amp; condition2) || (condition3 \u0026amp;\u0026amp; condition4)) \u0026amp;\u0026amp; condition5) { ... }\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nif ((myFirstCondition() || mySecondCondition()) \u0026amp;\u0026amp; myLastCondition()) { ... }\n\u003c/pre\u003e"
      }
    ],
    "params": {
      "max": {
        "key": "max",
        "name": "max",
        "description": "Maximum number of allowed conditional operators in an expression",
        "defaultValue": "3",
        "type": "INTEGER",
        "multiple": false,
        "possibleValues": []
      }
    },
    "defaultParams": {
      "max": "3"
    },
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "brain-overload"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S5542",
    "name": "Encryption algorithms should be used with secure mode and padding scheme",
    "defaultSeverity": "CRITICAL",
    "type": "VULNERABILITY",
    "cleanCodeAttribute": "TRUSTWORTHY",
    "defaultImpacts": {
      "SECURITY": "HIGH"
    },
    "description": "\u003cp\u003eThis vulnerability exposes encrypted data to a number of attacks whose goal is to recover the plaintext.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eEncryption algorithms are essential for protecting sensitive information and ensuring secure communications in a variety of domains. They are used\nfor several important reasons:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Confidentiality, privacy, and intellectual property protection \u003c/li\u003e\n  \u003cli\u003e Security during transmission or on storage devices \u003c/li\u003e\n  \u003cli\u003e Data integrity, general trust, and authentication \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWhen selecting encryption algorithms, tools, or combinations, you should also consider two things:\u003c/p\u003e\n\u003col\u003e\n  \u003cli\u003e No encryption is unbreakable. \u003c/li\u003e\n  \u003cli\u003e The strength of an encryption algorithm is usually measured by the effort required to crack it within a reasonable time frame. \u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eFor these reasons, as soon as cryptography is included in a project, it is important to choose encryption algorithms that are considered strong and\nsecure by the cryptography community.\u003c/p\u003e\n\u003cp\u003eFor AES, the weakest modes are CBC (Cipher Block Chaining) and ECB (Electronic Codebook) because they are either vulnerable to padding oracles or\ndo not provide authentication mechanisms.\u003c/p\u003e\n\u003cp\u003eFor RSA, the weakest algorithms are either using it without padding or using the PKCS1v1.5 padding scheme.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eThe cleartext of an encrypted message might be recoverable. Additionally, it might be possible to modify the cleartext of an encrypted message.\u003c/p\u003e\n\u003cp\u003eBelow are some real-world scenarios that illustrate possible impacts of an attacker exploiting the vulnerability.\u003c/p\u003e\n\u003ch4\u003eTheft of sensitive data\u003c/h4\u003e\n\u003cp\u003eThe encrypted message might contain data that is considered sensitive and should not be known to third parties.\u003c/p\u003e\n\u003cp\u003eBy using a weak algorithm the likelihood that an attacker might be able to recover the cleartext drastically increases.\u003c/p\u003e\n\u003ch4\u003eAdditional attack surface\u003c/h4\u003e\n\u003cp\u003eBy modifying the cleartext of the encrypted message it might be possible for an attacker to trigger other vulnerabilities in the code. Encrypted\nvalues are often considered trusted, since under normal circumstances it would not be possible for a third party to modify them.\u003c/p\u003e\n\u003ch2\u003eHow to fix it in Botan\u003c/h2\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cp\u003eExample with a symmetric cipher, AES:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;botan/cipher_mode.h\u0026gt;\n\nvoid encrypt() {\n  Botan::Cipher_Mode::create(\"AES-256/ECB\", Botan::ENCRYPTION); // Noncompliant\n}\n\u003c/pre\u003e\n\u003cp\u003eExample with an asymmetric cipher, RSA:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;botan/rng.h\u0026gt;\n#include \u0026lt;botan/auto_rng.h\u0026gt;\n#include \u0026lt;botan/rsa.h\u0026gt;\n#include \u0026lt;botan/pubkey.h\u0026gt;\n\nvoid encrypt() {\n  std::unique_ptr\u0026lt;Botan::RandomNumberGenerator\u0026gt;   rng(new Botan::AutoSeeded_RNG);\n  Botan::RSA_PrivateKey                           rsaKey(*rng.get(), 2048);\n\n  Botan::PK_Encryptor_EME(rsaKey, *rng.get(), \"PKCS1v15\"); // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eFor the AES symmetric cipher, use the GCM mode:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;botan/cipher_mode.h\u0026gt;\n\nvoid encrypt() {\n  Botan::Cipher_Mode::create(\"AES-256/GCM\", Botan::ENCRYPTION);\n}\n\u003c/pre\u003e\n\u003cp\u003eFor the RSA asymmetric cipher, use the Optimal Asymmetric Encryption Padding (OAEP):\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;botan/rng.h\u0026gt;\n#include \u0026lt;botan/auto_rng.h\u0026gt;\n#include \u0026lt;botan/rsa.h\u0026gt;\n#include \u0026lt;botan/pubkey.h\u0026gt;\n\nvoid encrypt() {\n  std::unique_ptr\u0026lt;Botan::RandomNumberGenerator\u0026gt;   rng(new Botan::AutoSeeded_RNG);\n  Botan::RSA_PrivateKey                           rsaKey(*rng.get(), 2048);\n\n  Botan::PK_Encryptor_EME(rsaKey, *rng.get(), \"OAEP\");\n}\n\u003c/pre\u003e\n\u003ch3\u003eHow does this work?\u003c/h3\u003e\n\u003cp\u003eAs a rule of thumb, use the cryptographic algorithms and mechanisms that are considered strong by the cryptographic community.\u003c/p\u003e\n\u003cp\u003eAppropriate choices are currently the following.\u003c/p\u003e\n\u003ch4\u003eFor AES: Use Galois/Counter mode (GCM)\u003c/h4\u003e\n\u003cp\u003eGCM mode combines encryption with authentication and integrity checks using a cryptographic hash function and provides both confidentiality and\nauthenticity of data.\u003c/p\u003e\n\u003cp\u003eOther similar modes are:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e CCM: \u003ccode\u003eCounter with CBC-MAC\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e CWC: \u003ccode\u003eCipher Block Chaining with Message Authentication Code\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e EAX: \u003ccode\u003eEncrypt-and-Authenticate\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e IAPM: \u003ccode\u003eInteger Authenticated Parallelizable Mode\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e OCB: \u003ccode\u003eOffset Codebook Mode\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIt is also possible to use AES-CBC with HMAC for integrity checks. However, it\u003c/p\u003e\n\u003cp\u003eis considered more straightforward to use AES-GCM directly instead.\u003c/p\u003e\n\u003ch4\u003eFor RSA: use the OAEP scheme\u003c/h4\u003e\n\u003cp\u003eThe Optimal Asymmetric Encryption Padding scheme (OAEP) adds randomness and a secure hash function that strengthens the regular inner workings of\nRSA.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eArticles \u0026amp; blog posts\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://learn.microsoft.com/en-us/dotnet/standard/security/vulnerabilities-cbc-mode\"\u003eMicrosoft, Timing vulnerabilities with CBC-mode\n  symmetric decryption using padding\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Padding_oracle_attack\"\u003eWikipedia, Padding Oracle Attack\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Chosen-ciphertext_attack\"\u003eWikipedia, Chosen-Ciphertext Attack\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Chosen-plaintext_attack\"\u003eWikipedia, Chosen-Plaintext Attack\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Semantic_security\"\u003eWikipedia, Semantically Secure Cryptosystems\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Optimal_asymmetric_encryption_padding\"\u003eWikipedia, OAEP\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Galois/Counter_Mode\"\u003eWikipedia, Galois/Counter Mode\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/Top10/A02_2021-Cryptographic_Failures/\"\u003eOWASP Top 10 2021 Category A2\u003c/a\u003e - Cryptographic Failures \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration\"\u003eOWASP Top 10 2017 Category A6\u003c/a\u003e - Security\n  Misconfiguration \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/327\"\u003eMITRE, CWE-327\u003c/a\u003e - Use of a Broken or Risky Cryptographic Algorithm \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eThis vulnerability exposes encrypted data to a number of attacks whose goal is to recover the plaintext.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eEncryption algorithms are essential for protecting sensitive information and ensuring secure communications in a variety of domains. They are used\nfor several important reasons:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Confidentiality, privacy, and intellectual property protection \u003c/li\u003e\n  \u003cli\u003e Security during transmission or on storage devices \u003c/li\u003e\n  \u003cli\u003e Data integrity, general trust, and authentication \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWhen selecting encryption algorithms, tools, or combinations, you should also consider two things:\u003c/p\u003e\n\u003col\u003e\n  \u003cli\u003e No encryption is unbreakable. \u003c/li\u003e\n  \u003cli\u003e The strength of an encryption algorithm is usually measured by the effort required to crack it within a reasonable time frame. \u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eFor these reasons, as soon as cryptography is included in a project, it is important to choose encryption algorithms that are considered strong and\nsecure by the cryptography community.\u003c/p\u003e\n\u003cp\u003eFor AES, the weakest modes are CBC (Cipher Block Chaining) and ECB (Electronic Codebook) because they are either vulnerable to padding oracles or\ndo not provide authentication mechanisms.\u003c/p\u003e\n\u003cp\u003eFor RSA, the weakest algorithms are either using it without padding or using the PKCS1v1.5 padding scheme.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eThe cleartext of an encrypted message might be recoverable. Additionally, it might be possible to modify the cleartext of an encrypted message.\u003c/p\u003e\n\u003cp\u003eBelow are some real-world scenarios that illustrate possible impacts of an attacker exploiting the vulnerability.\u003c/p\u003e\n\u003ch4\u003eTheft of sensitive data\u003c/h4\u003e\n\u003cp\u003eThe encrypted message might contain data that is considered sensitive and should not be known to third parties.\u003c/p\u003e\n\u003cp\u003eBy using a weak algorithm the likelihood that an attacker might be able to recover the cleartext drastically increases.\u003c/p\u003e\n\u003ch4\u003eAdditional attack surface\u003c/h4\u003e\n\u003cp\u003eBy modifying the cleartext of the encrypted message it might be possible for an attacker to trigger other vulnerabilities in the code. Encrypted\nvalues are often considered trusted, since under normal circumstances it would not be possible for a third party to modify them.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cp\u003eExample with a symmetric cipher, AES:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;botan/cipher_mode.h\u0026gt;\n\nvoid encrypt() {\n  Botan::Cipher_Mode::create(\"AES-256/ECB\", Botan::ENCRYPTION); // Noncompliant\n}\n\u003c/pre\u003e\n\u003cp\u003eExample with an asymmetric cipher, RSA:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;botan/rng.h\u0026gt;\n#include \u0026lt;botan/auto_rng.h\u0026gt;\n#include \u0026lt;botan/rsa.h\u0026gt;\n#include \u0026lt;botan/pubkey.h\u0026gt;\n\nvoid encrypt() {\n  std::unique_ptr\u0026lt;Botan::RandomNumberGenerator\u0026gt;   rng(new Botan::AutoSeeded_RNG);\n  Botan::RSA_PrivateKey                           rsaKey(*rng.get(), 2048);\n\n  Botan::PK_Encryptor_EME(rsaKey, *rng.get(), \"PKCS1v15\"); // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eFor the AES symmetric cipher, use the GCM mode:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;botan/cipher_mode.h\u0026gt;\n\nvoid encrypt() {\n  Botan::Cipher_Mode::create(\"AES-256/GCM\", Botan::ENCRYPTION);\n}\n\u003c/pre\u003e\n\u003cp\u003eFor the RSA asymmetric cipher, use the Optimal Asymmetric Encryption Padding (OAEP):\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;botan/rng.h\u0026gt;\n#include \u0026lt;botan/auto_rng.h\u0026gt;\n#include \u0026lt;botan/rsa.h\u0026gt;\n#include \u0026lt;botan/pubkey.h\u0026gt;\n\nvoid encrypt() {\n  std::unique_ptr\u0026lt;Botan::RandomNumberGenerator\u0026gt;   rng(new Botan::AutoSeeded_RNG);\n  Botan::RSA_PrivateKey                           rsaKey(*rng.get(), 2048);\n\n  Botan::PK_Encryptor_EME(rsaKey, *rng.get(), \"OAEP\");\n}\n\u003c/pre\u003e\n\u003ch3\u003eHow does this work?\u003c/h3\u003e\n\u003cp\u003eAs a rule of thumb, use the cryptographic algorithms and mechanisms that are considered strong by the cryptographic community.\u003c/p\u003e\n\u003cp\u003eAppropriate choices are currently the following.\u003c/p\u003e\n\u003ch4\u003eFor AES: Use Galois/Counter mode (GCM)\u003c/h4\u003e\n\u003cp\u003eGCM mode combines encryption with authentication and integrity checks using a cryptographic hash function and provides both confidentiality and\nauthenticity of data.\u003c/p\u003e\n\u003cp\u003eOther similar modes are:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e CCM: \u003ccode\u003eCounter with CBC-MAC\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e CWC: \u003ccode\u003eCipher Block Chaining with Message Authentication Code\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e EAX: \u003ccode\u003eEncrypt-and-Authenticate\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e IAPM: \u003ccode\u003eInteger Authenticated Parallelizable Mode\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e OCB: \u003ccode\u003eOffset Codebook Mode\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIt is also possible to use AES-CBC with HMAC for integrity checks. However, it\u003c/p\u003e\n\u003cp\u003eis considered more straightforward to use AES-GCM directly instead.\u003c/p\u003e\n\u003ch4\u003eFor RSA: use the OAEP scheme\u003c/h4\u003e\n\u003cp\u003eThe Optimal Asymmetric Encryption Padding scheme (OAEP) adds randomness and a secure hash function that strengthens the regular inner workings of\nRSA.\u003c/p\u003e",
        "context": {
          "key": "botan",
          "displayName": "Botan"
        }
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cp\u003eExample with a symmetric cipher, AES:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"21\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;cryptopp/aes.h\u0026gt;\n#include \u0026lt;cryptopp/modes.h\u0026gt;\n\nvoic encrypt() {\n  CryptoPP::CBC_Mode\u0026lt;CryptoPP::AES\u0026gt;::Encryption(); // Noncompliant\n}\n\u003c/pre\u003e\n\u003cp\u003eExample with an asymmetric cipher, RSA:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"22\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;cryptopp/rsa.h\u0026gt;\n\nvoid encrypt() {\n  CryptoPP::RSAES\u0026lt;CryptoPP::PKCS1v15\u0026gt;::Encryptor(); // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eFor the AES symmetric cipher, use the GCM mode:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"21\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;cryptopp/aes.h\u0026gt;\n#include \u0026lt;cryptopp/modes.h\u0026gt;\n\nvoid encrypt() {\n  CryptoPP::GCM\u0026lt;CryptoPP::AES\u0026gt;::Encryption();\n}\n\u003c/pre\u003e\n\u003cp\u003eFor the RSA asymmetric cipher, use the Optimal Asymmetric Encryption Padding (OAEP):\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"22\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;cryptopp/rsa.h\u0026gt;\n\nvoid encrypt() {\n  CryptoPP::RSAES\u0026lt;CryptoPP::OAEP\u0026lt;CryptoPP::SHA1\u0026gt;\u0026gt;::Encryptor();\n}\n\u003c/pre\u003e\n\u003ch3\u003eHow does this work?\u003c/h3\u003e\n\u003cp\u003eAs a rule of thumb, use the cryptographic algorithms and mechanisms that are considered strong by the cryptographic community.\u003c/p\u003e\n\u003cp\u003eAppropriate choices are currently the following.\u003c/p\u003e\n\u003ch4\u003eFor AES: Use Galois/Counter mode (GCM)\u003c/h4\u003e\n\u003cp\u003eGCM mode combines encryption with authentication and integrity checks using a cryptographic hash function and provides both confidentiality and\nauthenticity of data.\u003c/p\u003e\n\u003cp\u003eOther similar modes are:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e CCM: \u003ccode\u003eCounter with CBC-MAC\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e CWC: \u003ccode\u003eCipher Block Chaining with Message Authentication Code\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e EAX: \u003ccode\u003eEncrypt-and-Authenticate\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e IAPM: \u003ccode\u003eInteger Authenticated Parallelizable Mode\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e OCB: \u003ccode\u003eOffset Codebook Mode\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIt is also possible to use AES-CBC with HMAC for integrity checks. However, it\u003c/p\u003e\n\u003cp\u003eis considered more straightforward to use AES-GCM directly instead.\u003c/p\u003e\n\u003ch4\u003eFor RSA: use the OAEP scheme\u003c/h4\u003e\n\u003cp\u003eThe Optimal Asymmetric Encryption Padding scheme (OAEP) adds randomness and a secure hash function that strengthens the regular inner workings of\nRSA.\u003c/p\u003e",
        "context": {
          "key": "cryptopp",
          "displayName": "CryptoPP"
        }
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cp\u003eExample with a symmetric cipher, AES:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"31\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;openssl/evp.h\u0026gt;\n\nvoid encrypt() {\n  EVP_aes_128_cbc(); // Noncompliant\n}\n\u003c/pre\u003e\n\u003cp\u003eExample with an asymmetric cipher, RSA:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"32\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;openssl/rsa.h\u0026gt;\n\nvoid encrypt() {\n  RSA_public_decrypt(flen, from, to, key, RSA_SSLV23_PADDING); // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eFor the AES symmetric cipher, use the GCM mode:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"31\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;openssl/evp.h\u0026gt;\n\nvoid encrypt() {\n  EVP_aes_128_gcm();\n}\n\u003c/pre\u003e\n\u003cp\u003eFor the RSA asymmetric cipher, use the Optimal Asymmetric Encryption Padding (OAEP):\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"32\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;openssl/rsa.h\u0026gt;\n\nvoid encrypt() {\n  RSA_public_decrypt(flen, from, to, key, RSA_PKCS1_OAEP_PADDING);\n}\n\u003c/pre\u003e\n\u003ch3\u003eHow does this work?\u003c/h3\u003e\n\u003cp\u003eAs a rule of thumb, use the cryptographic algorithms and mechanisms that are considered strong by the cryptographic community.\u003c/p\u003e\n\u003cp\u003eAppropriate choices are currently the following.\u003c/p\u003e\n\u003ch4\u003eFor AES: Use Galois/Counter mode (GCM)\u003c/h4\u003e\n\u003cp\u003eGCM mode combines encryption with authentication and integrity checks using a cryptographic hash function and provides both confidentiality and\nauthenticity of data.\u003c/p\u003e\n\u003cp\u003eOther similar modes are:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e CCM: \u003ccode\u003eCounter with CBC-MAC\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e CWC: \u003ccode\u003eCipher Block Chaining with Message Authentication Code\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e EAX: \u003ccode\u003eEncrypt-and-Authenticate\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e IAPM: \u003ccode\u003eInteger Authenticated Parallelizable Mode\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e OCB: \u003ccode\u003eOffset Codebook Mode\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIt is also possible to use AES-CBC with HMAC for integrity checks. However, it\u003c/p\u003e\n\u003cp\u003eis considered more straightforward to use AES-GCM directly instead.\u003c/p\u003e\n\u003ch4\u003eFor RSA: use the OAEP scheme\u003c/h4\u003e\n\u003cp\u003eThe Optimal Asymmetric Encryption Padding scheme (OAEP) adds randomness and a secure hash function that strengthens the regular inner workings of\nRSA.\u003c/p\u003e",
        "context": {
          "key": "openssl",
          "displayName": "OpenSSL"
        }
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eArticles \u0026amp; blog posts\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://learn.microsoft.com/en-us/dotnet/standard/security/vulnerabilities-cbc-mode\"\u003eMicrosoft, Timing vulnerabilities with CBC-mode\n  symmetric decryption using padding\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Padding_oracle_attack\"\u003eWikipedia, Padding Oracle Attack\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Chosen-ciphertext_attack\"\u003eWikipedia, Chosen-Ciphertext Attack\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Chosen-plaintext_attack\"\u003eWikipedia, Chosen-Plaintext Attack\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Semantic_security\"\u003eWikipedia, Semantically Secure Cryptosystems\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Optimal_asymmetric_encryption_padding\"\u003eWikipedia, OAEP\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Galois/Counter_Mode\"\u003eWikipedia, Galois/Counter Mode\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/Top10/A02_2021-Cryptographic_Failures/\"\u003eOWASP Top 10 2021 Category A2\u003c/a\u003e - Cryptographic Failures \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration\"\u003eOWASP Top 10 2017 Category A6\u003c/a\u003e - Security\n  Misconfiguration \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/327\"\u003eMITRE, CWE-327\u003c/a\u003e - Use of a Broken or Risky Cryptographic Algorithm \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "cert",
      "cwe",
      "privacy"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S5547",
    "name": "Cipher algorithms should be robust",
    "defaultSeverity": "CRITICAL",
    "type": "VULNERABILITY",
    "cleanCodeAttribute": "TRUSTWORTHY",
    "defaultImpacts": {
      "SECURITY": "HIGH"
    },
    "description": "\u003cp\u003eThis vulnerability makes it possible that the cleartext of the encrypted message might be recoverable without prior knowledge of the key.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eEncryption algorithms are essential for protecting sensitive information and ensuring secure communication in various domains. They are used for\nseveral important reasons:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Confidentiality, privacy, and intellectual property protection \u003c/li\u003e\n  \u003cli\u003e Security during transmission or on storage devices \u003c/li\u003e\n  \u003cli\u003e Data integrity, general trust, and authentication \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWhen selecting encryption algorithms, tools, or combinations, you should also consider two things:\u003c/p\u003e\n\u003col\u003e\n  \u003cli\u003e No encryption is unbreakable. \u003c/li\u003e\n  \u003cli\u003e The strength of an encryption algorithm is usually measured by the effort required to crack it within a reasonable time frame. \u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eFor these reasons, as soon as cryptography is included in a project, it is important to choose encryption algorithms that are considered strong and\nsecure by the cryptography community.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eThe cleartext of an encrypted message might be recoverable. Additionally, it might be possible to modify the cleartext of an encrypted message.\u003c/p\u003e\n\u003cp\u003eBelow are some real-world scenarios that illustrate some impacts of an attacker exploiting the vulnerability.\u003c/p\u003e\n\u003ch4\u003eTheft of sensitive data\u003c/h4\u003e\n\u003cp\u003eThe encrypted message might contain data that is considered sensitive and should not be known to third parties.\u003c/p\u003e\n\u003cp\u003eBy using a weak algorithm the likelihood that an attacker might be able to recover the cleartext drastically increases.\u003c/p\u003e\n\u003ch4\u003eAdditional attack surface\u003c/h4\u003e\n\u003cp\u003eBy modifying the cleartext of the encrypted message it might be possible for an attacker to trigger other vulnerabilities in the code. Encrypted\nvalues are often considered trusted, since under normal circumstances it would not be possible for a third party to modify them.\u003c/p\u003e\n\u003ch2\u003eHow to fix it in Botan\u003c/h2\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003cp\u003eThe following code contains examples of algorithms that are not considered highly resistant to cryptanalysis and thus should be avoided.\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;botan/cipher_mode.h\u0026gt;\n\nvoid encrypt() {\n  Botan::Cipher_Mode::create(\"DES/CBC/PKCS7\", Botan::ENCRYPTION); // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;botan/cipher_mode.h\u0026gt;\n\nvoid encrypt() {\n  Botan::Cipher_Mode::create(\"AES-256/GCM\", Botan::ENCRYPTION);\n}\n\u003c/pre\u003e\n\u003ch3\u003eHow does this work?\u003c/h3\u003e\n\u003ch4\u003eUse a secure algorithm\u003c/h4\u003e\n\u003cp\u003eIt is highly recommended to use an algorithm that is currently considered secure by the cryptographic community. A common choice for such an\nalgorithm is the Advanced Encryption Standard (AES).\u003c/p\u003e\n\u003cp\u003eFor block ciphers, it is not recommended to use algorithms with a block size that is smaller than 128 bits.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://botan.randombit.net/handbook/\"\u003eBotan\u003c/a\u003e - Handbook \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://www.feistyduck.com/books/openssl-cookbook/\"\u003eOpenSSL\u003c/a\u003e - Cookbook \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/Top10/A02_2021-Cryptographic_Failures/\"\u003eOWASP Top 10 2021 Category A2\u003c/a\u003e - Cryptographic Failures \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://www.owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\"\u003eOWASP Top 10 2017 Category A3\u003c/a\u003e - Sensitive Data\n  Exposure \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/327\"\u003eMITRE, CWE-327\u003c/a\u003e - Use of a Broken or Risky Cryptographic Algorithm \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eThis vulnerability makes it possible that the cleartext of the encrypted message might be recoverable without prior knowledge of the key.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eEncryption algorithms are essential for protecting sensitive information and ensuring secure communication in various domains. They are used for\nseveral important reasons:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Confidentiality, privacy, and intellectual property protection \u003c/li\u003e\n  \u003cli\u003e Security during transmission or on storage devices \u003c/li\u003e\n  \u003cli\u003e Data integrity, general trust, and authentication \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWhen selecting encryption algorithms, tools, or combinations, you should also consider two things:\u003c/p\u003e\n\u003col\u003e\n  \u003cli\u003e No encryption is unbreakable. \u003c/li\u003e\n  \u003cli\u003e The strength of an encryption algorithm is usually measured by the effort required to crack it within a reasonable time frame. \u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eFor these reasons, as soon as cryptography is included in a project, it is important to choose encryption algorithms that are considered strong and\nsecure by the cryptography community.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eThe cleartext of an encrypted message might be recoverable. Additionally, it might be possible to modify the cleartext of an encrypted message.\u003c/p\u003e\n\u003cp\u003eBelow are some real-world scenarios that illustrate some impacts of an attacker exploiting the vulnerability.\u003c/p\u003e\n\u003ch4\u003eTheft of sensitive data\u003c/h4\u003e\n\u003cp\u003eThe encrypted message might contain data that is considered sensitive and should not be known to third parties.\u003c/p\u003e\n\u003cp\u003eBy using a weak algorithm the likelihood that an attacker might be able to recover the cleartext drastically increases.\u003c/p\u003e\n\u003ch4\u003eAdditional attack surface\u003c/h4\u003e\n\u003cp\u003eBy modifying the cleartext of the encrypted message it might be possible for an attacker to trigger other vulnerabilities in the code. Encrypted\nvalues are often considered trusted, since under normal circumstances it would not be possible for a third party to modify them.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eThe following code contains examples of algorithms that are not considered highly resistant to cryptanalysis and thus should be avoided.\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;botan/cipher_mode.h\u0026gt;\n\nvoid encrypt() {\n  Botan::Cipher_Mode::create(\"DES/CBC/PKCS7\", Botan::ENCRYPTION); // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;botan/cipher_mode.h\u0026gt;\n\nvoid encrypt() {\n  Botan::Cipher_Mode::create(\"AES-256/GCM\", Botan::ENCRYPTION);\n}\n\u003c/pre\u003e\n\u003ch3\u003eHow does this work?\u003c/h3\u003e\n\u003ch4\u003eUse a secure algorithm\u003c/h4\u003e\n\u003cp\u003eIt is highly recommended to use an algorithm that is currently considered secure by the cryptographic community. A common choice for such an\nalgorithm is the Advanced Encryption Standard (AES).\u003c/p\u003e\n\u003cp\u003eFor block ciphers, it is not recommended to use algorithms with a block size that is smaller than 128 bits.\u003c/p\u003e",
        "context": {
          "key": "botan",
          "displayName": "Botan"
        }
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eThe following code contains examples of algorithms that are not considered highly resistant to cryptanalysis and thus should be avoided.\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"21\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;cryptopp/des.h\u0026gt;\n\nvoid encrypt() {\n  CryptoPP::DES::Encryption(key, sizeof(key)); // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"21\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;cryptopp/aes.h\u0026gt;\n\nvoid encrypt() {\n  CryptoPP::AES::Encryption(key, sizeof(key));\n}\n\u003c/pre\u003e\n\u003ch3\u003eHow does this work?\u003c/h3\u003e\n\u003ch4\u003eUse a secure algorithm\u003c/h4\u003e\n\u003cp\u003eIt is highly recommended to use an algorithm that is currently considered secure by the cryptographic community. A common choice for such an\nalgorithm is the Advanced Encryption Standard (AES).\u003c/p\u003e\n\u003cp\u003eFor block ciphers, it is not recommended to use algorithms with a block size that is smaller than 128 bits.\u003c/p\u003e",
        "context": {
          "key": "cryptopp",
          "displayName": "CryptoPP"
        }
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eThe following code contains examples of algorithms that are not considered highly resistant to cryptanalysis and thus should be avoided.\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"31\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;openssl/evp.h\u0026gt;\n\nvoid encrypt() {\n  EVP_des_cbc(); // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"31\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;openssl/evp.h\u0026gt;\n\nvoid encrypt() {\n  EVP_aes_128_gcm();\n}\n\u003c/pre\u003e\n\u003ch3\u003eHow does this work?\u003c/h3\u003e\n\u003ch4\u003eUse a secure algorithm\u003c/h4\u003e\n\u003cp\u003eIt is highly recommended to use an algorithm that is currently considered secure by the cryptographic community. A common choice for such an\nalgorithm is the Advanced Encryption Standard (AES).\u003c/p\u003e\n\u003cp\u003eFor block ciphers, it is not recommended to use algorithms with a block size that is smaller than 128 bits.\u003c/p\u003e",
        "context": {
          "key": "openssl",
          "displayName": "OpenSSL"
        }
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://botan.randombit.net/handbook/\"\u003eBotan\u003c/a\u003e - Handbook \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://www.feistyduck.com/books/openssl-cookbook/\"\u003eOpenSSL\u003c/a\u003e - Cookbook \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/Top10/A02_2021-Cryptographic_Failures/\"\u003eOWASP Top 10 2021 Category A2\u003c/a\u003e - Cryptographic Failures \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://www.owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\"\u003eOWASP Top 10 2017 Category A3\u003c/a\u003e - Sensitive Data\n  Exposure \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/327\"\u003eMITRE, CWE-327\u003c/a\u003e - Use of a Broken or Risky Cryptographic Algorithm \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "cert",
      "cwe",
      "privacy"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S1862",
    "name": "Related \"if/else if\" statements should not have the same condition",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eA chain of \u003ccode\u003eif\u003c/code\u003e/\u003ccode\u003eelse if\u003c/code\u003e statements is evaluated from top to bottom. At most, only one branch will be executed: the first\none with a condition that evaluates to \u003ccode\u003etrue\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eTherefore, duplicating a condition automatically leads to dead code. Usually, this is due to a copy/paste error. At best, it’s simply dead code and\nat worst, it’s a bug that is likely to induce further bugs as the code is maintained, and obviously it could lead to unexpected behavior.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nif (param \u003d\u003d 1)\n  openWindow();\nelse if (param \u003d\u003d 2)\n  closeWindow();\nelse if (param \u003d\u003d 1)  // Noncompliant\n  moveWindowToTheBackground();\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nif (param \u003d\u003d 1)\n  openWindow();\nelse if (param \u003d\u003d 2)\n  closeWindow();\nelse if (param \u003d\u003d 3)\n  moveWindowToTheBackground();\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/5dUxBQ\"\u003eCERT, MSC12-C.\u003c/a\u003e - Detect and remove code that has no effect or is never executed\n  \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eA chain of \u003ccode\u003eif\u003c/code\u003e/\u003ccode\u003eelse if\u003c/code\u003e statements is evaluated from top to bottom. At most, only one branch will be executed: the first\none with a condition that evaluates to \u003ccode\u003etrue\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eTherefore, duplicating a condition automatically leads to dead code. Usually, this is due to a copy/paste error. At best, it’s simply dead code and\nat worst, it’s a bug that is likely to induce further bugs as the code is maintained, and obviously it could lead to unexpected behavior.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nif (param \u003d\u003d 1)\n  openWindow();\nelse if (param \u003d\u003d 2)\n  closeWindow();\nelse if (param \u003d\u003d 1)  // Noncompliant\n  moveWindowToTheBackground();\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nif (param \u003d\u003d 1)\n  openWindow();\nelse if (param \u003d\u003d 2)\n  closeWindow();\nelse if (param \u003d\u003d 3)\n  moveWindowToTheBackground();\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/5dUxBQ\"\u003eCERT, MSC12-C.\u003c/a\u003e - Detect and remove code that has no effect or is never executed\n  \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "cert",
      "pitfall",
      "unused"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S824",
    "name": "Functions should not be declared at block scope",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eA function declared at block scope will refer to a member of the enclosing namespace, and so the declaration should be explicitly placed at the\nnamespace level.\u003c/p\u003e\n\u003cp\u003eAdditionally, where a declaration statement could either declare a function or an object, the compiler will choose to declare the function. To\navoid potential developer confusion over the meaning of a declaration, functions should not be declared at block scope.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass A {\n};\n\nvoid fun() {\n  void nestedFun();  // Noncompliant; declares a function in block scope\n\n  A a();      // Noncompliant; declares a function at block scope, not an object\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 8.6 - Functions shall be declared at file scope \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 3-1-2 - Functions shall not be declared at block scope \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eA function declared at block scope will refer to a member of the enclosing namespace, and so the declaration should be explicitly placed at the\nnamespace level.\u003c/p\u003e\n\u003cp\u003eAdditionally, where a declaration statement could either declare a function or an object, the compiler will choose to declare the function. To\navoid potential developer confusion over the meaning of a declaration, functions should not be declared at block scope.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass A {\n};\n\nvoid fun() {\n  void nestedFun();  // Noncompliant; declares a function in block scope\n\n  A a();      // Noncompliant; declares a function at block scope, not an object\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 8.6 - Functions shall be declared at file scope \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 3-1-2 - Functions shall not be declared at block scope \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "misra-c++2008",
      "misra-c2004"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S943",
    "name": "Object declarations should contain no more than 2 levels of pointer indirection",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhile they are extraordinarily useful, pointers are not the most intuitive concept in the world. Pointers to pointers are even harder to understand\nand use correctly. And with each additional level of indirection, pointer variables become more difficult to use correctly. Therefore pointer\ndeclarators should be limited to no more than two levels of nesting.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\ntypedef int * INTPTR;\nstruct s {\n int ** s1;\n int *** s2; // Noncompliant\n};\n\nstruct s ** ps1;\nstruct s *** ps2; // Noncompliant\n\nint ** ( *pfunc1)();\nint ** ( **pfunc2)();\nint ** (***pfunc3)(); // Noncompliant\nint *** ( **pfunc4)(); // Noncompliant\n\nvoid function( int ** par1,\n               int *** par2, // Noncompliant\n               INTPTR * par3,\n               int * par4[],\n               int ** par5[]) // Noncompliant\n{\n  int ** ptr1;\n  int *** ptr2; // Noncompliant\n  INTPTR * ptr3;\n  int * ptr4[ 10 ];\n  int ** ptr5[ 10 ]; //Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\ntypedef int * INTPTR;\nstruct s {\n int ** s1;\n int ** s2;\n};\n\nstruct s ** ps1;\nstruct s ** ps2;\n\nint ** (*pfunc1)();\nint ** (**pfunc2)();\nint ** (**pfunc3)();\nint ** (**pfunc4)();\n\nvoid function( int ** par1,\n               int ** par2,\n               INTPTR * par3,\n               int * par4[],\n               int * par5[])\n{\n  int ** ptr1;\n  int ** ptr2;\n  INTPTR * ptr3;\n  int * ptr4[ 10 ];\n  int * ptr5[ 10 ];\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 17.5 - The declaration of objects should contain no more than 2 levels of pointer indirection \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 5-0-19 - The declaration of objects shall contain no more than two levels of pointer indirection \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 18.5 - Declarations should contain no more than two levels of pointer nesting \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhile they are extraordinarily useful, pointers are not the most intuitive concept in the world. Pointers to pointers are even harder to understand\nand use correctly. And with each additional level of indirection, pointer variables become more difficult to use correctly. Therefore pointer\ndeclarators should be limited to no more than two levels of nesting.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\ntypedef int * INTPTR;\nstruct s {\n int ** s1;\n int *** s2; // Noncompliant\n};\n\nstruct s ** ps1;\nstruct s *** ps2; // Noncompliant\n\nint ** ( *pfunc1)();\nint ** ( **pfunc2)();\nint ** (***pfunc3)(); // Noncompliant\nint *** ( **pfunc4)(); // Noncompliant\n\nvoid function( int ** par1,\n               int *** par2, // Noncompliant\n               INTPTR * par3,\n               int * par4[],\n               int ** par5[]) // Noncompliant\n{\n  int ** ptr1;\n  int *** ptr2; // Noncompliant\n  INTPTR * ptr3;\n  int * ptr4[ 10 ];\n  int ** ptr5[ 10 ]; //Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\ntypedef int * INTPTR;\nstruct s {\n int ** s1;\n int ** s2;\n};\n\nstruct s ** ps1;\nstruct s ** ps2;\n\nint ** (*pfunc1)();\nint ** (**pfunc2)();\nint ** (**pfunc3)();\nint ** (**pfunc4)();\n\nvoid function( int ** par1,\n               int ** par2,\n               INTPTR * par3,\n               int * par4[],\n               int * par5[])\n{\n  int ** ptr1;\n  int ** ptr2;\n  INTPTR * ptr3;\n  int * ptr4[ 10 ];\n  int * ptr5[ 10 ];\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 17.5 - The declaration of objects should contain no more than 2 levels of pointer indirection \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 5-0-19 - The declaration of objects shall contain no more than two levels of pointer indirection \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 18.5 - Declarations should contain no more than two levels of pointer nesting \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "based-on-misra",
      "brain-overload",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S1291",
    "name": "Track uses of \"NOSONAR\" comments",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eAny issue to quality rule can be deactivated with the \u003ccode\u003eNOSONAR\u003c/code\u003e marker. This marker is pretty useful to exclude false-positive results\nbut it can also be used abusively to hide real quality flaws.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when \u003ccode\u003eNOSONAR\u003c/code\u003e is used.\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eAny issue to quality rule can be deactivated with the \u003ccode\u003eNOSONAR\u003c/code\u003e marker. This marker is pretty useful to exclude false-positive results\nbut it can also be used abusively to hide real quality flaws.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when \u003ccode\u003eNOSONAR\u003c/code\u003e is used.\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "bad-practice"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S2260",
    "name": "Track parsing failures",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhen the analysis succeeds, it doesn’t mean that the analyzer was able to understand all the analyzed code. If the analyzer fails to parse some\nparts of your code, it will ignore them during the analysis. This rule will help you track these parsing failures.\u003c/p\u003e\n\u003cp\u003eThere are many reasons why parsing failures can happen, here are the common ones:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Compiler extensions: Your compiler might allow you to write code that isn’t standard-conforming. \u003c/li\u003e\n  \u003cli\u003e Bad analysis environment. This usually means that the environment during the build is different than the one during the analysis. For example,\n  files or symbolic links that were available during the build are not available during the analysis. \u003c/li\u003e\n  \u003cli\u003e Use of new language features that are not yet supported by our analyzer. \u003c/li\u003e\n  \u003cli\u003e Limitation in our analyzer. We are always working on improving this. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eHow do they impact analysis? We cannot judge without looking at specific examples, as they contain a broad range of types of errors. On our side,\nwe will make sure that you get notified through the analysis logs when they have an impact on the quality of the analysis.\u003c/p\u003e\n\u003cp\u003eThere are three recommended ways to deal with parsing failures:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Fix them when it is possible. It should be obvious from the message if you can do it. For example, by replacing the use of a compiler extension\n  with the standard-conforming equivalent. \u003c/li\u003e\n  \u003cli\u003e If you cannot fix them and the analysis logs state that they have a bad impact on the analysis results, Report them. \u003c/li\u003e\n  \u003cli\u003e If you cannot fix them and the analysis logs don’t state anything explicit about their impact, ignore them by resolving them as \"won’t fix\".\n  \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n// This example uses Microsoft extension /Zc:referenceBinding that allows binding r-value to l-value. Even though your compiler might allow it, our analyzer will flag it\n\nstruct S {\n...\n};\n\nvoid f(S\u0026amp;) {\n...\n}\n\nint main() {\n  f(S{}); // Noncompliant: no matching function for call to \u0027f\u0027\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n// Here we are showing how to fix the issue by replacing the code relying on a compiler extension by standard-conforming equivalent\n\nstruct S {\n...\n};\n\nvoid f(S\u0026amp;\u0026amp;) { // Using C++11 r-value reference fixes the issue\n...\n}\n\nint main() {\n  f(S{}); // Compliant\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhen the analysis succeeds, it doesn’t mean that the analyzer was able to understand all the analyzed code. If the analyzer fails to parse some\nparts of your code, it will ignore them during the analysis. This rule will help you track these parsing failures.\u003c/p\u003e\n\u003cp\u003eThere are many reasons why parsing failures can happen, here are the common ones:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Compiler extensions: Your compiler might allow you to write code that isn’t standard-conforming. \u003c/li\u003e\n  \u003cli\u003e Bad analysis environment. This usually means that the environment during the build is different than the one during the analysis. For example,\n  files or symbolic links that were available during the build are not available during the analysis. \u003c/li\u003e\n  \u003cli\u003e Use of new language features that are not yet supported by our analyzer. \u003c/li\u003e\n  \u003cli\u003e Limitation in our analyzer. We are always working on improving this. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eHow do they impact analysis? We cannot judge without looking at specific examples, as they contain a broad range of types of errors. On our side,\nwe will make sure that you get notified through the analysis logs when they have an impact on the quality of the analysis.\u003c/p\u003e\n\u003cp\u003eThere are three recommended ways to deal with parsing failures:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Fix them when it is possible. It should be obvious from the message if you can do it. For example, by replacing the use of a compiler extension\n  with the standard-conforming equivalent. \u003c/li\u003e\n  \u003cli\u003e If you cannot fix them and the analysis logs state that they have a bad impact on the analysis results, Report them. \u003c/li\u003e\n  \u003cli\u003e If you cannot fix them and the analysis logs don’t state anything explicit about their impact, ignore them by resolving them as \"won’t fix\".\n  \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n// This example uses Microsoft extension /Zc:referenceBinding that allows binding r-value to l-value. Even though your compiler might allow it, our analyzer will flag it\n\nstruct S {\n...\n};\n\nvoid f(S\u0026amp;) {\n...\n}\n\nint main() {\n  f(S{}); // Noncompliant: no matching function for call to \u0027f\u0027\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n// Here we are showing how to fix the issue by replacing the code relying on a compiler extension by standard-conforming equivalent\n\nstruct S {\n...\n};\n\nvoid f(S\u0026amp;\u0026amp;) { // Using C++11 r-value reference fixes the issue\n...\n}\n\nint main() {\n  f(S{}); // Compliant\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "suspicious"
    ],
    "deprecatedKeys": [
      "c:ParsingError"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S3590",
    "name": "Stack allocated memory and non-owned memory should not be freed",
    "defaultSeverity": "BLOCKER",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003cp\u003eExplicitly releasing non-heap memory leads to undefined behavior.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003efree\u003c/code\u003e function and \u003ccode\u003edelete\u003c/code\u003e operator are used exclusively to release dynamically allocated memory. Attempting to release\nany other type of memory is \u003cem\u003eundefined behavior\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eThe following non-heap memory types may not be released:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Stack allocated memory - local variables or memory allocated with the \u003ccode\u003ealloca\u003c/code\u003e, \u003ccode\u003e_alloca\u003c/code\u003e, \u003ccode\u003e_malloca\u003c/code\u003e and\n  \u003ccode\u003e__builtin_alloca\u003c/code\u003e functions. \u003c/li\u003e\n  \u003cli\u003e Executable program code - function pointers. \u003c/li\u003e\n  \u003cli\u003e Program data - global and static variables. \u003c/li\u003e\n  \u003cli\u003e Read-only program data - constants and strings. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eWhat is the potential impact\u003c/h3\u003e\n\u003cp\u003eTrying to release non-heap memory using \u003ccode\u003efree\u003c/code\u003e or \u003ccode\u003edelete\u003c/code\u003e results in undefined behavior.\u003c/p\u003e\n\u003cp\u003eWhen a program comprises undefined behavior, the compiler no longer needs to adhere to the language standard, and the program has no meaning\nassigned to it.\u003c/p\u003e\n\u003cp\u003eThe application will usually just crash, but in the worst case, the application may appear to execute correctly, while losing data or producing\nincorrect results.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eRemove any calls to \u003ccode\u003efree\u003c/code\u003e or \u003ccode\u003edelete\u003c/code\u003e that aim at releasing non-heap memory.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003cp\u003eStack allocated memory:\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid fun(int size) {\n  int number \u003d 0;\n  char* name \u003d (char*)alloca(size);\n  // ...\n  delete \u0026amp;number; // Noncompliant: memory is stack-allocated.\n  free(name); // Noncompliant: memory is stack-allocated.\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid fun(int size) {\n  int number \u003d 0;\n  char* name \u003d (char*)alloca(size);\n  // ...\n  // Compliant: stack memory is automatically released at the end of the function.\n}\n\u003c/pre\u003e\n\u003cp\u003eExecutable program code:\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\nint getValue() {\n  return 10;\n}\n\nint main() {\n  // ...\n  free((void*) \u0026amp;getValue); // Noncompliant: memory is part of executable code.\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\nint getValue() {\n  return 10;\n}\n\nint main() {\n  // ...\n  // Compliant: program code will be released at the end of the program\u0027s execution.\n  return 0;\n}\n\u003c/pre\u003e\n\u003cp\u003eProgram data:\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"noncompliant\"\u003e\nstruct S {\n  static inline int data \u003d 64;\n};\n\nint main() {\n  static int x \u003d 8;\n  // ...\n  free(\u0026amp;x); // Noncompliant: memory part of the program\u0027s data.\n  free(\u0026amp;S::data); // Noncompliant: memory part of the program\u0027s data.\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"compliant\"\u003e\nstruct S {\n  static inline int data \u003d 64;\n};\n\nint main() {\n  static int x \u003d 8;\n  // ...\n  // Compliant: globals and static variables are released at the end of the program\u0027s execution.\n  return 0;\n}\n\u003c/pre\u003e\n\u003cp\u003eRead-only program data:\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"4\" data-diff-type\u003d\"noncompliant\"\u003e\nint const limit \u003d 128;\n\nint main() {\n  char* name \u003d \"string\";\n  // ...\n  free((void*)\u0026amp;limit); // Noncompliant: memory part of program\u0027s read-only data.\n  free(name); // Noncompliant: memory part of read-only program data.\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"4\" data-diff-type\u003d\"compliant\"\u003e\nint const limit \u003d 128;\n\nint main() {\n  char const* name \u003d \"string\";\n  // ...\n  // Compliant: read-only program data is freed at the end of the program\u0027s execution.\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch3\u003eGoing the extra mile\u003c/h3\u003e\n\u003cp\u003eThe accidental release of non-heap memory usually occurs in practice if the same pointer variable is used to once reference heap and once non-heap\nmemory. This may lead to confusion and should be avoided.\u003c/p\u003e\n\u003cp\u003eThese best practices help to avoid accidentally releasing non-heap memory:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e If accessing different memory types, use different pointer variables. \u003c/li\u003e\n  \u003cli\u003e When passing non-heap memory addresses to functions, ensure that the functions do not attempt to release the memory. \u003c/li\u003e\n  \u003cli\u003e If manually managing dynamic memory, release it in the same scope where it was acquired. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe following example shows a situation in which the same pointer variable is used to hold a stack or heap address. This leads to a situation in\nwhich heap memory is accidentally released.\u003c/p\u003e\n\u003cp\u003eNoncompliant code example\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"5\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid fun(int length) {\n  static char smallString[32];\n  char* usedString;\n\n  if (length \u0026lt; 31) {\n    usedString \u003d smallString; // Pointer to stack memory assigned here\n  } else {\n    usedString \u003d (char*)malloc(length + 1);\n  }\n  // ...\n  free(usedString); // Noncompliant: if length \u0026lt; 31, the freed memory will be located on the stack.\n}\n\u003c/pre\u003e\n\u003cp\u003eCompliant solution\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"5\" data-diff-type\u003d\"compliant\"\u003e\nvoid fun(int length) {\n  static char smallString[32];\n  char* stackOrHeapString;\n  char* heapString \u003d nullptr;\n\n  if (length \u0026lt; 31) {\n    stackOrHeapString \u003d smallString;\n  } else {\n    heapString \u003d (char*)malloc(length + 1);\n    stackOrHeapString \u003d heapString;\n  }\n  // ...\n  free(heapString); // Compliant: only the heap string will be freed if allocated.\n}\n\u003c/pre\u003e\n\u003cp\u003eThe following example shows a situation in which dynamically allocated memory is acquired and released in different functions. On top of this\nchain, a stack allocated buffer is introduced, leading to a call to \u003ccode\u003efree\u003c/code\u003e of stack memory.\u003c/p\u003e\n\u003cp\u003eNoncompliant code example\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"6\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid use(char* string) {\n  // ...\n  free(string); // Noncompliant: pointer\u0027s origin is unknown. If non-heap, the program will crash.\n}\n\nvoid fun(int length) {\n  static char smallString[32];\n  char* usedString;\n\n  if (length \u0026lt; 31) {\n    usedString \u003d smallString; // Pointer to stack memory assigned here\n  } else {\n    usedString \u003d (char*)malloc(length + 1);\n  }\n  use(usedString); // If length \u0026lt; 31, the unsafe memory will free memory located on the stack.\n}\n\u003c/pre\u003e\n\u003cp\u003eCompliant solution\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"6\" data-diff-type\u003d\"compliant\"\u003e\nvoid use(char* string) {\n  // ...\n  // Compliant: memory no longer freed in the called function\n}\n\nvoid fun(int length) {\n  static char smallString[32];\n  if (length \u0026lt; 31) {\n    use(smallString);\n  } else {\n    heapString \u003d (char*)malloc(length + 1);\n    use(heapString);\n    free(heapString); // Compliant: memory released in the scope it was acquired in.\n  }\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eExplicitly releasing non-heap memory leads to undefined behavior.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe \u003ccode\u003efree\u003c/code\u003e function and \u003ccode\u003edelete\u003c/code\u003e operator are used exclusively to release dynamically allocated memory. Attempting to release\nany other type of memory is \u003cem\u003eundefined behavior\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eThe following non-heap memory types may not be released:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Stack allocated memory - local variables or memory allocated with the \u003ccode\u003ealloca\u003c/code\u003e, \u003ccode\u003e_alloca\u003c/code\u003e, \u003ccode\u003e_malloca\u003c/code\u003e and\n  \u003ccode\u003e__builtin_alloca\u003c/code\u003e functions. \u003c/li\u003e\n  \u003cli\u003e Executable program code - function pointers. \u003c/li\u003e\n  \u003cli\u003e Program data - global and static variables. \u003c/li\u003e\n  \u003cli\u003e Read-only program data - constants and strings. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eWhat is the potential impact\u003c/h3\u003e\n\u003cp\u003eTrying to release non-heap memory using \u003ccode\u003efree\u003c/code\u003e or \u003ccode\u003edelete\u003c/code\u003e results in undefined behavior.\u003c/p\u003e\n\u003cp\u003eWhen a program comprises undefined behavior, the compiler no longer needs to adhere to the language standard, and the program has no meaning\nassigned to it.\u003c/p\u003e\n\u003cp\u003eThe application will usually just crash, but in the worst case, the application may appear to execute correctly, while losing data or producing\nincorrect results.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eRemove any calls to \u003ccode\u003efree\u003c/code\u003e or \u003ccode\u003edelete\u003c/code\u003e that aim at releasing non-heap memory.\u003c/p\u003e\n\n\u003cp\u003eStack allocated memory:\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid fun(int size) {\n  int number \u003d 0;\n  char* name \u003d (char*)alloca(size);\n  // ...\n  delete \u0026amp;number; // Noncompliant: memory is stack-allocated.\n  free(name); // Noncompliant: memory is stack-allocated.\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid fun(int size) {\n  int number \u003d 0;\n  char* name \u003d (char*)alloca(size);\n  // ...\n  // Compliant: stack memory is automatically released at the end of the function.\n}\n\u003c/pre\u003e\n\u003cp\u003eExecutable program code:\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\nint getValue() {\n  return 10;\n}\n\nint main() {\n  // ...\n  free((void*) \u0026amp;getValue); // Noncompliant: memory is part of executable code.\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\nint getValue() {\n  return 10;\n}\n\nint main() {\n  // ...\n  // Compliant: program code will be released at the end of the program\u0027s execution.\n  return 0;\n}\n\u003c/pre\u003e\n\u003cp\u003eProgram data:\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"noncompliant\"\u003e\nstruct S {\n  static inline int data \u003d 64;\n};\n\nint main() {\n  static int x \u003d 8;\n  // ...\n  free(\u0026amp;x); // Noncompliant: memory part of the program\u0027s data.\n  free(\u0026amp;S::data); // Noncompliant: memory part of the program\u0027s data.\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"compliant\"\u003e\nstruct S {\n  static inline int data \u003d 64;\n};\n\nint main() {\n  static int x \u003d 8;\n  // ...\n  // Compliant: globals and static variables are released at the end of the program\u0027s execution.\n  return 0;\n}\n\u003c/pre\u003e\n\u003cp\u003eRead-only program data:\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"4\" data-diff-type\u003d\"noncompliant\"\u003e\nint const limit \u003d 128;\n\nint main() {\n  char* name \u003d \"string\";\n  // ...\n  free((void*)\u0026amp;limit); // Noncompliant: memory part of program\u0027s read-only data.\n  free(name); // Noncompliant: memory part of read-only program data.\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"4\" data-diff-type\u003d\"compliant\"\u003e\nint const limit \u003d 128;\n\nint main() {\n  char const* name \u003d \"string\";\n  // ...\n  // Compliant: read-only program data is freed at the end of the program\u0027s execution.\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch3\u003eGoing the extra mile\u003c/h3\u003e\n\u003cp\u003eThe accidental release of non-heap memory usually occurs in practice if the same pointer variable is used to once reference heap and once non-heap\nmemory. This may lead to confusion and should be avoided.\u003c/p\u003e\n\u003cp\u003eThese best practices help to avoid accidentally releasing non-heap memory:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e If accessing different memory types, use different pointer variables. \u003c/li\u003e\n  \u003cli\u003e When passing non-heap memory addresses to functions, ensure that the functions do not attempt to release the memory. \u003c/li\u003e\n  \u003cli\u003e If manually managing dynamic memory, release it in the same scope where it was acquired. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe following example shows a situation in which the same pointer variable is used to hold a stack or heap address. This leads to a situation in\nwhich heap memory is accidentally released.\u003c/p\u003e\n\u003cp\u003eNoncompliant code example\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"5\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid fun(int length) {\n  static char smallString[32];\n  char* usedString;\n\n  if (length \u0026lt; 31) {\n    usedString \u003d smallString; // Pointer to stack memory assigned here\n  } else {\n    usedString \u003d (char*)malloc(length + 1);\n  }\n  // ...\n  free(usedString); // Noncompliant: if length \u0026lt; 31, the freed memory will be located on the stack.\n}\n\u003c/pre\u003e\n\u003cp\u003eCompliant solution\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"5\" data-diff-type\u003d\"compliant\"\u003e\nvoid fun(int length) {\n  static char smallString[32];\n  char* stackOrHeapString;\n  char* heapString \u003d nullptr;\n\n  if (length \u0026lt; 31) {\n    stackOrHeapString \u003d smallString;\n  } else {\n    heapString \u003d (char*)malloc(length + 1);\n    stackOrHeapString \u003d heapString;\n  }\n  // ...\n  free(heapString); // Compliant: only the heap string will be freed if allocated.\n}\n\u003c/pre\u003e\n\u003cp\u003eThe following example shows a situation in which dynamically allocated memory is acquired and released in different functions. On top of this\nchain, a stack allocated buffer is introduced, leading to a call to \u003ccode\u003efree\u003c/code\u003e of stack memory.\u003c/p\u003e\n\u003cp\u003eNoncompliant code example\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"6\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid use(char* string) {\n  // ...\n  free(string); // Noncompliant: pointer\u0027s origin is unknown. If non-heap, the program will crash.\n}\n\nvoid fun(int length) {\n  static char smallString[32];\n  char* usedString;\n\n  if (length \u0026lt; 31) {\n    usedString \u003d smallString; // Pointer to stack memory assigned here\n  } else {\n    usedString \u003d (char*)malloc(length + 1);\n  }\n  use(usedString); // If length \u0026lt; 31, the unsafe memory will free memory located on the stack.\n}\n\u003c/pre\u003e\n\u003cp\u003eCompliant solution\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"6\" data-diff-type\u003d\"compliant\"\u003e\nvoid use(char* string) {\n  // ...\n  // Compliant: memory no longer freed in the called function\n}\n\nvoid fun(int length) {\n  static char smallString[32];\n  if (length \u0026lt; 31) {\n    use(smallString);\n  } else {\n    heapString \u003d (char*)malloc(length + 1);\n    use(heapString);\n    free(heapString); // Compliant: memory released in the scope it was acquired in.\n  }\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "symbolic-execution",
      "unpredictable"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S820",
    "name": "Object and function types should be explicitly stated in their declarations and definitions",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe C90 standard allows implicit typing of variables and functions, and some C compilers still support legacy code by allowing implicit typing. But\nit should not be used for new code because it might lead to confusion.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nextern x;\nconst x;\nstatic fun(void);\ntypedef ( *pfi ) ( void );\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nextern int16_t x;\nconst int16_t x;\nstatic int16_t fun(void);\ntypedef int16_t ( *pfi ) ( void );\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 8.2 - Whenever an object or function is declared or defined, its type shall be explicitly stated \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 8.1 - Types shall be explicitly specified \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/8NUxBQ\"\u003eCERT, DCL31-C.\u003c/a\u003e - Declare identifiers before using them \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe C90 standard allows implicit typing of variables and functions, and some C compilers still support legacy code by allowing implicit typing. But\nit should not be used for new code because it might lead to confusion.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nextern x;\nconst x;\nstatic fun(void);\ntypedef ( *pfi ) ( void );\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nextern int16_t x;\nconst int16_t x;\nstatic int16_t fun(void);\ntypedef int16_t ( *pfi ) ( void );\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 8.2 - Whenever an object or function is declared or defined, its type shall be explicitly stated \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 8.1 - Types shall be explicitly specified \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/8NUxBQ\"\u003eCERT, DCL31-C.\u003c/a\u003e - Declare identifiers before using them \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "based-on-misra",
      "cert"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S1172",
    "name": "Unused function parameters should be removed",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eA typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function’s\nbody. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to\nsuch parameters, the function’s behavior will be the same, but the programmer’s intention won’t be clearly expressed anymore. Therefore, removing\nfunction parameters that are not being utilized is considered best practice.\u003c/p\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThere are some cases when you want to have an unused parameter (usually because the function has to conform to a fixed prototype, or because it is\nvirtual, or it will be called from a template). In this case, and if the parameter is never used, an accepted practice is to leave it unnamed. If it\nis only sometimes used (for instance, depending on conditional compilation), you may, since C++17, use the \u003ccode\u003e[[maybe_unused]]\u003c/code\u003e attribute to\nbe explicit about it.\u003c/p\u003e\n\u003cpre\u003e\nvoid f([[maybe_unused]] int i) {\n  assert(i \u0026lt; 42); // In optimized mode, this assert will be removed, and \"i\" will be unused\n}\n\u003c/pre\u003e\n\u003cp\u003eIn case of Objective-C, it is acceptable to have unused parameters if the method is supposed to be overridden.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eHaving unused function parameters in your code can lead to confusion and misunderstanding of a developer’s intention. They reduce code readability\nand introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid doSomething(int a, int b) { // Noncompliant, \"b\" is unused\n  compute(a);\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid doSomething(int a) {\n  compute(a);\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 2.7 - There should be no unused parameters in functions \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/5dUxBQ\"\u003eCERT, MSC12-C.\u003c/a\u003e - Detect and remove code that has no effect or is never executed\n  \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f9-unused-parameters-should-be-unnamed\"\u003eF.9: Unused parameters\n  should be unnamed\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eA typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function’s\nbody. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to\nsuch parameters, the function’s behavior will be the same, but the programmer’s intention won’t be clearly expressed anymore. Therefore, removing\nfunction parameters that are not being utilized is considered best practice.\u003c/p\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThere are some cases when you want to have an unused parameter (usually because the function has to conform to a fixed prototype, or because it is\nvirtual, or it will be called from a template). In this case, and if the parameter is never used, an accepted practice is to leave it unnamed. If it\nis only sometimes used (for instance, depending on conditional compilation), you may, since C++17, use the \u003ccode\u003e[[maybe_unused]]\u003c/code\u003e attribute to\nbe explicit about it.\u003c/p\u003e\n\u003cpre\u003e\nvoid f([[maybe_unused]] int i) {\n  assert(i \u0026lt; 42); // In optimized mode, this assert will be removed, and \"i\" will be unused\n}\n\u003c/pre\u003e\n\u003cp\u003eIn case of Objective-C, it is acceptable to have unused parameters if the method is supposed to be overridden.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eHaving unused function parameters in your code can lead to confusion and misunderstanding of a developer’s intention. They reduce code readability\nand introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid doSomething(int a, int b) { // Noncompliant, \"b\" is unused\n  compute(a);\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid doSomething(int a) {\n  compute(a);\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 2.7 - There should be no unused parameters in functions \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/5dUxBQ\"\u003eCERT, MSC12-C.\u003c/a\u003e - Detect and remove code that has no effect or is never executed\n  \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f9-unused-parameters-should-be-unnamed\"\u003eF.9: Unused parameters\n  should be unnamed\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "based-on-misra",
      "cert",
      "unused"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S946",
    "name": "The address of an automatic object should not be assigned to another object that may persist after the first object has ceased to exist",
    "defaultSeverity": "BLOCKER",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003cp\u003eThe address of an automatic object should not be persisted beyond the object’s lifetime.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eAn automatic object is an object whose lifetime is automatically managed. The storage for an automatic object, e.g. a local variable, is allocated\nat the beginning of the enclosing code block and is deallocated at the end. This is commonly referred to as \"allocated on the stack\".\u003c/p\u003e\n\u003cp\u003eIf the address of an automatic object is assigned to another automatic object of larger scope, a static or extern object, or if it is returned from\na function (using \u003ccode\u003ereturn\u003c/code\u003e or an output parameter), then there will be a point where the address will point to an object that ceased to\nexist. In that case, the address becomes invalid, and attempts to dereference the invalid address — trying to access the object that ceased to\nexist — result in undefined behavior.\u003c/p\u003e\n\u003cpre\u003e\nint *global \u003d nullptr;\n\nint* bar(int **out) {\n  int local \u003d 42;\n  int *ptr;\n  global \u003d \u0026amp;local; // Noncompliant: assigning the address of an object allocated on the stack to a global variable\n  {\n    int i \u003d 9001;\n    ptr \u003d \u0026amp;i; // Noncompliant: assigning the address of a stack-allocated object to an object that outlives it\n  }\n  *out \u003d \u0026amp;local; // Noncompliant: returning the address of an object allocated on the stack (via output parameter)\n  return \u0026amp;local; // Noncompliant: returning the address of an object allocated on the stack\n}\n\u003c/pre\u003e\n\u003ch2\u003eWhat is the potential impact?\u003c/h2\u003e\n\u003cp\u003ePersisting addresses of objects with automatic storage past their lifetime is dangerous as it creates invalid addresses. Attempts to access objects\nthat no longer exist through such invalid addresses result in undefined behavior.\u003c/p\u003e\n\u003cp\u003eFor programs that exercise undefined behavior, the compiler is no longer bound by the language specification. The application may crash or, even\nworse, the application may appear to execute correctly while losing data or producing incorrect results.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eThere are multiple approaches to avoid persisting addresses of objects with automatic storage after their lifetime ended:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Make a full copy of the object instead of using its address. \u003c/li\u003e\n  \u003cli\u003e Allocate the object on the heap (free-store) and deallocate it once done. \u003c/li\u003e\n  \u003cli\u003e Create the automatic object in a larger scope where it outlives all accesses through its address. \u003c/li\u003e\n  \u003cli\u003e Reduce the scope of objects that store the address of the original automatic object. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nint* bar(void) {\n  int local_auto \u003d 42;\n  return \u0026amp;local_auto; // Noncompliant: returns the address of a stack-allocated object\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nint foo() {\n  int local_auto \u003d 42;\n  return local_auto; // Compliant: returns a value rather than an address\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nint* foo() {\n  int *local_auto \u003d new int(42);\n  return local_auto; // Compliant: returns the address of a heap-allocated object\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\nconst char *str_ptr \u003d nullptr;\n\nvoid bar() {\n  const char str[] \u003d \"This will change\";\n  str_ptr \u003d str; // Noncompliant: address of `str` becomes invalid when `str` goes out of scope\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\nvoid bar() {\n  const char str[] \u003d \"This will change\";\n  const char *str_ptr \u003d str; // Compliant: `str_ptr` has the same storage duration as `str`\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;string\u0026gt;\n\nstd::string bar() {\n  std::string str \u003d \"This will change\";\n  return str; // Compliant: `str` will be moved to the caller (using C++ move semantics)\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;array\u0026gt;\n#include \u0026lt;cstddef\u0026gt;\n\nint *buz() {\n  int buf[256];\n  for (size_t i \u003d 0; i \u0026lt; std::size(buf); ++i) {\n    buf[i] \u003d i;\n  }\n  return buf; // Noncompliant: returns address of stack-allocated object\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;array\u0026gt;\n#include \u0026lt;cstddef\u0026gt;\n#include \u0026lt;numeric\u0026gt;\n\nvoid buz(int *buf, size_t length) {\n  std::iota(\u0026amp;buf[0], \u0026amp;buf[length], 0);\n}\n\nvoid caller() {\n  int buf[256];\n  buz(buf, std::size(buf));\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;array\u0026gt;\n\nstd::array\u0026lt;int, 3\u0026gt; buz() {\n  std::array\u0026lt;int, 3\u0026gt; buf \u003d {1, 2, 3};\n  return buf; // Compliant: `buf` will by copied to the caller; return-value optimization (RVO) might be invoked\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;numeric\u0026gt;\n#include \u0026lt;vector\u0026gt;\n\nstd::vector\u0026lt;int\u0026gt; buz() {\n  std::vector\u0026lt;int\u0026gt; buf;\n  std::iota(buf.begin(), buf.end(), 0);\n  return buf; // Compliant: `buf` will be moved to the caller (using C++ move semantics)\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"4\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;algorithm\u0026gt;\n#include \u0026lt;array\u0026gt;\n\nvoid fun(char **out) {\n  char buffer[64];\n  std::fill(std::begin(buffer), std::end(buffer), 42);\n  *out \u003d buffer; // Noncompliant: `buffer`\u0027s address becomes invalid once it goes out of scope\n}\n\nvoid caller() {\n  char *p;\n  fun(\u0026amp;p);\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"4\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;algorithm\u0026gt;\n#include \u0026lt;array\u0026gt;\n\nchar buffer[64];\n\nvoid fun(char **out) {\n  std::fill(std::begin(buffer), std::end(buffer), 42);\n  *out \u003d buffer; // Compliant: `buffer`\u0027s lifetime is the program\u0027s lifetime\n}\n\nvoid caller() {\n  char *p;\n  fun(\u0026amp;p);\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"4\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;vector\u0026gt;\n\nstd::vector\u0026lt;int\u0026gt; fun() {\n  std::vector\u0026lt;int\u0026gt; buf(/* count */ 64, /* initial value */ 42);\n  return buf;\n}\n\nvoid caller() {\n  auto buf \u003d fun();\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eConference presentations\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CppCon 2018 - \u003ca href\u003d\"https://www.youtube.com/watch?v\u003duQyT-5iWUow\u0026amp;ab_channel\u003dCppCon\"\u003eSurprises in Object Lifetime\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/UtcxBQ\"\u003eDCL30-C. Declare objects with appropriate storage durations\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/OXw-BQ\"\u003eEXP54-CPP. Do not access an object outside of its lifetime\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/6NUxBQ\"\u003eMSC00-C. Compile cleanly at high warning levels\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e MISRA C:2004, 17.6 - The address of an object with automatic storage shall not be assigned to another object that may persist after the first\n  object has ceased to exist \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 7-5-2 - The address of an object with automatic storage shall not be assigned to another object that may persist after the\n  first object has ceased to exist \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 18.6 - The address of an object with automatic storage shall not be copied to another object that persists after the first object\n  has ceased to exist \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e S837 detects attempts to return addresses of automatic variables \u003c/li\u003e\n  \u003cli\u003e S839 ensures that functions do not return references or pointers to parameters that are passed by reference \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eThe address of an automatic object should not be persisted beyond the object’s lifetime.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eAn automatic object is an object whose lifetime is automatically managed. The storage for an automatic object, e.g. a local variable, is allocated\nat the beginning of the enclosing code block and is deallocated at the end. This is commonly referred to as \"allocated on the stack\".\u003c/p\u003e\n\u003cp\u003eIf the address of an automatic object is assigned to another automatic object of larger scope, a static or extern object, or if it is returned from\na function (using \u003ccode\u003ereturn\u003c/code\u003e or an output parameter), then there will be a point where the address will point to an object that ceased to\nexist. In that case, the address becomes invalid, and attempts to dereference the invalid address — trying to access the object that ceased to\nexist — result in undefined behavior.\u003c/p\u003e\n\u003cpre\u003e\nint *global \u003d nullptr;\n\nint* bar(int **out) {\n  int local \u003d 42;\n  int *ptr;\n  global \u003d \u0026amp;local; // Noncompliant: assigning the address of an object allocated on the stack to a global variable\n  {\n    int i \u003d 9001;\n    ptr \u003d \u0026amp;i; // Noncompliant: assigning the address of a stack-allocated object to an object that outlives it\n  }\n  *out \u003d \u0026amp;local; // Noncompliant: returning the address of an object allocated on the stack (via output parameter)\n  return \u0026amp;local; // Noncompliant: returning the address of an object allocated on the stack\n}\n\u003c/pre\u003e\n\u003ch2\u003eWhat is the potential impact?\u003c/h2\u003e\n\u003cp\u003ePersisting addresses of objects with automatic storage past their lifetime is dangerous as it creates invalid addresses. Attempts to access objects\nthat no longer exist through such invalid addresses result in undefined behavior.\u003c/p\u003e\n\u003cp\u003eFor programs that exercise undefined behavior, the compiler is no longer bound by the language specification. The application may crash or, even\nworse, the application may appear to execute correctly while losing data or producing incorrect results.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eThere are multiple approaches to avoid persisting addresses of objects with automatic storage after their lifetime ended:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Make a full copy of the object instead of using its address. \u003c/li\u003e\n  \u003cli\u003e Allocate the object on the heap (free-store) and deallocate it once done. \u003c/li\u003e\n  \u003cli\u003e Create the automatic object in a larger scope where it outlives all accesses through its address. \u003c/li\u003e\n  \u003cli\u003e Reduce the scope of objects that store the address of the original automatic object. \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nint* bar(void) {\n  int local_auto \u003d 42;\n  return \u0026amp;local_auto; // Noncompliant: returns the address of a stack-allocated object\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nint foo() {\n  int local_auto \u003d 42;\n  return local_auto; // Compliant: returns a value rather than an address\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nint* foo() {\n  int *local_auto \u003d new int(42);\n  return local_auto; // Compliant: returns the address of a heap-allocated object\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\nconst char *str_ptr \u003d nullptr;\n\nvoid bar() {\n  const char str[] \u003d \"This will change\";\n  str_ptr \u003d str; // Noncompliant: address of `str` becomes invalid when `str` goes out of scope\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\nvoid bar() {\n  const char str[] \u003d \"This will change\";\n  const char *str_ptr \u003d str; // Compliant: `str_ptr` has the same storage duration as `str`\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;string\u0026gt;\n\nstd::string bar() {\n  std::string str \u003d \"This will change\";\n  return str; // Compliant: `str` will be moved to the caller (using C++ move semantics)\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;array\u0026gt;\n#include \u0026lt;cstddef\u0026gt;\n\nint *buz() {\n  int buf[256];\n  for (size_t i \u003d 0; i \u0026lt; std::size(buf); ++i) {\n    buf[i] \u003d i;\n  }\n  return buf; // Noncompliant: returns address of stack-allocated object\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;array\u0026gt;\n#include \u0026lt;cstddef\u0026gt;\n#include \u0026lt;numeric\u0026gt;\n\nvoid buz(int *buf, size_t length) {\n  std::iota(\u0026amp;buf[0], \u0026amp;buf[length], 0);\n}\n\nvoid caller() {\n  int buf[256];\n  buz(buf, std::size(buf));\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;array\u0026gt;\n\nstd::array\u0026lt;int, 3\u0026gt; buz() {\n  std::array\u0026lt;int, 3\u0026gt; buf \u003d {1, 2, 3};\n  return buf; // Compliant: `buf` will by copied to the caller; return-value optimization (RVO) might be invoked\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;numeric\u0026gt;\n#include \u0026lt;vector\u0026gt;\n\nstd::vector\u0026lt;int\u0026gt; buz() {\n  std::vector\u0026lt;int\u0026gt; buf;\n  std::iota(buf.begin(), buf.end(), 0);\n  return buf; // Compliant: `buf` will be moved to the caller (using C++ move semantics)\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"4\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;algorithm\u0026gt;\n#include \u0026lt;array\u0026gt;\n\nvoid fun(char **out) {\n  char buffer[64];\n  std::fill(std::begin(buffer), std::end(buffer), 42);\n  *out \u003d buffer; // Noncompliant: `buffer`\u0027s address becomes invalid once it goes out of scope\n}\n\nvoid caller() {\n  char *p;\n  fun(\u0026amp;p);\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"4\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;algorithm\u0026gt;\n#include \u0026lt;array\u0026gt;\n\nchar buffer[64];\n\nvoid fun(char **out) {\n  std::fill(std::begin(buffer), std::end(buffer), 42);\n  *out \u003d buffer; // Compliant: `buffer`\u0027s lifetime is the program\u0027s lifetime\n}\n\nvoid caller() {\n  char *p;\n  fun(\u0026amp;p);\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"4\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;vector\u0026gt;\n\nstd::vector\u0026lt;int\u0026gt; fun() {\n  std::vector\u0026lt;int\u0026gt; buf(/* count */ 64, /* initial value */ 42);\n  return buf;\n}\n\nvoid caller() {\n  auto buf \u003d fun();\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eConference presentations\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CppCon 2018 - \u003ca href\u003d\"https://www.youtube.com/watch?v\u003duQyT-5iWUow\u0026amp;ab_channel\u003dCppCon\"\u003eSurprises in Object Lifetime\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/UtcxBQ\"\u003eDCL30-C. Declare objects with appropriate storage durations\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/OXw-BQ\"\u003eEXP54-CPP. Do not access an object outside of its lifetime\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/6NUxBQ\"\u003eMSC00-C. Compile cleanly at high warning levels\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e MISRA C:2004, 17.6 - The address of an object with automatic storage shall not be assigned to another object that may persist after the first\n  object has ceased to exist \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 7-5-2 - The address of an object with automatic storage shall not be assigned to another object that may persist after the\n  first object has ceased to exist \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 18.6 - The address of an object with automatic storage shall not be copied to another object that persists after the first object\n  has ceased to exist \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e S837 detects attempts to return addresses of automatic variables \u003c/li\u003e\n  \u003cli\u003e S839 ensures that functions do not return references or pointers to parameters that are passed by reference \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "based-on-misra",
      "cert",
      "symbolic-execution"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S1854",
    "name": "Unused assignments should be removed",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003cp\u003eUnused assignments should be removed.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eComputing or retrieving a value only to then immediately overwrite it or throw it away indicates a serious logic error in the code.\u003c/p\u003e\n\u003cp\u003eAssigning a value to a local variable that is not read by any subsequent instruction is called a \u003cem\u003edead store\u003c/em\u003e. The following code snippet\ndepicts a few dead stores.\u003c/p\u003e\n\u003cpre\u003e\nint foo() {\n  int x \u003d 0; // Noncompliant: dead store, next line overwrites x\n  x \u003d 100; // Noncompliant: dead store, next line overwrites x\n  x \u003d 200;\n  int y \u003d 0;\n  y +\u003d 9001; // Noncompliant: dead store, y is never used\n  int z \u003d 300; // Noncompliant: dead store, next line overwrites z\n  z \u003d 400;\n  return x + z * 2;\n}\n\u003c/pre\u003e\n\u003cp\u003eEven if the unnecessary operations do not do any harm in terms of the program’s correctness, they are—​at best—​a waste of computing resources. In\nmost cases, these operations have their intended use but it is not expressed correctly in the code. Therefore, unused values and superfluous code\nshould be removed to prevent logic errors.\u003c/p\u003e\n\u003ch2\u003eWhat is the potential impact?\u003c/h2\u003e\n\u003cp\u003eNot only do unused values and superfluous code make the program unnecessary complex, but also indicate significant logic errors. And even in the\nabsence of logic errors, they waste computing resources in case the compiler is not able to optimize them away.\u003c/p\u003e\n\u003cp\u003eUnused values typically showcase a discrepancy between what a developer intended and what is specified in the code and should be removed to uncover\nand eventually prevent logic errors.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eRemove unused values and superfluous code.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nint foo(int y) {\n  int x \u003d 0;\n  x \u003d 100; // Noncompliant: dead store\n  x \u003d 200;\n  return x + y;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nint foo(int y) {\n  int x \u003d 200; // Compliant: no unnecessary assignment\n  return x + y;\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\nint bar();\nint buz();\n\nint foo(bool b) {\n  int x \u003d 0;\n  if (b) {\n    x \u003d bar();\n    return x;\n  }\n  if (x !\u003d 0) {\n    int y \u003d buz();\n    y +\u003d 9001; // Noncompliant: dead store\n  }\n  return x;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\nint bar();\nint buz();\n\nint foo(bool b) {\n  int x \u003d 0;\n  if (b) {\n    x \u003d bar();\n    return x;\n  }\n  // Compliant: no more dead stores and superfluous code\n  // Assuming call to buz() had no important side effects\n  return x;\n}\n\u003c/pre\u003e\n\u003ch3\u003ePitfalls\u003c/h3\u003e\n\u003cp\u003eWhen removing unused values and superfluous code, make sure that the right-hand side of a given assignment has no side effects.\u003c/p\u003e\n\u003cp\u003eWhile it is safe to remove the call to \u003ccode\u003esquare\u003c/code\u003e in the following code since it has no side effects, removing the call to\n\u003ccode\u003efwrite\u003c/code\u003e changes the program’s behavior. Still, values that are never read such as \u003ccode\u003en\u003c/code\u003e indicate code smells that should be\nmitigated. In this code example, the return value of \u003ccode\u003efwrite\u003c/code\u003e should be checked and any potential error should be handled\nappropriately.\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;string.h\u0026gt;\n\nint square(int n) {\n  return n * n;\n}\n\nint foo(int i) {\n  int sq \u003d square(i); // Noncompliant: dead store, assignment can be removed\n  const char* const str \u003d \"Hello, World!\\n\";\n  // Although `n` is never read, the call to `fwrite` cannot be removed due to side effects\n  size_t n \u003d fwrite(str, sizeof(char), strlen(str), stdout); // Noncompliant: `n` is never read\n  return i + 9001;\n}\n\u003c/pre\u003e\n\u003ch3\u003eGoing the extra mile\u003c/h3\u003e\n\u003cp\u003eIn C++17, the \u003ccode\u003enodiscard\u003c/code\u003e attribute has been introduced which can be used to annotate functions, enumerations and classes.\u003c/p\u003e\n\u003cp\u003eThe attribute serves as a hint to the compiler and to other developers that a function’s return value should not be ignored. A function that is\nmarked \u003ccode\u003enodiscard\u003c/code\u003e whose return value is ignored encourages the compiler to issue a warning. Example usages of the \u003ccode\u003enodiscard\u003c/code\u003e\nattribute are shown in the following:\u003c/p\u003e\n\u003cpre\u003e\n[[nodiscard]] int foo() { return 100; }\nint bar() { return 200; }\n[[nodiscard(\"An explanation on why not to discard the return value\")]] int buz() { return 300; }\n\nenum class [[nodiscard]] important_error_info { OK, WARN, CRITICAL };\nimportant_error_info compute() {\n  // More code ...\n  // In case of a critical error, return corresponding error info:\n  return important_error_info::CRITICAL;\n}\n\nvoid caller() {\n  foo(); // compiler warns on discarding a nodiscard value\n  bar(); // compiler will issue no warning\n  buz(); // compiler warns on discarding a nodiscard value\n  compute(); // compiler warns on discarding a nodiscard value\n}\n\u003c/pre\u003e\n\u003cp\u003eIn case, the return value of a function marked as \u003ccode\u003enodiscard\u003c/code\u003e should be (exceptionally) ignored, a cast to \u003ccode\u003evoid\u003c/code\u003e can be used\nto silence the compiler warning as shown in the following:\u003c/p\u003e\n\u003cpre\u003e\n[[nodiscard]] int foo() { return 100; }\n\nvoid caller() {\n  foo(); // compiler warns on discarding a nodiscard value\n  (void)foo(); // compiler will issue no warning\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/39UxBQ\"\u003eMSC13-C. Detect and remove unused values\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/563\"\u003e563 - Assignment to Variable without Use (\u0027Unused Variable\u0027)\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:c:S1763} - All code should be reachable \u003c/li\u003e\n  \u003cli\u003e {rule:c:S2583} - Conditionally executed code should be reachable \u003c/li\u003e\n  \u003cli\u003e {rule:c:S2589} - Boolean expressions should not be gratuitous \u003c/li\u003e\n  \u003cli\u003e {rule:c:S3516} - Methods returns should not be invariant \u003c/li\u003e\n  \u003cli\u003e {rule:c:S3626} - Jump statements should not be redundant \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eUnused assignments should be removed.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eComputing or retrieving a value only to then immediately overwrite it or throw it away indicates a serious logic error in the code.\u003c/p\u003e\n\u003cp\u003eAssigning a value to a local variable that is not read by any subsequent instruction is called a \u003cem\u003edead store\u003c/em\u003e. The following code snippet\ndepicts a few dead stores.\u003c/p\u003e\n\u003cpre\u003e\nint foo() {\n  int x \u003d 0; // Noncompliant: dead store, next line overwrites x\n  x \u003d 100; // Noncompliant: dead store, next line overwrites x\n  x \u003d 200;\n  int y \u003d 0;\n  y +\u003d 9001; // Noncompliant: dead store, y is never used\n  int z \u003d 300; // Noncompliant: dead store, next line overwrites z\n  z \u003d 400;\n  return x + z * 2;\n}\n\u003c/pre\u003e\n\u003cp\u003eEven if the unnecessary operations do not do any harm in terms of the program’s correctness, they are—​at best—​a waste of computing resources. In\nmost cases, these operations have their intended use but it is not expressed correctly in the code. Therefore, unused values and superfluous code\nshould be removed to prevent logic errors.\u003c/p\u003e\n\u003ch2\u003eWhat is the potential impact?\u003c/h2\u003e\n\u003cp\u003eNot only do unused values and superfluous code make the program unnecessary complex, but also indicate significant logic errors. And even in the\nabsence of logic errors, they waste computing resources in case the compiler is not able to optimize them away.\u003c/p\u003e\n\u003cp\u003eUnused values typically showcase a discrepancy between what a developer intended and what is specified in the code and should be removed to uncover\nand eventually prevent logic errors.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eRemove unused values and superfluous code.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nint foo(int y) {\n  int x \u003d 0;\n  x \u003d 100; // Noncompliant: dead store\n  x \u003d 200;\n  return x + y;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nint foo(int y) {\n  int x \u003d 200; // Compliant: no unnecessary assignment\n  return x + y;\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\nint bar();\nint buz();\n\nint foo(bool b) {\n  int x \u003d 0;\n  if (b) {\n    x \u003d bar();\n    return x;\n  }\n  if (x !\u003d 0) {\n    int y \u003d buz();\n    y +\u003d 9001; // Noncompliant: dead store\n  }\n  return x;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\nint bar();\nint buz();\n\nint foo(bool b) {\n  int x \u003d 0;\n  if (b) {\n    x \u003d bar();\n    return x;\n  }\n  // Compliant: no more dead stores and superfluous code\n  // Assuming call to buz() had no important side effects\n  return x;\n}\n\u003c/pre\u003e\n\u003ch3\u003ePitfalls\u003c/h3\u003e\n\u003cp\u003eWhen removing unused values and superfluous code, make sure that the right-hand side of a given assignment has no side effects.\u003c/p\u003e\n\u003cp\u003eWhile it is safe to remove the call to \u003ccode\u003esquare\u003c/code\u003e in the following code since it has no side effects, removing the call to\n\u003ccode\u003efwrite\u003c/code\u003e changes the program’s behavior. Still, values that are never read such as \u003ccode\u003en\u003c/code\u003e indicate code smells that should be\nmitigated. In this code example, the return value of \u003ccode\u003efwrite\u003c/code\u003e should be checked and any potential error should be handled\nappropriately.\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;string.h\u0026gt;\n\nint square(int n) {\n  return n * n;\n}\n\nint foo(int i) {\n  int sq \u003d square(i); // Noncompliant: dead store, assignment can be removed\n  const char* const str \u003d \"Hello, World!\\n\";\n  // Although `n` is never read, the call to `fwrite` cannot be removed due to side effects\n  size_t n \u003d fwrite(str, sizeof(char), strlen(str), stdout); // Noncompliant: `n` is never read\n  return i + 9001;\n}\n\u003c/pre\u003e\n\u003ch3\u003eGoing the extra mile\u003c/h3\u003e\n\u003cp\u003eIn C++17, the \u003ccode\u003enodiscard\u003c/code\u003e attribute has been introduced which can be used to annotate functions, enumerations and classes.\u003c/p\u003e\n\u003cp\u003eThe attribute serves as a hint to the compiler and to other developers that a function’s return value should not be ignored. A function that is\nmarked \u003ccode\u003enodiscard\u003c/code\u003e whose return value is ignored encourages the compiler to issue a warning. Example usages of the \u003ccode\u003enodiscard\u003c/code\u003e\nattribute are shown in the following:\u003c/p\u003e\n\u003cpre\u003e\n[[nodiscard]] int foo() { return 100; }\nint bar() { return 200; }\n[[nodiscard(\"An explanation on why not to discard the return value\")]] int buz() { return 300; }\n\nenum class [[nodiscard]] important_error_info { OK, WARN, CRITICAL };\nimportant_error_info compute() {\n  // More code ...\n  // In case of a critical error, return corresponding error info:\n  return important_error_info::CRITICAL;\n}\n\nvoid caller() {\n  foo(); // compiler warns on discarding a nodiscard value\n  bar(); // compiler will issue no warning\n  buz(); // compiler warns on discarding a nodiscard value\n  compute(); // compiler warns on discarding a nodiscard value\n}\n\u003c/pre\u003e\n\u003cp\u003eIn case, the return value of a function marked as \u003ccode\u003enodiscard\u003c/code\u003e should be (exceptionally) ignored, a cast to \u003ccode\u003evoid\u003c/code\u003e can be used\nto silence the compiler warning as shown in the following:\u003c/p\u003e\n\u003cpre\u003e\n[[nodiscard]] int foo() { return 100; }\n\nvoid caller() {\n  foo(); // compiler warns on discarding a nodiscard value\n  (void)foo(); // compiler will issue no warning\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/39UxBQ\"\u003eMSC13-C. Detect and remove unused values\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/563\"\u003e563 - Assignment to Variable without Use (\u0027Unused Variable\u0027)\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:c:S1763} - All code should be reachable \u003c/li\u003e\n  \u003cli\u003e {rule:c:S2583} - Conditionally executed code should be reachable \u003c/li\u003e\n  \u003cli\u003e {rule:c:S2589} - Boolean expressions should not be gratuitous \u003c/li\u003e\n  \u003cli\u003e {rule:c:S3516} - Methods returns should not be invariant \u003c/li\u003e\n  \u003cli\u003e {rule:c:S3626} - Jump statements should not be redundant \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "cert",
      "cwe",
      "symbolic-execution",
      "unused"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S3231",
    "name": "Forward declarations should not be redundant",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eRedundant forward declarations simply clutter the code, and like any duplications, should be removed.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstruct S {\n  // ...\n};\n// ...\nstruct S;  // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstruct S {\n  // ...\n};\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eRedundant forward declarations simply clutter the code, and like any duplications, should be removed.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstruct S {\n  // ...\n};\n// ...\nstruct S;  // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstruct S {\n  // ...\n};\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "redundant",
      "unused"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S6069",
    "name": "\"sprintf\" should not be used",
    "defaultSeverity": "CRITICAL",
    "type": "SECURITY_HOTSPOT",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "SECURITY": "HIGH"
    },
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhen using \u003ccode\u003esprintf\u003c/code\u003e , it’s up to the developer to make sure the size of the buffer to be written to is large enough to avoid buffer\noverflows. Buffer overflows can cause the program to crash at a minimum. At worst, a carefully crafted overflow can cause malicious code to be\nexecuted.\u003c/p\u003e\n\u003ch2\u003eExceptions\u003c/h2\u003e\n\u003cp\u003eIt is a very common and acceptable pattern to compute the required size of the buffer with a call to \u003ccode\u003esnprintf\u003c/code\u003e with the same arguments\ninto an empty buffer (this will fail, but return the necessary size), then to call \u003ccode\u003esprintf\u003c/code\u003e as the bound check is not needed anymore. Note\nthat 1 needs to be added by the size reported by \u003ccode\u003esnprintf\u003c/code\u003e to account for the terminal null character.\u003c/p\u003e\n\u003cpre\u003e\nsize_t buflen \u003d snprintf(0, 0, \"%s\", message);\nchar* buf \u003d malloc(buflen + 1); // For the final 0\nsprintf(buf, \"%s\", message);{code}\n\u003c/pre\u003e"
      },
      {
        "key": "assess_the_problem",
        "htmlContent": "\u003ch2\u003eAsk Yourself Whether\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e if the provided buffer is large enough for the result of any possible call to the \u003ccode\u003esprintf\u003c/code\u003e function (including all possible format\n  strings and all possible additional arguments). \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere is a risk if you answered no to the above question.\u003c/p\u003e\n\u003ch2\u003eSensitive Code Example\u003c/h2\u003e\n\u003cpre\u003e\nsprintf(str, \"%s\", message);   // Sensitive: `str` buffer size is not checked and it is vulnerable to overflows\n\u003c/pre\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003ch2\u003eRecommended Secure Coding Practices\u003c/h2\u003e\n\u003cp\u003eThere are fundamentally safer alternatives. \u003ccode\u003esnprintf\u003c/code\u003e is one of them. It takes the size of the buffer as an additional argument,\npreventing the function from overflowing the buffer.\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Use \u003ccode\u003esnprintf\u003c/code\u003e instead of \u003ccode\u003esprintf\u003c/code\u003e. The slight performance overhead can be afforded in a vast majority of projects.\n  \u003c/li\u003e\n  \u003cli\u003e Check the buffer size passed to \u003ccode\u003esnprintf\u003c/code\u003e. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIf you are working in C++, other safe alternative exist:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003estd::string\u003c/code\u003e should be the prefered type to store strings \u003c/li\u003e\n  \u003cli\u003e You can format to a string using \u003ccode\u003estd::ostringstream\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e Since C++20, \u003ccode\u003estd::format\u003c/code\u003e is also available to format strings \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eCompliant Solution\u003c/h2\u003e\n\u003cpre\u003e\nsnprintf(str, sizeof(str), \"%s\", message); // Prevent overflows by enforcing a maximum size for `str` buffer\n\u003c/pre\u003e\n\u003ch2\u003eSee\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/Top10/A06_2021-Vulnerable_and_Outdated_Components/\"\u003eOWASP Top 10 2021 Category A6\u003c/a\u003e - Vulnerable and Outdated\n  Components \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/www-project-top-ten/2017/A9_2017-Using_Components_with_Known_Vulnerabilities\"\u003eOWASP Top 10 2017 Category\n  A9\u003c/a\u003e\u0026nbsp;- Using Components with Known Vulnerabilities \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/676\"\u003eMITRE, CWE-676\u003c/a\u003e - Use of Potentially Dangerous Function \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/119\"\u003eMITRE, CWE-119\u003c/a\u003e - Improper Restriction of Operations within the Bounds of a Memory\n  Buffer \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "cert",
      "cwe"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": [],
    "vulnerabilityProbability": "HIGH"
  },
  {
    "key": "c:S5658",
    "name": "Relational and subtraction operators should not be used with pointers to different arrays",
    "defaultSeverity": "CRITICAL",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eAttempting to make a comparison between pointers using \u0026gt;, \u0026gt;\u003d, \u0026lt; or \u0026lt;\u003d will produce undefined behavior if the two pointers point to\ndifferent arrays.\u003c/p\u003e\n\u003cp\u003eAdditionally, directly comparing two arrays for equality or inequality has been deprecated in C++.\u003c/p\u003e\n\u003cp\u003eHowever, equality or inequality between an array and a pointer is still valid\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid f1 ( )\n{\n  int a1[ 10 ];\n  int a2[ 10 ];\n  int * p1 \u003d a1;\n  if ( p1 \u0026lt; a2 ) // Non-compliant, p1 and a2 point to different arrays.\n  {\n  }\n  if ( p1 - a2 \u0026gt; 0 ) // Non-compliant, p1 and a2 point to different arrays.\n  {\n  }\n  if ( a1 \u003d\u003d a2) // Non-compliant (in C++). Comparing different array for equality is deprecated\n  {\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid f1 ( )\n{\n  int a1[ 10 ];\n  int * p1 \u003d a1;\n  if ( p1 \u0026lt; a1 ) // Compliant, p1 and a1 point to the same array.\n  {\n  }\n  if ( p1 - a1 \u0026gt; 0 )  // Compliant, p1 and a1 point to the same array.\n  {\n  }\n  if ( p1 \u003d\u003d a2 ) // Compliant, comparing a pointer and an array for equality is valid\n  {\n  }\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 17.3 - \u0026gt;, \u0026gt;\u003d, \u0026lt;, \u0026lt;\u003d shall not be applied to pointer types except where they point to the same array. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 5-0-18 - \u0026gt;, \u0026gt;\u003d, \u0026lt;, \u0026lt;\u003d shall not be applied to objects of pointer type, except where they point to the same array.\n  \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es62-dont-compare-pointers-into-different-arrays\"\u003eES.62: Don’t\n  compare pointers into different arrays\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eAttempting to make a comparison between pointers using \u0026gt;, \u0026gt;\u003d, \u0026lt; or \u0026lt;\u003d will produce undefined behavior if the two pointers point to\ndifferent arrays.\u003c/p\u003e\n\u003cp\u003eAdditionally, directly comparing two arrays for equality or inequality has been deprecated in C++.\u003c/p\u003e\n\u003cp\u003eHowever, equality or inequality between an array and a pointer is still valid\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid f1 ( )\n{\n  int a1[ 10 ];\n  int a2[ 10 ];\n  int * p1 \u003d a1;\n  if ( p1 \u0026lt; a2 ) // Non-compliant, p1 and a2 point to different arrays.\n  {\n  }\n  if ( p1 - a2 \u0026gt; 0 ) // Non-compliant, p1 and a2 point to different arrays.\n  {\n  }\n  if ( a1 \u003d\u003d a2) // Non-compliant (in C++). Comparing different array for equality is deprecated\n  {\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid f1 ( )\n{\n  int a1[ 10 ];\n  int * p1 \u003d a1;\n  if ( p1 \u0026lt; a1 ) // Compliant, p1 and a1 point to the same array.\n  {\n  }\n  if ( p1 - a1 \u0026gt; 0 )  // Compliant, p1 and a1 point to the same array.\n  {\n  }\n  if ( p1 \u003d\u003d a2 ) // Compliant, comparing a pointer and an array for equality is valid\n  {\n  }\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 17.3 - \u0026gt;, \u0026gt;\u003d, \u0026lt;, \u0026lt;\u003d shall not be applied to pointer types except where they point to the same array. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 5-0-18 - \u0026gt;, \u0026gt;\u003d, \u0026lt;, \u0026lt;\u003d shall not be applied to objects of pointer type, except where they point to the same array.\n  \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es62-dont-compare-pointers-into-different-arrays\"\u003eES.62: Don’t\n  compare pointers into different arrays\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "based-on-misra",
      "cppcoreguidelines"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S3358",
    "name": "Conditional operators should not be nested",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eNested ternaries are hard to read and can make the order of operations complex to understand.\u003c/p\u003e\n\u003cpre\u003e\nint max(int p1, int p2, int p3) {\n  return p1 \u0026gt; p2 ? (p1 \u0026gt; p3 ? p1 : p3) : (p2 \u0026gt; p3 ? p2 : p3); // Noncompliant\n}\n\u003c/pre\u003e\n\u003cp\u003eInstead, use another line to express the nested operation in a separate statement.\u003c/p\u003e\n\u003cpre\u003e\nint max(int p1, int p2, int p3) {\n  if (p1 \u0026gt; p2) {\n    return p1 \u0026gt; p3 ? p1 : p3;\n  } else {\n    return p2 \u0026gt; p3 ? p2 : p3;\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eIn C++11, the rule ignores ternary operators inside \u003ccode\u003econstexpr\u003c/code\u003e functions.\u003c/p\u003e\n\u003cp\u003eIndeed, in C++11, such functions are limited to just a return statement, so using a ternary operator might be required. Later standards lifted this\nrestriction, so this exception does not apply to them.\u003c/p\u003e\n\u003cpre\u003e\nconstexpr int max(int p1, int p2, int p3) {\n  return p1 \u0026gt; p2 ? (p1 \u0026gt; p3 ? p1 : p3) : (p2 \u0026gt; p3 ? p2 : p3); // Compliant by exception in C++11\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eNested ternaries are hard to read and can make the order of operations complex to understand.\u003c/p\u003e\n\u003cpre\u003e\nint max(int p1, int p2, int p3) {\n  return p1 \u0026gt; p2 ? (p1 \u0026gt; p3 ? p1 : p3) : (p2 \u0026gt; p3 ? p2 : p3); // Noncompliant\n}\n\u003c/pre\u003e\n\u003cp\u003eInstead, use another line to express the nested operation in a separate statement.\u003c/p\u003e\n\u003cpre\u003e\nint max(int p1, int p2, int p3) {\n  if (p1 \u0026gt; p2) {\n    return p1 \u0026gt; p3 ? p1 : p3;\n  } else {\n    return p2 \u0026gt; p3 ? p2 : p3;\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eIn C++11, the rule ignores ternary operators inside \u003ccode\u003econstexpr\u003c/code\u003e functions.\u003c/p\u003e\n\u003cp\u003eIndeed, in C++11, such functions are limited to just a return statement, so using a ternary operator might be required. Later standards lifted this\nrestriction, so this exception does not apply to them.\u003c/p\u003e\n\u003cpre\u003e\nconstexpr int max(int p1, int p2, int p3) {\n  return p1 \u0026gt; p2 ? (p1 \u0026gt; p3 ? p1 : p3) : (p2 \u0026gt; p3 ? p2 : p3); // Compliant by exception in C++11\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "confusing"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S856",
    "name": "Pointer conversions should be restricted to a safe subset",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eCasting an object pointer can very easily lead to undefined behavior. Only a few cases are supported, for instance casting an object pointer to a\nlarge enough integral type (and back again), casting an object pointer to a pointer to void (and back again)…​ Using a pointer cast to access an\nobject as if it was of another type than its real type is not supported in general.\u003c/p\u003e\n\u003cp\u003eThis rule detects casts between object pointers and incompatible types.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstruct S1 *p1;\nstruct S2;\nvoid f ()\n{\n  (float) p1; // Noncompliant, conversion to floating point type\n  (int *) p1; // Noncompliant\n  float f;\n  int *i \u003d (int *)\u0026amp;f; // Noncompliant, undefined behavior even if sizeof(int) \u003d\u003d sizeof(float)\n  (int) p1; // Compliant, but might be undefined behavior if \u0027int\u0027 is not large enough to hold the value of p1.\n  (void *) p1; // Compliant, conversion to \u0027void *\u0027\n  (struct S2 *)p1; // Noncompliant, conversion to another type.\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eIn C, it is allowed to cast an object pointer to a character pointer to access the byte representation of the object. This rule ignores this\ncase.\u003c/p\u003e\n\u003cp\u003eAnything can be safely cast to \u003ccode\u003evoid\u003c/code\u003e (since nothing can be done with a result of this cast), and doing so is a common pattern to\nsilence compiler warnings about unused variables. This rule ignores such casts.\u003c/p\u003e\n\u003cpre\u003e\nvoid f(int *p) {\n  (void)p;\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 11.2 - Conversions shall not be performed between a pointer to object and any type other than an integral type, another pointer\n  to object type or a pointer to void. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 11.3 - A cast shall not be performed between a pointer to object type and a pointer to a different object type. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eCasting an object pointer can very easily lead to undefined behavior. Only a few cases are supported, for instance casting an object pointer to a\nlarge enough integral type (and back again), casting an object pointer to a pointer to void (and back again)…​ Using a pointer cast to access an\nobject as if it was of another type than its real type is not supported in general.\u003c/p\u003e\n\u003cp\u003eThis rule detects casts between object pointers and incompatible types.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstruct S1 *p1;\nstruct S2;\nvoid f ()\n{\n  (float) p1; // Noncompliant, conversion to floating point type\n  (int *) p1; // Noncompliant\n  float f;\n  int *i \u003d (int *)\u0026amp;f; // Noncompliant, undefined behavior even if sizeof(int) \u003d\u003d sizeof(float)\n  (int) p1; // Compliant, but might be undefined behavior if \u0027int\u0027 is not large enough to hold the value of p1.\n  (void *) p1; // Compliant, conversion to \u0027void *\u0027\n  (struct S2 *)p1; // Noncompliant, conversion to another type.\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eIn C, it is allowed to cast an object pointer to a character pointer to access the byte representation of the object. This rule ignores this\ncase.\u003c/p\u003e\n\u003cp\u003eAnything can be safely cast to \u003ccode\u003evoid\u003c/code\u003e (since nothing can be done with a result of this cast), and doing so is a common pattern to\nsilence compiler warnings about unused variables. This rule ignores such casts.\u003c/p\u003e\n\u003cpre\u003e\nvoid f(int *p) {\n  (void)p;\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 11.2 - Conversions shall not be performed between a pointer to object and any type other than an integral type, another pointer\n  to object type or a pointer to void. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 11.3 - A cast shall not be performed between a pointer to object type and a pointer to a different object type. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "based-on-misra"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S977",
    "name": "Lines starting with \"#\" should contain valid preprocessing directives",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003ePreprocessing directives (lines that start with \u003ccode\u003e#\u003c/code\u003e) can be used to conditionally include or exclude code from compilation. Malformed\npreprocessing directives could lead to the exclusion or inclusion of more code than was intended. Therefore all preprocessing directives should be\nsyntactically meaningful.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#define AAA 2\n...\nint foo(void)\n{\n  int x \u003d 0;\n  ...\n\n#ifndef AAA\n  x \u003d 1;\n#else1  /* Noncompliant */\n  x \u003d AAA;\n#endif\n\n  ...\n  return x;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#define AAA 2\n...\nint foo(void)\n{\n  int x \u003d 0;\n  ...\n\n#ifndef AAA\n  x \u003d 1;\n#else\n  x \u003d AAA;\n#endif\n\n  ...\n  return x;\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 19.16 - Preprocessing directives shall be syntactically meaningful even when excluded by preprocessor. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 16-0-8 - If the # token appears as the first token on a line, then it shall be immediately followed by a preprocessing token.\n  \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 20.13 - A line whose first token is # shall be a valid preprocessing directive \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003ePreprocessing directives (lines that start with \u003ccode\u003e#\u003c/code\u003e) can be used to conditionally include or exclude code from compilation. Malformed\npreprocessing directives could lead to the exclusion or inclusion of more code than was intended. Therefore all preprocessing directives should be\nsyntactically meaningful.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#define AAA 2\n...\nint foo(void)\n{\n  int x \u003d 0;\n  ...\n\n#ifndef AAA\n  x \u003d 1;\n#else1  /* Noncompliant */\n  x \u003d AAA;\n#endif\n\n  ...\n  return x;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#define AAA 2\n...\nint foo(void)\n{\n  int x \u003d 0;\n  ...\n\n#ifndef AAA\n  x \u003d 1;\n#else\n  x \u003d AAA;\n#endif\n\n  ...\n  return x;\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 19.16 - Preprocessing directives shall be syntactically meaningful even when excluded by preprocessor. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 16-0-8 - If the # token appears as the first token on a line, then it shall be immediately followed by a preprocessing token.\n  \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 20.13 - A line whose first token is # shall be a valid preprocessing directive \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "based-on-misra",
      "preprocessor"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S5283",
    "name": "Size of variable length arrays should be greater than zero",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003cp\u003eCreating a Variable Length Array (VLA) with a size that is not greater than zero leads to undefined behavior.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eVariable length arrays are used to allocate a stack size for the number of elements that are known at the runtime, for example:\u003c/p\u003e\n\u003cpre\u003e\nvoid merge(int* tab, int size, int first) {\n  int res[size]; // allocate buffer for merging on stack\n  /* Code that merges two sorted ranges [tab, tab + first) and [tab + first, tab + last)\n   * into res buffer.\n   * ....\n   */\n  // copy merged data into input\n  memcpy(tab, res, size * sizeof(int));\n}\n\u003c/pre\u003e\n\u003cp\u003eThe syntax follows the one used by an array with static size (where size is a constant), and the value placed in the square brackets\n(\u003ccode\u003e[size]\u003c/code\u003e in the above example) determines the size of the array. For both static and runtime-sized arrays, the size is required to be\ngreater than zero. However, in the case of VLAs, this cannot be checked by the compiler, and any program that creates such an array with a size that\nhas a value of zero or is negative, has undefined behavior.\u003c/p\u003e\n\u003cpre\u003e\nvoid example() {\n  int s \u003d -1;\n  int vla[s];  // program compiles, and have undefined behavior\n  int arr[-1]; // program is ill-formed\n}\n\u003c/pre\u003e\n\u003cp\u003eThis defect may also manifest when the variable used as size is not initialized. Uninitialized variables might have zero, negative, or any value at\neach time the program executes.\u003c/p\u003e\n\u003cpre\u003e\nvoid uninitialized() {\n  int s;      // uninitialized, the value is not determined\n  int vla[s]; // program compiles, have undefined behavior if the value read from s is negative or zero\n}\n\u003c/pre\u003e\n\u003cp\u003eA non-positive size of the VLAs may also result from using a value loaded by the program from a file or other external resources used as size\nwithout previous validation. Such values as usually referred to as being \u003cem\u003etainted\u003c/em\u003e.\u003c/p\u003e\n\u003cpre\u003e\nvoid loadFromInput() {\n  int size \u003d -1;\n  scanf(\"%d\", \u0026amp;size); // loads size from input\n  char bytes[size];   // size may be negative\n  /* ... */\n}\n\u003c/pre\u003e\n\u003cp\u003eThe above code will lead to undefined behavior when the value of the \u003ccode\u003esize\u003c/code\u003e load from the input is not greater than zero. This may\nhappen due to source data corruption, accidental user mistake, or malicious action.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eCreating a variable length array with a size smaller or equal to zero leads to undefined behavior. This means the compiler is not bound by the\nlanguage standard anymore, and your program has no meaning assigned to it.\u003c/p\u003e\n\u003cp\u003ePractically this can lead to a wide range of effects and may lead to the following:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e crashes, in particular segmentation faults, when the program access memory that it is not allowed to, \u003c/li\u003e\n  \u003cli\u003e memory corruption and data losses, when the program overwrites bytes responsible for storing data or executable code, \u003c/li\u003e\n  \u003cli\u003e stack overflow, when negative size is interpreted as a large positive number. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eFurthermore, in a situation when VLA size is dependent on the user input, it can lead to vulnerabilities in the program.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eEnsure that the size of the variable length array is always greater than zero. In case of value that depends on user input (is \u003cem\u003etainted\u003c/em\u003e),\nprefer to allocate the memory on heap, or if that is not possible, include appropriate checks to ensure that value is positive and constrained before\nusing it as size for VLA.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cp\u003eZero size VLA is created due of by-one error.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid zeroSize() {\n  for (int i \u003d 0; i \u0026lt;\u003d 5; ++i) {\n    int buffer[5 - i]; // Noncompliant: buffer size is zero for last iteration\n    /* ... */\n  }\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid zeroSize() {\n  for (int i \u003d 0; i \u0026lt; 5; ++i) {\n    int buffer[5 - i]; // Complaint\n    /* ... */\n  }\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cp\u003eSize is not initialized in one of code paths.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\nint countGrapheneClusters(int codeUnits, int bytesInCodeUnit) {\n  int size;\n  if (bytesInCodeUnit \u0026gt; 0) {\n    size \u003d codeUnits * bytesInCodeUnit;\n  }\n  char buffer[size]; // Noncomplaint: size may not be initialized\n  // ....\n  return  0;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\nint countGrapheneClusters(int codeUnits, int bytesInCodeUnit) {\n  int size;\n  if (bytesInCodeUnit \u0026gt; 0) {\n    size \u003d codeUnits * bytesInCodeUnit;\n  } else {\n    return -1;\n  }\n  char buffer[size]; // Complaint: size is always initialized\n  // ....\n  return  0;\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"noncompliant\"\u003e\nint taintedSize() {\n  int size \u003d 0;\n  scanf(\"%d\", \u0026amp;size); // size value is loaded from input, value is tainted here\n  char bytes[size];   // Noncomplaint: size may be negative\n  /* ... */\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eAllocate memory on heap, instead of using variable lenght array.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"compliant\"\u003e\nint taintedSize() {\n  int size \u003d 0;\n  scanf(\"%d\", \u0026amp;size);\n  if (size \u0026lt;\u003d 0 || size \u0026gt; 1000) {\n    return -1;\n  }\n\n  char* bytes \u003d (char*)malloc(size); // Complaint: uses heap allocation\n  /* ... */\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch2\u003eGoing the extra mile\u003c/h2\u003e\n\u003cp\u003eVariable length arrays are allocated on the stack, so in situations when a large value of the size is used, creating such an array may lead to\nstack overflow and undefined behavior:\u003c/p\u003e\n\u003cpre\u003e\nvoid largeVLA() {\n  int s \u003d INT_MAX;\n  int vla[s][100]; // requires allocation of the INT_MAX * 100\n}\n\u003c/pre\u003e\n\u003cp\u003eIn addition, the language does not provide a way to query available stack space, nor the possibility of reporting failure in the creation of such\nan array.\u003c/p\u003e\n\u003cp\u003eWhen applicable, it is recommended to replace the VLA with heap-allocated memory. In contrast to VLA, heap allocation functions report in a\nsituation when sufficient memory cannot be provided, by returning \u003ccode\u003eNULL\u003c/code\u003e or throwing an exception (in C++). Furthermore, the C++ standard\nlibrary provides containers like \u003ccode\u003estd::vector\u003c/code\u003e, that manage the heap-allocated memory.\u003c/p\u003e\n\u003cp\u003eMoreover, the C11 language standard and above only optionally supports VLAs (with \u003ccode\u003e__STDC_NO_VLA__\u003c/code\u003e), and the C++ standard never\nsupported it, however, they are commonly accepted as extensions.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/c/language/array#Variable-length_arrays\"\u003eVariable-length arrays\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/container/vector\"\u003e\u003ccode\u003estd::vector\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca\n  href\u003d\"https://wiki.sei.cmu.edu/confluence/display/c/ARR32-C.+Ensure+size+arguments+for+variable+length+arrays+are+in+a+valid+range\"\u003eARR32-C. Ensure\n  size arguments for variable length arrays are in a valid range\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eCreating a Variable Length Array (VLA) with a size that is not greater than zero leads to undefined behavior.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eVariable length arrays are used to allocate a stack size for the number of elements that are known at the runtime, for example:\u003c/p\u003e\n\u003cpre\u003e\nvoid merge(int* tab, int size, int first) {\n  int res[size]; // allocate buffer for merging on stack\n  /* Code that merges two sorted ranges [tab, tab + first) and [tab + first, tab + last)\n   * into res buffer.\n   * ....\n   */\n  // copy merged data into input\n  memcpy(tab, res, size * sizeof(int));\n}\n\u003c/pre\u003e\n\u003cp\u003eThe syntax follows the one used by an array with static size (where size is a constant), and the value placed in the square brackets\n(\u003ccode\u003e[size]\u003c/code\u003e in the above example) determines the size of the array. For both static and runtime-sized arrays, the size is required to be\ngreater than zero. However, in the case of VLAs, this cannot be checked by the compiler, and any program that creates such an array with a size that\nhas a value of zero or is negative, has undefined behavior.\u003c/p\u003e\n\u003cpre\u003e\nvoid example() {\n  int s \u003d -1;\n  int vla[s];  // program compiles, and have undefined behavior\n  int arr[-1]; // program is ill-formed\n}\n\u003c/pre\u003e\n\u003cp\u003eThis defect may also manifest when the variable used as size is not initialized. Uninitialized variables might have zero, negative, or any value at\neach time the program executes.\u003c/p\u003e\n\u003cpre\u003e\nvoid uninitialized() {\n  int s;      // uninitialized, the value is not determined\n  int vla[s]; // program compiles, have undefined behavior if the value read from s is negative or zero\n}\n\u003c/pre\u003e\n\u003cp\u003eA non-positive size of the VLAs may also result from using a value loaded by the program from a file or other external resources used as size\nwithout previous validation. Such values as usually referred to as being \u003cem\u003etainted\u003c/em\u003e.\u003c/p\u003e\n\u003cpre\u003e\nvoid loadFromInput() {\n  int size \u003d -1;\n  scanf(\"%d\", \u0026amp;size); // loads size from input\n  char bytes[size];   // size may be negative\n  /* ... */\n}\n\u003c/pre\u003e\n\u003cp\u003eThe above code will lead to undefined behavior when the value of the \u003ccode\u003esize\u003c/code\u003e load from the input is not greater than zero. This may\nhappen due to source data corruption, accidental user mistake, or malicious action.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eCreating a variable length array with a size smaller or equal to zero leads to undefined behavior. This means the compiler is not bound by the\nlanguage standard anymore, and your program has no meaning assigned to it.\u003c/p\u003e\n\u003cp\u003ePractically this can lead to a wide range of effects and may lead to the following:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e crashes, in particular segmentation faults, when the program access memory that it is not allowed to, \u003c/li\u003e\n  \u003cli\u003e memory corruption and data losses, when the program overwrites bytes responsible for storing data or executable code, \u003c/li\u003e\n  \u003cli\u003e stack overflow, when negative size is interpreted as a large positive number. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eFurthermore, in a situation when VLA size is dependent on the user input, it can lead to vulnerabilities in the program.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eEnsure that the size of the variable length array is always greater than zero. In case of value that depends on user input (is \u003cem\u003etainted\u003c/em\u003e),\nprefer to allocate the memory on heap, or if that is not possible, include appropriate checks to ensure that value is positive and constrained before\nusing it as size for VLA.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cp\u003eZero size VLA is created due of by-one error.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid zeroSize() {\n  for (int i \u003d 0; i \u0026lt;\u003d 5; ++i) {\n    int buffer[5 - i]; // Noncompliant: buffer size is zero for last iteration\n    /* ... */\n  }\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid zeroSize() {\n  for (int i \u003d 0; i \u0026lt; 5; ++i) {\n    int buffer[5 - i]; // Complaint\n    /* ... */\n  }\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cp\u003eSize is not initialized in one of code paths.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\nint countGrapheneClusters(int codeUnits, int bytesInCodeUnit) {\n  int size;\n  if (bytesInCodeUnit \u0026gt; 0) {\n    size \u003d codeUnits * bytesInCodeUnit;\n  }\n  char buffer[size]; // Noncomplaint: size may not be initialized\n  // ....\n  return  0;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\nint countGrapheneClusters(int codeUnits, int bytesInCodeUnit) {\n  int size;\n  if (bytesInCodeUnit \u0026gt; 0) {\n    size \u003d codeUnits * bytesInCodeUnit;\n  } else {\n    return -1;\n  }\n  char buffer[size]; // Complaint: size is always initialized\n  // ....\n  return  0;\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"noncompliant\"\u003e\nint taintedSize() {\n  int size \u003d 0;\n  scanf(\"%d\", \u0026amp;size); // size value is loaded from input, value is tainted here\n  char bytes[size];   // Noncomplaint: size may be negative\n  /* ... */\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eAllocate memory on heap, instead of using variable lenght array.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"compliant\"\u003e\nint taintedSize() {\n  int size \u003d 0;\n  scanf(\"%d\", \u0026amp;size);\n  if (size \u0026lt;\u003d 0 || size \u0026gt; 1000) {\n    return -1;\n  }\n\n  char* bytes \u003d (char*)malloc(size); // Complaint: uses heap allocation\n  /* ... */\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch2\u003eGoing the extra mile\u003c/h2\u003e\n\u003cp\u003eVariable length arrays are allocated on the stack, so in situations when a large value of the size is used, creating such an array may lead to\nstack overflow and undefined behavior:\u003c/p\u003e\n\u003cpre\u003e\nvoid largeVLA() {\n  int s \u003d INT_MAX;\n  int vla[s][100]; // requires allocation of the INT_MAX * 100\n}\n\u003c/pre\u003e\n\u003cp\u003eIn addition, the language does not provide a way to query available stack space, nor the possibility of reporting failure in the creation of such\nan array.\u003c/p\u003e\n\u003cp\u003eWhen applicable, it is recommended to replace the VLA with heap-allocated memory. In contrast to VLA, heap allocation functions report in a\nsituation when sufficient memory cannot be provided, by returning \u003ccode\u003eNULL\u003c/code\u003e or throwing an exception (in C++). Furthermore, the C++ standard\nlibrary provides containers like \u003ccode\u003estd::vector\u003c/code\u003e, that manage the heap-allocated memory.\u003c/p\u003e\n\u003cp\u003eMoreover, the C11 language standard and above only optionally supports VLAs (with \u003ccode\u003e__STDC_NO_VLA__\u003c/code\u003e), and the C++ standard never\nsupported it, however, they are commonly accepted as extensions.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/c/language/array#Variable-length_arrays\"\u003eVariable-length arrays\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/container/vector\"\u003e\u003ccode\u003estd::vector\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca\n  href\u003d\"https://wiki.sei.cmu.edu/confluence/display/c/ARR32-C.+Ensure+size+arguments+for+variable+length+arrays+are+in+a+valid+range\"\u003eARR32-C. Ensure\n  size arguments for variable length arrays are in a valid range\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "suspicious",
      "symbolic-execution"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S978",
    "name": "Reserved identifiers and functions in the C standard library should not be defined or declared",
    "defaultSeverity": "BLOCKER",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eDefining or declaring identifiers with reserved names may lead to undefined behavior. Similarly, defining macros, variables or functions/methods\nwith the same names as functions from the C standard library is likely to lead to unexpected results.\u003c/p\u003e\n\u003cp\u003eAdditionally, such identifiers have the potential to thoroughly confuse people who are unfamiliar with the code base, possibly leading them to\nintroduce additional errors. Therefore reserved words and the names of C standard library functions should not be used as identifiers.\u003c/p\u003e\n\u003cp\u003eThis rule applies to:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003edefined\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e C standard library function names \u003c/li\u003e\n  \u003cli\u003e identifiers that contain two consecutive underscores \u003c/li\u003e\n  \u003cli\u003e identifiers that begin with an underscore, followed by an uppercase letter \u003c/li\u003e\n  \u003cli\u003e identifiers in the global namespace that start with an underscore \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#ifndef _MY_FILE\n#define _MY_FILE   // Noncompliant: starts with \u0027_\u0027\n\n#define FIELD__VAL(field) ##field // Noncompliant: contains \"__\"\n\nint free(void *pArg, int len) {  // Noncompliant: free is a standard function\n  int __i; // Noncompliant: starts with \"__\"\n  //...\n}\n#endif\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#ifndef MY_FILE\n#define MY_FILE\n\n#define FIELD_VAL(field) ##field\n\nint clean(void *pArg, int len) {\n  int i;\n  //...\n}\n#endif\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 20.1 - Reserved identifiers, macros and functions in the standard library, shall not be defined redefined or undefined. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 17-0-1 - Reserved identifiers, macros and functions in the standard library shall not be defined, redefined, or undefined.\n  \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 21.2 - A reserved identifier or macro name shall not be declared \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/tNYxBQ\"\u003eCERT, DCL37-C.\u003c/a\u003e - Do not declare or define a reserved identifier \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/Q30-BQ\"\u003eCERT, DCL51-CPP.\u003c/a\u003e - Do not declare or define a reserved identifier \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eDefining or declaring identifiers with reserved names may lead to undefined behavior. Similarly, defining macros, variables or functions/methods\nwith the same names as functions from the C standard library is likely to lead to unexpected results.\u003c/p\u003e\n\u003cp\u003eAdditionally, such identifiers have the potential to thoroughly confuse people who are unfamiliar with the code base, possibly leading them to\nintroduce additional errors. Therefore reserved words and the names of C standard library functions should not be used as identifiers.\u003c/p\u003e\n\u003cp\u003eThis rule applies to:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003edefined\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e C standard library function names \u003c/li\u003e\n  \u003cli\u003e identifiers that contain two consecutive underscores \u003c/li\u003e\n  \u003cli\u003e identifiers that begin with an underscore, followed by an uppercase letter \u003c/li\u003e\n  \u003cli\u003e identifiers in the global namespace that start with an underscore \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#ifndef _MY_FILE\n#define _MY_FILE   // Noncompliant: starts with \u0027_\u0027\n\n#define FIELD__VAL(field) ##field // Noncompliant: contains \"__\"\n\nint free(void *pArg, int len) {  // Noncompliant: free is a standard function\n  int __i; // Noncompliant: starts with \"__\"\n  //...\n}\n#endif\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#ifndef MY_FILE\n#define MY_FILE\n\n#define FIELD_VAL(field) ##field\n\nint clean(void *pArg, int len) {\n  int i;\n  //...\n}\n#endif\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 20.1 - Reserved identifiers, macros and functions in the standard library, shall not be defined redefined or undefined. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 17-0-1 - Reserved identifiers, macros and functions in the standard library shall not be defined, redefined, or undefined.\n  \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 21.2 - A reserved identifier or macro name shall not be declared \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/tNYxBQ\"\u003eCERT, DCL37-C.\u003c/a\u003e - Do not declare or define a reserved identifier \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/Q30-BQ\"\u003eCERT, DCL51-CPP.\u003c/a\u003e - Do not declare or define a reserved identifier \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "bad-practice",
      "based-on-misra",
      "cert"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S5280",
    "name": "\"mktemp\" family of functions templates should have at least six trailing \"X\"s",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003cp\u003eThe \u003ccode\u003etemplate\u003c/code\u003e parameter for creating temporary files or directories must contain at least six trailing \"X\"s to ensure uniqueness.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe standard C library provides several functions to create temporary files and directories. These functions include \u003ccode\u003emktemp\u003c/code\u003e,\n\u003ccode\u003emkstemp\u003c/code\u003e, \u003ccode\u003emkstemps\u003c/code\u003e and \u003ccode\u003emkdtemp\u003c/code\u003e, and they accept as a parameter a \u003ccode\u003etemplate\u003c/code\u003e that defines the path\nwhere the file (or directory) should be created. The filename part of the \u003ccode\u003etemplate\u003c/code\u003e must contain at least six trailing \"X\"s to ensure the\nuniqueness of the filename, since these \"X\"\u0027s are replaced with a string that makes the filename unique.\u003c/p\u003e\n\u003cp\u003eNote that the \u003ccode\u003etemplate\u003c/code\u003e parameter will be modified and therefore, it may not be a string constant, but should be declared as a\ncharacter array, instead.\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n\nint create_tmp_file() {\n  char tmp_name[] \u003d \"example_XXXXX\"; // `template` parameter only contains five \"X\"s\n  printf(\"raw template: %s\\n\", tmp_name);\n  int fd \u003d mkstemp(tmp_name); // Noncompliant: `mkstemp` will fail due to an invalid template parameter.\n  if (fd \u003d\u003d -1) {\n    perror(\"mkstemp failed\");\n    return 1;\n  }\n  printf(\"unique name: %s\\n\", tmp_name);\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch2\u003eWhat is the potential impact?\u003c/h2\u003e\n\u003cp\u003eIf the last six characters of the \u003ccode\u003etemplate\u003c/code\u003e parameter are different from \"XXXXXX\", \u003ccode\u003emktemp\u003c/code\u003e, \u003ccode\u003emkstemp\u003c/code\u003e,\n\u003ccode\u003emkstemps\u003c/code\u003e and \u003ccode\u003emkdtemp\u003c/code\u003e will fail to create the desired unique temporary file or directory.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eEnsure that the \u003ccode\u003etemplate\u003c/code\u003e parameter ends on at least six \"X\"\u0027s, i.e., \"XXXXXX\".\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n\nint create_tmp_file() {\n  char tmp_name[] \u003d \"/tmp/example_XXXXX\";\n  int fd \u003d mkstemp(tmp_name); // Noncompliant: `mkstemp` will fail due to an invalid template parameter.\n  if (fd \u003d\u003d -1) {\n    perror(\"mkstemp failed\");\n    return 1;\n  }\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n\nint create_tmp_file() {\n  char tmp_name[] \u003d \"/tmp/example_XXXXXX\";\n  int fd \u003d mkstemp(tmp_name); // Compliant: template parameter ends on six \"X\"s.\n  if (fd \u003d\u003d -1) {\n    perror(\"mkstemp failed\");\n    return 1;\n  }\n  printf(\"unique name: %s\\n\", tmp_name); // May print \"/tmp/example_hNjl9G\"\n  return 0;\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eThe \u003ccode\u003etemplate\u003c/code\u003e parameter for creating temporary files or directories must contain at least six trailing \"X\"s to ensure uniqueness.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe standard C library provides several functions to create temporary files and directories. These functions include \u003ccode\u003emktemp\u003c/code\u003e,\n\u003ccode\u003emkstemp\u003c/code\u003e, \u003ccode\u003emkstemps\u003c/code\u003e and \u003ccode\u003emkdtemp\u003c/code\u003e, and they accept as a parameter a \u003ccode\u003etemplate\u003c/code\u003e that defines the path\nwhere the file (or directory) should be created. The filename part of the \u003ccode\u003etemplate\u003c/code\u003e must contain at least six trailing \"X\"s to ensure the\nuniqueness of the filename, since these \"X\"\u0027s are replaced with a string that makes the filename unique.\u003c/p\u003e\n\u003cp\u003eNote that the \u003ccode\u003etemplate\u003c/code\u003e parameter will be modified and therefore, it may not be a string constant, but should be declared as a\ncharacter array, instead.\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n\nint create_tmp_file() {\n  char tmp_name[] \u003d \"example_XXXXX\"; // `template` parameter only contains five \"X\"s\n  printf(\"raw template: %s\\n\", tmp_name);\n  int fd \u003d mkstemp(tmp_name); // Noncompliant: `mkstemp` will fail due to an invalid template parameter.\n  if (fd \u003d\u003d -1) {\n    perror(\"mkstemp failed\");\n    return 1;\n  }\n  printf(\"unique name: %s\\n\", tmp_name);\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch2\u003eWhat is the potential impact?\u003c/h2\u003e\n\u003cp\u003eIf the last six characters of the \u003ccode\u003etemplate\u003c/code\u003e parameter are different from \"XXXXXX\", \u003ccode\u003emktemp\u003c/code\u003e, \u003ccode\u003emkstemp\u003c/code\u003e,\n\u003ccode\u003emkstemps\u003c/code\u003e and \u003ccode\u003emkdtemp\u003c/code\u003e will fail to create the desired unique temporary file or directory.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eEnsure that the \u003ccode\u003etemplate\u003c/code\u003e parameter ends on at least six \"X\"\u0027s, i.e., \"XXXXXX\".\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n\nint create_tmp_file() {\n  char tmp_name[] \u003d \"/tmp/example_XXXXX\";\n  int fd \u003d mkstemp(tmp_name); // Noncompliant: `mkstemp` will fail due to an invalid template parameter.\n  if (fd \u003d\u003d -1) {\n    perror(\"mkstemp failed\");\n    return 1;\n  }\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n\nint create_tmp_file() {\n  char tmp_name[] \u003d \"/tmp/example_XXXXXX\";\n  int fd \u003d mkstemp(tmp_name); // Compliant: template parameter ends on six \"X\"s.\n  if (fd \u003d\u003d -1) {\n    perror(\"mkstemp failed\");\n    return 1;\n  }\n  printf(\"unique name: %s\\n\", tmp_name); // May print \"/tmp/example_hNjl9G\"\n  return 0;\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "suspicious",
      "symbolic-execution"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S854",
    "name": "Constants of unsigned type should have a \"U\" suffix",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe type of an integer is dependent on a complex combination of factors including:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The magnitude of the constant; \u003c/li\u003e\n  \u003cli\u003e The implemented sizes of the integer types; \u003c/li\u003e\n  \u003cli\u003e The presence of any suffixes; \u003c/li\u003e\n  \u003cli\u003e The number base in which the value is expressed (i.e. decimal, octal or hexadecimal). \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eFor example, the value 0x8000 is of type \u003ccode\u003eunsigned int\u003c/code\u003e in a 16-bit environment, but of type (\u003ccode\u003esigned\u003c/code\u003e) \u003ccode\u003eint\u003c/code\u003e in a\n32-bit environment.\u003c/p\u003e\n\u003cp\u003eNote:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Any value with a \"U\" suffix is of unsigned type; \u003c/li\u003e\n  \u003cli\u003e An unsuffixed decimal value less than 2^31 is of signed type. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eBut:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e An unsuffixed hexadecimal value greater than or equal to 2^15 may be of signed or unsigned type; \u003c/li\u003e\n  \u003cli\u003e For C90, an unsuffixed decimal value greater than or equal to 2^31 may be of signed or unsigned type. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn C++, if an overload set includes candidates for an \u003ccode\u003eunsigned int\u003c/code\u003e and an \u003ccode\u003eint\u003c/code\u003e, then the overload that would be matched by\n0x8000 is therefore dependent on the implemented integer size. Adding a \"U\" suffix to the value specifies that it is unsigned.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 10.6 - A \"U\" suffix shall be applied to all constants of unsigned type. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 2-13-3 - A \"U\" suffix shall be applied to all octal or hexadecimal integer literals of unsigned type. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 7.2 - A \"u\" or \"U\" suffix shall be applied to all integer constants that are represented in an unsigned type. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe type of an integer is dependent on a complex combination of factors including:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The magnitude of the constant; \u003c/li\u003e\n  \u003cli\u003e The implemented sizes of the integer types; \u003c/li\u003e\n  \u003cli\u003e The presence of any suffixes; \u003c/li\u003e\n  \u003cli\u003e The number base in which the value is expressed (i.e. decimal, octal or hexadecimal). \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eFor example, the value 0x8000 is of type \u003ccode\u003eunsigned int\u003c/code\u003e in a 16-bit environment, but of type (\u003ccode\u003esigned\u003c/code\u003e) \u003ccode\u003eint\u003c/code\u003e in a\n32-bit environment.\u003c/p\u003e\n\u003cp\u003eNote:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Any value with a \"U\" suffix is of unsigned type; \u003c/li\u003e\n  \u003cli\u003e An unsuffixed decimal value less than 2^31 is of signed type. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eBut:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e An unsuffixed hexadecimal value greater than or equal to 2^15 may be of signed or unsigned type; \u003c/li\u003e\n  \u003cli\u003e For C90, an unsuffixed decimal value greater than or equal to 2^31 may be of signed or unsigned type. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn C++, if an overload set includes candidates for an \u003ccode\u003eunsigned int\u003c/code\u003e and an \u003ccode\u003eint\u003c/code\u003e, then the overload that would be matched by\n0x8000 is therefore dependent on the implemented integer size. Adding a \"U\" suffix to the value specifies that it is unsigned.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 10.6 - A \"U\" suffix shall be applied to all constants of unsigned type. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 2-13-3 - A \"U\" suffix shall be applied to all octal or hexadecimal integer literals of unsigned type. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 7.2 - A \"u\" or \"U\" suffix shall be applied to all integer constants that are represented in an unsigned type. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "based-on-misra",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S5281",
    "name": "Argument of \"printf\" should be a format string",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eIt is a security vulnerability to call \u003ccode\u003eprintf\u003c/code\u003e with a unique string argument which is not a string literal. Indeed, if this argument\ncomes from a user input, this user can :\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e make the program crash, by executing code equivalent to: \u003ccode\u003eprintf(\"%s%s%s%s%s%s%s%s\")\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e view the stack or a memory at any location, by executing code equivalent to: \u003ccode\u003eprintf(\"%08x %08x %08x %08x %08x\\n\")\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid f(char* userInput) {\n  printf(userInput); // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid f(char* userInput) {\n  printf(\"%s\", userInput); // Compliant\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/www-community/attacks/Format_string_attack\"\u003eOwasp: format string attack\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eIt is a security vulnerability to call \u003ccode\u003eprintf\u003c/code\u003e with a unique string argument which is not a string literal. Indeed, if this argument\ncomes from a user input, this user can :\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e make the program crash, by executing code equivalent to: \u003ccode\u003eprintf(\"%s%s%s%s%s%s%s%s\")\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e view the stack or a memory at any location, by executing code equivalent to: \u003ccode\u003eprintf(\"%08x %08x %08x %08x %08x\\n\")\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid f(char* userInput) {\n  printf(userInput); // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid f(char* userInput) {\n  printf(\"%s\", userInput); // Compliant\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/www-community/attacks/Format_string_attack\"\u003eOwasp: format string attack\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "bad-practice"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S855",
    "name": "Function pointers should not be converted to any other type",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eConversion of a function pointer to a different type of pointer results in undefined behaviour. This means, for example, that a pointer to a\nfunction cannot be converted to a pointer to a different type of function.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint f(int a)\n{\n  float (*p)(float) \u003d (float (*)(float)) \u0026amp; f; // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 11.1 - Conversions shall not be performed between a pointer to a function and any type other than an integral type. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 5-2-6 - A cast shall not convert a pointer to a function to any other pointer type, including a pointer to function type. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 11.1 - Conversions shall not be performed between a pointer to a function and any other type \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eConversion of a function pointer to a different type of pointer results in undefined behaviour. This means, for example, that a pointer to a\nfunction cannot be converted to a pointer to a different type of function.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint f(int a)\n{\n  float (*p)(float) \u003d (float (*)(float)) \u0026amp; f; // Noncompliant\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 11.1 - Conversions shall not be performed between a pointer to a function and any type other than an integral type. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 5-2-6 - A cast shall not convert a pointer to a function to any other pointer type, including a pointer to function type. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 11.1 - Conversions shall not be performed between a pointer to a function and any other type \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "based-on-misra"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S853",
    "name": "Results of ~ and \u003c\u003c operations on operands of underlying types unsigned char and unsigned short should immediately be cast to the operand\u0027s underlying type",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhen \u003ccode\u003e~\u003c/code\u003e and \u003ccode\u003e\u0026lt;\u0026lt;\u003c/code\u003e are applied to small integer types (\u003ccode\u003eunsigned char\u003c/code\u003e or \u003ccode\u003eunsigned short\u003c/code\u003e), the\noperations are preceded by integral promotion, and the result may contain high-order bits which have not been anticipated.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nunsigned char port \u003d 0x5aU;\nunsigned char result_8;\nunsigned short result_16;\nunsigned short mode;\nresult_8 \u003d (~port) \u0026gt;\u0026gt; 4; // Noncompliant; \u0027~port\u0027 is 0xFFA5 on a 16-bit machine but 0xFFFFFFA5 on a 32-bit machine. Result is 0xFA for both, but 0x0A may have been expected.\nresult_16 \u003d ((port \u0026lt;\u0026lt; 4) \u0026amp; mode) \u0026gt;\u0026gt; 6; // Noncompliant; result_16 value depends on the implemented size of an int.\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nresult_8 \u003d ((unsigned char)(~port)) \u0026gt;\u0026gt; 4; // Compliant\nresult_16 \u003d ((unsigned short)((unsigned short) port \u0026lt;\u0026lt; 4) \u0026amp; mode) \u0026gt;\u0026gt; 6; // Compliant\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C 2004, 10.5 - If the bitwise operators ~ and \u0026lt;\u0026lt; are applied to an operand of \u003cem\u003eunderlying type\u003c/em\u003e unsigned char or unsigned\n  short, the result shall be immediately cast to the \u003cem\u003eunderlying type\u003c/em\u003e of the operand. \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2008, 5-0-10 - If the bitwise operators ~ and \u0026lt;\u0026lt; are applied to an operand with an \u003cem\u003eunderlying type\u003c/em\u003e of unsigned char or\n  unsigned short, the result shall be immediately cast to the \u003cem\u003eunderlying type\u003c/em\u003e of the operand. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhen \u003ccode\u003e~\u003c/code\u003e and \u003ccode\u003e\u0026lt;\u0026lt;\u003c/code\u003e are applied to small integer types (\u003ccode\u003eunsigned char\u003c/code\u003e or \u003ccode\u003eunsigned short\u003c/code\u003e), the\noperations are preceded by integral promotion, and the result may contain high-order bits which have not been anticipated.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nunsigned char port \u003d 0x5aU;\nunsigned char result_8;\nunsigned short result_16;\nunsigned short mode;\nresult_8 \u003d (~port) \u0026gt;\u0026gt; 4; // Noncompliant; \u0027~port\u0027 is 0xFFA5 on a 16-bit machine but 0xFFFFFFA5 on a 32-bit machine. Result is 0xFA for both, but 0x0A may have been expected.\nresult_16 \u003d ((port \u0026lt;\u0026lt; 4) \u0026amp; mode) \u0026gt;\u0026gt; 6; // Noncompliant; result_16 value depends on the implemented size of an int.\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nresult_8 \u003d ((unsigned char)(~port)) \u0026gt;\u0026gt; 4; // Compliant\nresult_16 \u003d ((unsigned short)((unsigned short) port \u0026lt;\u0026lt; 4) \u0026amp; mode) \u0026gt;\u0026gt; 6; // Compliant\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C 2004, 10.5 - If the bitwise operators ~ and \u0026lt;\u0026lt; are applied to an operand of \u003cem\u003eunderlying type\u003c/em\u003e unsigned char or unsigned\n  short, the result shall be immediately cast to the \u003cem\u003eunderlying type\u003c/em\u003e of the operand. \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2008, 5-0-10 - If the bitwise operators ~ and \u0026lt;\u0026lt; are applied to an operand with an \u003cem\u003eunderlying type\u003c/em\u003e of unsigned char or\n  unsigned short, the result shall be immediately cast to the \u003cem\u003eunderlying type\u003c/em\u003e of the operand. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "based-on-misra"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S5042",
    "name": "Expanding archive files without controlling resource consumption is security-sensitive",
    "defaultSeverity": "CRITICAL",
    "type": "SECURITY_HOTSPOT",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "SECURITY": "HIGH"
    },
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eSuccessful Zip Bomb attacks occur when an application expands untrusted archive files without controlling the size of the expanded data, which can\nlead to denial of service. A Zip bomb is usually a malicious archive file of a few kilobytes of compressed data but turned into gigabytes of\nuncompressed data. To achieve this extreme \u003ca href\u003d\"https://en.wikipedia.org/wiki/Data_compression_ratio\"\u003ecompression ratio\u003c/a\u003e, attackers will\ncompress irrelevant data (eg: a long string of repeated bytes).\u003c/p\u003e"
      },
      {
        "key": "assess_the_problem",
        "htmlContent": "\u003ch2\u003eAsk Yourself Whether\u003c/h2\u003e\n\u003cp\u003eArchives to expand are untrusted and:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e There is no validation of the number of entries in the archive. \u003c/li\u003e\n  \u003cli\u003e There is no validation of the total size of the uncompressed data. \u003c/li\u003e\n  \u003cli\u003e There is no validation of the ratio between the compressed and uncompressed archive entry. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere is a risk if you answered yes to any of those questions.\u003c/p\u003e\n\u003ch2\u003eSensitive Code Example\u003c/h2\u003e\n\u003cpre\u003e\n#include \u0026lt;archive.h\u0026gt;\n#include \u0026lt;archive_entry.h\u0026gt;\n// ...\n\nvoid f(const char *filename, int flags) {\n  struct archive_entry *entry;\n  struct archive *a \u003d archive_read_new();\n  struct archive *ext \u003d archive_write_disk_new();\n  archive_write_disk_set_options(ext, flags);\n  archive_read_support_format_tar(a);\n\n  if ((archive_read_open_filename(a, filename, 10240))) {\n    return;\n  }\n\n  for (;;) {\n    int r \u003d archive_read_next_header(a, \u0026amp;entry);\n    if (r \u003d\u003d ARCHIVE_EOF) {\n      break;\n    }\n    if (r !\u003d ARCHIVE_OK) {\n      return;\n    }\n  }\n  archive_read_close(a);\n  archive_read_free(a);\n\n  archive_write_close(ext);\n  archive_write_free(ext);\n}\n\u003c/pre\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003ch2\u003eRecommended Secure Coding Practices\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e Define and control the threshold for maximum total size of the uncompressed data. \u003c/li\u003e\n  \u003cli\u003e Count the number of file entries extracted from the archive and abort the extraction if their number is greater than a predefined threshold, in\n  particular it’s not recommended to recursively expand archives (an entry of an archive could be also an archive). \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eCompliant Solution\u003c/h2\u003e\n\u003cpre\u003e\n#include \u0026lt;archive.h\u0026gt;\n#include \u0026lt;archive_entry.h\u0026gt;\n// ...\n\nint f(const char *filename, int flags) {\n  const int max_number_of_extraced_entries \u003d 1000;\n  const int64_t max_file_size \u003d 1000000000; // 1 GB\n\n  int number_of_extraced_entries \u003d 0;\n  int64_t total_file_size \u003d 0;\n\n  struct archive_entry *entry;\n  struct archive *a \u003d archive_read_new();\n  struct archive *ext \u003d archive_write_disk_new();\n  archive_write_disk_set_options(ext, flags);\n  archive_read_support_format_tar(a);\n  int status \u003d 0;\n\n  if ((archive_read_open_filename(a, filename, 10240))) {\n    return -1;\n  }\n\n  for (;;) {\n    number_of_extraced_entries++;\n    if (number_of_extraced_entries \u0026gt; max_number_of_extraced_entries) {\n      status \u003d 1;\n      break;\n    }\n\n    int r \u003d archive_read_next_header(a, \u0026amp;entry);\n    if (r \u003d\u003d ARCHIVE_EOF) {\n      break;\n    }\n    if (r !\u003d ARCHIVE_OK) {\n      status \u003d -1;\n      break;\n    }\n\n    int file_size \u003d archive_entry_size(entry);\n    total_file_size +\u003d file_size;\n    if (total_file_size \u0026gt; max_file_size) {\n      status \u003d 1;\n      break;\n    }\n  }\n  archive_read_close(a);\n  archive_read_free(a);\n\n  archive_write_close(ext);\n  archive_write_free(ext);\n\n  return status;\n}\n\u003c/pre\u003e\n\u003ch2\u003eSee\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/Top10/A01_2021-Broken_Access_Control/\"\u003eOWASP Top 10 2021 Category A1\u003c/a\u003e - Broken Access Control \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/Top10/A05_2021-Security_Misconfiguration/\"\u003eOWASP Top 10 2021 Category A5\u003c/a\u003e - Security Misconfiguration \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A6-Security_Misconfiguration\"\u003eOWASP Top 10 2017 Category A6\u003c/a\u003e -\n  Security Misconfiguration \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/409\"\u003eMITRE, CWE-409\u003c/a\u003e - Improper Handling of Highly Compressed Data (Data Amplification)\n  \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://www.bamsoftware.com/hacks/zipbomb/\"\u003ebamsoftware.com\u003c/a\u003e - A better Zip Bomb \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "cert",
      "cwe"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": [],
    "vulnerabilityProbability": "LOW"
  },
  {
    "key": "c:S1481",
    "name": "Unused local variables should be removed",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eAn unused local variable is a variable that has been declared but is not used anywhere in the block of code where it is defined. It is dead code,\ncontributing to unnecessary complexity and leading to confusion when reading the code. Therefore, it should be removed from your code to maintain\nclarity and efficiency.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eHaving unused local variables in your code can lead to several issues:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Decreased Readability: Unused variables can make your code more difficult to read. They add extra lines and complexity, which can distract from\n  the main logic of the code. \u003c/li\u003e\n  \u003cli\u003e Misunderstanding: When other developers read your code, they may wonder why a variable is declared but not used. This can lead to confusion and\n  misinterpretation of the code’s intent. \u003c/li\u003e\n  \u003cli\u003e Potential for Bugs: If a variable is declared but not used, it might indicate a bug or incomplete code. For example, if you declared a variable\n  intending to use it in a calculation, but then forgot to do so, your program might not work as expected. \u003c/li\u003e\n  \u003cli\u003e Maintenance Issues: Unused variables can make code maintenance more difficult. If a programmer sees an unused variable, they might think it is\n  a mistake and try to \u0027fix\u0027 the code, potentially introducing new bugs. \u003c/li\u003e\n  \u003cli\u003e Memory Usage: Although modern compilers are smart enough to ignore unused variables, not all compilers do this. In such cases, unused variables\n  take up memory space, leading to inefficient use of resources. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn summary, unused local variables can make your code less readable, more confusing, and harder to maintain, and they can potentially lead to bugs\nor inefficient memory use. Therefore, it is best to remove them.\u003c/p\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eNo issue is raised on local variables with the attribute \u003ccode\u003e[[maybe_unused]]\u003c/code\u003e or \u003ccode\u003eunused\u003c/code\u003e and object declarations with\nnon-empty arguments.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eThe fix for this issue is straightforward. Once you ensure the unused variable is not part of an incomplete implementation leading to bugs, you\njust need to remove it.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nint numberOfMinutes(int hours) {\n  int seconds \u003d 0; // Noncompliant second is unused\n  return hours * 60;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nint numberOfMinutes(int hours) {\n  return hours * 60;\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eAn unused local variable is a variable that has been declared but is not used anywhere in the block of code where it is defined. It is dead code,\ncontributing to unnecessary complexity and leading to confusion when reading the code. Therefore, it should be removed from your code to maintain\nclarity and efficiency.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eHaving unused local variables in your code can lead to several issues:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Decreased Readability: Unused variables can make your code more difficult to read. They add extra lines and complexity, which can distract from\n  the main logic of the code. \u003c/li\u003e\n  \u003cli\u003e Misunderstanding: When other developers read your code, they may wonder why a variable is declared but not used. This can lead to confusion and\n  misinterpretation of the code’s intent. \u003c/li\u003e\n  \u003cli\u003e Potential for Bugs: If a variable is declared but not used, it might indicate a bug or incomplete code. For example, if you declared a variable\n  intending to use it in a calculation, but then forgot to do so, your program might not work as expected. \u003c/li\u003e\n  \u003cli\u003e Maintenance Issues: Unused variables can make code maintenance more difficult. If a programmer sees an unused variable, they might think it is\n  a mistake and try to \u0027fix\u0027 the code, potentially introducing new bugs. \u003c/li\u003e\n  \u003cli\u003e Memory Usage: Although modern compilers are smart enough to ignore unused variables, not all compilers do this. In such cases, unused variables\n  take up memory space, leading to inefficient use of resources. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn summary, unused local variables can make your code less readable, more confusing, and harder to maintain, and they can potentially lead to bugs\nor inefficient memory use. Therefore, it is best to remove them.\u003c/p\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eNo issue is raised on local variables with the attribute \u003ccode\u003e[[maybe_unused]]\u003c/code\u003e or \u003ccode\u003eunused\u003c/code\u003e and object declarations with\nnon-empty arguments.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eThe fix for this issue is straightforward. Once you ensure the unused variable is not part of an incomplete implementation leading to bugs, you\njust need to remove it.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nint numberOfMinutes(int hours) {\n  int seconds \u003d 0; // Noncompliant second is unused\n  return hours * 60;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nint numberOfMinutes(int hours) {\n  return hours * 60;\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "unused"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S851",
    "name": "The value of a complex expression should only be cast to a type that is narrower and of the same signedness as the underlying type of the expression",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eIf a cast is to be used on any complex expression, the type of cast that may be applied is severely restricted. As explained in MISRA C 2004,\nsection 6.10, conversions on complex expressions are often a source of confusion and it is therefore wise to be cautious. In order to comply with\nthese rules, it may be necessary to use a temporary variable and introduce an extra statement.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n  ... (float32_t)(f64a + f64b)\n  ... (float64_t)(f32a + f32b) // Noncompliant\n  ... (float64_t)f32a\n  ... (float64_t)(s32a / s32b) // Noncompliant\n  ... (float64_t)(s32a \u0026gt; s32b) // Noncompliant\n  ... (float64_t)s32a / (float32_t)s32b\n  ... (uint32_t)(u16a + u16b) // Noncompliant\n  ... (uint32_t)u16a + u16b\n  ... (uint32_t)u16a + (uint32_t)u16b\n  ... (int16_t)(s32a - 12345)\n  ... (uint8_t)(u16a * u16b)\n  ... (uint16_t)(u8a * u8b) // Noncompliant\n  ... (int16_t)(s32a * s32b)\n  ... (int32_t)(s16a * s16b) // Noncompliant\n  ... (uint16_t)(f64a + f64b) // Noncompliant\n  ... (float32_t)(u16a + u16b) // Noncompliant\n  ... (float64_t)foo1(u16a + u16b)\n  ... (int32_t)buf16a[u16a + u16b]\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 10.3 - The value of a complex expression of integer type may only be cast to a type that is narrower and of the same signedness\n  as the underlying type of the expression. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2004, 10.4 - The value of a complex expression of floating type may only be cast to a narrower floating type. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eIf a cast is to be used on any complex expression, the type of cast that may be applied is severely restricted. As explained in MISRA C 2004,\nsection 6.10, conversions on complex expressions are often a source of confusion and it is therefore wise to be cautious. In order to comply with\nthese rules, it may be necessary to use a temporary variable and introduce an extra statement.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n  ... (float32_t)(f64a + f64b)\n  ... (float64_t)(f32a + f32b) // Noncompliant\n  ... (float64_t)f32a\n  ... (float64_t)(s32a / s32b) // Noncompliant\n  ... (float64_t)(s32a \u0026gt; s32b) // Noncompliant\n  ... (float64_t)s32a / (float32_t)s32b\n  ... (uint32_t)(u16a + u16b) // Noncompliant\n  ... (uint32_t)u16a + u16b\n  ... (uint32_t)u16a + (uint32_t)u16b\n  ... (int16_t)(s32a - 12345)\n  ... (uint8_t)(u16a * u16b)\n  ... (uint16_t)(u8a * u8b) // Noncompliant\n  ... (int16_t)(s32a * s32b)\n  ... (int32_t)(s16a * s16b) // Noncompliant\n  ... (uint16_t)(f64a + f64b) // Noncompliant\n  ... (float32_t)(u16a + u16b) // Noncompliant\n  ... (float64_t)foo1(u16a + u16b)\n  ... (int32_t)buf16a[u16a + u16b]\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 10.3 - The value of a complex expression of integer type may only be cast to a type that is narrower and of the same signedness\n  as the underlying type of the expression. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2004, 10.4 - The value of a complex expression of floating type may only be cast to a narrower floating type. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "based-on-misra"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S1916",
    "name": "Line continuation characters \u0027\\\u0027 should not be followed by trailing whitespace",
    "defaultSeverity": "MINOR",
    "type": "BUG",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "RELIABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhen a line of code ends with the \u003ccode\u003e\\\u003c/code\u003e (backslash) character, the newline character is deleted. The compiler considers the next line a\ncontinuation of the current line, resulting in only one logical line of code.\u003c/p\u003e\n\u003cp\u003eThis source code transformation, known as \u003cem\u003eline-splicing\u003c/em\u003e, occurs during the second phase of C and C++ translation.\u003c/p\u003e\n\u003cp\u003eSeveral compilers have a loose implementation of \u003cem\u003eline-splicing\u003c/em\u003e and allow whitespace after the \u003ccode\u003e\\\u003c/code\u003e character. While this\npractice was non-portable until C++23, it remains non-portable in C. Furthermore, readers can easily be confused about the meaning of these\nwhitespaces.\u003c/p\u003e\n\u003cp\u003eTherefore, for portability and clarity, \u003ccode\u003e\\\u003c/code\u003e should be immediately followed by a newline character, as in the following example.\u003c/p\u003e\n\u003cpre\u003e\n// Compliant: there is no whitespace after the \u0027\\\u0027\n#define FOO BAR \\\n            BAZ\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/translation_phases\"\u003ePhases of translation\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:c:S2323} - Line-splicing should not be used in \"//\" comments \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhen a line of code ends with the \u003ccode\u003e\\\u003c/code\u003e (backslash) character, the newline character is deleted. The compiler considers the next line a\ncontinuation of the current line, resulting in only one logical line of code.\u003c/p\u003e\n\u003cp\u003eThis source code transformation, known as \u003cem\u003eline-splicing\u003c/em\u003e, occurs during the second phase of C and C++ translation.\u003c/p\u003e\n\u003cp\u003eSeveral compilers have a loose implementation of \u003cem\u003eline-splicing\u003c/em\u003e and allow whitespace after the \u003ccode\u003e\\\u003c/code\u003e character. While this\npractice was non-portable until C++23, it remains non-portable in C. Furthermore, readers can easily be confused about the meaning of these\nwhitespaces.\u003c/p\u003e\n\u003cp\u003eTherefore, for portability and clarity, \u003ccode\u003e\\\u003c/code\u003e should be immediately followed by a newline character, as in the following example.\u003c/p\u003e\n\u003cpre\u003e\n// Compliant: there is no whitespace after the \u0027\\\u0027\n#define FOO BAR \\\n            BAZ\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/translation_phases\"\u003ePhases of translation\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:c:S2323} - Line-splicing should not be used in \"//\" comments \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [],
    "deprecatedKeys": [
      "c:PPBackslashNotLastCharacter"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S1917",
    "name": "Comment styles \"//\" and \"/* ... */\" should not be mixed within a file",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eUse either the \u003ccode\u003e// ...\u003c/code\u003e or \u003ccode\u003e/* ... */\u003c/code\u003e comment syntax, but be consistent and do not mix them within the same file.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n/* Noncompliant; both comment syntaxes are used in the same file */\n// Foo\n/* Bar */\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n// Compliant; uniform comment syntax\n// Foo\n// Bar\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eUse either the \u003ccode\u003e// ...\u003c/code\u003e or \u003ccode\u003e/* ... */\u003c/code\u003e comment syntax, but be consistent and do not mix them within the same file.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n/* Noncompliant; both comment syntaxes are used in the same file */\n// Foo\n/* Bar */\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n// Compliant; uniform comment syntax\n// Foo\n// Bar\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "cert",
      "convention"
    ],
    "deprecatedKeys": [
      "c:CommentMixedStyles"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:M23_146",
    "name": "A \"declaration\" should not declare more than one variable or member variable",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "FORMATTED",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 10.0.1\u003c/p\u003e\n\u003cp\u003eCategory: Advisory\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eAn \u003cem\u003einit-declarator-list\u003c/em\u003e or a \u003cem\u003emember-declarator-list\u003c/em\u003e should consist of a single \u003cem\u003einit-declarator\u003c/em\u003e or\n\u003cem\u003emember-declarator\u003c/em\u003e respectively.\u003c/p\u003e\n\u003cp\u003eStructured bindings are permitted by this rule.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eWhere multiple declarators appear in the same \u003cem\u003edeclaration\u003c/em\u003e [1], the type of an identifier may not meet developer expectations.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nint32_t   i1; int32_t j1;                 // Compliant\nint32_t   i2, * j2;                       // Non-compliant\nint32_t * i3,\n        \u0026amp; j3 \u003d i2;                        // Non-compliant\n\nstruct point\n{\n  int32_t x, y;                           // Non-compliant\n};\n\nstd::map\u0026lt; char, char \u0026gt; map \u003d f();\n\nauto [ loc, inserted ] \u003d\n  map.insert( make_pair( \u0027A\u0027, \u0027a\u0027 ) );    // Compliant - structured binding\n\u003c/pre\u003e\n\u003ch3\u003eGlossary\u003c/h3\u003e\n\u003ch4\u003e[1] Declaration\u003c/h4\u003e\n\u003cp\u003eA \u003cem\u003edeclaration\u003c/em\u003e introduces the name of an \u003cem\u003eentity\u003c/em\u003e into a \u003cem\u003etranslation unit\u003c/em\u003e (see [basic.def]/1).\u003c/p\u003e\n\u003cp\u003eAn \u003cem\u003eentity\u003c/em\u003e may be \u003cem\u003edeclared\u003c/em\u003e several times. The first \u003cem\u003edeclaration\u003c/em\u003e of an \u003cem\u003eentity\u003c/em\u003e in a \u003cem\u003etranslation unit\u003c/em\u003e is\ncalled an \u003cem\u003eintroduction\u003c/em\u003e [2]. All subsequent \u003cem\u003edeclarations\u003c/em\u003e are called \u003cem\u003eredeclarations\u003c/em\u003e [3].\u003c/p\u003e\n\u003cp\u003eA \u003cem\u003edefinition\u003c/em\u003e [4] is a \u003cem\u003edeclaration\u003c/em\u003e, as described in [basic.def]/2.\u003c/p\u003e\n\u003ch4\u003e[2] Introduction\u003c/h4\u003e\n\u003cp\u003eSee \u003cem\u003edeclaration\u003c/em\u003e [1].\u003c/p\u003e\n\u003ch4\u003e[3] Redeclaration\u003c/h4\u003e\n\u003cp\u003eSee \u003cem\u003edeclaration\u003c/em\u003e [1].\u003c/p\u003e\n\u003ch4\u003e[4] Definition\u003c/h4\u003e\n\u003cp\u003eSee \u003cem\u003edeclaration\u003c/em\u003e [1].\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003e{rule:c:S1659} targets the same defect as this rule but for a non-mission-critical context.\u003c/p\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/YTZGBQ\"\u003eCERT, DCL52-J.\u003c/a\u003e - Do not declare more than one variable per declaration \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/EtcxBQ\"\u003eCERT, DCL04-C.\u003c/a\u003e - Do not declare more than one variable per declaration \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/036324/CppCoreGuidelines.md#es10-declare-one-name-only-per-declaration\"\u003eC++ Core\n  Guidelines - ES.10\u003c/a\u003e - Declare one name (only) per declaration \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 10.0.1\u003c/p\u003e\n\u003cp\u003eCategory: Advisory\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eAn \u003cem\u003einit-declarator-list\u003c/em\u003e or a \u003cem\u003emember-declarator-list\u003c/em\u003e should consist of a single \u003cem\u003einit-declarator\u003c/em\u003e or\n\u003cem\u003emember-declarator\u003c/em\u003e respectively.\u003c/p\u003e\n\u003cp\u003eStructured bindings are permitted by this rule.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eWhere multiple declarators appear in the same \u003cem\u003edeclaration\u003c/em\u003e [1], the type of an identifier may not meet developer expectations.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nint32_t   i1; int32_t j1;                 // Compliant\nint32_t   i2, * j2;                       // Non-compliant\nint32_t * i3,\n        \u0026amp; j3 \u003d i2;                        // Non-compliant\n\nstruct point\n{\n  int32_t x, y;                           // Non-compliant\n};\n\nstd::map\u0026lt; char, char \u0026gt; map \u003d f();\n\nauto [ loc, inserted ] \u003d\n  map.insert( make_pair( \u0027A\u0027, \u0027a\u0027 ) );    // Compliant - structured binding\n\u003c/pre\u003e\n\u003ch3\u003eGlossary\u003c/h3\u003e\n\u003ch4\u003e[1] Declaration\u003c/h4\u003e\n\u003cp\u003eA \u003cem\u003edeclaration\u003c/em\u003e introduces the name of an \u003cem\u003eentity\u003c/em\u003e into a \u003cem\u003etranslation unit\u003c/em\u003e (see [basic.def]/1).\u003c/p\u003e\n\u003cp\u003eAn \u003cem\u003eentity\u003c/em\u003e may be \u003cem\u003edeclared\u003c/em\u003e several times. The first \u003cem\u003edeclaration\u003c/em\u003e of an \u003cem\u003eentity\u003c/em\u003e in a \u003cem\u003etranslation unit\u003c/em\u003e is\ncalled an \u003cem\u003eintroduction\u003c/em\u003e [2]. All subsequent \u003cem\u003edeclarations\u003c/em\u003e are called \u003cem\u003eredeclarations\u003c/em\u003e [3].\u003c/p\u003e\n\u003cp\u003eA \u003cem\u003edefinition\u003c/em\u003e [4] is a \u003cem\u003edeclaration\u003c/em\u003e, as described in [basic.def]/2.\u003c/p\u003e\n\u003ch4\u003e[2] Introduction\u003c/h4\u003e\n\u003cp\u003eSee \u003cem\u003edeclaration\u003c/em\u003e [1].\u003c/p\u003e\n\u003ch4\u003e[3] Redeclaration\u003c/h4\u003e\n\u003cp\u003eSee \u003cem\u003edeclaration\u003c/em\u003e [1].\u003c/p\u003e\n\u003ch4\u003e[4] Definition\u003c/h4\u003e\n\u003cp\u003eSee \u003cem\u003edeclaration\u003c/em\u003e [1].\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003e{rule:c:S1659} targets the same defect as this rule but for a non-mission-critical context.\u003c/p\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/YTZGBQ\"\u003eCERT, DCL52-J.\u003c/a\u003e - Do not declare more than one variable per declaration \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/EtcxBQ\"\u003eCERT, DCL04-C.\u003c/a\u003e - Do not declare more than one variable per declaration \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/036324/CppCoreGuidelines.md#es10-declare-one-name-only-per-declaration\"\u003eC++ Core\n  Guidelines - ES.10\u003c/a\u003e - Declare one name (only) per declaration \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "convention",
      "misra-advisory",
      "misra-c++2023"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:M23_388",
    "name": "\"Global variables\" shall not be used",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "MODULAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 6.7.2\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003e\u003cem\u003eGlobal variables\u003c/em\u003e are:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Variables defined in namespace scope; and \u003c/li\u003e\n  \u003cli\u003e Class static data members. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis rule does not apply to \u003cem\u003eglobal variables\u003c/em\u003e that are:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003econstexpr\u003c/code\u003e; or \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003econst\u003c/code\u003e and that are initialized through \u003cem\u003estatic initialization\u003c/em\u003e. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003e\u003cem\u003eGlobal variables\u003c/em\u003e can be accessed and modified from:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Anywhere within the \u003cem\u003etranslation unit\u003c/em\u003e, if they have internal linkage; or \u003c/li\u003e\n  \u003cli\u003e Anywhere within the program, if they have external linkage. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis can lead to uncontrollable interactions between functions, with the risk of \u003cem\u003eundefined behaviour\u003c/em\u003e occurring due to data races in\nconcurrent programs.\u003c/p\u003e\n\u003cp\u003eAdditionally, certain aspects of the order of initialization of global variables are \u003cem\u003eunspecified\u003c/em\u003e. This can lead to unpredictable results\nfor global variables that are initialized at run-time (\u003cem\u003edynamic initialization\u003c/em\u003e).\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nint32_t foo();\n\n      int32_t i1 { foo() };               // Non-compliant\nconst int32_t i2 { i1 };                  // Non-compliant - dynamic initialization\n\nnamespace\n{\n  int32_t i3 { 0 };                       // Non-compliant\n\n  constexpr int32_t bar()\n  {\n    return 42;\n  }\n\n  constexpr int32_t i4 { bar() };         // Rule does not apply - constexpr\n\n  const int32_t SIZE { 100 };             // Rule does not apply\n}                                         // - const without dynamic initialization\n\nstruct ComplexInit\n{\n  ComplexInit();\n};\n\nconst ComplexInit c1 {};                  // Non-compliant - dynamic initialization\n\nclass StaticMember\n{\n         int32_t x;                       // Rule does not apply\n  static int32_t numInstances;\n};\n\nint32_t StaticMember::numInstances \u003d 0;   // Non-compliant\n\nconstexpr auto add \u003d                      // Rule does not apply - add is const\n  []( auto x, auto y ) { return x + y; };\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e S5421 targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n  \u003cli\u003e {rule:c:M23_233}: MISRA C++ 2023 Rule\u0026nbsp;6.7.1 - Local variables shall not have static storage duration \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cp\u003e\u003ca href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/036324/CppCoreGuidelines.md#i2-avoid-non-const-global-variables\"\u003eC++ Core Guidelines\nI.2\u003c/a\u003e - Avoid non-const global variables\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 6.7.2\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003e\u003cem\u003eGlobal variables\u003c/em\u003e are:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Variables defined in namespace scope; and \u003c/li\u003e\n  \u003cli\u003e Class static data members. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis rule does not apply to \u003cem\u003eglobal variables\u003c/em\u003e that are:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003econstexpr\u003c/code\u003e; or \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003econst\u003c/code\u003e and that are initialized through \u003cem\u003estatic initialization\u003c/em\u003e. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003e\u003cem\u003eGlobal variables\u003c/em\u003e can be accessed and modified from:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Anywhere within the \u003cem\u003etranslation unit\u003c/em\u003e, if they have internal linkage; or \u003c/li\u003e\n  \u003cli\u003e Anywhere within the program, if they have external linkage. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis can lead to uncontrollable interactions between functions, with the risk of \u003cem\u003eundefined behaviour\u003c/em\u003e occurring due to data races in\nconcurrent programs.\u003c/p\u003e\n\u003cp\u003eAdditionally, certain aspects of the order of initialization of global variables are \u003cem\u003eunspecified\u003c/em\u003e. This can lead to unpredictable results\nfor global variables that are initialized at run-time (\u003cem\u003edynamic initialization\u003c/em\u003e).\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nint32_t foo();\n\n      int32_t i1 { foo() };               // Non-compliant\nconst int32_t i2 { i1 };                  // Non-compliant - dynamic initialization\n\nnamespace\n{\n  int32_t i3 { 0 };                       // Non-compliant\n\n  constexpr int32_t bar()\n  {\n    return 42;\n  }\n\n  constexpr int32_t i4 { bar() };         // Rule does not apply - constexpr\n\n  const int32_t SIZE { 100 };             // Rule does not apply\n}                                         // - const without dynamic initialization\n\nstruct ComplexInit\n{\n  ComplexInit();\n};\n\nconst ComplexInit c1 {};                  // Non-compliant - dynamic initialization\n\nclass StaticMember\n{\n         int32_t x;                       // Rule does not apply\n  static int32_t numInstances;\n};\n\nint32_t StaticMember::numInstances \u003d 0;   // Non-compliant\n\nconstexpr auto add \u003d                      // Rule does not apply - add is const\n  []( auto x, auto y ) { return x + y; };\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e S5421 targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n  \u003cli\u003e {rule:c:M23_233}: MISRA C++ 2023 Rule\u0026nbsp;6.7.1 - Local variables shall not have static storage duration \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cp\u003e\u003ca href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/036324/CppCoreGuidelines.md#i2-avoid-non-const-global-variables\"\u003eC++ Core Guidelines\nI.2\u003c/a\u003e - Avoid non-const global variables\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "confusing",
      "misra-c++2023",
      "misra-required"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S859",
    "name": "A cast shall not remove any const or volatile qualification from the type of a pointer or reference",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "MODULAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eUsing \u003ccode\u003econst\u003c/code\u003e in your code improves reliability and maintenance. When passing a \u003ccode\u003econst\u003c/code\u003e value, developers assume that its\nvalue won’t be changed. But using \u003ccode\u003econst_cast\u0026lt;\u0026gt;()\u003c/code\u003e to cast away a \u003ccode\u003econst\u003c/code\u003e qualifier, destroys developer assumptions and\ncode reliability. It is a bad practice and reveals a flaw in the design. Furthermore, it may have an undefined behavior.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nUser\u0026amp; func(const int\u0026amp; value, const User\u0026amp; user) {\n  const_cast\u0026lt;int\u0026amp;\u0026gt;(value) \u003d 2; // Noncompliant and undefined behavior\n  return const_cast\u0026lt;User\u0026amp;\u0026gt;(user); // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nUser\u0026amp; func(int\u0026amp; value, User\u0026amp; user) {\n  value \u003d 2;\n  return user;\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 11.5 - A cast shall not be performed that removes any const or volatile qualification from the type addressed by a pointer \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 5-2-5 - A cast shall not remove any const or volatile qualification from the type of a pointer or reference \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 11.8 - A cast shall not remove any const or volatile qualification from the type pointed to by a pointer \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/HNcxBQ\"\u003eCERT, EXP32-C.\u003c/a\u003e - Do not access a volatile object through a nonvolatile reference\n  \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/P9YxBQ\"\u003eCERT, EXP05-C.\u003c/a\u003e - Do not cast away a const qualification \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/AHw-BQ\"\u003eCERT, EXP55-CPP.\u003c/a\u003e - Do not access a cv-qualified object through a cv-unqualified type\n  \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines Type.3 - Don’t use const_cast to cast away const (i.e., at all): Don’t cast away const. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eUsing \u003ccode\u003econst\u003c/code\u003e in your code improves reliability and maintenance. When passing a \u003ccode\u003econst\u003c/code\u003e value, developers assume that its\nvalue won’t be changed. But using \u003ccode\u003econst_cast\u0026lt;\u0026gt;()\u003c/code\u003e to cast away a \u003ccode\u003econst\u003c/code\u003e qualifier, destroys developer assumptions and\ncode reliability. It is a bad practice and reveals a flaw in the design. Furthermore, it may have an undefined behavior.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nUser\u0026amp; func(const int\u0026amp; value, const User\u0026amp; user) {\n  const_cast\u0026lt;int\u0026amp;\u0026gt;(value) \u003d 2; // Noncompliant and undefined behavior\n  return const_cast\u0026lt;User\u0026amp;\u0026gt;(user); // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nUser\u0026amp; func(int\u0026amp; value, User\u0026amp; user) {\n  value \u003d 2;\n  return user;\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 11.5 - A cast shall not be performed that removes any const or volatile qualification from the type addressed by a pointer \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 5-2-5 - A cast shall not remove any const or volatile qualification from the type of a pointer or reference \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 11.8 - A cast shall not remove any const or volatile qualification from the type pointed to by a pointer \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/HNcxBQ\"\u003eCERT, EXP32-C.\u003c/a\u003e - Do not access a volatile object through a nonvolatile reference\n  \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/P9YxBQ\"\u003eCERT, EXP05-C.\u003c/a\u003e - Do not cast away a const qualification \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/AHw-BQ\"\u003eCERT, EXP55-CPP.\u003c/a\u003e - Do not access a cv-qualified object through a cv-unqualified type\n  \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines Type.3 - Don’t use const_cast to cast away const (i.e., at all): Don’t cast away const. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "cert",
      "cppcoreguidelines",
      "misra-c++2008",
      "misra-c2004",
      "misra-c2012",
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S2216",
    "name": "Single-bit named bit fields should not be of a signed type",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe values that can be represented by a signed bit field with a length of one bit may not meet developer expectations. For example, according to\nthe C99 Standard, a single-bit signed bit-field has a single (one) sign bit and no (zero) value bits.\u003c/p\u003e\n\u003cp\u003eThis rule does not apply to unnamed bit fields, as their values cannot be accessed.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nsigned int f:1;  // Noncompliant; there\u0027s only room here for the sign\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nunsigned int f:1;\n\u003c/pre\u003e\n\u003cp\u003eor\u003c/p\u003e\n\u003cpre\u003e\nsigned int:1; // unnamed\n\u003c/pre\u003e\n\u003cp\u003eor\u003c/p\u003e\n\u003cpre\u003e\nsigned int f:2;\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 6.5 - Bit fields of type signed int shall be at least 2 bits long \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 6.2 - Single-bit named bit fields shall not be of a signed type \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 9-6-4 - Named bit-fields with signed integer type shall have a length of more than one bit \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe values that can be represented by a signed bit field with a length of one bit may not meet developer expectations. For example, according to\nthe C99 Standard, a single-bit signed bit-field has a single (one) sign bit and no (zero) value bits.\u003c/p\u003e\n\u003cp\u003eThis rule does not apply to unnamed bit fields, as their values cannot be accessed.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nsigned int f:1;  // Noncompliant; there\u0027s only room here for the sign\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nunsigned int f:1;\n\u003c/pre\u003e\n\u003cp\u003eor\u003c/p\u003e\n\u003cpre\u003e\nsigned int:1; // unnamed\n\u003c/pre\u003e\n\u003cp\u003eor\u003c/p\u003e\n\u003cpre\u003e\nsigned int f:2;\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 6.5 - Bit fields of type signed int shall be at least 2 bits long \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 6.2 - Single-bit named bit fields shall not be of a signed type \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 9-6-4 - Named bit-fields with signed integer type shall have a length of more than one bit \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "based-on-misra"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S5849",
    "name": "Setting capabilities is security-sensitive",
    "defaultSeverity": "MAJOR",
    "type": "SECURITY_HOTSPOT",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "SECURITY": "MEDIUM"
    },
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eSetting capabilities can lead to privilege escalation.\u003c/p\u003e\n\u003cp\u003eLinux capabilities allow you to assign narrow slices of \u003ccode\u003eroot\u003c/code\u003e\u0027s permissions to files or processes. A thread with capabilities bypasses\nthe normal kernel security checks to execute high-privilege actions such as mounting a device to a directory, without requiring (additional) root\nprivileges.\u003c/p\u003e"
      },
      {
        "key": "assess_the_problem",
        "htmlContent": "\u003ch2\u003eAsk Yourself Whether\u003c/h2\u003e\n\u003cp\u003eCapabilities are granted:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e To a process that does not require all capabilities to do its job. \u003c/li\u003e\n  \u003cli\u003e To a not trusted process. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere is a risk if you answered yes to any of those questions.\u003c/p\u003e\n\u003ch2\u003eSensitive Code Example\u003c/h2\u003e\n\u003cp\u003eWhen setting capabilities:\u003c/p\u003e\n\u003cpre\u003e\ncap_t caps \u003d cap_init();\ncap_value_t cap_list[2];\ncap_list[0] \u003d CAP_FOWNER;\ncap_list[1] \u003d CAP_CHOWN;\ncap_set_flag(caps, CAP_PERMITTED, 2, cap_list, CAP_SET);\n\ncap_set_file(\"file\", caps); // Sensitive\ncap_set_fd(fd, caps); // Sensitive\ncap_set_proc(caps); // Sensitive\ncapsetp(pid, caps); // Sensitive\ncapset(hdrp, datap); // Sensitive: is discouraged to be used because it is a system call\n\u003c/pre\u003e\n\u003cp\u003eWhen setting SUID/SGID attributes:\u003c/p\u003e\n\u003cpre\u003e\nchmod(\"file\", S_ISUID|S_ISGID); // Sensitive\nfchmod(fd, S_ISUID|S_ISGID); // Sensitive\n\u003c/pre\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003ch2\u003eRecommended Secure Coding Practices\u003c/h2\u003e\n\u003cp\u003eCapabilities are high privileges, traditionally associated with superuser (root), thus make sure that the most restrictive and necessary\ncapabilities are assigned to files and processes.\u003c/p\u003e\n\u003ch2\u003eSee\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/Top10/A01_2021-Broken_Access_Control/\"\u003eOWASP Top 10 2021 Category A1\u003c/a\u003e - Broken Access Control \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control\"\u003eOWASP Top 10 2017 Category A5\u003c/a\u003e - Broken Access Control\n  \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/250\"\u003eMITRE, CWE-250\u003c/a\u003e - Execution with Unnecessary Privileges \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/266\"\u003eMITRE, CWE-266\u003c/a\u003e - Incorrect Privilege Assignment \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://forums.grsecurity.net/viewtopic.php?f\u003d7\u0026amp;t\u003d2522\"\u003eFalse Boundaries and Arbitrary Code Execution\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://man7.org/linux/man-pages/man7/capabilities.7.html\"\u003eLinux manual page\u003c/a\u003e - capabilities(7) \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "cwe"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": [],
    "vulnerabilityProbability": "MEDIUM"
  },
  {
    "key": "c:M23_152",
    "name": "The value of an object must not be read before it has been set",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 11.6.2\u003c/p\u003e\n\u003cp\u003eCategory: Mandatory\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Undecidable,System\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eFor the purposes of this rule, an array element or class member is considered to be a discrete object.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e struct members are also class members.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eObjects created with \u003cem\u003eautomatic storage duration\u003c/em\u003e or \u003cem\u003edynamic storage duration\u003c/em\u003e have an \u003cem\u003eindeterminate value\u003c/em\u003e. Reading an\nindeterminate value may result in \u003cem\u003eundefined behaviour\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eThis rule requires that all objects are written, either by implicit or explicit initialization in their declaration or by assignment, before they\nare read.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e jumping over an initializer by the use of a \u003ccode\u003egoto\u003c/code\u003e or \u003ccode\u003eswitch\u003c/code\u003e statement \"bypasses\" the declaration of\nthe object, rendering the program \u003cem\u003eill-formed\u003c/em\u003e.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nnamespace\n{\n  int32_t Z;                  // Compliant - implicitly initialized with \u00270\u0027\n}\n\nvoid f()\n{\n  int32_t  i;\n  int32_t  j \u003d i + 1;         // Non-compliant - i has not been assigned a value\n\n  int32_t * p \u003d new int32_t;\n  int32_t   k \u003d *p;           // Non-compliant - *p has not been assigned a value\n\n  int32_t * q;\n\n  if ( q \u003d\u003d p )               // Non-compliant - q has not been assigned a value\n  {\n  }\n}\n\nint32_t g( bool b )\n{\n  if ( b )\n  {\n    goto L1;\n  }\n\n  int32_t x;\n\n  x \u003d 10u;\n\nL1:\n  x \u003d x + 1u;               // Non-compliant - x may not have been assigned a value\n\n  return x;\n}\n\nstruct S { int32_t a; int32_t b; };\n\nvoid h()\n{\n  S s1;\n  S s2 \u003d { 10 };\n\n  auto i1 \u003d s1.a;           // Non-compliant\n  auto i2 \u003d s2.b;           // Compliant - s2.b implicitly initialized to 0\n\n  int32_t array1[ 10 ] \u003d { 1, 2, 3 };\n  int32_t array2[ 10 ];\n  auto i3 \u003d array1[ 5 ];    // Compliant - array1[ 5 ] implicitly initialized to 0\n  auto i4 \u003d array2[ 5 ];    // Non-compliant\n}\n\nclass C\n{\npublic:\n  C() : m_a( 10 ), m_b( 7 )   // Both m_a and m_b initialized\n  {\n  }\n\n  C( int32_t a ) : m_a( a )   // m_b not initialized\n  {\n  }\n\n  int32_t GetmB()\n  {\n    return m_b;\n  }\n\nprivate:\n  int32_t m_a;\n  int32_t m_b;\n};\n\nint main()\n{\n  C c1;\n  if ( c1.GetmB() \u0026gt; 0 )       // Compliant - m_b initialized\n  {\n  }\n\n  C c2( 5 );\n\n  if ( c2.GetmB() \u0026gt; 0 )       // Non-compliant - m_b not initialized\n  {\n  }\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:c:S836} targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n  \u003cli\u003e {rule:c:M23_321}: MISRA C++ 2023 Rule\u0026nbsp;11.6.1 - All variables should be initialized \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2023 Rule\u0026nbsp;15.1.4 - All direct, non-static data members of a class should be initialized before the class object is\n  \u003cem\u003eaccessible\u003c/em\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cp\u003e\u003ca href\u003d\"https://cwe.mitre.org/data/definitions/457\"\u003eMITRE, CWE-457\u003c/a\u003e - Use of Uninitialized Variable\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 11.6.2\u003c/p\u003e\n\u003cp\u003eCategory: Mandatory\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Undecidable,System\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eFor the purposes of this rule, an array element or class member is considered to be a discrete object.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e struct members are also class members.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eObjects created with \u003cem\u003eautomatic storage duration\u003c/em\u003e or \u003cem\u003edynamic storage duration\u003c/em\u003e have an \u003cem\u003eindeterminate value\u003c/em\u003e. Reading an\nindeterminate value may result in \u003cem\u003eundefined behaviour\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eThis rule requires that all objects are written, either by implicit or explicit initialization in their declaration or by assignment, before they\nare read.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e jumping over an initializer by the use of a \u003ccode\u003egoto\u003c/code\u003e or \u003ccode\u003eswitch\u003c/code\u003e statement \"bypasses\" the declaration of\nthe object, rendering the program \u003cem\u003eill-formed\u003c/em\u003e.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nnamespace\n{\n  int32_t Z;                  // Compliant - implicitly initialized with \u00270\u0027\n}\n\nvoid f()\n{\n  int32_t  i;\n  int32_t  j \u003d i + 1;         // Non-compliant - i has not been assigned a value\n\n  int32_t * p \u003d new int32_t;\n  int32_t   k \u003d *p;           // Non-compliant - *p has not been assigned a value\n\n  int32_t * q;\n\n  if ( q \u003d\u003d p )               // Non-compliant - q has not been assigned a value\n  {\n  }\n}\n\nint32_t g( bool b )\n{\n  if ( b )\n  {\n    goto L1;\n  }\n\n  int32_t x;\n\n  x \u003d 10u;\n\nL1:\n  x \u003d x + 1u;               // Non-compliant - x may not have been assigned a value\n\n  return x;\n}\n\nstruct S { int32_t a; int32_t b; };\n\nvoid h()\n{\n  S s1;\n  S s2 \u003d { 10 };\n\n  auto i1 \u003d s1.a;           // Non-compliant\n  auto i2 \u003d s2.b;           // Compliant - s2.b implicitly initialized to 0\n\n  int32_t array1[ 10 ] \u003d { 1, 2, 3 };\n  int32_t array2[ 10 ];\n  auto i3 \u003d array1[ 5 ];    // Compliant - array1[ 5 ] implicitly initialized to 0\n  auto i4 \u003d array2[ 5 ];    // Non-compliant\n}\n\nclass C\n{\npublic:\n  C() : m_a( 10 ), m_b( 7 )   // Both m_a and m_b initialized\n  {\n  }\n\n  C( int32_t a ) : m_a( a )   // m_b not initialized\n  {\n  }\n\n  int32_t GetmB()\n  {\n    return m_b;\n  }\n\nprivate:\n  int32_t m_a;\n  int32_t m_b;\n};\n\nint main()\n{\n  C c1;\n  if ( c1.GetmB() \u0026gt; 0 )       // Compliant - m_b initialized\n  {\n  }\n\n  C c2( 5 );\n\n  if ( c2.GetmB() \u0026gt; 0 )       // Non-compliant - m_b not initialized\n  {\n  }\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:c:S836} targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n  \u003cli\u003e {rule:c:M23_321}: MISRA C++ 2023 Rule\u0026nbsp;11.6.1 - All variables should be initialized \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2023 Rule\u0026nbsp;15.1.4 - All direct, non-static data members of a class should be initialized before the class object is\n  \u003cem\u003eaccessible\u003c/em\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cp\u003e\u003ca href\u003d\"https://cwe.mitre.org/data/definitions/457\"\u003eMITRE, CWE-457\u003c/a\u003e - Use of Uninitialized Variable\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "cwe",
      "misra-c++2023",
      "misra-mandatory",
      "symbolic-execution",
      "unpredictable"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S5847",
    "name": "Accessing files should not introduce TOCTOU vulnerabilities",
    "defaultSeverity": "CRITICAL",
    "type": "VULNERABILITY",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "SECURITY": "HIGH"
    },
    "description": "\u003cp\u003eWhen an application manipulates files, \"Time-Of-Check to Time-Of-Use\" can occur when a file-checking operation is disconnected from the actual\noperation it is bound to.\u003c/p\u003e\n\u003cp\u003eFor example, such a vulnerability occurs when a file existence check is performed strictly before a file creation operation.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eRace conditions can happen when file operations and their associated pre-checks are disconnected. Indeed, while the application assumes that the\nchecked file property will not change before performing the operation, there is a chance that changes are applied to the file.\u003c/p\u003e\n\u003cp\u003eEspecially, a concurrent process, which an attacker can control, could modify a file right after a check is performed and before the actual use.\nThis file can be deleted, created, altered, or see its permissions changed depending on the use case.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eThe impact of a successfully exploited race condition is dependent on the business logic of the vulnerable application. The consequences will vary\ndepending on what check is performed and how the file is used.\u003c/p\u003e\n\u003cp\u003eIn general, attackers use such attacks to escalate privileges, execute arbitrary code, or perform a denial of service.\u003c/p\u003e\n\u003ch4\u003eArbitrary code execution\u003c/h4\u003e\n\u003cp\u003eExecutable or script file integrity and authenticity checks can be bypassed when exploiting a TOCTOU vulnerability. In such a scenario, attackers\nwould change an executable file content between when its integrity is checked and when the application executes it.\u003c/p\u003e\n\u003cp\u003eThis attack would allow attackers to trick the application into executing malicious, arbitrary code. They would then be granted the same privilege\nlevels as the application itself, which can be particularly severe when it runs with administration privileges.\u003c/p\u003e\n\u003ch4\u003ePrivileges escalation\u003c/h4\u003e\n\u003cp\u003eWhen the attacker is a local user on the same server as the running application, the same attack is possible with extended probability. In such a\ncase, attackers can exploit the reading and writing to configuration files, the creation of local network resources, or the use of temporary files to\nachieve the same code execution purpose.\u003c/p\u003e\n\u003cp\u003eHowever, in that case, the attack is only meaningful when the application is running with high or otherwise interesting privileges. Attackers\nexploiting a TOCTOU vulnerability that way would achieve horizontal or vertical privilege escalation.\u003c/p\u003e\n\u003ch4\u003eDenial of service\u003c/h4\u003e\n\u003cp\u003eWhen the application expects some file properties to be set at the operation time, it will often face unexpected errors when those properties have\nactually changed. This might be the case when writing to a file where newly set permissions forbid that operation or when reading from a deleted\nfile.\u003c/p\u003e\n\u003cp\u003eWhen such errors are faced, the application might unexpectedly stop, which can affect its availability. Depending on the application and hosting\narchitectures, the interruption can be temporary or permanent, partial or complete.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eTo prevent TOCTOU race condition issues, best practices recommend relying on file operations that can perform the necessary preliminary checks\natomically. For example, file opening functions usually accept a parameter to check the file exists and return an error depending on the result. This\ncheck is atomic and is not susceptible to race conditions.\u003c/p\u003e\n\u003cp\u003eWhen this is not possible, it might be possible to open a file directly, and to keep a reference to it for later use. If the conditions are set for\nthe subsequent operations, the application can continue with its processing and use the open file pointer to read or write to the file. In the\nopposite case, an error might be raised that will need to be properly handled.\u003c/p\u003e\n\u003cp\u003eTo finish, for most complex operations, the application can create a dedicated working directory and set tight permissions on it. This needs to be\nperformed atomically to prevent further race conditions. All subsequent sensitive file operations can then be performed in this dedicated\ndirectory.\u003c/p\u003e\n\u003cp\u003eNote that this last solution is imperfect and is still susceptible to race condition attacks from privileged users and the application itself. It\nshould be used when no other countermeasure is acceptable.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cp\u003eThe following code sample is susceptible to a race condition attack because it checks a file exists strictly before it opens it for writing.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nFILE *fopen_if_not_exists(const char *file) {\n  if (access(file, F_OK) \u003d\u003d -1 \u0026amp;\u0026amp; errno \u003d\u003d ENOENT) {\n    FILE *f \u003d fopen(file, \"w\"); // Noncompliant\n\n    return f;\n  }\n\n  return nullptr;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nFILE *fopen_if_not_exists(const char *file) {\n  FILE *f \u003d fopen(file, \"wx\");\n  return f;\n}\n\u003c/pre\u003e\n\u003ch3\u003eHow does this work?\u003c/h3\u003e\n\u003cp\u003eHere, the compliant code example uses an atomic operation to open the file and check for its existence beforehand.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Carnegie Mellon University Software Engineering Institure - \u003ca\n  href\u003d\"https://wiki.sei.cmu.edu/confluence/display/c/FIO45-C.+Avoid+TOCTOU+race+conditions+while+accessing+files\"\u003eFIO45-C. - Avoid TOCTOU race\n  conditions while accessing files\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e OWASP - \u003ca href\u003d\"https://owasp.org/Top10/A01_2021-Broken_Access_Control/\"\u003eTop 10 2021 Category A1 - Broken Access Control\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e OWASP - \u003ca href\u003d\"https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control\"\u003eTop 10 2017 Category A5 - Broken Access Control\u003c/a\u003e\n  \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/367\"\u003eCWE-367 - Time-of-check Time-of-use (TOCTOU) Race Condition\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eWhen an application manipulates files, \"Time-Of-Check to Time-Of-Use\" can occur when a file-checking operation is disconnected from the actual\noperation it is bound to.\u003c/p\u003e\n\u003cp\u003eFor example, such a vulnerability occurs when a file existence check is performed strictly before a file creation operation.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eRace conditions can happen when file operations and their associated pre-checks are disconnected. Indeed, while the application assumes that the\nchecked file property will not change before performing the operation, there is a chance that changes are applied to the file.\u003c/p\u003e\n\u003cp\u003eEspecially, a concurrent process, which an attacker can control, could modify a file right after a check is performed and before the actual use.\nThis file can be deleted, created, altered, or see its permissions changed depending on the use case.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eThe impact of a successfully exploited race condition is dependent on the business logic of the vulnerable application. The consequences will vary\ndepending on what check is performed and how the file is used.\u003c/p\u003e\n\u003cp\u003eIn general, attackers use such attacks to escalate privileges, execute arbitrary code, or perform a denial of service.\u003c/p\u003e\n\u003ch4\u003eArbitrary code execution\u003c/h4\u003e\n\u003cp\u003eExecutable or script file integrity and authenticity checks can be bypassed when exploiting a TOCTOU vulnerability. In such a scenario, attackers\nwould change an executable file content between when its integrity is checked and when the application executes it.\u003c/p\u003e\n\u003cp\u003eThis attack would allow attackers to trick the application into executing malicious, arbitrary code. They would then be granted the same privilege\nlevels as the application itself, which can be particularly severe when it runs with administration privileges.\u003c/p\u003e\n\u003ch4\u003ePrivileges escalation\u003c/h4\u003e\n\u003cp\u003eWhen the attacker is a local user on the same server as the running application, the same attack is possible with extended probability. In such a\ncase, attackers can exploit the reading and writing to configuration files, the creation of local network resources, or the use of temporary files to\nachieve the same code execution purpose.\u003c/p\u003e\n\u003cp\u003eHowever, in that case, the attack is only meaningful when the application is running with high or otherwise interesting privileges. Attackers\nexploiting a TOCTOU vulnerability that way would achieve horizontal or vertical privilege escalation.\u003c/p\u003e\n\u003ch4\u003eDenial of service\u003c/h4\u003e\n\u003cp\u003eWhen the application expects some file properties to be set at the operation time, it will often face unexpected errors when those properties have\nactually changed. This might be the case when writing to a file where newly set permissions forbid that operation or when reading from a deleted\nfile.\u003c/p\u003e\n\u003cp\u003eWhen such errors are faced, the application might unexpectedly stop, which can affect its availability. Depending on the application and hosting\narchitectures, the interruption can be temporary or permanent, partial or complete.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eTo prevent TOCTOU race condition issues, best practices recommend relying on file operations that can perform the necessary preliminary checks\natomically. For example, file opening functions usually accept a parameter to check the file exists and return an error depending on the result. This\ncheck is atomic and is not susceptible to race conditions.\u003c/p\u003e\n\u003cp\u003eWhen this is not possible, it might be possible to open a file directly, and to keep a reference to it for later use. If the conditions are set for\nthe subsequent operations, the application can continue with its processing and use the open file pointer to read or write to the file. In the\nopposite case, an error might be raised that will need to be properly handled.\u003c/p\u003e\n\u003cp\u003eTo finish, for most complex operations, the application can create a dedicated working directory and set tight permissions on it. This needs to be\nperformed atomically to prevent further race conditions. All subsequent sensitive file operations can then be performed in this dedicated\ndirectory.\u003c/p\u003e\n\u003cp\u003eNote that this last solution is imperfect and is still susceptible to race condition attacks from privileged users and the application itself. It\nshould be used when no other countermeasure is acceptable.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cp\u003eThe following code sample is susceptible to a race condition attack because it checks a file exists strictly before it opens it for writing.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nFILE *fopen_if_not_exists(const char *file) {\n  if (access(file, F_OK) \u003d\u003d -1 \u0026amp;\u0026amp; errno \u003d\u003d ENOENT) {\n    FILE *f \u003d fopen(file, \"w\"); // Noncompliant\n\n    return f;\n  }\n\n  return nullptr;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nFILE *fopen_if_not_exists(const char *file) {\n  FILE *f \u003d fopen(file, \"wx\");\n  return f;\n}\n\u003c/pre\u003e\n\u003ch3\u003eHow does this work?\u003c/h3\u003e\n\u003cp\u003eHere, the compliant code example uses an atomic operation to open the file and check for its existence beforehand.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Carnegie Mellon University Software Engineering Institure - \u003ca\n  href\u003d\"https://wiki.sei.cmu.edu/confluence/display/c/FIO45-C.+Avoid+TOCTOU+race+conditions+while+accessing+files\"\u003eFIO45-C. - Avoid TOCTOU race\n  conditions while accessing files\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e OWASP - \u003ca href\u003d\"https://owasp.org/Top10/A01_2021-Broken_Access_Control/\"\u003eTop 10 2021 Category A1 - Broken Access Control\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e OWASP - \u003ca href\u003d\"https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control\"\u003eTop 10 2017 Category A5 - Broken Access Control\u003c/a\u003e\n  \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/367\"\u003eCWE-367 - Time-of-check Time-of-use (TOCTOU) Race Condition\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "cert",
      "cwe"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S860",
    "name": "Objects with integer type should not be converted to objects with pointer type",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eConverting an integer type to a pointer generally leads to unspecified behavior. There are several cases where it might be legitimate:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Converting the integral literal \u003ccode\u003e0\u003c/code\u003e to the null pointer (but you should use \u003ccode\u003enullptr\u003c/code\u003e instead, see S4962),\n  \u003c/li\u003e\n  \u003cli\u003e Converting back to a pointer a pointer value that was converted to a large enough integer (see {rule:c:S1767}), \u003c/li\u003e\n  \u003cli\u003e On embedded devices, device drivers…​ converting a hard-coded address to a pointer to read some specific memory (this often goes together with\n  the use of \u003ccode\u003evolatile\u003c/code\u003e, since such memory values can change from the outside of the program). \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSince even legitimate cases are corner cases that require to be reviewed carefully, this rule simply reports all places where an integer is cast\ninto a pointer (except the literal \u003ccode\u003e0\u003c/code\u003e).\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstruct S {\n  int i;\n  int j;\n};\n\nvoid f(void* a);\n\nvoid g(int i) {\n  S* s1 \u003d (S*)i; // Noncompliant\n  f((void*)i); // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++ 2008, 5-2-8 - An object with integer type or pointer to void type shall not be converted to an object with pointer type. \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/0dUxBQ\"\u003eCERT, INT36-C.\u003c/a\u003e - Converting a pointer to integer or integer to pointer \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eConverting an integer type to a pointer generally leads to unspecified behavior. There are several cases where it might be legitimate:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Converting the integral literal \u003ccode\u003e0\u003c/code\u003e to the null pointer (but you should use \u003ccode\u003enullptr\u003c/code\u003e instead, see S4962),\n  \u003c/li\u003e\n  \u003cli\u003e Converting back to a pointer a pointer value that was converted to a large enough integer (see {rule:c:S1767}), \u003c/li\u003e\n  \u003cli\u003e On embedded devices, device drivers…​ converting a hard-coded address to a pointer to read some specific memory (this often goes together with\n  the use of \u003ccode\u003evolatile\u003c/code\u003e, since such memory values can change from the outside of the program). \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSince even legitimate cases are corner cases that require to be reviewed carefully, this rule simply reports all places where an integer is cast\ninto a pointer (except the literal \u003ccode\u003e0\u003c/code\u003e).\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstruct S {\n  int i;\n  int j;\n};\n\nvoid f(void* a);\n\nvoid g(int i) {\n  S* s1 \u003d (S*)i; // Noncompliant\n  f((void*)i); // Noncompliant\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C++ 2008, 5-2-8 - An object with integer type or pointer to void type shall not be converted to an object with pointer type. \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/0dUxBQ\"\u003eCERT, INT36-C.\u003c/a\u003e - Converting a pointer to integer or integer to pointer \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "based-on-misra",
      "cert"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S1121",
    "name": "Assignments should not be made from within conditions",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eAssigning a value inside a condition (of an \u003ccode\u003eif\u003c/code\u003e statement, a \u003ccode\u003efor\u003c/code\u003e statement, a \u003ccode\u003ewhile\u003c/code\u003e, or a\n\u003ccode\u003eswitch\u003c/code\u003e) can be confusing. It assigns the value and checks it at the same time, but it is easily confused with a simple equality check\nwith \u003ccode\u003e\u003d\u003d\u003c/code\u003e and the original intention can be unclear.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n  if (x \u003d getValue()) { // Noncompliant: assigning and checking. Is it on purpose?\n    doSomething();\n  }\n\u003c/pre\u003e\n\u003cp\u003eIt is better to assign before the statement and use the condition for the check only:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n  x \u003d getValue();\n  if (x) {\n    doSomething();\n  }\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThis rule ignores assignments explicitly enclosed in parentheses.\u003c/p\u003e\n\u003cpre\u003e\nwhile ((run \u003d keepRunning())) {\n  //...\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/481\"\u003e481: Assigning instead of Comparing\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/ZNYxBQ\"\u003eEXP45-C. Do not perform assignments in selection statements\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 13.1 - Assignment operators shall not be used in expressions that yield a Boolean value \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 6-2-1 - Assignment operators shall not be used in sub-expressions \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 13.4 - The result of an assignment operator should not be used \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eAssigning a value inside a condition (of an \u003ccode\u003eif\u003c/code\u003e statement, a \u003ccode\u003efor\u003c/code\u003e statement, a \u003ccode\u003ewhile\u003c/code\u003e, or a\n\u003ccode\u003eswitch\u003c/code\u003e) can be confusing. It assigns the value and checks it at the same time, but it is easily confused with a simple equality check\nwith \u003ccode\u003e\u003d\u003d\u003c/code\u003e and the original intention can be unclear.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n  if (x \u003d getValue()) { // Noncompliant: assigning and checking. Is it on purpose?\n    doSomething();\n  }\n\u003c/pre\u003e\n\u003cp\u003eIt is better to assign before the statement and use the condition for the check only:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n  x \u003d getValue();\n  if (x) {\n    doSomething();\n  }\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThis rule ignores assignments explicitly enclosed in parentheses.\u003c/p\u003e\n\u003cpre\u003e\nwhile ((run \u003d keepRunning())) {\n  //...\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/481\"\u003e481: Assigning instead of Comparing\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/ZNYxBQ\"\u003eEXP45-C. Do not perform assignments in selection statements\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 13.1 - Assignment operators shall not be used in expressions that yield a Boolean value \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 6-2-1 - Assignment operators shall not be used in sub-expressions \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 13.4 - The result of an assignment operator should not be used \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "based-on-misra",
      "cert",
      "cwe",
      "suspicious"
    ],
    "deprecatedKeys": [
      "c:AssignmentInSubExpression"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S1123",
    "name": "Deprecated attributes should include explanations",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003edeprecated\u003c/code\u003e attribute can be applied with or without explanations, but marking something \u003ccode\u003edeprecated\u003c/code\u003e without including\nadvice as to why it’s deprecated or on what to use instead will lead maintainers to waste time trying to figure those things out - every single time\nthe warning is encountered.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n[[deprecated]] // Noncompliant\nvoid foo1();\n\n__attribute__((deprecated)) // Noncompliant\nvoid foo2();\n\n__declspec(deprecated) // Noncompliant\nvoid foo3();\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n[[deprecated(\"use \u0027bar\u0027 instead\")]]\nvoid foo1();\n\n__attribute__((deprecated(\"use \u0027bar\u0027 instead\")))\nvoid foo2();\n\n__declspec(deprecated(\"use \u0027bar\u0027 instead\"))\nvoid foo3();\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe \u003ccode\u003edeprecated\u003c/code\u003e attribute can be applied with or without explanations, but marking something \u003ccode\u003edeprecated\u003c/code\u003e without including\nadvice as to why it’s deprecated or on what to use instead will lead maintainers to waste time trying to figure those things out - every single time\nthe warning is encountered.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n[[deprecated]] // Noncompliant\nvoid foo1();\n\n__attribute__((deprecated)) // Noncompliant\nvoid foo2();\n\n__declspec(deprecated) // Noncompliant\nvoid foo3();\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n[[deprecated(\"use \u0027bar\u0027 instead\")]]\nvoid foo1();\n\n__attribute__((deprecated(\"use \u0027bar\u0027 instead\")))\nvoid foo2();\n\n__declspec(deprecated(\"use \u0027bar\u0027 instead\"))\nvoid foo3();\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "bad-practice",
      "obsolete"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S1244",
    "name": "Floating point numbers should not be tested for equality",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eFloating point math is imprecise because of the challenges of storing such values in a binary representation. Even worse, floating point math is\nnot associative; push a \u003ccode\u003efloat\u003c/code\u003e or a \u003ccode\u003edouble\u003c/code\u003e through a series of simple mathematical operations and the answer will be\ndifferent based on the order of those operation because of the rounding that takes place at each step.\u003c/p\u003e\n\u003cp\u003eEven simple floating point assignments are not simple:\u003c/p\u003e\n\u003cpre\u003e\nfloat f \u003d 0.1; // 0.100000001490116119384765625\ndouble d \u003d 0.1; // 0.1000000000000000055511151231257827021181583404541015625\n\u003c/pre\u003e\n\u003cp\u003e(Results will vary based on compiler and compiler settings.)\u003c/p\u003e\n\u003cp\u003eTherefore, the use of the equality (\u003ccode\u003e\u003d\u003d\u003c/code\u003e) and inequality (\u003ccode\u003e!\u003d\u003c/code\u003e) operators on \u003ccode\u003efloat\u003c/code\u003e or \u003ccode\u003edouble\u003c/code\u003e values\nis very often an error.\u003c/p\u003e\n\u003cp\u003eThe accepted solution is to use or write a float comparison library:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Either using a comparison taking into account the magnitude of the numbers being compared and an epsilon value (which may be based on the\n  capability of the floating point epsilon (FLT_EPSILON)). This comparison will often be absolute for very small values, and relative for larger ones\n  \u003c/li\u003e\n  \u003cli\u003e Or using the notion of \u003ca href\u003d\"https://en.wikipedia.org/wiki/Unit_in_the_last_place\"\u003eunits in the last place\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis rule checks for the use of equality/inequality tests on \u003ccode\u003efloat\u003c/code\u003es, \u003ccode\u003edouble\u003c/code\u003es and \u003ccode\u003elong double\u003c/code\u003es.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nfloat myNumber \u003d 3.146;\nif ( myNumber \u003d\u003d 3.146 ) {  //Noncompliant. Because of floating point imprecision, this will be false\n  // ...\n}\n\nif (myNumber \u0026lt;\u003d 3.146 \u0026amp;\u0026amp; mNumber \u0026gt;\u003d 3.146) { // Noncompliant indirect equality test\n  // ...\n}\n\nif (myNumber \u0026lt; 4 || myNumber \u0026gt; 4) { // Noncompliant indirect inequality test\n  // ...\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 13.3 - Floating-point expressions shall not be tested for equality or inequality. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 6-2-2 - Floating-point expressions shall not be directly or indirectly tested for equality or inequality \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/\"\u003eComparing Floating Point Numbers, 2012\n  Edition\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eFloating point math is imprecise because of the challenges of storing such values in a binary representation. Even worse, floating point math is\nnot associative; push a \u003ccode\u003efloat\u003c/code\u003e or a \u003ccode\u003edouble\u003c/code\u003e through a series of simple mathematical operations and the answer will be\ndifferent based on the order of those operation because of the rounding that takes place at each step.\u003c/p\u003e\n\u003cp\u003eEven simple floating point assignments are not simple:\u003c/p\u003e\n\u003cpre\u003e\nfloat f \u003d 0.1; // 0.100000001490116119384765625\ndouble d \u003d 0.1; // 0.1000000000000000055511151231257827021181583404541015625\n\u003c/pre\u003e\n\u003cp\u003e(Results will vary based on compiler and compiler settings.)\u003c/p\u003e\n\u003cp\u003eTherefore, the use of the equality (\u003ccode\u003e\u003d\u003d\u003c/code\u003e) and inequality (\u003ccode\u003e!\u003d\u003c/code\u003e) operators on \u003ccode\u003efloat\u003c/code\u003e or \u003ccode\u003edouble\u003c/code\u003e values\nis very often an error.\u003c/p\u003e\n\u003cp\u003eThe accepted solution is to use or write a float comparison library:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Either using a comparison taking into account the magnitude of the numbers being compared and an epsilon value (which may be based on the\n  capability of the floating point epsilon (FLT_EPSILON)). This comparison will often be absolute for very small values, and relative for larger ones\n  \u003c/li\u003e\n  \u003cli\u003e Or using the notion of \u003ca href\u003d\"https://en.wikipedia.org/wiki/Unit_in_the_last_place\"\u003eunits in the last place\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis rule checks for the use of equality/inequality tests on \u003ccode\u003efloat\u003c/code\u003es, \u003ccode\u003edouble\u003c/code\u003es and \u003ccode\u003elong double\u003c/code\u003es.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nfloat myNumber \u003d 3.146;\nif ( myNumber \u003d\u003d 3.146 ) {  //Noncompliant. Because of floating point imprecision, this will be false\n  // ...\n}\n\nif (myNumber \u0026lt;\u003d 3.146 \u0026amp;\u0026amp; mNumber \u0026gt;\u003d 3.146) { // Noncompliant indirect equality test\n  // ...\n}\n\nif (myNumber \u0026lt; 4 || myNumber \u0026gt; 4) { // Noncompliant indirect inequality test\n  // ...\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 13.3 - Floating-point expressions shall not be tested for equality or inequality. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 6-2-2 - Floating-point expressions shall not be directly or indirectly tested for equality or inequality \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/\"\u003eComparing Floating Point Numbers, 2012\n  Edition\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "based-on-misra"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S1005",
    "name": "A function should have a single point of exit at the end of the function",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThis is required by IEC 61508, under good programming style.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint function1()\n{\n  return 3;\n}\n\nvoid function2()\n{\n  function1();\n}\n\nint function3(char* ptr) /* Noncompliant; two explicit returns */\n{\n  if (ptr \u003d\u003d NULL) return -1;\n\n  return 7;\n}\n\nvoid function4(char *ptr) /* Noncompliant; two returns, one explicit and one implicit */\n{\n  if (1) return;\n\n  printf(\"hello world!\\n\");\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 14.7 - A function shall have a single point of exit at the end of the function. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 6-6-5 - A function shall have a single point of exit at the end of the function \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 15.5 - A function should have a single point of exit at the end \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThis is required by IEC 61508, under good programming style.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint function1()\n{\n  return 3;\n}\n\nvoid function2()\n{\n  function1();\n}\n\nint function3(char* ptr) /* Noncompliant; two explicit returns */\n{\n  if (ptr \u003d\u003d NULL) return -1;\n\n  return 7;\n}\n\nvoid function4(char *ptr) /* Noncompliant; two returns, one explicit and one implicit */\n{\n  if (1) return;\n\n  printf(\"hello world!\\n\");\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 14.7 - A function shall have a single point of exit at the end of the function. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 6-6-5 - A function shall have a single point of exit at the end of the function \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 15.5 - A function should have a single point of exit at the end \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "based-on-misra",
      "brain-overload"
    ],
    "deprecatedKeys": [
      "c:FunctionSinglePointOfExit"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S2335",
    "name": "Octal and hexadecimal escape sequences should be terminated",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThere is potential for confusion if an octal or hexadecimal escape sequence is immediately followed by other characters. Instead, such sequences\nshall be terminated by either:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The start of another escape sequence. \u003c/li\u003e\n  \u003cli\u003e The end of the character constant or the end of a string literal. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nconst char *s1 \u003d \"\\x41g\";  // Noncompliant\nint c1 \u003d \u0027\\141t\u0027; // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nconst char *s2 \u003d \"\\x41\" \"g\"; // Compliant - terminated by end of literal\nconst char *s3 \u003d \"\\x41\\x67\"; // Compliant - terminated by another escape\nint c2 \u003d \u0027\\141\\t\u0027; // Compliant - terminated by another escape\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2012, 4.1 - Octal and hexadecimal escape sequences shall be terminated \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThere is potential for confusion if an octal or hexadecimal escape sequence is immediately followed by other characters. Instead, such sequences\nshall be terminated by either:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The start of another escape sequence. \u003c/li\u003e\n  \u003cli\u003e The end of the character constant or the end of a string literal. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nconst char *s1 \u003d \"\\x41g\";  // Noncompliant\nint c1 \u003d \u0027\\141t\u0027; // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nconst char *s2 \u003d \"\\x41\" \"g\"; // Compliant - terminated by end of literal\nconst char *s3 \u003d \"\\x41\\x67\"; // Compliant - terminated by another escape\nint c2 \u003d \u0027\\141\\t\u0027; // Compliant - terminated by another escape\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2012, 4.1 - Octal and hexadecimal escape sequences shall be terminated \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "based-on-misra",
      "misra-c2012",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S5271",
    "name": "Functions which do not return should be declared as \"noreturn\"",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "EFFICIENT",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe attribute \u003ccode\u003enoreturn\u003c/code\u003e indicates that a function does not return. This information clarifies the behavior of the function and it\nallows the compiler to do optimizations.\u003c/p\u003e\n\u003cp\u003eIt can also help the compiler (and static analyzer tools, i.e. us) provide better error messages:\u003c/p\u003e\n\u003cpre\u003e\n__attribute__((noreturn)) void f();\n\nint g(int b) {\n  if (b \u003d\u003d 5) {\n    f();\n    printf(\"Hello world\\n\"); // This is dead code, the compiler/static analyzer can now detect it\n    // There is no returned value, but it is fine, the compiler/static analyzer knows not to warn about it\n  } else {\n    return 3;\n  }\n}\n\u003c/pre\u003e\n\u003cp\u003eThis rule detects when the attribute \u003ccode\u003enoreturn\u003c/code\u003e can be added to a function.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid g() {\u0026nbsp;// Noncompliant\n\u0026nbsp;\u0026nbsp;abort();\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n__attribute__((noreturn)) void g() {\u0026nbsp;// or [[noreturn]] for C++\n  abort(); // Compliant\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe attribute \u003ccode\u003enoreturn\u003c/code\u003e indicates that a function does not return. This information clarifies the behavior of the function and it\nallows the compiler to do optimizations.\u003c/p\u003e\n\u003cp\u003eIt can also help the compiler (and static analyzer tools, i.e. us) provide better error messages:\u003c/p\u003e\n\u003cpre\u003e\n__attribute__((noreturn)) void f();\n\nint g(int b) {\n  if (b \u003d\u003d 5) {\n    f();\n    printf(\"Hello world\\n\"); // This is dead code, the compiler/static analyzer can now detect it\n    // There is no returned value, but it is fine, the compiler/static analyzer knows not to warn about it\n  } else {\n    return 3;\n  }\n}\n\u003c/pre\u003e\n\u003cp\u003eThis rule detects when the attribute \u003ccode\u003enoreturn\u003c/code\u003e can be added to a function.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid g() {\u0026nbsp;// Noncompliant\n\u0026nbsp;\u0026nbsp;abort();\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n__attribute__((noreturn)) void g() {\u0026nbsp;// or [[noreturn]] for C++\n  abort(); // Compliant\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "confusing",
      "since-c++11"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S845",
    "name": "Signed and unsigned types should not be mixed in expressions",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eSome signed to unsigned conversions may lead to implementation-defined behavior. This behavior may not be consistent with developer\nexpectations.\u003c/p\u003e\n\u003cp\u003eIf you need to mix signed and unsigned types, you should make your intent explicit by using explicit casts and avoiding implicit casts.\u003c/p\u003e\n\u003cp\u003eThis rule will detect implicit conversions that change the signedness.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid f(int a) {\n  unsigned int b \u003d a; // Noncompliant\n  int c \u003d (a \u0026gt; 0) ? a : b; // Noncompliant\n\n  if (a \u0026gt; b) { // Noncompliant\n    // ...\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid f(int a) {\n  unsigned int b \u003d static_cast\u0026lt;unsigned int\u0026gt;(a); // Compliant\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++ 2008, 5-0-4 \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/U9YxBQ\"\u003eCERT, INT31-C.\u003c/a\u003e - Ensure that integer conversions do not result in lost or\n  misinterpreted data \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eSome signed to unsigned conversions may lead to implementation-defined behavior. This behavior may not be consistent with developer\nexpectations.\u003c/p\u003e\n\u003cp\u003eIf you need to mix signed and unsigned types, you should make your intent explicit by using explicit casts and avoiding implicit casts.\u003c/p\u003e\n\u003cp\u003eThis rule will detect implicit conversions that change the signedness.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid f(int a) {\n  unsigned int b \u003d a; // Noncompliant\n  int c \u003d (a \u0026gt; 0) ? a : b; // Noncompliant\n\n  if (a \u0026gt; b) { // Noncompliant\n    // ...\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid f(int a) {\n  unsigned int b \u003d static_cast\u0026lt;unsigned int\u0026gt;(a); // Compliant\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C++ 2008, 5-0-4 \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/U9YxBQ\"\u003eCERT, INT31-C.\u003c/a\u003e - Ensure that integer conversions do not result in lost or\n  misinterpreted data \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "based-on-misra",
      "cert"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S966",
    "name": "Macros used in preprocessor directives should be defined before use",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eAn attempt to use an undefined identifier may elicit a warning from the preprocessor. Or it may not; the preprocessor may simply assume that the\nundefined token has a value of 0.\u003c/p\u003e\n\u003cp\u003eTherefore macro identifiers should not be used in preprocessor directives until after they have been defined, and this limited usage should be\nenforced with the use of definition tests.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#if x \u0026gt; 0  /* x assumed to be zero if not defined */\n#include SOMETHING_IMPORTANT\n#endif\n\n#ifdef y  /* Okay; y is not evaluated */\n#if y \u0026gt; 0 /* Okay; y must be defined to reach this point */\n...\n#endif\n#endif\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#define x 10\n...\n#if x \u0026gt; 0\n#include SOMETHING_IMPORTANT\n#endif\n\n#if defined ( y ) \u0026amp;\u0026amp; ( y \u0026gt; 0 )  /* more compact form, same result as before */\n...\n#endif\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 19.11 - All macro identifiers in preprocessor directives shall be defined before use, except in #ifdef and #ifndef preprocessor\n  directives and the defined() operator. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 20.9 - All identifiers used in the controlling expression of #if or #elif preprocessing directives shall be #define’d before\n  evaluation \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eAn attempt to use an undefined identifier may elicit a warning from the preprocessor. Or it may not; the preprocessor may simply assume that the\nundefined token has a value of 0.\u003c/p\u003e\n\u003cp\u003eTherefore macro identifiers should not be used in preprocessor directives until after they have been defined, and this limited usage should be\nenforced with the use of definition tests.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#if x \u0026gt; 0  /* x assumed to be zero if not defined */\n#include SOMETHING_IMPORTANT\n#endif\n\n#ifdef y  /* Okay; y is not evaluated */\n#if y \u0026gt; 0 /* Okay; y must be defined to reach this point */\n...\n#endif\n#endif\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#define x 10\n...\n#if x \u0026gt; 0\n#include SOMETHING_IMPORTANT\n#endif\n\n#if defined ( y ) \u0026amp;\u0026amp; ( y \u0026gt; 0 )  /* more compact form, same result as before */\n...\n#endif\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 19.11 - All macro identifiers in preprocessor directives shall be defined before use, except in #ifdef and #ifndef preprocessor\n  directives and the defined() operator. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 20.9 - All identifiers used in the controlling expression of #if or #elif preprocessing directives shall be #define’d before\n  evaluation \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "based-on-misra",
      "preprocessor"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S967",
    "name": "There shall be at most one occurrence of the # or ## operators in a single macro definition",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eBecause the evaluation order of \u003ccode\u003e#\u003c/code\u003e and \u003ccode\u003e##\u003c/code\u003e are not specified, the results of using them both in the same macro could be\nunpredictable. Therefore macros should contain at most once instance of either \u003ccode\u003e#\u003c/code\u003e or \u003ccode\u003e##\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#define NonCompliant(a, b)  # a ## b\nint main() {\n  std::cout \u0026lt;\u0026lt; NonCompliant(Hello, World);\n}\n\u003c/pre\u003e\n\u003cp\u003eThe result of this code is unspecified. It will either print \"HelloWorld\" or trigger a compilation error. If ## is evaluated first this will print\nHelloWorld. If # is evaluated first this will cause a compilation error telling that\u0026nbsp;\u003cstrong\u003e\"Hello\"World\u003c/strong\u003e is not a valid preprocessor\ntoken.\u003c/p\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#define Stringfy(a) #a\n#define Compliant(a, b)  Stringfy(a##b)\n\nint main(){\n  std::cout \u0026lt;\u0026lt; Compliant(Hello, World);\n}\n\u003c/pre\u003e\n\u003cp\u003eThis example will always print \"HelloWorld\".\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 19.12 \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2008, 16-3-1 \u003c/li\u003e\n  \u003cli\u003e Related: MISRA C:2012, 20.11 \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eBecause the evaluation order of \u003ccode\u003e#\u003c/code\u003e and \u003ccode\u003e##\u003c/code\u003e are not specified, the results of using them both in the same macro could be\nunpredictable. Therefore macros should contain at most once instance of either \u003ccode\u003e#\u003c/code\u003e or \u003ccode\u003e##\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#define NonCompliant(a, b)  # a ## b\nint main() {\n  std::cout \u0026lt;\u0026lt; NonCompliant(Hello, World);\n}\n\u003c/pre\u003e\n\u003cp\u003eThe result of this code is unspecified. It will either print \"HelloWorld\" or trigger a compilation error. If ## is evaluated first this will print\nHelloWorld. If # is evaluated first this will cause a compilation error telling that\u0026nbsp;\u003cstrong\u003e\"Hello\"World\u003c/strong\u003e is not a valid preprocessor\ntoken.\u003c/p\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#define Stringfy(a) #a\n#define Compliant(a, b)  Stringfy(a##b)\n\nint main(){\n  std::cout \u0026lt;\u0026lt; Compliant(Hello, World);\n}\n\u003c/pre\u003e\n\u003cp\u003eThis example will always print \"HelloWorld\".\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 19.12 \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2008, 16-3-1 \u003c/li\u003e\n  \u003cli\u003e Related: MISRA C:2012, 20.11 \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "misra-c++2008",
      "misra-c2004",
      "misra-c2012",
      "preprocessor"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S5270",
    "name": "User-defined types should not be passed as variadic arguments",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eVariadic arguments allow a function to accept any number of arguments (in this rule, we are not talking about variadic templates, but about\nfunctions with ellipses). But these arguments have to respect some criteria to be handled properly.\u003c/p\u003e\n\u003cp\u003eThe standard imposes some requirements on the class types that can be passed as variadic arguments, and those requirements vary according to the\nC++ standard version in use:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Before C++11, the standard only allows POD types to be used as variadic arguments. \u003c/li\u003e\n  \u003cli\u003e In C++11, the rules are relaxed such that any class type with an eligible non-trivial copy constructor, an eligible non-trivial move\n  constructor, or a non-trivial destructor can be used in variadic arguments. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe rule detects any violations of these requirements since they can trigger undefined behavior.\u003c/p\u003e\n\u003cp\u003eAdditionally, since using an incorrect type to access the passed parameter within the variadic function can lead to undefined behavior, the rule\ngoes a step further and reports all cases when class types are passed as variadic arguments. The rationale is that, most likely, the user forgot to\ncall a method on the object being passed (\u003ccode\u003estd::string_view::data()\u003c/code\u003e for example) that would get a member of a built-in type.\u003c/p\u003e\n\u003cp\u003eWhen in need to pass class types to functions that take a variable number of arguments, consider using modern type-safe alternatives like C++11\nparameter packs instead of variadic functions.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid my_log(const char* format, ...);\n\nvoid f() {\n  std::string someStr \u003d \"foo\";\n  my_log(\"%s\", someStr);  // Noncompliant; the C++11 standard requires types passed as variadic arguments to have a trivial copy constructor. The user probably meant to pass someStr.c_str() here\n\n  std::string_view someStrView \u003d \"bar\";\n  my_log(\"%s\", someStrView); // Noncompliant; the user probably meant to pass someText.data()\n  std::chrono::duration\u0026lt;float\u0026gt; duration;\n  my_log(\"%f\", duration); // Noncompliant, the user probably meant to pass duration.count()\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid my_log(const char* format, ...);\n\nvoid f() {\n  std::string someStr \u003d \"foo\";\n  my_log(\"%s\", someStr.c_str());  // Compliant\n\n  std::string_view someStrView \u003d \"bar\";\n  my_log(\"%s\", someStrView.data()); // Compliant\n  std::chrono::duration\u0026lt;float\u0026gt; duration;\n  my_log(\"%f\", duration.count()); // Compliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThe rule doesn’t report an issue in the following cases:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e When the called variadic function doesn’t have any non-variadic parameters. This is a common pattern when the function is used as a catch-all\n  net for an overload set. This is also guaranteed to be safe since there is no portable to access the passed arguments. \u003c/li\u003e\n  \u003cli\u003e When the called variadic function is known to accept a class type object as a variadic argument (e.g., the \u003ccode\u003esemctl\u003c/code\u003e system call).\n  \u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\n// This variadic function is used as a catch-all net to terminate recursion\nstd::size_t elementsCount(...) { return 1u; }\n\ntemplate\u0026lt;typename T\u0026gt;\nstd::size_t elementsCount(const std::vector\u0026lt;T\u0026gt;\u0026amp; vec) {\n  // Sum the elements of all nested vectors recursively\n  return std::accumulate(vec.begin(), vec.end(), 0u, [] (const std::size_t count, const T\u0026amp; element) {\n    return count + elementsCount(element); // Compliant (the callee doesn\u0027t have non-variadic arguments)\n  });\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 16.1 - Functions shall not be defined with a variable number of arguments. \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/5ns-BQ\"\u003eCERT, DCL50-CPP.\u003c/a\u003e - Do not define a C-style variadic function \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#-es34-dont-define-a-c-style-variadic-function\"\u003eES.34: Don’t\n  define a (C-style) variadic function\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:c:S2275} and {rule:c:S3457} are rules that specialize in detecting type mismatches with format strings. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eVariadic arguments allow a function to accept any number of arguments (in this rule, we are not talking about variadic templates, but about\nfunctions with ellipses). But these arguments have to respect some criteria to be handled properly.\u003c/p\u003e\n\u003cp\u003eThe standard imposes some requirements on the class types that can be passed as variadic arguments, and those requirements vary according to the\nC++ standard version in use:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Before C++11, the standard only allows POD types to be used as variadic arguments. \u003c/li\u003e\n  \u003cli\u003e In C++11, the rules are relaxed such that any class type with an eligible non-trivial copy constructor, an eligible non-trivial move\n  constructor, or a non-trivial destructor can be used in variadic arguments. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe rule detects any violations of these requirements since they can trigger undefined behavior.\u003c/p\u003e\n\u003cp\u003eAdditionally, since using an incorrect type to access the passed parameter within the variadic function can lead to undefined behavior, the rule\ngoes a step further and reports all cases when class types are passed as variadic arguments. The rationale is that, most likely, the user forgot to\ncall a method on the object being passed (\u003ccode\u003estd::string_view::data()\u003c/code\u003e for example) that would get a member of a built-in type.\u003c/p\u003e\n\u003cp\u003eWhen in need to pass class types to functions that take a variable number of arguments, consider using modern type-safe alternatives like C++11\nparameter packs instead of variadic functions.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid my_log(const char* format, ...);\n\nvoid f() {\n  std::string someStr \u003d \"foo\";\n  my_log(\"%s\", someStr);  // Noncompliant; the C++11 standard requires types passed as variadic arguments to have a trivial copy constructor. The user probably meant to pass someStr.c_str() here\n\n  std::string_view someStrView \u003d \"bar\";\n  my_log(\"%s\", someStrView); // Noncompliant; the user probably meant to pass someText.data()\n  std::chrono::duration\u0026lt;float\u0026gt; duration;\n  my_log(\"%f\", duration); // Noncompliant, the user probably meant to pass duration.count()\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid my_log(const char* format, ...);\n\nvoid f() {\n  std::string someStr \u003d \"foo\";\n  my_log(\"%s\", someStr.c_str());  // Compliant\n\n  std::string_view someStrView \u003d \"bar\";\n  my_log(\"%s\", someStrView.data()); // Compliant\n  std::chrono::duration\u0026lt;float\u0026gt; duration;\n  my_log(\"%f\", duration.count()); // Compliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThe rule doesn’t report an issue in the following cases:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e When the called variadic function doesn’t have any non-variadic parameters. This is a common pattern when the function is used as a catch-all\n  net for an overload set. This is also guaranteed to be safe since there is no portable to access the passed arguments. \u003c/li\u003e\n  \u003cli\u003e When the called variadic function is known to accept a class type object as a variadic argument (e.g., the \u003ccode\u003esemctl\u003c/code\u003e system call).\n  \u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\n// This variadic function is used as a catch-all net to terminate recursion\nstd::size_t elementsCount(...) { return 1u; }\n\ntemplate\u0026lt;typename T\u0026gt;\nstd::size_t elementsCount(const std::vector\u0026lt;T\u0026gt;\u0026amp; vec) {\n  // Sum the elements of all nested vectors recursively\n  return std::accumulate(vec.begin(), vec.end(), 0u, [] (const std::size_t count, const T\u0026amp; element) {\n    return count + elementsCount(element); // Compliant (the callee doesn\u0027t have non-variadic arguments)\n  });\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 16.1 - Functions shall not be defined with a variable number of arguments. \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/5ns-BQ\"\u003eCERT, DCL50-CPP.\u003c/a\u003e - Do not define a C-style variadic function \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#-es34-dont-define-a-c-style-variadic-function\"\u003eES.34: Don’t\n  define a (C-style) variadic function\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:c:S2275} and {rule:c:S3457} are rules that specialize in detecting type mismatches with format strings. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "based-on-misra",
      "cert",
      "cppcoreguidelines",
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S841",
    "name": "\"enum\" members other than the first one should not be explicitly initialized unless all members are explicitly initialized",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eIf an enumerator list is given with no explicit initialization of members, then C/C++ allocates a sequence of integers starting at zero for the\nfirst element and increasing by one for each subsequent element.\u003c/p\u003e\n\u003cp\u003eAn explicit initialization of the first element, as permitted by this rule, forces the allocation of integers to start at the given value. When\nadopting this approach it is essential to ensure that the initialization value used is small enough that no subsequent value in the list will exceed\nthe \u003ccode\u003eint\u003c/code\u003e storage used by enumeration constants.\u003c/p\u003e\n\u003cp\u003eExplicit initialization of all items in the list, which is also permissible, prevents the mixing of automatic and manual allocation, which is error\nprone.\u003c/p\u003e\n\u003cp\u003eHowever, it is then the responsibility of the developer to ensure that all values are in the required range, and that values are not\nunintentionally duplicated.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nenum color { red \u003d 3, blue, green, yellow \u003d 5 }; // Noncompliant; both green and yellow \u003d 5\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nenum color { red \u003d 3, blue \u003d 4, green \u003d 5, yellow \u003d 5 }; // Compliant\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 9.3 - In an enumerator list, the \"\u003d\" construct shall not be used to explicitly initialize members other than the first, unless\n  all items are explicitly initialized. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 8-5-3 - In an enumerator list, the \u003d construct shall not be used to explicitly initialize members other than the first, unless\n  all items are explicitly initialized. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eIf an enumerator list is given with no explicit initialization of members, then C/C++ allocates a sequence of integers starting at zero for the\nfirst element and increasing by one for each subsequent element.\u003c/p\u003e\n\u003cp\u003eAn explicit initialization of the first element, as permitted by this rule, forces the allocation of integers to start at the given value. When\nadopting this approach it is essential to ensure that the initialization value used is small enough that no subsequent value in the list will exceed\nthe \u003ccode\u003eint\u003c/code\u003e storage used by enumeration constants.\u003c/p\u003e\n\u003cp\u003eExplicit initialization of all items in the list, which is also permissible, prevents the mixing of automatic and manual allocation, which is error\nprone.\u003c/p\u003e\n\u003cp\u003eHowever, it is then the responsibility of the developer to ensure that all values are in the required range, and that values are not\nunintentionally duplicated.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nenum color { red \u003d 3, blue, green, yellow \u003d 5 }; // Noncompliant; both green and yellow \u003d 5\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nenum color { red \u003d 3, blue \u003d 4, green \u003d 5, yellow \u003d 5 }; // Compliant\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 9.3 - In an enumerator list, the \"\u003d\" construct shall not be used to explicitly initialize members other than the first, unless\n  all items are explicitly initialized. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 8-5-3 - In an enumerator list, the \u003d construct shall not be used to explicitly initialize members other than the first, unless\n  all items are explicitly initialized. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "based-on-misra"
    ],
    "deprecatedKeys": [
      "c:EnumPartialInitialization"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S5276",
    "name": "Implicit casts should not lower precision",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eA narrowing conversion is an implicit conversion to a destination type that cannot represent all values from the source type.\u003c/p\u003e\n\u003cp\u003eIt can be a floating-point type converted to an integer type, or a type with a larger range of values converted to a type with a smaller range.\u003c/p\u003e\n\u003cp\u003eNarrowing conversions can lead to a loss of information and because they are implicit, they are not always obvious.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nint a \u003d 2.1f; // Noncompliant: loss of floating-point precision\n\nlong double f();\ndouble d \u003d 0;\nd +\u003d f(); // Noncompliant: smaller range of values\n\u003c/pre\u003e\n\u003cp\u003eNarrowing conversions should be fixed by either using a destination type that can represent all the source values or by using an explicit\nconversion:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\ndouble a \u003d 2.1f; // Compliant: double can represent all floats\n\nlong double f();\ndouble d \u003d 0;\nd +\u003d static_cast\u0026lt;double\u0026gt;(f()); // Compliant: the intent is clear\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eA narrowing conversion is an implicit conversion to a destination type that cannot represent all values from the source type.\u003c/p\u003e\n\u003cp\u003eIt can be a floating-point type converted to an integer type, or a type with a larger range of values converted to a type with a smaller range.\u003c/p\u003e\n\u003cp\u003eNarrowing conversions can lead to a loss of information and because they are implicit, they are not always obvious.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nint a \u003d 2.1f; // Noncompliant: loss of floating-point precision\n\nlong double f();\ndouble d \u003d 0;\nd +\u003d f(); // Noncompliant: smaller range of values\n\u003c/pre\u003e\n\u003cp\u003eNarrowing conversions should be fixed by either using a destination type that can represent all the source values or by using an explicit\nconversion:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\ndouble a \u003d 2.1f; // Compliant: double can represent all floats\n\nlong double f();\ndouble d \u003d 0;\nd +\u003d static_cast\u0026lt;double\u0026gt;(f()); // Compliant: the intent is clear\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S5273",
    "name": "Appropriate size arguments should be passed to \"strncat\" and \"strlcpy\"",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003cp\u003eSize argument should be based on the size of the destination buffer to to prevent buffer overflows.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe string manipulation functions \u003ccode\u003estrncat\u003c/code\u003e, \u003ccode\u003estrlcat\u003c/code\u003e and \u003ccode\u003estrlcpy\u003c/code\u003e require a size argument that describes how\nmany bytes from the source buffer are used at most. In many situations the size of the source buffer is unknown, which is why the size argument for\nthese functions should be based on the size of the destination buffer. This helps to prevent buffer overflows.\u003c/p\u003e\n\u003cp\u003eNote that \u003ccode\u003estrncat\u003c/code\u003e always adds a terminating null character at the end of the appended characters; therefore, the size argument should\nbe smaller than the size of the destination to leave enough space for the null character.\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;string.h\u0026gt;\n\nvoid foo(const char *src) {\n  char dst[10] \u003d {0};\n  strlcpy(dst, src, sizeof(src)); // Noncompliant: size of destination should be used.\n  printf(\"%s\", dst);\n}\n\u003c/pre\u003e\n\u003ch2\u003eWhat is the potential impact?\u003c/h2\u003e\n\u003cp\u003eBy using the source buffer’s size to determine the size argument for \u003ccode\u003estrncat\u003c/code\u003e, \u003ccode\u003estrlcat\u003c/code\u003e or \u003ccode\u003estrlcpy\u003c/code\u003e, the\nprogram becomes vulnerable to buffer overflows which pose a security risk.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eTo prevent potential buffer overflows, use the size of the destination buffer to determine the correct size argument for \u003ccode\u003estrncat\u003c/code\u003e,\n\u003ccode\u003estrlcat\u003c/code\u003e and \u003ccode\u003estrlcpy\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eGoing the extra mile\u003c/h3\u003e\n\u003cp\u003eBuffer overflows occur when a program writes data beyond the boundaries of a buffer and can lead to memory corruption and potential security\nvulnerabilities. Attackers can use buffer overflows to overwrite critical data, execute arbitrary code, or gain unauthorized access to a system. To\nmitigate this risk, developers must carefully manage buffer sizes (, use secure coding practices, and employ techniques like input validation and\nbounds checking).\u003c/p\u003e\n\u003cp\u003eIn C++, manual string, i.e., buffer manipulations are considered a code smell. Instead, the \u003ccode\u003estd::string\u003c/code\u003e type should be used to manage\nbuffers, which guarantees safe buffer manipulations.\u003c/p\u003e\n\u003cp\u003eInstead of manually concatenating two buffers using \u003ccode\u003estrncat\u003c/code\u003e, for instance, \u003ccode\u003estd::string\u003c/code\u003e allows this operation to be\nperformed in a much more convenient manner as shown in the following code:\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;string\u0026gt;\n\nvoid buz(std::string const \u0026amp;s) {\n  std::string t \u003d \"Hello, \" + s;\n  std::cout \u0026lt;\u0026lt; t \u0026lt;\u0026lt; \u0027\\n\u0027;\n}\n\u003c/pre\u003e\n\u003cp\u003eIn addition, the \u003ccode\u003estd::format\u003c/code\u003e function allows one to format strings according to a user-specified format and returns the result as a\nstring as shown in what follows:\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;format\u0026gt;\n#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;string\u0026gt;\n\nvoid tar(std::string const \u0026amp;s) {\n  std::string t \u003d std::format(\"Hello, World! Greetings {}\\n\", s);\n  std::cout \u0026lt;\u0026lt; t \u0026lt;\u0026lt; \u0027\\n\u0027;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;string.h\u0026gt;\n\nvoid foo(const char *src) {\n  char dst[10] \u003d {0};\n  strlcpy(dst, src, sizeof(src)); // Noncompliant: size of `dst` should be used.\n  printf(\"%s\", dst);\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;string.h\u0026gt;\n\nvoid foo(const char *src) {\n  char dst[10] \u003d {0};\n  // `strlcpy` copies up to size - 1 characters from the NUL-terminated string\n  // src to dst, NUL-terminating the result.\n  strlcpy(dst, src, sizeof(dst)); // Compliant: using `dst`\u0027s size avoid prevents buffer overflows.\n  printf(\"%s\", dst);\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;string.h\u0026gt;\n\nvoid bar(const char *src) {\n  char dst[256] \u003d \"Hello, \";\n  strncat(dst, src, sizeof(src)); // Noncompliant: incorrect size used.\n  printf(\"%s\\n\", dst);\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;string.h\u0026gt;\n\nvoid bar(const char *src) {\n  char dst[256] \u003d \"Hello, \";\n  // `strncat` always adds a terminating null character at the end of the appended\n  // characters, which is the reason for the `- 1`.\n  strncat(dst, src, sizeof(dst) - strlen(dst) - 1); // Compliant: uses only `dst` to compute size.\n  printf(\"%s\\n\", dst);\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eConference presentations\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CppCon 2018 - \u003ca href\u003d\"https://www.youtube.com/watch?v\u003d0S0QgQd75Sw\u0026amp;ab_channel\u003dCppCon\"\u003eSoftware Vulnerabilities in C and C++\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca\n  href\u003d\"https://wiki.sei.cmu.edu/confluence/display/c/STR31-C.+Guarantee+that+storage+for+strings+has+sufficient+space+for+character+data+and+the+null+terminator\"\u003eSTR31-C. Guarantee that storage for strings has sufficient space for character data and the null terminator\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/121.html\"\u003e121 Stack-based Buffer Overflow\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/122.html\"\u003e122 Heap-based Buffer Overflow\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/676.html\"\u003e676 Use of Potentially Dangerous Function\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eSize argument should be based on the size of the destination buffer to to prevent buffer overflows.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe string manipulation functions \u003ccode\u003estrncat\u003c/code\u003e, \u003ccode\u003estrlcat\u003c/code\u003e and \u003ccode\u003estrlcpy\u003c/code\u003e require a size argument that describes how\nmany bytes from the source buffer are used at most. In many situations the size of the source buffer is unknown, which is why the size argument for\nthese functions should be based on the size of the destination buffer. This helps to prevent buffer overflows.\u003c/p\u003e\n\u003cp\u003eNote that \u003ccode\u003estrncat\u003c/code\u003e always adds a terminating null character at the end of the appended characters; therefore, the size argument should\nbe smaller than the size of the destination to leave enough space for the null character.\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;string.h\u0026gt;\n\nvoid foo(const char *src) {\n  char dst[10] \u003d {0};\n  strlcpy(dst, src, sizeof(src)); // Noncompliant: size of destination should be used.\n  printf(\"%s\", dst);\n}\n\u003c/pre\u003e\n\u003ch2\u003eWhat is the potential impact?\u003c/h2\u003e\n\u003cp\u003eBy using the source buffer’s size to determine the size argument for \u003ccode\u003estrncat\u003c/code\u003e, \u003ccode\u003estrlcat\u003c/code\u003e or \u003ccode\u003estrlcpy\u003c/code\u003e, the\nprogram becomes vulnerable to buffer overflows which pose a security risk.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eTo prevent potential buffer overflows, use the size of the destination buffer to determine the correct size argument for \u003ccode\u003estrncat\u003c/code\u003e,\n\u003ccode\u003estrlcat\u003c/code\u003e and \u003ccode\u003estrlcpy\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eGoing the extra mile\u003c/h3\u003e\n\u003cp\u003eBuffer overflows occur when a program writes data beyond the boundaries of a buffer and can lead to memory corruption and potential security\nvulnerabilities. Attackers can use buffer overflows to overwrite critical data, execute arbitrary code, or gain unauthorized access to a system. To\nmitigate this risk, developers must carefully manage buffer sizes (, use secure coding practices, and employ techniques like input validation and\nbounds checking).\u003c/p\u003e\n\u003cp\u003eIn C++, manual string, i.e., buffer manipulations are considered a code smell. Instead, the \u003ccode\u003estd::string\u003c/code\u003e type should be used to manage\nbuffers, which guarantees safe buffer manipulations.\u003c/p\u003e\n\u003cp\u003eInstead of manually concatenating two buffers using \u003ccode\u003estrncat\u003c/code\u003e, for instance, \u003ccode\u003estd::string\u003c/code\u003e allows this operation to be\nperformed in a much more convenient manner as shown in the following code:\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;string\u0026gt;\n\nvoid buz(std::string const \u0026amp;s) {\n  std::string t \u003d \"Hello, \" + s;\n  std::cout \u0026lt;\u0026lt; t \u0026lt;\u0026lt; \u0027\\n\u0027;\n}\n\u003c/pre\u003e\n\u003cp\u003eIn addition, the \u003ccode\u003estd::format\u003c/code\u003e function allows one to format strings according to a user-specified format and returns the result as a\nstring as shown in what follows:\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;format\u0026gt;\n#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;string\u0026gt;\n\nvoid tar(std::string const \u0026amp;s) {\n  std::string t \u003d std::format(\"Hello, World! Greetings {}\\n\", s);\n  std::cout \u0026lt;\u0026lt; t \u0026lt;\u0026lt; \u0027\\n\u0027;\n}\n\u003c/pre\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;string.h\u0026gt;\n\nvoid foo(const char *src) {\n  char dst[10] \u003d {0};\n  strlcpy(dst, src, sizeof(src)); // Noncompliant: size of `dst` should be used.\n  printf(\"%s\", dst);\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;string.h\u0026gt;\n\nvoid foo(const char *src) {\n  char dst[10] \u003d {0};\n  // `strlcpy` copies up to size - 1 characters from the NUL-terminated string\n  // src to dst, NUL-terminating the result.\n  strlcpy(dst, src, sizeof(dst)); // Compliant: using `dst`\u0027s size avoid prevents buffer overflows.\n  printf(\"%s\", dst);\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;string.h\u0026gt;\n\nvoid bar(const char *src) {\n  char dst[256] \u003d \"Hello, \";\n  strncat(dst, src, sizeof(src)); // Noncompliant: incorrect size used.\n  printf(\"%s\\n\", dst);\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;string.h\u0026gt;\n\nvoid bar(const char *src) {\n  char dst[256] \u003d \"Hello, \";\n  // `strncat` always adds a terminating null character at the end of the appended\n  // characters, which is the reason for the `- 1`.\n  strncat(dst, src, sizeof(dst) - strlen(dst) - 1); // Compliant: uses only `dst` to compute size.\n  printf(\"%s\\n\", dst);\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eConference presentations\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CppCon 2018 - \u003ca href\u003d\"https://www.youtube.com/watch?v\u003d0S0QgQd75Sw\u0026amp;ab_channel\u003dCppCon\"\u003eSoftware Vulnerabilities in C and C++\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca\n  href\u003d\"https://wiki.sei.cmu.edu/confluence/display/c/STR31-C.+Guarantee+that+storage+for+strings+has+sufficient+space+for+character+data+and+the+null+terminator\"\u003eSTR31-C. Guarantee that storage for strings has sufficient space for character data and the null terminator\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/121.html\"\u003e121 Stack-based Buffer Overflow\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/122.html\"\u003e122 Heap-based Buffer Overflow\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/676.html\"\u003e676 Use of Potentially Dangerous Function\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "suspicious",
      "symbolic-execution"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S960",
    "name": "Function-like macros should not be used",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eIt is tempting to treat function-like macros as functions, but the two things work differently. For instance, the use of functions offers parameter\ntype-checking, while the use of macros does not. Additionally, with macros, there is the potential for a macro to be evaluated multiple times. In\ngeneral, functions offer a safer, more robust mechanism than function-like macros, and that safety usually outweighs the speed advantages offered by\nmacros. Therefore functions should be used instead when possible.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#define CUBE (X) ((X) * (X) * (X)) // Noncompliant\n\nvoid func(void) {\n  int i \u003d 2;\n  int a \u003d CUBE(++i); // Noncompliant. Expands to: int a \u003d ((++i) * (++i) * (++i))\n  // ...\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\ninline int cube(int i) {\n  return i * i * i;\n}\n\nvoid func(void) {\n  int i \u003d 2;\n  int a \u003d cube(++i); // yields 27\n  // ...\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 19.7 - A function should be used in preference to a function-like macro. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 16-0-4 - Function-like macros shall not be defined. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, Dir. 4.9 - A function should be used in preference to a function-like macro where they are interchangeable \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/INcxBQ\"\u003eCERT, PRE00-C.\u003c/a\u003e - Prefer inline or static functions to function-like macros \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es31-dont-use-macros-for-constants-or-functions\"\u003eES.31: Don’t\n  use macros for constants or \"functions\"\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eIt is tempting to treat function-like macros as functions, but the two things work differently. For instance, the use of functions offers parameter\ntype-checking, while the use of macros does not. Additionally, with macros, there is the potential for a macro to be evaluated multiple times. In\ngeneral, functions offer a safer, more robust mechanism than function-like macros, and that safety usually outweighs the speed advantages offered by\nmacros. Therefore functions should be used instead when possible.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#define CUBE (X) ((X) * (X) * (X)) // Noncompliant\n\nvoid func(void) {\n  int i \u003d 2;\n  int a \u003d CUBE(++i); // Noncompliant. Expands to: int a \u003d ((++i) * (++i) * (++i))\n  // ...\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\ninline int cube(int i) {\n  return i * i * i;\n}\n\nvoid func(void) {\n  int i \u003d 2;\n  int a \u003d cube(++i); // yields 27\n  // ...\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 19.7 - A function should be used in preference to a function-like macro. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 16-0-4 - Function-like macros shall not be defined. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, Dir. 4.9 - A function should be used in preference to a function-like macro where they are interchangeable \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/INcxBQ\"\u003eCERT, PRE00-C.\u003c/a\u003e - Prefer inline or static functions to function-like macros \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es31-dont-use-macros-for-constants-or-functions\"\u003eES.31: Don’t\n  use macros for constants or \"functions\"\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "bad-practice",
      "based-on-misra",
      "cert",
      "cppcoreguidelines",
      "preprocessor"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S961",
    "name": "Function-like macros should not be invoked without all of their arguments",
    "defaultSeverity": "BLOCKER",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eBefore compilation, the preprocessor replaces macros with the code they expand to. The resulting code may be invalid when a function-like macro is\ninvoked without all its arguments, which can cause the program to fail to compile or to behave unexpectedly at runtime.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/preprocessor/replace\"\u003eReplacing text macros\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/translation_phases#Phase_3\"\u003ePhases of translation: Phase 3\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e MISRA C:2004, 19.8 - A function-like macro shall not be invoked without all of its arguments. \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/628\"\u003eCWE\u003c/a\u003e - CWE-628: Function Call with Incorrectly Specified Arguments \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eBefore compilation, the preprocessor replaces macros with the code they expand to. The resulting code may be invalid when a function-like macro is\ninvoked without all its arguments, which can cause the program to fail to compile or to behave unexpectedly at runtime.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/preprocessor/replace\"\u003eReplacing text macros\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/translation_phases#Phase_3\"\u003ePhases of translation: Phase 3\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e MISRA C:2004, 19.8 - A function-like macro shall not be invoked without all of its arguments. \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/628\"\u003eCWE\u003c/a\u003e - CWE-628: Function Call with Incorrectly Specified Arguments \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "based-on-misra",
      "cwe",
      "preprocessor"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S1905",
    "name": "Redundant casts should not be used",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eCasting expressions are utilized to convert one data type to another, such as transforming an integer into a string. This is especially crucial in\nstrongly typed languages like C, C++, C#, Java, Python, and others.\u003c/p\u003e\n\u003cp\u003eHowever, there are instances where casting expressions are not needed. These include situations like:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e casting a variable to its own type \u003c/li\u003e\n  \u003cli\u003e casting a subclass to a parent class (in the case of polymorphism) \u003c/li\u003e\n  \u003cli\u003e the programming language is capable of automatically converting the given type to another \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThese scenarios are considered unnecessary casting expressions. They can complicate the code and make it more difficult to understand, without\noffering any advantages.\u003c/p\u003e\n\u003cp\u003eAs a result, it’s generally advised to avoid unnecessary casting expressions. Instead, rely on the language’s type system to ensure type safety and\ncode clarity.\u003c/p\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eIn some rare cases, a redundant cast might be justifiable. For example, when casting from platform dependant types: your cast might be redundant on\none platform but not on the others.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eTo fix your code, remove the unnecessary casting expression.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nint example(int i) {\n  int result \u003d static_cast\u0026lt;int\u0026gt;(i + 42); // Noncompliant\n  return (int) result; // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nint example(int i) {\n int result \u003d i + 42;\n return result;\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Wikipedia - \u003ca href\u003d\"https://en.wikipedia.org/wiki/Type_conversion\"\u003eType Conversion\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e Wikipedia - \u003ca href\u003d\"https://en.wikipedia.org/wiki/Strong_and_weak_typing\"\u003eStrong and Weak Typing\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e Wikipedia - \u003ca href\u003d\"https://en.wikipedia.org/wiki/Polymorphism_(computer_science)\"\u003e Polymorphism (Computer Science)\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eCasting expressions are utilized to convert one data type to another, such as transforming an integer into a string. This is especially crucial in\nstrongly typed languages like C, C++, C#, Java, Python, and others.\u003c/p\u003e\n\u003cp\u003eHowever, there are instances where casting expressions are not needed. These include situations like:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e casting a variable to its own type \u003c/li\u003e\n  \u003cli\u003e casting a subclass to a parent class (in the case of polymorphism) \u003c/li\u003e\n  \u003cli\u003e the programming language is capable of automatically converting the given type to another \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThese scenarios are considered unnecessary casting expressions. They can complicate the code and make it more difficult to understand, without\noffering any advantages.\u003c/p\u003e\n\u003cp\u003eAs a result, it’s generally advised to avoid unnecessary casting expressions. Instead, rely on the language’s type system to ensure type safety and\ncode clarity.\u003c/p\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eIn some rare cases, a redundant cast might be justifiable. For example, when casting from platform dependant types: your cast might be redundant on\none platform but not on the others.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eTo fix your code, remove the unnecessary casting expression.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nint example(int i) {\n  int result \u003d static_cast\u0026lt;int\u0026gt;(i + 42); // Noncompliant\n  return (int) result; // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nint example(int i) {\n int result \u003d i + 42;\n return result;\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Wikipedia - \u003ca href\u003d\"https://en.wikipedia.org/wiki/Type_conversion\"\u003eType Conversion\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e Wikipedia - \u003ca href\u003d\"https://en.wikipedia.org/wiki/Strong_and_weak_typing\"\u003eStrong and Weak Typing\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e Wikipedia - \u003ca href\u003d\"https://en.wikipedia.org/wiki/Polymorphism_(computer_science)\"\u003e Polymorphism (Computer Science)\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "clumsy",
      "redundant"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:M23_039",
    "name": "\"#include\" directives should only be preceded by preprocessor directives or comments",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 19.0.3\u003c/p\u003e\n\u003cp\u003eCategory: Advisory\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eThis rule shall be applied to the contents of a file before preprocessing occurs.\u003c/p\u003e\n\u003cp\u003eFor purposes of this rule, the tokens used to open and close a \u003cem\u003elinkage-specification\u003c/em\u003e are ignored.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eTo aid code readability, all of the \u003ccode\u003e#include\u003c/code\u003e directives in a particular code file should be grouped together near the top of the\nfile.\u003c/p\u003e\n\u003cp\u003eAdditionally, using \u003ccode\u003e#include\u003c/code\u003e to include a \u003cem\u003estandard header file\u003c/em\u003e within a declaration or definition, or using part of the C++\nStandard Library before the inclusion of the related \u003cem\u003estandard header file\u003c/em\u003e results in \u003cem\u003eundefined behaviour\u003c/em\u003e.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\n// f.h\nxyz \u003d 0;\n\n// f.cpp\nint16_t             // No more includes allowed in f.cpp after this code\n#include \"f.h\"      // Non-compliant\n\n// f1.cpp\n#define F1_MACRO\n#include \"a.h\"      // Compliant\n\nextern \"C\"          // Linkage-specification tokens are ignored\n{                   // Linkage-specification token is ignored\n  #include \"b.h\"    // Compliant\n}                   // Linkage-specification token is ignored\n\n#include \"c.h\"      // Compliant\n\nextern \"C\"          // Linkage-specification tokens are ignored\n{                   // Linkage-specification token is ignored\n  #include \"d.h\"    // Compliant\n\n  void g();         // No more includes allowed in f1.cpp after this code\n}                   // Linkage-specification token is ignored\n\n#include \"e.h\"      // Non-compliant\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003e{rule:c:S954} targets the same defect as this rule but for a non-mission-critical context.\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 19.0.3\u003c/p\u003e\n\u003cp\u003eCategory: Advisory\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eThis rule shall be applied to the contents of a file before preprocessing occurs.\u003c/p\u003e\n\u003cp\u003eFor purposes of this rule, the tokens used to open and close a \u003cem\u003elinkage-specification\u003c/em\u003e are ignored.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eTo aid code readability, all of the \u003ccode\u003e#include\u003c/code\u003e directives in a particular code file should be grouped together near the top of the\nfile.\u003c/p\u003e\n\u003cp\u003eAdditionally, using \u003ccode\u003e#include\u003c/code\u003e to include a \u003cem\u003estandard header file\u003c/em\u003e within a declaration or definition, or using part of the C++\nStandard Library before the inclusion of the related \u003cem\u003estandard header file\u003c/em\u003e results in \u003cem\u003eundefined behaviour\u003c/em\u003e.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\n// f.h\nxyz \u003d 0;\n\n// f.cpp\nint16_t             // No more includes allowed in f.cpp after this code\n#include \"f.h\"      // Non-compliant\n\n// f1.cpp\n#define F1_MACRO\n#include \"a.h\"      // Compliant\n\nextern \"C\"          // Linkage-specification tokens are ignored\n{                   // Linkage-specification token is ignored\n  #include \"b.h\"    // Compliant\n}                   // Linkage-specification token is ignored\n\n#include \"c.h\"      // Compliant\n\nextern \"C\"          // Linkage-specification tokens are ignored\n{                   // Linkage-specification token is ignored\n  #include \"d.h\"    // Compliant\n\n  void g();         // No more includes allowed in f1.cpp after this code\n}                   // Linkage-specification token is ignored\n\n#include \"e.h\"      // Non-compliant\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003e{rule:c:S954} targets the same defect as this rule but for a non-mission-critical context.\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "confusing",
      "misra-advisory",
      "misra-c++2023"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S1909",
    "name": "\"goto\" statements should not be used to jump into blocks",
    "defaultSeverity": "BLOCKER",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eUse of \u003ccode\u003egoto\u003c/code\u003e can lead to programs that are extremely difficult to comprehend and analyse, and possibly to unspecified behavior.\u003c/p\u003e\n\u003cp\u003eUnfortunately, removing \u003ccode\u003egoto\u003c/code\u003e from some code can lead to a rewritten version that is even more difficult to understand than the\noriginal. Therefore, limited use of \u003ccode\u003egoto\u003c/code\u003e is sometimes advised.\u003c/p\u003e\n\u003cp\u003eHowever, the use of \u003ccode\u003egoto\u003c/code\u003e to jump into or out of a sub-block of code, such as into the body of a \u003ccode\u003efor\u003c/code\u003e loop is never\nacceptable, because it is extremely difficult to understand and will likely yield results other than what is intended.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid f1 (int a) {\n  if (a \u0026lt;\u003d0) {\n    goto L2;  // Noncompliant; jumps into a different block\n  }\n\n  if (a \u003d\u003d 0) {\n  {\n    goto L1; // Compliant\n  }\n  goto L2;  // Noncompliant; jumps into a block\n\nL1:\n  for (int i \u003d 0; i \u0026lt; a; i++) {\n  L2:\n    //...  Should only have come here with a \u0026gt;\u003d0. Loop is infinite if a \u0026lt; 0\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid f1 (int a) {\n  if (a \u0026lt;\u003d0) {\n    // ...\n  }\n\n  if (a \u003d\u003d 0) {\n  {\n    goto L1; // Compliant\n  }\n\nL1:\n  for (int i \u003d 0; i \u0026lt; a; i++) {\n  L2:\n    //...\n  }\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 6-6-1 - Any label referenced by a goto statement shall be declared in the same block, or in a block enclosing the goto\n  statement \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 15.3 - Any label referenced by a goto statement shall be declared in the same block, or in a block enclosing the goto statement\n  \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eUse of \u003ccode\u003egoto\u003c/code\u003e can lead to programs that are extremely difficult to comprehend and analyse, and possibly to unspecified behavior.\u003c/p\u003e\n\u003cp\u003eUnfortunately, removing \u003ccode\u003egoto\u003c/code\u003e from some code can lead to a rewritten version that is even more difficult to understand than the\noriginal. Therefore, limited use of \u003ccode\u003egoto\u003c/code\u003e is sometimes advised.\u003c/p\u003e\n\u003cp\u003eHowever, the use of \u003ccode\u003egoto\u003c/code\u003e to jump into or out of a sub-block of code, such as into the body of a \u003ccode\u003efor\u003c/code\u003e loop is never\nacceptable, because it is extremely difficult to understand and will likely yield results other than what is intended.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid f1 (int a) {\n  if (a \u0026lt;\u003d0) {\n    goto L2;  // Noncompliant; jumps into a different block\n  }\n\n  if (a \u003d\u003d 0) {\n  {\n    goto L1; // Compliant\n  }\n  goto L2;  // Noncompliant; jumps into a block\n\nL1:\n  for (int i \u003d 0; i \u0026lt; a; i++) {\n  L2:\n    //...  Should only have come here with a \u0026gt;\u003d0. Loop is infinite if a \u0026lt; 0\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid f1 (int a) {\n  if (a \u0026lt;\u003d0) {\n    // ...\n  }\n\n  if (a \u003d\u003d 0) {\n  {\n    goto L1; // Compliant\n  }\n\nL1:\n  for (int i \u003d 0; i \u0026lt; a; i++) {\n  L2:\n    //...\n  }\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 6-6-1 - Any label referenced by a goto statement shall be declared in the same block, or in a block enclosing the goto\n  statement \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 15.3 - Any label referenced by a goto statement shall be declared in the same block, or in a block enclosing the goto statement\n  \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "based-on-misra",
      "brain-overload",
      "pitfall"
    ],
    "deprecatedKeys": [
      "c:GotoLabelInNestedBlock"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S968",
    "name": "Preprocessor operators \"#\" and \"##\" should not be used",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe evaluation order of both the \u003ccode\u003e#\u003c/code\u003e and \u003ccode\u003e##\u003c/code\u003e preprocessor operators is unspecified. Compilers have been known to implement\nthese operators inconsistently, therefore, to avoid these problems, do not use them.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#define A(Y)   #Y    /* Noncompliant */\n#define A(X,Y) X##Y  /* Noncompliant */\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 19.13 - The # and ## preprocessor operators should not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 16-3-2 - The # and ## operators should not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 20.10 - The # and ## preprocessor operators should not be used \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe evaluation order of both the \u003ccode\u003e#\u003c/code\u003e and \u003ccode\u003e##\u003c/code\u003e preprocessor operators is unspecified. Compilers have been known to implement\nthese operators inconsistently, therefore, to avoid these problems, do not use them.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#define A(Y)   #Y    /* Noncompliant */\n#define A(X,Y) X##Y  /* Noncompliant */\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 19.13 - The # and ## preprocessor operators should not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 16-3-2 - The # and ## operators should not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 20.10 - The # and ## preprocessor operators should not be used \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "based-on-misra",
      "lock-in"
    ],
    "deprecatedKeys": [
      "c:PPStringifyAndPastingUsage"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:M23_036",
    "name": "Unsigned \"integer literals\" shall be appropriately suffixed",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 5.13.4\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eThis rule applies to any \u003cem\u003einteger-literal\u003c/em\u003e that exists after preprocessing. It does not apply to \u003cem\u003euser-defined-integer-literals\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eAn unsigned \u003cem\u003einteger-suffix\u003c/em\u003e is required when the type of the \u003cem\u003einteger literal\u003c/em\u003e, as specified by the C++ Standard in [lex.icon], is\nunsigned.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e this rule does not depend on the context in which a literal is used; promotion and other conversions that may be applied to\nthe value are not relevant in determining compliance with this rule.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eThe type of an \u003cem\u003einteger literal\u003c/em\u003e is a potential source of confusion, because it is dependent on a complex combination of factors\nincluding:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The magnitude of the constant; \u003c/li\u003e\n  \u003cli\u003e The implemented sizes of the integer types; \u003c/li\u003e\n  \u003cli\u003e The presence of any suffixes; \u003c/li\u003e\n  \u003cli\u003e The number base that is used. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eFor example, the decimal \u003cem\u003einteger literal\u003c/em\u003e \u003ccode\u003e32768\u003c/code\u003e always has signed type. However, the \u003cem\u003einteger literal\u003c/em\u003e\n\u003ccode\u003e0x8000\u003c/code\u003e is of type \u003ccode\u003eunsigned int\u003c/code\u003e in a 16-bit environment, but of type \u003ccode\u003esigned int\u003c/code\u003e in a 32-bit environment. Adding\na \u003ccode\u003eU\u003c/code\u003e or \u003ccode\u003eu\u003c/code\u003e suffix to the \u003cem\u003einteger literal\u003c/em\u003e makes the signedness of the value explicit on a 16-bit platform.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e compliance checks against this rule will only be valid if an analysis tool has been configured with the same integer sizes\nas the compiler that is being used within the project.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cp\u003eThe following examples assume that \u003ccode\u003eint\u003c/code\u003e is 16 bits:\u003c/p\u003e\n\u003cpre\u003e\n    auto x \u003d 32768;     // Compliant - signed type\n    auto y \u003d 0x8000;    // Non-compliant - unsigned type\nuint16_t z \u003d 123;       // Compliant - \u0027u\u0027 is not required as \u0027123\u0027 is signed\n\nvoid f( uint16_t );     // #1\nvoid f(  int16_t );     // #2\n\nvoid b()\n{\n  f( 0x8000  );         // Non-compliant - calls #1 as 0x8000 is unsigned\n  f( 0x8000u );         // Compliant - calls #1\n  f( 0x7FFF  );         // Compliant - calls #2 as 0x7FFF is signed\n  f( 0x7FFFu );         // Compliant - calls #1\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003e{rule:c:S854} targets the same defect as this rule but for a non-mission-critical context.\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 5.13.4\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eThis rule applies to any \u003cem\u003einteger-literal\u003c/em\u003e that exists after preprocessing. It does not apply to \u003cem\u003euser-defined-integer-literals\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eAn unsigned \u003cem\u003einteger-suffix\u003c/em\u003e is required when the type of the \u003cem\u003einteger literal\u003c/em\u003e, as specified by the C++ Standard in [lex.icon], is\nunsigned.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e this rule does not depend on the context in which a literal is used; promotion and other conversions that may be applied to\nthe value are not relevant in determining compliance with this rule.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eThe type of an \u003cem\u003einteger literal\u003c/em\u003e is a potential source of confusion, because it is dependent on a complex combination of factors\nincluding:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The magnitude of the constant; \u003c/li\u003e\n  \u003cli\u003e The implemented sizes of the integer types; \u003c/li\u003e\n  \u003cli\u003e The presence of any suffixes; \u003c/li\u003e\n  \u003cli\u003e The number base that is used. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eFor example, the decimal \u003cem\u003einteger literal\u003c/em\u003e \u003ccode\u003e32768\u003c/code\u003e always has signed type. However, the \u003cem\u003einteger literal\u003c/em\u003e\n\u003ccode\u003e0x8000\u003c/code\u003e is of type \u003ccode\u003eunsigned int\u003c/code\u003e in a 16-bit environment, but of type \u003ccode\u003esigned int\u003c/code\u003e in a 32-bit environment. Adding\na \u003ccode\u003eU\u003c/code\u003e or \u003ccode\u003eu\u003c/code\u003e suffix to the \u003cem\u003einteger literal\u003c/em\u003e makes the signedness of the value explicit on a 16-bit platform.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e compliance checks against this rule will only be valid if an analysis tool has been configured with the same integer sizes\nas the compiler that is being used within the project.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cp\u003eThe following examples assume that \u003ccode\u003eint\u003c/code\u003e is 16 bits:\u003c/p\u003e\n\u003cpre\u003e\n    auto x \u003d 32768;     // Compliant - signed type\n    auto y \u003d 0x8000;    // Non-compliant - unsigned type\nuint16_t z \u003d 123;       // Compliant - \u0027u\u0027 is not required as \u0027123\u0027 is signed\n\nvoid f( uint16_t );     // #1\nvoid f(  int16_t );     // #2\n\nvoid b()\n{\n  f( 0x8000  );         // Non-compliant - calls #1 as 0x8000 is unsigned\n  f( 0x8000u );         // Compliant - calls #1\n  f( 0x7FFF  );         // Compliant - calls #2 as 0x7FFF is signed\n  f( 0x7FFFu );         // Compliant - calls #1\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003e{rule:c:S854} targets the same defect as this rule but for a non-mission-critical context.\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "misra-c++2023",
      "misra-required",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S969",
    "name": "Only standard forms of the \"defined\" directive should be used",
    "defaultSeverity": "BLOCKER",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003edefined\u003c/code\u003e preprocessing directive is used in the context of \u003ccode\u003e#if\u003c/code\u003e and \u003ccode\u003e#elif\u003c/code\u003e expressions to see whether a\ngiven identifier has been defined as a macro. It returns a value of 0 (false) or 1 (true), and has two valid forms, \u003ccode\u003edefined IDENTIFIER\u003c/code\u003e\nand \u003ccode\u003edefined ( IDENTIFIER )\u003c/code\u003e. Since it is essentially a macro existence check, it cannot take expressions as arguments.\u003c/p\u003e\n\u003cp\u003eNote that since\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e#if defined AN_IDENTIFIER\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eis equivalent to\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e#ifdef AN_IDENTIFIER\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003edefined\u003c/code\u003e is most useful when there are multiple arguments to check, E.G.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e#if defined AAA || defined BBB\u003c/code\u003e\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#if defined ( X \u0026gt; Y ) // Noncompliant; expressions not allowed\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#if defined X \u0026amp;\u0026amp; defined Y \u0026amp;\u0026amp; X \u0026gt; Y\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 19.14 - The defined preprocessor operator shall only be used in one of the two standard forms. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 16-1-1 - The defined preprocessor operator shall only be used in one of the two standard forms. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe \u003ccode\u003edefined\u003c/code\u003e preprocessing directive is used in the context of \u003ccode\u003e#if\u003c/code\u003e and \u003ccode\u003e#elif\u003c/code\u003e expressions to see whether a\ngiven identifier has been defined as a macro. It returns a value of 0 (false) or 1 (true), and has two valid forms, \u003ccode\u003edefined IDENTIFIER\u003c/code\u003e\nand \u003ccode\u003edefined ( IDENTIFIER )\u003c/code\u003e. Since it is essentially a macro existence check, it cannot take expressions as arguments.\u003c/p\u003e\n\u003cp\u003eNote that since\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e#if defined AN_IDENTIFIER\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eis equivalent to\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e#ifdef AN_IDENTIFIER\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003edefined\u003c/code\u003e is most useful when there are multiple arguments to check, E.G.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e#if defined AAA || defined BBB\u003c/code\u003e\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#if defined ( X \u0026gt; Y ) // Noncompliant; expressions not allowed\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#if defined X \u0026amp;\u0026amp; defined Y \u0026amp;\u0026amp; X \u0026gt; Y\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 19.14 - The defined preprocessor operator shall only be used in one of the two standard forms. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 16-1-1 - The defined preprocessor operator shall only be used in one of the two standard forms. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "bad-practice",
      "based-on-misra"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S1116",
    "name": "Empty statements should be removed",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eEmpty statements represented by a semicolon \u003ccode\u003e;\u003c/code\u003e are statements that do not perform any operation. They are often the result of a typo or\na misunderstanding of the language syntax. It is a good practice to remove empty statements since they don’t add value and lead to confusion and\nerrors.\u003c/p\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eIn the case of an empty expanded macro, the issue is not raised.\u003c/p\u003e\n\u003cpre\u003e\n#define LOG(x)\n\nvoid fun() {\n  LOG(X);\n}\n\u003c/pre\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid doSomething() {\n  ;                // Noncompliant - was used as a kind of TODO marker\n}\n\n#define A(x) x;    // Noncompliant - macro definitions should not end with a semi-colon when they are used as functions\n\nvoid fun() {\n  A(5);            // Noncompliant - after expansion, there are 2 consecutive semi-colons\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid doSomething() {\n}\n\n#define A(x) x\n\nvoid fun() {\n  A(5);\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 14.3 - Before preprocessing, a null statement shall only occur on a line by itself; it may be followed by a comment provided that\n  the first character following the null statement is a white-space character. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 6-2-3 - Before preprocessing, a null statement shall only occur on a line by itself; it may be followed by a comment, provided\n  that the first character following the null statement is a white-space character. \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/5dUxBQ\"\u003eCERT, MSC12-C.\u003c/a\u003e - Detect and remove code that has no effect or is never executed\n  \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/WtYxBQ\"\u003eCERT, EXP15-C.\u003c/a\u003e - Do not place a semicolon on the same line as an if, for, or while\n  statement \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eEmpty statements represented by a semicolon \u003ccode\u003e;\u003c/code\u003e are statements that do not perform any operation. They are often the result of a typo or\na misunderstanding of the language syntax. It is a good practice to remove empty statements since they don’t add value and lead to confusion and\nerrors.\u003c/p\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eIn the case of an empty expanded macro, the issue is not raised.\u003c/p\u003e\n\u003cpre\u003e\n#define LOG(x)\n\nvoid fun() {\n  LOG(X);\n}\n\u003c/pre\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid doSomething() {\n  ;                // Noncompliant - was used as a kind of TODO marker\n}\n\n#define A(x) x;    // Noncompliant - macro definitions should not end with a semi-colon when they are used as functions\n\nvoid fun() {\n  A(5);            // Noncompliant - after expansion, there are 2 consecutive semi-colons\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid doSomething() {\n}\n\n#define A(x) x\n\nvoid fun() {\n  A(5);\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 14.3 - Before preprocessing, a null statement shall only occur on a line by itself; it may be followed by a comment provided that\n  the first character following the null statement is a white-space character. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 6-2-3 - Before preprocessing, a null statement shall only occur on a line by itself; it may be followed by a comment, provided\n  that the first character following the null statement is a white-space character. \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/5dUxBQ\"\u003eCERT, MSC12-C.\u003c/a\u003e - Detect and remove code that has no effect or is never executed\n  \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/WtYxBQ\"\u003eCERT, EXP15-C.\u003c/a\u003e - Do not place a semicolon on the same line as an if, for, or while\n  statement \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "based-on-misra",
      "cert",
      "unused"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S1479",
    "name": "\"switch\" statements should not have too many \"case\" clauses",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "FOCUSED",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhen \u003ccode\u003eswitch\u003c/code\u003e statements have large sets of \u003ccode\u003ecase\u003c/code\u003e clauses, it is usually an attempt to map two sets of data. A real map\nstructure would be more readable and maintainable, and should be used instead.\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhen \u003ccode\u003eswitch\u003c/code\u003e statements have large sets of \u003ccode\u003ecase\u003c/code\u003e clauses, it is usually an attempt to map two sets of data. A real map\nstructure would be more readable and maintainable, and should be used instead.\u003c/p\u003e"
      }
    ],
    "params": {
      "maximum": {
        "key": "maximum",
        "name": "maximum",
        "description": "Maximum number of case",
        "defaultValue": "30",
        "type": "INTEGER",
        "multiple": false,
        "possibleValues": []
      }
    },
    "defaultParams": {
      "maximum": "30"
    },
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "brain-overload"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:M23_162",
    "name": "A named bit-field with \"signed integer type\" shall not have a length of one bit",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 12.2.3\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eA single-bit signed bit-field is unlikely to behave in a useful way and its presence is likely to indicate an error.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e anonymous signed bit-fields of any length are allowed as they cannot be accessed.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nstruct S\n{\n  signed int a : 1;    // Non-compliant\n  signed int   : 1;    // Rule does not apply\n  signed int   : 0;    // Rule does not apply\n  signed int b : 2;    // Compliant\n         int c : 1;    // Non-compliant\n};\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003e{rule:c:S2216} targets the same defect as this rule but for a non-mission-critical context.\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 12.2.3\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eA single-bit signed bit-field is unlikely to behave in a useful way and its presence is likely to indicate an error.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e anonymous signed bit-fields of any length are allowed as they cannot be accessed.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nstruct S\n{\n  signed int a : 1;    // Non-compliant\n  signed int   : 1;    // Rule does not apply\n  signed int   : 0;    // Rule does not apply\n  signed int b : 2;    // Compliant\n         int c : 1;    // Non-compliant\n};\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003e{rule:c:S2216} targets the same defect as this rule but for a non-mission-critical context.\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "misra-c++2023",
      "misra-required",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S1117",
    "name": "Variables should not be shadowed",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eVariable shadowing happens when a variable declared in a specific scope has the same name as a variable in an outer scope.\u003c/p\u003e\n\u003cp\u003eThis can lead to three main problems:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Confusion: The same name can refer to different variables in different parts of the scope, making the code hard to read and understand. \u003c/li\u003e\n  \u003cli\u003e Unintended Behavior: You might accidentally use the wrong variable, leading to hard-to-detect bugs. \u003c/li\u003e\n  \u003cli\u003e Maintenance Issues: If the inner variable is removed or renamed, the code’s behavior might change unexpectedly because the outer variable is\n  now being used. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eTo avoid these problems, rename the shadowing, shadowed, or both variables to accurately represent their purpose with unique and meaningful\nnames.\u003c/p\u003e\n\u003cp\u003eThe examples below show typical situations in which shadowing can occur.\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Parameter shadowing \u003cpre\u003e\nvoid f(int x, bool b) {\n  int y \u003d 4;\n  if (b) {\n    int x \u003d 7; // Noncompliant: the parameter \"x\" is shadowed.\n    int y \u003d 9; // Noncompliant: the local variable \"y\" is shadowed.\n    // ...\n  }\n}\n\u003c/pre\u003e \u003c/li\u003e\n  \u003cli\u003e Member variable shadowing \u003cpre\u003e\nclass Foo {\nprivate:\n  int myField;\n\npublic:\n  void doSomething() {\n    int myField \u003d 0; // Noncompliant: Foo::myField is shadowed.\n    // ...\n  }\n};\n\u003c/pre\u003e \u003c/li\u003e\n  \u003cli\u003e Global variable shadowing \u003cpre\u003e\nnamespace ns {\n  int state;\n\n  void bar() {\n    int state \u003d 0; // Noncompliant: the namespace variable is shadowed.\n  }\n}\n\u003c/pre\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eIt is common practice to have constructor arguments shadowing the fields they initialize in the \u003cem\u003emember initializer list\u003c/em\u003e. This pattern\navoids the need to select new names for the constructor arguments and will not be reported by this rule.\u003c/p\u003e\n\u003cpre\u003e\nclass Point {\npublic:\n  Point(int x, int y)\n    : x(x) // Compliant by exception: the parameter \"x\" is used\n           // in the member initializer list.\n  {\n    y \u003d y; // Noncompliant: the parameter is assigned to itself\n           // and the member \"y\" is not initialized.\n  }\n\nprivate:\n  int x;\n  int y;\n};\n\u003c/pre\u003e\n\u003ch3\u003eCaveats\u003c/h3\u003e\n\u003ch4\u003eShadowing in \u003ccode\u003eif\u003c/code\u003e, \u003ccode\u003eelse if\u003c/code\u003e, and \u003ccode\u003eelse\u003c/code\u003e\u003c/h4\u003e\n\u003cp\u003eVariables can be introduced in the condition of an \u003ccode\u003eif\u003c/code\u003e statement. Their scope includes the optional \u003ccode\u003eelse\u003c/code\u003e statement, which\nmay be surprising. Consequently, such variables can be shadowed in an \u003ccode\u003eelse if\u003c/code\u003e statement. This can be even more confusing and result in\nunintended behavior, as illustrated in this example:\u003c/p\u003e\n\u003cpre\u003e\nusing ExpectedData \u003d std::expected\u0026lt;std::string, std::error_code\u0026gt;;\n\nif (ExpectedData e \u003d readData()) {\n  printMessage(e.value());\n} else if (ExpectedData e \u003d readFallbackSource()) { // Noncompliant\n  printMessage(e.value());\n} else {\n  logError(\n    \"Initial source failed with: \",\n    e.error() // Contrary to the intention, the second \"e\" is used.\n  );\n}\n\u003c/pre\u003e\n\u003ch4\u003eShadowing of inaccessible declarations\u003c/h4\u003e\n\u003cp\u003eThis rule also raises issues on some variables, although they do not shadow another variable according to a strict interpretation of the C++\nlanguage. There are mainly two reasons for this.\u003c/p\u003e\n\u003col\u003e\n  \u003cli\u003e Primarily, the readability and maintainability of the code are impaired. Readers need an advanced understanding of the C++ language to\n  understand the subtle differences. \u003c/li\u003e\n  \u003cli\u003e Secondly, a small change can lead to actual shadowing. This can lead to subtle bugs when updating the code. \u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eHere is an example with nested classes:\u003c/p\u003e\n\u003cpre\u003e\nclass A {\npublic:\n  int x;\n  class B;\n};\n\nclass A::B {\n  void f(int x) { // Noncompliant: The parameter \"x\" shadows the field \"A::x\".\n    // ...\n  }\n};\n\u003c/pre\u003e\n\u003cp\u003eIn the above example, \u003ccode\u003eA::x\u003c/code\u003e cannot be used from \u003ccode\u003eA::B\u003c/code\u003e member functions because it is not a \u003ccode\u003estatic\u003c/code\u003e field. This\ncan lead to surprising effects when moving code around, particularly if the declaration of \u003ccode\u003eA::x\u003c/code\u003e was changed from \u003ccode\u003eint x;\u003c/code\u003e to\n\u003ccode\u003estatic int x;\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eYou should always avoid shadowing to avoid any confusion and increase the maintainability of your code.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 5.2 - Identifiers in an inner scope shall not use the same name as an identifier in an outer scope, and therefore hide that\n  identifier \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 2-10-2 - Identifiers declared in an inner scope shall not hide an identifier declared in an outer scope \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 5.3 - An identifier declared in an inner scope shall not hide an identifier declared in an outer scope \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/display/c/DCL01-C.+Do+not+reuse+variable+names+in+subscopes\"\u003eDCL01-C. Do not reuse variable\n  names in subscopes\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e S2387 - Child class fields should not shadow parent class fields \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eVariable shadowing happens when a variable declared in a specific scope has the same name as a variable in an outer scope.\u003c/p\u003e\n\u003cp\u003eThis can lead to three main problems:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Confusion: The same name can refer to different variables in different parts of the scope, making the code hard to read and understand. \u003c/li\u003e\n  \u003cli\u003e Unintended Behavior: You might accidentally use the wrong variable, leading to hard-to-detect bugs. \u003c/li\u003e\n  \u003cli\u003e Maintenance Issues: If the inner variable is removed or renamed, the code’s behavior might change unexpectedly because the outer variable is\n  now being used. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eTo avoid these problems, rename the shadowing, shadowed, or both variables to accurately represent their purpose with unique and meaningful\nnames.\u003c/p\u003e\n\u003cp\u003eThe examples below show typical situations in which shadowing can occur.\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Parameter shadowing \u003cpre\u003e\nvoid f(int x, bool b) {\n  int y \u003d 4;\n  if (b) {\n    int x \u003d 7; // Noncompliant: the parameter \"x\" is shadowed.\n    int y \u003d 9; // Noncompliant: the local variable \"y\" is shadowed.\n    // ...\n  }\n}\n\u003c/pre\u003e \u003c/li\u003e\n  \u003cli\u003e Member variable shadowing \u003cpre\u003e\nclass Foo {\nprivate:\n  int myField;\n\npublic:\n  void doSomething() {\n    int myField \u003d 0; // Noncompliant: Foo::myField is shadowed.\n    // ...\n  }\n};\n\u003c/pre\u003e \u003c/li\u003e\n  \u003cli\u003e Global variable shadowing \u003cpre\u003e\nnamespace ns {\n  int state;\n\n  void bar() {\n    int state \u003d 0; // Noncompliant: the namespace variable is shadowed.\n  }\n}\n\u003c/pre\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eIt is common practice to have constructor arguments shadowing the fields they initialize in the \u003cem\u003emember initializer list\u003c/em\u003e. This pattern\navoids the need to select new names for the constructor arguments and will not be reported by this rule.\u003c/p\u003e\n\u003cpre\u003e\nclass Point {\npublic:\n  Point(int x, int y)\n    : x(x) // Compliant by exception: the parameter \"x\" is used\n           // in the member initializer list.\n  {\n    y \u003d y; // Noncompliant: the parameter is assigned to itself\n           // and the member \"y\" is not initialized.\n  }\n\nprivate:\n  int x;\n  int y;\n};\n\u003c/pre\u003e\n\u003ch3\u003eCaveats\u003c/h3\u003e\n\u003ch4\u003eShadowing in \u003ccode\u003eif\u003c/code\u003e, \u003ccode\u003eelse if\u003c/code\u003e, and \u003ccode\u003eelse\u003c/code\u003e\u003c/h4\u003e\n\u003cp\u003eVariables can be introduced in the condition of an \u003ccode\u003eif\u003c/code\u003e statement. Their scope includes the optional \u003ccode\u003eelse\u003c/code\u003e statement, which\nmay be surprising. Consequently, such variables can be shadowed in an \u003ccode\u003eelse if\u003c/code\u003e statement. This can be even more confusing and result in\nunintended behavior, as illustrated in this example:\u003c/p\u003e\n\u003cpre\u003e\nusing ExpectedData \u003d std::expected\u0026lt;std::string, std::error_code\u0026gt;;\n\nif (ExpectedData e \u003d readData()) {\n  printMessage(e.value());\n} else if (ExpectedData e \u003d readFallbackSource()) { // Noncompliant\n  printMessage(e.value());\n} else {\n  logError(\n    \"Initial source failed with: \",\n    e.error() // Contrary to the intention, the second \"e\" is used.\n  );\n}\n\u003c/pre\u003e\n\u003ch4\u003eShadowing of inaccessible declarations\u003c/h4\u003e\n\u003cp\u003eThis rule also raises issues on some variables, although they do not shadow another variable according to a strict interpretation of the C++\nlanguage. There are mainly two reasons for this.\u003c/p\u003e\n\u003col\u003e\n  \u003cli\u003e Primarily, the readability and maintainability of the code are impaired. Readers need an advanced understanding of the C++ language to\n  understand the subtle differences. \u003c/li\u003e\n  \u003cli\u003e Secondly, a small change can lead to actual shadowing. This can lead to subtle bugs when updating the code. \u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eHere is an example with nested classes:\u003c/p\u003e\n\u003cpre\u003e\nclass A {\npublic:\n  int x;\n  class B;\n};\n\nclass A::B {\n  void f(int x) { // Noncompliant: The parameter \"x\" shadows the field \"A::x\".\n    // ...\n  }\n};\n\u003c/pre\u003e\n\u003cp\u003eIn the above example, \u003ccode\u003eA::x\u003c/code\u003e cannot be used from \u003ccode\u003eA::B\u003c/code\u003e member functions because it is not a \u003ccode\u003estatic\u003c/code\u003e field. This\ncan lead to surprising effects when moving code around, particularly if the declaration of \u003ccode\u003eA::x\u003c/code\u003e was changed from \u003ccode\u003eint x;\u003c/code\u003e to\n\u003ccode\u003estatic int x;\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eYou should always avoid shadowing to avoid any confusion and increase the maintainability of your code.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 5.2 - Identifiers in an inner scope shall not use the same name as an identifier in an outer scope, and therefore hide that\n  identifier \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 2-10-2 - Identifiers declared in an inner scope shall not hide an identifier declared in an outer scope \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 5.3 - An identifier declared in an inner scope shall not hide an identifier declared in an outer scope \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/display/c/DCL01-C.+Do+not+reuse+variable+names+in+subscopes\"\u003eDCL01-C. Do not reuse variable\n  names in subscopes\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e S2387 - Child class fields should not shadow parent class fields \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "based-on-misra",
      "cert",
      "pitfall",
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:M23_042",
    "name": "Function-like macros shall not be defined",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 19.0.2\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eFunctions have a number of advantages over function-like macros, including:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Function arguments and return values are type-checked; \u003c/li\u003e\n  \u003cli\u003e Function arguments are evaluated once, preventing problems with potential multiple side effects; \u003c/li\u003e\n  \u003cli\u003e Function names follow classical scoping rules; \u003c/li\u003e\n  \u003cli\u003e Functions can be overloaded and templatized; \u003c/li\u003e\n  \u003cli\u003e The address of a function can be passed to another function; \u003c/li\u003e\n  \u003cli\u003e Function calls can be inlined, providing the same performance characteristics as macros; \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003econstexpr\u003c/code\u003e functions can be evaluated at compile-time and may be used in all contexts where a compile-time constant is required;\n  \u003c/li\u003e\n  \u003cli\u003e In many debugging systems, it is easier to step through execution of a function than a macro. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eException\u003c/h3\u003e\n\u003cp\u003eAs it is not possible to implement equivalent behaviour within a function, a function-like macro may be defined if its definition includes any of\nthe following:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003e__LINE__\u003c/code\u003e, \u003ccode\u003e__FILE__\u003c/code\u003e or \u003ccode\u003e__func__\u003c/code\u003e; \u003c/li\u003e\n  \u003cli\u003e The \u003ccode\u003e#\u003c/code\u003e or \u003ccode\u003e##\u003c/code\u003e operators. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\n#define FUNC( X ) \\\n  ( ( X ) + ( X ) )             // Non-compliant\n\ntemplate\u0026lt; typename T \u0026gt;\nconstexpr auto func( T x )      // Possible alternative\n{\n  return x + x;\n}\n\u003c/pre\u003e\n\u003cp\u003eThe following examples are compliant by exception:\u003c/p\u003e\n\u003cpre\u003e\n#define ID( name ) \\\n  constexpr auto name \u003d #name;  // Compliant - use of #\n\n#define TAG( name ) \\\n  class name##Tag {};           // Compliant - use of ##\n\n#define LOG( message ) \\\n  log( __func__, message );     // Compliant - use of __func__\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:c:S960} targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n  \u003cli\u003e S6190 proposes a replacement for \u003ccode\u003e__FILE__\u003c/code\u003e, \u003ccode\u003e__LINE__\u003c/code\u003e and \u003ccode\u003e__func__\u003c/code\u003e in C++20 \u003c/li\u003e\n  \u003cli\u003e {rule:c:M23_212}: MISRA C++ 2023 Rule\u0026nbsp;19.3.1 - The \u003ccode\u003e#\u003c/code\u003e and \u003ccode\u003e##\u003c/code\u003e preprocessor operators should not be used \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/INcxBQ\"\u003eCERT, PRE00-C.\u003c/a\u003e - Prefer inline or static functions to function-like macros \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/036324/CppCoreGuidelines.md#es31-dont-use-macros-for-constants-or-functions\"\u003eC++ Core\n  Guidelines ES.31\u003c/a\u003e - Don’t use macros for constants or \"functions\" \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 19.0.2\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eFunctions have a number of advantages over function-like macros, including:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Function arguments and return values are type-checked; \u003c/li\u003e\n  \u003cli\u003e Function arguments are evaluated once, preventing problems with potential multiple side effects; \u003c/li\u003e\n  \u003cli\u003e Function names follow classical scoping rules; \u003c/li\u003e\n  \u003cli\u003e Functions can be overloaded and templatized; \u003c/li\u003e\n  \u003cli\u003e The address of a function can be passed to another function; \u003c/li\u003e\n  \u003cli\u003e Function calls can be inlined, providing the same performance characteristics as macros; \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003econstexpr\u003c/code\u003e functions can be evaluated at compile-time and may be used in all contexts where a compile-time constant is required;\n  \u003c/li\u003e\n  \u003cli\u003e In many debugging systems, it is easier to step through execution of a function than a macro. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eException\u003c/h3\u003e\n\u003cp\u003eAs it is not possible to implement equivalent behaviour within a function, a function-like macro may be defined if its definition includes any of\nthe following:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003e__LINE__\u003c/code\u003e, \u003ccode\u003e__FILE__\u003c/code\u003e or \u003ccode\u003e__func__\u003c/code\u003e; \u003c/li\u003e\n  \u003cli\u003e The \u003ccode\u003e#\u003c/code\u003e or \u003ccode\u003e##\u003c/code\u003e operators. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\n#define FUNC( X ) \\\n  ( ( X ) + ( X ) )             // Non-compliant\n\ntemplate\u0026lt; typename T \u0026gt;\nconstexpr auto func( T x )      // Possible alternative\n{\n  return x + x;\n}\n\u003c/pre\u003e\n\u003cp\u003eThe following examples are compliant by exception:\u003c/p\u003e\n\u003cpre\u003e\n#define ID( name ) \\\n  constexpr auto name \u003d #name;  // Compliant - use of #\n\n#define TAG( name ) \\\n  class name##Tag {};           // Compliant - use of ##\n\n#define LOG( message ) \\\n  log( __func__, message );     // Compliant - use of __func__\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:c:S960} targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n  \u003cli\u003e S6190 proposes a replacement for \u003ccode\u003e__FILE__\u003c/code\u003e, \u003ccode\u003e__LINE__\u003c/code\u003e and \u003ccode\u003e__func__\u003c/code\u003e in C++20 \u003c/li\u003e\n  \u003cli\u003e {rule:c:M23_212}: MISRA C++ 2023 Rule\u0026nbsp;19.3.1 - The \u003ccode\u003e#\u003c/code\u003e and \u003ccode\u003e##\u003c/code\u003e preprocessor operators should not be used \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/INcxBQ\"\u003eCERT, PRE00-C.\u003c/a\u003e - Prefer inline or static functions to function-like macros \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/036324/CppCoreGuidelines.md#es31-dont-use-macros-for-constants-or-functions\"\u003eC++ Core\n  Guidelines ES.31\u003c/a\u003e - Don’t use macros for constants or \"functions\" \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "misra-c++2023",
      "misra-required",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:M23_043",
    "name": "Tokens that look like a preprocessing directive shall not occur within a macro argument",
    "defaultSeverity": "BLOCKER",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW",
      "RELIABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 19.3.5\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eA macro argument containing sequences of tokens that would otherwise act as preprocessing directives results in \u003cem\u003eundefined behaviour\u003c/em\u003e.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\n#define M(A) printf ( #A )\n\nint main()\n{\n   M(\n#ifdef SW        // Non-compliant\n   \"Message 1\"\n#else            // Non-compliant\n   \"Message 2\"\n#endif           // Non-compliant\n    );\n}\n\u003c/pre\u003e\n\u003cp\u003eThe above could print:\u003c/p\u003e\n\u003cpre\u003e\n#ifdef SW \"Message 1\" #else \"Message 2\" #endif\n\u003c/pre\u003e\n\u003cp\u003eor it could print:\u003c/p\u003e\n\u003cpre\u003e\nMessage 2\n\u003c/pre\u003e\n\u003cp\u003eor it could exhibit some other behaviour.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cp\u003e\u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/display/c/PRE32-C.+Do+not+use+preprocessor+directives+in+invocations+of+function-like+macros\"\u003eCERT,\nPRE32-C.\u003c/a\u003e - Do not use preprocessor directives in invocations of function-like macros\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 19.3.5\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eA macro argument containing sequences of tokens that would otherwise act as preprocessing directives results in \u003cem\u003eundefined behaviour\u003c/em\u003e.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\n#define M(A) printf ( #A )\n\nint main()\n{\n   M(\n#ifdef SW        // Non-compliant\n   \"Message 1\"\n#else            // Non-compliant\n   \"Message 2\"\n#endif           // Non-compliant\n    );\n}\n\u003c/pre\u003e\n\u003cp\u003eThe above could print:\u003c/p\u003e\n\u003cpre\u003e\n#ifdef SW \"Message 1\" #else \"Message 2\" #endif\n\u003c/pre\u003e\n\u003cp\u003eor it could print:\u003c/p\u003e\n\u003cpre\u003e\nMessage 2\n\u003c/pre\u003e\n\u003cp\u003eor it could exhibit some other behaviour.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cp\u003e\u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/display/c/PRE32-C.+Do+not+use+preprocessor+directives+in+invocations+of+function-like+macros\"\u003eCERT,\nPRE32-C.\u003c/a\u003e - Do not use preprocessor directives in invocations of function-like macros\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "misra-c++2023",
      "misra-required",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S1911",
    "name": "Obsolete POSIX functions should not be used",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eTo ensure future code portability, obsolete POSIX functions should be removed. Those functions, with their replacements are listed below:\u003c/p\u003e\n\u003ctable\u003e\n  \u003ccolgroup\u003e\n    \u003ccol style\u003d\"width: 50%;\"\u003e\n    \u003ccol style\u003d\"width: 50%;\"\u003e\n  \u003c/colgroup\u003e\n  \u003cthead\u003e\n    \u003ctr\u003e\n      \u003cth\u003eObsolete\u003c/th\u003e\n      \u003cth\u003eUse Instead\u003c/th\u003e\n    \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003easctime\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003estrftime\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003easctime_r\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003estrftime\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003ebcmp\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003ememcmp\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003ebcopy\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003ememmove memcpy\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003ebsd_signal\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003esigaction\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003ebzero\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003ememset\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003ectime\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003estrftime\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003eecvt\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003esprintf\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003efcvt\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003esprintf\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003eftime\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003eno replacement function\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003egcvt\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003esprintf\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003egetcontext\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003eRewrite to use POSIX threads.\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003egethostbyaddr\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003egetnameinfo\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003egethostbyname\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003egetaddrinfo\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003egetwd\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003egetcwd\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003eindex\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003estrchr\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003emakecontext\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003eRewrite to use POSIX threads.\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003emktemp\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003emkstemp\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003epthread_attr_getstackaddr\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003epthread_attr_getstack\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003epthread_attr_setstackaddr\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003epthread_attr_setstack\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003erand_r\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003erand\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003erindex\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003estrrchr\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003escalb\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003escalbln\u0027, \u0027scalblnf\u0027 or \u0027scalblnl\u0027 instead of this function\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003eswapcontext\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003eRewrite to use POSIX threads.\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003eualarm\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003e\u0027timer_create\u0027, \u0027timer_delete\u0027, \u0027timer_getoverrun\u0027, \u0027timer_gettime\u0027, or \u0027timer_settime\u0027 instead of this function\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003eusleep\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003e\u0027nanosleep\u0027 or \u0027setitimer\u0027 function\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003eutime\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003eutimensat\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003evfork\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003efork\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003ewcswcs\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003ewcsstr\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eTo ensure future code portability, obsolete POSIX functions should be removed. Those functions, with their replacements are listed below:\u003c/p\u003e\n\u003ctable\u003e\n  \u003ccolgroup\u003e\n    \u003ccol style\u003d\"width: 50%;\"\u003e\n    \u003ccol style\u003d\"width: 50%;\"\u003e\n  \u003c/colgroup\u003e\n  \u003cthead\u003e\n    \u003ctr\u003e\n      \u003cth\u003eObsolete\u003c/th\u003e\n      \u003cth\u003eUse Instead\u003c/th\u003e\n    \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003easctime\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003estrftime\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003easctime_r\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003estrftime\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003ebcmp\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003ememcmp\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003ebcopy\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003ememmove memcpy\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003ebsd_signal\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003esigaction\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003ebzero\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003ememset\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003ectime\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003estrftime\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003eecvt\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003esprintf\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003efcvt\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003esprintf\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003eftime\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003eno replacement function\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003egcvt\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003esprintf\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003egetcontext\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003eRewrite to use POSIX threads.\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003egethostbyaddr\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003egetnameinfo\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003egethostbyname\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003egetaddrinfo\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003egetwd\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003egetcwd\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003eindex\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003estrchr\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003emakecontext\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003eRewrite to use POSIX threads.\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003emktemp\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003emkstemp\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003epthread_attr_getstackaddr\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003epthread_attr_getstack\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003epthread_attr_setstackaddr\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003epthread_attr_setstack\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003erand_r\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003erand\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003erindex\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003estrrchr\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003escalb\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003escalbln\u0027, \u0027scalblnf\u0027 or \u0027scalblnl\u0027 instead of this function\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003eswapcontext\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003eRewrite to use POSIX threads.\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003eualarm\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003e\u0027timer_create\u0027, \u0027timer_delete\u0027, \u0027timer_getoverrun\u0027, \u0027timer_gettime\u0027, or \u0027timer_settime\u0027 instead of this function\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003eusleep\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003e\u0027nanosleep\u0027 or \u0027setitimer\u0027 function\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003eutime\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003eutimensat\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003evfork\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003efork\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003ewcswcs\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003ewcsstr\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "cert",
      "obsolete"
    ],
    "deprecatedKeys": [
      "c:ObsoletePosixFunction"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S1912",
    "name": "Non-reentrant POSIX functions should be replaced with their reentrant versions",
    "defaultSeverity": "BLOCKER",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eA function is called reentrant if it can be interrupted in the middle of its execution and then safely called again (\"re-entered\") before its\nprevious invocations complete execution.\u003c/p\u003e\n\u003cp\u003eIt is especially important that multi-threaded applications do not call the same non-reentrant function from different threads.\u003c/p\u003e\n\u003cp\u003eThis rule will trigger an issue each time a function in the configurable list is invoked.\u003c/p\u003e\n\u003cp\u003eA call will be matched differently depending on the presence of the scope resolution operator \u003ccode\u003e::\u003c/code\u003e in the function name from the\nconfigurable list.\u003c/p\u003e\n\u003cp\u003eFor example, \u003ccode\u003enamespace a { namespace b { void f(); } }\u003c/code\u003e can be matched with \"f\", \"b::f\", \"a::b::f\", \"::a::b::f\" (fully qualified name\nyielding most precise results).\u003c/p\u003e\n\u003cp\u003eIt is recommended to provide fully qualified names to the configurable list (i.e., start each name with \u003ccode\u003e::\u003c/code\u003e), even for the functions in\nthe global namespace.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cp\u003eGiven a function that includes \u003ccode\u003elocaltime\u003c/code\u003e:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;time.h\u0026gt;\n\nvoid print_date_and_time(struct tm *time_ptr)\n{\n  printf(\n    \"Current date and time: %d/%02d/%02d %02d:%02d:%02d\\n\",\n    time_ptr-\u0026gt;tm_year + 1900,\n    time_ptr-\u0026gt;tm_mon,\n    time_ptr-\u0026gt;tm_mday,\n    time_ptr-\u0026gt;tm_hour,\n    time_ptr-\u0026gt;tm_min,\n    time_ptr-\u0026gt;tm_sec);\n}\n\nvoid print_unix_epoch_date_and_time()\n{\n  time_t unix_epoch_time \u003d (time_t)0;\n  struct tm *local_time_ptr \u003d localtime(\u0026amp;unix_epoch_time); // Noncompliant, call to the non-reentrant localtime() function\n  print_date_and_time(local_time_ptr);\n}\n\nint main(int argc, char* argv[])\n{\n  time_t current_time;\n  struct tm *local_time_ptr;\n\n  time(\u0026amp;current_time);\n\n  local_time_ptr \u003d localtime(\u0026amp;current_time); // Noncompliant, call to the non-reentrant localtime() function\n\n  // As expected, this will print: Current date and time: 1970/00/01 01:00:00\n  print_unix_epoch_date_and_time();\n\n  // This will actually also print Current date and time: 1970/00/01 01:00:00\n  // Indeed, localtime() is non-reentrant, and always returns the same pointer\n  print_date_and_time(local_time_ptr);\n\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;time.h\u0026gt;\n\nvoid print_date_and_time(struct tm *time_ptr)\n{\n  printf(\n    \"Current date and time: %d/%02d/%02d %02d:%02d:%02d\\n\",\n    time_ptr-\u0026gt;tm_year + 1900,\n    time_ptr-\u0026gt;tm_mon,\n    time_ptr-\u0026gt;tm_mday,\n    time_ptr-\u0026gt;tm_hour,\n    time_ptr-\u0026gt;tm_min,\n    time_ptr-\u0026gt;tm_sec);\n}\n\nvoid print_unix_epoch_date_and_time()\n{\n  time_t unix_epoch_time \u003d (time_t)0;\n  struct tm local_time;\n  localtime_r(\u0026amp;unix_epoch_time, \u0026amp;local_time); // Compliant\n  print_date_and_time(\u0026amp;local_time);\n}\n\nint main(int argc, char* argv[])\n{\n  time_t current_time;\n  struct tm local_time;\n\n  time(\u0026amp;current_time);\n\n  localtime_r(\u0026amp;current_time, \u0026amp;local_time); // Compliant\n\n  // As expected, this will print: Current date and time: 1970/00/01 01:00:00\n  print_unix_epoch_date_and_time();\n\n  // As expected, this will print the current date and time\n  print_date_and_time(\u0026amp;local_time);\n\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/lookup\"\u003eName Lookup\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eA function is called reentrant if it can be interrupted in the middle of its execution and then safely called again (\"re-entered\") before its\nprevious invocations complete execution.\u003c/p\u003e\n\u003cp\u003eIt is especially important that multi-threaded applications do not call the same non-reentrant function from different threads.\u003c/p\u003e\n\u003cp\u003eThis rule will trigger an issue each time a function in the configurable list is invoked.\u003c/p\u003e\n\u003cp\u003eA call will be matched differently depending on the presence of the scope resolution operator \u003ccode\u003e::\u003c/code\u003e in the function name from the\nconfigurable list.\u003c/p\u003e\n\u003cp\u003eFor example, \u003ccode\u003enamespace a { namespace b { void f(); } }\u003c/code\u003e can be matched with \"f\", \"b::f\", \"a::b::f\", \"::a::b::f\" (fully qualified name\nyielding most precise results).\u003c/p\u003e\n\u003cp\u003eIt is recommended to provide fully qualified names to the configurable list (i.e., start each name with \u003ccode\u003e::\u003c/code\u003e), even for the functions in\nthe global namespace.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cp\u003eGiven a function that includes \u003ccode\u003elocaltime\u003c/code\u003e:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;time.h\u0026gt;\n\nvoid print_date_and_time(struct tm *time_ptr)\n{\n  printf(\n    \"Current date and time: %d/%02d/%02d %02d:%02d:%02d\\n\",\n    time_ptr-\u0026gt;tm_year + 1900,\n    time_ptr-\u0026gt;tm_mon,\n    time_ptr-\u0026gt;tm_mday,\n    time_ptr-\u0026gt;tm_hour,\n    time_ptr-\u0026gt;tm_min,\n    time_ptr-\u0026gt;tm_sec);\n}\n\nvoid print_unix_epoch_date_and_time()\n{\n  time_t unix_epoch_time \u003d (time_t)0;\n  struct tm *local_time_ptr \u003d localtime(\u0026amp;unix_epoch_time); // Noncompliant, call to the non-reentrant localtime() function\n  print_date_and_time(local_time_ptr);\n}\n\nint main(int argc, char* argv[])\n{\n  time_t current_time;\n  struct tm *local_time_ptr;\n\n  time(\u0026amp;current_time);\n\n  local_time_ptr \u003d localtime(\u0026amp;current_time); // Noncompliant, call to the non-reentrant localtime() function\n\n  // As expected, this will print: Current date and time: 1970/00/01 01:00:00\n  print_unix_epoch_date_and_time();\n\n  // This will actually also print Current date and time: 1970/00/01 01:00:00\n  // Indeed, localtime() is non-reentrant, and always returns the same pointer\n  print_date_and_time(local_time_ptr);\n\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;time.h\u0026gt;\n\nvoid print_date_and_time(struct tm *time_ptr)\n{\n  printf(\n    \"Current date and time: %d/%02d/%02d %02d:%02d:%02d\\n\",\n    time_ptr-\u0026gt;tm_year + 1900,\n    time_ptr-\u0026gt;tm_mon,\n    time_ptr-\u0026gt;tm_mday,\n    time_ptr-\u0026gt;tm_hour,\n    time_ptr-\u0026gt;tm_min,\n    time_ptr-\u0026gt;tm_sec);\n}\n\nvoid print_unix_epoch_date_and_time()\n{\n  time_t unix_epoch_time \u003d (time_t)0;\n  struct tm local_time;\n  localtime_r(\u0026amp;unix_epoch_time, \u0026amp;local_time); // Compliant\n  print_date_and_time(\u0026amp;local_time);\n}\n\nint main(int argc, char* argv[])\n{\n  time_t current_time;\n  struct tm local_time;\n\n  time(\u0026amp;current_time);\n\n  localtime_r(\u0026amp;current_time, \u0026amp;local_time); // Compliant\n\n  // As expected, this will print: Current date and time: 1970/00/01 01:00:00\n  print_unix_epoch_date_and_time();\n\n  // As expected, this will print the current date and time\n  print_date_and_time(\u0026amp;local_time);\n\n  return 0;\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/lookup\"\u003eName Lookup\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {
      "nonReentrantFunctionList": {
        "key": "nonReentrantFunctionList",
        "name": "nonReentrantFunctionList",
        "description": "List of non-reentrant functions",
        "defaultValue": "::asctime,::crypt,::ctermid,::ctime,::fgetgrent,::fgetpwent,::fgetspent,::getgrent,::getgrgid,::getgrnam,::gethostbyaddr,::gethostbyname,::gethostbyname2,::gethostent,::getlogin,::getnetbyaddr,::getnetbyname,::getnetent,::getnetgrent,::getprotobyname,::getprotobynumber,::getprotoent,::getpwent,::getpwnam,::getpwuid,::getrpcbyname,::getrpcbynumber,::getrpcent,::getservbyname,::getservbyport,::getservent,::getspent,::getspnam,::gmtime,::localtime,::sgetspent,::strtok,::ttyname",
        "type": "STRING",
        "multiple": false,
        "possibleValues": []
      }
    },
    "defaultParams": {
      "nonReentrantFunctionList": "::asctime,::crypt,::ctermid,::ctime,::fgetgrent,::fgetpwent,::fgetspent,::getgrent,::getgrgid,::getgrnam,::gethostbyaddr,::gethostbyname,::gethostbyname2,::gethostent,::getlogin,::getnetbyaddr,::getnetbyname,::getnetent,::getnetgrent,::getprotobyname,::getprotobynumber,::getprotoent,::getpwent,::getpwnam,::getpwuid,::getrpcbyname,::getrpcbynumber,::getrpcent,::getservbyname,::getservbyport,::getservent,::getspent,::getspnam,::gmtime,::localtime,::sgetspent,::strtok,::ttyname"
    },
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "multi-threading"
    ],
    "deprecatedKeys": [
      "c:NonReentrantFunction"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S1913",
    "name": "\"sizeof(sizeof(...))\" should not be used",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eGiven an expression \u003ccode\u003ee\u003c/code\u003e of type \u003ccode\u003eT\u003c/code\u003e, \u003ccode\u003esizeof(e)\u003c/code\u003e returns the size in bytes of \u003ccode\u003eT\u003c/code\u003e. The\n\u003ccode\u003esizeof\u003c/code\u003e operator results in a value of type \u003ccode\u003esize_t\u003c/code\u003e. Also, \u003ccode\u003esizeof(e)\u003c/code\u003e has no side effects because \u003ccode\u003ee\u003c/code\u003e\nis not evaluated. Therefore, \u003ccode\u003esizeof(sizeof(e))\u003c/code\u003e is equivalent to \u003ccode\u003esizeof(size_t)\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eIn other words, \u003ccode\u003esizeof(sizeof(e))\u003c/code\u003e always gives the same result and does not depend on \u003ccode\u003ee\u003c/code\u003e, which is unlikely what was\nexpected.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eThis defect is usually the consequence of a typo, and the fix is to remove one level of \u003ccode\u003esizeof\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid function() {\n  char buffer[42];\n  char buffer2[sizeof(sizeof(buffer))]; // Noncompliant: a single sizeof() was intended\n\n  memcpy(buffer, \"Hello, world!\", strlen(\"Hello, world!\")+1);\n  memcpy(buffer2, buffer, sizeof(buffer)); // Buffer overflow\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid function() {\n  char buffer[42];\n  char buffer2[sizeof(buffer)]; // Compliant\n\n  memcpy(buffer, \"Hello, world!\", strlen(\"Hello, world!\")+1);\n  memcpy(buffer2, buffer, sizeof(buffer));\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/sizeof\"\u003e\u003ccode\u003esizeof\u003c/code\u003e operator\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eGiven an expression \u003ccode\u003ee\u003c/code\u003e of type \u003ccode\u003eT\u003c/code\u003e, \u003ccode\u003esizeof(e)\u003c/code\u003e returns the size in bytes of \u003ccode\u003eT\u003c/code\u003e. The\n\u003ccode\u003esizeof\u003c/code\u003e operator results in a value of type \u003ccode\u003esize_t\u003c/code\u003e. Also, \u003ccode\u003esizeof(e)\u003c/code\u003e has no side effects because \u003ccode\u003ee\u003c/code\u003e\nis not evaluated. Therefore, \u003ccode\u003esizeof(sizeof(e))\u003c/code\u003e is equivalent to \u003ccode\u003esizeof(size_t)\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eIn other words, \u003ccode\u003esizeof(sizeof(e))\u003c/code\u003e always gives the same result and does not depend on \u003ccode\u003ee\u003c/code\u003e, which is unlikely what was\nexpected.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eThis defect is usually the consequence of a typo, and the fix is to remove one level of \u003ccode\u003esizeof\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid function() {\n  char buffer[42];\n  char buffer2[sizeof(sizeof(buffer))]; // Noncompliant: a single sizeof() was intended\n\n  memcpy(buffer, \"Hello, world!\", strlen(\"Hello, world!\")+1);\n  memcpy(buffer2, buffer, sizeof(buffer)); // Buffer overflow\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid function() {\n  char buffer[42];\n  char buffer2[sizeof(buffer)]; // Compliant\n\n  memcpy(buffer, \"Hello, world!\", strlen(\"Hello, world!\")+1);\n  memcpy(buffer2, buffer, sizeof(buffer));\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/sizeof\"\u003e\u003ccode\u003esizeof\u003c/code\u003e operator\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [],
    "deprecatedKeys": [
      "c:SizeofSizeof"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S1914",
    "name": "Track instances of the \"#error\" preprocessor directive being reached",
    "defaultSeverity": "INFO",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThis rule creates a issue whenever an \u003ccode\u003e#error\u003c/code\u003e preprocessor directive is reached during the project’s analysis. In most cases, this\nindicates that the preprocessor was badly configured. Some predefined macros or library include paths might be required to fix the configuration.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#error This is an error\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThis rule creates a issue whenever an \u003ccode\u003e#error\u003c/code\u003e preprocessor directive is reached during the project’s analysis. In most cases, this\nindicates that the preprocessor was badly configured. Some predefined macros or library include paths might be required to fix the configuration.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#error This is an error\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [],
    "deprecatedKeys": [
      "c:PPErrorDirectiveReached"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S1915",
    "name": "Preprocessor directives should not be indented",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "FORMATTED",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eIndenting preprocessor directives reduces the code readability, because it make preprocessor directives harder to spot.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid optimal()\n{\n  #if INTEL             /* Noncompliant - hard to spot */\n  specificIntelStuff();\n  #endif                /* Noncompliant - hard to spot */\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid optimal()\n{\n#if INTEL               /* Compliant */\n  specificIntelStuff();\n#endif                  /* Compliant */\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eIndenting preprocessor directives reduces the code readability, because it make preprocessor directives harder to spot.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid optimal()\n{\n  #if INTEL             /* Noncompliant - hard to spot */\n  specificIntelStuff();\n  #endif                /* Noncompliant - hard to spot */\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid optimal()\n{\n#if INTEL               /* Compliant */\n  specificIntelStuff();\n#endif                  /* Compliant */\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "convention",
      "pitfall"
    ],
    "deprecatedKeys": [
      "c:PPDirectiveIndentation"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S5279",
    "name": "Unevaluated operands should not have side effects",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eOperands of \u003ccode\u003esizeof\u003c/code\u003e, \u003ccode\u003enoexcept\u003c/code\u003e and \u003ccode\u003edecltype\u003c/code\u003e are unevaluated. So side effects in these operands (which are all\nthe effects an expression can have in addition to producing a value), will not be applied. And that may be surprising to the reader.\u003c/p\u003e\n\u003cp\u003eAdditionally, the operand of \u003ccode\u003etypeid\u003c/code\u003e may or may not be evaluated, depending on its type: it will be evaluated if it is a function call\nthat returns reference to a polymorphic type, but it will not be evaluated in all the other cases. This difference of behavior is tricky to apprehend\nand that is why both cases are reported here.\u003c/p\u003e\n\u003cp\u003eThis rules reports an issue when operands of such operators have side-effects.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass A {\npublic:\n  virtual ~A();\n  /*...*/\n};\nclass B : public A { /* ....*/ };\nA\u0026amp; create(string const \u0026amp;xml);\n\nvoid test(string const \u0026amp;xml) {\n  int i \u003d 0;\n  cout \u0026lt;\u0026lt; noexcept(++i); // Noncompliant, \"i\" is not incremented\n  cout \u0026lt;\u0026lt; typeid(++i).name(); // Noncompliant, \"i\" is not incremented\n  auto p1 \u003d malloc(sizeof(i \u003d 5)); // Noncompliant, \"i\" is not changed\n\n  cout \u0026lt;\u0026lt; typeid(create(xml)).name(); // Noncompliant, even if the side-effects will be evaluated in this case\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nclass A {\npublic:\n  virtual ~A();\n  /*...*/\n};\nclass B : public A { /* ....*/ };\nA\u0026amp; create(string const \u0026amp;xml);\n\nvoid test(string const \u0026amp;xml) {\n  int i \u003d 0;\n  ++i;\n  cout \u0026lt;\u0026lt; noexcept(i); // Compliant\n  ++i;\n  cout \u0026lt;\u0026lt; typeid(i).name(); // Compliant\n  i \u003d 5;\n  auto p1 \u003d malloc(sizeof(i)); // Compliant\n\n  auto a \u003d create(xml);\n  cout \u0026lt;\u0026lt; typeid(a).name(); // Compliant\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eOperands of \u003ccode\u003esizeof\u003c/code\u003e, \u003ccode\u003enoexcept\u003c/code\u003e and \u003ccode\u003edecltype\u003c/code\u003e are unevaluated. So side effects in these operands (which are all\nthe effects an expression can have in addition to producing a value), will not be applied. And that may be surprising to the reader.\u003c/p\u003e\n\u003cp\u003eAdditionally, the operand of \u003ccode\u003etypeid\u003c/code\u003e may or may not be evaluated, depending on its type: it will be evaluated if it is a function call\nthat returns reference to a polymorphic type, but it will not be evaluated in all the other cases. This difference of behavior is tricky to apprehend\nand that is why both cases are reported here.\u003c/p\u003e\n\u003cp\u003eThis rules reports an issue when operands of such operators have side-effects.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass A {\npublic:\n  virtual ~A();\n  /*...*/\n};\nclass B : public A { /* ....*/ };\nA\u0026amp; create(string const \u0026amp;xml);\n\nvoid test(string const \u0026amp;xml) {\n  int i \u003d 0;\n  cout \u0026lt;\u0026lt; noexcept(++i); // Noncompliant, \"i\" is not incremented\n  cout \u0026lt;\u0026lt; typeid(++i).name(); // Noncompliant, \"i\" is not incremented\n  auto p1 \u003d malloc(sizeof(i \u003d 5)); // Noncompliant, \"i\" is not changed\n\n  cout \u0026lt;\u0026lt; typeid(create(xml)).name(); // Noncompliant, even if the side-effects will be evaluated in this case\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nclass A {\npublic:\n  virtual ~A();\n  /*...*/\n};\nclass B : public A { /* ....*/ };\nA\u0026amp; create(string const \u0026amp;xml);\n\nvoid test(string const \u0026amp;xml) {\n  int i \u003d 0;\n  ++i;\n  cout \u0026lt;\u0026lt; noexcept(i); // Compliant\n  ++i;\n  cout \u0026lt;\u0026lt; typeid(i).name(); // Compliant\n  i \u003d 5;\n  auto p1 \u003d malloc(sizeof(i)); // Compliant\n\n  auto a \u003d create(xml);\n  cout \u0026lt;\u0026lt; typeid(a).name(); // Compliant\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "based-on-misra",
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S2681",
    "name": "Multiline blocks should be enclosed in curly braces",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "FORMATTED",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eHaving inconsistent indentation and omitting curly braces from a control structure, such as an \u003ccode\u003eif\u003c/code\u003e statement or \u003ccode\u003efor\u003c/code\u003e loop,\nis misleading and can induce bugs.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when the indentation of the lines after a control structure indicates an intent to include those lines in the block, but\nthe omission of curly braces means the lines will be unconditionally executed once.\u003c/p\u003e\n\u003cp\u003eThe following patterns are recognized:\u003c/p\u003e\n\u003cpre\u003e\nif (condition)\n  firstActionInBlock();\n  secondAction();  // Noncompliant: secondAction is executed unconditionally\nthirdAction();\n\u003c/pre\u003e\n\u003cpre\u003e\nif (condition) firstActionInBlock(); secondAction();  // Noncompliant: secondAction is executed unconditionally\n\u003c/pre\u003e\n\u003cpre\u003e\nif (condition) firstActionInBlock();\n  secondAction();  // Noncompliant: secondAction is executed unconditionally\n\u003c/pre\u003e\n\u003cpre\u003e\nif (condition); secondAction();  // Noncompliant: secondAction is executed unconditionally\n\u003c/pre\u003e\n\u003cpre\u003e\nfor (int i \u003d 0; i \u0026lt; array.length; i++)\n  str \u003d array[i];\n  doTheThing(str);  // Noncompliant: executed only on the last element\n\u003c/pre\u003e\n\u003cp\u003eNote that this rule considers tab characters to be equivalent to 1 space. When mixing spaces and tabs, a code may look fine in one editor but be\nconfusing in another configured differently.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/483\"\u003eMITRE, CWE-483\u003c/a\u003e - Incorrect Block Delimitation \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eHaving inconsistent indentation and omitting curly braces from a control structure, such as an \u003ccode\u003eif\u003c/code\u003e statement or \u003ccode\u003efor\u003c/code\u003e loop,\nis misleading and can induce bugs.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when the indentation of the lines after a control structure indicates an intent to include those lines in the block, but\nthe omission of curly braces means the lines will be unconditionally executed once.\u003c/p\u003e\n\u003cp\u003eThe following patterns are recognized:\u003c/p\u003e\n\u003cpre\u003e\nif (condition)\n  firstActionInBlock();\n  secondAction();  // Noncompliant: secondAction is executed unconditionally\nthirdAction();\n\u003c/pre\u003e\n\u003cpre\u003e\nif (condition) firstActionInBlock(); secondAction();  // Noncompliant: secondAction is executed unconditionally\n\u003c/pre\u003e\n\u003cpre\u003e\nif (condition) firstActionInBlock();\n  secondAction();  // Noncompliant: secondAction is executed unconditionally\n\u003c/pre\u003e\n\u003cpre\u003e\nif (condition); secondAction();  // Noncompliant: secondAction is executed unconditionally\n\u003c/pre\u003e\n\u003cpre\u003e\nfor (int i \u003d 0; i \u0026lt; array.length; i++)\n  str \u003d array[i];\n  doTheThing(str);  // Noncompliant: executed only on the last element\n\u003c/pre\u003e\n\u003cp\u003eNote that this rule considers tab characters to be equivalent to 1 space. When mixing spaces and tabs, a code may look fine in one editor but be\nconfusing in another configured differently.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/483\"\u003eMITRE, CWE-483\u003c/a\u003e - Incorrect Block Delimitation \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "cert",
      "cwe"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S1110",
    "name": "Redundant pairs of parentheses should be removed",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eParentheses can disambiguate the order of operations in complex expressions and make the code easier to understand.\u003c/p\u003e\n\u003cpre\u003e\na \u003d (b * c) + (d * e); // Compliant: the intent is clear.\n\u003c/pre\u003e\n\u003cp\u003eRedundant parentheses are parenthesis that do not change the behavior of the code, and do not clarify the intent. They can mislead and complexify\nthe code. They should be removed.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nint x \u003d ((y / 2 + 1)); // Noncompliant\n\nif (a \u0026amp;\u0026amp; ((x + y \u0026gt; 0))) { // Noncompliant\n  return ((x + 1)); // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nint x \u003d (y / 2 + 1);\n\nif (a \u0026amp;\u0026amp; (x + y \u0026gt; 0)) {\n  return (x + 1);\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eAssignments inside conditions are often the result of a mistake. {rule:c:S1121} flags this potential bug.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\nif (x \u003d 7) { // Noncompliant: Did the author mean \"x \u003d\u003d 7\"?\n  // ...\n}\n\u003c/pre\u003e\n\u003cp\u003eAdding a pair of parentheses to clearly state the intent is standard practice and is accepted by this rule.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\nif ((x \u003d 7)) { // Compliant\n  // ...\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eParentheses can disambiguate the order of operations in complex expressions and make the code easier to understand.\u003c/p\u003e\n\u003cpre\u003e\na \u003d (b * c) + (d * e); // Compliant: the intent is clear.\n\u003c/pre\u003e\n\u003cp\u003eRedundant parentheses are parenthesis that do not change the behavior of the code, and do not clarify the intent. They can mislead and complexify\nthe code. They should be removed.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nint x \u003d ((y / 2 + 1)); // Noncompliant\n\nif (a \u0026amp;\u0026amp; ((x + y \u0026gt; 0))) { // Noncompliant\n  return ((x + 1)); // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nint x \u003d (y / 2 + 1);\n\nif (a \u0026amp;\u0026amp; (x + y \u0026gt; 0)) {\n  return (x + 1);\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eAssignments inside conditions are often the result of a mistake. {rule:c:S1121} flags this potential bug.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\nif (x \u003d 7) { // Noncompliant: Did the author mean \"x \u003d\u003d 7\"?\n  // ...\n}\n\u003c/pre\u003e\n\u003cp\u003eAdding a pair of parentheses to clearly state the intent is standard practice and is accepted by this rule.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\nif ((x \u003d 7)) { // Compliant\n  // ...\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "confusing"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S5278",
    "name": "Size argument of memory functions should be consistent",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe memory functions \u003ccode\u003ememset\u003c/code\u003e, \u003ccode\u003ememcpy\u003c/code\u003e, \u003ccode\u003ememmove\u003c/code\u003e, and \u003ccode\u003ememcmp\u003c/code\u003e take as last argument the number of\nbytes they will work on. If this size argument is badly defined (eg it is greater than the size of the destination object), it can lead to undefined\nbehavior.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when the size argument of a memory function seems inconsistent with the other arguments of the function.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstruct A {};\n\nvoid f() {\n  struct A dest;\n  memset(\u0026amp;dest, 0, sizeof(\u0026amp;dest)); // Noncompliant; size is based on \"A*\" when the destination is of type \"A\"\n  struct A src;\n  memcpy(\u0026amp;dest, \u0026amp;src, sizeof(\u0026amp;dest)); // Noncompliant; size is based on \"A*\" when the source is of type \"A\"\n\n  if (memset(\u0026amp;dest, 0, sizeof(dest) !\u003d 0)) { // Noncompliant; size argument is a comparison\n    // ...\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstruct A {};\n\nvoid f() {\n  struct A dest;\n  memset(\u0026amp;dest, 0, sizeof(dest)); // Compliant\n  struct A src;\n  memcpy(\u0026amp;dest, \u0026amp;src, sizeof(dest)); // Compliant\n\n  if (memset(\u0026amp;dest, 0, sizeof(dest)) !\u003d 0) { // Compliant\n    // ...\n  }\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe memory functions \u003ccode\u003ememset\u003c/code\u003e, \u003ccode\u003ememcpy\u003c/code\u003e, \u003ccode\u003ememmove\u003c/code\u003e, and \u003ccode\u003ememcmp\u003c/code\u003e take as last argument the number of\nbytes they will work on. If this size argument is badly defined (eg it is greater than the size of the destination object), it can lead to undefined\nbehavior.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when the size argument of a memory function seems inconsistent with the other arguments of the function.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstruct A {};\n\nvoid f() {\n  struct A dest;\n  memset(\u0026amp;dest, 0, sizeof(\u0026amp;dest)); // Noncompliant; size is based on \"A*\" when the destination is of type \"A\"\n  struct A src;\n  memcpy(\u0026amp;dest, \u0026amp;src, sizeof(\u0026amp;dest)); // Noncompliant; size is based on \"A*\" when the source is of type \"A\"\n\n  if (memset(\u0026amp;dest, 0, sizeof(dest) !\u003d 0)) { // Noncompliant; size argument is a comparison\n    // ...\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstruct A {};\n\nvoid f() {\n  struct A dest;\n  memset(\u0026amp;dest, 0, sizeof(dest)); // Compliant\n  struct A src;\n  memcpy(\u0026amp;dest, \u0026amp;src, sizeof(dest)); // Compliant\n\n  if (memset(\u0026amp;dest, 0, sizeof(dest)) !\u003d 0) { // Compliant\n    // ...\n  }\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S2323",
    "name": "Line-splicing should not be used in \"//\" comments",
    "defaultSeverity": "CRITICAL",
    "type": "BUG",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhen a line of code ends with the \u003ccode\u003e\\\u003c/code\u003e (backslash) character, the newline character is deleted. The compiler considers the next line a\ncontinuation of the current line, resulting in only one logical line of code.\u003c/p\u003e\n\u003cp\u003eThis source code transformation, known as \u003cem\u003eline-splicing\u003c/em\u003e, occurs during the second phase of C and C++ translation.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eLine-splicing\u003c/em\u003e is often harmless and is sometimes used to improve the readability of macros:\u003c/p\u003e\n\u003cpre\u003e\n#define LOG_FAILURE(CONDITION, MESSAGE) \\\n  do {                                  \\\n    if (!(CONDITION)) {                 \\\n      log(MESSAGE);                     \\\n    }                                   \\\n  } while (0)\n\u003c/pre\u003e\n\u003cp\u003eFurthermore, \u003cem\u003eline-splicing\u003c/em\u003e does not apply inside C++11 raw string literal.\u003c/p\u003e\n\u003cp\u003eHowever, the effect of \u003cem\u003eline-splicing\u003c/em\u003e in single-line comments (\u003ccode\u003e//\u003c/code\u003e) can be surprising, leading to unintentional code removal\nand possibly undefined behavior.\u003c/p\u003e\n\u003cp\u003eIn the following example, the \u003ccode\u003ereturn\u003c/code\u003e expression is considered part of the previous comment. The function has undefined behavior\nbecause it exits without returning a value.\u003c/p\u003e\n\u003cpre\u003e\nbool isSpecialCharacter(char c)\n{\n  // Noncompliant comment: it ends with a backslash.\n  // Characters considered special: [ ] \\\n  return 91 \u0026lt;\u003d c \u0026amp;\u0026amp; c \u0026lt;\u003d 93;\n}\n\u003c/pre\u003e\n\u003cp\u003eCompilers may also delete whitespace characters between a backslash and the newline characters. This practice is standard-compliant since C++23. In\nother words, trailing whitespaces do not disable \u003cem\u003eline-splicing\u003c/em\u003e.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/translation_phases\"\u003ePhases of translation\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2012, 3.2 - Line-splicing shall not be used in // comments \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:c:S1916} is a companion rule and detects trailing whitespace after \u003ccode\u003e\\\u003c/code\u003e. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhen a line of code ends with the \u003ccode\u003e\\\u003c/code\u003e (backslash) character, the newline character is deleted. The compiler considers the next line a\ncontinuation of the current line, resulting in only one logical line of code.\u003c/p\u003e\n\u003cp\u003eThis source code transformation, known as \u003cem\u003eline-splicing\u003c/em\u003e, occurs during the second phase of C and C++ translation.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eLine-splicing\u003c/em\u003e is often harmless and is sometimes used to improve the readability of macros:\u003c/p\u003e\n\u003cpre\u003e\n#define LOG_FAILURE(CONDITION, MESSAGE) \\\n  do {                                  \\\n    if (!(CONDITION)) {                 \\\n      log(MESSAGE);                     \\\n    }                                   \\\n  } while (0)\n\u003c/pre\u003e\n\u003cp\u003eFurthermore, \u003cem\u003eline-splicing\u003c/em\u003e does not apply inside C++11 raw string literal.\u003c/p\u003e\n\u003cp\u003eHowever, the effect of \u003cem\u003eline-splicing\u003c/em\u003e in single-line comments (\u003ccode\u003e//\u003c/code\u003e) can be surprising, leading to unintentional code removal\nand possibly undefined behavior.\u003c/p\u003e\n\u003cp\u003eIn the following example, the \u003ccode\u003ereturn\u003c/code\u003e expression is considered part of the previous comment. The function has undefined behavior\nbecause it exits without returning a value.\u003c/p\u003e\n\u003cpre\u003e\nbool isSpecialCharacter(char c)\n{\n  // Noncompliant comment: it ends with a backslash.\n  // Characters considered special: [ ] \\\n  return 91 \u0026lt;\u003d c \u0026amp;\u0026amp; c \u0026lt;\u003d 93;\n}\n\u003c/pre\u003e\n\u003cp\u003eCompilers may also delete whitespace characters between a backslash and the newline characters. This practice is standard-compliant since C++23. In\nother words, trailing whitespaces do not disable \u003cem\u003eline-splicing\u003c/em\u003e.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/translation_phases\"\u003ePhases of translation\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2012, 3.2 - Line-splicing shall not be used in // comments \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:c:S1916} is a companion rule and detects trailing whitespace after \u003ccode\u003e\\\u003c/code\u003e. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "based-on-misra"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S5955",
    "name": "Loop variables should be declared in the minimal possible scope",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "MODULAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhen a loop variable is not used outside of a loop, it should be declared inside the loop declaration:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e It improves readability. The scope of the variable is clearly defined. \u003c/li\u003e\n  \u003cli\u003e It reduces the number of mistakes. The variable can’t be accidentally misused outside of the loop. \u003c/li\u003e\n  \u003cli\u003e Resources are not retained longer than necessary. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid f() {\n  int i \u003d 0; // Noncompliant: i is not used outside of the loop\n  for (i \u003d 0; i \u0026lt; 10; ++i) {\n    std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; std::endl;\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid f() {\n  for (int i \u003d 0; i \u0026lt; 10; ++i) {\n    std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; std::endl;\n  }\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es5-keep-scopes-small\"\u003eES.5: Keep\n  scopes small\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhen a loop variable is not used outside of a loop, it should be declared inside the loop declaration:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e It improves readability. The scope of the variable is clearly defined. \u003c/li\u003e\n  \u003cli\u003e It reduces the number of mistakes. The variable can’t be accidentally misused outside of the loop. \u003c/li\u003e\n  \u003cli\u003e Resources are not retained longer than necessary. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid f() {\n  int i \u003d 0; // Noncompliant: i is not used outside of the loop\n  for (i \u003d 0; i \u0026lt; 10; ++i) {\n    std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; std::endl;\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid f() {\n  for (int i \u003d 0; i \u0026lt; 10; ++i) {\n    std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; std::endl;\n  }\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es5-keep-scopes-small\"\u003eES.5: Keep\n  scopes small\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "clumsy",
      "cppcoreguidelines"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S2324",
    "name": "Flexible array members should not be declared",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eFlexible array members are most likely to be used in conjunction with dynamic memory allocation.\u003c/p\u003e\n\u003cp\u003eThe presence of flexible array members modifies the behaviour of the \u003ccode\u003esizeof\u003c/code\u003e operator in ways that might not be expected by a\nprogrammer. The assignment of a structure that contains a flexible array member to another structure of the same type may not behave in the expected\nmanner as it copies only those elements up to but not including the start of the flexible array member.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;stdlib.h\u0026gt;\nstruct s\n{\n  uint16_t len;\n  uint32_t data[ ]; // Noncompliant - flexible array member\n} str;\n\nstruct s *copy ( struct s *s1 )\n{\n  struct s *s2 \u003d malloc ( sizeof ( struct s ) + ( s1-\u0026gt;len * sizeof ( uint32_t ) ) );\n  /* Omit malloc ( ) return check for brevity */\n  *s2 \u003d *s1; /* Only copies s1-\u0026gt;len */\n  return s2;\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2012, 18.7 - Flexible array members shall not be declared. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eFlexible array members are most likely to be used in conjunction with dynamic memory allocation.\u003c/p\u003e\n\u003cp\u003eThe presence of flexible array members modifies the behaviour of the \u003ccode\u003esizeof\u003c/code\u003e operator in ways that might not be expected by a\nprogrammer. The assignment of a structure that contains a flexible array member to another structure of the same type may not behave in the expected\nmanner as it copies only those elements up to but not including the start of the flexible array member.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;stdlib.h\u0026gt;\nstruct s\n{\n  uint16_t len;\n  uint32_t data[ ]; // Noncompliant - flexible array member\n} str;\n\nstruct s *copy ( struct s *s1 )\n{\n  struct s *s2 \u003d malloc ( sizeof ( struct s ) + ( s1-\u0026gt;len * sizeof ( uint32_t ) ) );\n  /* Omit malloc ( ) return check for brevity */\n  *s2 \u003d *s1; /* Only copies s1-\u0026gt;len */\n  return s2;\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2012, 18.7 - Flexible array members shall not be declared. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "based-on-misra",
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S3776",
    "name": "Cognitive Complexity of functions should not be too high",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "FOCUSED",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003cp\u003eThis rule raises an issue when the code cognitive complexity of a function is above a certain threshold.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eCognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard\nto read, understand, test, and modify.\u003c/p\u003e\n\u003cp\u003eAs a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.\u003c/p\u003e\n\u003ch3\u003eWhich syntax in code does impact cognitive complexity score?\u003c/h3\u003e\n\u003cp\u003eHere are the core concepts:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003cstrong\u003eCognitive complexity is incremented each time the code breaks the normal linear reading flow.\u003c/strong\u003e\u003cbr\u003e This concerns, for example:\n  Loop structures, Conditionals, Catches, Switches, Jumps to label and mixed operators in condition. \u003c/li\u003e\n  \u003cli\u003e \u003cstrong\u003eEach nesting level adds a malus to the breaking call.\u003c/strong\u003e\u003cbr\u003e During code reading, the deeper you go through nested layers, the\n  harder it becomes to keep the context in mind. \u003c/li\u003e\n  \u003cli\u003e \u003cstrong\u003eMethod calls are free\u003c/strong\u003e\u003cbr\u003e A well-picked method name is a summary of multiple lines of code. A reader can first explore a\n  high-level view of what the code is performing then go deeper and deeper by looking at called functions content.\u003cbr\u003e \u003cem\u003eNote:\u003c/em\u003e This does not\n  apply to recursive calls, those will increment cognitive score. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe method of computation is fully detailed in the pdf linked in the resources.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eDevelopers spend more time reading and understanding code than writing it. High cognitive complexity slows down changes and increases the cost of\nmaintenance.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eReducing cognitive complexity can be challenging.\u003cbr\u003e Here are a few suggestions:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003cstrong\u003eExtract complex conditions in a new function.\u003c/strong\u003e\u003cbr\u003e Mixed operators in condition will increase complexity. Extracting the\n  condition in a new function with an appropriate name will reduce cognitive load. \u003c/li\u003e\n  \u003cli\u003e \u003cstrong\u003eBreak down large functions.\u003c/strong\u003e\u003cbr\u003e Large functions can be hard to understand and maintain. If a function is doing too many\n  things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. \u003c/li\u003e\n  \u003cli\u003e \u003cstrong\u003eAvoid deep nesting by returning early.\u003c/strong\u003e\u003cbr\u003e To avoid the nesting of conditions, process exceptional cases first and return\n  early. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eExtraction of a complex condition in a new function.\u003c/strong\u003e\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cp\u003eThe code is using a complex condition and has a cognitive cost of 3.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid processEligibleUser(User user) {\n  if ((user.isActive() \u0026amp;\u0026amp; user.hasProfile()) // +1 (if) +1 (multiple conditions)\n     || (user.getAge() \u0026gt; 18)) {              // +1 (mixing operators)\n    // process the user\n  }\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eEven if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the\n\u003ccode\u003eprocessEligibleUser\u003c/code\u003e function, which now only has a cognitive score of 1.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid processEligibleUser(User user) {\n  if (isEligibleUser(user)) {  // +1 (if)\n    // process the user\n  }\n}\n\nbool isEligibleUser(User user) {\n  return (user.isActive() \u0026amp;\u0026amp; user.hasProfile()) // +1 (multiple conditions)\n      || (user.getAge() \u0026gt; 18));                 // +1 (mixing operators)\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eBreak down large functions.\u003c/strong\u003e\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cp\u003eThe code is simplified here to illustrate the purpose. Please imagine there is more happening in the process.\u003cbr\u003e The overall complexity of\n\u003ccode\u003eprocessUser\u003c/code\u003e is 8.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid processUser(User user) {\n  if (user.isActive()) {      // +1 (if)\n    if (user.hasProfile()) {  // +1 (if) +1 (nested)\n      // process active user with profile\n    } else {                  // +1 (else)\n      // process active user without profile\n    }\n  } else {                    // +1 (else)\n    if (user.hasProfile()) {  // +1 (if) +1 (nested)\n      // process inactive user with profile\n    } else {                  // +1 (else)\n      // process inactive user without profile\n    }\n  }\n}\n\u003c/pre\u003e\n\u003cp\u003eThis function could be refactored into smaller functions: The complexity is spread over multiple functions, and the breaks in flow are no longer\nnested.\u003cbr\u003e The \u003ccode\u003eprocessUser\u003c/code\u003e now has a complexity score of two.\u003c/p\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"compliant\"\u003e\nvoid processUser(User user) {\n  if (user.isActive()) {      // +1 (if)\n    processActiveUser(user);\n  } else {                    // +1 (else)\n    processInactiveUser(user);\n  }\n}\n\nvoid processActiveUser(User user) {\n  if (user.hasProfile()) {    // +1 (if)\n      // process active user with profile\n  } else {                    // +1 (else)\n      // process active user without profile\n  }\n}\n\nvoid processInactiveUser(User user) {\n  if (user.hasProfile()) {    // +1 (if)\n    // process inactive user with profile\n  } else {                    // +1 (else)\n    // process inactive user without profile\n  }\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eAvoid deep nesting by returning early.\u003c/strong\u003e\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cp\u003eThe below code has a cognitive complexity of 3.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"4\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid checkUser(User user) {\n  if (user.isActive()) {     // +1 (if)\n    if (user.hasProfile()) { // +1 (if) +1 (nested)\n      // do something\n    }\n  }\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eChecking for the edge case first flattens the \u003ccode\u003eif\u003c/code\u003e statements and reduces the cognitive complexity to 2.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"4\" data-diff-type\u003d\"compliant\"\u003e\nvoid checkUser(User user) {\n  if (!user.isActive()) {\n    return;\n  }\n  if (!user.hasProfile()) {\n    return;\n  }\n  // do something\n}\n\u003c/pre\u003e\n\u003ch3\u003ePitfalls\u003c/h3\u003e\n\u003cp\u003eAs this code is complex, ensure that you have unit tests that cover the code before refactoring.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Sonar - \u003ca href\u003d\"https://www.sonarsource.com/docs/CognitiveComplexity.pdf\"\u003eCognitive Complexity\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eArticles \u0026amp; blog posts\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Sonar Blog - \u003ca href\u003d\"https://www.sonarsource.com/blog/5-clean-code-tips-for-reducing-cognitive-complexity/\"\u003e5 Clean Code Tips for Reducing\n  Cognitive Complexity\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eThis rule raises an issue when the code cognitive complexity of a function is above a certain threshold.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eCognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard\nto read, understand, test, and modify.\u003c/p\u003e\n\u003cp\u003eAs a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.\u003c/p\u003e\n\u003ch3\u003eWhich syntax in code does impact cognitive complexity score?\u003c/h3\u003e\n\u003cp\u003eHere are the core concepts:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003cstrong\u003eCognitive complexity is incremented each time the code breaks the normal linear reading flow.\u003c/strong\u003e\u003cbr\u003e This concerns, for example:\n  Loop structures, Conditionals, Catches, Switches, Jumps to label and mixed operators in condition. \u003c/li\u003e\n  \u003cli\u003e \u003cstrong\u003eEach nesting level adds a malus to the breaking call.\u003c/strong\u003e\u003cbr\u003e During code reading, the deeper you go through nested layers, the\n  harder it becomes to keep the context in mind. \u003c/li\u003e\n  \u003cli\u003e \u003cstrong\u003eMethod calls are free\u003c/strong\u003e\u003cbr\u003e A well-picked method name is a summary of multiple lines of code. A reader can first explore a\n  high-level view of what the code is performing then go deeper and deeper by looking at called functions content.\u003cbr\u003e \u003cem\u003eNote:\u003c/em\u003e This does not\n  apply to recursive calls, those will increment cognitive score. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe method of computation is fully detailed in the pdf linked in the resources.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eDevelopers spend more time reading and understanding code than writing it. High cognitive complexity slows down changes and increases the cost of\nmaintenance.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eReducing cognitive complexity can be challenging.\u003cbr\u003e Here are a few suggestions:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003cstrong\u003eExtract complex conditions in a new function.\u003c/strong\u003e\u003cbr\u003e Mixed operators in condition will increase complexity. Extracting the\n  condition in a new function with an appropriate name will reduce cognitive load. \u003c/li\u003e\n  \u003cli\u003e \u003cstrong\u003eBreak down large functions.\u003c/strong\u003e\u003cbr\u003e Large functions can be hard to understand and maintain. If a function is doing too many\n  things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. \u003c/li\u003e\n  \u003cli\u003e \u003cstrong\u003eAvoid deep nesting by returning early.\u003c/strong\u003e\u003cbr\u003e To avoid the nesting of conditions, process exceptional cases first and return\n  early. \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u003cstrong\u003eExtraction of a complex condition in a new function.\u003c/strong\u003e\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cp\u003eThe code is using a complex condition and has a cognitive cost of 3.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid processEligibleUser(User user) {\n  if ((user.isActive() \u0026amp;\u0026amp; user.hasProfile()) // +1 (if) +1 (multiple conditions)\n     || (user.getAge() \u0026gt; 18)) {              // +1 (mixing operators)\n    // process the user\n  }\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eEven if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the\n\u003ccode\u003eprocessEligibleUser\u003c/code\u003e function, which now only has a cognitive score of 1.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid processEligibleUser(User user) {\n  if (isEligibleUser(user)) {  // +1 (if)\n    // process the user\n  }\n}\n\nbool isEligibleUser(User user) {\n  return (user.isActive() \u0026amp;\u0026amp; user.hasProfile()) // +1 (multiple conditions)\n      || (user.getAge() \u0026gt; 18));                 // +1 (mixing operators)\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eBreak down large functions.\u003c/strong\u003e\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cp\u003eThe code is simplified here to illustrate the purpose. Please imagine there is more happening in the process.\u003cbr\u003e The overall complexity of\n\u003ccode\u003eprocessUser\u003c/code\u003e is 8.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid processUser(User user) {\n  if (user.isActive()) {      // +1 (if)\n    if (user.hasProfile()) {  // +1 (if) +1 (nested)\n      // process active user with profile\n    } else {                  // +1 (else)\n      // process active user without profile\n    }\n  } else {                    // +1 (else)\n    if (user.hasProfile()) {  // +1 (if) +1 (nested)\n      // process inactive user with profile\n    } else {                  // +1 (else)\n      // process inactive user without profile\n    }\n  }\n}\n\u003c/pre\u003e\n\u003cp\u003eThis function could be refactored into smaller functions: The complexity is spread over multiple functions, and the breaks in flow are no longer\nnested.\u003cbr\u003e The \u003ccode\u003eprocessUser\u003c/code\u003e now has a complexity score of two.\u003c/p\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"compliant\"\u003e\nvoid processUser(User user) {\n  if (user.isActive()) {      // +1 (if)\n    processActiveUser(user);\n  } else {                    // +1 (else)\n    processInactiveUser(user);\n  }\n}\n\nvoid processActiveUser(User user) {\n  if (user.hasProfile()) {    // +1 (if)\n      // process active user with profile\n  } else {                    // +1 (else)\n      // process active user without profile\n  }\n}\n\nvoid processInactiveUser(User user) {\n  if (user.hasProfile()) {    // +1 (if)\n    // process inactive user with profile\n  } else {                    // +1 (else)\n    // process inactive user without profile\n  }\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eAvoid deep nesting by returning early.\u003c/strong\u003e\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cp\u003eThe below code has a cognitive complexity of 3.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"4\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid checkUser(User user) {\n  if (user.isActive()) {     // +1 (if)\n    if (user.hasProfile()) { // +1 (if) +1 (nested)\n      // do something\n    }\n  }\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eChecking for the edge case first flattens the \u003ccode\u003eif\u003c/code\u003e statements and reduces the cognitive complexity to 2.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"4\" data-diff-type\u003d\"compliant\"\u003e\nvoid checkUser(User user) {\n  if (!user.isActive()) {\n    return;\n  }\n  if (!user.hasProfile()) {\n    return;\n  }\n  // do something\n}\n\u003c/pre\u003e\n\u003ch3\u003ePitfalls\u003c/h3\u003e\n\u003cp\u003eAs this code is complex, ensure that you have unit tests that cover the code before refactoring.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Sonar - \u003ca href\u003d\"https://www.sonarsource.com/docs/CognitiveComplexity.pdf\"\u003eCognitive Complexity\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eArticles \u0026amp; blog posts\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Sonar Blog - \u003ca href\u003d\"https://www.sonarsource.com/blog/5-clean-code-tips-for-reducing-cognitive-complexity/\"\u003e5 Clean Code Tips for Reducing\n  Cognitive Complexity\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {
      "maximumFunctionCognitiveComplexityThreshold": {
        "key": "maximumFunctionCognitiveComplexityThreshold",
        "name": "maximumFunctionCognitiveComplexityThreshold",
        "description": "The maximum authorized complexity.",
        "defaultValue": "25",
        "type": "INTEGER",
        "multiple": false,
        "possibleValues": []
      }
    },
    "defaultParams": {
      "maximumFunctionCognitiveComplexityThreshold": "25"
    },
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "brain-overload"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S5832",
    "name": "Account validity should be verified when authenticating users with PAM",
    "defaultSeverity": "MAJOR",
    "type": "VULNERABILITY",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "SECURITY": "MEDIUM"
    },
    "description": "\u003cp\u003ePluggable authentication module (PAM) is a mechanism used on many UNIX variants to provide a unified way to authenticate users, independently of\nthe underlying authentication scheme.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhen authenticating users, if the validity of the account is not checked (not locked, not expired …​), it may lead to unauthorized access to\nresources.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nint valid(pam_handle_t *pamh) {\n    if (pam_authenticate(pamh, PAM_DISALLOW_NULL_AUTHTOK) !\u003d PAM_SUCCESS) { // Noncompliant\n        return -1;\n    }\n\n    return 0;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nint valid(pam_handle_t *pamh) {\n    if (pam_authenticate(pamh, PAM_DISALLOW_NULL_AUTHTOK) !\u003d PAM_SUCCESS) {\n        return -1;\n    }\n    if (pam_acct_mgmt(pamh, 0) !\u003d PAM_SUCCESS) {\n        return -1;\n    }\n\n    return 0;\n}\n\u003c/pre\u003e\n\u003ch3\u003eHow does this work?\u003c/h3\u003e\n\u003cp\u003eThe account validity is checked with \u003ccode\u003epam_acct_mgmt\u003c/code\u003e when authenticating a user with \u003ccode\u003epam_authenticate\u003c/code\u003e.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e The Open Group - \u003ca href\u003d\"https://pubs.opengroup.org/onlinepubs/8329799/pam_acct_mgmt.htm\"\u003e\u003ccode\u003epam_acct_mgmt\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eArticles \u0026amp; blog posts\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Packt hub - \u003ca href\u003d\"https://hub.packtpub.com/development-pluggable-authentication-modules-pam/\"\u003eDevelopment with Pluggable Authentication\n  Modules (PAM)\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e OWASP - \u003ca href\u003d\"https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures/\"\u003eTop 10 2021 Category A7 - Identification and\n  Authentication Failures\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e OWASP - \u003ca href\u003d\"https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A5-Broken_Access_Control\"\u003eTop 10 2017 Category A5 -\n  Broken Access Control\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/304\"\u003eCWE-304 - Missing Critical Step in Authentication\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003ePluggable authentication module (PAM) is a mechanism used on many UNIX variants to provide a unified way to authenticate users, independently of\nthe underlying authentication scheme.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhen authenticating users, if the validity of the account is not checked (not locked, not expired …​), it may lead to unauthorized access to\nresources.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nint valid(pam_handle_t *pamh) {\n    if (pam_authenticate(pamh, PAM_DISALLOW_NULL_AUTHTOK) !\u003d PAM_SUCCESS) { // Noncompliant\n        return -1;\n    }\n\n    return 0;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nint valid(pam_handle_t *pamh) {\n    if (pam_authenticate(pamh, PAM_DISALLOW_NULL_AUTHTOK) !\u003d PAM_SUCCESS) {\n        return -1;\n    }\n    if (pam_acct_mgmt(pamh, 0) !\u003d PAM_SUCCESS) {\n        return -1;\n    }\n\n    return 0;\n}\n\u003c/pre\u003e\n\u003ch3\u003eHow does this work?\u003c/h3\u003e\n\u003cp\u003eThe account validity is checked with \u003ccode\u003epam_acct_mgmt\u003c/code\u003e when authenticating a user with \u003ccode\u003epam_authenticate\u003c/code\u003e.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e The Open Group - \u003ca href\u003d\"https://pubs.opengroup.org/onlinepubs/8329799/pam_acct_mgmt.htm\"\u003e\u003ccode\u003epam_acct_mgmt\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eArticles \u0026amp; blog posts\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Packt hub - \u003ca href\u003d\"https://hub.packtpub.com/development-pluggable-authentication-modules-pam/\"\u003eDevelopment with Pluggable Authentication\n  Modules (PAM)\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e OWASP - \u003ca href\u003d\"https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures/\"\u003eTop 10 2021 Category A7 - Identification and\n  Authentication Failures\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e OWASP - \u003ca href\u003d\"https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A5-Broken_Access_Control\"\u003eTop 10 2017 Category A5 -\n  Broken Access Control\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/304\"\u003eCWE-304 - Missing Critical Step in Authentication\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "cwe",
      "symbolic-execution"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S878",
    "name": "Comma operator should not be used",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe comma operator takes two expressions, executes them from left to right, and returns the result of the second one. The use of this operator is\ngenerally detrimental to the readability and reliability of code, and the same effect can be achieved by other means.\u003c/p\u003e\n\u003cpre\u003e\ni \u003d a +\u003d 2, a + b;  // Noncompliant: What is the value of i?\n\u003c/pre\u003e\n\u003cp\u003eWriting each expression on its own line will improve readability and might fix misunderstandings.\u003c/p\u003e\n\u003cpre\u003e\na +\u003d 2;\ni \u003d a + b; // We probably expected to assign the result of the addition to i, although the previous code wasn\u0027t doing it.\n\u003c/pre\u003e\n\u003cp\u003eIt is especially error-prone in array subscripts - until C++20 - where it might be misinterpreted as accessing a multidimensional array.\u003c/p\u003e\n\u003cpre\u003e\na[1, 2] \u003d 3; // Noncompliant: until C++20, 1 is ignored. This is not an access to a multidimensional array.\n\u003c/pre\u003e\n\u003cp\u003eUsing a comma in this context was deprecated in C++20, and a real multi-dimensional subscript operator was introduced in C++23.\u003c/p\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThe comma operator is tolerated in initializations and increment expressions of \u003ccode\u003efor\u003c/code\u003e loops.\u003c/p\u003e\n\u003cpre\u003e\nfor (i \u003d 0, j \u003d 5; i \u0026lt; 6; i++, j++) { ... }\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 12.10 - The comma operator shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 5-18-1 - The comma operator shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 12.3 - The comma operator should not be used \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/operators#Array_subscript_operator\"\u003eArray subscript operator\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe comma operator takes two expressions, executes them from left to right, and returns the result of the second one. The use of this operator is\ngenerally detrimental to the readability and reliability of code, and the same effect can be achieved by other means.\u003c/p\u003e\n\u003cpre\u003e\ni \u003d a +\u003d 2, a + b;  // Noncompliant: What is the value of i?\n\u003c/pre\u003e\n\u003cp\u003eWriting each expression on its own line will improve readability and might fix misunderstandings.\u003c/p\u003e\n\u003cpre\u003e\na +\u003d 2;\ni \u003d a + b; // We probably expected to assign the result of the addition to i, although the previous code wasn\u0027t doing it.\n\u003c/pre\u003e\n\u003cp\u003eIt is especially error-prone in array subscripts - until C++20 - where it might be misinterpreted as accessing a multidimensional array.\u003c/p\u003e\n\u003cpre\u003e\na[1, 2] \u003d 3; // Noncompliant: until C++20, 1 is ignored. This is not an access to a multidimensional array.\n\u003c/pre\u003e\n\u003cp\u003eUsing a comma in this context was deprecated in C++20, and a real multi-dimensional subscript operator was introduced in C++23.\u003c/p\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThe comma operator is tolerated in initializations and increment expressions of \u003ccode\u003efor\u003c/code\u003e loops.\u003c/p\u003e\n\u003cpre\u003e\nfor (i \u003d 0, j \u003d 5; i \u0026lt; 6; i++, j++) { ... }\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 12.10 - The comma operator shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 5-18-1 - The comma operator shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 12.3 - The comma operator should not be used \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/operators#Array_subscript_operator\"\u003eArray subscript operator\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "based-on-misra"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S999",
    "name": "\"goto\" should jump to labels declared later in the same function",
    "defaultSeverity": "BLOCKER",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eUnconstrained use of \u003ccode\u003egoto\u003c/code\u003e can lead to programs that are extremely difficult to comprehend and analyse. For C++, it can also lead to\nthe program exhibiting unspecified behavior.\u003c/p\u003e\n\u003cp\u003eHowever, in many cases a total ban on \u003ccode\u003egoto\u003c/code\u003e requires the introduction of flags to ensure correct control flow, and it is possible that\nthese flags may themselves be less transparent than the \u003ccode\u003egoto\u003c/code\u003e they replace.\u003c/p\u003e\n\u003cp\u003eTherefore, the restricted use of \u003ccode\u003egoto\u003c/code\u003e is allowed where that use will not lead to semantics contrary to developer expectations. \"Back\"\njumps are prohibited, since they can be used to create iterations without using the well-defined iteration statements supplied by the core\nlanguage.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint f() {\n  int j \u003d 0;\nL1:\n  ++j;\n  if (10 \u003d\u003d j) {\n    goto L2;         // forward jump ignored\n  }\n  // ...\n  goto L1;           // Noncompliant\nL2:\n  return ++j;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint f() {\n  for (int j \u003d 0; j \u0026lt; 11; j++) {\n    // ...\n  }\n  return ++j;\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 6-6-2 - The goto statement shall jump to a label declared later in the same function body \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 15.2 - The goto statement shall jump to a label declared later in the same function \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eUnconstrained use of \u003ccode\u003egoto\u003c/code\u003e can lead to programs that are extremely difficult to comprehend and analyse. For C++, it can also lead to\nthe program exhibiting unspecified behavior.\u003c/p\u003e\n\u003cp\u003eHowever, in many cases a total ban on \u003ccode\u003egoto\u003c/code\u003e requires the introduction of flags to ensure correct control flow, and it is possible that\nthese flags may themselves be less transparent than the \u003ccode\u003egoto\u003c/code\u003e they replace.\u003c/p\u003e\n\u003cp\u003eTherefore, the restricted use of \u003ccode\u003egoto\u003c/code\u003e is allowed where that use will not lead to semantics contrary to developer expectations. \"Back\"\njumps are prohibited, since they can be used to create iterations without using the well-defined iteration statements supplied by the core\nlanguage.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint f() {\n  int j \u003d 0;\nL1:\n  ++j;\n  if (10 \u003d\u003d j) {\n    goto L2;         // forward jump ignored\n  }\n  // ...\n  goto L1;           // Noncompliant\nL2:\n  return ++j;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint f() {\n  for (int j \u003d 0; j \u0026lt; 11; j++) {\n    // ...\n  }\n  return ++j;\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 6-6-2 - The goto statement shall jump to a label declared later in the same function body \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 15.2 - The goto statement shall jump to a label declared later in the same function \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "based-on-misra",
      "pitfall"
    ],
    "deprecatedKeys": [
      "c:BackJumpWithGoto"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S876",
    "name": "Unary minus should not be applied to an unsigned expression",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eApplying the unary minus operator to an unsigned variable or expression will always yield another unsigned expression. More plainly, in some cases\nthe operation itself is meaningless, and in some other cases the result will be unexpected. In all cases it is bad practice. Therefore the unary minus\noperator should not be applied to unsigned variables or expressions.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nuint8_t a \u003d -1U;\nint32_t b \u003d -a; // Noncompliant; b is assigned -255\nuint32_t c \u003d 1U;\nint64_t d \u003d -c; // Noncompliant; d is assigned MAX_UINT\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThis rule ignores \u003ccode\u003e-1U\u003c/code\u003e because it is commonly used as shorthand for \u003ccode\u003eMAX_UINT\u003c/code\u003e.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 12.9 - The unary minus operator shall not be applied to an expression whose underlying type is unsigned. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 5-3-2 - The unary minus operator shall not be applied to an expression whose underlying type is unsigned. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 10.1 - Operands shall not be of an inappropriate essential type \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eApplying the unary minus operator to an unsigned variable or expression will always yield another unsigned expression. More plainly, in some cases\nthe operation itself is meaningless, and in some other cases the result will be unexpected. In all cases it is bad practice. Therefore the unary minus\noperator should not be applied to unsigned variables or expressions.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nuint8_t a \u003d -1U;\nint32_t b \u003d -a; // Noncompliant; b is assigned -255\nuint32_t c \u003d 1U;\nint64_t d \u003d -c; // Noncompliant; d is assigned MAX_UINT\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThis rule ignores \u003ccode\u003e-1U\u003c/code\u003e because it is commonly used as shorthand for \u003ccode\u003eMAX_UINT\u003c/code\u003e.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 12.9 - The unary minus operator shall not be applied to an expression whose underlying type is unsigned. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 5-3-2 - The unary minus operator shall not be applied to an expression whose underlying type is unsigned. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 10.1 - Operands shall not be of an inappropriate essential type \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "based-on-misra"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S874",
    "name": "Bitwise operators should not be applied to signed operands",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eMost built-in bitwise operators (\u003ccode\u003e~\u003c/code\u003e, \u003ccode\u003e\u0026gt;\u0026gt;\u003c/code\u003e, \u003ccode\u003e\u0026gt;\u0026gt;\u003d\u003c/code\u003e, \u003ccode\u003e\u0026amp;\u003c/code\u003e, \u003ccode\u003e\u0026amp;\u003d\u003c/code\u003e,\n\u003ccode\u003e^\u003c/code\u003e, \u003ccode\u003e^\u003d\u003c/code\u003e, \u003ccode\u003e|\u003c/code\u003e, and \u003ccode\u003e|\u003d\u003c/code\u003e) have implementation-dependent results when performed on signed operands, and\nbitwise left shift (\u003ccode\u003e\u0026lt;\u0026lt;\u003c/code\u003e and \u003ccode\u003e\u0026lt;\u0026lt;\u003d\u003c/code\u003e) has unspecified or undefined behavior when performed on negative operands.\u003c/p\u003e\n\u003cp\u003eTherefore, bitwise operations should not be performed on signed operands.\u003c/p\u003e\n\u003cp\u003eStarting with C++20, the behaviors have been defined more accurately (negative values have to be represented using two’s complement), and therefore\nthis rule will only report an issue when the second operand of a shift operator is signed (shifting by a negative value is still undefined\nbehavior).\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nif ( ( uint16_a \u0026amp; int16_b ) \u003d\u003d 0x1234U ) // Noncompliant until C++20\nif ( ~int16_a \u003d\u003d 0x1234U ) // Noncompliant until C++20\n\nauto f(int i) {\n    return 1 \u0026lt;\u0026lt; i; // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nif ( ( uint16_a | uint16_b ) \u003d\u003d 0x1234U )\nif ( ~uint16_a \u003d\u003d 0x1234U )\n\nauto f(unsigned int i) {\n    return 1 \u0026lt;\u0026lt; i;\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eWhen used as bit flags, it is acceptable to use preprocessor macros as arguments to the \u0026amp; and | operators even if the value is not explicitly\ndeclared as unsigned.\u003c/p\u003e\n\u003cpre\u003e\nfd \u003d open(file_name, UO_WRONLY | UO_CREAT | UO_EXCL | UO_TRUNC, 0600);\n\u003c/pre\u003e\n\u003cp\u003eIf the right-side operand to a shift operator is known at compile time, it is acceptable for the value to be represented with a signed type\nprovided it is positive.\u003c/p\u003e\n\u003cpre\u003e\n#define SHIFT 24\nfoo \u003d 15u \u0026gt;\u0026gt; SHIFT;\n\u003c/pre\u003e\n\u003cp\u003eWhen combining several bitwise operations, even if all leaf operands are unsigned, if they are smaller than an \u003ccode\u003eint\u003c/code\u003e, some intermediate\nresults will be of type \u003ccode\u003esigned int\u003c/code\u003e, due to integral promotion. However, this situation is usually not an issue, and is an exception for\nthis rule:\u003c/p\u003e\n\u003cpre\u003e\nunsigned int f(unsigned short src) {\n  return (src \u0026gt;\u0026gt; 3) \u0026amp; 0x1F; // (src \u0026gt;\u0026gt; 3) is of type signed int\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 12.7 - Bitwise operators shall not be applied to operands whose underlying type is signed \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 5-0-21 - Bitwise operators shall only be applied to operands of unsigned underlying type \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 10.1 - Operands shall not be of an inappropriate essential type \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/9tYxBQ\"\u003eCERT, INT13-C.\u003c/a\u003e - Use bitwise operators only on unsigned operands \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/682\"\u003eMITRE, CWE-682\u003c/a\u003e - Incorrect Calculation \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eMost built-in bitwise operators (\u003ccode\u003e~\u003c/code\u003e, \u003ccode\u003e\u0026gt;\u0026gt;\u003c/code\u003e, \u003ccode\u003e\u0026gt;\u0026gt;\u003d\u003c/code\u003e, \u003ccode\u003e\u0026amp;\u003c/code\u003e, \u003ccode\u003e\u0026amp;\u003d\u003c/code\u003e,\n\u003ccode\u003e^\u003c/code\u003e, \u003ccode\u003e^\u003d\u003c/code\u003e, \u003ccode\u003e|\u003c/code\u003e, and \u003ccode\u003e|\u003d\u003c/code\u003e) have implementation-dependent results when performed on signed operands, and\nbitwise left shift (\u003ccode\u003e\u0026lt;\u0026lt;\u003c/code\u003e and \u003ccode\u003e\u0026lt;\u0026lt;\u003d\u003c/code\u003e) has unspecified or undefined behavior when performed on negative operands.\u003c/p\u003e\n\u003cp\u003eTherefore, bitwise operations should not be performed on signed operands.\u003c/p\u003e\n\u003cp\u003eStarting with C++20, the behaviors have been defined more accurately (negative values have to be represented using two’s complement), and therefore\nthis rule will only report an issue when the second operand of a shift operator is signed (shifting by a negative value is still undefined\nbehavior).\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nif ( ( uint16_a \u0026amp; int16_b ) \u003d\u003d 0x1234U ) // Noncompliant until C++20\nif ( ~int16_a \u003d\u003d 0x1234U ) // Noncompliant until C++20\n\nauto f(int i) {\n    return 1 \u0026lt;\u0026lt; i; // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nif ( ( uint16_a | uint16_b ) \u003d\u003d 0x1234U )\nif ( ~uint16_a \u003d\u003d 0x1234U )\n\nauto f(unsigned int i) {\n    return 1 \u0026lt;\u0026lt; i;\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eWhen used as bit flags, it is acceptable to use preprocessor macros as arguments to the \u0026amp; and | operators even if the value is not explicitly\ndeclared as unsigned.\u003c/p\u003e\n\u003cpre\u003e\nfd \u003d open(file_name, UO_WRONLY | UO_CREAT | UO_EXCL | UO_TRUNC, 0600);\n\u003c/pre\u003e\n\u003cp\u003eIf the right-side operand to a shift operator is known at compile time, it is acceptable for the value to be represented with a signed type\nprovided it is positive.\u003c/p\u003e\n\u003cpre\u003e\n#define SHIFT 24\nfoo \u003d 15u \u0026gt;\u0026gt; SHIFT;\n\u003c/pre\u003e\n\u003cp\u003eWhen combining several bitwise operations, even if all leaf operands are unsigned, if they are smaller than an \u003ccode\u003eint\u003c/code\u003e, some intermediate\nresults will be of type \u003ccode\u003esigned int\u003c/code\u003e, due to integral promotion. However, this situation is usually not an issue, and is an exception for\nthis rule:\u003c/p\u003e\n\u003cpre\u003e\nunsigned int f(unsigned short src) {\n  return (src \u0026gt;\u0026gt; 3) \u0026amp; 0x1F; // (src \u0026gt;\u0026gt; 3) is of type signed int\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 12.7 - Bitwise operators shall not be applied to operands whose underlying type is signed \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 5-0-21 - Bitwise operators shall only be applied to operands of unsigned underlying type \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 10.1 - Operands shall not be of an inappropriate essential type \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/9tYxBQ\"\u003eCERT, INT13-C.\u003c/a\u003e - Use bitwise operators only on unsigned operands \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/682\"\u003eMITRE, CWE-682\u003c/a\u003e - Incorrect Calculation \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "bad-practice",
      "based-on-misra",
      "cert",
      "cwe",
      "lock-in"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S995",
    "name": "Pointer and reference parameters should be \"const\" if the corresponding object is not modified",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eConst correctness is an important tool for type safety. It allows for catching coding errors at compile time and it documents the code for\nmaintainers.\u003c/p\u003e\n\u003cp\u003eCorrectly const-qualifying pointers can be tricky because the indirection they add can also be const.\u003c/p\u003e\n\u003cp\u003eFor a pointer \u003ccode\u003eX * ptr\u003c/code\u003e, const can be written in three different places:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003econst X * ptr\u003c/code\u003e and \u003ccode\u003eX const * ptr\u003c/code\u003e are identical and mean that the X object \u003ccode\u003eptr\u003c/code\u003e points to cannot be\n  changed. \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003eX * const ptr\u003c/code\u003e means that the pointer cannot be changed to point to a different X object. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn a function signature, the first \u003ccode\u003econst X * ptr\u003c/code\u003e (or its equivalent \u003ccode\u003eX const * ptr\u003c/code\u003e) is the one that will bring\ntype-safety. It protects against changing the value pointed at.\u003c/p\u003e\n\u003cpre\u003e\nvoid externalFunction(int * a, const int * b);\n\nvoid myfunc() {\n  int a \u003d 1;\n  int b \u003d 2;\n  externalFunction(\u0026amp;a, \u0026amp;b);\n  // a can now have any value\n  // We know that b is still \u00272\u0027\n}\n\u003c/pre\u003e\n\u003cp\u003eThis rule detects when a pointer or reference parameter could be made const\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid myfunc (      int * param1,  // object is modified\n             const int * param2,\n                   int * param3, // Noncompliant\n             int * const param4) // Noncompliant: const doesn\u0027t qualify what is pointed at.\n{\n  *param1 \u003d *param2 + *param3 + *param4;\n}\n\nvoid increment (int \u0026amp; value,\n                int \u0026amp; increment) // Noncompliant\n{\n  value +\u003d increment;\n}\n\u003c/pre\u003e\n\u003cp\u003eWhen adding all possible \u003ccode\u003econst\u003c/code\u003e qualifications, we get:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid myfunc (      int * param1,  // object is modified\n             const int * param2,\n             const int * param3,\n             const int * param4)\n{\n  *param1 \u003d *param2 + *param3 + *param4;\n}\n\nvoid increment (int \u0026amp; value,\n                const int \u0026amp; increment)\n{\n  value +\u003d increment;\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eArticles \u0026amp; blog posts\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://isocpp.org/wiki/faq/const-correctness\"\u003eISO C++ FAQ about const correctness\u003c/a\u003e. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify\n  the addressed object. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the\n  corresponding object is not modified. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eConst correctness is an important tool for type safety. It allows for catching coding errors at compile time and it documents the code for\nmaintainers.\u003c/p\u003e\n\u003cp\u003eCorrectly const-qualifying pointers can be tricky because the indirection they add can also be const.\u003c/p\u003e\n\u003cp\u003eFor a pointer \u003ccode\u003eX * ptr\u003c/code\u003e, const can be written in three different places:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003econst X * ptr\u003c/code\u003e and \u003ccode\u003eX const * ptr\u003c/code\u003e are identical and mean that the X object \u003ccode\u003eptr\u003c/code\u003e points to cannot be\n  changed. \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003eX * const ptr\u003c/code\u003e means that the pointer cannot be changed to point to a different X object. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn a function signature, the first \u003ccode\u003econst X * ptr\u003c/code\u003e (or its equivalent \u003ccode\u003eX const * ptr\u003c/code\u003e) is the one that will bring\ntype-safety. It protects against changing the value pointed at.\u003c/p\u003e\n\u003cpre\u003e\nvoid externalFunction(int * a, const int * b);\n\nvoid myfunc() {\n  int a \u003d 1;\n  int b \u003d 2;\n  externalFunction(\u0026amp;a, \u0026amp;b);\n  // a can now have any value\n  // We know that b is still \u00272\u0027\n}\n\u003c/pre\u003e\n\u003cp\u003eThis rule detects when a pointer or reference parameter could be made const\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid myfunc (      int * param1,  // object is modified\n             const int * param2,\n                   int * param3, // Noncompliant\n             int * const param4) // Noncompliant: const doesn\u0027t qualify what is pointed at.\n{\n  *param1 \u003d *param2 + *param3 + *param4;\n}\n\nvoid increment (int \u0026amp; value,\n                int \u0026amp; increment) // Noncompliant\n{\n  value +\u003d increment;\n}\n\u003c/pre\u003e\n\u003cp\u003eWhen adding all possible \u003ccode\u003econst\u003c/code\u003e qualifications, we get:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid myfunc (      int * param1,  // object is modified\n             const int * param2,\n             const int * param3,\n             const int * param4)\n{\n  *param1 \u003d *param2 + *param3 + *param4;\n}\n\nvoid increment (int \u0026amp; value,\n                const int \u0026amp; increment)\n{\n  value +\u003d increment;\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eArticles \u0026amp; blog posts\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://isocpp.org/wiki/faq/const-correctness\"\u003eISO C++ FAQ about const correctness\u003c/a\u003e. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify\n  the addressed object. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the\n  corresponding object is not modified. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "bad-practice",
      "misra-c++2008",
      "misra-c2004",
      "misra-c2012"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S872",
    "name": "\"bool\" expressions should not be used as operands to built-in operators other than \u003d, \u0026\u0026, ||, !, \u003d\u003d, !\u003d, unary \u0026, and the conditional operator",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe use of \u003ccode\u003ebool\u003c/code\u003e operands with other operators is unlikely to be meaningful (or intended). Best case it will be confusing to\nmaintainers, worst case it will not have the intended effect. Either way, it is highly recommended to stick to boolean operators when dealing with\n\u003ccode\u003ebool\u003c/code\u003e operands.\u003c/p\u003e\n\u003cp\u003eThis rule allows the detection of such uses, which often occur because the logical operators (\u003ccode\u003e\u0026amp;\u0026amp;\u003c/code\u003e, \u003ccode\u003e||\u003c/code\u003e and\n\u003ccode\u003e!\u003c/code\u003e) can be easily confused with the bitwise operators (\u003ccode\u003e\u0026amp;\u003c/code\u003e, \u003ccode\u003e|\u003c/code\u003e and \u003ccode\u003e~\u003c/code\u003e).\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nbool b1 \u003d true;\nbool b2 \u003d false;\nint8_t s8a;\nif ( b1 \u0026amp; b2 ) // Noncompliant\nif ( ~b1 ) // Noncompliant\nif ( b1 \u0026lt; b2 ) // Noncompliant\nif ( b1 ^ b2 ) // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nif ( b1 \u0026amp;\u0026amp; b2 )\nif ( !b1 )\nif ( b1 \u003d\u003d false )\nif ( b1 \u003d\u003d b2 )\nif ( b1 !\u003d b2 )\ns8a \u003d b1 ? 3 : 7;\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eOperators \u003ccode\u003e|\u003d\u003c/code\u003e and \u003ccode\u003e\u0026amp;\u003d\u003c/code\u003e are ignored when used with \u003ccode\u003ebool\u003c/code\u003e operands. Operator \u003ccode\u003e++\u003c/code\u003e is also ignored\nwith a \u003ccode\u003ebool\u003c/code\u003e operand because it is covered by rule {rule:c:S2668}.\u003c/p\u003e\n\u003cpre\u003e\nvoid test(bool b1, bool b2, int i1) {\n  b1 |\u003d b2; // ignored\n  b1++; // ignored here, handled by S2668\n  b1 \u0026amp;\u003d b2; // ignored\n  b1 \u0026amp;\u003d i1; // Noncompliant; right operand is not a bool\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 4-5-1 - Expressions with type bool shall not be used as operands to built-in operators other than the assignment operator \u003d,\n  the logical operators \u0026amp;\u0026amp;, ||, !, the equality operators \u003d\u003d and !\u003d, the unary \u0026amp; operator, and the conditional operator. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe use of \u003ccode\u003ebool\u003c/code\u003e operands with other operators is unlikely to be meaningful (or intended). Best case it will be confusing to\nmaintainers, worst case it will not have the intended effect. Either way, it is highly recommended to stick to boolean operators when dealing with\n\u003ccode\u003ebool\u003c/code\u003e operands.\u003c/p\u003e\n\u003cp\u003eThis rule allows the detection of such uses, which often occur because the logical operators (\u003ccode\u003e\u0026amp;\u0026amp;\u003c/code\u003e, \u003ccode\u003e||\u003c/code\u003e and\n\u003ccode\u003e!\u003c/code\u003e) can be easily confused with the bitwise operators (\u003ccode\u003e\u0026amp;\u003c/code\u003e, \u003ccode\u003e|\u003c/code\u003e and \u003ccode\u003e~\u003c/code\u003e).\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nbool b1 \u003d true;\nbool b2 \u003d false;\nint8_t s8a;\nif ( b1 \u0026amp; b2 ) // Noncompliant\nif ( ~b1 ) // Noncompliant\nif ( b1 \u0026lt; b2 ) // Noncompliant\nif ( b1 ^ b2 ) // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nif ( b1 \u0026amp;\u0026amp; b2 )\nif ( !b1 )\nif ( b1 \u003d\u003d false )\nif ( b1 \u003d\u003d b2 )\nif ( b1 !\u003d b2 )\ns8a \u003d b1 ? 3 : 7;\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eOperators \u003ccode\u003e|\u003d\u003c/code\u003e and \u003ccode\u003e\u0026amp;\u003d\u003c/code\u003e are ignored when used with \u003ccode\u003ebool\u003c/code\u003e operands. Operator \u003ccode\u003e++\u003c/code\u003e is also ignored\nwith a \u003ccode\u003ebool\u003c/code\u003e operand because it is covered by rule {rule:c:S2668}.\u003c/p\u003e\n\u003cpre\u003e\nvoid test(bool b1, bool b2, int i1) {\n  b1 |\u003d b2; // ignored\n  b1++; // ignored here, handled by S2668\n  b1 \u0026amp;\u003d b2; // ignored\n  b1 \u0026amp;\u003d i1; // Noncompliant; right operand is not a bool\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 4-5-1 - Expressions with type bool shall not be used as operands to built-in operators other than the assignment operator \u003d,\n  the logical operators \u0026amp;\u0026amp;, ||, !, the equality operators \u003d\u003d and !\u003d, the unary \u0026amp; operator, and the conditional operator. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "based-on-misra",
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S873",
    "name": "\"enum\" values should not be used as operands to built-in operators other than [ ], \u003d, \u003d\u003d, !\u003d, unary \u0026, and the relational operators \u003c, \u003c\u003d, \u003e, \u003e\u003d",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eEnumerations are used to represent symbolic values, or sometimes bit fields. They are not supposed to be used in arithmetic contexts.\u003c/p\u003e\n\u003cp\u003eAdditionally, even though comparing them with integer numbers can make sense (for instance, to test if an enum lies with a certain range),\ncomparing them with floating point numbers does not (and is deprecated since C++20).\u003c/p\u003e\n\u003cp\u003eThere are other restrictions related to the use of enums, see for instance {rule:c:S2753}.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nenum { COLOUR_0, COLOUR_1, COLOUR_2, COLOUR_COUNT } colour;\nif ( COLOUR_0 \u003d\u003d colour ) { ... }\nif ( ( COLOUR_0 + COLOUR_1 ) \u003d\u003d colour ) { ... } // Noncompliant, arithmetic used\nif ( colour \u0026lt; COLOUR_COUNT ) { ... }\nif ( colour \u0026gt; 3.14 ) { ... } // Noncompliant, comparison with float\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 4-5-2 - Expressions with type enum shall not be used as operands to builtin operators other than the subscript operator [ ],\n  the assignment operator \u003d, the equality operators \u003d\u003d and !\u003d, the unary \u0026amp; operator, and the relational operators \u0026lt;, \u0026lt;\u003d, \u0026gt;, \u0026gt;\u003d \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eEnumerations are used to represent symbolic values, or sometimes bit fields. They are not supposed to be used in arithmetic contexts.\u003c/p\u003e\n\u003cp\u003eAdditionally, even though comparing them with integer numbers can make sense (for instance, to test if an enum lies with a certain range),\ncomparing them with floating point numbers does not (and is deprecated since C++20).\u003c/p\u003e\n\u003cp\u003eThere are other restrictions related to the use of enums, see for instance {rule:c:S2753}.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nenum { COLOUR_0, COLOUR_1, COLOUR_2, COLOUR_COUNT } colour;\nif ( COLOUR_0 \u003d\u003d colour ) { ... }\nif ( ( COLOUR_0 + COLOUR_1 ) \u003d\u003d colour ) { ... } // Noncompliant, arithmetic used\nif ( colour \u0026lt; COLOUR_COUNT ) { ... }\nif ( colour \u0026gt; 3.14 ) { ... } // Noncompliant, comparison with float\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 4-5-2 - Expressions with type enum shall not be used as operands to builtin operators other than the subscript operator [ ],\n  the assignment operator \u003d, the equality operators \u003d\u003d and !\u003d, the unary \u0026amp; operator, and the relational operators \u0026lt;, \u0026lt;\u003d, \u0026gt;, \u0026gt;\u003d \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "based-on-misra",
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:M23_045",
    "name": "All identifiers used in the controlling expression of \"#if\" or \"#elif\" preprocessing directives shall be defined prior to evaluation",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 19.1.3\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eAs well as using a \u003ccode\u003e#define\u003c/code\u003e preprocessor directive, macro names may effectively be defined in other \u003cem\u003eimplementation-defined\u003c/em\u003e,\nways. For example some implementations support:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Using a compiler command-line option, such as \u003ccode\u003e-D\u003c/code\u003e, to allow macros to be defined prior to translation; \u003c/li\u003e\n  \u003cli\u003e Pre-defined macros provided by the compiler. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eIf an attempt is made to use an identifier in a preprocessor directive, and that identifier has not been defined as a macro name, then the\npreprocessor will assume that it has a value of zero. This may not meet developer expectations.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cp\u003eThe following example assumes that the identifier \u003ccode\u003eM\u003c/code\u003e is not defined as a macro name.\u003c/p\u003e\n\u003cpre\u003e\n#if M \u003d\u003d 0        // Non-compliant\n#endif\n\n#if defined( N )  // Compliant - N is not evaluated, even if not a macro\n#if N \u003d\u003d 0        // Compliant - N is known to be defined at this point\n#endif\n#endif\n\n// Compliant - B is only evaluated in ( B \u003d\u003d 0 ) if it is defined\n#if defined( B ) \u0026amp;\u0026amp; ( B \u003d\u003d 0 )\n#endif\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003e{rule:c:S966} targets the same defect as this rule but for a non-mission-critical context.\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 19.1.3\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eAs well as using a \u003ccode\u003e#define\u003c/code\u003e preprocessor directive, macro names may effectively be defined in other \u003cem\u003eimplementation-defined\u003c/em\u003e,\nways. For example some implementations support:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Using a compiler command-line option, such as \u003ccode\u003e-D\u003c/code\u003e, to allow macros to be defined prior to translation; \u003c/li\u003e\n  \u003cli\u003e Pre-defined macros provided by the compiler. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eIf an attempt is made to use an identifier in a preprocessor directive, and that identifier has not been defined as a macro name, then the\npreprocessor will assume that it has a value of zero. This may not meet developer expectations.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cp\u003eThe following example assumes that the identifier \u003ccode\u003eM\u003c/code\u003e is not defined as a macro name.\u003c/p\u003e\n\u003cpre\u003e\n#if M \u003d\u003d 0        // Non-compliant\n#endif\n\n#if defined( N )  // Compliant - N is not evaluated, even if not a macro\n#if N \u003d\u003d 0        // Compliant - N is known to be defined at this point\n#endif\n#endif\n\n// Compliant - B is only evaluated in ( B \u003d\u003d 0 ) if it is defined\n#if defined( B ) \u0026amp;\u0026amp; ( B \u003d\u003d 0 )\n#endif\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003e{rule:c:S966} targets the same defect as this rule but for a non-mission-critical context.\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "confusing",
      "misra-c++2023",
      "misra-required"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:M23_046",
    "name": "A line whose first token is \"#\" shall be a valid preprocessing directive",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 19.0.1\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eThis rule applies to all the lines within a \u003cem\u003etranslation unit\u003c/em\u003e, even if they are excluded by preprocessing.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e white-space is permitted before and after the \u003ccode\u003e#\u003c/code\u003e token.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eA preprocessor directive may be used to conditionally exclude source code until a corresponding \u003ccode\u003e#else\u003c/code\u003e, \u003ccode\u003e#elif\u003c/code\u003e or\n\u003ccode\u003e#endif\u003c/code\u003e directive is encountered. A malformed or invalid preprocessing directive contained within the excluded source code may not be\ndetected by the compiler, possibly leading to the exclusion of more code than was intended.\u003c/p\u003e\n\u003cp\u003eRequiring all preprocessor directives to be syntactically valid, even when they occur within an excluded block of code, ensures that this cannot\nhappen.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cp\u003eIn the following example all the code between the \u003ccode\u003e#ifndef\u003c/code\u003e and \u003ccode\u003e#endif\u003c/code\u003e directives may be excluded if \u003ccode\u003eAAA\u003c/code\u003e is\ndefined. The developer intended that \u003ccode\u003eAAA\u003c/code\u003e be assigned to \u003ccode\u003ex\u003c/code\u003e, but the \u003ccode\u003e#else\u003c/code\u003e directive was entered incorrectly and\nnot diagnosed by the compiler.\u003c/p\u003e\n\u003cpre\u003e\n#define AAA 2\n\nint32_t foo()\n{\n  int32_t x \u003d 0;\n\n#ifndef AAA\n  x \u003d 1;\n#else1        // Non-compliant\n  x \u003d AAA;\n#endif\n\n  return x;\n}\n\u003c/pre\u003e\n\u003cp\u003eThis rule does not apply to the following examples as the \u003ccode\u003e#\u003c/code\u003e is not a preprocessing token:\u003c/p\u003e\n\u003cpre\u003e\n// Not a preprocessing token within a comment \\\n#not a token\n\nauto s \u003d R\"(\n#text)\";      // Use in a raw string literal is not a preprocessing token\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003e{rule:c:S977} targets the same defect as this rule but for a non-mission-critical context.\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 19.0.1\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eThis rule applies to all the lines within a \u003cem\u003etranslation unit\u003c/em\u003e, even if they are excluded by preprocessing.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e white-space is permitted before and after the \u003ccode\u003e#\u003c/code\u003e token.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eA preprocessor directive may be used to conditionally exclude source code until a corresponding \u003ccode\u003e#else\u003c/code\u003e, \u003ccode\u003e#elif\u003c/code\u003e or\n\u003ccode\u003e#endif\u003c/code\u003e directive is encountered. A malformed or invalid preprocessing directive contained within the excluded source code may not be\ndetected by the compiler, possibly leading to the exclusion of more code than was intended.\u003c/p\u003e\n\u003cp\u003eRequiring all preprocessor directives to be syntactically valid, even when they occur within an excluded block of code, ensures that this cannot\nhappen.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cp\u003eIn the following example all the code between the \u003ccode\u003e#ifndef\u003c/code\u003e and \u003ccode\u003e#endif\u003c/code\u003e directives may be excluded if \u003ccode\u003eAAA\u003c/code\u003e is\ndefined. The developer intended that \u003ccode\u003eAAA\u003c/code\u003e be assigned to \u003ccode\u003ex\u003c/code\u003e, but the \u003ccode\u003e#else\u003c/code\u003e directive was entered incorrectly and\nnot diagnosed by the compiler.\u003c/p\u003e\n\u003cpre\u003e\n#define AAA 2\n\nint32_t foo()\n{\n  int32_t x \u003d 0;\n\n#ifndef AAA\n  x \u003d 1;\n#else1        // Non-compliant\n  x \u003d AAA;\n#endif\n\n  return x;\n}\n\u003c/pre\u003e\n\u003cp\u003eThis rule does not apply to the following examples as the \u003ccode\u003e#\u003c/code\u003e is not a preprocessing token:\u003c/p\u003e\n\u003cpre\u003e\n// Not a preprocessing token within a comment \\\n#not a token\n\nauto s \u003d R\"(\n#text)\";      // Use in a raw string literal is not a preprocessing token\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003e{rule:c:S977} targets the same defect as this rule but for a non-mission-critical context.\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "misra-c++2023",
      "misra-required",
      "unpredictable"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S1820",
    "name": "Structures should not have too many fields",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "FOCUSED",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eA structure, such as a \u003ccode\u003estruct\u003c/code\u003e, \u003ccode\u003eunion\u003c/code\u003e or \u003ccode\u003eclass\u003c/code\u003e that grows too much tends to aggregate too many\nresponsibilities and inevitably becomes harder to understand and therefore to maintain, and having a lot of fields is an indication that a structure\nhas grown too large.\u003c/p\u003e\n\u003cp\u003eAbove a specific threshold, it is strongly advised to refactor the structure into smaller ones that focus on well defined topics.\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eA structure, such as a \u003ccode\u003estruct\u003c/code\u003e, \u003ccode\u003eunion\u003c/code\u003e or \u003ccode\u003eclass\u003c/code\u003e that grows too much tends to aggregate too many\nresponsibilities and inevitably becomes harder to understand and therefore to maintain, and having a lot of fields is an indication that a structure\nhas grown too large.\u003c/p\u003e\n\u003cp\u003eAbove a specific threshold, it is strongly advised to refactor the structure into smaller ones that focus on well defined topics.\u003c/p\u003e"
      }
    ],
    "params": {
      "maximumFieldThreshold": {
        "key": "maximumFieldThreshold",
        "name": "maximumFieldThreshold",
        "description": "The maximum number of fields",
        "defaultValue": "20",
        "type": "INTEGER",
        "multiple": false,
        "possibleValues": []
      }
    },
    "defaultParams": {
      "maximumFieldThreshold": "20"
    },
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "brain-overload"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S1821",
    "name": "\"switch\" statements should not be nested",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "FOCUSED",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eNested \u003ccode\u003eswitch\u003c/code\u003e structures are difficult to understand because you can easily confuse the cases of an inner \u003ccode\u003eswitch\u003c/code\u003e as\nbelonging to an outer statement. Therefore nested \u003ccode\u003eswitch\u003c/code\u003e statements should be avoided.\u003c/p\u003e\n\u003cp\u003eSpecifically, you should structure your code to avoid the need for nested \u003ccode\u003eswitch\u003c/code\u003e statements, but if you cannot, then consider moving\nthe inner \u003ccode\u003eswitch\u003c/code\u003e to another function.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid func(int n, int m) {\n\n  switch (n) {\n    case 1:\n      // ...\n    case 2:\n      // ...\n    case 3:\n      switch (m) {  // Noncompliant\n    case 4:  // Bad indentation makes this particularly hard to read properly\n      // ...\n    case 5:\n      // ...\n    case 6:\n      // ...\n    }\n    case 4:\n      // ...\n    default:\n      // ...\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid func(int n, int m) {\n\n  switch (n) {\n    case 1:\n      // ...\n    case 2:\n      // ...\n    case 3:\n      int m2 \u003d handle_m(m);\n    case 4:\n      // ...\n    default:\n      // ...\n  }\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eNested \u003ccode\u003eswitch\u003c/code\u003e structures are difficult to understand because you can easily confuse the cases of an inner \u003ccode\u003eswitch\u003c/code\u003e as\nbelonging to an outer statement. Therefore nested \u003ccode\u003eswitch\u003c/code\u003e statements should be avoided.\u003c/p\u003e\n\u003cp\u003eSpecifically, you should structure your code to avoid the need for nested \u003ccode\u003eswitch\u003c/code\u003e statements, but if you cannot, then consider moving\nthe inner \u003ccode\u003eswitch\u003c/code\u003e to another function.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid func(int n, int m) {\n\n  switch (n) {\n    case 1:\n      // ...\n    case 2:\n      // ...\n    case 3:\n      switch (m) {  // Noncompliant\n    case 4:  // Bad indentation makes this particularly hard to read properly\n      // ...\n    case 5:\n      // ...\n    case 6:\n      // ...\n    }\n    case 4:\n      // ...\n    default:\n      // ...\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid func(int n, int m) {\n\n  switch (n) {\n    case 1:\n      // ...\n    case 2:\n      // ...\n    case 3:\n      int m2 \u003d handle_m(m);\n    case 4:\n      // ...\n    default:\n      // ...\n  }\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S1705",
    "name": "The prefix increment/decrement form should be used",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "EFFICIENT",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003ePostfix increment and decrement typically involves making a copy of the object being incremented or decremented, whereas its prefix form does not.\nTherefore the prefix form is usually the more efficient form, and should be preferred.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue if a postfix increment or decrement operator is used, but its return value is not read.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid myFunc(int lim)\n{\n  int i;\n  for (i \u003d 0; i \u0026lt; lim; i++)\n  {\n    // do something\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid myFunc(int lim)\n{\n  int i;\n  for (i \u003d 0; i \u0026lt; lim; ++i)\n  {\n    // do something\n  }\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003ePostfix increment and decrement typically involves making a copy of the object being incremented or decremented, whereas its prefix form does not.\nTherefore the prefix form is usually the more efficient form, and should be preferred.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue if a postfix increment or decrement operator is used, but its return value is not read.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid myFunc(int lim)\n{\n  int i;\n  for (i \u003d 0; i \u0026lt; lim; i++)\n  {\n    // do something\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid myFunc(int lim)\n{\n  int i;\n  for (i \u003d 0; i \u0026lt; lim; ++i)\n  {\n    // do something\n  }\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "performance"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S3562",
    "name": "\"switch\" statements should cover all cases",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eFor completeness, a \u003ccode\u003eswitch\u003c/code\u003e over the values of an \u003ccode\u003eenum\u003c/code\u003e must either address each value in the \u003ccode\u003eenum\u003c/code\u003e or contain\na \u003ccode\u003edefault\u003c/code\u003e case. \u003ccode\u003eswitch\u003c/code\u003e statements that are not over \u003ccode\u003eenum\u003c/code\u003e must end with a \u003ccode\u003edefault\u003c/code\u003e case.\u003c/p\u003e\n\u003cp\u003eThis rule is a more nuanced version of {rule:c:S131}. Use {rule:c:S131} if you want to require a \u003ccode\u003edefault\u003c/code\u003e case for every\n\u003ccode\u003eswitch\u003c/code\u003e even if it already handles all enumerators of an \u003ccode\u003eenum\u003c/code\u003e. Otherwise, use this rule.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\ntypedef enum {APPLE, GRAPE, KIWI} fruit;\n\nvoid example(fruit f, int i) {\n  switch (f) {  // Noncompliant; no case for KIWI\n    case APPLE:\n      //...\n    case GRAPE:\n      //...\n    case 3: // Noncompliant; case value not in enum\n      // ...\n  }\n\n  switch (i) { // Noncompliant; no default\n    case 0:\n      // ...\n    case 1:\n      // ...\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\ntypedef enum {APPLE, GRAPE, KIWI} fruit;\n\nvoid example(fruit f) {\n  switch (f) {\n    case APPLE:\n      //...\n    case GRAPE:\n      //...\n    default:\n      // ...\n  }\n\n  switch (i) {\n    case 0:\n      // ...\n    case 1:\n      // ...\n    default:\n      // ...\n  }\n}\n\u003c/pre\u003e\n\u003cp\u003eor\u003c/p\u003e\n\u003cpre\u003e\ntypedef enum {APPLE, GRAPE, KIWI} fruit;\n\nvoid example(fruit f) {\n  switch (f) {\n    case APPLE:\n      //...\n    case GRAPE:\n      //...\n    case KIWI:\n      //...\n  }\n\n  switch (i) {\n    case 0:\n    case 1:\n      // ...\n    default:\n      // ...\n  }\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#enum2-use-enumerations-to-represent-sets-of-related-named-constants\"\u003eEnum.2: Use enumerations to represent sets of related named constants\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:c:S131} \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eFor completeness, a \u003ccode\u003eswitch\u003c/code\u003e over the values of an \u003ccode\u003eenum\u003c/code\u003e must either address each value in the \u003ccode\u003eenum\u003c/code\u003e or contain\na \u003ccode\u003edefault\u003c/code\u003e case. \u003ccode\u003eswitch\u003c/code\u003e statements that are not over \u003ccode\u003eenum\u003c/code\u003e must end with a \u003ccode\u003edefault\u003c/code\u003e case.\u003c/p\u003e\n\u003cp\u003eThis rule is a more nuanced version of {rule:c:S131}. Use {rule:c:S131} if you want to require a \u003ccode\u003edefault\u003c/code\u003e case for every\n\u003ccode\u003eswitch\u003c/code\u003e even if it already handles all enumerators of an \u003ccode\u003eenum\u003c/code\u003e. Otherwise, use this rule.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\ntypedef enum {APPLE, GRAPE, KIWI} fruit;\n\nvoid example(fruit f, int i) {\n  switch (f) {  // Noncompliant; no case for KIWI\n    case APPLE:\n      //...\n    case GRAPE:\n      //...\n    case 3: // Noncompliant; case value not in enum\n      // ...\n  }\n\n  switch (i) { // Noncompliant; no default\n    case 0:\n      // ...\n    case 1:\n      // ...\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\ntypedef enum {APPLE, GRAPE, KIWI} fruit;\n\nvoid example(fruit f) {\n  switch (f) {\n    case APPLE:\n      //...\n    case GRAPE:\n      //...\n    default:\n      // ...\n  }\n\n  switch (i) {\n    case 0:\n      // ...\n    case 1:\n      // ...\n    default:\n      // ...\n  }\n}\n\u003c/pre\u003e\n\u003cp\u003eor\u003c/p\u003e\n\u003cpre\u003e\ntypedef enum {APPLE, GRAPE, KIWI} fruit;\n\nvoid example(fruit f) {\n  switch (f) {\n    case APPLE:\n      //...\n    case GRAPE:\n      //...\n    case KIWI:\n      //...\n  }\n\n  switch (i) {\n    case 0:\n    case 1:\n      // ...\n    default:\n      // ...\n  }\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#enum2-use-enumerations-to-represent-sets-of-related-named-constants\"\u003eEnum.2: Use enumerations to represent sets of related named constants\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:c:S131} \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S881",
    "name": "Increment (++) and decrement (--) operators should not be used in a method call or mixed with other operators in an expression",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe use of increment and decrement operators in method calls or in combination with other arithmetic operators is not recommended, because:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e It can significantly impair the readability of the code. \u003c/li\u003e\n  \u003cli\u003e It introduces additional side effects into a statement, with the potential for undefined behavior. \u003c/li\u003e\n  \u003cli\u003e It is safer to use these operators in isolation from any other arithmetic operators. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nu8a \u003d ++u8b + u8c--;\nfoo \u003d bar++ / 4;\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cp\u003eThe following sequence is clearer and therefore safer:\u003c/p\u003e\n\u003cpre\u003e\n++u8b;\nu8a \u003d u8b + u8c;\nu8c--;\nfoo \u003d bar / 4;\nbar++;\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 12.1 - Limited dependence should be placed on the C operator precedence rules in expressions. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2004, 12.13 - The increment (++) and decrement (--) operators should not be mixed with other operators in an expression. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 5-2-10 - The increment (++) and decrement (--) operator should not be mixed with other operators in an expression. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 12.1 - The precedence of operators within expressions should be made explicit \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 13.3 - A full expression containing an increment (++) or decrement (--) operator should have no other potential side effects\n  other than that cause by the increment or decrement operator \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/StYxBQ\"\u003eCERT, EXP30-C.\u003c/a\u003e - Do not depend on the order of evaluation for side effects \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/IXw-BQ\"\u003eCERT, EXP50-CPP.\u003c/a\u003e - Do not depend on the order of evaluation for side effects \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe use of increment and decrement operators in method calls or in combination with other arithmetic operators is not recommended, because:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e It can significantly impair the readability of the code. \u003c/li\u003e\n  \u003cli\u003e It introduces additional side effects into a statement, with the potential for undefined behavior. \u003c/li\u003e\n  \u003cli\u003e It is safer to use these operators in isolation from any other arithmetic operators. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nu8a \u003d ++u8b + u8c--;\nfoo \u003d bar++ / 4;\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cp\u003eThe following sequence is clearer and therefore safer:\u003c/p\u003e\n\u003cpre\u003e\n++u8b;\nu8a \u003d u8b + u8c;\nu8c--;\nfoo \u003d bar / 4;\nbar++;\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 12.1 - Limited dependence should be placed on the C operator precedence rules in expressions. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2004, 12.13 - The increment (++) and decrement (--) operators should not be mixed with other operators in an expression. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 5-2-10 - The increment (++) and decrement (--) operator should not be mixed with other operators in an expression. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 12.1 - The precedence of operators within expressions should be made explicit \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 13.3 - A full expression containing an increment (++) or decrement (--) operator should have no other potential side effects\n  other than that cause by the increment or decrement operator \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/StYxBQ\"\u003eCERT, EXP30-C.\u003c/a\u003e - Do not depend on the order of evaluation for side effects \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/IXw-BQ\"\u003eCERT, EXP50-CPP.\u003c/a\u003e - Do not depend on the order of evaluation for side effects \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "based-on-misra",
      "cert"
    ],
    "deprecatedKeys": [
      "c:IncAndDecMixedWithOtherOperators"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S1142",
    "name": "Functions should not contain too many return statements",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eHaving too many return statements in a function increases the function’s essential complexity because the flow of execution is broken each time a\nreturn statement is encountered. This makes it harder to read and understand the logic of the function.\u003c/p\u003e\n\u003cp\u003eThe way of counting the return statements is aligned with the way we compute \u003ca\nhref\u003d\"https://www.sonarsource.com/docs/CognitiveComplexity.pdf\"\u003e\u003cstrong\u003eCognitive Complexity\u003c/strong\u003e\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e\"Under Cyclomatic Complexity, a switch is treated as an analog to an if-else if chain […​] but from a maintainer’s point of view, a switch -\nwhich compares a single variable to an explicitly named set of literal values - is much easier to understand than an if-else if chain because the\nlatter may make any number of comparisons, using any number of variables and values. \"\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eAs a consequence, all the return statements located at the top level of case statements (including default) of a same switch statement count all\ntogether as 1.\u003c/p\u003e\n\u003cpre\u003e\n// this counts as 1 return\nint fun() {\n  switch(variable) {\n  case value1:\n    return 1;\n  case value2:\n    return 2;\n  default:\n    return 3;\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cp\u003eWith the default threshold of 3:\u003c/p\u003e\n\u003cpre\u003e\n// this counts as 3 returns\nint fun() {\n  if (condition1) {\n    return 1;\n  } else {\n    if (condition2) {\n      return 0;\n    } else {\n      return 1;\n    }\n  }\n  return 0;\n}\n\u003c/pre\u003e\n\u003cpre\u003e\n// this counts as 3 returns\nint fun() {\n  switch(variable) {\n  case value1:\n    if(condition1) {\n      return 1;\n    } else {\n      return -1;\n    }\n  default:\n    return 2;\n  }\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eHaving too many return statements in a function increases the function’s essential complexity because the flow of execution is broken each time a\nreturn statement is encountered. This makes it harder to read and understand the logic of the function.\u003c/p\u003e\n\u003cp\u003eThe way of counting the return statements is aligned with the way we compute \u003ca\nhref\u003d\"https://www.sonarsource.com/docs/CognitiveComplexity.pdf\"\u003e\u003cstrong\u003eCognitive Complexity\u003c/strong\u003e\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e\"Under Cyclomatic Complexity, a switch is treated as an analog to an if-else if chain […​] but from a maintainer’s point of view, a switch -\nwhich compares a single variable to an explicitly named set of literal values - is much easier to understand than an if-else if chain because the\nlatter may make any number of comparisons, using any number of variables and values. \"\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eAs a consequence, all the return statements located at the top level of case statements (including default) of a same switch statement count all\ntogether as 1.\u003c/p\u003e\n\u003cpre\u003e\n// this counts as 1 return\nint fun() {\n  switch(variable) {\n  case value1:\n    return 1;\n  case value2:\n    return 2;\n  default:\n    return 3;\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cp\u003eWith the default threshold of 3:\u003c/p\u003e\n\u003cpre\u003e\n// this counts as 3 returns\nint fun() {\n  if (condition1) {\n    return 1;\n  } else {\n    if (condition2) {\n      return 0;\n    } else {\n      return 1;\n    }\n  }\n  return 0;\n}\n\u003c/pre\u003e\n\u003cpre\u003e\n// this counts as 3 returns\nint fun() {\n  switch(variable) {\n  case value1:\n    if(condition1) {\n      return 1;\n    } else {\n      return -1;\n    }\n  default:\n    return 2;\n  }\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {
      "max": {
        "key": "max",
        "name": "max",
        "description": "Maximum allowed return statements per function",
        "defaultValue": "3",
        "type": "INTEGER",
        "multiple": false,
        "possibleValues": []
      }
    },
    "defaultParams": {
      "max": "3"
    },
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "brain-overload"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S1264",
    "name": "A \"while\" loop should be used instead of a \"for\" loop",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhen only the condition expression is defined in a \u003ccode\u003efor\u003c/code\u003e loop, and the initialization and increment expressions are missing, a\n\u003ccode\u003ewhile\u003c/code\u003e loop should be used instead to increase readability.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nfor (;condition;) { /*...*/ }\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nwhile (condition) { /*...*/ }\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhen only the condition expression is defined in a \u003ccode\u003efor\u003c/code\u003e loop, and the initialization and increment expressions are missing, a\n\u003ccode\u003ewhile\u003c/code\u003e loop should be used instead to increase readability.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nfor (;condition;) { /*...*/ }\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nwhile (condition) { /*...*/ }\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "clumsy"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S1144",
    "name": "Unused functions and methods should be removed",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003cp\u003eThis rule raises an issue when a function is never referenced in the code.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eA function that is never called is dead code, and should be removed. Cleaning out dead code decreases the size of the maintained codebase, making\nit easier to understand the program and preventing bugs from being introduced.\u003c/p\u003e\n\u003cp\u003eThis rule detects functions that are never referenced from inside a translation unit, and cannot be referenced from the outside.\u003c/p\u003e\n\u003cpre\u003e\nstatic void unusedStaticFunction() { // Noncompliant\n}\n\nclass Server {\npublic:\n  void start() { // Compliant, the member function \"start()\" is public\n    log(\"start\");\n  }\nprivate:\n  void clear() { // Noncompliant, the member function \"clear()\" is unused\n  }\n  void log(const char * msg) { // Compliant, the member function \"log()\" is used in \"start() { ... }\"\n    printf(msg);\n  }\n};\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 0-1-10 - Every defined function shall be called at least once. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eThis rule raises an issue when a function is never referenced in the code.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eA function that is never called is dead code, and should be removed. Cleaning out dead code decreases the size of the maintained codebase, making\nit easier to understand the program and preventing bugs from being introduced.\u003c/p\u003e\n\u003cp\u003eThis rule detects functions that are never referenced from inside a translation unit, and cannot be referenced from the outside.\u003c/p\u003e\n\u003cpre\u003e\nstatic void unusedStaticFunction() { // Noncompliant\n}\n\nclass Server {\npublic:\n  void start() { // Compliant, the member function \"start()\" is public\n    log(\"start\");\n  }\nprivate:\n  void clear() { // Noncompliant, the member function \"clear()\" is unused\n  }\n  void log(const char * msg) { // Compliant, the member function \"log()\" is used in \"start() { ... }\"\n    printf(msg);\n  }\n};\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 0-1-10 - Every defined function shall be called at least once. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "based-on-misra",
      "unused"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S5982",
    "name": "Changing working directories without verifying the success is security-sensitive",
    "defaultSeverity": "CRITICAL",
    "type": "SECURITY_HOTSPOT",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "SECURITY": "HIGH"
    },
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe purpose of changing the current working directory is to modify the base path when the process performs relative path resolutions. When the\nworking directory cannot be changed, the process keeps the directory previously defined as the active working directory. Thus, verifying the success\nof chdir() type of functions is important to prevent unintended relative paths and unauthorized access.\u003c/p\u003e"
      },
      {
        "key": "assess_the_problem",
        "htmlContent": "\u003ch2\u003eAsk Yourself Whether\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e The success of changing the working directory is relevant for the application. \u003c/li\u003e\n  \u003cli\u003e Changing the working directory is required by chroot to make the new root effective. \u003c/li\u003e\n  \u003cli\u003e Subsequent disk operations are using relative paths. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere is a risk if you answered yes to any of those questions.\u003c/p\u003e\n\u003ch2\u003eSensitive Code Example\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003echdir\u003c/code\u003e operation could fail and the process still has access to unauthorized resources. The return code should be verified:\u003c/p\u003e\n\u003cpre\u003e\nconst char* any_dir \u003d \"/any/\";\nchdir(any_dir); // Sensitive: missing check of the return value\n\nint fd \u003d open(any_dir, O_RDONLY | O_DIRECTORY);\nfchdir(fd); // Sensitive: missing check of the return value\n\u003c/pre\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003ch2\u003eRecommended Secure Coding Practices\u003c/h2\u003e\n\u003cp\u003eAfter changing the current working directory verify the success of the operation and handle errors.\u003c/p\u003e\n\u003ch2\u003eCompliant Solution\u003c/h2\u003e\n\u003cp\u003eVerify the return code of \u003ccode\u003echdir\u003c/code\u003e and handle errors:\u003c/p\u003e\n\u003cpre\u003e\nconst char* root_dir \u003d \"/jail/\";\nif (chdir(root_dir) \u003d\u003d -1) {\n  exit(-1);\n} // Compliant\n\nint fd \u003d open(any_dir, O_RDONLY | O_DIRECTORY);\nif(fchdir(fd) \u003d\u003d -1) {\n  exit(-1);\n} // Compliant\n\u003c/pre\u003e\n\u003ch2\u003eSee\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/Top10/A01_2021-Broken_Access_Control/\"\u003eOWASP Top 10 2021 Category A1\u003c/a\u003e - Broken Access Control \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A5-Broken_Access_Control\"\u003eOWASP Top 10 2017 Category A5\u003c/a\u003e -\n  Broken Access Control \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/252\"\u003eMITRE, CWE-252\u003c/a\u003e - Unchecked Return Value \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://man7.org/linux/man-pages/man2/chdir.2.html\"\u003eman7.org\u003c/a\u003e - chdir \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "cwe"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": [],
    "vulnerabilityProbability": "LOW"
  },
  {
    "key": "c:S3687",
    "name": "Atomic types should be used instead of \"volatile\" types",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe main intended use-case for \u003ccode\u003evolatile\u003c/code\u003e in C and C++ is to access data that can be modified by something external to the program,\ntypically some hardware register. In contrast with other languages that provide a \u003ccode\u003evolatile\u003c/code\u003e keyword, it does not provide any useful\nguarantees related to atomicity, memory ordering, or inter-thread synchronization. It is only really needed for the kind of low-level code found in\nkernels or embedded software, i.e. using memory-mapped I/O registers to manipulate hardware directly.\u003c/p\u003e\n\u003cp\u003eAccording to the C standard:\u003c/p\u003e\n\u003cblockquote\u003e\n  \u003cp\u003e\u003ccode\u003evolatile\u003c/code\u003e is a hint to the implementation to avoid aggressive optimization involving the object because the value of the object might\n  be changed by means undetectable by an implementation.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eOnly C11/C++11 \"atomic types\" are free from data races, and you should use them or synchronization primitives if you want to avoid race\nconditions.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when a local variable or class data member is declared as \u003ccode\u003evolatile\u003c/code\u003e (at the top level of the type, pointers\nto volatile are not reported).\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvolatile int counter; // Noncompliant\nUser * volatile vpUser; // Noncompliant; pointer is volatile\nUser volatile * pvUser;  // Compliant; User instance is volatile, not the pointer\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\natomic_int counter;\nstd::atomic\u0026lt;User*\u0026gt; vpUser;\nUser volatile * pvUser;\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/display/c/CON02-C.+Do+not+use+volatile+as+a+synchronization+primitive\"\u003eCERT CON02-C\u003c/a\u003e - Do not\n  use volatile as a synchronization primitive \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#cp200-use-volatile-only-to-talk-to-non-c-memory\"\u003eCP.200: Use\n  \u003ccode\u003evolatile\u003c/code\u003e only to talk to non-C++ memory\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe main intended use-case for \u003ccode\u003evolatile\u003c/code\u003e in C and C++ is to access data that can be modified by something external to the program,\ntypically some hardware register. In contrast with other languages that provide a \u003ccode\u003evolatile\u003c/code\u003e keyword, it does not provide any useful\nguarantees related to atomicity, memory ordering, or inter-thread synchronization. It is only really needed for the kind of low-level code found in\nkernels or embedded software, i.e. using memory-mapped I/O registers to manipulate hardware directly.\u003c/p\u003e\n\u003cp\u003eAccording to the C standard:\u003c/p\u003e\n\u003cblockquote\u003e\n  \u003cp\u003e\u003ccode\u003evolatile\u003c/code\u003e is a hint to the implementation to avoid aggressive optimization involving the object because the value of the object might\n  be changed by means undetectable by an implementation.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eOnly C11/C++11 \"atomic types\" are free from data races, and you should use them or synchronization primitives if you want to avoid race\nconditions.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when a local variable or class data member is declared as \u003ccode\u003evolatile\u003c/code\u003e (at the top level of the type, pointers\nto volatile are not reported).\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvolatile int counter; // Noncompliant\nUser * volatile vpUser; // Noncompliant; pointer is volatile\nUser volatile * pvUser;  // Compliant; User instance is volatile, not the pointer\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\natomic_int counter;\nstd::atomic\u0026lt;User*\u0026gt; vpUser;\nUser volatile * pvUser;\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/display/c/CON02-C.+Do+not+use+volatile+as+a+synchronization+primitive\"\u003eCERT CON02-C\u003c/a\u003e - Do not\n  use volatile as a synchronization primitive \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#cp200-use-volatile-only-to-talk-to-non-c-memory\"\u003eCP.200: Use\n  \u003ccode\u003evolatile\u003c/code\u003e only to talk to non-C++ memory\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "c11",
      "cert",
      "cppcoreguidelines",
      "multi-threading",
      "since-c++11"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S2234",
    "name": "Parameters should be passed in the correct order",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhen the names of parameters in a method call match the names of the method arguments, it contributes to clearer, more readable code. However, when\nthe names match, but are passed in a different order than the method arguments, it indicates a mistake in the parameter order which will likely lead\nto unexpected results.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint divide(int divisor, int dividend) {\n  return divisor / dividend;\n}\n\nvoid doTheThing() {\n  int divisor \u003d 15;\n  int dividend \u003d 5;\n\n  int result \u003d divide(dividend, divisor);  // Noncompliant; operation succeeds, but result is unexpected\n  //...\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint divide(int divisor, int dividend) {\n  return divisor / dividend;\n}\n\nvoid doTheThing() {\n  int divisor \u003d 15;\n  int dividend \u003d 5;\n\n  int result \u003d divide(divisor, dividend);\n  //...\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhen the names of parameters in a method call match the names of the method arguments, it contributes to clearer, more readable code. However, when\nthe names match, but are passed in a different order than the method arguments, it indicates a mistake in the parameter order which will likely lead\nto unexpected results.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint divide(int divisor, int dividend) {\n  return divisor / dividend;\n}\n\nvoid doTheThing() {\n  int divisor \u003d 15;\n  int dividend \u003d 5;\n\n  int result \u003d divide(dividend, divisor);  // Noncompliant; operation succeeds, but result is unexpected\n  //...\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint divide(int divisor, int dividend) {\n  return divisor / dividend;\n}\n\nvoid doTheThing() {\n  int divisor \u003d 15;\n  int dividend \u003d 5;\n\n  int result \u003d divide(divisor, dividend);\n  //...\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S2479",
    "name": "Control characters should not be used in literals",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eControl characters (e.g., tabs or carriage returns) are not visible to maintainers, so they should be escaped.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nconst char* foo \u003d \"A\tB\";  // Noncompliant: contains a tabulation\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nconst char* foo \u003d \"A\\tB\";  // Compliant: use escaped value\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThis rule does not raise issues in raw string literals since they have no escape character mechanism.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e Wikipedia - \u003ca href\u003d\"https://en.wikipedia.org/wiki/Control_character\"\u003eControl character\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eControl characters (e.g., tabs or carriage returns) are not visible to maintainers, so they should be escaped.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nconst char* foo \u003d \"A\tB\";  // Noncompliant: contains a tabulation\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nconst char* foo \u003d \"A\\tB\";  // Compliant: use escaped value\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThis rule does not raise issues in raw string literals since they have no escape character mechanism.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e Wikipedia - \u003ca href\u003d\"https://en.wikipedia.org/wiki/Control_character\"\u003eControl character\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S3689",
    "name": "Declaration specifiers should not be redundant",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eRedundant declaration specifiers should be removed or corrected. Typically, they represent bugs. A specifier modifies the type or pointer to its\nleft. Only when it is at the far left does it apply to the right.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nconst int const * v1a; // Noncompliant; both const specifiers apply to int\nconst int const * v1b; // Noncompliant\nstatic static int v2;  // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nconst int *       v1a;  // pointer to a const int. same meaning as before but less confusing\nint const * const v1b;  // const pointer to a const int\nstatic int         v2;\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eRedundant declaration specifiers should be removed or corrected. Typically, they represent bugs. A specifier modifies the type or pointer to its\nleft. Only when it is at the far left does it apply to the right.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nconst int const * v1a; // Noncompliant; both const specifiers apply to int\nconst int const * v1b; // Noncompliant\nstatic static int v2;  // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nconst int *       v1a;  // pointer to a const int. same meaning as before but less confusing\nint const * const v1b;  // const pointer to a const int\nstatic int         v2;\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "redundant"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S5501",
    "name": "\"#pragma pack\" should be used correctly",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003e#pragma pack\u003c/code\u003e is a non-standard extension that specifies the packing alignment for structure, union, and class members.\u003c/p\u003e\n\u003cp\u003eIt is useful to\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e remove padding and decrease the size of objects \u003c/li\u003e\n  \u003cli\u003e align members to better fit optimal cpu alignment \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eHowever, the pragma pack directives need to be correctly defined to work properly.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue if:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e the specified packing value is incorrect: it can only be 1, 2, 4, 8, or 16 \u003c/li\u003e\n  \u003cli\u003e a parameter is ill-formed \u003c/li\u003e\n  \u003cli\u003e the \u003ccode\u003epop\u003c/code\u003e variant of this \u003ccode\u003e#pragma\u003c/code\u003e is called with both arguments \u003ccode\u003eidentifier\u003c/code\u003e and \u003ccode\u003evalue\u003c/code\u003e: such a\n  call is undefined behavior \u003c/li\u003e\n  \u003cli\u003e a \u003ccode\u003e#pragma pack(push...)\u003c/code\u003e is performed but there is not corresponding use of \u003ccode\u003e#pragma pack(pop...)\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e a \u003ccode\u003e#pragma pack(pop...)\u003c/code\u003e is performed but there is not corresponding use of \u003ccode\u003e#pragma pack(push...)\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e a \u003ccode\u003e#pragma pack\u003c/code\u003e is in effect across several files: this becomes too complex and could easily lead to undefined behavior, the same\n  structure having a different layout when seen from different translation units \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#pragma pack(5) // Noncompliant, value is invalid\n#pragma pack(2+2) // Noncompliant, value should be a literal\n\n#pragma pack(4)\n#include \"myFile.h\" // Noncompliant, the specified alignment value will be applied to this file\n\nstruct T {\n   int i;\n   short j;\n   double k;\n};\n\n#pragma pack(push, r1, 16)\n#pragma pack(pop, r1, 4)  // Noncompliant, call to pop with two arguments is undefined\n\n#pragma pack(push, r2, 16) // Noncompliant, call to push with no matching pop\n#pragma pack(pop, r3)  // Noncompliant, call to pop with no matching push\n\n#pragma pack(push, 8) // Noncompliant, unmatched push\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#include \"myFile.h\"\n\n#pragma pack(4)\n\nstruct T {\n   int i;\n   short j;\n   double k;\n};\n\n#pragma pack(push, r1, 16)\n#pragma pack(pop, r1)\n\n#pragma pack(push, r2, 16)\n#pragma pack(pop, r2)\n\n#pragma pack(push, 8)\n#pragma pack(pop)\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003ccode\u003e#pragma pack\u003c/code\u003e is a non-standard extension that specifies the packing alignment for structure, union, and class members.\u003c/p\u003e\n\u003cp\u003eIt is useful to\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e remove padding and decrease the size of objects \u003c/li\u003e\n  \u003cli\u003e align members to better fit optimal cpu alignment \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eHowever, the pragma pack directives need to be correctly defined to work properly.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue if:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e the specified packing value is incorrect: it can only be 1, 2, 4, 8, or 16 \u003c/li\u003e\n  \u003cli\u003e a parameter is ill-formed \u003c/li\u003e\n  \u003cli\u003e the \u003ccode\u003epop\u003c/code\u003e variant of this \u003ccode\u003e#pragma\u003c/code\u003e is called with both arguments \u003ccode\u003eidentifier\u003c/code\u003e and \u003ccode\u003evalue\u003c/code\u003e: such a\n  call is undefined behavior \u003c/li\u003e\n  \u003cli\u003e a \u003ccode\u003e#pragma pack(push...)\u003c/code\u003e is performed but there is not corresponding use of \u003ccode\u003e#pragma pack(pop...)\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e a \u003ccode\u003e#pragma pack(pop...)\u003c/code\u003e is performed but there is not corresponding use of \u003ccode\u003e#pragma pack(push...)\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e a \u003ccode\u003e#pragma pack\u003c/code\u003e is in effect across several files: this becomes too complex and could easily lead to undefined behavior, the same\n  structure having a different layout when seen from different translation units \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#pragma pack(5) // Noncompliant, value is invalid\n#pragma pack(2+2) // Noncompliant, value should be a literal\n\n#pragma pack(4)\n#include \"myFile.h\" // Noncompliant, the specified alignment value will be applied to this file\n\nstruct T {\n   int i;\n   short j;\n   double k;\n};\n\n#pragma pack(push, r1, 16)\n#pragma pack(pop, r1, 4)  // Noncompliant, call to pop with two arguments is undefined\n\n#pragma pack(push, r2, 16) // Noncompliant, call to push with no matching pop\n#pragma pack(pop, r3)  // Noncompliant, call to pop with no matching push\n\n#pragma pack(push, 8) // Noncompliant, unmatched push\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#include \"myFile.h\"\n\n#pragma pack(4)\n\nstruct T {\n   int i;\n   short j;\n   double k;\n};\n\n#pragma pack(push, r1, 16)\n#pragma pack(pop, r1)\n\n#pragma pack(push, r2, 16)\n#pragma pack(pop, r2)\n\n#pragma pack(push, 8)\n#pragma pack(pop)\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S5293",
    "name": "Format strings should comply with ISO standards",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe possibilities of ISO C \u003ccode\u003eprintf\u003c/code\u003e format strings are limited, this is why many extensions have been added by several implementations.\nEven though they are widespread and similar in many implementations, they are not standard, which means that using them may create portability\nissues.\u003c/p\u003e\n\u003cp\u003eThis rule reports an issue when format strings do not comply with ISO C standards.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid test() {\n  printf(\"%1$d\", 1); // Noncompliant; positional arguments are not supported by ISO C\n  printf(\"%qd\", (long long)1); // Noncompliant; length specifier \"q\" is not supported by ISO C\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe possibilities of ISO C \u003ccode\u003eprintf\u003c/code\u003e format strings are limited, this is why many extensions have been added by several implementations.\nEven though they are widespread and similar in many implementations, they are not standard, which means that using them may create portability\nissues.\u003c/p\u003e\n\u003cp\u003eThis rule reports an issue when format strings do not comply with ISO C standards.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid test() {\n  printf(\"%1$d\", 1); // Noncompliant; positional arguments are not supported by ISO C\n  printf(\"%qd\", (long long)1); // Noncompliant; length specifier \"q\" is not supported by ISO C\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "convention"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S867",
    "name": "Boolean operations should not have numeric operands, and vice versa",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThere are several constructs in the language that work with boolean:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e If statements: \u003ccode\u003eif (b) ...\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e Conditional operator: \u003ccode\u003eint i \u003d b ? 0 : 42;\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e Logical operators: \u003ccode\u003e(b1 || b2) \u0026amp;\u0026amp; !b3\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThose operations would also work with arithmetic or enum values operands, because there is a conversion from those types to bool. However, this\nconversion might not always be obvious, for instance, an integer return code might use the value \u003ccode\u003e0\u003c/code\u003e to indicate that everything worked as\nexpected, but converted to boolean, this value would be \u003ccode\u003efalse\u003c/code\u003e, which often denotes failure. Conversion from integer to bool should be\nexplicit.\u003c/p\u003e\n\u003cp\u003eMoreover, a logical operation with integer types might also be a confusion with the bitwise operators (\u003ccode\u003e\u0026amp;\u003c/code\u003e, \u003ccode\u003e|\u003c/code\u003e and\n\u003ccode\u003e~\u003c/code\u003e).\u003c/p\u003e\n\u003cp\u003eConverting a pointer to \u003ccode\u003ebool\u003c/code\u003e to check if it is null is idiomatic and is allowed by this rule. We also allow the use of any\nuser-defined type convertible to bool (for instance \u003ccode\u003estd::ostream\u003c/code\u003e), since they were specifically designed to be used in such situations.\nWhat this rule really detects is the use or arithmetic types (\u003ccode\u003eint\u003c/code\u003e, \u003ccode\u003elong\u003c/code\u003e…​) and of enum types.\u003c/p\u003e\n\u003cp\u003eOn the other hand, arithmetic operations are defined with booleans, but usually make little sense (think of adding two booleans). Booleans should\nnot be used in an arithmetic context.\u003c/p\u003e\n\u003cp\u003eFinally, comparing a boolean with the literals \u003ccode\u003etrue\u003c/code\u003e or \u003ccode\u003efalse\u003c/code\u003e is unnecessarily verbose, and should be avoided.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nif ( 1 \u0026amp;\u0026amp; ( c \u0026lt; d ) ) // Noncompliant\nif ( ( a \u0026lt; b ) \u0026amp;\u0026amp; ( c + d ) ) // Noncompliant\nif ( u8_a \u0026amp;\u0026amp; ( c + d ) ) // Noncompliant\nif ( !0 ) // Noncompliant, always true\nif ( !ptr ) // Compliant\nif ( ( a \u0026lt; b ) \u0026amp;\u0026amp; ( c \u0026lt; d ) ) // Compliant\nif ( !false ) // Compliant\nif (!!a) // Compliant by exception\nif ( ( a \u0026lt; b ) \u003d\u003d true) // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nif ( 1 !\u003d 0 \u0026amp;\u0026amp; ( c \u0026lt; d ) ) // Compliant, but left operand is always true\nif ( ( a \u0026lt; b ) \u0026amp;\u0026amp; ( c + d ) !\u003d 0 ) // Compliant\nif ( u8_a !\u003d 0 \u0026amp;\u0026amp; ( c + d ) !\u003d 0) // Compliant\nif ( 0 \u003d\u003d 0 ) // Compliant, always true\nif ( a \u0026lt; b )\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eSome people use \u003ccode\u003e!!\u003c/code\u003e as a shortcut to cast an integer to bool. This usage of the \u003ccode\u003e!\u003c/code\u003e operator with an integer argument is\nallowed for this rule.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 12.6 - The operands of logical operators (\u0026amp;\u0026amp;, || and !) should be effectively Boolean. Expressions that are effectively\n  Boolean should not be used as operands to operators other than (\u0026amp;\u0026amp;, || and !). \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 5-3-1 - Each operand of the ! operator, the logical \u0026amp;\u0026amp; or the logical || operators shall have type bool. \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/display/c/EXP13-C.+Treat+relational+and+equality+operators+as+if+they+were+nonassociative\"\u003eCERT,\n  EXP13-C.\u003c/a\u003e - Treat relational and equality operators as if they were nonassociative \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es87-dont-add-redundant—​or—​to-conditions\"\u003eES.87: Don’t add\n  redundant \u003ccode\u003e\u003d\u003d\u003c/code\u003e or \u003ccode\u003e!\u003d\u003c/code\u003e to conditions\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThere are several constructs in the language that work with boolean:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e If statements: \u003ccode\u003eif (b) ...\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e Conditional operator: \u003ccode\u003eint i \u003d b ? 0 : 42;\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e Logical operators: \u003ccode\u003e(b1 || b2) \u0026amp;\u0026amp; !b3\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThose operations would also work with arithmetic or enum values operands, because there is a conversion from those types to bool. However, this\nconversion might not always be obvious, for instance, an integer return code might use the value \u003ccode\u003e0\u003c/code\u003e to indicate that everything worked as\nexpected, but converted to boolean, this value would be \u003ccode\u003efalse\u003c/code\u003e, which often denotes failure. Conversion from integer to bool should be\nexplicit.\u003c/p\u003e\n\u003cp\u003eMoreover, a logical operation with integer types might also be a confusion with the bitwise operators (\u003ccode\u003e\u0026amp;\u003c/code\u003e, \u003ccode\u003e|\u003c/code\u003e and\n\u003ccode\u003e~\u003c/code\u003e).\u003c/p\u003e\n\u003cp\u003eConverting a pointer to \u003ccode\u003ebool\u003c/code\u003e to check if it is null is idiomatic and is allowed by this rule. We also allow the use of any\nuser-defined type convertible to bool (for instance \u003ccode\u003estd::ostream\u003c/code\u003e), since they were specifically designed to be used in such situations.\nWhat this rule really detects is the use or arithmetic types (\u003ccode\u003eint\u003c/code\u003e, \u003ccode\u003elong\u003c/code\u003e…​) and of enum types.\u003c/p\u003e\n\u003cp\u003eOn the other hand, arithmetic operations are defined with booleans, but usually make little sense (think of adding two booleans). Booleans should\nnot be used in an arithmetic context.\u003c/p\u003e\n\u003cp\u003eFinally, comparing a boolean with the literals \u003ccode\u003etrue\u003c/code\u003e or \u003ccode\u003efalse\u003c/code\u003e is unnecessarily verbose, and should be avoided.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nif ( 1 \u0026amp;\u0026amp; ( c \u0026lt; d ) ) // Noncompliant\nif ( ( a \u0026lt; b ) \u0026amp;\u0026amp; ( c + d ) ) // Noncompliant\nif ( u8_a \u0026amp;\u0026amp; ( c + d ) ) // Noncompliant\nif ( !0 ) // Noncompliant, always true\nif ( !ptr ) // Compliant\nif ( ( a \u0026lt; b ) \u0026amp;\u0026amp; ( c \u0026lt; d ) ) // Compliant\nif ( !false ) // Compliant\nif (!!a) // Compliant by exception\nif ( ( a \u0026lt; b ) \u003d\u003d true) // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nif ( 1 !\u003d 0 \u0026amp;\u0026amp; ( c \u0026lt; d ) ) // Compliant, but left operand is always true\nif ( ( a \u0026lt; b ) \u0026amp;\u0026amp; ( c + d ) !\u003d 0 ) // Compliant\nif ( u8_a !\u003d 0 \u0026amp;\u0026amp; ( c + d ) !\u003d 0) // Compliant\nif ( 0 \u003d\u003d 0 ) // Compliant, always true\nif ( a \u0026lt; b )\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eSome people use \u003ccode\u003e!!\u003c/code\u003e as a shortcut to cast an integer to bool. This usage of the \u003ccode\u003e!\u003c/code\u003e operator with an integer argument is\nallowed for this rule.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 12.6 - The operands of logical operators (\u0026amp;\u0026amp;, || and !) should be effectively Boolean. Expressions that are effectively\n  Boolean should not be used as operands to operators other than (\u0026amp;\u0026amp;, || and !). \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 5-3-1 - Each operand of the ! operator, the logical \u0026amp;\u0026amp; or the logical || operators shall have type bool. \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/display/c/EXP13-C.+Treat+relational+and+equality+operators+as+if+they+were+nonassociative\"\u003eCERT,\n  EXP13-C.\u003c/a\u003e - Treat relational and equality operators as if they were nonassociative \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es87-dont-add-redundant—​or—​to-conditions\"\u003eES.87: Don’t add\n  redundant \u003ccode\u003e\u003d\u003d\u003c/code\u003e or \u003ccode\u003e!\u003d\u003c/code\u003e to conditions\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "based-on-misra",
      "cert",
      "cppcoreguidelines"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S988",
    "name": "\"\u003cstdio.h\u003e\" should not be used in production code",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThis includes file and I/O functions \u003ccode\u003efgetpos\u003c/code\u003e, \u003ccode\u003efopen\u003c/code\u003e, \u003ccode\u003eftell\u003c/code\u003e, \u003ccode\u003egets\u003c/code\u003e, \u003ccode\u003eperror\u003c/code\u003e,\n\u003ccode\u003eremove\u003c/code\u003e, \u003ccode\u003erename\u003c/code\u003e and \u003ccode\u003eungetc\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eStreams and file I/O have a large number of unspecified, undefined and implementation-defined behaviors associated with them. It is assumed within\nMISRA C that they will not normally be needed in production code in embedded systems.\u003c/p\u003e\n\u003cp\u003eIf any of the features of \u003ccode\u003estdio.h\u003c/code\u003e need to be used in production code, then the issues associated with the features need to be\nunderstood.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;stdio.h\u0026gt; /* Noncompliant */\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 20.9 - The input/output library \u0026lt;stdio.h\u0026gt; shall not be used in production code. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 27-0-1 - The stream input/output library \u0026lt;cstdio\u0026gt; shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 21.6 - The Standard Library input/output functions shall not be used \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThis includes file and I/O functions \u003ccode\u003efgetpos\u003c/code\u003e, \u003ccode\u003efopen\u003c/code\u003e, \u003ccode\u003eftell\u003c/code\u003e, \u003ccode\u003egets\u003c/code\u003e, \u003ccode\u003eperror\u003c/code\u003e,\n\u003ccode\u003eremove\u003c/code\u003e, \u003ccode\u003erename\u003c/code\u003e and \u003ccode\u003eungetc\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eStreams and file I/O have a large number of unspecified, undefined and implementation-defined behaviors associated with them. It is assumed within\nMISRA C that they will not normally be needed in production code in embedded systems.\u003c/p\u003e\n\u003cp\u003eIf any of the features of \u003ccode\u003estdio.h\u003c/code\u003e need to be used in production code, then the issues associated with the features need to be\nunderstood.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;stdio.h\u0026gt; /* Noncompliant */\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 20.9 - The input/output library \u0026lt;stdio.h\u0026gt; shall not be used in production code. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 27-0-1 - The stream input/output library \u0026lt;cstdio\u0026gt; shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 21.6 - The Standard Library input/output functions shall not be used \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "based-on-misra",
      "lock-in"
    ],
    "deprecatedKeys": [
      "c:PPIncludeStdio"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S868",
    "name": "Operands of \"\u0026\u0026\" and \"||\" should be primary (C) or postfix (C++) expressions",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe effect of this rule is to require that operands are appropriately parenthesized. Parentheses are important in this situation both for\nreadability of code and for ensuring that the behavior is as the developer intended.\u003c/p\u003e\n\u003cp\u003eWhere an expression consists of either a sequence of only logical \u003ccode\u003e\u0026amp;\u0026amp;\u003c/code\u003e or a sequence of logical \u003ccode\u003e||\u003c/code\u003e, extra\nparentheses are not required.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nif (x \u003d\u003d 0 \u0026amp;\u0026amp; ishigh);                   // Noncompliant\nif (x || y || z);\nif (x || y \u0026amp;\u0026amp; z);                        // Noncompliant\nif (x \u0026amp;\u0026amp; !y);                            // Noncompliant\nif (is_odd(y) \u0026amp;\u0026amp; x);\nif ((x \u0026gt; c1) \u0026amp;\u0026amp; (y \u0026gt; c2) \u0026amp;\u0026amp; (z \u0026gt; c3));\nif ((x \u0026gt; c1) \u0026amp;\u0026amp; (y \u0026gt; c2) || (z \u0026gt; c3));   // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nif ((x \u003d\u003d 0) \u0026amp;\u0026amp; ishigh);\nif (x || y || z);\nif (x || (y \u0026amp;\u0026amp; z));\nif (x \u0026amp;\u0026amp; (!y));\nif (is_odd(y) \u0026amp;\u0026amp; x);\nif ((x \u0026gt; c1) \u0026amp;\u0026amp; (y \u0026gt; c2) \u0026amp;\u0026amp; (z \u0026gt; c3));\nif ((x \u0026gt; c1) \u0026amp;\u0026amp; ((y \u0026gt; c2) || (z \u0026gt; c3)));\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 12.5 - The operands of a logical \u0026amp;\u0026amp; or || shall be primary-expressions. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 5-2-1 - Each operand of a logical \u0026amp;\u0026amp; or || shall be a postfix-expression. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe effect of this rule is to require that operands are appropriately parenthesized. Parentheses are important in this situation both for\nreadability of code and for ensuring that the behavior is as the developer intended.\u003c/p\u003e\n\u003cp\u003eWhere an expression consists of either a sequence of only logical \u003ccode\u003e\u0026amp;\u0026amp;\u003c/code\u003e or a sequence of logical \u003ccode\u003e||\u003c/code\u003e, extra\nparentheses are not required.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nif (x \u003d\u003d 0 \u0026amp;\u0026amp; ishigh);                   // Noncompliant\nif (x || y || z);\nif (x || y \u0026amp;\u0026amp; z);                        // Noncompliant\nif (x \u0026amp;\u0026amp; !y);                            // Noncompliant\nif (is_odd(y) \u0026amp;\u0026amp; x);\nif ((x \u0026gt; c1) \u0026amp;\u0026amp; (y \u0026gt; c2) \u0026amp;\u0026amp; (z \u0026gt; c3));\nif ((x \u0026gt; c1) \u0026amp;\u0026amp; (y \u0026gt; c2) || (z \u0026gt; c3));   // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nif ((x \u003d\u003d 0) \u0026amp;\u0026amp; ishigh);\nif (x || y || z);\nif (x || (y \u0026amp;\u0026amp; z));\nif (x \u0026amp;\u0026amp; (!y));\nif (is_odd(y) \u0026amp;\u0026amp; x);\nif ((x \u0026gt; c1) \u0026amp;\u0026amp; (y \u0026gt; c2) \u0026amp;\u0026amp; (z \u0026gt; c3));\nif ((x \u0026gt; c1) \u0026amp;\u0026amp; ((y \u0026gt; c2) || (z \u0026gt; c3)));\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 12.5 - The operands of a logical \u0026amp;\u0026amp; or || shall be primary-expressions. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 5-2-1 - Each operand of a logical \u0026amp;\u0026amp; or || shall be a postfix-expression. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "based-on-misra"
    ],
    "deprecatedKeys": [
      "c:LogicalExpressionOperands"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S989",
    "name": "\"atof\", \"atoi\" and \"atol\" from \u003cstdlib.h\u003e should not be used",
    "defaultSeverity": "CRITICAL",
    "type": "BUG",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003e\u0026lt;stdlib.h\u0026gt;\u003c/code\u003e\u0027s \u003ccode\u003eatof\u003c/code\u003e, \u003ccode\u003eatoi\u003c/code\u003e, and \u003ccode\u003eatol\u003c/code\u003e functions, which convert strings to numbers, have\nundefined behavior when the strings cannot be converted, and should therefore be avoided.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint converter (const char * numstr) {\n  return atoi(numstr); // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint converter (const char * numstr) {\n  return strtol(numstr, NULL, 10);\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 20.10 - The library functions atof, atoi and atol from library \u0026lt;stdlib.h\u0026gt; shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 18-0-2 - The library functions atof, atoi and atol from library \u0026lt;cstdlib\u0026gt; shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 21.7 - The atof, atoi, atol and atoll functions of \u0026lt;stdlib.h\u0026gt; shall not be used \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/C9cxBQ\"\u003eCERT, ERR34-C.\u003c/a\u003e - Detect errors when converting a string to a number \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003ccode\u003e\u0026lt;stdlib.h\u0026gt;\u003c/code\u003e\u0027s \u003ccode\u003eatof\u003c/code\u003e, \u003ccode\u003eatoi\u003c/code\u003e, and \u003ccode\u003eatol\u003c/code\u003e functions, which convert strings to numbers, have\nundefined behavior when the strings cannot be converted, and should therefore be avoided.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint converter (const char * numstr) {\n  return atoi(numstr); // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint converter (const char * numstr) {\n  return strtol(numstr, NULL, 10);\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 20.10 - The library functions atof, atoi and atol from library \u0026lt;stdlib.h\u0026gt; shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 18-0-2 - The library functions atof, atoi and atol from library \u0026lt;cstdlib\u0026gt; shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 21.7 - The atof, atoi, atol and atoll functions of \u0026lt;stdlib.h\u0026gt; shall not be used \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/C9cxBQ\"\u003eCERT, ERR34-C.\u003c/a\u003e - Detect errors when converting a string to a number \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "based-on-misra",
      "cert"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S986",
    "name": "\"offsetof\" macro should not be used",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eoffsetof\u003c/code\u003e can lead to undefined behavior when the argument types are incompatible or when bit fields are used. Therefore\n\u003ccode\u003eoffsetof\u003c/code\u003e should be avoided.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;stddef.h\u0026gt;\n\nstruct A\n{\n  int32_t i;\n};\n\nvoid f1 ( )\n{\n  offsetof ( A, i ); // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 20.6 - The macro offsetof, in library \u0026lt;stddef.h\u0026gt;, shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2008, 18-2-1 - The macro offsetof, in library \u0026lt;stddef.h\u0026gt;, shall not be used. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003ccode\u003eoffsetof\u003c/code\u003e can lead to undefined behavior when the argument types are incompatible or when bit fields are used. Therefore\n\u003ccode\u003eoffsetof\u003c/code\u003e should be avoided.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;stddef.h\u0026gt;\n\nstruct A\n{\n  int32_t i;\n};\n\nvoid f1 ( )\n{\n  offsetof ( A, i ); // Noncompliant\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 20.6 - The macro offsetof, in library \u0026lt;stddef.h\u0026gt;, shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2008, 18-2-1 - The macro offsetof, in library \u0026lt;stddef.h\u0026gt;, shall not be used. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "misra-c++2008",
      "misra-c2004",
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S987",
    "name": "\"\u003csignal.h\u003e\" should not be used",
    "defaultSeverity": "CRITICAL",
    "type": "BUG",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eSignal handling contains implementation-defined and undefined behavior.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;signal.h\u0026gt; /* Noncompliant */\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 20.8 - The signal handling facilities of \u0026lt;signal.h\u0026gt; shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 21.5 - The standard header file \u0026lt;signal.h\u0026gt; shall not be used \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eSignal handling contains implementation-defined and undefined behavior.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;signal.h\u0026gt; /* Noncompliant */\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 20.8 - The signal handling facilities of \u0026lt;signal.h\u0026gt; shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 21.5 - The standard header file \u0026lt;signal.h\u0026gt; shall not be used \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "based-on-misra",
      "lock-in"
    ],
    "deprecatedKeys": [
      "c:PPIncludeSignal"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S5297",
    "name": "GNU attributes should be used correctly",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003e__attribute__\u003c/code\u003e is a GNU extension that allows to decorate functions, parameters, variables…​ with some attributes. It may help for\ncompiler optimizations or for the writer of some code to better state his intent (and have the compiler check it).\u003c/p\u003e\n\u003cp\u003eIf this extension is used incorrectly, it will usually not break the build, but it still means that the code may not behave as the developer\nexpects. This rule reports such occurrences of bad use of \u003ccode\u003e__attribute__\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint f1() __attribute__((returns_nonnull)); // Noncompliant; \"returns_nonnull\" only applies to return values which are pointers\n\nvoid g(int *a) __attribute__((nonnull(1))){} // Noncompliant; \"nonnull\" position in the function definition is not allowed\n\nvoid h() __attribute__((warn_unused_result)); // Noncompliant; \"warn_unused_result\" does not work with function without return value\n\nvoid test() {\n  int __declspec(empty_bases)i; // Noncompliant; \"empty_bases\" only applies to classes\n  char c \u003d (char __attribute__((aligned(8)))) i; // Noncompliant, attribute is ignored\n}}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003ccode\u003e__attribute__\u003c/code\u003e is a GNU extension that allows to decorate functions, parameters, variables…​ with some attributes. It may help for\ncompiler optimizations or for the writer of some code to better state his intent (and have the compiler check it).\u003c/p\u003e\n\u003cp\u003eIf this extension is used incorrectly, it will usually not break the build, but it still means that the code may not behave as the developer\nexpects. This rule reports such occurrences of bad use of \u003ccode\u003e__attribute__\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint f1() __attribute__((returns_nonnull)); // Noncompliant; \"returns_nonnull\" only applies to return values which are pointers\n\nvoid g(int *a) __attribute__((nonnull(1))){} // Noncompliant; \"nonnull\" position in the function definition is not allowed\n\nvoid h() __attribute__((warn_unused_result)); // Noncompliant; \"warn_unused_result\" does not work with function without return value\n\nvoid test() {\n  int __declspec(empty_bases)i; // Noncompliant; \"empty_bases\" only applies to classes\n  char c \u003d (char __attribute__((aligned(8)))) i; // Noncompliant, attribute is ignored\n}}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "confusing"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S984",
    "name": "Dynamic heap memory allocation should not be used",
    "defaultSeverity": "CRITICAL",
    "type": "BUG",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe use of dynamic memory can lead to out-of-storage run-time failures, which are undesirable.\u003c/p\u003e\n\u003cp\u003eThe built-in \u003ccode\u003enew\u003c/code\u003e and \u003ccode\u003edelete\u003c/code\u003e operators, other than the placement versions, use dynamic heap memory. The functions\n\u003ccode\u003ecalloc\u003c/code\u003e, \u003ccode\u003emalloc\u003c/code\u003e, \u003ccode\u003erealloc\u003c/code\u003e and \u003ccode\u003efree\u003c/code\u003e also use dynamic heap memory.\u003c/p\u003e\n\u003cp\u003eThere is a range of unspecified, undefined and implementation-defined behaviour associated with dynamic memory allocation, as well as a number of\nother potential pitfalls. Dynamic heap memory allocation may lead to memory leaks, data inconsistency, memory exhaustion, non-deterministic behaviour,\netc.\u003c/p\u003e\n\u003cp\u003eNote that some implementations may use dynamic heap memory allocation to implement other functions (for example, functions in the library\n\u003ccode\u003ecstring\u003c/code\u003e). If this is the case, then these functions shall also be avoided.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint *b;\nvoid initialize()\n{\n  b \u003d (int*) malloc(1024 * sizeof(int)); // Noncompliant, could lead to an out-of-storage run-time failure.\n  if (b \u003d\u003d 0)\n  {\n    // handle case when dynamic allocation failed.\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint b[1024]; // Compliant solution.\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 20.4 - Dynamic heap memory allocation shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2008, 18-4-1 - Dynamic heap memory allocation shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 21.3 The memory allocation and deallocation functions of \u0026lt;stdlib.h\u0026gt; shall not be used \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe use of dynamic memory can lead to out-of-storage run-time failures, which are undesirable.\u003c/p\u003e\n\u003cp\u003eThe built-in \u003ccode\u003enew\u003c/code\u003e and \u003ccode\u003edelete\u003c/code\u003e operators, other than the placement versions, use dynamic heap memory. The functions\n\u003ccode\u003ecalloc\u003c/code\u003e, \u003ccode\u003emalloc\u003c/code\u003e, \u003ccode\u003erealloc\u003c/code\u003e and \u003ccode\u003efree\u003c/code\u003e also use dynamic heap memory.\u003c/p\u003e\n\u003cp\u003eThere is a range of unspecified, undefined and implementation-defined behaviour associated with dynamic memory allocation, as well as a number of\nother potential pitfalls. Dynamic heap memory allocation may lead to memory leaks, data inconsistency, memory exhaustion, non-deterministic behaviour,\netc.\u003c/p\u003e\n\u003cp\u003eNote that some implementations may use dynamic heap memory allocation to implement other functions (for example, functions in the library\n\u003ccode\u003ecstring\u003c/code\u003e). If this is the case, then these functions shall also be avoided.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint *b;\nvoid initialize()\n{\n  b \u003d (int*) malloc(1024 * sizeof(int)); // Noncompliant, could lead to an out-of-storage run-time failure.\n  if (b \u003d\u003d 0)\n  {\n    // handle case when dynamic allocation failed.\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint b[1024]; // Compliant solution.\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 20.4 - Dynamic heap memory allocation shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2008, 18-4-1 - Dynamic heap memory allocation shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 21.3 The memory allocation and deallocation functions of \u0026lt;stdlib.h\u0026gt; shall not be used \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "based-on-misra",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S864",
    "name": "Limited dependence should be placed on operator precedence",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe rules of operator precedence are complicated and can lead to errors. For this reason, parentheses should be used for clarification in complex\nstatements. However, this does not mean that parentheses should be gratuitously added around every operation.\u003c/p\u003e\n\u003cp\u003eParentheses are not needed:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e with a unary operator, except when \u003ccode\u003e!\u003c/code\u003e is used as left operand in comparison expressions \u003c/li\u003e\n  \u003cli\u003e when all the operators in an expression are the same \u003c/li\u003e\n  \u003cli\u003e when only a single operator is involved \u003c/li\u003e\n  \u003cli\u003e around the right-hand side of an assignment operator unless the right-hand side itself contains an assignment \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eParentheses are needed:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e in the condition of a ternary operator if it uses operators \u003c/li\u003e\n  \u003cli\u003e when overloaded shift operator \u003ccode\u003e\u0026lt;\u0026lt;\u003c/code\u003e or \u003ccode\u003e\u0026gt;\u0026gt;\u003c/code\u003e is used in an expression with comparison operators \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nx \u003d a + b;\nx \u003d a * -1;\nx \u003d a + b + c;\nx \u003d f ( a + b, c );\n\nx \u003d a \u003d\u003d b ? a : a - b; // Noncompliant\nx \u003d a + b - c + d; // Noncompliant\nx \u003d a * 3 + c + d; // Noncompliant\n\nif (a \u003d f(b,c) \u003d\u003d true) { ... } // Noncompliant; \u003d\u003d evaluated first\nx - b ? a : c; // Noncompliant; \"-\" evaluated first\ns \u0026lt;\u0026lt; 5 \u003d\u003d 1; // Noncompliant; \"\u0026lt;\u0026lt;\" evaluated first\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nx \u003d a + b;\nx \u003d a * -1;\nx \u003d a + b + c;\nx \u003d f ( a + b, c );\n\nx \u003d ( a \u003d\u003d b ) ? a : ( a - b );\nx \u003d ( a + b ) - ( c + d );\nx \u003d ( a * 3 ) + c + d;\n\nif ( (a \u003d f(b,c)) \u003d\u003d true) { ... }\n(x - b) ? a : c; // Compliant\n(s \u0026lt;\u0026lt; 5) \u003d\u003d 1; // Compliant\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 12.1 - Limited dependence should be placed on C’s operator precedence rules in expressions \u003c/li\u003e\n  \u003cli\u003e MISRA C:2004, 12.2 - The value of an expression shall be the same under any order of evaluation that the standard permits. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2004, 12.5 - The operands of a logical \u0026amp;\u0026amp; or || shall be primary-expressions. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 5-0-1 - The value of an expression shall be the same under any order of evaluation that the standard permits. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 5-0-2 - Limited dependence should be placed on C++ operator precedence rules in expressions \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 5-2-1 - Each operand of a logical \u0026amp;\u0026amp; or || shall be a postfix-expression. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 12.1 - The precedence of operators within expressions should be made explicit \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/YdYxBQ\"\u003eCERT, EXP00-C.\u003c/a\u003e - Use parentheses for precedence of operation \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/783\"\u003eMITRE, CWE-783\u003c/a\u003e - Operator Precedence Logic Error \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe rules of operator precedence are complicated and can lead to errors. For this reason, parentheses should be used for clarification in complex\nstatements. However, this does not mean that parentheses should be gratuitously added around every operation.\u003c/p\u003e\n\u003cp\u003eParentheses are not needed:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e with a unary operator, except when \u003ccode\u003e!\u003c/code\u003e is used as left operand in comparison expressions \u003c/li\u003e\n  \u003cli\u003e when all the operators in an expression are the same \u003c/li\u003e\n  \u003cli\u003e when only a single operator is involved \u003c/li\u003e\n  \u003cli\u003e around the right-hand side of an assignment operator unless the right-hand side itself contains an assignment \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eParentheses are needed:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e in the condition of a ternary operator if it uses operators \u003c/li\u003e\n  \u003cli\u003e when overloaded shift operator \u003ccode\u003e\u0026lt;\u0026lt;\u003c/code\u003e or \u003ccode\u003e\u0026gt;\u0026gt;\u003c/code\u003e is used in an expression with comparison operators \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nx \u003d a + b;\nx \u003d a * -1;\nx \u003d a + b + c;\nx \u003d f ( a + b, c );\n\nx \u003d a \u003d\u003d b ? a : a - b; // Noncompliant\nx \u003d a + b - c + d; // Noncompliant\nx \u003d a * 3 + c + d; // Noncompliant\n\nif (a \u003d f(b,c) \u003d\u003d true) { ... } // Noncompliant; \u003d\u003d evaluated first\nx - b ? a : c; // Noncompliant; \"-\" evaluated first\ns \u0026lt;\u0026lt; 5 \u003d\u003d 1; // Noncompliant; \"\u0026lt;\u0026lt;\" evaluated first\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nx \u003d a + b;\nx \u003d a * -1;\nx \u003d a + b + c;\nx \u003d f ( a + b, c );\n\nx \u003d ( a \u003d\u003d b ) ? a : ( a - b );\nx \u003d ( a + b ) - ( c + d );\nx \u003d ( a * 3 ) + c + d;\n\nif ( (a \u003d f(b,c)) \u003d\u003d true) { ... }\n(x - b) ? a : c; // Compliant\n(s \u0026lt;\u0026lt; 5) \u003d\u003d 1; // Compliant\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 12.1 - Limited dependence should be placed on C’s operator precedence rules in expressions \u003c/li\u003e\n  \u003cli\u003e MISRA C:2004, 12.2 - The value of an expression shall be the same under any order of evaluation that the standard permits. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2004, 12.5 - The operands of a logical \u0026amp;\u0026amp; or || shall be primary-expressions. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 5-0-1 - The value of an expression shall be the same under any order of evaluation that the standard permits. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 5-0-2 - Limited dependence should be placed on C++ operator precedence rules in expressions \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 5-2-1 - Each operand of a logical \u0026amp;\u0026amp; or || shall be a postfix-expression. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 12.1 - The precedence of operators within expressions should be made explicit \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/YdYxBQ\"\u003eCERT, EXP00-C.\u003c/a\u003e - Use parentheses for precedence of operation \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/783\"\u003eMITRE, CWE-783\u003c/a\u003e - Operator Precedence Logic Error \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "cert",
      "cwe"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S985",
    "name": "\"errno\" should not be used",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eerrno\u003c/code\u003e is a facility of C++ which should in theory be useful, but which in practice is poorly defined by ISO/IEC 14882:2003. A non-zero\nvalue may or may not indicate that a problem has occurred; therefore \u003ccode\u003eerrno\u003c/code\u003e shall not be used.\u003c/p\u003e\n\u003cp\u003eEven for those functions for which the behaviour of \u003ccode\u003eerrno\u003c/code\u003e is well defined, it is preferable to check the values of inputs before\ncalling the function rather than relying on using \u003ccode\u003eerrno\u003c/code\u003e to trap errors.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;cstdlib\u0026gt;\n#include \u0026lt;cerrno\u0026gt;\n\nvoid f1 (const char * str)\n{\n  errno \u003d 0; // Noncompliant\n  int i \u003d atoi(str);\n  if ( 0 !\u003d errno ) // Noncompliant\n  {\n    // handle error case???\n  }\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 20.5 - The error indicator errno shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 19-3-1 - The error indicator errno shall not be used. \u003c/li\u003e\n  \u003cli\u003e ISO/IEC 14882:2003 \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003ccode\u003eerrno\u003c/code\u003e is a facility of C++ which should in theory be useful, but which in practice is poorly defined by ISO/IEC 14882:2003. A non-zero\nvalue may or may not indicate that a problem has occurred; therefore \u003ccode\u003eerrno\u003c/code\u003e shall not be used.\u003c/p\u003e\n\u003cp\u003eEven for those functions for which the behaviour of \u003ccode\u003eerrno\u003c/code\u003e is well defined, it is preferable to check the values of inputs before\ncalling the function rather than relying on using \u003ccode\u003eerrno\u003c/code\u003e to trap errors.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;cstdlib\u0026gt;\n#include \u0026lt;cerrno\u0026gt;\n\nvoid f1 (const char * str)\n{\n  errno \u003d 0; // Noncompliant\n  int i \u003d atoi(str);\n  if ( 0 !\u003d errno ) // Noncompliant\n  {\n    // handle error case???\n  }\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 20.5 - The error indicator errno shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 19-3-1 - The error indicator errno shall not be used. \u003c/li\u003e\n  \u003cli\u003e ISO/IEC 14882:2003 \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "based-on-misra",
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S982",
    "name": "\"setjmp\" and \"longjmp\" should not be used",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003esetjmp.h\u003c/code\u003e functions allow the normal function mechanisms to be bypassed and should be used only with extreme caution, if at all.\u003c/p\u003e\n\u003cp\u003eCalling \u003ccode\u003esetjmp\u003c/code\u003e saves the program environment into the buffer passed into the call. Later calling \u003ccode\u003elongjmp\u003c/code\u003e returns\nexecution to the point at which \u003ccode\u003esetjmp\u003c/code\u003e was called and restores the context that was saved into the buffer. But the values of non-volatile\nlocal variables after \u003ccode\u003elongjmp\u003c/code\u003e are indeterminate. Additionally invoking \u003ccode\u003elongjmp\u003c/code\u003e from a nested signal handler is undefined, as\nis \u003ccode\u003elongjmp\u003c/code\u003eing back to a method that has already completed execution.\u003c/p\u003e\n\u003cp\u003eThis rule flags all instances of \u003ccode\u003esetjmp\u003c/code\u003e, \u003ccode\u003e_setjmp\u003c/code\u003e, \u003ccode\u003elongjmp\u003c/code\u003e, \u003ccode\u003e_longjmp\u003c/code\u003e, \u003ccode\u003esigsetjmp\u003c/code\u003e,\n\u003ccode\u003esiglongjmp\u003c/code\u003e and \u003ccode\u003e\u0026lt;setjmp.h\u0026gt;\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;setjmp.h\u0026gt;  // Noncompliant\n\njmp_buf buf;\n\nint main(int argc, char* argv[]) {\n  int i \u003d setjmp(buf);  // Noncompliant\n  if (i \u003d\u003d 0) { // value of i was assigned after env was saved \u0026amp; will be indeterminate after longjmp();\n    // normal execution\n  } else {\n    // recover\n  }\n}\n\n//...\n\nvoid fun() {\n  //...\n  longjmp(buf, 1);  // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint main(int argc, char* argv[]) {\n  // normal execution\n}\n\n//...\n\nvoid fun() {\n  //...\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 20.7 - The setjmp macro and the longjmp function shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 17-0-5 - The setjmp macro and the longjmp function shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 21.4 - The standard header file \u0026lt;setjmp.h\u0026gt; shall not be used \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/ktYxBQ\"\u003eCERT, MSC22-C.\u003c/a\u003e - Use the setjmp(), longjmp() facility securely \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/nHs-BQ\"\u003eCERT, ERR52-CPP.\u003c/a\u003e - Do not use setjmp() or longjmp() \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003ccode\u003esetjmp.h\u003c/code\u003e functions allow the normal function mechanisms to be bypassed and should be used only with extreme caution, if at all.\u003c/p\u003e\n\u003cp\u003eCalling \u003ccode\u003esetjmp\u003c/code\u003e saves the program environment into the buffer passed into the call. Later calling \u003ccode\u003elongjmp\u003c/code\u003e returns\nexecution to the point at which \u003ccode\u003esetjmp\u003c/code\u003e was called and restores the context that was saved into the buffer. But the values of non-volatile\nlocal variables after \u003ccode\u003elongjmp\u003c/code\u003e are indeterminate. Additionally invoking \u003ccode\u003elongjmp\u003c/code\u003e from a nested signal handler is undefined, as\nis \u003ccode\u003elongjmp\u003c/code\u003eing back to a method that has already completed execution.\u003c/p\u003e\n\u003cp\u003eThis rule flags all instances of \u003ccode\u003esetjmp\u003c/code\u003e, \u003ccode\u003e_setjmp\u003c/code\u003e, \u003ccode\u003elongjmp\u003c/code\u003e, \u003ccode\u003e_longjmp\u003c/code\u003e, \u003ccode\u003esigsetjmp\u003c/code\u003e,\n\u003ccode\u003esiglongjmp\u003c/code\u003e and \u003ccode\u003e\u0026lt;setjmp.h\u0026gt;\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;setjmp.h\u0026gt;  // Noncompliant\n\njmp_buf buf;\n\nint main(int argc, char* argv[]) {\n  int i \u003d setjmp(buf);  // Noncompliant\n  if (i \u003d\u003d 0) { // value of i was assigned after env was saved \u0026amp; will be indeterminate after longjmp();\n    // normal execution\n  } else {\n    // recover\n  }\n}\n\n//...\n\nvoid fun() {\n  //...\n  longjmp(buf, 1);  // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint main(int argc, char* argv[]) {\n  // normal execution\n}\n\n//...\n\nvoid fun() {\n  //...\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 20.7 - The setjmp macro and the longjmp function shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 17-0-5 - The setjmp macro and the longjmp function shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 21.4 - The standard header file \u0026lt;setjmp.h\u0026gt; shall not be used \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/ktYxBQ\"\u003eCERT, MSC22-C.\u003c/a\u003e - Use the setjmp(), longjmp() facility securely \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/nHs-BQ\"\u003eCERT, ERR52-CPP.\u003c/a\u003e - Do not use setjmp() or longjmp() \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "based-on-misra",
      "cert",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:M23_058",
    "name": "The names of the \"standard signed integer types\" and \"standard unsigned integer types\" should not be used",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW",
      "RELIABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 6.9.2\u003c/p\u003e\n\u003cp\u003eCategory: Advisory\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eThis rule applies to the names of integral types constructed using the keywords \u003ccode\u003echar\u003c/code\u003e, \u003ccode\u003eshort\u003c/code\u003e, \u003ccode\u003eint\u003c/code\u003e,\n\u003ccode\u003elong\u003c/code\u003e, \u003ccode\u003esigned\u003c/code\u003e and \u003ccode\u003eunsigned\u003c/code\u003e (ignoring any \u003cem\u003ecv-qualification\u003c/em\u003e). It does not apply to the use of plain\n\u003ccode\u003echar\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eIt is \u003cem\u003eimplementation-defined\u003c/em\u003e how much storage is required for any object of the \u003cem\u003estandard signed integer types\u003c/em\u003e or \u003cem\u003estandard\nunsigned integer types\u003c/em\u003e. When the amount of storage being used is important, the use of types having specified widths makes it clear how much\nstorage is being reserved for each object.\u003c/p\u003e\n\u003cp\u003eThe C++ Standard Library \u003cem\u003eheader file\u003c/em\u003e [1] \u003ccode\u003e\u0026lt;cstdint\u0026gt;\u003c/code\u003e often provides a suitable set of integer types having specified\nwidths. If a project defines its own type aliases, it is good practice to use \u003ccode\u003estatic_assert\u003c/code\u003e to validate any size assumptions. For\nexample:\u003c/p\u003e\n\u003cpre\u003e\nusing torque_t \u003d unsigned short;\n\nstatic_assert( sizeof( torque_t ) \u0026gt;\u003d 2 );\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eNotes:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Adherence to this rule does not prevent integer promotion, which is influenced by the implemented size of \u003ccode\u003eint\u003c/code\u003e and the type used\n  for an alias. For example, an expression of type \u003ccode\u003eint16_t\u003c/code\u003e will only be promoted if the aliased type has a rank lower than that of\n  \u003ccode\u003eint\u003c/code\u003e. The presence or absence of integer promotion may have an influence on overload resolution. \u003c/li\u003e\n  \u003cli\u003e Strong typing, which may be provided by class or enum types, is more robust than the use of type aliases to represent specific width types.\n  \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eException\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e The names of the \u003cem\u003estandard signed integer types\u003c/em\u003e and \u003cem\u003estandard unsigned integer types\u003c/em\u003e may be used to define a type alias. \u003c/li\u003e\n  \u003cli\u003e The name \u003ccode\u003eint\u003c/code\u003e may be used for: \u003c/li\u003e\n  \u003cli\u003e The parameter to a postfix operator, which \u003cem\u003emust\u003c/em\u003e use that type; and \u003c/li\u003e\n  \u003cli\u003e The return type of \u003ccode\u003emain\u003c/code\u003e; and \u003c/li\u003e\n  \u003cli\u003e The \u003ccode\u003eargc\u003c/code\u003e parameter to \u003ccode\u003emain\u003c/code\u003e. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;cstdint\u0026gt;\n\nint           x \u003d 0;                     // Non-compliant - use of int\nint32_t       y \u003d 0;                     // Compliant\nint_least32_t z \u003d 0;                     // Compliant\n\nusing torque_t \u003d int;                    // Compliant by exception #1\ntorque_t w \u003d 0;\n\nclass C\n{\npublic:\n  C  operator++ ( int );                 // Compliant by exception #2.1\n};\n\nint main() { }                           // Compliant by exception #2.2\nint main( int argc, char * argv[] ) { }  // Compliant by exception #2.2 and #2.3\n\u003c/pre\u003e\n\u003ch3\u003eGlossary\u003c/h3\u003e\n\u003ch4\u003e[1] Header file\u003c/h4\u003e\n\u003cp\u003eA \u003cem\u003eheader file\u003c/em\u003e is considered to be any file that is included during preprocessing (for example via the \u003ccode\u003e#include\u003c/code\u003e directive),\nregardless of its name or suffix.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 6.9.2\u003c/p\u003e\n\u003cp\u003eCategory: Advisory\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eThis rule applies to the names of integral types constructed using the keywords \u003ccode\u003echar\u003c/code\u003e, \u003ccode\u003eshort\u003c/code\u003e, \u003ccode\u003eint\u003c/code\u003e,\n\u003ccode\u003elong\u003c/code\u003e, \u003ccode\u003esigned\u003c/code\u003e and \u003ccode\u003eunsigned\u003c/code\u003e (ignoring any \u003cem\u003ecv-qualification\u003c/em\u003e). It does not apply to the use of plain\n\u003ccode\u003echar\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eIt is \u003cem\u003eimplementation-defined\u003c/em\u003e how much storage is required for any object of the \u003cem\u003estandard signed integer types\u003c/em\u003e or \u003cem\u003estandard\nunsigned integer types\u003c/em\u003e. When the amount of storage being used is important, the use of types having specified widths makes it clear how much\nstorage is being reserved for each object.\u003c/p\u003e\n\u003cp\u003eThe C++ Standard Library \u003cem\u003eheader file\u003c/em\u003e [1] \u003ccode\u003e\u0026lt;cstdint\u0026gt;\u003c/code\u003e often provides a suitable set of integer types having specified\nwidths. If a project defines its own type aliases, it is good practice to use \u003ccode\u003estatic_assert\u003c/code\u003e to validate any size assumptions. For\nexample:\u003c/p\u003e\n\u003cpre\u003e\nusing torque_t \u003d unsigned short;\n\nstatic_assert( sizeof( torque_t ) \u0026gt;\u003d 2 );\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eNotes:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Adherence to this rule does not prevent integer promotion, which is influenced by the implemented size of \u003ccode\u003eint\u003c/code\u003e and the type used\n  for an alias. For example, an expression of type \u003ccode\u003eint16_t\u003c/code\u003e will only be promoted if the aliased type has a rank lower than that of\n  \u003ccode\u003eint\u003c/code\u003e. The presence or absence of integer promotion may have an influence on overload resolution. \u003c/li\u003e\n  \u003cli\u003e Strong typing, which may be provided by class or enum types, is more robust than the use of type aliases to represent specific width types.\n  \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eException\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e The names of the \u003cem\u003estandard signed integer types\u003c/em\u003e and \u003cem\u003estandard unsigned integer types\u003c/em\u003e may be used to define a type alias. \u003c/li\u003e\n  \u003cli\u003e The name \u003ccode\u003eint\u003c/code\u003e may be used for: \u003c/li\u003e\n  \u003cli\u003e The parameter to a postfix operator, which \u003cem\u003emust\u003c/em\u003e use that type; and \u003c/li\u003e\n  \u003cli\u003e The return type of \u003ccode\u003emain\u003c/code\u003e; and \u003c/li\u003e\n  \u003cli\u003e The \u003ccode\u003eargc\u003c/code\u003e parameter to \u003ccode\u003emain\u003c/code\u003e. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;cstdint\u0026gt;\n\nint           x \u003d 0;                     // Non-compliant - use of int\nint32_t       y \u003d 0;                     // Compliant\nint_least32_t z \u003d 0;                     // Compliant\n\nusing torque_t \u003d int;                    // Compliant by exception #1\ntorque_t w \u003d 0;\n\nclass C\n{\npublic:\n  C  operator++ ( int );                 // Compliant by exception #2.1\n};\n\nint main() { }                           // Compliant by exception #2.2\nint main( int argc, char * argv[] ) { }  // Compliant by exception #2.2 and #2.3\n\u003c/pre\u003e\n\u003ch3\u003eGlossary\u003c/h3\u003e\n\u003ch4\u003e[1] Header file\u003c/h4\u003e\n\u003cp\u003eA \u003cem\u003eheader file\u003c/em\u003e is considered to be any file that is included during preprocessing (for example via the \u003ccode\u003e#include\u003c/code\u003e directive),\nregardless of its name or suffix.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "misra-advisory",
      "misra-c++2023",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S1259",
    "name": "\"typedef\" should be used for function pointers",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eFunction pointer syntax can be hard on the eyes, particularly when one function is used as a parameter to another. Providing and using a\n\u003ccode\u003etypedef\u003c/code\u003e instead (or a \u003ccode\u003eusing\u003c/code\u003e in C++) can make code easier to read, and should be preferred.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nextern void (*signal(int, void(*)(int)))(int);\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\ntypedef void (*SignalHandler)(int signum);\nextern SignalHandler signal(int signum, SignalHandler handler);\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eFunction pointer syntax can be hard on the eyes, particularly when one function is used as a parameter to another. Providing and using a\n\u003ccode\u003etypedef\u003c/code\u003e instead (or a \u003ccode\u003eusing\u003c/code\u003e in C++) can make code easier to read, and should be preferred.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nextern void (*signal(int, void(*)(int)))(int);\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\ntypedef void (*SignalHandler)(int signum);\nextern SignalHandler signal(int signum, SignalHandler handler);\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S5978",
    "name": "Multicharacter literals should not be used",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eMulticharacter literals have \u003ccode\u003eint\u003c/code\u003e type and have an implementation-defined value. This means they might be interpreted differently by\ndifferent compilers. For example, they might lead to different behavior when compiled with GCC than when compiled with MSVC.\u003c/p\u003e\n\u003cp\u003eEven if they work as you expect with a specific compiler, they will make your code less portable. They are also misleading as they look like\nstrings, hence make your code less readable.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid f(int i) {\n  // ...\n  if (i \u003d\u003d \u0027abcd\u0027) { // Noncompliant\n    // ...\n  }\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eMulticharacter literals have \u003ccode\u003eint\u003c/code\u003e type and have an implementation-defined value. This means they might be interpreted differently by\ndifferent compilers. For example, they might lead to different behavior when compiled with GCC than when compiled with MSVC.\u003c/p\u003e\n\u003cp\u003eEven if they work as you expect with a specific compiler, they will make your code less portable. They are also misleading as they look like\nstrings, hence make your code less readable.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid f(int i) {\n  // ...\n  if (i \u003d\u003d \u0027abcd\u0027) { // Noncompliant\n    // ...\n  }\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "confusing",
      "lock-in"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S2583",
    "name": "Conditionally executed code should be reachable",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eConditional expressions which are always \u003ccode\u003etrue\u003c/code\u003e or \u003ccode\u003efalse\u003c/code\u003e can lead to \u003ca\nhref\u003d\"https://en.wikipedia.org/wiki/Unreachable_code\"\u003eunreachable code\u003c/a\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\na \u003d false;\nif (a) { // Noncompliant\n  doSomething(); // never executed\n}\n\nif (!a || b) { // Noncompliant; \"!a\" is always \"true\", \"b\" is never evaluated\n  doSomething();\n} else {\n  doSomethingElse(); // never executed\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 13.7 - Boolean operations whose results are invariant shall not be permitted. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 14.3 - Controlling expressions shall not be invariant \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/570\"\u003eMITRE, CWE-570\u003c/a\u003e - Expression is Always False \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/571\"\u003eMITRE, CWE-571\u003c/a\u003e - Expression is Always True \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/5dUxBQ\"\u003eCERT, MSC12-C.\u003c/a\u003e - Detect and remove code that has no effect or is never executed\n  \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eConditional expressions which are always \u003ccode\u003etrue\u003c/code\u003e or \u003ccode\u003efalse\u003c/code\u003e can lead to \u003ca\nhref\u003d\"https://en.wikipedia.org/wiki/Unreachable_code\"\u003eunreachable code\u003c/a\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\na \u003d false;\nif (a) { // Noncompliant\n  doSomething(); // never executed\n}\n\nif (!a || b) { // Noncompliant; \"!a\" is always \"true\", \"b\" is never evaluated\n  doSomething();\n} else {\n  doSomethingElse(); // never executed\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 13.7 - Boolean operations whose results are invariant shall not be permitted. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 14.3 - Controlling expressions shall not be invariant \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/570\"\u003eMITRE, CWE-570\u003c/a\u003e - Expression is Always False \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/571\"\u003eMITRE, CWE-571\u003c/a\u003e - Expression is Always True \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/5dUxBQ\"\u003eCERT, MSC12-C.\u003c/a\u003e - Detect and remove code that has no effect or is never executed\n  \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "based-on-misra",
      "cert",
      "cwe",
      "pitfall",
      "suspicious",
      "unused"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S991",
    "name": "\"\u003ctime.h\u003e\" should not be used",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eIncludes \u003ccode\u003etime\u003c/code\u003e, \u003ccode\u003estrftime\u003c/code\u003e. This library is associated with clock times. Various aspects are implementation dependent or\nunspecified, such as the formats of times. If any of the facilities of \u003ccode\u003etime.h\u003c/code\u003e are used, then the exact implementation for the compiler\nbeing used must be determined, and a deviation raised.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;time.h\u0026gt;  /* Noncompliant */\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 20.12 - The time handling functions of library \u0026lt;time.h\u0026gt; shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 21.10 - The Standard Library time and date functions shall not be used \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eIncludes \u003ccode\u003etime\u003c/code\u003e, \u003ccode\u003estrftime\u003c/code\u003e. This library is associated with clock times. Various aspects are implementation dependent or\nunspecified, such as the formats of times. If any of the facilities of \u003ccode\u003etime.h\u003c/code\u003e are used, then the exact implementation for the compiler\nbeing used must be determined, and a deviation raised.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;time.h\u0026gt;  /* Noncompliant */\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 20.12 - The time handling functions of library \u0026lt;time.h\u0026gt; shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 21.10 - The Standard Library time and date functions shall not be used \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "based-on-misra",
      "lock-in"
    ],
    "deprecatedKeys": [
      "c:PPIncludeTime"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S1131",
    "name": "Lines should not end with trailing whitespaces",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "FORMATTED",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eTrailing whitespaces bring no information, they may generate noise when comparing different versions of the same file, and they can create bugs\nwhen they appear after a \u003ccode\u003e\\\u003c/code\u003e marking a line continuation. They should be systematically removed.\u003c/p\u003e\n\u003cp\u003eAn automated code formatter allows to completely avoid this family of issues and should be used wherever possible.\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eTrailing whitespaces bring no information, they may generate noise when comparing different versions of the same file, and they can create bugs\nwhen they appear after a \u003ccode\u003e\\\u003c/code\u003e marking a line continuation. They should be systematically removed.\u003c/p\u003e\n\u003cp\u003eAn automated code formatter allows to completely avoid this family of issues and should be used wherever possible.\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "convention"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S2343",
    "name": "Enumeration values should comply with a naming convention",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "IDENTIFIABLE",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eShared coding conventions allow teams to collaborate efficiently. This rule checks that all enumeration values match a provided regular\nexpression.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cp\u003eWith default provided regular expression:\u003c/p\u003e\n\u003cpre\u003e\nenum SomeEnumeration {\n    some  // Non-Compliant\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nenum SomeEnumeration {\n    SOME\n};\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eShared coding conventions allow teams to collaborate efficiently. This rule checks that all enumeration values match a provided regular\nexpression.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cp\u003eWith default provided regular expression:\u003c/p\u003e\n\u003cpre\u003e\nenum SomeEnumeration {\n    some  // Non-Compliant\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nenum SomeEnumeration {\n    SOME\n};\n\u003c/pre\u003e"
      }
    ],
    "params": {
      "format": {
        "key": "format",
        "name": "format",
        "description": "POSIX regular expression used to check the enumeration value names against.",
        "defaultValue": "^[A-Z][A-Z_0-9]*$",
        "type": "STRING",
        "multiple": false,
        "possibleValues": []
      }
    },
    "defaultParams": {
      "format": "^[A-Z][A-Z_0-9]*$"
    },
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "convention"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S1133",
    "name": "Deprecated code should be removed",
    "defaultSeverity": "INFO",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThis rule is meant to be used as a way to track code which is marked as being deprecated. Deprecated code should eventually be removed.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n// C++14 attribute\n[[deprecated]] // Noncompliant\nvoid fun();\n\n// GNU attribute\n__attribute__((deprecated)) // Noncompliant\nvoid fun();\n\n// Microsoft attribute\n__declspec(deprecated) // Noncompliant\nvoid fun();\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThis rule is meant to be used as a way to track code which is marked as being deprecated. Deprecated code should eventually be removed.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n// C++14 attribute\n[[deprecated]] // Noncompliant\nvoid fun();\n\n// GNU attribute\n__attribute__((deprecated)) // Noncompliant\nvoid fun();\n\n// Microsoft attribute\n__declspec(deprecated) // Noncompliant\nvoid fun();\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "obsolete"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S2342",
    "name": "Enumeration names should comply with a naming convention",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "IDENTIFIABLE",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eShared naming conventions allow teams to collaborate efficiently. This rule checks that all \u003ccode\u003eenum\u003c/code\u003e names match a provided regular\nexpression.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cp\u003eWith default provided regular expression \u003ccode\u003e^[A-Z][a-zA-Z0-9]*$\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\nenum someEnumeration { // Noncompliant\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nenum SomeEnumeration {\n};\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eShared naming conventions allow teams to collaborate efficiently. This rule checks that all \u003ccode\u003eenum\u003c/code\u003e names match a provided regular\nexpression.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cp\u003eWith default provided regular expression \u003ccode\u003e^[A-Z][a-zA-Z0-9]*$\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\nenum someEnumeration { // Noncompliant\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nenum SomeEnumeration {\n};\n\u003c/pre\u003e"
      }
    ],
    "params": {
      "format": {
        "key": "format",
        "name": "format",
        "description": "POSIX regular expression used to check the enumeration names against",
        "defaultValue": "^[A-Z][a-zA-Z0-9]*$",
        "type": "STRING",
        "multiple": false,
        "possibleValues": []
      }
    },
    "defaultParams": {
      "format": "^[A-Z][a-zA-Z0-9]*$"
    },
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "convention"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S990",
    "name": "\"abort\", \"exit\", \"getenv\" and \"system\" from \u003cstdlib.h\u003e should not be used",
    "defaultSeverity": "CRITICAL",
    "type": "BUG",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003e\u0026lt;stdlib.h\u0026gt;\u003c/code\u003e\u0027s \u003ccode\u003eabort\u003c/code\u003e, \u003ccode\u003eexit\u003c/code\u003e, \u003ccode\u003egetenv\u003c/code\u003e, and \u003ccode\u003esystem\u003c/code\u003e have implementation-defined\nbehaviors, and should therefore be avoided.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;stdlib.h\u0026gt;\n\nvoid f( ) {\n  exit(0); // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 20.11 - The library functions abort, exit, getenv and system from library \u0026lt;stdlib.h\u0026gt; shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 18-0-3 - The library functions abort, exit, getenv and system from library \u0026lt;cstdlib\u0026gt; shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 21.8 - The library functions abort, exit, getenv and system of \u0026lt;stdlib.h\u0026gt; shall not be used \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003ccode\u003e\u0026lt;stdlib.h\u0026gt;\u003c/code\u003e\u0027s \u003ccode\u003eabort\u003c/code\u003e, \u003ccode\u003eexit\u003c/code\u003e, \u003ccode\u003egetenv\u003c/code\u003e, and \u003ccode\u003esystem\u003c/code\u003e have implementation-defined\nbehaviors, and should therefore be avoided.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;stdlib.h\u0026gt;\n\nvoid f( ) {\n  exit(0); // Noncompliant\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 20.11 - The library functions abort, exit, getenv and system from library \u0026lt;stdlib.h\u0026gt; shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 18-0-3 - The library functions abort, exit, getenv and system from library \u0026lt;cstdlib\u0026gt; shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 21.8 - The library functions abort, exit, getenv and system of \u0026lt;stdlib.h\u0026gt; shall not be used \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "C",
    "tags": [
      "cert",
      "misra-c++2008",
      "misra-c2004",
      "misra-c2012"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S1134",
    "name": "Track uses of \"FIXME\" tags",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eFIXME\u003c/code\u003e tags are commonly used to mark places where a bug is suspected, but which the developer wants to deal with later.\u003c/p\u003e\n\u003cp\u003eSometimes the developer will not have the time or will simply forget to get back to that tag.\u003c/p\u003e\n\u003cp\u003eThis rule is meant to track those tags and to ensure that they do not go unnoticed.\u003c/p\u003e\n\u003cpre\u003e\nint Divide(int numerator, int denominator)\n{\n    return numerator / denominator; // FIXME denominator value might be 0\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/546\"\u003eMITRE, CWE-546 - Suspicious Comment\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003ccode\u003eFIXME\u003c/code\u003e tags are commonly used to mark places where a bug is suspected, but which the developer wants to deal with later.\u003c/p\u003e\n\u003cp\u003eSometimes the developer will not have the time or will simply forget to get back to that tag.\u003c/p\u003e\n\u003cp\u003eThis rule is meant to track those tags and to ensure that they do not go unnoticed.\u003c/p\u003e\n\u003cpre\u003e\nint Divide(int numerator, int denominator)\n{\n    return numerator / denominator; // FIXME denominator value might be 0\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/546\"\u003eMITRE, CWE-546 - Suspicious Comment\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "cwe"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S4524",
    "name": "\"default\" clauses should be first or last",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "FORMATTED",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eswitch\u003c/code\u003e can contain a \u003ccode\u003edefault\u003c/code\u003e clause for various reasons: to handle unexpected values, to show that all the cases were\nproperly considered, etc.\u003c/p\u003e\n\u003cp\u003eFor readability purposes, to help a developer quickly spot the default behavior of a \u003ccode\u003eswitch\u003c/code\u003e statement, it is recommended to put the\n\u003ccode\u003edefault\u003c/code\u003e clause at the beginning or the end of the \u003ccode\u003eswitch\u003c/code\u003e statement.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue if the \u003ccode\u003edefault\u003c/code\u003e clause is not the first or the last one of the \u003ccode\u003eswitch\u003c/code\u003e\u0027s cases.\u003c/p\u003e\n\u003cpre\u003e\nswitch (param) {\n  case 0:\n    doSomething();\n    break;\n  default: // Noncompliant: default clause should be the first or last one\n    error();\n    break;\n  case 1:\n    doSomethingElse();\n    break;\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 15.3 - The final clause of a switch statement shall be the default clause \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 6-4-6 - The final clause of a switch statement shall be the default-clause \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 16.4 - Every switch statement shall have a default label \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 16.5 - A default label shall appear as either the first or the last switch label of a switch statement \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003ccode\u003eswitch\u003c/code\u003e can contain a \u003ccode\u003edefault\u003c/code\u003e clause for various reasons: to handle unexpected values, to show that all the cases were\nproperly considered, etc.\u003c/p\u003e\n\u003cp\u003eFor readability purposes, to help a developer quickly spot the default behavior of a \u003ccode\u003eswitch\u003c/code\u003e statement, it is recommended to put the\n\u003ccode\u003edefault\u003c/code\u003e clause at the beginning or the end of the \u003ccode\u003eswitch\u003c/code\u003e statement.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue if the \u003ccode\u003edefault\u003c/code\u003e clause is not the first or the last one of the \u003ccode\u003eswitch\u003c/code\u003e\u0027s cases.\u003c/p\u003e\n\u003cpre\u003e\nswitch (param) {\n  case 0:\n    doSomething();\n    break;\n  default: // Noncompliant: default clause should be the first or last one\n    error();\n    break;\n  case 1:\n    doSomethingElse();\n    break;\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 15.3 - The final clause of a switch statement shall be the default clause \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 6-4-6 - The final clause of a switch statement shall be the default-clause \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 16.4 - Every switch statement shall have a default label \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 16.5 - A default label shall appear as either the first or the last switch label of a switch statement \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "based-on-misra",
      "misra-c2004",
      "misra-c2012"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S1135",
    "name": "Track uses of \"TODO\" tags",
    "defaultSeverity": "INFO",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eDevelopers often use \u003ccode\u003eTODO\u003c/code\u003e tags to mark areas in the code where additional work or improvements are needed but are not implemented\nimmediately. However, these \u003ccode\u003eTODO\u003c/code\u003e tags sometimes get overlooked or forgotten, leading to incomplete or unfinished code. This code smell\nclass aims to identify and address such unattended \u003ccode\u003eTODO\u003c/code\u003e tags to ensure a clean and maintainable codebase. This description will explore\nwhy this is a problem and how it can be fixed to improve the overall code quality.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eUnattended \u003ccode\u003eTODO\u003c/code\u003e tags in code can have significant implications for the development process and the overall codebase.\u003c/p\u003e\n\u003cp\u003eIncomplete Functionality: When developers leave \u003ccode\u003eTODO\u003c/code\u003e tags without implementing the corresponding code, it results in incomplete\nfunctionality within the software. This can lead to unexpected behavior or missing features, adversely affecting the end-user experience.\u003c/p\u003e\n\u003cp\u003eMissed Bug Fixes: If developers do not promptly address \u003ccode\u003eTODO\u003c/code\u003e tags, they might overlook critical bug fixes and security updates.\nDelayed bug fixes can result in more severe issues and increase the effort required to resolve them later.\u003c/p\u003e\n\u003cp\u003eImpact on Collaboration: In team-based development environments, unattended \u003ccode\u003eTODO\u003c/code\u003e tags can hinder collaboration. Other team members\nmight not be aware of the intended changes, leading to conflicts or redundant efforts in the codebase.\u003c/p\u003e\n\u003cp\u003eCodebase Bloat: Accumulation of unattended \u003ccode\u003eTODO\u003c/code\u003e tags over time can clutter the codebase and make it difficult to distinguish between\nwork in progress and completed code. This bloat can make it challenging to maintain an organized and efficient codebase.\u003c/p\u003e\n\u003cp\u003eAddressing this code smell is essential to ensure a maintainable, readable, reliable codebase and promote effective collaboration among\ndevelopers.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid foo() {\n  // TODO\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/546\"\u003eMITRE, CWE-546\u003c/a\u003e - Suspicious Comment \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eDevelopers often use \u003ccode\u003eTODO\u003c/code\u003e tags to mark areas in the code where additional work or improvements are needed but are not implemented\nimmediately. However, these \u003ccode\u003eTODO\u003c/code\u003e tags sometimes get overlooked or forgotten, leading to incomplete or unfinished code. This code smell\nclass aims to identify and address such unattended \u003ccode\u003eTODO\u003c/code\u003e tags to ensure a clean and maintainable codebase. This description will explore\nwhy this is a problem and how it can be fixed to improve the overall code quality.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eUnattended \u003ccode\u003eTODO\u003c/code\u003e tags in code can have significant implications for the development process and the overall codebase.\u003c/p\u003e\n\u003cp\u003eIncomplete Functionality: When developers leave \u003ccode\u003eTODO\u003c/code\u003e tags without implementing the corresponding code, it results in incomplete\nfunctionality within the software. This can lead to unexpected behavior or missing features, adversely affecting the end-user experience.\u003c/p\u003e\n\u003cp\u003eMissed Bug Fixes: If developers do not promptly address \u003ccode\u003eTODO\u003c/code\u003e tags, they might overlook critical bug fixes and security updates.\nDelayed bug fixes can result in more severe issues and increase the effort required to resolve them later.\u003c/p\u003e\n\u003cp\u003eImpact on Collaboration: In team-based development environments, unattended \u003ccode\u003eTODO\u003c/code\u003e tags can hinder collaboration. Other team members\nmight not be aware of the intended changes, leading to conflicts or redundant efforts in the codebase.\u003c/p\u003e\n\u003cp\u003eCodebase Bloat: Accumulation of unattended \u003ccode\u003eTODO\u003c/code\u003e tags over time can clutter the codebase and make it difficult to distinguish between\nwork in progress and completed code. This bloat can make it challenging to maintain an organized and efficient codebase.\u003c/p\u003e\n\u003cp\u003eAddressing this code smell is essential to ensure a maintainable, readable, reliable codebase and promote effective collaboration among\ndevelopers.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid foo() {\n  // TODO\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/546\"\u003eMITRE, CWE-546\u003c/a\u003e - Suspicious Comment \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "cwe"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "c:S2589",
    "name": "Boolean expressions should not be gratuitous",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003cp\u003eGratuitous boolean expressions are conditions that do not change the evaluation of a program. This issue can indicate logical errors and affect the\ncorrectness of an application, as well as its maintainability.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eControl flow constructs like \u003ccode\u003eif\u003c/code\u003e-statements allow the programmer to direct the flow of a program depending on a boolean expression.\nHowever, if the condition is always true or always false, only one of the branches will ever be executed. In that case, the control flow construct and\nthe condition no longer serve a purpose; they become \u003cem\u003egratuitous\u003c/em\u003e.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eThe presence of gratuitous conditions can indicate a logical error. For example, the programmer \u003cem\u003eintended\u003c/em\u003e to have the program branch into\ndifferent paths but made a mistake when formulating the branching condition. In this case, this issue might result in a bug and thus affect the\nreliability of the application. For instance, it might lead to the computation of incorrect results.\u003c/p\u003e\n\u003cp\u003eAdditionally, gratuitous conditions and control flow constructs introduce unnecessary complexity. The source code becomes harder to understand, and\nthus, the application becomes more difficult to maintain.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eGratuitous boolean expressions are suspicious and should be carefully removed from the code.\u003c/p\u003e\n\u003cp\u003eFirst, the boolean expression in question should be closely inspected for logical errors. If a mistake was made, it can be corrected so the\ncondition is no longer gratuitous.\u003c/p\u003e\n\u003cp\u003eIf it becomes apparent that the condition is actually unnecessary, it can be removed. The associated control flow construct (e.g., the\n\u003ccode\u003eif\u003c/code\u003e-statement containing the condition) will be adapted or even removed, leaving only the necessary branches.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\na \u003d true;\nif (a) { // Noncompliant\n  doSomething();\n}\n\nif (b \u0026amp;\u0026amp; a) { // Noncompliant; \"a\" is always \"true\"\n  doSomething();\n}\n\nif (c || !a) { // Noncompliant; \"!a\" is always \"false\"\n  doSomething();\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\na \u003d true;\nif (foo(a)) {\n  doSomething();\n}\n\nif (b) {\n  doSomething();\n}\n\nif (c) {\n  doSomething();\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 13.7 - Boolean operations whose results are invariant shall not be permitted. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 14.3 - Controlling expressions shall not be invariant \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/571\"\u003eMITRE, CWE-571\u003c/a\u003e - Expression is Always True \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/570\"\u003eMITRE, CWE-570\u003c/a\u003e - Expression is Always False \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/5dUxBQ\"\u003eCERT, MSC12-C.\u003c/a\u003e - Detect and remove code that has no effect or is never executed\n  \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eGratuitous boolean expressions are conditions that do not change the evaluation of a program. This issue can indicate logical errors and affect the\ncorrectness of an application, as well as its maintainability.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eControl flow constructs like \u003ccode\u003eif\u003c/code\u003e-statements allow the programmer to direct the flow of a program depending on a boolean expression.\nHowever, if the condition is always true or always false, only one of the branches will ever be executed. In that case, the control flow construct and\nthe condition no longer serve a purpose; they become \u003cem\u003egratuitous\u003c/em\u003e.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eThe presence of gratuitous conditions can indicate a logical error. For example, the programmer \u003cem\u003eintended\u003c/em\u003e to have the program branch into\ndifferent paths but made a mistake when formulating the branching condition. In this case, this issue might result in a bug and thus affect the\nreliability of the application. For instance, it might lead to the computation of incorrect results.\u003c/p\u003e\n\u003cp\u003eAdditionally, gratuitous conditions and control flow constructs introduce unnecessary complexity. The source code becomes harder to understand, and\nthus, the application becomes more difficult to maintain.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eGratuitous boolean expressions are suspicious and should be carefully removed from the code.\u003c/p\u003e\n\u003cp\u003eFirst, the boolean expression in question should be closely inspected for logical errors. If a mistake was made, it can be corrected so the\ncondition is no longer gratuitous.\u003c/p\u003e\n\u003cp\u003eIf it becomes apparent that the condition is actually unnecessary, it can be removed. The associated control flow construct (e.g., the\n\u003ccode\u003eif\u003c/code\u003e-statement containing the condition) will be adapted or even removed, leaving only the necessary branches.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\na \u003d true;\nif (a) { // Noncompliant\n  doSomething();\n}\n\nif (b \u0026amp;\u0026amp; a) { // Noncompliant; \"a\" is always \"true\"\n  doSomething();\n}\n\nif (c || !a) { // Noncompliant; \"!a\" is always \"false\"\n  doSomething();\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\na \u003d true;\nif (foo(a)) {\n  doSomething();\n}\n\nif (b) {\n  doSomething();\n}\n\nif (c) {\n  doSomething();\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 13.7 - Boolean operations whose results are invariant shall not be permitted. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 14.3 - Controlling expressions shall not be invariant \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/571\"\u003eMITRE, CWE-571\u003c/a\u003e - Expression is Always True \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/570\"\u003eMITRE, CWE-570\u003c/a\u003e - Expression is Always False \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/5dUxBQ\"\u003eCERT, MSC12-C.\u003c/a\u003e - Detect and remove code that has no effect or is never executed\n  \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "C",
    "tags": [
      "based-on-misra",
      "cert",
      "cwe",
      "misra-c2004",
      "misra-c2012",
      "redundant",
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  }
]