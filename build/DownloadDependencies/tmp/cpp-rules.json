[
  {
    "key": "cpp:S2095",
    "name": "Resources should be closed",
    "defaultSeverity": "BLOCKER",
    "type": "BUG",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003cp\u003eA function call to \u003ccode\u003efopen\u003c/code\u003e or \u003ccode\u003eopen\u003c/code\u003e must be matched with a call to \u003ccode\u003efclose\u003c/code\u003e or \u003ccode\u003eclose\u003c/code\u003e,\nrespectively.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe standard C library provides \u003ccode\u003efopen\u003c/code\u003e and the system call \u003ccode\u003eopen\u003c/code\u003e to open and possibly create files. Each call to one of\nthese functions must be matched with a respective call to \u003ccode\u003efclose\u003c/code\u003e or \u003ccode\u003eclose\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eFailing to close files that have been opened may lead to using up all of the OS’s file handles.\u003c/p\u003e\n\u003ch2\u003eWhat is the potential impact?\u003c/h2\u003e\n\u003cp\u003eIf a program does not properly close or release file handles after using them, it will leak resources. In that case, the program will continue to\nhold onto file handles even when they are no longer needed, eventually exhausting the available file handles.\u003c/p\u003e\n\u003cp\u003eIf a program has run out of file handles and tries to open yet another file, the file opening operation will fail. This can result in errors or\nunexpected behavior in the program.\u003c/p\u003e\n\u003cp\u003eThe program may not be able to read or write to files anymore, which can cause data loss, corruption, or incomplete operations. In some cases, when\na program runs out of file handles, it may crash or hang indefinitely. This can happen if the program does not handle the error condition properly or\nif it enters an infinite loop trying to open files, for instance. In the worst case, a resource leak can lock up everything that runs on the\nmachine.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eMake sure that each call to \u003ccode\u003efopen\u003c/code\u003e and \u003ccode\u003eopen\u003c/code\u003e has a matching call to \u003ccode\u003efclose\u003c/code\u003e and \u003ccode\u003eclose\u003c/code\u003e,\nrespectively.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n\nint process_file(int print) {\n  FILE *f \u003d fopen(\"example.txt\", \"r\");\n  if (!f) {\n    perror(\"fopen() failed\");\n    return 1;\n  }\n\n  if (print) {\n    char buffer[256];\n    while (fgets(buffer, 256, f)) {\n      printf(\"%s\", buffer);\n    }\n  }\n\n  return 0; // Noncompliant: file `f` has not been closed\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n\nint process_file(int print) {\n  FILE *f \u003d fopen(\"example.txt\", \"r\");\n  if (!f) {\n    perror(\"fopen() failed\");\n    return 1;\n  }\n\n  if (print) {\n    char buffer[256];\n    while (fgets(buffer, 256, f)) {\n      printf(\"%s\", buffer);\n    }\n  }\n\n  fclose(f);\n  return 0; // Compliant: file `f` has been closed\n}\n\u003c/pre\u003e\n\u003ch3\u003eGoing the extra mile\u003c/h3\u003e\n\u003cp\u003eUsing C++\u0027s \u003cem\u003eRAII\u003c/em\u003e idiom can mitigate unmatched calls to \u003ccode\u003efopen\u003c/code\u003e and \u003ccode\u003eopen\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eFollowing this idiom, one would create a class that manages the underlying file by opening it when the object is constructed and closing it when\nthe object is destroyed, effectively using a constructor-destructor pair as a \"do-undo\"-mechanism.\u003c/p\u003e\n\u003cp\u003eAn exemplary class that manages a pointer to a file is shown in what follows.\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;cstdio\u0026gt;\n#include \u0026lt;fstream\u0026gt;\n#include \u0026lt;string\u0026gt;\n#include \u0026lt;utility\u0026gt;\n\n// Although `std::fstream` should be preferred, if available, a file stream\n// managed by this `File` class cannot suffer from \"double-close\" issues.\nclass File {\n  FILE *f;\n\npublic:\n  // Opens file stream on construction.\n  File(std::string const \u0026amp;path, std::string const \u0026amp;modes)\n      : f(fopen(path.c_str(), modes.c_str())) {\n    if (!f) {\n      throw std::ios_base::failure(\"fopen() failed\");\n    }\n  }\n  // Will close the file stream upon destruction.\n  ~File() {\n    // Here we are fine with `std::terminate` being called here in case `close`\n    // throws and exception.\n    close();\n  }\n  // Allow only one owner of a file, disallow copy operations.\n  File(const File \u0026amp;other) \u003d delete;\n  File \u0026amp;operator\u003d(const File \u0026amp;other) \u003d delete;\n  // Moving a file to a different scope shall be allowed.\n  File(File \u0026amp;\u0026amp;other) : f(std::exchange(other.f, nullptr)) {}\n  File \u0026amp;operator\u003d(File \u0026amp;\u0026amp;other) {\n    if (this !\u003d \u0026amp;other) {\n      // In case of non-self-assignment, close the currently managed file and\n      // \"steal\" the other\u0027s file.\n      close();\n      f \u003d std::exchange(other.f, nullptr);\n    }\n    return *this;\n  }\n  // Allow file to be closed explicitly.\n  void close() {\n    if (f !\u003d nullptr \u0026amp;\u0026amp; fclose(std::exchange(f, nullptr)) \u003d\u003d EOF) {\n      throw std::ios_base::failure(\"fclose() failed\");\n    }\n  }\n  // Allow access to underlying file via `f`.\n  FILE *handle() { return f; }\n  // Release `f`, i.e., stop managing it.\n  FILE *release() { return std::exchange(f, nullptr); }\n};\n\nvoid file_user() {\n  File fh{\"example.txt\", \"r\"};\n  FILE *f \u003d fh.handle();\n  // Use `f` for the desired file operation(s).\n  //\n  // The file stream managed by `fh` will be automatically closed when `fh` goes\n  // out of scope at the end of this function.\n}\n\u003c/pre\u003e\n\u003cp\u003eWith the design shown above, calls to \u003ccode\u003efopen\u003c/code\u003e will be automatically matched with a corresponding call to \u003ccode\u003efclose\u003c/code\u003e by default.\nThe associated file will be automatically closed when the \u003ccode\u003eFile\u003c/code\u003e typed file handle object goes out of scope and its destructor is called.\nHowever, it is still possible to leak a resource, if \u003ccode\u003eFile\u003c/code\u003e\u0027s function member \u003ccode\u003eFile::release\u003c/code\u003e is used inappropriately. If this\nis a concern, this function member should be removed.\u003c/p\u003e\n\u003cp\u003eIf falling back to low-level file operations is not necessary, one should prefer \u003ccode\u003estd::fstream\u003c/code\u003e.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/QtUxBQ\"\u003eFIO42-C. Close files when they are no longer needed\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/459\"\u003e459 Incomplete Cleanup\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/772\"\u003e772 Missing Release of Resource after Effective Lifetime\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S3588} ensures that \u003ccode\u003eFILE*\u003c/code\u003e typed variables are not accessed after the associated file has been closed \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eA function call to \u003ccode\u003efopen\u003c/code\u003e or \u003ccode\u003eopen\u003c/code\u003e must be matched with a call to \u003ccode\u003efclose\u003c/code\u003e or \u003ccode\u003eclose\u003c/code\u003e,\nrespectively.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe standard C library provides \u003ccode\u003efopen\u003c/code\u003e and the system call \u003ccode\u003eopen\u003c/code\u003e to open and possibly create files. Each call to one of\nthese functions must be matched with a respective call to \u003ccode\u003efclose\u003c/code\u003e or \u003ccode\u003eclose\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eFailing to close files that have been opened may lead to using up all of the OS’s file handles.\u003c/p\u003e\n\u003ch2\u003eWhat is the potential impact?\u003c/h2\u003e\n\u003cp\u003eIf a program does not properly close or release file handles after using them, it will leak resources. In that case, the program will continue to\nhold onto file handles even when they are no longer needed, eventually exhausting the available file handles.\u003c/p\u003e\n\u003cp\u003eIf a program has run out of file handles and tries to open yet another file, the file opening operation will fail. This can result in errors or\nunexpected behavior in the program.\u003c/p\u003e\n\u003cp\u003eThe program may not be able to read or write to files anymore, which can cause data loss, corruption, or incomplete operations. In some cases, when\na program runs out of file handles, it may crash or hang indefinitely. This can happen if the program does not handle the error condition properly or\nif it enters an infinite loop trying to open files, for instance. In the worst case, a resource leak can lock up everything that runs on the\nmachine.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eMake sure that each call to \u003ccode\u003efopen\u003c/code\u003e and \u003ccode\u003eopen\u003c/code\u003e has a matching call to \u003ccode\u003efclose\u003c/code\u003e and \u003ccode\u003eclose\u003c/code\u003e,\nrespectively.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n\nint process_file(int print) {\n  FILE *f \u003d fopen(\"example.txt\", \"r\");\n  if (!f) {\n    perror(\"fopen() failed\");\n    return 1;\n  }\n\n  if (print) {\n    char buffer[256];\n    while (fgets(buffer, 256, f)) {\n      printf(\"%s\", buffer);\n    }\n  }\n\n  return 0; // Noncompliant: file `f` has not been closed\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n\nint process_file(int print) {\n  FILE *f \u003d fopen(\"example.txt\", \"r\");\n  if (!f) {\n    perror(\"fopen() failed\");\n    return 1;\n  }\n\n  if (print) {\n    char buffer[256];\n    while (fgets(buffer, 256, f)) {\n      printf(\"%s\", buffer);\n    }\n  }\n\n  fclose(f);\n  return 0; // Compliant: file `f` has been closed\n}\n\u003c/pre\u003e\n\u003ch3\u003eGoing the extra mile\u003c/h3\u003e\n\u003cp\u003eUsing C++\u0027s \u003cem\u003eRAII\u003c/em\u003e idiom can mitigate unmatched calls to \u003ccode\u003efopen\u003c/code\u003e and \u003ccode\u003eopen\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eFollowing this idiom, one would create a class that manages the underlying file by opening it when the object is constructed and closing it when\nthe object is destroyed, effectively using a constructor-destructor pair as a \"do-undo\"-mechanism.\u003c/p\u003e\n\u003cp\u003eAn exemplary class that manages a pointer to a file is shown in what follows.\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;cstdio\u0026gt;\n#include \u0026lt;fstream\u0026gt;\n#include \u0026lt;string\u0026gt;\n#include \u0026lt;utility\u0026gt;\n\n// Although `std::fstream` should be preferred, if available, a file stream\n// managed by this `File` class cannot suffer from \"double-close\" issues.\nclass File {\n  FILE *f;\n\npublic:\n  // Opens file stream on construction.\n  File(std::string const \u0026amp;path, std::string const \u0026amp;modes)\n      : f(fopen(path.c_str(), modes.c_str())) {\n    if (!f) {\n      throw std::ios_base::failure(\"fopen() failed\");\n    }\n  }\n  // Will close the file stream upon destruction.\n  ~File() {\n    // Here we are fine with `std::terminate` being called here in case `close`\n    // throws and exception.\n    close();\n  }\n  // Allow only one owner of a file, disallow copy operations.\n  File(const File \u0026amp;other) \u003d delete;\n  File \u0026amp;operator\u003d(const File \u0026amp;other) \u003d delete;\n  // Moving a file to a different scope shall be allowed.\n  File(File \u0026amp;\u0026amp;other) : f(std::exchange(other.f, nullptr)) {}\n  File \u0026amp;operator\u003d(File \u0026amp;\u0026amp;other) {\n    if (this !\u003d \u0026amp;other) {\n      // In case of non-self-assignment, close the currently managed file and\n      // \"steal\" the other\u0027s file.\n      close();\n      f \u003d std::exchange(other.f, nullptr);\n    }\n    return *this;\n  }\n  // Allow file to be closed explicitly.\n  void close() {\n    if (f !\u003d nullptr \u0026amp;\u0026amp; fclose(std::exchange(f, nullptr)) \u003d\u003d EOF) {\n      throw std::ios_base::failure(\"fclose() failed\");\n    }\n  }\n  // Allow access to underlying file via `f`.\n  FILE *handle() { return f; }\n  // Release `f`, i.e., stop managing it.\n  FILE *release() { return std::exchange(f, nullptr); }\n};\n\nvoid file_user() {\n  File fh{\"example.txt\", \"r\"};\n  FILE *f \u003d fh.handle();\n  // Use `f` for the desired file operation(s).\n  //\n  // The file stream managed by `fh` will be automatically closed when `fh` goes\n  // out of scope at the end of this function.\n}\n\u003c/pre\u003e\n\u003cp\u003eWith the design shown above, calls to \u003ccode\u003efopen\u003c/code\u003e will be automatically matched with a corresponding call to \u003ccode\u003efclose\u003c/code\u003e by default.\nThe associated file will be automatically closed when the \u003ccode\u003eFile\u003c/code\u003e typed file handle object goes out of scope and its destructor is called.\nHowever, it is still possible to leak a resource, if \u003ccode\u003eFile\u003c/code\u003e\u0027s function member \u003ccode\u003eFile::release\u003c/code\u003e is used inappropriately. If this\nis a concern, this function member should be removed.\u003c/p\u003e\n\u003cp\u003eIf falling back to low-level file operations is not necessary, one should prefer \u003ccode\u003estd::fstream\u003c/code\u003e.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/QtUxBQ\"\u003eFIO42-C. Close files when they are no longer needed\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/459\"\u003e459 Incomplete Cleanup\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/772\"\u003e772 Missing Release of Resource after Effective Lifetime\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S3588} ensures that \u003ccode\u003eFILE*\u003c/code\u003e typed variables are not accessed after the associated file has been closed \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cert",
      "cwe",
      "denial-of-service",
      "leak",
      "symbolic-execution"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5000",
    "name": "\"memcmp\" should only be called with pointers to trivially copyable types with no padding",
    "defaultSeverity": "BLOCKER",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003cp\u003eThe function \u003ccode\u003ememcmp\u003c/code\u003e only returns meaningful results for objects of trivially copyable types without padding. This includes scalar\ntypes, arrays, and trivially copyable classes.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003ememcmp\u003c/code\u003e compares the raw memory representation of two objects (what the standard calls their \u003cem\u003eobject representation\u003c/em\u003e). When\nobjects are not trivially copyable or contain padding, they could have different raw memory representations even though they store identical values.\nSo the result of \u003ccode\u003ememcmp\u003c/code\u003e is not meaningful.\u003c/p\u003e\n\u003cp\u003ePadding refers to the insertion of additional bits into a structure or class to ensure proper alignment of its members in memory.\u003c/p\u003e\n\u003cp\u003eTrivially copyable types include:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e scalar types \u003c/li\u003e\n  \u003cli\u003e trivially copyable classes \u003c/li\u003e\n  \u003cli\u003e arrays of these types \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eA class is trivially copyable when:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e all its non-static data members and base classes are trivially copyable types, \u003c/li\u003e\n  \u003cli\u003e it has no virtual functions or base classes, \u003c/li\u003e\n  \u003cli\u003e its destructor is trival, \u003c/li\u003e\n  \u003cli\u003e and one or more of the following special member functions is trivial, and the rest are deleted: copy constructor, move constructor, copy\n  assignment operator, and move assignment operator. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cem\u003eNote: a default implementation is always considered trivial, both when it is explicit (with \u003ccode\u003e\u003d default\u003c/code\u003e) or implicit (if the special\nmember function is omitted).\u003c/em\u003e\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eThe comparison operator \u003ccode\u003eoperator\u003d\u003d\u003c/code\u003e should be defined and used instead of \u003ccode\u003ememcmp\u003c/code\u003e when the types are not trivially copyable\nor contain padding. This allows comparing member by member to check object equality.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nstruct Shape { // Trivially copyable, but will contain padding after the bool on most architectures\n  bool visible;\n  int x;\n  int y;\n};\n\nbool isSame(Shape *s1, Shape *s2)\n{\n    return memcmp(s1, s2, sizeof(Shape)) \u003d\u003d 0; // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nstruct Shape { // Trivially copyable, but will contain padding after the bool on most architectures\n  bool visible;\n  int x;\n  int y;\n};\n\nbool isSame(Shape *s1, Shape *s2)\n{\n  return s1-\u0026gt;visible \u003d\u003d s2-\u0026gt;visible \u0026amp;\u0026amp; s1-\u0026gt;x \u003d\u003d s2-\u0026gt;x \u0026amp;\u0026amp; s1-\u0026gt;y \u003d\u003d s2-\u0026gt;y;\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\nclass Resource { // Not trivially copyable\npublic:\n  Ptr* ptr;\n  ~Resource();\n};\n\nbool isSame(Resource *r1, Resource *r2)\n{\n    return memcmp(r1, r2, sizeof(Resource)) \u003d\u003d 0; // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\nclass Resource { // Not trivially copyable\npublic:\n  Ptr* ptr;\n  ~Resource();\n};\n\nbool operator\u003d\u003d(Resource const \u0026amp;r1, Resource const \u0026amp;r2) {\n  return r1.ptr \u003d\u003d r2.ptr;\n}\n\nbool isSame(Resource *r1, Resource *r2)\n{\n    return (*r1) \u003d\u003d (*r2);\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/classes#Trivially_copyable_class\"\u003eDefinition of a trivially copyable\n  class\u003c/a\u003e. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S4999} - \"memcpy\", \"memmove\", and \"memset\" should only be called with pointers to trivially copyable types \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eThe function \u003ccode\u003ememcmp\u003c/code\u003e only returns meaningful results for objects of trivially copyable types without padding. This includes scalar\ntypes, arrays, and trivially copyable classes.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003ccode\u003ememcmp\u003c/code\u003e compares the raw memory representation of two objects (what the standard calls their \u003cem\u003eobject representation\u003c/em\u003e). When\nobjects are not trivially copyable or contain padding, they could have different raw memory representations even though they store identical values.\nSo the result of \u003ccode\u003ememcmp\u003c/code\u003e is not meaningful.\u003c/p\u003e\n\u003cp\u003ePadding refers to the insertion of additional bits into a structure or class to ensure proper alignment of its members in memory.\u003c/p\u003e\n\u003cp\u003eTrivially copyable types include:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e scalar types \u003c/li\u003e\n  \u003cli\u003e trivially copyable classes \u003c/li\u003e\n  \u003cli\u003e arrays of these types \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eA class is trivially copyable when:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e all its non-static data members and base classes are trivially copyable types, \u003c/li\u003e\n  \u003cli\u003e it has no virtual functions or base classes, \u003c/li\u003e\n  \u003cli\u003e its destructor is trival, \u003c/li\u003e\n  \u003cli\u003e and one or more of the following special member functions is trivial, and the rest are deleted: copy constructor, move constructor, copy\n  assignment operator, and move assignment operator. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cem\u003eNote: a default implementation is always considered trivial, both when it is explicit (with \u003ccode\u003e\u003d default\u003c/code\u003e) or implicit (if the special\nmember function is omitted).\u003c/em\u003e\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eThe comparison operator \u003ccode\u003eoperator\u003d\u003d\u003c/code\u003e should be defined and used instead of \u003ccode\u003ememcmp\u003c/code\u003e when the types are not trivially copyable\nor contain padding. This allows comparing member by member to check object equality.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nstruct Shape { // Trivially copyable, but will contain padding after the bool on most architectures\n  bool visible;\n  int x;\n  int y;\n};\n\nbool isSame(Shape *s1, Shape *s2)\n{\n    return memcmp(s1, s2, sizeof(Shape)) \u003d\u003d 0; // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nstruct Shape { // Trivially copyable, but will contain padding after the bool on most architectures\n  bool visible;\n  int x;\n  int y;\n};\n\nbool isSame(Shape *s1, Shape *s2)\n{\n  return s1-\u0026gt;visible \u003d\u003d s2-\u0026gt;visible \u0026amp;\u0026amp; s1-\u0026gt;x \u003d\u003d s2-\u0026gt;x \u0026amp;\u0026amp; s1-\u0026gt;y \u003d\u003d s2-\u0026gt;y;\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\nclass Resource { // Not trivially copyable\npublic:\n  Ptr* ptr;\n  ~Resource();\n};\n\nbool isSame(Resource *r1, Resource *r2)\n{\n    return memcmp(r1, r2, sizeof(Resource)) \u003d\u003d 0; // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\nclass Resource { // Not trivially copyable\npublic:\n  Ptr* ptr;\n  ~Resource();\n};\n\nbool operator\u003d\u003d(Resource const \u0026amp;r1, Resource const \u0026amp;r2) {\n  return r1.ptr \u003d\u003d r2.ptr;\n}\n\nbool isSame(Resource *r1, Resource *r2)\n{\n    return (*r1) \u003d\u003d (*r2);\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/classes#Trivially_copyable_class\"\u003eDefinition of a trivially copyable\n  class\u003c/a\u003e. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S4999} - \"memcpy\", \"memmove\", and \"memset\" should only be called with pointers to trivially copyable types \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "unpredictable"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5485",
    "name": "Only valid arguments should be passed to stream functions",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003cp\u003ePassing invalid arguments to standard C library functions for handling I/O streams results in undefined behavior.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe standard C library includes a number of functions for handling I/O streams. These functions put certain constraints on the values of their\nparameters. The constraints include the following:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The value for the \u003ccode\u003eFILE*\u003c/code\u003e-typed parameter may \u003cem\u003enot\u003c/em\u003e be \u003ccode\u003eNULL\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e The third argument of \u003ccode\u003efseek\u003c/code\u003e must be either of \u003ccode\u003eSEEK_SET\u003c/code\u003e, \u003ccode\u003eSEEK_END\u003c/code\u003e, or \u003ccode\u003eSEEK_CUR\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eFailing to pass correctly constrained parameters renders them invalid and will result in undefined behavior.\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;stdio.h\u0026gt;\n\nsize_t get_file_size() {\n  FILE *f \u003d fopen(\"example_file.txt\", \"r\");\n  // `f` may be NULL if `fopen` fails.\n  fseek(f, 0L, SEEK_END); // Leads to undefined behavior, if `f` is NULL.\n  size_t size \u003d ftell(f); // Leads to undefined behavior, if `f` is NULL.\n  fclose(f);\n  return size;\n}\n\u003c/pre\u003e\n\u003ch2\u003eWhat is the potential impact?\u003c/h2\u003e\n\u003cp\u003eUsing the standard C library’s functions for handling I/O streams with invalid arguments leads to \u003cstrong\u003eundefined behavior\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eWhen a program comprises undefined behavior, the compiler no longer needs to adhere to the language standard, and the program has no meaning\nassigned to it.\u003c/p\u003e\n\u003cp\u003eDue to the resulting NULL pointer dereferences in the C library functions, the application might just crash, but in the worst case, the application\nmay appear to execute correctly, while losing data or producing incorrect results.\u003c/p\u003e\n\u003cp\u003eBesides affecting the application’s availability, NULL pointer dereferences may lead to code execution, in rare circumstances. If NULL is\nequivalent to the 0x0 memory address that can be accessed by privileged code, writing and reading memory is possible, which compromises the integrity\nand confidentiality of the application.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eEnsure that the \u003ccode\u003eFILE*\u003c/code\u003e-typed pointer parameters passed to the standard C library’s I/O stream handling functions are\nnon-\u003ccode\u003eNULL\u003c/code\u003e and also any other parameters such as the third argument of \u003ccode\u003efseek\u003c/code\u003e carry appropriate values, namely any of\n\u003ccode\u003eSEEK_SET\u003c/code\u003e, \u003ccode\u003eSEEK_END\u003c/code\u003e, or \u003ccode\u003eSEEK_CUR\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n\nint process_file(const char *fname) {\n  FILE *f \u003d fopen(fname, \"r\");\n  fseek(f, 0L, SEEK_END);\n  size_t size \u003d ftell(f);\n  rewind(f);\n  char *buf \u003d (char *)malloc(size);\n  // Read file into buffer ...\n  fclose(f);\n  // Process buffer ...\n  free(buf);\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n\nint process_file(const char *fname) {\n  FILE *f \u003d fopen(fname, \"r\");\n  if (!f) {\n    printf(\"Could not open file!\\n\");\n    return 1;\n  }\n  fseek(f, 0L, SEEK_END);\n  size_t size \u003d ftell(f);\n  rewind(f);\n  char *buf \u003d (char *)malloc(size);\n  // Read file into buffer ...\n  fclose(f);\n  // Process buffer ...\n  free(buf);\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n\nvoid process_tmp_file() {\n  FILE *f \u003d tmpfile();\n  size_t pos_indicator \u003d ftell(f); // Noncompliant: `f` could be NULL.\n  fseek(f, 0L, 3); // Noncompliant: 3rd argument should either be SEEK_SET, SEEK_CUR or SEEK_END.\n  // Further file processing ...\n  fclose(f);\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n\nint process_tmp_file() {\n  FILE *f \u003d tmpfile();\n  if (!f) {\n    printf(\"Could not create temporary file!\\n\");\n    return 1;\n  }\n  size_t pos_indicator \u003d ftell(f); // Compliant: `f` cannot be NULL here.\n  fseek(f, 0L, SEEK_END); // Compliant: 3rd argument is now a valid value.\n  // Further file processing ...\n  fclose(f);\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/476\"\u003e476 NULL Pointer Dereference\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S3807} ensures that appropriate arguments are passed to C standard library functions \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S5488} ensures that appropriate arguments are passed to UNIX/POSIX functions \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003ePassing invalid arguments to standard C library functions for handling I/O streams results in undefined behavior.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe standard C library includes a number of functions for handling I/O streams. These functions put certain constraints on the values of their\nparameters. The constraints include the following:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The value for the \u003ccode\u003eFILE*\u003c/code\u003e-typed parameter may \u003cem\u003enot\u003c/em\u003e be \u003ccode\u003eNULL\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e The third argument of \u003ccode\u003efseek\u003c/code\u003e must be either of \u003ccode\u003eSEEK_SET\u003c/code\u003e, \u003ccode\u003eSEEK_END\u003c/code\u003e, or \u003ccode\u003eSEEK_CUR\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eFailing to pass correctly constrained parameters renders them invalid and will result in undefined behavior.\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;stdio.h\u0026gt;\n\nsize_t get_file_size() {\n  FILE *f \u003d fopen(\"example_file.txt\", \"r\");\n  // `f` may be NULL if `fopen` fails.\n  fseek(f, 0L, SEEK_END); // Leads to undefined behavior, if `f` is NULL.\n  size_t size \u003d ftell(f); // Leads to undefined behavior, if `f` is NULL.\n  fclose(f);\n  return size;\n}\n\u003c/pre\u003e\n\u003ch2\u003eWhat is the potential impact?\u003c/h2\u003e\n\u003cp\u003eUsing the standard C library’s functions for handling I/O streams with invalid arguments leads to \u003cstrong\u003eundefined behavior\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eWhen a program comprises undefined behavior, the compiler no longer needs to adhere to the language standard, and the program has no meaning\nassigned to it.\u003c/p\u003e\n\u003cp\u003eDue to the resulting NULL pointer dereferences in the C library functions, the application might just crash, but in the worst case, the application\nmay appear to execute correctly, while losing data or producing incorrect results.\u003c/p\u003e\n\u003cp\u003eBesides affecting the application’s availability, NULL pointer dereferences may lead to code execution, in rare circumstances. If NULL is\nequivalent to the 0x0 memory address that can be accessed by privileged code, writing and reading memory is possible, which compromises the integrity\nand confidentiality of the application.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eEnsure that the \u003ccode\u003eFILE*\u003c/code\u003e-typed pointer parameters passed to the standard C library’s I/O stream handling functions are\nnon-\u003ccode\u003eNULL\u003c/code\u003e and also any other parameters such as the third argument of \u003ccode\u003efseek\u003c/code\u003e carry appropriate values, namely any of\n\u003ccode\u003eSEEK_SET\u003c/code\u003e, \u003ccode\u003eSEEK_END\u003c/code\u003e, or \u003ccode\u003eSEEK_CUR\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n\nint process_file(const char *fname) {\n  FILE *f \u003d fopen(fname, \"r\");\n  fseek(f, 0L, SEEK_END);\n  size_t size \u003d ftell(f);\n  rewind(f);\n  char *buf \u003d (char *)malloc(size);\n  // Read file into buffer ...\n  fclose(f);\n  // Process buffer ...\n  free(buf);\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n\nint process_file(const char *fname) {\n  FILE *f \u003d fopen(fname, \"r\");\n  if (!f) {\n    printf(\"Could not open file!\\n\");\n    return 1;\n  }\n  fseek(f, 0L, SEEK_END);\n  size_t size \u003d ftell(f);\n  rewind(f);\n  char *buf \u003d (char *)malloc(size);\n  // Read file into buffer ...\n  fclose(f);\n  // Process buffer ...\n  free(buf);\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n\nvoid process_tmp_file() {\n  FILE *f \u003d tmpfile();\n  size_t pos_indicator \u003d ftell(f); // Noncompliant: `f` could be NULL.\n  fseek(f, 0L, 3); // Noncompliant: 3rd argument should either be SEEK_SET, SEEK_CUR or SEEK_END.\n  // Further file processing ...\n  fclose(f);\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n\nint process_tmp_file() {\n  FILE *f \u003d tmpfile();\n  if (!f) {\n    printf(\"Could not create temporary file!\\n\");\n    return 1;\n  }\n  size_t pos_indicator \u003d ftell(f); // Compliant: `f` cannot be NULL here.\n  fseek(f, 0L, SEEK_END); // Compliant: 3rd argument is now a valid value.\n  // Further file processing ...\n  fclose(f);\n  return 0;\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/476\"\u003e476 NULL Pointer Dereference\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S3807} ensures that appropriate arguments are passed to C standard library functions \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S5488} ensures that appropriate arguments are passed to UNIX/POSIX functions \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "suspicious",
      "symbolic-execution"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S897",
    "name": "Unused type declarations should be removed",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eIf a type is declared but not used, then it is unclear to a reviewer if the type is redundant or it has been left unused by mistake.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid unusedtype()\n{\n  typedef int local_Type; // Noncompliant, unused\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 0-1-5 - A project shall not contain unused type declarations. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eIf a type is declared but not used, then it is unclear to a reviewer if the type is redundant or it has been left unused by mistake.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid unusedtype()\n{\n  typedef int local_Type; // Noncompliant, unused\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 0-1-5 - A project shall not contain unused type declarations. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "unused"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:M23_100",
    "name": "The \"address-of\" operator shall not be overloaded",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 16.5.2\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eTaking the address of an object of incomplete type where the complete type contains a user-declared \u003ccode\u003eoperator\u0026amp;\u003c/code\u003e results in\n\u003cem\u003eundefined behaviour\u003c/em\u003e (until C++11) or \u003cem\u003eunspecified behaviour\u003c/em\u003e (since C++11).\u003c/p\u003e\n\u003cp\u003eOverloading the \u003ccode\u003e\u0026amp;\u003c/code\u003e operator can make code harder to understand as \u003ccode\u003e*\u0026amp;a\u003c/code\u003e may not give the same result as\n\u003ccode\u003ea\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e \u003ccode\u003estd::addressof\u003c/code\u003e will always return the address of an object without there being a risk of \u003cem\u003eundefined\u003c/em\u003e or\n\u003cem\u003eunspecified behaviour\u003c/em\u003e.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\n// A.h\nclass A\n{\npublic:\n  A * operator\u0026amp;();       // Non-compliant\n};\n\n// f1.cc\nclass A;\n\nvoid f1( A \u0026amp; a )\n{\n  \u0026amp;a;                    // Undefined or unspecified behaviour\n}\n\n// f2.cc\n#include \"A.h\"\n\nvoid f2( A \u0026amp; a )\n{\n  \u0026amp;a;                    // Uses user-defined operator\u0026amp;\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003e{rule:cpp:S877} targets the same defect as this rule but for a non-mission-critical context.\u003c/p\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cp\u003e\u003ca\nhref\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/036324/CppCoreGuidelines.md#c166-overload-unary—​only-as-part-of-a-system-of-smart-pointers-and-references\"\u003eC++\nCore Guidelines C.166\u003c/a\u003e- Overload unary \u0026amp; only as part of a system of smart pointers and references\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 16.5.2\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eTaking the address of an object of incomplete type where the complete type contains a user-declared \u003ccode\u003eoperator\u0026amp;\u003c/code\u003e results in\n\u003cem\u003eundefined behaviour\u003c/em\u003e (until C++11) or \u003cem\u003eunspecified behaviour\u003c/em\u003e (since C++11).\u003c/p\u003e\n\u003cp\u003eOverloading the \u003ccode\u003e\u0026amp;\u003c/code\u003e operator can make code harder to understand as \u003ccode\u003e*\u0026amp;a\u003c/code\u003e may not give the same result as\n\u003ccode\u003ea\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e \u003ccode\u003estd::addressof\u003c/code\u003e will always return the address of an object without there being a risk of \u003cem\u003eundefined\u003c/em\u003e or\n\u003cem\u003eunspecified behaviour\u003c/em\u003e.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\n// A.h\nclass A\n{\npublic:\n  A * operator\u0026amp;();       // Non-compliant\n};\n\n// f1.cc\nclass A;\n\nvoid f1( A \u0026amp; a )\n{\n  \u0026amp;a;                    // Undefined or unspecified behaviour\n}\n\n// f2.cc\n#include \"A.h\"\n\nvoid f2( A \u0026amp; a )\n{\n  \u0026amp;a;                    // Uses user-defined operator\u0026amp;\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003e{rule:cpp:S877} targets the same defect as this rule but for a non-mission-critical context.\u003c/p\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cp\u003e\u003ca\nhref\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/036324/CppCoreGuidelines.md#c166-overload-unary—​only-as-part-of-a-system-of-smart-pointers-and-references\"\u003eC++\nCore Guidelines C.166\u003c/a\u003e- Overload unary \u0026amp; only as part of a system of smart pointers and references\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "misra-c++2023",
      "misra-required",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:M23_224",
    "name": "The macro \"offsetof\" shall not be used",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 21.2.4\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eThe \u003ccode\u003eoffsetof\u003c/code\u003e macro is used to access the underlying representation of an object, breaking its encapsulation. In addition, its use\nresults in \u003cem\u003eundefined behaviour\u003c/em\u003e when the specified member is a bit-field, a static data member, or a member function.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nstruct A\n{\n  int32_t i;\n};\n\nvoid f1()\n{\n  offsetof( A, i );      // Non-compliant\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003e{rule:cpp:S986} targets the same defect as this rule but for a non-mission-critical context.\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 21.2.4\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eThe \u003ccode\u003eoffsetof\u003c/code\u003e macro is used to access the underlying representation of an object, breaking its encapsulation. In addition, its use\nresults in \u003cem\u003eundefined behaviour\u003c/em\u003e when the specified member is a bit-field, a static data member, or a member function.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nstruct A\n{\n  int32_t i;\n};\n\nvoid f1()\n{\n  offsetof( A, i );      // Non-compliant\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003e{rule:cpp:S986} targets the same defect as this rule but for a non-mission-critical context.\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "misra-c++2023",
      "misra-required",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5488",
    "name": "Only valid arguments should be passed to UNIX/POSIX functions",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003cp\u003ePassing invalid arguments to UNIX/POSIX functions may result in undefined behavior.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eMany UNIX/POSIX functions put certain constraints on the values of their parameters. The behavior for some of those UNIX/POSIX functions is not\ndefined but instead, their behavior is implementation-defined, if one passes incorrectly constrained parameters. This may lead to undefined behavior\ndepending on a function’s concrete implementation. The constraints include the following:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Allocation sizes of \u003ccode\u003ecalloc\u003c/code\u003e, \u003ccode\u003emalloc\u003c/code\u003e, \u003ccode\u003erealloc\u003c/code\u003e, \u003ccode\u003ereallocf\u003c/code\u003e, \u003ccode\u003ealloca\u003c/code\u003e and\n  \u003ccode\u003evalloc\u003c/code\u003e must be strictly positive \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003eopen\u003c/code\u003e and \u003ccode\u003eopenat\u003c/code\u003e should be called with a flag that contains one of the access modes: \u003ccode\u003eO_RDONLY\u003c/code\u003e,\n  \u003ccode\u003eO_WRONLY\u003c/code\u003e, or \u003ccode\u003eO_RDWR\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003eopen\u003c/code\u003e and \u003ccode\u003eopenat\u003c/code\u003e with flag \u003ccode\u003eO_CREAT\u003c/code\u003e should be called with a third argument \u003c/li\u003e\n  \u003cli\u003e The \u003ccode\u003eO_EXCL\u003c/code\u003e flag should be used with \u003ccode\u003eO_CREAT\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e The first argument of \u003ccode\u003epthread_once\u003c/code\u003e should not have automatic storage duration and should be initialized by the constant\n  \u003ccode\u003ePTHREAD_ONCE_INIT\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eFailing to pass correctly constrained parameters can result in undefined behavior.\u003c/p\u003e\n\u003cpre\u003e\n// Depending on the implementation, either NULL is returned, or the behavior is\n// as if the passed size parameter were a non-zero value, except that accesses\n// of the returned pointer result in undefined behavior.\nvoid *mem \u003d alloca(0); // May result in undefined behavior.\n\nint fd \u003d open(\"example.txt\", O_ APPEND); // Access mode is missing, may result in undefined behavior.\n\n// Third argument should be used to specify the file\u0027s access permissions.\nint fd_1 \u003d open(\"another_example.txt\", O_CREAT); // May result in undefined behavior.\n\n// Since `O_EXCL` prevents file creation if it already exists, the flag for\n// file creation `O_CREAT` should be used in combination with `O_EXCL`.\nint fd_3 \u003d open(\"further_example.txt\", O_EXCL); // `O_CREAT` flag is missing, may result in undefined behavior.\n\nint counter \u003d 0;\n\nvoid inc_counter() { ++counter; }\n\nvoid bar() {\n  // May trigger undefined behavior, because `once_control`\u0027s storage duration\n  // is automatic. `counter` might be incremented with each call to `bar`.\n  pthread_once_t once_control \u003d PTHREAD_ONCE_INIT;\n  pthread_once(\u0026amp;once_control, \u0026amp;inc_counter); // May result in undefined behavior.\n}\n\u003c/pre\u003e\n\u003ch2\u003eWhat is the potential impact?\u003c/h2\u003e\n\u003cp\u003eUsing UNIX/POSIX functions with invalid arguments results in implementation-defined behavior and may lead to \u003cstrong\u003eundefined\nbehavior\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eWhen a function emits implementation-defined behavior, its behavior is unspecified and each implementation documents how the choice is made.\nImplementation-defined behavior can quickly lead to undefined behavior, if the respective function is not used exactly as per the documentation.\u003c/p\u003e\n\u003cp\u003eWhen a program comprises undefined behavior, the compiler no longer needs to adhere to the language standard, and the program has no meaning\nassigned to it.\u003c/p\u003e\n\u003cp\u003eDepending on the concrete situation, the application might just crash, but in the worst case, the application may appear to execute correctly,\nwhile losing data or producing incorrect results.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eEnsure that allocation sizes are strictly positive, calls to \u003ccode\u003eopen\u003c/code\u003e and \u003ccode\u003eopenat\u003c/code\u003e are correctly parameterized, and the first\nargument of \u003ccode\u003epthread_once\u003c/code\u003e has non-automatic storage duration and is initialized with \u003ccode\u003ePTHREAD_ONCE_INIT\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n\nchar *allocate_buffer(size_t size) {\n  char *buf \u003d (char *)malloc(size); // Noncompliant: `size` might be zero.\n  if (buf \u003d\u003d NULL) {\n    // Handle allocation error.\n    perror(\"malloc failed\");\n    exit(1);\n  }\n  return buf;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n\nchar *allocate_buffer(size_t size) {\n  if (size \u003d\u003d 0) { // Compliant: `size` is checked for zero.\n    // Handle error.\n    printf(\"Cannot allocate 0 bytes!\\n\");\n    exit(1);\n  }\n  char *buf \u003d (char *)malloc(size);\n  if (buf \u003d\u003d NULL) {\n    // Handle allocation error.\n    perror(\"malloc failed\");\n    exit(1);\n  }\n  return buf;\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;fcntl.h\u0026gt;\n#include \u0026lt;sys/stat.h\u0026gt;\n\nint foo() {\n  int fd \u003d open(\"example.txt\", O_CREAT); // Noncompliant: file permissions are not set.\n  if (fd \u003d\u003d -1) {\n    return -1;\n  }\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;fcntl.h\u0026gt;\n#include \u0026lt;sys/stat.h\u0026gt;\n\nint foo() {\n  // Specify read permissions for user, group and others.\n  int fd \u003d open(\"example.txt\", O_CREAT, S_IRUSR | S_IRGRP | S_IROTH); // Compliant: file permissions correctly set.\n  if (fd \u003d\u003d -1) {\n    return -1;\n  }\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;pthread.h\u0026gt;\n#include \u0026lt;stdio.h\u0026gt;\n\nint counter \u003d 0;\n\nvoid inc_counter() { ++counter; }\n\nvoid bar() {\n  pthread_once_t once_control \u003d PTHREAD_ONCE_INIT;\n  pthread_once(\u0026amp;once_control, \u0026amp;inc_counter); // Noncompliant: `once_control` has automatic storage duration.\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;pthread.h\u0026gt;\n#include \u0026lt;stdio.h\u0026gt;\n\nint counter \u003d 0;\npthread_once_t once_control \u003d PTHREAD_ONCE_INIT;\n\nvoid inc_counter() { ++counter; }\n\nvoid bar() {\n  pthread_once(\u0026amp;once_control, \u0026amp;inc_counter); // Compliant: `once_control` has global storage duration here.\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/display/c/MEM04-C.+Beware+of+zero-length+allocations\"\u003eMEM04-C. Beware of zero-length\n  allocations\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S3807} ensures that appropriate arguments are passed to C standard library functions \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S5485} ensures that appropriate arguments are passed to C standard library for handling I/O streams \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003ePassing invalid arguments to UNIX/POSIX functions may result in undefined behavior.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eMany UNIX/POSIX functions put certain constraints on the values of their parameters. The behavior for some of those UNIX/POSIX functions is not\ndefined but instead, their behavior is implementation-defined, if one passes incorrectly constrained parameters. This may lead to undefined behavior\ndepending on a function’s concrete implementation. The constraints include the following:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Allocation sizes of \u003ccode\u003ecalloc\u003c/code\u003e, \u003ccode\u003emalloc\u003c/code\u003e, \u003ccode\u003erealloc\u003c/code\u003e, \u003ccode\u003ereallocf\u003c/code\u003e, \u003ccode\u003ealloca\u003c/code\u003e and\n  \u003ccode\u003evalloc\u003c/code\u003e must be strictly positive \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003eopen\u003c/code\u003e and \u003ccode\u003eopenat\u003c/code\u003e should be called with a flag that contains one of the access modes: \u003ccode\u003eO_RDONLY\u003c/code\u003e,\n  \u003ccode\u003eO_WRONLY\u003c/code\u003e, or \u003ccode\u003eO_RDWR\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003eopen\u003c/code\u003e and \u003ccode\u003eopenat\u003c/code\u003e with flag \u003ccode\u003eO_CREAT\u003c/code\u003e should be called with a third argument \u003c/li\u003e\n  \u003cli\u003e The \u003ccode\u003eO_EXCL\u003c/code\u003e flag should be used with \u003ccode\u003eO_CREAT\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e The first argument of \u003ccode\u003epthread_once\u003c/code\u003e should not have automatic storage duration and should be initialized by the constant\n  \u003ccode\u003ePTHREAD_ONCE_INIT\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eFailing to pass correctly constrained parameters can result in undefined behavior.\u003c/p\u003e\n\u003cpre\u003e\n// Depending on the implementation, either NULL is returned, or the behavior is\n// as if the passed size parameter were a non-zero value, except that accesses\n// of the returned pointer result in undefined behavior.\nvoid *mem \u003d alloca(0); // May result in undefined behavior.\n\nint fd \u003d open(\"example.txt\", O_ APPEND); // Access mode is missing, may result in undefined behavior.\n\n// Third argument should be used to specify the file\u0027s access permissions.\nint fd_1 \u003d open(\"another_example.txt\", O_CREAT); // May result in undefined behavior.\n\n// Since `O_EXCL` prevents file creation if it already exists, the flag for\n// file creation `O_CREAT` should be used in combination with `O_EXCL`.\nint fd_3 \u003d open(\"further_example.txt\", O_EXCL); // `O_CREAT` flag is missing, may result in undefined behavior.\n\nint counter \u003d 0;\n\nvoid inc_counter() { ++counter; }\n\nvoid bar() {\n  // May trigger undefined behavior, because `once_control`\u0027s storage duration\n  // is automatic. `counter` might be incremented with each call to `bar`.\n  pthread_once_t once_control \u003d PTHREAD_ONCE_INIT;\n  pthread_once(\u0026amp;once_control, \u0026amp;inc_counter); // May result in undefined behavior.\n}\n\u003c/pre\u003e\n\u003ch2\u003eWhat is the potential impact?\u003c/h2\u003e\n\u003cp\u003eUsing UNIX/POSIX functions with invalid arguments results in implementation-defined behavior and may lead to \u003cstrong\u003eundefined\nbehavior\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eWhen a function emits implementation-defined behavior, its behavior is unspecified and each implementation documents how the choice is made.\nImplementation-defined behavior can quickly lead to undefined behavior, if the respective function is not used exactly as per the documentation.\u003c/p\u003e\n\u003cp\u003eWhen a program comprises undefined behavior, the compiler no longer needs to adhere to the language standard, and the program has no meaning\nassigned to it.\u003c/p\u003e\n\u003cp\u003eDepending on the concrete situation, the application might just crash, but in the worst case, the application may appear to execute correctly,\nwhile losing data or producing incorrect results.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eEnsure that allocation sizes are strictly positive, calls to \u003ccode\u003eopen\u003c/code\u003e and \u003ccode\u003eopenat\u003c/code\u003e are correctly parameterized, and the first\nargument of \u003ccode\u003epthread_once\u003c/code\u003e has non-automatic storage duration and is initialized with \u003ccode\u003ePTHREAD_ONCE_INIT\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n\nchar *allocate_buffer(size_t size) {\n  char *buf \u003d (char *)malloc(size); // Noncompliant: `size` might be zero.\n  if (buf \u003d\u003d NULL) {\n    // Handle allocation error.\n    perror(\"malloc failed\");\n    exit(1);\n  }\n  return buf;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n\nchar *allocate_buffer(size_t size) {\n  if (size \u003d\u003d 0) { // Compliant: `size` is checked for zero.\n    // Handle error.\n    printf(\"Cannot allocate 0 bytes!\\n\");\n    exit(1);\n  }\n  char *buf \u003d (char *)malloc(size);\n  if (buf \u003d\u003d NULL) {\n    // Handle allocation error.\n    perror(\"malloc failed\");\n    exit(1);\n  }\n  return buf;\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;fcntl.h\u0026gt;\n#include \u0026lt;sys/stat.h\u0026gt;\n\nint foo() {\n  int fd \u003d open(\"example.txt\", O_CREAT); // Noncompliant: file permissions are not set.\n  if (fd \u003d\u003d -1) {\n    return -1;\n  }\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;fcntl.h\u0026gt;\n#include \u0026lt;sys/stat.h\u0026gt;\n\nint foo() {\n  // Specify read permissions for user, group and others.\n  int fd \u003d open(\"example.txt\", O_CREAT, S_IRUSR | S_IRGRP | S_IROTH); // Compliant: file permissions correctly set.\n  if (fd \u003d\u003d -1) {\n    return -1;\n  }\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;pthread.h\u0026gt;\n#include \u0026lt;stdio.h\u0026gt;\n\nint counter \u003d 0;\n\nvoid inc_counter() { ++counter; }\n\nvoid bar() {\n  pthread_once_t once_control \u003d PTHREAD_ONCE_INIT;\n  pthread_once(\u0026amp;once_control, \u0026amp;inc_counter); // Noncompliant: `once_control` has automatic storage duration.\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;pthread.h\u0026gt;\n#include \u0026lt;stdio.h\u0026gt;\n\nint counter \u003d 0;\npthread_once_t once_control \u003d PTHREAD_ONCE_INIT;\n\nvoid inc_counter() { ++counter; }\n\nvoid bar() {\n  pthread_once(\u0026amp;once_control, \u0026amp;inc_counter); // Compliant: `once_control` has global storage duration here.\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/display/c/MEM04-C.+Beware+of+zero-length+allocations\"\u003eMEM04-C. Beware of zero-length\n  allocations\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S3807} ensures that appropriate arguments are passed to C standard library functions \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S5485} ensures that appropriate arguments are passed to C standard library for handling I/O streams \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "suspicious",
      "symbolic-execution"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6214",
    "name": "\"std::cmp_*\" functions should be used to compare unsigned values with negative values",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003cp\u003eCompare integers of mixed signedness safely using \u003ccode\u003estd::cmp_*\u003c/code\u003e functions to avoid any unexpected results.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eComparison between \u003ccode\u003esigned\u003c/code\u003e and \u003ccode\u003eunsigned\u003c/code\u003e integers is dangerous because it produces counter-intuitive results due to\nimplicit conversions. When a signed integer is compared to an unsigned one, the former might be converted to unsigned. Since C++20, the conversion\npreserves the two’s-complement bit pattern of the signed value that always corresponds to a large unsigned result. For example, \u003ccode\u003e2U \u0026lt;\n-1\u003c/code\u003e is \u003ccode\u003etrue\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when an unsigned integer is compared with a negative value.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact\u003c/h3\u003e\n\u003cp\u003eInteger comparisons are often used in branch and loop conditions. An unexpected result from one of these conditions can lead to hard-to-detect\nissues, such as unexpected infinite loops.\u003c/p\u003e\n\u003cp\u003eFor example, using container size functions in a comparison can lead to such a problem since these return an unsigned integer value.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eC++20 introduced a remedy to this common pitfall: a family of \u003ccode\u003estd::cmp_*\u003c/code\u003e functions defined in the \u003ccode\u003e\u0026lt;utility\u0026gt;\u003c/code\u003e header.\nThese functions correctly handle negative numbers and lossy integer conversion. For example, \u003ccode\u003estd::cmp_less(2U, -1)\u003c/code\u003e is\n\u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nbool less \u003d 2U \u0026lt; -1; // Noncompliant\n\nunsigned x \u003d 1;\nsigned y \u003d -1;\nif (x \u0026lt; y) { // Noncompliant\n  // ...\n}\n\nbool fun(int x, std::vector\u0026lt;int\u0026gt; const\u0026amp; v) {\n  return x \u0026lt; v.size(); // Noncompliant: if x is negative, it is converted to unsigned, losing its value.\n}\n\nstd::vector\u0026lt;int\u0026gt; v \u003d foo();\nif (-1 \u0026lt; v.size() \u0026amp;\u0026amp; v.size() \u0026lt; 100) { // Noncompliant: -1 \u0026lt; v.size() is false for all sizes.\n                                       // -1 converted to unsigned is larger than any int value\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nbool less \u003d std::cmp_less(2U, -1); // Compliant\n\nunsigned x \u003d 1;\nsigned y \u003d -1;\nif (std::cmp_less(x, y)) { // Compliant\n  // ...\n}\n\nbool fun(int x, std::vector\u0026lt;int\u0026gt; const\u0026amp; v) {\n  return std::cmp_less(x, v.size()); // Compliant\n}\n\nstd::vector\u0026lt;int\u0026gt; v \u003d foo();\nif (0 \u0026lt;\u003d v.size() \u0026amp;\u0026amp; v.size() \u0026lt; 100) { // Compliant, even though v.size() returns an unsigned integer\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/utility/intcmp\"\u003estd::cmp_* functions\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S845} - a more generic rule about mixing signed and unsigned values. \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S6183} - a version of this rule that triggers when any signed and unsigned variables are compared. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eCompare integers of mixed signedness safely using \u003ccode\u003estd::cmp_*\u003c/code\u003e functions to avoid any unexpected results.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eComparison between \u003ccode\u003esigned\u003c/code\u003e and \u003ccode\u003eunsigned\u003c/code\u003e integers is dangerous because it produces counter-intuitive results due to\nimplicit conversions. When a signed integer is compared to an unsigned one, the former might be converted to unsigned. Since C++20, the conversion\npreserves the two’s-complement bit pattern of the signed value that always corresponds to a large unsigned result. For example, \u003ccode\u003e2U \u0026lt;\n-1\u003c/code\u003e is \u003ccode\u003etrue\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when an unsigned integer is compared with a negative value.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact\u003c/h3\u003e\n\u003cp\u003eInteger comparisons are often used in branch and loop conditions. An unexpected result from one of these conditions can lead to hard-to-detect\nissues, such as unexpected infinite loops.\u003c/p\u003e\n\u003cp\u003eFor example, using container size functions in a comparison can lead to such a problem since these return an unsigned integer value.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eC++20 introduced a remedy to this common pitfall: a family of \u003ccode\u003estd::cmp_*\u003c/code\u003e functions defined in the \u003ccode\u003e\u0026lt;utility\u0026gt;\u003c/code\u003e header.\nThese functions correctly handle negative numbers and lossy integer conversion. For example, \u003ccode\u003estd::cmp_less(2U, -1)\u003c/code\u003e is\n\u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nbool less \u003d 2U \u0026lt; -1; // Noncompliant\n\nunsigned x \u003d 1;\nsigned y \u003d -1;\nif (x \u0026lt; y) { // Noncompliant\n  // ...\n}\n\nbool fun(int x, std::vector\u0026lt;int\u0026gt; const\u0026amp; v) {\n  return x \u0026lt; v.size(); // Noncompliant: if x is negative, it is converted to unsigned, losing its value.\n}\n\nstd::vector\u0026lt;int\u0026gt; v \u003d foo();\nif (-1 \u0026lt; v.size() \u0026amp;\u0026amp; v.size() \u0026lt; 100) { // Noncompliant: -1 \u0026lt; v.size() is false for all sizes.\n                                       // -1 converted to unsigned is larger than any int value\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nbool less \u003d std::cmp_less(2U, -1); // Compliant\n\nunsigned x \u003d 1;\nsigned y \u003d -1;\nif (std::cmp_less(x, y)) { // Compliant\n  // ...\n}\n\nbool fun(int x, std::vector\u0026lt;int\u0026gt; const\u0026amp; v) {\n  return std::cmp_less(x, v.size()); // Compliant\n}\n\nstd::vector\u0026lt;int\u0026gt; v \u003d foo();\nif (0 \u0026lt;\u003d v.size() \u0026amp;\u0026amp; v.size() \u0026lt; 100) { // Compliant, even though v.size() returns an unsigned integer\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/utility/intcmp\"\u003estd::cmp_* functions\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S845} - a more generic rule about mixing signed and unsigned values. \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S6183} - a version of this rule that triggers when any signed and unsigned variables are compared. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "bad-practice",
      "pitfall",
      "since-c++20",
      "symbolic-execution"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6456",
    "name": "Requires-expression should not contain unevaluated concept checks or type predicates",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eA \u003cem\u003erequires-expression\u003c/em\u003e is a list of requirements that can be of different natures. \u003cem\u003eSimple-requirements\u003c/em\u003e are expressions that do not\nstart with the keyword \u003ccode\u003erequires\u003c/code\u003e and \u003cem\u003ecompound-requirements\u003c/em\u003e are expressions surrounded by curly brackets potentially followed by a\n\u003ccode\u003enoexcept\u003c/code\u003e specification and return type requirements.\u003c/p\u003e\n\u003cp\u003eIn both cases, the expressions are not evaluated. They will only be checked for validity, and if the expression is invalid, the\n\u003cem\u003erequires-expression\u003c/em\u003e evaluates to \u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eWhen we write a concept check or a type predicate, the intent is usually to evaluate them, therefore, they don’t really belong in a\n\u003cem\u003esimple-requirement\u003c/em\u003e or a \u003cem\u003ecompound-requirement\u003c/em\u003e. Instead, they should either be used directly in a concept definition (outside of a\n\u003cem\u003erequires-expression\u003c/em\u003e) or, less often, as a \u003cem\u003enested-requirement\u003c/em\u003e (a requirement introduced by the \u003ccode\u003erequires\u003c/code\u003e keyword within\nthe \u003cem\u003erequires-expression\u003c/em\u003e).\u003c/p\u003e\n\u003cp\u003eThis rule detects concept checks and standard type predicates (from the header \u003ccode\u003e\u0026lt;type_traits\u0026gt;\u003c/code\u003e) in single and compound\nrequirements of \u003cem\u003erequires-expressions\u003c/em\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\ntemplate\u0026lt;typename T\u0026gt;\nconcept TriviallyCopyable \u003d requires {\n   std::copyable\u0026lt;T\u0026gt;;  // Noncompliant\n   {std::is_trivally_copy_constructible_v\u0026lt;T\u0026gt;}; // Noncompliant\n   std::is_trivally_move_constructible\u0026lt;T\u0026gt;::value; // Noncompliant\n};\n\u003c/pre\u003e\n\u003cp\u003eThis concept is always \u003ccode\u003etrue\u003c/code\u003e, for every type \u003ccode\u003eT\u003c/code\u003e, because expressions such as \u003ccode\u003estd::copyable\u0026lt;T\u0026gt;\u003c/code\u003e are always\nwell-formed.\u003c/p\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\ntemplate\u0026lt;typename T\u0026gt;\nconcept TriviallyCopyable \u003d\n    std::copyable\u0026lt;T\u0026gt; \u0026amp;\u0026amp;\n    std::is_trivially_copy_constructible_v\u0026lt;T\u0026gt; \u0026amp;\u0026amp;\n    std::is_trivially_move_constructible\u0026lt;T\u0026gt;::value;\n\u003c/pre\u003e\n\u003cp\u003eOr:\u003c/p\u003e\n\u003cpre\u003e\ntemplate\u0026lt;typename T\u0026gt;\nconcept TriviallyCopyable \u003d requires {\n   requires std::copyable\u0026lt;T\u0026gt;;\n   requires std::is_trivially_copy_constructible_v\u0026lt;T\u0026gt; \u0026amp;\u0026amp;\n       std::is_trivially_move_constructible\u0026lt;T\u0026gt;::value;\n};\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eA \u003cem\u003erequires-expression\u003c/em\u003e is a list of requirements that can be of different natures. \u003cem\u003eSimple-requirements\u003c/em\u003e are expressions that do not\nstart with the keyword \u003ccode\u003erequires\u003c/code\u003e and \u003cem\u003ecompound-requirements\u003c/em\u003e are expressions surrounded by curly brackets potentially followed by a\n\u003ccode\u003enoexcept\u003c/code\u003e specification and return type requirements.\u003c/p\u003e\n\u003cp\u003eIn both cases, the expressions are not evaluated. They will only be checked for validity, and if the expression is invalid, the\n\u003cem\u003erequires-expression\u003c/em\u003e evaluates to \u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eWhen we write a concept check or a type predicate, the intent is usually to evaluate them, therefore, they don’t really belong in a\n\u003cem\u003esimple-requirement\u003c/em\u003e or a \u003cem\u003ecompound-requirement\u003c/em\u003e. Instead, they should either be used directly in a concept definition (outside of a\n\u003cem\u003erequires-expression\u003c/em\u003e) or, less often, as a \u003cem\u003enested-requirement\u003c/em\u003e (a requirement introduced by the \u003ccode\u003erequires\u003c/code\u003e keyword within\nthe \u003cem\u003erequires-expression\u003c/em\u003e).\u003c/p\u003e\n\u003cp\u003eThis rule detects concept checks and standard type predicates (from the header \u003ccode\u003e\u0026lt;type_traits\u0026gt;\u003c/code\u003e) in single and compound\nrequirements of \u003cem\u003erequires-expressions\u003c/em\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\ntemplate\u0026lt;typename T\u0026gt;\nconcept TriviallyCopyable \u003d requires {\n   std::copyable\u0026lt;T\u0026gt;;  // Noncompliant\n   {std::is_trivally_copy_constructible_v\u0026lt;T\u0026gt;}; // Noncompliant\n   std::is_trivally_move_constructible\u0026lt;T\u0026gt;::value; // Noncompliant\n};\n\u003c/pre\u003e\n\u003cp\u003eThis concept is always \u003ccode\u003etrue\u003c/code\u003e, for every type \u003ccode\u003eT\u003c/code\u003e, because expressions such as \u003ccode\u003estd::copyable\u0026lt;T\u0026gt;\u003c/code\u003e are always\nwell-formed.\u003c/p\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\ntemplate\u0026lt;typename T\u0026gt;\nconcept TriviallyCopyable \u003d\n    std::copyable\u0026lt;T\u0026gt; \u0026amp;\u0026amp;\n    std::is_trivially_copy_constructible_v\u0026lt;T\u0026gt; \u0026amp;\u0026amp;\n    std::is_trivially_move_constructible\u0026lt;T\u0026gt;::value;\n\u003c/pre\u003e\n\u003cp\u003eOr:\u003c/p\u003e\n\u003cpre\u003e\ntemplate\u0026lt;typename T\u0026gt;\nconcept TriviallyCopyable \u003d requires {\n   requires std::copyable\u0026lt;T\u0026gt;;\n   requires std::is_trivially_copy_constructible_v\u0026lt;T\u0026gt; \u0026amp;\u0026amp;\n       std::is_trivially_move_constructible\u0026lt;T\u0026gt;::value;\n};\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "since-c++20",
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5489",
    "name": "\"pthread_mutex_t\" should be unlocked in the reverse order they were locked",
    "defaultSeverity": "BLOCKER",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cem\u003eMutexes\u003c/em\u003e are synchronization primitives that allow the managing of concurrency. It is a common situation to have to use multiple\n\u003cem\u003emutexes\u003c/em\u003e to protect multiple resources with different access patterns.\u003c/p\u003e\n\u003cp\u003eIn such a situation, it is crucial to define an order on the set of all \u003cem\u003emutexes\u003c/em\u003e:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e This order should be strictly followed when \u003cem\u003elocking\u003c/em\u003e \u003cem\u003emutexes\u003c/em\u003e. \u003c/li\u003e\n  \u003cli\u003e The reverse order should be strictly followed when \u003cem\u003eunlocking\u003c/em\u003e \u003cem\u003emutexes\u003c/em\u003e. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eFailure to do so can lead to \u003cem\u003edeadlocks\u003c/em\u003e. i.e., situations where two or more threads are blocked forever, each holding one mutex and waiting\nfor one held by the other(s).\u003c/p\u003e\n\u003cp\u003eIn C++, an easy way to make sure the unlocks are called in reverse order from the lock is to wrap the lock/unlock operations in an RAII class\n(since destructors of local variables are called in reverse order of their creation).\u003c/p\u003e\n\u003cp\u003eIf instead of \u003ccode\u003epthread_mutex_t\u003c/code\u003e you are using \u003ccode\u003estd::mutex\u003c/code\u003e, there are other mechanisms that allow you to avoid deadlocks in\nthat case, see {rule:cpp:S5524}.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eReorder locking and unlocking operations to always lock in the same order and unlock in the reverse order.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre\u003e\npthread_mutex_t mtx1;\npthread_mutex_t mtx2;\n\nvoid thread_safe_operation(void) {\n  pthread_mutex_lock(\u0026amp;mtx1);\n  pthread_mutex_lock(\u0026amp;mtx2);\n  use_resources();\n  pthread_mutex_unlock(\u0026amp;mtx1); // Noncompliant\n  pthread_mutex_unlock(\u0026amp;mtx2);\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eC solution:\u003c/p\u003e\n\u003cpre\u003e\npthread_mutex_t mtx1;\npthread_mutex_t mtx2;\n\nvoid thread_safe_operation(void) {\n  pthread_mutex_lock(\u0026amp;mtx1);\n  pthread_mutex_lock(\u0026amp;mtx2);\n  use_resources();\n  pthread_mutex_unlock(\u0026amp;mtx2);\n  pthread_mutex_unlock(\u0026amp;mtx1);\n}\n\u003c/pre\u003e\n\u003cp\u003eC++03 solution:\u003c/p\u003e\n\u003cpre\u003e\npthread_mutex_t mtx1;\npthread_mutex_t mtx2;\n\nstruct MutexLocker {\n  MutexLocker(pthread_mutex_t* mtx) : mtx(mtx) {\n    pthread_mutex_lock(mtx);\n  }\n  ~MutexLocker() {\n    pthread_mutex_unlock(mtx);\n  }\n  pthread_mutex_t* mtx;\n};\n\nstruct ResourcesLocker {\n  ResourcesLocker() : m1(\u0026amp;mtx1), m2(\u0026amp;mtx2) {}\n  MutexLocker m1;\n  MutexLocker m2;\n};\n\nvoid thread_safe_operation(void) {\n  ResourcesLocker locker;\n  use_resources();\n}\n\u003c/pre\u003e\n\u003cp\u003eC++11 and C++14 solution:\u003c/p\u003e\n\u003cpre\u003e\nstd::mutex m1;\nstd::mutex m2;\n\nvoid thread_safe_operation(void) {\n  std::lock(m1, m2);\n  std::lock_guard\u0026lt;std::mutex\u0026gt; lck1(m1, std::adopt_lock);\n  std::lock_guard\u0026lt;std::mutex\u0026gt; lck2(m2, std::adopt_lock);\n  use_resources();\n}\n\u003c/pre\u003e\n\u003cp\u003eC++17 and after:\u003c/p\u003e\n\u003cpre\u003e\nstd::mutex m1;\nstd::mutex m2;\n\nvoid thread_safe_operation(void) {\n  std::scoped_lock lck1(m1, m2);\n  use_resources();\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cem\u003eMutexes\u003c/em\u003e are synchronization primitives that allow the managing of concurrency. It is a common situation to have to use multiple\n\u003cem\u003emutexes\u003c/em\u003e to protect multiple resources with different access patterns.\u003c/p\u003e\n\u003cp\u003eIn such a situation, it is crucial to define an order on the set of all \u003cem\u003emutexes\u003c/em\u003e:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e This order should be strictly followed when \u003cem\u003elocking\u003c/em\u003e \u003cem\u003emutexes\u003c/em\u003e. \u003c/li\u003e\n  \u003cli\u003e The reverse order should be strictly followed when \u003cem\u003eunlocking\u003c/em\u003e \u003cem\u003emutexes\u003c/em\u003e. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eFailure to do so can lead to \u003cem\u003edeadlocks\u003c/em\u003e. i.e., situations where two or more threads are blocked forever, each holding one mutex and waiting\nfor one held by the other(s).\u003c/p\u003e\n\u003cp\u003eIn C++, an easy way to make sure the unlocks are called in reverse order from the lock is to wrap the lock/unlock operations in an RAII class\n(since destructors of local variables are called in reverse order of their creation).\u003c/p\u003e\n\u003cp\u003eIf instead of \u003ccode\u003epthread_mutex_t\u003c/code\u003e you are using \u003ccode\u003estd::mutex\u003c/code\u003e, there are other mechanisms that allow you to avoid deadlocks in\nthat case, see {rule:cpp:S5524}.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eReorder locking and unlocking operations to always lock in the same order and unlock in the reverse order.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre\u003e\npthread_mutex_t mtx1;\npthread_mutex_t mtx2;\n\nvoid thread_safe_operation(void) {\n  pthread_mutex_lock(\u0026amp;mtx1);\n  pthread_mutex_lock(\u0026amp;mtx2);\n  use_resources();\n  pthread_mutex_unlock(\u0026amp;mtx1); // Noncompliant\n  pthread_mutex_unlock(\u0026amp;mtx2);\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eC solution:\u003c/p\u003e\n\u003cpre\u003e\npthread_mutex_t mtx1;\npthread_mutex_t mtx2;\n\nvoid thread_safe_operation(void) {\n  pthread_mutex_lock(\u0026amp;mtx1);\n  pthread_mutex_lock(\u0026amp;mtx2);\n  use_resources();\n  pthread_mutex_unlock(\u0026amp;mtx2);\n  pthread_mutex_unlock(\u0026amp;mtx1);\n}\n\u003c/pre\u003e\n\u003cp\u003eC++03 solution:\u003c/p\u003e\n\u003cpre\u003e\npthread_mutex_t mtx1;\npthread_mutex_t mtx2;\n\nstruct MutexLocker {\n  MutexLocker(pthread_mutex_t* mtx) : mtx(mtx) {\n    pthread_mutex_lock(mtx);\n  }\n  ~MutexLocker() {\n    pthread_mutex_unlock(mtx);\n  }\n  pthread_mutex_t* mtx;\n};\n\nstruct ResourcesLocker {\n  ResourcesLocker() : m1(\u0026amp;mtx1), m2(\u0026amp;mtx2) {}\n  MutexLocker m1;\n  MutexLocker m2;\n};\n\nvoid thread_safe_operation(void) {\n  ResourcesLocker locker;\n  use_resources();\n}\n\u003c/pre\u003e\n\u003cp\u003eC++11 and C++14 solution:\u003c/p\u003e\n\u003cpre\u003e\nstd::mutex m1;\nstd::mutex m2;\n\nvoid thread_safe_operation(void) {\n  std::lock(m1, m2);\n  std::lock_guard\u0026lt;std::mutex\u0026gt; lck1(m1, std::adopt_lock);\n  std::lock_guard\u0026lt;std::mutex\u0026gt; lck2(m2, std::adopt_lock);\n  use_resources();\n}\n\u003c/pre\u003e\n\u003cp\u003eC++17 and after:\u003c/p\u003e\n\u003cpre\u003e\nstd::mutex m1;\nstd::mutex m2;\n\nvoid thread_safe_operation(void) {\n  std::scoped_lock lck1(m1, m2);\n  use_resources();\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "multi-threading",
      "symbolic-execution"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5486",
    "name": "\"pthread_mutex_t\" should not be locked when already locked, or unlocked when already unlocked",
    "defaultSeverity": "BLOCKER",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003cp\u003e\u003ccode\u003epthread_mutex_t\u003c/code\u003e should not be locked when already locked, or unlocked when already unlocked.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cem\u003eMutexes\u003c/em\u003e are synchronization primitives that allow to manage concurrency. This is the most fundamental building block for creating\n\u003cem\u003esafe\u003c/em\u003e concurrent applications. By using a \u003cem\u003emutex\u003c/em\u003e, one can ensure that a block of code is executed by a single thread concurrently.\nData structures are designed to maintain their invariants between member-function calls. If a data structure is accessed concurrently, and one of the\naccesses is a write operation, then it has a \u003cem\u003edata race\u003c/em\u003e. Having \u003cem\u003edata races\u003c/em\u003e is \u003cem\u003eundefined behavior\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eAdversaries actively exploit \u003cem\u003edata races\u003c/em\u003e to take over systems, but \u003cem\u003edata races\u003c/em\u003e are also a common source of \u003cem\u003edata corruption\u003c/em\u003e\nin concurrent applications resulting in dormant and hard-to-find bugs.\u003c/p\u003e\n\u003cp\u003eTo prevent \u003cem\u003edata races\u003c/em\u003e, the shared resource (usually memory) must be protected by obtaining mutual access to the data during both reading\nand writing. Such mutual exclusion is generally achieved by using a \u003cem\u003emutex\u003c/em\u003e, which is frequently referred to as a \u003cem\u003elock\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eA \u003cem\u003emutex\u003c/em\u003e has two states: \u003cem\u003ereleased\u003c/em\u003e - which is the initial state, or \u003cem\u003eacquired\u003c/em\u003e. These two states are frequently called\n\u003cem\u003eunlocked\u003c/em\u003e and \u003cem\u003elocked\u003c/em\u003e as well.\u003c/p\u003e\n\u003cp\u003eTo effectively protect the shared resource from concurrent accesses, all such accesses should be guarded by the same \u003cem\u003emutex\u003c/em\u003e. They need to\n\u003cem\u003elock\u003c/em\u003e the \u003cem\u003emutex\u003c/em\u003e to gain \u003cem\u003esafe\u003c/em\u003e exclusive access to the resource and \u003cem\u003eunlock\u003c/em\u003e it after they are done mutating or reading\nit.\u003c/p\u003e\n\u003cp\u003eYou can abstract away the concurrent threads sharing the mutex and think of it as owned by the current thread. It never spontaneously changes\nbetween \u003cem\u003eacquired\u003c/em\u003e and \u003cem\u003ereleased\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eIn this view, these are the possible transitions when calling \u003ccode\u003elock\u003c/code\u003e or \u003ccode\u003eunlock\u003c/code\u003e on a \u003cem\u003emutex\u003c/em\u003e in a given state:\u003c/p\u003e\n\u003col\u003e\n  \u003cli\u003e \u003cem\u003ereleased\u003c/em\u003e + \u003ccode\u003elock()\u003c/code\u003e ⇒ \u003cem\u003eacquired\u003c/em\u003e \u003c/li\u003e\n  \u003cli\u003e \u003cem\u003eacquired\u003c/em\u003e + \u003ccode\u003eunlock()\u003c/code\u003e ⇒ \u003cem\u003ereleased\u003c/em\u003e \u003c/li\u003e\n  \u003cli\u003e \u003cem\u003eacquired\u003c/em\u003e + \u003ccode\u003elock()\u003c/code\u003e ⇒ \u003cem\u003edeadlock\u003c/em\u003e \u003c/li\u003e\n  \u003cli\u003e \u003cem\u003ereleased\u003c/em\u003e + \u003ccode\u003eunlock()\u003c/code\u003e ⇒ \u003cem\u003eundefined behavior\u003c/em\u003e \u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eWhen a thread locks a mutex, another thread trying to \u003cem\u003eacquire\u003c/em\u003e the same mutex will be \u003cem\u003eblocked\u003c/em\u003e and have to wait for the first\nthread to \u003cem\u003erelease\u003c/em\u003e it. This waiting period can take some time. If a thread attempts to lock a mutex it has already acquired, it will\n\u003cem\u003edeadlock\u003c/em\u003e because it would need to release it to lock it again.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eLocking an \u003cem\u003eacquired\u003c/em\u003e mutex leads to a \u003cem\u003edeadlock\u003c/em\u003e, as a mutex can only be obtained once. Unlocking a \u003cem\u003ereleased\u003c/em\u003e mutex is\n\u003cem\u003eundefined behavior\u003c/em\u003e. Removing synchronization can cause \u003cem\u003edata races\u003c/em\u003e, leading to \u003cem\u003edata corruption\u003c/em\u003e, which adversaries might\nleverage to take over the system.\u003c/p\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThere are \u003cem\u003erecursive mutexes\u003c/em\u003e that can be \u003cem\u003eacquired\u003c/em\u003e multiple times by the same thread, given that just as many times we also\n\u003cem\u003erelease\u003c/em\u003e the \u003cem\u003emutex\u003c/em\u003e. They are rare in practice and usually signal design problems in the code. Thus we assume\n\u003ccode\u003epthread_mutex_t\u003c/code\u003e refers to \u003cem\u003enon-recursive\u003c/em\u003e mutexes.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eNever lock an \u003cem\u003eacquired\u003c/em\u003e mutex. Lock the mutexes in a strict order that is followed throughout the project. Unlock operations should be done\nthe same way but in reversed order.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;pthread.h\u0026gt;\n\npthread_mutex_t m1 \u003d PTHREAD_MUTEX_INITIALIZER;\npthread_mutex_t m2 \u003d PTHREAD_MUTEX_INITIALIZER;\n\nvoid locks() {\n  pthread_mutex_lock(\u0026amp;m1);\n  pthread_mutex_lock(\u0026amp;m1); // Noncompliant: \u0027m1\u0027 is already acquired\n}\n\nvoid unlocks() {\n  pthread_mutex_unlock(\u0026amp;m1);\n  pthread_mutex_unlock(\u0026amp;m1); // Noncompliant: \u0027m1\u0027 is already released\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;pthread.h\u0026gt;\n\npthread_mutex_t m1 \u003d PTHREAD_MUTEX_INITIALIZER;\npthread_mutex_t m2 \u003d PTHREAD_MUTEX_INITIALIZER;\n\nvoid locks() {\n  pthread_mutex_lock(\u0026amp;m1);\n  pthread_mutex_lock(\u0026amp;m2); // Compliant: we acquired both \u0027m1\u0027 and \u0027m2\u0027 for the first time.\n}\n\nvoid unlocks() {\n  pthread_mutex_unlock(\u0026amp;m2);\n  pthread_mutex_unlock(\u0026amp;m1); // Compliant: we released both \u0027m1\u0027 and \u0027m2\u0027 for the first time.\n}\n\u003c/pre\u003e\n\u003ch3\u003ePitfalls\u003c/h3\u003e\n\u003cp\u003eCalling arbitrary functions while holding a lock should be avoided, as the function might also want to lock the resource we already acquired,\ncausing a deadlock. One particular example of such functions is callbacks.\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;pthread.h\u0026gt;\n\npthread_mutex_t m \u003d PTHREAD_MUTEX_INITIALIZER;\n\nvoid handle_callback(void (*callback)(void)) {\n  pthread_mutex_lock(\u0026amp;m);\n  callback(); // If tries to lock mutex \u0027m\u0027, then we have a deadlock.\n  pthread_mutex_unlock(\u0026amp;m);\n}\n\u003c/pre\u003e\n\u003ch3\u003eGoing the extra mile\u003c/h3\u003e\n\u003cp\u003eThe section of code for which the \u003cem\u003emutex\u003c/em\u003e is \u003cem\u003eacquired\u003c/em\u003e is called the \u003cem\u003ecritical section\u003c/em\u003e. Inside the \u003cem\u003ecritical\nsection\u003c/em\u003e, we are the only ones with access to the shared resource. Thus we are free to mutate or read it without considering what other threads\nare doing concurrently. However, having large \u003cem\u003ecritical sections\u003c/em\u003e can prevent other threads from making progress if they want to also\n\u003cem\u003eacquire\u003c/em\u003e the same \u003cem\u003emutex\u003c/em\u003e and access the shared resource. Consequently, \u003cem\u003ecritical sections\u003c/em\u003e are supposed to be as small as\npossible.\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;pthread.h\u0026gt;\n#include \u0026lt;stdbool.h\u0026gt;\n\nint input;\nint result;\nbool isFib;\n\n// Guards both \u0027num1\u0027 and \u0027num2\u0027.\npthread_mutex_t m \u003d PTHREAD_MUTEX_INITIALIZER;\n\nint fibonacci(int n);\nint factorial(int n);\n\nvoid locks(bool calcFib, int n) {\n  // Do the calculations without taking the lock.\n  int res;\n  if (calcFib) {\n    res \u003d fibonacci(n);\n  } else {\n    res \u003d factorial(n);\n  }\n\n  pthread_mutex_lock(\u0026amp;m);\n  // Critical section starts\n  input \u003d n;\n  result \u003d res;\n  isFib \u003d calcFib;\n  // Critical section ends.\n  pthread_mutex_unlock(\u0026amp;m);\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/764\"\u003e764 Multiple Locks of a Critical Resource\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/362\"\u003e362 Multiple Concurrent Execution using Shared Resource with Improper\n  Synchronization (\u0027Race Condition\u0027)\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S5487} enforces proper initialization and destruction of \u003ccode\u003epthread\u003c/code\u003e mutexes. \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S5489} enforces unlocking held \u003ccode\u003epthread\u003c/code\u003e mutexes in reverse order. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e The Open Group - \u003ca href\u003d\"https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_mutex_init.html\"\u003e\u003ccode\u003epthread_mutex_init\u003c/code\u003e,\n  \u003ccode\u003epthread_mutex_destroy\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e The Open Group - \u003ca href\u003d\"https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_mutex_lock.html\"\u003e\u003ccode\u003epthread_mutex_lock\u003c/code\u003e,\n  \u003ccode\u003epthread_mutex_unlock\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003e\u003ccode\u003epthread_mutex_t\u003c/code\u003e should not be locked when already locked, or unlocked when already unlocked.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cem\u003eMutexes\u003c/em\u003e are synchronization primitives that allow to manage concurrency. This is the most fundamental building block for creating\n\u003cem\u003esafe\u003c/em\u003e concurrent applications. By using a \u003cem\u003emutex\u003c/em\u003e, one can ensure that a block of code is executed by a single thread concurrently.\nData structures are designed to maintain their invariants between member-function calls. If a data structure is accessed concurrently, and one of the\naccesses is a write operation, then it has a \u003cem\u003edata race\u003c/em\u003e. Having \u003cem\u003edata races\u003c/em\u003e is \u003cem\u003eundefined behavior\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eAdversaries actively exploit \u003cem\u003edata races\u003c/em\u003e to take over systems, but \u003cem\u003edata races\u003c/em\u003e are also a common source of \u003cem\u003edata corruption\u003c/em\u003e\nin concurrent applications resulting in dormant and hard-to-find bugs.\u003c/p\u003e\n\u003cp\u003eTo prevent \u003cem\u003edata races\u003c/em\u003e, the shared resource (usually memory) must be protected by obtaining mutual access to the data during both reading\nand writing. Such mutual exclusion is generally achieved by using a \u003cem\u003emutex\u003c/em\u003e, which is frequently referred to as a \u003cem\u003elock\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eA \u003cem\u003emutex\u003c/em\u003e has two states: \u003cem\u003ereleased\u003c/em\u003e - which is the initial state, or \u003cem\u003eacquired\u003c/em\u003e. These two states are frequently called\n\u003cem\u003eunlocked\u003c/em\u003e and \u003cem\u003elocked\u003c/em\u003e as well.\u003c/p\u003e\n\u003cp\u003eTo effectively protect the shared resource from concurrent accesses, all such accesses should be guarded by the same \u003cem\u003emutex\u003c/em\u003e. They need to\n\u003cem\u003elock\u003c/em\u003e the \u003cem\u003emutex\u003c/em\u003e to gain \u003cem\u003esafe\u003c/em\u003e exclusive access to the resource and \u003cem\u003eunlock\u003c/em\u003e it after they are done mutating or reading\nit.\u003c/p\u003e\n\u003cp\u003eYou can abstract away the concurrent threads sharing the mutex and think of it as owned by the current thread. It never spontaneously changes\nbetween \u003cem\u003eacquired\u003c/em\u003e and \u003cem\u003ereleased\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eIn this view, these are the possible transitions when calling \u003ccode\u003elock\u003c/code\u003e or \u003ccode\u003eunlock\u003c/code\u003e on a \u003cem\u003emutex\u003c/em\u003e in a given state:\u003c/p\u003e\n\u003col\u003e\n  \u003cli\u003e \u003cem\u003ereleased\u003c/em\u003e + \u003ccode\u003elock()\u003c/code\u003e ⇒ \u003cem\u003eacquired\u003c/em\u003e \u003c/li\u003e\n  \u003cli\u003e \u003cem\u003eacquired\u003c/em\u003e + \u003ccode\u003eunlock()\u003c/code\u003e ⇒ \u003cem\u003ereleased\u003c/em\u003e \u003c/li\u003e\n  \u003cli\u003e \u003cem\u003eacquired\u003c/em\u003e + \u003ccode\u003elock()\u003c/code\u003e ⇒ \u003cem\u003edeadlock\u003c/em\u003e \u003c/li\u003e\n  \u003cli\u003e \u003cem\u003ereleased\u003c/em\u003e + \u003ccode\u003eunlock()\u003c/code\u003e ⇒ \u003cem\u003eundefined behavior\u003c/em\u003e \u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eWhen a thread locks a mutex, another thread trying to \u003cem\u003eacquire\u003c/em\u003e the same mutex will be \u003cem\u003eblocked\u003c/em\u003e and have to wait for the first\nthread to \u003cem\u003erelease\u003c/em\u003e it. This waiting period can take some time. If a thread attempts to lock a mutex it has already acquired, it will\n\u003cem\u003edeadlock\u003c/em\u003e because it would need to release it to lock it again.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eLocking an \u003cem\u003eacquired\u003c/em\u003e mutex leads to a \u003cem\u003edeadlock\u003c/em\u003e, as a mutex can only be obtained once. Unlocking a \u003cem\u003ereleased\u003c/em\u003e mutex is\n\u003cem\u003eundefined behavior\u003c/em\u003e. Removing synchronization can cause \u003cem\u003edata races\u003c/em\u003e, leading to \u003cem\u003edata corruption\u003c/em\u003e, which adversaries might\nleverage to take over the system.\u003c/p\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThere are \u003cem\u003erecursive mutexes\u003c/em\u003e that can be \u003cem\u003eacquired\u003c/em\u003e multiple times by the same thread, given that just as many times we also\n\u003cem\u003erelease\u003c/em\u003e the \u003cem\u003emutex\u003c/em\u003e. They are rare in practice and usually signal design problems in the code. Thus we assume\n\u003ccode\u003epthread_mutex_t\u003c/code\u003e refers to \u003cem\u003enon-recursive\u003c/em\u003e mutexes.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eNever lock an \u003cem\u003eacquired\u003c/em\u003e mutex. Lock the mutexes in a strict order that is followed throughout the project. Unlock operations should be done\nthe same way but in reversed order.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;pthread.h\u0026gt;\n\npthread_mutex_t m1 \u003d PTHREAD_MUTEX_INITIALIZER;\npthread_mutex_t m2 \u003d PTHREAD_MUTEX_INITIALIZER;\n\nvoid locks() {\n  pthread_mutex_lock(\u0026amp;m1);\n  pthread_mutex_lock(\u0026amp;m1); // Noncompliant: \u0027m1\u0027 is already acquired\n}\n\nvoid unlocks() {\n  pthread_mutex_unlock(\u0026amp;m1);\n  pthread_mutex_unlock(\u0026amp;m1); // Noncompliant: \u0027m1\u0027 is already released\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;pthread.h\u0026gt;\n\npthread_mutex_t m1 \u003d PTHREAD_MUTEX_INITIALIZER;\npthread_mutex_t m2 \u003d PTHREAD_MUTEX_INITIALIZER;\n\nvoid locks() {\n  pthread_mutex_lock(\u0026amp;m1);\n  pthread_mutex_lock(\u0026amp;m2); // Compliant: we acquired both \u0027m1\u0027 and \u0027m2\u0027 for the first time.\n}\n\nvoid unlocks() {\n  pthread_mutex_unlock(\u0026amp;m2);\n  pthread_mutex_unlock(\u0026amp;m1); // Compliant: we released both \u0027m1\u0027 and \u0027m2\u0027 for the first time.\n}\n\u003c/pre\u003e\n\u003ch3\u003ePitfalls\u003c/h3\u003e\n\u003cp\u003eCalling arbitrary functions while holding a lock should be avoided, as the function might also want to lock the resource we already acquired,\ncausing a deadlock. One particular example of such functions is callbacks.\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;pthread.h\u0026gt;\n\npthread_mutex_t m \u003d PTHREAD_MUTEX_INITIALIZER;\n\nvoid handle_callback(void (*callback)(void)) {\n  pthread_mutex_lock(\u0026amp;m);\n  callback(); // If tries to lock mutex \u0027m\u0027, then we have a deadlock.\n  pthread_mutex_unlock(\u0026amp;m);\n}\n\u003c/pre\u003e\n\u003ch3\u003eGoing the extra mile\u003c/h3\u003e\n\u003cp\u003eThe section of code for which the \u003cem\u003emutex\u003c/em\u003e is \u003cem\u003eacquired\u003c/em\u003e is called the \u003cem\u003ecritical section\u003c/em\u003e. Inside the \u003cem\u003ecritical\nsection\u003c/em\u003e, we are the only ones with access to the shared resource. Thus we are free to mutate or read it without considering what other threads\nare doing concurrently. However, having large \u003cem\u003ecritical sections\u003c/em\u003e can prevent other threads from making progress if they want to also\n\u003cem\u003eacquire\u003c/em\u003e the same \u003cem\u003emutex\u003c/em\u003e and access the shared resource. Consequently, \u003cem\u003ecritical sections\u003c/em\u003e are supposed to be as small as\npossible.\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;pthread.h\u0026gt;\n#include \u0026lt;stdbool.h\u0026gt;\n\nint input;\nint result;\nbool isFib;\n\n// Guards both \u0027num1\u0027 and \u0027num2\u0027.\npthread_mutex_t m \u003d PTHREAD_MUTEX_INITIALIZER;\n\nint fibonacci(int n);\nint factorial(int n);\n\nvoid locks(bool calcFib, int n) {\n  // Do the calculations without taking the lock.\n  int res;\n  if (calcFib) {\n    res \u003d fibonacci(n);\n  } else {\n    res \u003d factorial(n);\n  }\n\n  pthread_mutex_lock(\u0026amp;m);\n  // Critical section starts\n  input \u003d n;\n  result \u003d res;\n  isFib \u003d calcFib;\n  // Critical section ends.\n  pthread_mutex_unlock(\u0026amp;m);\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/764\"\u003e764 Multiple Locks of a Critical Resource\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/362\"\u003e362 Multiple Concurrent Execution using Shared Resource with Improper\n  Synchronization (\u0027Race Condition\u0027)\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S5487} enforces proper initialization and destruction of \u003ccode\u003epthread\u003c/code\u003e mutexes. \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S5489} enforces unlocking held \u003ccode\u003epthread\u003c/code\u003e mutexes in reverse order. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e The Open Group - \u003ca href\u003d\"https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_mutex_init.html\"\u003e\u003ccode\u003epthread_mutex_init\u003c/code\u003e,\n  \u003ccode\u003epthread_mutex_destroy\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e The Open Group - \u003ca href\u003d\"https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_mutex_lock.html\"\u003e\u003ccode\u003epthread_mutex_lock\u003c/code\u003e,\n  \u003ccode\u003epthread_mutex_unlock\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cwe",
      "multi-threading",
      "symbolic-execution"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5487",
    "name": "\"pthread_mutex_t\" should be properly initialized and destroyed",
    "defaultSeverity": "BLOCKER",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003cp\u003eFailing to properly initialize or destroy a \u003ccode\u003epthread\u003c/code\u003e mutex can lead to undefined behavior.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cem\u003eMutexes\u003c/em\u003e are synchronization primitives that allow managing concurrency.\u003c/p\u003e\n\u003cp\u003eTheir use requires following a well-defined life cycle:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003cem\u003eMutexes\u003c/em\u003e need to be initialized (using \u003ccode\u003epthread_mutex_init\u003c/code\u003e) before being used. Once it is initialized, a \u003cem\u003emutex\u003c/em\u003e is\n  in an \u003cem\u003eunlocked\u003c/em\u003e state. \u003c/li\u003e\n  \u003cli\u003e \u003cem\u003eMutexes\u003c/em\u003e need to be destroyed (using \u003ccode\u003epthread_mutex_destroy\u003c/code\u003e) to free the associated internal resources. Only\n  \u003cem\u003eunlocked\u003c/em\u003e \u003cem\u003emutexes\u003c/em\u003e can be safely destroyed. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eBefore initialization and after destruction, a mutex is in an uninitialized state.\u003c/p\u003e\n\u003cp\u003eDuring a \u003cem\u003emutex\u003c/em\u003e\u0027 life cycle, the following patterns should be avoided as they result in undefined behavior:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e trying to initialize an already initialized \u003cem\u003emutex\u003c/em\u003e \u003c/li\u003e\n  \u003cli\u003e trying to destroy an initialized \u003cem\u003emutex\u003c/em\u003e that is in a \u003cem\u003elocked\u003c/em\u003e state \u003c/li\u003e\n  \u003cli\u003e trying to destroy an uninitialized \u003cem\u003emutex\u003c/em\u003e \u003c/li\u003e\n  \u003cli\u003e trying to lock an uninitialized \u003cem\u003emutex\u003c/em\u003e \u003c/li\u003e\n  \u003cli\u003e trying to unlock an uninitialized \u003cem\u003emutex\u003c/em\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn C++11 and higher, \u003ccode\u003estd::mutex\u003c/code\u003e is less error-prone and is supported by more platforms.\u003c/p\u003e\n\u003cp\u003eIn C++03, it is recommended to wrap mutex creation/destruction in an RAII class, as well as mutex lock/unlock. Those RAII classes will perform the\nright operations, even in the presence of exceptions.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eFailing to properly initialize or destroy a POSIX Thread Mutex leads to \u003cstrong\u003eundefined behavior\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eFor programs that exercise undefined behavior, the compiler is no longer bound by the language specification. The application may crash or, even\nworse, the application may appear to execute correctly while losing data or producing incorrect results. In a multi-threaded context, additionally,\nthe application may experience spurious deadlocks or data races.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eEnsure that all mutexes follow the well-defined life cycle.\u003c/p\u003e\n\u003cp\u003eIf C++11 (or higher) is available, use \u003ccode\u003estd::mutex\u003c/code\u003e and \u003ccode\u003estd::lock_guard\u003c/code\u003e, instead, to avoid invalid usage patterns that lead\nto undefined behavior. Depending on the scenario, \u003ccode\u003estd::atomic\u003c/code\u003e may be used as an alternative if only small and primitive data shall be\nmodified in a concurrent context and in a synchronized manner.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre\u003e\n#include \u0026lt;pthread.h\u0026gt;\n\npthread_mutex_t mtx;\n\nvoid double_initialization(void)\n{\n  pthread_mutex_init(\u0026amp;mtx, /*mutex attribute\u003d*/NULL); // Initializes the mutex using an implementation-defined default attribute.\n  pthread_mutex_init(\u0026amp;mtx, /*mutex attribute\u003d*/NULL); // Noncompliant: initializing an already initialized mutex\n}\n\nvoid destroy_locked(void)\n{\n  pthread_mutex_init(\u0026amp;mtx, /*mutex attribute\u003d*/NULL);\n  pthread_mutex_lock(\u0026amp;mtx);\n  pthread_mutex_destroy(\u0026amp;mtx); // Noncompliant: destroying a locked mutex\n}\n\nvoid double_destruction(void)\n{\n  pthread_mutex_init(\u0026amp;mtx, /*mutex attribute\u003d*/NULL);\n  pthread_mutex_destroy(\u0026amp;mtx);\n  pthread_mutex_destroy(\u0026amp;mtx); // Noncompliant: destroying an uninitialized mutex\n}\n\nvoid lock_destroyed(void)\n{\n  pthread_mutex_init(\u0026amp;mtx, /*mutex attribute\u003d*/NULL);\n  pthread_mutex_destroy(\u0026amp;mtx);\n  pthread_mutex_lock(\u0026amp;mtx); // Noncompliant: locking an uninitialized mutex\n}\n\nvoid unlock_destroyed(void)\n{\n  pthread_mutex_init(\u0026amp;mtx, /*mutex attribute\u003d*/NULL);\n  pthread_mutex_destroy(\u0026amp;mtx);\n  pthread_mutex_unlock(\u0026amp;mtx); // Noncompliant: unlocking an uninitialized mutex\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eC solution:\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;pthread.h\u0026gt;\n\npthread_mutex_t mtx;\n\nvoid destroy_initialized(void)\n{\n  pthread_mutex_init(\u0026amp;mtx, /*mutex attribute\u003d*/NULL);\n  pthread_mutex_destroy(\u0026amp;mtx);\n}\n\nvoid use_and_destroy_initialized(void)\n{\n  pthread_mutex_init(\u0026amp;mtx, /*mutex attribute\u003d*/NULL);\n  pthread_mutex_lock(\u0026amp;mtx);\n  // Critical code that processes a shared resource (e.g. memory).\n  pthread_mutex_unlock(\u0026amp;mtx);\n  pthread_mutex_destroy(\u0026amp;mtx);\n}\n\u003c/pre\u003e\n\u003cp\u003eFor static mutex variables:\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;pthread.h\u0026gt;\n\npthread_mutex_t mtx \u003d PTHREAD_MUTEX_INITIALIZER;\n\nvoid use_statically_initialized(void)\n{\n  pthread_mutex_lock(\u0026amp;mtx); // Compliant: mutex is initialized statically\n  // Critical code that processes a shared resource (e.g. memory).\n  pthread_mutex_unlock(\u0026amp;mtx);\n}\n\u003c/pre\u003e\n\u003cp\u003eC++11 and higher solution:\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;mutex\u0026gt;\n#include \u0026lt;stdexcept\u0026gt;\n\nstd::mutex mtx;\n\nvoid use_lock_guard(bool condition) {\n  std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mtx);\n  // Critical code that processes a shared resource (e.g. memory).\n  if (condition) {\n    // Compliant: mutex will unlock automatically even in case of an exception\n    throw std::invalid_argument(\"Expected false\");\n  }\n  // Compliant: mutex will unlock automatically at the end of the scope\n}\n\u003c/pre\u003e\n\u003cp\u003eC++03 solution:\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;pthread.h\u0026gt;\n\npthread_mutex_t mtx;\n\nclass Mutex {\npublic:\n  Mutex(pthread_mutex_t* mtx) : pmtx(mtx) {\n    pthread_mutex_init(pmtx, /*mutex attribute\u003d*/NULL);\n  }\n  ~Mutex() {\n    pthread_mutex_destroy(pmtx);\n  }\n  pthread_mutex_t* pmtx;\nprivate:\n  // Disallow copy operations to avoid double-free issues.\n  Mutex(Mutex const\u0026amp; other);\n  Mutex\u0026amp; operator\u003d(Mutex const\u0026amp; other);\n};\n\nstruct LockGuard {\n  LockGuard(Mutex \u0026amp;m) : mtx(m) {\n    pthread_mutex_lock(mtx.pmtx);\n  }\n  ~LockGuard() {\n    pthread_mutex_unlock(mtx.pmtx);\n  }\n  Mutex \u0026amp;mtx;\n};\n\nvoid destroy_initialized()\n{\n  Mutex m(\u0026amp;mtx);\n  // Compliant: mtx will be properly initialized and destroyed\n}\n\nvoid use_and_destroy_initialized()\n{\n  Mutex m(\u0026amp;mtx);\n  {\n    LockGuard lock(m);\n    // Critical code that processes a shared resource (e.g. memory).\n    // Compliant: mutex will unlock automatically at the end of the scope\n  }\n  // Compliant: mtx will be destroyed properly\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e The Open Group - \u003ca href\u003d\"https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_mutex_init.html\"\u003e\u003ccode\u003epthread_mutex_init\u003c/code\u003e,\n  \u003ccode\u003epthread_mutex_destroy\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/atomic/atomic\"\u003e\u003ccode\u003estd::atomic\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/thread/lock_guard\"\u003e\u003ccode\u003estd::lock_guard\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/thread/mutex\"\u003e\u003ccode\u003estd::mutex\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eConference presentations\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CppCon 2020 - \u003ca href\u003d\"https://youtu.be/A7sVFJLJM-A?si\u003dv76jhmv3XnHExZYU\"\u003eAn Introduction to Multithreading in C++20\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S5486} enforces the proper locking and unlocking of \u003ccode\u003epthread\u003c/code\u003e mutexes. \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S5489} enforces unlocking multiple held \u003ccode\u003epthread\u003c/code\u003e mutexes in reverse order. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eFailing to properly initialize or destroy a \u003ccode\u003epthread\u003c/code\u003e mutex can lead to undefined behavior.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cem\u003eMutexes\u003c/em\u003e are synchronization primitives that allow managing concurrency.\u003c/p\u003e\n\u003cp\u003eTheir use requires following a well-defined life cycle:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003cem\u003eMutexes\u003c/em\u003e need to be initialized (using \u003ccode\u003epthread_mutex_init\u003c/code\u003e) before being used. Once it is initialized, a \u003cem\u003emutex\u003c/em\u003e is\n  in an \u003cem\u003eunlocked\u003c/em\u003e state. \u003c/li\u003e\n  \u003cli\u003e \u003cem\u003eMutexes\u003c/em\u003e need to be destroyed (using \u003ccode\u003epthread_mutex_destroy\u003c/code\u003e) to free the associated internal resources. Only\n  \u003cem\u003eunlocked\u003c/em\u003e \u003cem\u003emutexes\u003c/em\u003e can be safely destroyed. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eBefore initialization and after destruction, a mutex is in an uninitialized state.\u003c/p\u003e\n\u003cp\u003eDuring a \u003cem\u003emutex\u003c/em\u003e\u0027 life cycle, the following patterns should be avoided as they result in undefined behavior:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e trying to initialize an already initialized \u003cem\u003emutex\u003c/em\u003e \u003c/li\u003e\n  \u003cli\u003e trying to destroy an initialized \u003cem\u003emutex\u003c/em\u003e that is in a \u003cem\u003elocked\u003c/em\u003e state \u003c/li\u003e\n  \u003cli\u003e trying to destroy an uninitialized \u003cem\u003emutex\u003c/em\u003e \u003c/li\u003e\n  \u003cli\u003e trying to lock an uninitialized \u003cem\u003emutex\u003c/em\u003e \u003c/li\u003e\n  \u003cli\u003e trying to unlock an uninitialized \u003cem\u003emutex\u003c/em\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn C++11 and higher, \u003ccode\u003estd::mutex\u003c/code\u003e is less error-prone and is supported by more platforms.\u003c/p\u003e\n\u003cp\u003eIn C++03, it is recommended to wrap mutex creation/destruction in an RAII class, as well as mutex lock/unlock. Those RAII classes will perform the\nright operations, even in the presence of exceptions.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eFailing to properly initialize or destroy a POSIX Thread Mutex leads to \u003cstrong\u003eundefined behavior\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eFor programs that exercise undefined behavior, the compiler is no longer bound by the language specification. The application may crash or, even\nworse, the application may appear to execute correctly while losing data or producing incorrect results. In a multi-threaded context, additionally,\nthe application may experience spurious deadlocks or data races.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eEnsure that all mutexes follow the well-defined life cycle.\u003c/p\u003e\n\u003cp\u003eIf C++11 (or higher) is available, use \u003ccode\u003estd::mutex\u003c/code\u003e and \u003ccode\u003estd::lock_guard\u003c/code\u003e, instead, to avoid invalid usage patterns that lead\nto undefined behavior. Depending on the scenario, \u003ccode\u003estd::atomic\u003c/code\u003e may be used as an alternative if only small and primitive data shall be\nmodified in a concurrent context and in a synchronized manner.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre\u003e\n#include \u0026lt;pthread.h\u0026gt;\n\npthread_mutex_t mtx;\n\nvoid double_initialization(void)\n{\n  pthread_mutex_init(\u0026amp;mtx, /*mutex attribute\u003d*/NULL); // Initializes the mutex using an implementation-defined default attribute.\n  pthread_mutex_init(\u0026amp;mtx, /*mutex attribute\u003d*/NULL); // Noncompliant: initializing an already initialized mutex\n}\n\nvoid destroy_locked(void)\n{\n  pthread_mutex_init(\u0026amp;mtx, /*mutex attribute\u003d*/NULL);\n  pthread_mutex_lock(\u0026amp;mtx);\n  pthread_mutex_destroy(\u0026amp;mtx); // Noncompliant: destroying a locked mutex\n}\n\nvoid double_destruction(void)\n{\n  pthread_mutex_init(\u0026amp;mtx, /*mutex attribute\u003d*/NULL);\n  pthread_mutex_destroy(\u0026amp;mtx);\n  pthread_mutex_destroy(\u0026amp;mtx); // Noncompliant: destroying an uninitialized mutex\n}\n\nvoid lock_destroyed(void)\n{\n  pthread_mutex_init(\u0026amp;mtx, /*mutex attribute\u003d*/NULL);\n  pthread_mutex_destroy(\u0026amp;mtx);\n  pthread_mutex_lock(\u0026amp;mtx); // Noncompliant: locking an uninitialized mutex\n}\n\nvoid unlock_destroyed(void)\n{\n  pthread_mutex_init(\u0026amp;mtx, /*mutex attribute\u003d*/NULL);\n  pthread_mutex_destroy(\u0026amp;mtx);\n  pthread_mutex_unlock(\u0026amp;mtx); // Noncompliant: unlocking an uninitialized mutex\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eC solution:\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;pthread.h\u0026gt;\n\npthread_mutex_t mtx;\n\nvoid destroy_initialized(void)\n{\n  pthread_mutex_init(\u0026amp;mtx, /*mutex attribute\u003d*/NULL);\n  pthread_mutex_destroy(\u0026amp;mtx);\n}\n\nvoid use_and_destroy_initialized(void)\n{\n  pthread_mutex_init(\u0026amp;mtx, /*mutex attribute\u003d*/NULL);\n  pthread_mutex_lock(\u0026amp;mtx);\n  // Critical code that processes a shared resource (e.g. memory).\n  pthread_mutex_unlock(\u0026amp;mtx);\n  pthread_mutex_destroy(\u0026amp;mtx);\n}\n\u003c/pre\u003e\n\u003cp\u003eFor static mutex variables:\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;pthread.h\u0026gt;\n\npthread_mutex_t mtx \u003d PTHREAD_MUTEX_INITIALIZER;\n\nvoid use_statically_initialized(void)\n{\n  pthread_mutex_lock(\u0026amp;mtx); // Compliant: mutex is initialized statically\n  // Critical code that processes a shared resource (e.g. memory).\n  pthread_mutex_unlock(\u0026amp;mtx);\n}\n\u003c/pre\u003e\n\u003cp\u003eC++11 and higher solution:\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;mutex\u0026gt;\n#include \u0026lt;stdexcept\u0026gt;\n\nstd::mutex mtx;\n\nvoid use_lock_guard(bool condition) {\n  std::lock_guard\u0026lt;std::mutex\u0026gt; lock(mtx);\n  // Critical code that processes a shared resource (e.g. memory).\n  if (condition) {\n    // Compliant: mutex will unlock automatically even in case of an exception\n    throw std::invalid_argument(\"Expected false\");\n  }\n  // Compliant: mutex will unlock automatically at the end of the scope\n}\n\u003c/pre\u003e\n\u003cp\u003eC++03 solution:\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;pthread.h\u0026gt;\n\npthread_mutex_t mtx;\n\nclass Mutex {\npublic:\n  Mutex(pthread_mutex_t* mtx) : pmtx(mtx) {\n    pthread_mutex_init(pmtx, /*mutex attribute\u003d*/NULL);\n  }\n  ~Mutex() {\n    pthread_mutex_destroy(pmtx);\n  }\n  pthread_mutex_t* pmtx;\nprivate:\n  // Disallow copy operations to avoid double-free issues.\n  Mutex(Mutex const\u0026amp; other);\n  Mutex\u0026amp; operator\u003d(Mutex const\u0026amp; other);\n};\n\nstruct LockGuard {\n  LockGuard(Mutex \u0026amp;m) : mtx(m) {\n    pthread_mutex_lock(mtx.pmtx);\n  }\n  ~LockGuard() {\n    pthread_mutex_unlock(mtx.pmtx);\n  }\n  Mutex \u0026amp;mtx;\n};\n\nvoid destroy_initialized()\n{\n  Mutex m(\u0026amp;mtx);\n  // Compliant: mtx will be properly initialized and destroyed\n}\n\nvoid use_and_destroy_initialized()\n{\n  Mutex m(\u0026amp;mtx);\n  {\n    LockGuard lock(m);\n    // Critical code that processes a shared resource (e.g. memory).\n    // Compliant: mutex will unlock automatically at the end of the scope\n  }\n  // Compliant: mtx will be destroyed properly\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e The Open Group - \u003ca href\u003d\"https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_mutex_init.html\"\u003e\u003ccode\u003epthread_mutex_init\u003c/code\u003e,\n  \u003ccode\u003epthread_mutex_destroy\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/atomic/atomic\"\u003e\u003ccode\u003estd::atomic\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/thread/lock_guard\"\u003e\u003ccode\u003estd::lock_guard\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/thread/mutex\"\u003e\u003ccode\u003estd::mutex\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eConference presentations\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CppCon 2020 - \u003ca href\u003d\"https://youtu.be/A7sVFJLJM-A?si\u003dv76jhmv3XnHExZYU\"\u003eAn Introduction to Multithreading in C++20\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S5486} enforces the proper locking and unlocking of \u003ccode\u003epthread\u003c/code\u003e mutexes. \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S5489} enforces unlocking multiple held \u003ccode\u003epthread\u003c/code\u003e mutexes in reverse order. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "multi-threading",
      "symbolic-execution"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5008",
    "name": "\"void *\" should not be used in typedefs, member variables, function parameters or return type",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003evoid*\u003c/code\u003e is a pointer to memory of unknown type, and therefore works outside of the safety net provided by the type system. While it can\nbe useful in a function body to interface with external code, there is no good reason to step out of the robust C++ type system when defining a\nfunction, either for the function parameters, or for the function return type. For the same reasons, having a member variable of type\n\u003ccode\u003evoid*\u003c/code\u003e is not recommended.\u003c/p\u003e\n\u003cp\u003eIf you want to work with raw memory buffer, use \u003ccode\u003eunsigned char *\u003c/code\u003e (or \u003ccode\u003ebyte *\u003c/code\u003e if your compiler supports it).\u003c/p\u003e\n\u003cp\u003eIf you want to work with different types of data, define a function template and use typed pointers, instead of \u003ccode\u003evoid *\u003c/code\u003e. If you want a\nsingle object to be able to stores objects of different types, \u003ccode\u003estd::any\u003c/code\u003e can also be a type-safe alternative to \u003ccode\u003evoid*\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eIf you want to provide to users of an API an opaque type, declare a type and don’t provide its definition (like with \u003ccode\u003eFILE*\u003c/code\u003e).\u003c/p\u003e\n\u003cp\u003eNote that \u003ccode\u003evoid*\u003c/code\u003e is commonly used to communicate data of unknown type with C code. This rule will nevertheless raise an issue in this\ncase, but it can be ignored.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid saveBuffer(void *buffer, size_t size); // Noncompliant\nvoid duplicate(void* destination, size_t count, void *source, size_t size); // Noncompliant\nclass Process {\n  // ...\n  void *userData;\n};\nusing UserData \u003d void*; // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid saveBuffer(unsigned char *buffer, size_t size);\ntemplate\u0026lt;class T\u0026gt;\nvoid duplicate(T* destination, size_t count, T *source);\nclass Process {\n  // ...\n  std::any userData;\n};\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003evoid*\u003c/code\u003e can be useful when interfacing with C. As such, the rule will ignore \u003ccode\u003eextern \"C\"\u003c/code\u003e functions, as well as types with\nstandard layout.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#i4-make-interfaces-precisely-and-strongly-typed\"\u003eI.4: Make\n  interfaces precisely and strongly typed\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#t3-use-templates-to-express-containers-and-ranges\"\u003eT.3: Use\n  templates to express containers and ranges\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003ccode\u003evoid*\u003c/code\u003e is a pointer to memory of unknown type, and therefore works outside of the safety net provided by the type system. While it can\nbe useful in a function body to interface with external code, there is no good reason to step out of the robust C++ type system when defining a\nfunction, either for the function parameters, or for the function return type. For the same reasons, having a member variable of type\n\u003ccode\u003evoid*\u003c/code\u003e is not recommended.\u003c/p\u003e\n\u003cp\u003eIf you want to work with raw memory buffer, use \u003ccode\u003eunsigned char *\u003c/code\u003e (or \u003ccode\u003ebyte *\u003c/code\u003e if your compiler supports it).\u003c/p\u003e\n\u003cp\u003eIf you want to work with different types of data, define a function template and use typed pointers, instead of \u003ccode\u003evoid *\u003c/code\u003e. If you want a\nsingle object to be able to stores objects of different types, \u003ccode\u003estd::any\u003c/code\u003e can also be a type-safe alternative to \u003ccode\u003evoid*\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eIf you want to provide to users of an API an opaque type, declare a type and don’t provide its definition (like with \u003ccode\u003eFILE*\u003c/code\u003e).\u003c/p\u003e\n\u003cp\u003eNote that \u003ccode\u003evoid*\u003c/code\u003e is commonly used to communicate data of unknown type with C code. This rule will nevertheless raise an issue in this\ncase, but it can be ignored.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid saveBuffer(void *buffer, size_t size); // Noncompliant\nvoid duplicate(void* destination, size_t count, void *source, size_t size); // Noncompliant\nclass Process {\n  // ...\n  void *userData;\n};\nusing UserData \u003d void*; // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid saveBuffer(unsigned char *buffer, size_t size);\ntemplate\u0026lt;class T\u0026gt;\nvoid duplicate(T* destination, size_t count, T *source);\nclass Process {\n  // ...\n  std::any userData;\n};\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003evoid*\u003c/code\u003e can be useful when interfacing with C. As such, the rule will ignore \u003ccode\u003eextern \"C\"\u003c/code\u003e functions, as well as types with\nstandard layout.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#i4-make-interfaces-precisely-and-strongly-typed\"\u003eI.4: Make\n  interfaces precisely and strongly typed\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#t3-use-templates-to-express-containers-and-ranges\"\u003eT.3: Use\n  templates to express containers and ranges\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "cppcoreguidelines"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6458",
    "name": "Perfect forwarding constructors should be constrained",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cem\u003eForwarding references\u003c/em\u003e (also known as \u003cem\u003euniversal references\u003c/em\u003e) provide the ability to write a template that can deduce and accept any\nkind of reference to the object (\u003cem\u003ervalue\u003c/em\u003e/\u003cem\u003elvalue\u003c/em\u003e \u003cem\u003emutable\u003c/em\u003e/\u003cem\u003econst\u003c/em\u003e). This enables the creation of a perfect forwarding\nconstructor for wrapper types: the constructor arguments are forwarded to build the underlying type:\u003c/p\u003e\n\u003cpre\u003e\nclass Wrapper {\npublic:\n  // A defaulted copy constructor\n  Wrapper(Wrapper const\u0026amp; other) \u003d default;\n\n  template \u0026lt;typename T\u0026gt;\n  Wrapper(T\u0026amp;\u0026amp; str)  // A noncompliant forwarding constructor\n    : str(std::forward\u0026lt;T\u0026gt;(str)) {}\n\nprivate:\n  std::string str;\n};\n\u003c/pre\u003e\n\u003cp\u003eHowever, this constructor is too greedy: overload resolution prefers it over the copy constructor as soon as the argument type is slightly\ndifferent from a \u003ccode\u003eWrapper const\u0026amp;\u003c/code\u003e. For instance, when passing a non-const \u003cem\u003elvalue\u003c/em\u003e (\u003ccode\u003ew\u003c/code\u003e in the following example),\ncalling the copy constructor requires a non-const to const conversion, while the forwarding reference parameter is an exact match, and will therefore\nbe selected. This is usually not the expected behavior.\u003c/p\u003e\n\u003cpre\u003e\nWrapper const cw(\"str1\");\nWrapper w(\"str2\");\n\nWrapper w1(cw);  // Ok: calls Wrapper(Wrapper const\u0026amp; other)\nWrapper w2(w);   // Ill-formed: calls Wrapper(T\u0026amp;\u0026amp; str) with [T \u003d Wrapper\u0026amp;]\n                 // This tries to initialize a std::string using a Wrapper object\n\u003c/pre\u003e\n\u003cp\u003eThis rule specifically targets constructors that can be called with a single \u003cem\u003eforwarding reference\u003c/em\u003e argument. In such cases, they compete\nwith copy or move constructors, including those implicitly generated by the compiler. Yet, selecting the wrong overload can also happen with\nforwarding references on regular functions and methods, but this is out of scope for this rule.\u003c/p\u003e\n\u003cp\u003eEven if the non-constrained forwarding constructor may currently seem to work fine, using it with different value categories in the future could\nresult in unexpected compilation errors or, even worse, hard-to-debug run-time behavior if the wrapped type happens to be constructible from instances\nof the wrapper.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eThe rule reports forwarding constructors without proper constraints if they can be called with a single argument. To eliminate this pitfall, add\nconstraints to such constructors so that they are not considered an overload candidate when the argument is a reference to the class itself. This can\nbe achieved by adding any of the following checks to the forwarding reference constructor:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e a check of the concept \u003ccode\u003e!std::same_as\u0026lt;std::remove_cvref_t\u0026lt;U\u0026gt;, Wrapper\u0026gt;\u003c/code\u003e, or \u003c/li\u003e\n  \u003cli\u003e a check of type predicate \u003ccode\u003e!std::is_same_v\u0026lt;std::remove_cvref_t\u0026lt;U\u0026gt;, Wrapper\u0026gt;\u003c/code\u003e, or \u003c/li\u003e\n  \u003cli\u003e an \u003ccode\u003estd::enable_if\u003c/code\u003e with the equivalent condition. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eNote that special care has to be taken when \u003ccode\u003eWrapper\u003c/code\u003e is a base class. This is explained in more detail in \"Going the extra mile\" below.\nIn this case, those checks would become:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e the concept \u003ccode\u003e!std::derived_from\u0026lt;std::remove_cvref_t\u0026lt;U\u0026gt;, Wrapper\u0026gt;\u003c/code\u003e, or \u003c/li\u003e\n  \u003cli\u003e a type-predicate \u003ccode\u003e!std::is_base_of_v\u0026lt;Wrapper, std::remove_cvref_t\u0026lt;U\u0026gt;\u0026gt;\u003c/code\u003e, or \u003c/li\u003e\n  \u003cli\u003e an \u003ccode\u003estd::enable_if\u003c/code\u003e with the equivalent condition. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe concept-based solutions require C++20. The \u003ccode\u003estd::enable_if\u003c/code\u003e solution is more cumbersome to write but can always be used.\u003c/p\u003e\n\u003cp\u003eNote that there are other ways to constrain such a constructor, but this rule only recognizes the explicit checks described above as compliant.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cp\u003eIn this noncompliant example, the implicitly compiler-generated copy constructor can receive calls only when copying non-const lvalues (i.e., exact\nmatches). Otherwise, the forwarding constructor is used, even when the given type can not be used to initialize the wrapped \u003ccode\u003estd::string\u003c/code\u003e\nobject.\u003c/p\u003e\n\u003cpre\u003e\nclass Wrapper {\npublic:\n  template \u0026lt;typename T\u0026gt;\n  Wrapper(T\u0026amp;\u0026amp; str)  // Noncompliant: competes with compiler-generated copy constructor\n    : str(std::forward\u0026lt;T\u0026gt;(str)) {}\n\nprivate:\n  std::string str;\n};\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eWe fix the problem by adding a constraint to our forwarding constructor. This enables the copy constructor to receive calls again by excluding the\nforwarding constructor when the deduced \u003ccode\u003eT\u003c/code\u003e is \u003ccode\u003eWrapper\u003c/code\u003e (after discarding references and const-volatile qualifiers).\u003c/p\u003e\n\u003cpre\u003e\nclass Wrapper {\npublic:\n  template \u0026lt;typename T\u0026gt;\n  requires (!std::same_as\u0026lt;Wrapper, std::remove_cvref_t\u0026lt;T\u0026gt;\u0026gt;)\n  Wrapper(T\u0026amp;\u0026amp; str)  // Compliant: no longer competes with the copy constructor\n    : str(std::forward\u0026lt;T\u0026gt;(str)) {}\n\nprivate:\n  std::string str;\n};\n\u003c/pre\u003e\n\u003cp\u003eIf C++20 is not available, we can use \u003ccode\u003estd::enable_if\u003c/code\u003e instead of concepts. We also can not use \u003ccode\u003estd::remove_cvref_t\u003c/code\u003e, and we\nhave to be more verbose:\u003c/p\u003e\n\u003cpre\u003e\n// Define our own remove_cvref_t for use in C++11\ntemplate \u0026lt;typename T\u0026gt;\nusing remove_cvref_t \u003d typename std::remove_cv\u0026lt;typename std::remove_reference\u0026lt;T\u0026gt;::type\u0026gt;::type;\n\nclass Wrapper {\npublic:\n  template \u0026lt;\n    typename T,\n    typename std::enable_if\u0026lt;\n      !std::is_same\u0026lt;Wrapper, remove_cvref_t\u0026lt;T\u0026gt;\u0026gt;::value, int\u0026gt;::type /* Unnamed */ \u003d 0\u0026gt;\n  Wrapper(T\u0026amp;\u0026amp; str)  // Compliant: no longer competes with the copy constructor\n    : str(std::forward\u0026lt;T\u0026gt;(str)) {}\n\nprivate:\n  std::string str;\n};\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cp\u003eThis noncompliant example demonstrates a bad attempt at constraining a forwarding constructor in a template wrapper:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\ntemplate\u0026lt;typename T\u0026gt;\nclass TemplateWrapper {\npublic:\n  TemplateWrapper(TemplateWrapper const\u0026amp; other) \u003d default;\n\n  template\u0026lt;typename U\u0026gt;\n    requires std::constructible_from\u0026lt;T, U\u0026gt;\n  TemplateWrapper(U\u0026amp;\u0026amp; u) // Noncompliant: constructible_from check is not sufficient in general\n    : value(std::forward\u0026lt;U\u0026gt;(u))\n  {}\n\nprivate:\n  T value;\n};\n\u003c/pre\u003e\n\u003cp\u003eThe problem with this constraint is that it depends on how the type \u003ccode\u003eT\u003c/code\u003e can be constructed; For example, it can yield unexpected results\nif \u003ccode\u003eT\u003c/code\u003e itself has a forwarding constructor.\u003c/p\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eIn order to properly make our \u003ccode\u003eTemplateWrapper\u003c/code\u003e generic, we need to add the necessary constraint alongside\n\u003ccode\u003estd::constructible_from\u003c/code\u003e:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\ntemplate\u0026lt;typename T\u0026gt;\nclass TemplateWrapper {\npublic:\n  TemplateWrapper(TemplateWrapper const\u0026amp; other) \u003d default;\n\n  template\u0026lt;typename U\u0026gt;\n    requires (!std::derived_from\u0026lt;std::remove_cvref_t\u0026lt;U\u0026gt;, TemplateWrapper\u0026gt; \u0026amp;\u0026amp; std::constructible_from\u0026lt;T, U\u0026gt;)\n  TemplateWrapper(U\u0026amp;\u0026amp; u)  // Compliant: properly constrained regardless of how T can be constructed\n    : value(std::forward\u0026lt;U\u0026gt;(u))\n  {}\n\nprivate:\n  T value;\n};\n\u003c/pre\u003e\n\u003cp\u003eUsing \u003ccode\u003estd::derived_from\u003c/code\u003e instead of \u003ccode\u003estd::same_as\u003c/code\u003e is only meant for demonstration purposes here.\n\u003ccode\u003estd::derived_from\u003c/code\u003e is necessary only if \u003ccode\u003eTemplateWrapper\u003c/code\u003e has derived classes, to ensure that the copy constructors of these\nderived classes don’t end up calling the forwarding constructor. This is explained in more detail in the \"Going the extra mile\" section below.\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cp\u003eIn this noncompliant example, the forwarding constructor accepts a parameter pack and uses it to initialize the wrapped type. This can still\ncompete with the copy constructor when called with a single argument. Using \u003ccode\u003estd::constructible_from\u003c/code\u003e is not sufficient for the same\nreasons as the previous example.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\ntemplate\u0026lt;typename T\u0026gt;\nclass EmplaceWrapper {\npublic:\n  EmplaceWrapper(EmplaceWrapper const\u0026amp; other) \u003d default;\n\n  template\u0026lt;typename... Args\u0026gt;\n    requires std::constructible_from\u0026lt;T, Args...\u0026gt;\n  EmplaceWrapper(Args\u0026amp;\u0026amp;... args) // Noncompliant: will compete with copy-constructor\n    : value(std::forward\u0026lt;Args\u0026gt;(args)...)\n  {}\n\nprivate:\n  T value;\n};\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eIn this case, we can use a type tag to allow the user to explicitly choose the emplace constructor. This approach is simpler to implement and\noffers greater flexibility. It is the same approach used by many wrapper types in the standard library, such as \u003ca\nhref\u003d\"https://en.cppreference.com/w/cpp/utility/optional/optional\"\u003e\u003ccode\u003estd::optional\u003c/code\u003e\u003c/a\u003e and \u003ca\nhref\u003d\"https://en.cppreference.com/w/cpp/utility/expected/expected\"\u003e\u003ccode\u003estd::expected\u003c/code\u003e\u003c/a\u003e.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\ntemplate\u0026lt;typename T\u0026gt;\nclass EmplaceWrapper {\npublic:\n  EmplaceWrapper(EmplaceWrapper const\u0026amp; other) \u003d default;\n\n  template\u0026lt;typename... Args\u0026gt;\n    requires std::constructible_from\u0026lt;T, Args...\u0026gt;\n  EmplaceWrapper(std::in_place_t, Args\u0026amp;\u0026amp;... args)  // Compliant: use type tag to explicitly choose emplace constructor\n    : value(std::forward\u0026lt;Args\u0026gt;(args)...)\n  {}\n\nprivate:\n  T value;\n};\n\u003c/pre\u003e\n\u003ch3\u003eGoing the extra mile\u003c/h3\u003e\n\u003cp\u003eWhen the forwarding constructor belongs to a base class, using the \u003ccode\u003esame_as\u003c/code\u003e constraint check is not sufficient: The forwarding\nconstructor can still get selected when we are copying from a derived object.\u003c/p\u003e\n\u003cpre\u003e\nclass Base {\npublic:\n  template \u0026lt;typename T\u0026gt;\n  requires (!std::same_as\u0026lt;std::remove_cvref_t\u0026lt;T\u0026gt;, Base\u0026gt;)  // Incorrect: same_as is not sufficient for base classes.\n  Base(T\u0026amp;\u0026amp; str) : str(std::forward\u0026lt;T\u0026gt;(str)) {}\nprivate:\n  std::string str;\n};\n\nclass Derived : public Base {};\n\u003c/pre\u003e\n\u003cp\u003eThen the following results in a compilation error:\u003c/p\u003e\n\u003cpre\u003e\nDerived d(\"str\");\n// Note that the constraint is satisfied when T is Derived\u0026amp;\nBase b(d);  // Calls the forwarding constructor instead of the usual \"slicing\" behavior\n\u003c/pre\u003e\n\u003cp\u003eAdditionally, subclasses can run into trouble when they try to define their copy constructors:\u003c/p\u003e\n\u003cpre\u003e\nclass Derived2 : public Base {\n  // ...\npublic:\n  Derived2(Derived2 const\u0026amp; d)\n    // d is of Derived2 type and it therefore satisfies the same_as constraint for the forwarding constructor\n    : Base(d) {  // Error: Calls the forwarding constructor instead of the base copy constructor\n    // ...\n  }\n};\n\u003c/pre\u003e\n\u003cp\u003eTo avoid these problems, use \u003ccode\u003estd::derived_from\u003c/code\u003e or \u003ccode\u003estd::base_of\u003c/code\u003e checks instead of \u003ccode\u003estd::same_as\u003c/code\u003e or\n\u003ccode\u003estd::is_same\u003c/code\u003e when the forwarding constructor belongs to a class that has derived classes.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/utility/forward\"\u003e\u003ccode\u003estd::forward\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/overload_resolution#Ranking_of_implicit_conversion_sequences\"\u003eRanking of\n  implicit conversion sequences during overload resolution\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eArticles \u0026amp; blog posts\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Effective Modern C++ item 26: Avoid overloading on universal references \u003c/li\u003e\n  \u003cli\u003e Eric Niebler - \u003ca href\u003d\"https://ericniebler.com/2013/08/07/universal-references-and-the-copy-constructo/\"\u003eUniversal References and the Copy\n  Constructor\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cem\u003eForwarding references\u003c/em\u003e (also known as \u003cem\u003euniversal references\u003c/em\u003e) provide the ability to write a template that can deduce and accept any\nkind of reference to the object (\u003cem\u003ervalue\u003c/em\u003e/\u003cem\u003elvalue\u003c/em\u003e \u003cem\u003emutable\u003c/em\u003e/\u003cem\u003econst\u003c/em\u003e). This enables the creation of a perfect forwarding\nconstructor for wrapper types: the constructor arguments are forwarded to build the underlying type:\u003c/p\u003e\n\u003cpre\u003e\nclass Wrapper {\npublic:\n  // A defaulted copy constructor\n  Wrapper(Wrapper const\u0026amp; other) \u003d default;\n\n  template \u0026lt;typename T\u0026gt;\n  Wrapper(T\u0026amp;\u0026amp; str)  // A noncompliant forwarding constructor\n    : str(std::forward\u0026lt;T\u0026gt;(str)) {}\n\nprivate:\n  std::string str;\n};\n\u003c/pre\u003e\n\u003cp\u003eHowever, this constructor is too greedy: overload resolution prefers it over the copy constructor as soon as the argument type is slightly\ndifferent from a \u003ccode\u003eWrapper const\u0026amp;\u003c/code\u003e. For instance, when passing a non-const \u003cem\u003elvalue\u003c/em\u003e (\u003ccode\u003ew\u003c/code\u003e in the following example),\ncalling the copy constructor requires a non-const to const conversion, while the forwarding reference parameter is an exact match, and will therefore\nbe selected. This is usually not the expected behavior.\u003c/p\u003e\n\u003cpre\u003e\nWrapper const cw(\"str1\");\nWrapper w(\"str2\");\n\nWrapper w1(cw);  // Ok: calls Wrapper(Wrapper const\u0026amp; other)\nWrapper w2(w);   // Ill-formed: calls Wrapper(T\u0026amp;\u0026amp; str) with [T \u003d Wrapper\u0026amp;]\n                 // This tries to initialize a std::string using a Wrapper object\n\u003c/pre\u003e\n\u003cp\u003eThis rule specifically targets constructors that can be called with a single \u003cem\u003eforwarding reference\u003c/em\u003e argument. In such cases, they compete\nwith copy or move constructors, including those implicitly generated by the compiler. Yet, selecting the wrong overload can also happen with\nforwarding references on regular functions and methods, but this is out of scope for this rule.\u003c/p\u003e\n\u003cp\u003eEven if the non-constrained forwarding constructor may currently seem to work fine, using it with different value categories in the future could\nresult in unexpected compilation errors or, even worse, hard-to-debug run-time behavior if the wrapped type happens to be constructible from instances\nof the wrapper.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eThe rule reports forwarding constructors without proper constraints if they can be called with a single argument. To eliminate this pitfall, add\nconstraints to such constructors so that they are not considered an overload candidate when the argument is a reference to the class itself. This can\nbe achieved by adding any of the following checks to the forwarding reference constructor:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e a check of the concept \u003ccode\u003e!std::same_as\u0026lt;std::remove_cvref_t\u0026lt;U\u0026gt;, Wrapper\u0026gt;\u003c/code\u003e, or \u003c/li\u003e\n  \u003cli\u003e a check of type predicate \u003ccode\u003e!std::is_same_v\u0026lt;std::remove_cvref_t\u0026lt;U\u0026gt;, Wrapper\u0026gt;\u003c/code\u003e, or \u003c/li\u003e\n  \u003cli\u003e an \u003ccode\u003estd::enable_if\u003c/code\u003e with the equivalent condition. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eNote that special care has to be taken when \u003ccode\u003eWrapper\u003c/code\u003e is a base class. This is explained in more detail in \"Going the extra mile\" below.\nIn this case, those checks would become:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e the concept \u003ccode\u003e!std::derived_from\u0026lt;std::remove_cvref_t\u0026lt;U\u0026gt;, Wrapper\u0026gt;\u003c/code\u003e, or \u003c/li\u003e\n  \u003cli\u003e a type-predicate \u003ccode\u003e!std::is_base_of_v\u0026lt;Wrapper, std::remove_cvref_t\u0026lt;U\u0026gt;\u0026gt;\u003c/code\u003e, or \u003c/li\u003e\n  \u003cli\u003e an \u003ccode\u003estd::enable_if\u003c/code\u003e with the equivalent condition. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe concept-based solutions require C++20. The \u003ccode\u003estd::enable_if\u003c/code\u003e solution is more cumbersome to write but can always be used.\u003c/p\u003e\n\u003cp\u003eNote that there are other ways to constrain such a constructor, but this rule only recognizes the explicit checks described above as compliant.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cp\u003eIn this noncompliant example, the implicitly compiler-generated copy constructor can receive calls only when copying non-const lvalues (i.e., exact\nmatches). Otherwise, the forwarding constructor is used, even when the given type can not be used to initialize the wrapped \u003ccode\u003estd::string\u003c/code\u003e\nobject.\u003c/p\u003e\n\u003cpre\u003e\nclass Wrapper {\npublic:\n  template \u0026lt;typename T\u0026gt;\n  Wrapper(T\u0026amp;\u0026amp; str)  // Noncompliant: competes with compiler-generated copy constructor\n    : str(std::forward\u0026lt;T\u0026gt;(str)) {}\n\nprivate:\n  std::string str;\n};\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eWe fix the problem by adding a constraint to our forwarding constructor. This enables the copy constructor to receive calls again by excluding the\nforwarding constructor when the deduced \u003ccode\u003eT\u003c/code\u003e is \u003ccode\u003eWrapper\u003c/code\u003e (after discarding references and const-volatile qualifiers).\u003c/p\u003e\n\u003cpre\u003e\nclass Wrapper {\npublic:\n  template \u0026lt;typename T\u0026gt;\n  requires (!std::same_as\u0026lt;Wrapper, std::remove_cvref_t\u0026lt;T\u0026gt;\u0026gt;)\n  Wrapper(T\u0026amp;\u0026amp; str)  // Compliant: no longer competes with the copy constructor\n    : str(std::forward\u0026lt;T\u0026gt;(str)) {}\n\nprivate:\n  std::string str;\n};\n\u003c/pre\u003e\n\u003cp\u003eIf C++20 is not available, we can use \u003ccode\u003estd::enable_if\u003c/code\u003e instead of concepts. We also can not use \u003ccode\u003estd::remove_cvref_t\u003c/code\u003e, and we\nhave to be more verbose:\u003c/p\u003e\n\u003cpre\u003e\n// Define our own remove_cvref_t for use in C++11\ntemplate \u0026lt;typename T\u0026gt;\nusing remove_cvref_t \u003d typename std::remove_cv\u0026lt;typename std::remove_reference\u0026lt;T\u0026gt;::type\u0026gt;::type;\n\nclass Wrapper {\npublic:\n  template \u0026lt;\n    typename T,\n    typename std::enable_if\u0026lt;\n      !std::is_same\u0026lt;Wrapper, remove_cvref_t\u0026lt;T\u0026gt;\u0026gt;::value, int\u0026gt;::type /* Unnamed */ \u003d 0\u0026gt;\n  Wrapper(T\u0026amp;\u0026amp; str)  // Compliant: no longer competes with the copy constructor\n    : str(std::forward\u0026lt;T\u0026gt;(str)) {}\n\nprivate:\n  std::string str;\n};\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cp\u003eThis noncompliant example demonstrates a bad attempt at constraining a forwarding constructor in a template wrapper:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\ntemplate\u0026lt;typename T\u0026gt;\nclass TemplateWrapper {\npublic:\n  TemplateWrapper(TemplateWrapper const\u0026amp; other) \u003d default;\n\n  template\u0026lt;typename U\u0026gt;\n    requires std::constructible_from\u0026lt;T, U\u0026gt;\n  TemplateWrapper(U\u0026amp;\u0026amp; u) // Noncompliant: constructible_from check is not sufficient in general\n    : value(std::forward\u0026lt;U\u0026gt;(u))\n  {}\n\nprivate:\n  T value;\n};\n\u003c/pre\u003e\n\u003cp\u003eThe problem with this constraint is that it depends on how the type \u003ccode\u003eT\u003c/code\u003e can be constructed; For example, it can yield unexpected results\nif \u003ccode\u003eT\u003c/code\u003e itself has a forwarding constructor.\u003c/p\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eIn order to properly make our \u003ccode\u003eTemplateWrapper\u003c/code\u003e generic, we need to add the necessary constraint alongside\n\u003ccode\u003estd::constructible_from\u003c/code\u003e:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\ntemplate\u0026lt;typename T\u0026gt;\nclass TemplateWrapper {\npublic:\n  TemplateWrapper(TemplateWrapper const\u0026amp; other) \u003d default;\n\n  template\u0026lt;typename U\u0026gt;\n    requires (!std::derived_from\u0026lt;std::remove_cvref_t\u0026lt;U\u0026gt;, TemplateWrapper\u0026gt; \u0026amp;\u0026amp; std::constructible_from\u0026lt;T, U\u0026gt;)\n  TemplateWrapper(U\u0026amp;\u0026amp; u)  // Compliant: properly constrained regardless of how T can be constructed\n    : value(std::forward\u0026lt;U\u0026gt;(u))\n  {}\n\nprivate:\n  T value;\n};\n\u003c/pre\u003e\n\u003cp\u003eUsing \u003ccode\u003estd::derived_from\u003c/code\u003e instead of \u003ccode\u003estd::same_as\u003c/code\u003e is only meant for demonstration purposes here.\n\u003ccode\u003estd::derived_from\u003c/code\u003e is necessary only if \u003ccode\u003eTemplateWrapper\u003c/code\u003e has derived classes, to ensure that the copy constructors of these\nderived classes don’t end up calling the forwarding constructor. This is explained in more detail in the \"Going the extra mile\" section below.\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cp\u003eIn this noncompliant example, the forwarding constructor accepts a parameter pack and uses it to initialize the wrapped type. This can still\ncompete with the copy constructor when called with a single argument. Using \u003ccode\u003estd::constructible_from\u003c/code\u003e is not sufficient for the same\nreasons as the previous example.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\ntemplate\u0026lt;typename T\u0026gt;\nclass EmplaceWrapper {\npublic:\n  EmplaceWrapper(EmplaceWrapper const\u0026amp; other) \u003d default;\n\n  template\u0026lt;typename... Args\u0026gt;\n    requires std::constructible_from\u0026lt;T, Args...\u0026gt;\n  EmplaceWrapper(Args\u0026amp;\u0026amp;... args) // Noncompliant: will compete with copy-constructor\n    : value(std::forward\u0026lt;Args\u0026gt;(args)...)\n  {}\n\nprivate:\n  T value;\n};\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eIn this case, we can use a type tag to allow the user to explicitly choose the emplace constructor. This approach is simpler to implement and\noffers greater flexibility. It is the same approach used by many wrapper types in the standard library, such as \u003ca\nhref\u003d\"https://en.cppreference.com/w/cpp/utility/optional/optional\"\u003e\u003ccode\u003estd::optional\u003c/code\u003e\u003c/a\u003e and \u003ca\nhref\u003d\"https://en.cppreference.com/w/cpp/utility/expected/expected\"\u003e\u003ccode\u003estd::expected\u003c/code\u003e\u003c/a\u003e.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\ntemplate\u0026lt;typename T\u0026gt;\nclass EmplaceWrapper {\npublic:\n  EmplaceWrapper(EmplaceWrapper const\u0026amp; other) \u003d default;\n\n  template\u0026lt;typename... Args\u0026gt;\n    requires std::constructible_from\u0026lt;T, Args...\u0026gt;\n  EmplaceWrapper(std::in_place_t, Args\u0026amp;\u0026amp;... args)  // Compliant: use type tag to explicitly choose emplace constructor\n    : value(std::forward\u0026lt;Args\u0026gt;(args)...)\n  {}\n\nprivate:\n  T value;\n};\n\u003c/pre\u003e\n\u003ch3\u003eGoing the extra mile\u003c/h3\u003e\n\u003cp\u003eWhen the forwarding constructor belongs to a base class, using the \u003ccode\u003esame_as\u003c/code\u003e constraint check is not sufficient: The forwarding\nconstructor can still get selected when we are copying from a derived object.\u003c/p\u003e\n\u003cpre\u003e\nclass Base {\npublic:\n  template \u0026lt;typename T\u0026gt;\n  requires (!std::same_as\u0026lt;std::remove_cvref_t\u0026lt;T\u0026gt;, Base\u0026gt;)  // Incorrect: same_as is not sufficient for base classes.\n  Base(T\u0026amp;\u0026amp; str) : str(std::forward\u0026lt;T\u0026gt;(str)) {}\nprivate:\n  std::string str;\n};\n\nclass Derived : public Base {};\n\u003c/pre\u003e\n\u003cp\u003eThen the following results in a compilation error:\u003c/p\u003e\n\u003cpre\u003e\nDerived d(\"str\");\n// Note that the constraint is satisfied when T is Derived\u0026amp;\nBase b(d);  // Calls the forwarding constructor instead of the usual \"slicing\" behavior\n\u003c/pre\u003e\n\u003cp\u003eAdditionally, subclasses can run into trouble when they try to define their copy constructors:\u003c/p\u003e\n\u003cpre\u003e\nclass Derived2 : public Base {\n  // ...\npublic:\n  Derived2(Derived2 const\u0026amp; d)\n    // d is of Derived2 type and it therefore satisfies the same_as constraint for the forwarding constructor\n    : Base(d) {  // Error: Calls the forwarding constructor instead of the base copy constructor\n    // ...\n  }\n};\n\u003c/pre\u003e\n\u003cp\u003eTo avoid these problems, use \u003ccode\u003estd::derived_from\u003c/code\u003e or \u003ccode\u003estd::base_of\u003c/code\u003e checks instead of \u003ccode\u003estd::same_as\u003c/code\u003e or\n\u003ccode\u003estd::is_same\u003c/code\u003e when the forwarding constructor belongs to a class that has derived classes.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/utility/forward\"\u003e\u003ccode\u003estd::forward\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/overload_resolution#Ranking_of_implicit_conversion_sequences\"\u003eRanking of\n  implicit conversion sequences during overload resolution\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eArticles \u0026amp; blog posts\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Effective Modern C++ item 26: Avoid overloading on universal references \u003c/li\u003e\n  \u003cli\u003e Eric Niebler - \u003ca href\u003d\"https://ericniebler.com/2013/08/07/universal-references-and-the-copy-constructo/\"\u003eUniversal References and the Copy\n  Constructor\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "since-c++11",
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6459",
    "name": "Type-constraints should not be used for forwarding reference parameters",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cem\u003eType-constraints\u003c/em\u003e provide a concise way to express constraints on the type deduced for a given template parameter or auto placeholder. In a\nsituation when a type-constraint is applied to a forwarding reference parameter (\u003ccode\u003eT\u0026amp;\u0026amp;\u003c/code\u003e), the corresponding concept will be checked\nagainst the \u003cem\u003elvalue reference\u003c/em\u003e (if the argument is an \u003cem\u003elvalue\u003c/em\u003e) or the plain type (if the argument is an \u003cem\u003ervalue\u003c/em\u003e):\u003c/p\u003e\n\u003cpre\u003e\ntemplate \u0026lt;SomeConcept T\u0026gt; void func(T\u0026amp;\u0026amp; x);\nvoid f() {\n  func(SomeType{});  // Argument is an rvalue -\u0026gt; T is deduced as \u0027SomeType\u0027\n  SomeType obj;\n  func(obj);  //  Argument is lvalue -\u0026gt; T is deduced as \u0027SomeType\u0026amp;\u0027\n}\n\u003c/pre\u003e\n\u003cp\u003eEven if it is possible to write \u003ccode\u003eSomeConcept\u003c/code\u003e in a way that works for both plain types and references, it is not straightforward and\nrequires a dedicated effort.\u003c/p\u003e\n\u003cp\u003eMany standard-provided constraints change their behavior when the type is a reference. For instance, a \u003ccode\u003estd::copyable\u003c/code\u003e constraint is\nnever satisfied for references, regardless of the referenced type, while a \u003ccode\u003estd::copy_constructible\u003c/code\u003e constraint always is. The following\nexample illustrates this:\u003c/p\u003e\n\u003cpre\u003e\ntemplate \u0026lt;std::copyable T\u0026gt; void func(T\u0026amp;\u0026amp; t);  // Overload #1.\ntemplate \u0026lt;typename T\u0026gt; void func(T\u0026amp;\u0026amp; t);  // Overload #2 (unconstrained).\n\nvoid f() {\n    // Call with an rvalue argument:\n    func(std::string{\"\"});  // Calls #1: T is \u0027std::string\u0027, which satisfies \u0027std::copyable\u0027.\n\n    // Call with an lvalue argument:\n    std::string s{\"\"};\n    func(s);  // Calls #2: T is a reference type (\u0027std::string\u0026amp;\u0027) and therefore does not satisfy \u0027std::copyable\u0027.\n}\n\u003c/pre\u003e\n\u003cp\u003eThe rule raises an issue when a forwarding reference parameter is constrained by a standard-provided concept using \u003cem\u003etype-constraint\u003c/em\u003e\nsyntax.\u003c/p\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThe rule does not raise an issue for the \u003ccode\u003estd::ranges::range\u003c/code\u003e concept and its refinements (like \u003ccode\u003estd::ranges::forward_range\u003c/code\u003e,\n\u003ccode\u003estd::ranges::bidirectional_range\u003c/code\u003e) which are designed to handle forwarding reference parameters.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eTo apply a constraint to a forwarding reference parameter, consider the following options:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Either wrap the deduced type in \u003ccode\u003estd::remove_cvref_t\u003c/code\u003e and use the standard-provided constraint on the result in a\n  \u003ccode\u003erequires\u003c/code\u003e clause. \u003c/li\u003e\n  \u003cli\u003e Or design a custom constraint that works for both reference and non-reference types, which is useful if you frequently encounter this issue\n  with a specific constraint. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nauto func(std::copy_constructible auto\u0026amp;\u0026amp; arg) // Noncompliant\n{ /* … */ }\n\ntemplate\u0026lt;std::copyable T\u0026gt;\nauto func2(T\u0026amp;\u0026amp; arg) //  Noncompliant\n{ /* … */ }\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nauto func(auto\u0026amp;\u0026amp; arg)\n  requires std::copy_constructible\u0026lt;std::remove_cvref_t\u0026lt;decltype(arg)\u0026gt;\u0026gt;\n{ /* … */ }\n\ntemplate\u0026lt;typename T\u0026gt;\n  requires std::copyable\u0026lt;std::remove_cvref_t\u0026lt;T\u0026gt;\u0026gt;\nauto func2(T\u0026amp;\u0026amp; arg)\n{ /* … */ }\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/reference#Forwarding_references\"\u003eForwarding references\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/constraints\"\u003eConstraints and concepts\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/concepts/copy_constructible\"\u003e\u003ccode\u003estd::copy_constructible\u003c/code\u003e concept\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/concepts/copyable\"\u003e\u003ccode\u003estd::copyable\u003c/code\u003e concept\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cem\u003eType-constraints\u003c/em\u003e provide a concise way to express constraints on the type deduced for a given template parameter or auto placeholder. In a\nsituation when a type-constraint is applied to a forwarding reference parameter (\u003ccode\u003eT\u0026amp;\u0026amp;\u003c/code\u003e), the corresponding concept will be checked\nagainst the \u003cem\u003elvalue reference\u003c/em\u003e (if the argument is an \u003cem\u003elvalue\u003c/em\u003e) or the plain type (if the argument is an \u003cem\u003ervalue\u003c/em\u003e):\u003c/p\u003e\n\u003cpre\u003e\ntemplate \u0026lt;SomeConcept T\u0026gt; void func(T\u0026amp;\u0026amp; x);\nvoid f() {\n  func(SomeType{});  // Argument is an rvalue -\u0026gt; T is deduced as \u0027SomeType\u0027\n  SomeType obj;\n  func(obj);  //  Argument is lvalue -\u0026gt; T is deduced as \u0027SomeType\u0026amp;\u0027\n}\n\u003c/pre\u003e\n\u003cp\u003eEven if it is possible to write \u003ccode\u003eSomeConcept\u003c/code\u003e in a way that works for both plain types and references, it is not straightforward and\nrequires a dedicated effort.\u003c/p\u003e\n\u003cp\u003eMany standard-provided constraints change their behavior when the type is a reference. For instance, a \u003ccode\u003estd::copyable\u003c/code\u003e constraint is\nnever satisfied for references, regardless of the referenced type, while a \u003ccode\u003estd::copy_constructible\u003c/code\u003e constraint always is. The following\nexample illustrates this:\u003c/p\u003e\n\u003cpre\u003e\ntemplate \u0026lt;std::copyable T\u0026gt; void func(T\u0026amp;\u0026amp; t);  // Overload #1.\ntemplate \u0026lt;typename T\u0026gt; void func(T\u0026amp;\u0026amp; t);  // Overload #2 (unconstrained).\n\nvoid f() {\n    // Call with an rvalue argument:\n    func(std::string{\"\"});  // Calls #1: T is \u0027std::string\u0027, which satisfies \u0027std::copyable\u0027.\n\n    // Call with an lvalue argument:\n    std::string s{\"\"};\n    func(s);  // Calls #2: T is a reference type (\u0027std::string\u0026amp;\u0027) and therefore does not satisfy \u0027std::copyable\u0027.\n}\n\u003c/pre\u003e\n\u003cp\u003eThe rule raises an issue when a forwarding reference parameter is constrained by a standard-provided concept using \u003cem\u003etype-constraint\u003c/em\u003e\nsyntax.\u003c/p\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThe rule does not raise an issue for the \u003ccode\u003estd::ranges::range\u003c/code\u003e concept and its refinements (like \u003ccode\u003estd::ranges::forward_range\u003c/code\u003e,\n\u003ccode\u003estd::ranges::bidirectional_range\u003c/code\u003e) which are designed to handle forwarding reference parameters.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eTo apply a constraint to a forwarding reference parameter, consider the following options:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Either wrap the deduced type in \u003ccode\u003estd::remove_cvref_t\u003c/code\u003e and use the standard-provided constraint on the result in a\n  \u003ccode\u003erequires\u003c/code\u003e clause. \u003c/li\u003e\n  \u003cli\u003e Or design a custom constraint that works for both reference and non-reference types, which is useful if you frequently encounter this issue\n  with a specific constraint. \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nauto func(std::copy_constructible auto\u0026amp;\u0026amp; arg) // Noncompliant\n{ /* … */ }\n\ntemplate\u0026lt;std::copyable T\u0026gt;\nauto func2(T\u0026amp;\u0026amp; arg) //  Noncompliant\n{ /* … */ }\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nauto func(auto\u0026amp;\u0026amp; arg)\n  requires std::copy_constructible\u0026lt;std::remove_cvref_t\u0026lt;decltype(arg)\u0026gt;\u0026gt;\n{ /* … */ }\n\ntemplate\u0026lt;typename T\u0026gt;\n  requires std::copyable\u0026lt;std::remove_cvref_t\u0026lt;T\u0026gt;\u0026gt;\nauto func2(T\u0026amp;\u0026amp; arg)\n{ /* … */ }\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/reference#Forwarding_references\"\u003eForwarding references\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/constraints\"\u003eConstraints and concepts\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/concepts/copy_constructible\"\u003e\u003ccode\u003estd::copy_constructible\u003c/code\u003e concept\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/concepts/copyable\"\u003e\u003ccode\u003estd::copyable\u003c/code\u003e concept\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "since-c++20",
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S4263",
    "name": "Include directives should not rely on non-portable search strategy",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eMicrosoft’s MSVC has a search strategy which differs from other compilers when resolving quoted include directives \u003ccode\u003e#include \"file.h\"\u003c/code\u003e.\nRelying on such a strategy is not portable and may lead to compilation failure when trying to build with a different compiler.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue whenever the file specified in a \u003ccode\u003e#include\u003c/code\u003e directive can only be found using the MSVC search strategy.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e Microsoft Learn - \u003ca href\u003d\"https://learn.microsoft.com/en-us/cpp/preprocessor/hash-include-directive-c-cpp\"\u003e\u003ccode\u003e#include\u003c/code\u003e directive\n  (C/C++)\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eMicrosoft’s MSVC has a search strategy which differs from other compilers when resolving quoted include directives \u003ccode\u003e#include \"file.h\"\u003c/code\u003e.\nRelying on such a strategy is not portable and may lead to compilation failure when trying to build with a different compiler.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue whenever the file specified in a \u003ccode\u003e#include\u003c/code\u003e directive can only be found using the MSVC search strategy.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e Microsoft Learn - \u003ca href\u003d\"https://learn.microsoft.com/en-us/cpp/preprocessor/hash-include-directive-c-cpp\"\u003e\u003ccode\u003e#include\u003c/code\u003e directive\n  (C/C++)\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S4143",
    "name": "Array values should not be replaced unconditionally",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eStoring a value inside a collection at a given key or index and then unconditionally overwriting it without reading the initial value is a case of\na \"dead store\".\u003c/p\u003e\n\u003cpre\u003e\ntowns[i] \u003d \"London\";\ntowns[i] \u003d \"Chicago\";  // Noncompliant: We never used the previous value\n\u003c/pre\u003e\n\u003cp\u003eThis practice is redundant and will cause confusion for the reader. More importantly, it is often an error and not what the developer intended to\ndo.\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eStoring a value inside a collection at a given key or index and then unconditionally overwriting it without reading the initial value is a case of\na \"dead store\".\u003c/p\u003e\n\u003cpre\u003e\ntowns[i] \u003d \"London\";\ntowns[i] \u003d \"Chicago\";  // Noncompliant: We never used the previous value\n\u003c/pre\u003e\n\u003cp\u003eThis practice is redundant and will cause confusion for the reader. More importantly, it is often an error and not what the developer intended to\ndo.\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6200",
    "name": "\"volatile\" should not be used to qualify objects for which the meaning is not defined",
    "defaultSeverity": "CRITICAL",
    "type": "BUG",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003evolatile\u003c/code\u003e can be used to qualify many objects in C and C++, but only a few of the possible places have a well-defined meaning (global\nvariables and local variables, for instance). There is no well-defined meaning to the use of volatile to qualify a function return type or a function\nparameter. Furthermore, for structured bindings, the volatile qualifier appertains to the decomposed object, which cannot be referred to. Since C++20,\nthese uses are deprecated, but even before you should not use volatile in those places.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue for a volatile qualified function return type, function parameter, and structured binding (available in C++ since\nC++17).\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint volatile f(int volatile i); // Noncompliant, both for the return type and the parameter\n\nvoid g() {\n  auto volatile [a, b] \u003d getPair(); // Noncompliant\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003ccode\u003evolatile\u003c/code\u003e can be used to qualify many objects in C and C++, but only a few of the possible places have a well-defined meaning (global\nvariables and local variables, for instance). There is no well-defined meaning to the use of volatile to qualify a function return type or a function\nparameter. Furthermore, for structured bindings, the volatile qualifier appertains to the decomposed object, which cannot be referred to. Since C++20,\nthese uses are deprecated, but even before you should not use volatile in those places.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue for a volatile qualified function return type, function parameter, and structured binding (available in C++ since\nC++17).\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint volatile f(int volatile i); // Noncompliant, both for the return type and the parameter\n\nvoid g() {\n  auto volatile [a, b] \u003d getPair(); // Noncompliant\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S886",
    "name": "The three expressions of a \"for\" statement should only be concerned with loop control",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003efor\u003c/code\u003e loops are very flexible in C and C++. Because of that, they can carry a complexity that can make the code error-prone, difficult\nto understand, and hard to maintain.\u003c/p\u003e\n\u003cp\u003eMany for loops can be written in a way that clearly separates the iteration process from the content of the iteration. This rule makes sure that\nall the code relevant to the iteration is placed in the for-loop header. The compliant code is then easier to reason about.\u003c/p\u003e\n\u003cp\u003eA for loop is composed of 4 sub-parts:\u003c/p\u003e\n\u003cpre\u003e\nfor([initialization]; [condition]; [update])\n  [body]\n\u003c/pre\u003e\n\u003cp\u003eWe classify the variables used to control them in three categories:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e A \u003cem\u003eloop-counter\u003c/em\u003e is a variable modified in the update. It should not be modified in the body. \u003c/li\u003e\n  \u003cli\u003e A \u003cem\u003eloop-constant\u003c/em\u003e is an auxiliary variable declared in the initialization. It’s very often used to precompute some data about the end\n  condition or the stride. \u003c/li\u003e\n  \u003cli\u003e A \u003cem\u003epseudo-counter\u003c/em\u003e shares some properties with a loop counter, but its update conditions are more complex. It will therefore only be\n  updated in the body, and cannot be used in the update. Using a pseudo-counter makes the loop more complex to reason about, and therefore is not\n  permitted. They are very often declared in the initialization, for instance, to limit their scope, but in some cases reuse existing variables. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eAdditionally, the loop condition should refer to at least one \u003cem\u003eloop-counter\u003c/em\u003e, and should not modify anything.\u003c/p\u003e\n\u003cp\u003eThis rule is only checking for loops with a condition and an update.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nfor( int h \u003d 0, int i \u003d 0 ; h \u0026lt; 10 ; i +\u003d 1 ) { // Noncompliant, the loop-counter is not used in the condition\n}\n\nfor( int i \u003d 0 ; i++ \u0026lt; 10 ; i +\u003d 1 ) { // Noncompliant, loop-counter i is updated in the condition\n}\n\nfor( int i \u003d 0 , int h \u003d 0; i+(++h) \u0026lt; 10 ; i +\u003d 1 ) { // Noncompliant, pseudo-counter h is updated in the condition\n}\n\nfor( int i \u003d 0 ; i \u0026lt; 10 ; i +\u003d 1 ) { // Noncompliant, loop-counter i is updated in the body\n  if (i%2)  { ++i;}\n}\n\nfor( int i \u003d 0 , j \u003d 0 ; i \u0026lt; 10 ; i +\u003d j) { // Noncompliant, pseudo-counter j is is used in the update\n  j \u003d i + 1;\n}\n\nfor( int i \u003d 0 , j \u003d 0 ; i \u0026lt; 10 + j ; i +\u003d 1) { // Noncompliant, pseudo-counter j is is used in the condition\n  j \u003d i + 1;\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 13.5 - The three expressions of a for statement shall be concerned only with loop control. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 6-5-5 - A \u003cem\u003eloop-control-variable\u003c/em\u003e other than the \u003cem\u003eloop-counter\u003c/em\u003e shall not be modified within \u003cem\u003econdition\u003c/em\u003e\n  or \u003cem\u003eexpression\u003c/em\u003e. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 14.2 - A for loop shall be well-formed \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003ccode\u003efor\u003c/code\u003e loops are very flexible in C and C++. Because of that, they can carry a complexity that can make the code error-prone, difficult\nto understand, and hard to maintain.\u003c/p\u003e\n\u003cp\u003eMany for loops can be written in a way that clearly separates the iteration process from the content of the iteration. This rule makes sure that\nall the code relevant to the iteration is placed in the for-loop header. The compliant code is then easier to reason about.\u003c/p\u003e\n\u003cp\u003eA for loop is composed of 4 sub-parts:\u003c/p\u003e\n\u003cpre\u003e\nfor([initialization]; [condition]; [update])\n  [body]\n\u003c/pre\u003e\n\u003cp\u003eWe classify the variables used to control them in three categories:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e A \u003cem\u003eloop-counter\u003c/em\u003e is a variable modified in the update. It should not be modified in the body. \u003c/li\u003e\n  \u003cli\u003e A \u003cem\u003eloop-constant\u003c/em\u003e is an auxiliary variable declared in the initialization. It’s very often used to precompute some data about the end\n  condition or the stride. \u003c/li\u003e\n  \u003cli\u003e A \u003cem\u003epseudo-counter\u003c/em\u003e shares some properties with a loop counter, but its update conditions are more complex. It will therefore only be\n  updated in the body, and cannot be used in the update. Using a pseudo-counter makes the loop more complex to reason about, and therefore is not\n  permitted. They are very often declared in the initialization, for instance, to limit their scope, but in some cases reuse existing variables. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eAdditionally, the loop condition should refer to at least one \u003cem\u003eloop-counter\u003c/em\u003e, and should not modify anything.\u003c/p\u003e\n\u003cp\u003eThis rule is only checking for loops with a condition and an update.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nfor( int h \u003d 0, int i \u003d 0 ; h \u0026lt; 10 ; i +\u003d 1 ) { // Noncompliant, the loop-counter is not used in the condition\n}\n\nfor( int i \u003d 0 ; i++ \u0026lt; 10 ; i +\u003d 1 ) { // Noncompliant, loop-counter i is updated in the condition\n}\n\nfor( int i \u003d 0 , int h \u003d 0; i+(++h) \u0026lt; 10 ; i +\u003d 1 ) { // Noncompliant, pseudo-counter h is updated in the condition\n}\n\nfor( int i \u003d 0 ; i \u0026lt; 10 ; i +\u003d 1 ) { // Noncompliant, loop-counter i is updated in the body\n  if (i%2)  { ++i;}\n}\n\nfor( int i \u003d 0 , j \u003d 0 ; i \u0026lt; 10 ; i +\u003d j) { // Noncompliant, pseudo-counter j is is used in the update\n  j \u003d i + 1;\n}\n\nfor( int i \u003d 0 , j \u003d 0 ; i \u0026lt; 10 + j ; i +\u003d 1) { // Noncompliant, pseudo-counter j is is used in the condition\n  j \u003d i + 1;\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 13.5 - The three expressions of a for statement shall be concerned only with loop control. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 6-5-5 - A \u003cem\u003eloop-control-variable\u003c/em\u003e other than the \u003cem\u003eloop-counter\u003c/em\u003e shall not be modified within \u003cem\u003econdition\u003c/em\u003e\n  or \u003cem\u003eexpression\u003c/em\u003e. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 14.2 - A for loop shall be well-formed \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "based-on-misra"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5350",
    "name": "Pointer and reference local variables should be \"const\" if the corresponding object is not modified",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThis rule leads to greater precision in the definition of local variables by making the developer intention about modifying the variable explicit.\nThe \u003ccode\u003econst\u003c/code\u003e qualification shall be applied to the object pointed to, not to the pointer, since it is the object itself that is being\nprotected.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstd::string\u0026amp; getString();\nvoid myfunc()\n{\n  std::string\u0026amp; s \u003d getString(); // Noncompliant\n  if (s.size()) {\n   std::cout \u0026lt;\u0026lt; s;\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstd::string\u0026amp; getString();\nvoid myfunc () {\n  const std::string\u0026amp; x \u003d getString();\n  if (s.size()) {\n    std::cout \u0026lt;\u0026lt; s;\n  }\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThis rule leads to greater precision in the definition of local variables by making the developer intention about modifying the variable explicit.\nThe \u003ccode\u003econst\u003c/code\u003e qualification shall be applied to the object pointed to, not to the pointer, since it is the object itself that is being\nprotected.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstd::string\u0026amp; getString();\nvoid myfunc()\n{\n  std::string\u0026amp; s \u003d getString(); // Noncompliant\n  if (s.size()) {\n   std::cout \u0026lt;\u0026lt; s;\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstd::string\u0026amp; getString();\nvoid myfunc () {\n  const std::string\u0026amp; x \u003d getString();\n  if (s.size()) {\n    std::cout \u0026lt;\u0026lt; s;\n  }\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "bad-practice",
      "based-on-misra"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:M23_357",
    "name": "\"std::vector\" should not be specialized with \"bool\"",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 26.3.1\u003c/p\u003e\n\u003cp\u003eCategory: Advisory\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eThe \u003ccode\u003estd::vector\u0026lt; bool \u0026gt;\u003c/code\u003e specialization’s behaviour differs from that of other uses of \u003ccode\u003estd::vector\u003c/code\u003e as it uses\noptimized space allocation. For example, the \u003ccode\u003edata\u003c/code\u003e member function is not available.\u003c/p\u003e\n\u003cp\u003eThe C++ Standard guarantees that, in general, elements of a C++ Standard Library container can be modified concurrently, but specifically notes\nthat this is not true for \u003ccode\u003estd::vector\u0026lt; bool \u0026gt;\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e other C++ Standard Library containers do not have specializations for \u003ccode\u003ebool\u003c/code\u003e and do not exhibit the behaviours\nidentified above.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nstruct myBool { bool b; };          // Wrapper for bool\n\nvoid foo() noexcept\n{\n  std::vector\u0026lt; bool         \u0026gt; a;    // Non-compliant - optimized storage\n  std::vector\u0026lt; std::uint8_t \u0026gt; b;    // Compliant\n  std::vector\u0026lt; myBool       \u0026gt; c;    // Compliant\n  std::array \u0026lt; bool, 20     \u0026gt; d;    // Rule does not apply\n  std::bitset\u0026lt; 200          \u0026gt; e;    // Rule does not apply - efficient storage\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/container/vector_bool\"\u003e\u003ccode\u003estd::vector\u0026lt;bool\u0026gt;\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e isocpp.org blog- \u003ca href\u003d\"https://isocpp.org/blog/2012/11/on-vectorbool\"\u003eOn vector\u0026lt;bool\u0026gt;\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 26.3.1\u003c/p\u003e\n\u003cp\u003eCategory: Advisory\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eThe \u003ccode\u003estd::vector\u0026lt; bool \u0026gt;\u003c/code\u003e specialization’s behaviour differs from that of other uses of \u003ccode\u003estd::vector\u003c/code\u003e as it uses\noptimized space allocation. For example, the \u003ccode\u003edata\u003c/code\u003e member function is not available.\u003c/p\u003e\n\u003cp\u003eThe C++ Standard guarantees that, in general, elements of a C++ Standard Library container can be modified concurrently, but specifically notes\nthat this is not true for \u003ccode\u003estd::vector\u0026lt; bool \u0026gt;\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e other C++ Standard Library containers do not have specializations for \u003ccode\u003ebool\u003c/code\u003e and do not exhibit the behaviours\nidentified above.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nstruct myBool { bool b; };          // Wrapper for bool\n\nvoid foo() noexcept\n{\n  std::vector\u0026lt; bool         \u0026gt; a;    // Non-compliant - optimized storage\n  std::vector\u0026lt; std::uint8_t \u0026gt; b;    // Compliant\n  std::vector\u0026lt; myBool       \u0026gt; c;    // Compliant\n  std::array \u0026lt; bool, 20     \u0026gt; d;    // Rule does not apply\n  std::bitset\u0026lt; 200          \u0026gt; e;    // Rule does not apply - efficient storage\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/container/vector_bool\"\u003e\u003ccode\u003estd::vector\u0026lt;bool\u0026gt;\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e isocpp.org blog- \u003ca href\u003d\"https://isocpp.org/blog/2012/11/on-vectorbool\"\u003eOn vector\u0026lt;bool\u0026gt;\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "misra-advisory",
      "misra-c++2023",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:M23_359",
    "name": "A function declared with the \"[[noreturn]]\" attribute shall not return",
    "defaultSeverity": "BLOCKER",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 9.6.4\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Undecidable,System\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eLeaving a function as the result of an exception is not a return.\u003c/p\u003e\n\u003cp\u003eA function’s compliance with this rule is determined independently of the context in which the function is called. For example, a boolean parameter\nis treated as if it may have a value of \u003ccode\u003etrue\u003c/code\u003e or \u003ccode\u003efalse\u003c/code\u003e, even if all the calls expressed in the current program use a value of\n\u003ccode\u003etrue\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eReturning from a function declared as \u003ccode\u003e[[noreturn]]\u003c/code\u003e results in \u003cem\u003eundefined behaviour\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e a function may be declared as \u003ccode\u003e[[noreturn]]\u003c/code\u003e when:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e It only exits by throwing an exception; or \u003c/li\u003e\n  \u003cli\u003e It loops endlessly; or \u003c/li\u003e\n  \u003cli\u003e It causes program termination. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\n[[noreturn]] void kill_the_process()   // Compliant\n{\n  std::abort();                        // Note - std::abort is also [[noreturn]]\n}\n\n[[noreturn]] void throw_some()         // Compliant - only exits with an exception\n{\n  throw 42;\n}\n\n[[noreturn]] void g( bool b )          // Non-compliant - returns if \u0027b\u0027 is false\n{\n  if ( b )\n  {\n    throw std::exception{};\n  }\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S5267} targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2023 Rule\u0026nbsp;6.2.2 - All \u003cem\u003edeclarations\u003c/em\u003e of a variable or function shall have the same type \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 9.6.4\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Undecidable,System\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eLeaving a function as the result of an exception is not a return.\u003c/p\u003e\n\u003cp\u003eA function’s compliance with this rule is determined independently of the context in which the function is called. For example, a boolean parameter\nis treated as if it may have a value of \u003ccode\u003etrue\u003c/code\u003e or \u003ccode\u003efalse\u003c/code\u003e, even if all the calls expressed in the current program use a value of\n\u003ccode\u003etrue\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eReturning from a function declared as \u003ccode\u003e[[noreturn]]\u003c/code\u003e results in \u003cem\u003eundefined behaviour\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e a function may be declared as \u003ccode\u003e[[noreturn]]\u003c/code\u003e when:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e It only exits by throwing an exception; or \u003c/li\u003e\n  \u003cli\u003e It loops endlessly; or \u003c/li\u003e\n  \u003cli\u003e It causes program termination. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\n[[noreturn]] void kill_the_process()   // Compliant\n{\n  std::abort();                        // Note - std::abort is also [[noreturn]]\n}\n\n[[noreturn]] void throw_some()         // Compliant - only exits with an exception\n{\n  throw 42;\n}\n\n[[noreturn]] void g( bool b )          // Non-compliant - returns if \u0027b\u0027 is false\n{\n  if ( b )\n  {\n    throw std::exception{};\n  }\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S5267} targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2023 Rule\u0026nbsp;6.2.2 - All \u003cem\u003edeclarations\u003c/em\u003e of a variable or function shall have the same type \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "confusing",
      "misra-c++2023",
      "misra-required"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:M23_239",
    "name": "A comparison of a \"potentially virtual\" pointer to member function shall only be with \"nullptr\"",
    "defaultSeverity": "BLOCKER",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 13.3.4\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eA pointer to member function is \u003cem\u003epotentially virtual\u003c/em\u003e if it is:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e A compile-time constant that points to a virtual member function; or \u003c/li\u003e\n  \u003cli\u003e A pointer to member function of a class that is incomplete at the end of the translation unit; or \u003c/li\u003e\n  \u003cli\u003e Not a compile-time constant pointer to member function and has a type matching that of a virtual member function of its class. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eThe result of comparing a pointer to member function that points to a virtual function with anything other than \u003ccode\u003enullptr\u003c/code\u003e is\nunspecified.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nclass A\n{\npublic:\n          void f1();\n          void f2();\n  virtual void f3();\n};\n\nvoid foo()\n{\n  if ( \u0026amp;A::f1 !\u003d \u0026amp;A::f2  ) {}   // Compliant\n  if ( \u0026amp;A::f1 !\u003d nullptr ) {}   // Compliant\n  if ( \u0026amp;A::f3 \u003d\u003d \u0026amp;A::f2  ) {}   // Non-compliant - f3 virtual\n  if ( \u0026amp;A::f3 \u003d\u003d nullptr ) {}   // Compliant\n}\n\nvoid bar( void ( A::*ptr )() )\n{\n  if ( ptr \u003d\u003d \u0026amp;A::f2 ) {}       // Non-compliant - ptr potentially points to A::f3,\n                                // which is virtual\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e the example above would be compliant if \u003ccode\u003eA\u003c/code\u003e had no virtual members.\u003c/p\u003e\n\u003cpre\u003e\nclass B\n{\npublic:\n          void f1();\n          void f2();\n  virtual void f3( int32_t i );\n};\n\nvoid bar( void ( B::*ptr )() )\n{\n  if ( ptr \u003d\u003d \u0026amp;B::f2 ) {}       // Compliant - there are no virtual functions\n                                // in B with the appropriate signature\n}\n\nclass D: public A               // Inherits virtual functions from A\n{\npublic:\n  void f4();\n};\n\nvoid car( void ( D::*ptr )() )\n{\n  if ( ptr \u003d\u003d \u0026amp;D::f4 ) {}       // Non-compliant - ptr potentially points to A::f3,\n                                // which is virtual\n}\n\nstruct E;\n\nvoid foo ( void ( E::*p1 )(), void ( E::*p2 )() )\n{\n  if ( p1 \u003d\u003d p2 ) {}            // Non-compliant - \u0027E\u0027 is incomplete, so it is\n                                // unknown if the pointers are to virtual members\n}\n\n// The following definition of E anywhere in the translation\n// unit would make the above example compliant\n// struct E{ void f1(); void f2(); };\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 13.3.4\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eA pointer to member function is \u003cem\u003epotentially virtual\u003c/em\u003e if it is:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e A compile-time constant that points to a virtual member function; or \u003c/li\u003e\n  \u003cli\u003e A pointer to member function of a class that is incomplete at the end of the translation unit; or \u003c/li\u003e\n  \u003cli\u003e Not a compile-time constant pointer to member function and has a type matching that of a virtual member function of its class. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eThe result of comparing a pointer to member function that points to a virtual function with anything other than \u003ccode\u003enullptr\u003c/code\u003e is\nunspecified.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nclass A\n{\npublic:\n          void f1();\n          void f2();\n  virtual void f3();\n};\n\nvoid foo()\n{\n  if ( \u0026amp;A::f1 !\u003d \u0026amp;A::f2  ) {}   // Compliant\n  if ( \u0026amp;A::f1 !\u003d nullptr ) {}   // Compliant\n  if ( \u0026amp;A::f3 \u003d\u003d \u0026amp;A::f2  ) {}   // Non-compliant - f3 virtual\n  if ( \u0026amp;A::f3 \u003d\u003d nullptr ) {}   // Compliant\n}\n\nvoid bar( void ( A::*ptr )() )\n{\n  if ( ptr \u003d\u003d \u0026amp;A::f2 ) {}       // Non-compliant - ptr potentially points to A::f3,\n                                // which is virtual\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e the example above would be compliant if \u003ccode\u003eA\u003c/code\u003e had no virtual members.\u003c/p\u003e\n\u003cpre\u003e\nclass B\n{\npublic:\n          void f1();\n          void f2();\n  virtual void f3( int32_t i );\n};\n\nvoid bar( void ( B::*ptr )() )\n{\n  if ( ptr \u003d\u003d \u0026amp;B::f2 ) {}       // Compliant - there are no virtual functions\n                                // in B with the appropriate signature\n}\n\nclass D: public A               // Inherits virtual functions from A\n{\npublic:\n  void f4();\n};\n\nvoid car( void ( D::*ptr )() )\n{\n  if ( ptr \u003d\u003d \u0026amp;D::f4 ) {}       // Non-compliant - ptr potentially points to A::f3,\n                                // which is virtual\n}\n\nstruct E;\n\nvoid foo ( void ( E::*p1 )(), void ( E::*p2 )() )\n{\n  if ( p1 \u003d\u003d p2 ) {}            // Non-compliant - \u0027E\u0027 is incomplete, so it is\n                                // unknown if the pointers are to virtual members\n}\n\n// The following definition of E anywhere in the translation\n// unit would make the above example compliant\n// struct E{ void f1(); void f2(); };\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "misra-c++2023",
      "misra-required",
      "suspicious",
      "unpredictable"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:M23_112",
    "name": "All \"if ... else if\" constructs shall be terminated with an \"else\" statement",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 9.4.1\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eA final \u003ccode\u003eelse\u003c/code\u003e shall always be provided whenever an \u003ccode\u003eif\u003c/code\u003e statement is followed by a sequence of one or more \u003ccode\u003eelse\nif\u003c/code\u003e constructs.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e a final \u003ccode\u003eelse\u003c/code\u003e statement is not required for a simple \u003ccode\u003eif\u003c/code\u003e statement.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eTerminating a sequence of \u003ccode\u003eif ... else if\u003c/code\u003e constructs with an \u003ccode\u003eelse\u003c/code\u003e statement is defensive programming, complementing the\nrequirement for a \u003ccode\u003edefault\u003c/code\u003e clause in a \u003ccode\u003eswitch\u003c/code\u003e statement (see MISRA C++ 2023 Rule\u0026nbsp;9.4.2 (The structure of a\n\u003ccode\u003eswitch\u003c/code\u003e statement shall be appropriate)).\u003c/p\u003e\n\u003cp\u003eThe addition of an \u003ccode\u003eelse\u003c/code\u003e statement, even when empty, indicates that consideration has been given regarding the behaviour when all other\nconditions evaluate to \u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nvoid f1( bool flag_1, bool flag_2 )\n{\n  if ( flag_1 )\n  {\n    action_1();\n  }\n  else if ( flag_2 )\n  {\n    action_2();\n  }                     // Non-compliant\n}\n\nvoid f2(bool flag_1, bool flag_2)\n{\n  if ( flag_1 )\n  {\n    action_1();\n  }\n  else if ( flag_2 )\n  {\n    action_2();\n  }\n  else                  // Compliant\n  {\n  }\n}\n\nvoid f3( bool flag )\n{\n  if ( flag )\n  {\n    action_1();\n  }                     // Simple \u0027if\u0027 - rule does not apply\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S5307} targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2023 Rule\u0026nbsp;9.4.2 - The structure of a \u003ccode\u003eswitch\u003c/code\u003e statement shall be appropriate \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 9.4.1\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eA final \u003ccode\u003eelse\u003c/code\u003e shall always be provided whenever an \u003ccode\u003eif\u003c/code\u003e statement is followed by a sequence of one or more \u003ccode\u003eelse\nif\u003c/code\u003e constructs.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e a final \u003ccode\u003eelse\u003c/code\u003e statement is not required for a simple \u003ccode\u003eif\u003c/code\u003e statement.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eTerminating a sequence of \u003ccode\u003eif ... else if\u003c/code\u003e constructs with an \u003ccode\u003eelse\u003c/code\u003e statement is defensive programming, complementing the\nrequirement for a \u003ccode\u003edefault\u003c/code\u003e clause in a \u003ccode\u003eswitch\u003c/code\u003e statement (see MISRA C++ 2023 Rule\u0026nbsp;9.4.2 (The structure of a\n\u003ccode\u003eswitch\u003c/code\u003e statement shall be appropriate)).\u003c/p\u003e\n\u003cp\u003eThe addition of an \u003ccode\u003eelse\u003c/code\u003e statement, even when empty, indicates that consideration has been given regarding the behaviour when all other\nconditions evaluate to \u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nvoid f1( bool flag_1, bool flag_2 )\n{\n  if ( flag_1 )\n  {\n    action_1();\n  }\n  else if ( flag_2 )\n  {\n    action_2();\n  }                     // Non-compliant\n}\n\nvoid f2(bool flag_1, bool flag_2)\n{\n  if ( flag_1 )\n  {\n    action_1();\n  }\n  else if ( flag_2 )\n  {\n    action_2();\n  }\n  else                  // Compliant\n  {\n  }\n}\n\nvoid f3( bool flag )\n{\n  if ( flag )\n  {\n    action_1();\n  }                     // Simple \u0027if\u0027 - rule does not apply\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S5307} targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2023 Rule\u0026nbsp;9.4.2 - The structure of a \u003ccode\u003eswitch\u003c/code\u003e statement shall be appropriate \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "misra-c++2023",
      "misra-required"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:M23_233",
    "name": "Local variables shall not have static storage duration",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 6.7.1\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eThis rule does not apply to variables declared \u003ccode\u003econstexpr\u003c/code\u003e or \u003ccode\u003econst\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eThe use of mutable variables with static storage duration, even when they do not have linkage, potentially results in hidden temporal coupling.\nThis can lead to data races (and thus \u003cem\u003eundefined behaviour\u003c/em\u003e). Additionally, functions with persistent state are usually more difficult to\nunderstand and test.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e the lifetime of local variables with static storage duration ends at program termination in the reverse order of their\ncreation. Suitable care should be taken to ensure that the code executed during destruction does not access a previously destroyed variable.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nint32_t bar();\n\nint32_t ga \u003d 0;                         // Compliant - but violates \"See also\"\n\nint32_t foo()\n{\n                   int32_t a \u003d 0;       // Compliant\n  static           int32_t b \u003d 0;       // Non-compliant\n  static constexpr int32_t c \u003d 0;       // Compliant\n  static const     int32_t d \u003d bar();   // Compliant\n}\n\nclass Application\n{\n  static Application \u0026amp; theApp()\n  {\n    static Application app;             // Non-compliant\n\n    return app;\n  }\n};\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S6018} targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:M23_388}: MISRA C++ 2023 Rule\u0026nbsp;6.7.2 - \u003cem\u003eGlobal variables\u003c/em\u003e shall not be used \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 6.7.1\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eThis rule does not apply to variables declared \u003ccode\u003econstexpr\u003c/code\u003e or \u003ccode\u003econst\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eThe use of mutable variables with static storage duration, even when they do not have linkage, potentially results in hidden temporal coupling.\nThis can lead to data races (and thus \u003cem\u003eundefined behaviour\u003c/em\u003e). Additionally, functions with persistent state are usually more difficult to\nunderstand and test.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e the lifetime of local variables with static storage duration ends at program termination in the reverse order of their\ncreation. Suitable care should be taken to ensure that the code executed during destruction does not access a previously destroyed variable.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nint32_t bar();\n\nint32_t ga \u003d 0;                         // Compliant - but violates \"See also\"\n\nint32_t foo()\n{\n                   int32_t a \u003d 0;       // Compliant\n  static           int32_t b \u003d 0;       // Non-compliant\n  static constexpr int32_t c \u003d 0;       // Compliant\n  static const     int32_t d \u003d bar();   // Compliant\n}\n\nclass Application\n{\n  static Application \u0026amp; theApp()\n  {\n    static Application app;             // Non-compliant\n\n    return app;\n  }\n};\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S6018} targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:M23_388}: MISRA C++ 2023 Rule\u0026nbsp;6.7.2 - \u003cem\u003eGlobal variables\u003c/em\u003e shall not be used \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "confusing",
      "misra-c++2023",
      "misra-required",
      "unpredictable"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:M23_355",
    "name": "The \"setlocale\" and \"std::locale::global\" functions shall not be called",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 25.5.1\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eCalls to \u003ccode\u003esetlocale\u003c/code\u003e or \u003ccode\u003estd::locale::global\u003c/code\u003e may introduce data races (leading to \u003cem\u003eundefined behaviour\u003c/em\u003e) with\nfunctions that use the locale (e.g. \u003ccode\u003eprintf\u003c/code\u003e, \u003ccode\u003etolower\u003c/code\u003e). It is not as easy to guard against these potential data races due to\nthe ways in which the global locale is used within the C++ Standard Library.\u003c/p\u003e\n\u003cp\u003eThe C++ Standard Library provides functions that allow a locale to be passed as an argument, meaning that it is possible to use a specific locale\nwithout having to depend on the setting of the global locale objects.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nvoid f1()\n{\n  wchar_t c \u003d L\u0027\\u2002\u0027;                     // En-space\n\n  std::setlocale( LC_ALL, \"ja_JP.utf8\" );    // Non-compliant\n\n  if ( std::isspace( c ) ) {}                // Uses global locale\n}\n\u003c/pre\u003e\n\u003cp\u003eThe following example sets the locale without violating this rule:\u003c/p\u003e\n\u003cpre\u003e\nvoid f2()\n{\n  wchar_t c \u003d L\u0027\\u2002\u0027;                     // En-space\n\n  std::locale utf8( \"ja_JP.utf8\" );\n\n  if ( std::isspace( c, utf8 ) ) {}          // Does not use global locale\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 25.5.1\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eCalls to \u003ccode\u003esetlocale\u003c/code\u003e or \u003ccode\u003estd::locale::global\u003c/code\u003e may introduce data races (leading to \u003cem\u003eundefined behaviour\u003c/em\u003e) with\nfunctions that use the locale (e.g. \u003ccode\u003eprintf\u003c/code\u003e, \u003ccode\u003etolower\u003c/code\u003e). It is not as easy to guard against these potential data races due to\nthe ways in which the global locale is used within the C++ Standard Library.\u003c/p\u003e\n\u003cp\u003eThe C++ Standard Library provides functions that allow a locale to be passed as an argument, meaning that it is possible to use a specific locale\nwithout having to depend on the setting of the global locale objects.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nvoid f1()\n{\n  wchar_t c \u003d L\u0027\\u2002\u0027;                     // En-space\n\n  std::setlocale( LC_ALL, \"ja_JP.utf8\" );    // Non-compliant\n\n  if ( std::isspace( c ) ) {}                // Uses global locale\n}\n\u003c/pre\u003e\n\u003cp\u003eThe following example sets the locale without violating this rule:\u003c/p\u003e\n\u003cpre\u003e\nvoid f2()\n{\n  wchar_t c \u003d L\u0027\\u2002\u0027;                     // En-space\n\n  std::locale utf8( \"ja_JP.utf8\" );\n\n  if ( std::isspace( c, utf8 ) ) {}          // Does not use global locale\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "misra-c++2023",
      "misra-required",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:M23_235",
    "name": "Variables should be captured explicitly in a non-\"transient lambda\"",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 8.1.2\u003c/p\u003e\n\u003cp\u003eCategory: Advisory\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eThis rule applies to capture by value and capture by reference.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eNaming the variables captured by a lambda expression clarifies its dependencies. This allows variables captured by reference and pointers captured\nby value to be more easily identified, helping to ensure that they are not dangling when the lambda is called.\u003c/p\u003e\n\u003cp\u003eThis issue cannot occur for a \u003cem\u003etransient lambda\u003c/em\u003e [1], so there is no need to explicitly capture its variables.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nvoid bar( double val, double min, double max )\n{\n  auto const easedVal \u003d [\u0026amp;]()\n  {\n    if ( val \u0026lt; min ) { return ( val + min ) / 2; }\n    if ( val \u0026gt; max ) { return ( val + max ) / 2; }\n    return val;\n  }();                                          // Compliant - called immediately\n\n  auto const ease \u003d [\u0026amp;]()\n  {\n    if ( val \u0026lt; min ) { return ( val + min ) / 2; }\n    if ( val \u0026gt; max ) { return ( val + max ) / 2; }\n    return val;\n  };                                            // Non-compliant\n  ease();                                       //   - not an immediate call\n}\n\ntemplate\u0026lt; typename It, typename Func \u0026gt;\nbool f1( It b, It e, Func f )                   // f1 does not store f\n{\n  for ( It it \u003d b; it !\u003d e; ++it )\n  {\n    if ( f( *it ) )                             // f is called\n    {\n      return true;\n    }\n  }\n\n  return false;\n}\n\ntemplate\u0026lt; typename Cont, typename Func \u0026gt;\nbool f2( Cont const \u0026amp; c, Func f )               // f2 does not store f\n{\n  return f1( std::begin(c), std::end(c), f );   // f passed to non-storing function\n}\n\nvoid foo( std::vector\u0026lt; size_t \u0026gt; const \u0026amp; v, size_t i )\n{\n  bool b1 \u003d f1( v.cbegin(), v.cend(),\n                [\u0026amp;]( size_t elem ) { return elem \u003d\u003d i; } );  // Compliant\n  bool b2 \u003d f2( v,\n                [\u0026amp;]( size_t elem ) { return elem \u003d\u003d i; } );  // Compliant\n}\n\nstruct Speedometer\n{\n  std::vector\u0026lt; std::function\u0026lt; void ( double ) \u0026gt; \u0026gt; observers;\n\n  template\u0026lt; typename Func \u0026gt;\n  void addObserver( Func f )                    // addObserver stores f\n  {\n    observers.push_back( f );                   // Copying f to the std::function\n  }\n};\n\n\nvoid process( std::function\u0026lt; Speedometer() \u0026gt; );\n\nauto f3()\n{\n  Speedometer s;\n\n  process( [\u0026amp;](){ return s; } );                // Non-compliant - conversion to\n                                                //  std::function stores the lambda\n  return [\u003d]() { return s; };                   // Non-compliant - implicit capture\n}\n\n\nvoid addLoggers( Speedometer s, std::ostream \u0026amp; os )\n{\n  s.addObserver( [\u0026amp;]( double speed )            // Non-compliant - implicit capture\n                 { os \u0026lt;\u0026lt; speed; });\n  s.addObserver( [\u0026amp;os]( double speed )          // Compliant - explicit capture\n                 { os \u0026lt;\u0026lt; speed; } );\n  s.addObserver( []( double speed )             // Compliant - no capture\n                 { std::cout \u0026lt;\u0026lt; speed; } );\n}\n\u003c/pre\u003e\n\u003ch3\u003eGlossary\u003c/h3\u003e\n\u003ch4\u003e[1] Transient lambda\u003c/h4\u003e\n\u003cp\u003eA lambda is \u003cem\u003etransient\u003c/em\u003e when:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e It is immediately invoked; or \u003c/li\u003e\n  \u003cli\u003e It is passed to a function that does not \u003cem\u003estore\u003c/em\u003e it. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eA function does not \u003cem\u003estore\u003c/em\u003e a lambda when:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The function is defined in the same \u003cem\u003etranslation unit\u003c/em\u003e as the lambda; and \u003c/li\u003e\n  \u003cli\u003e The lambda is only copied or moved when it is passed as an argument; and \u003c/li\u003e\n  \u003cli\u003e The function only calls the lambda and/or passes the lambda to another function that does not \u003cem\u003estore\u003c/em\u003e it. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S3608} targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:M23_394}: MISRA C++ 2023 Rule\u0026nbsp;8.1.1 ensures that \u003ccode\u003ethis\u003c/code\u003e is not implicit captured in non-transient lambda \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 8.1.2\u003c/p\u003e\n\u003cp\u003eCategory: Advisory\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eThis rule applies to capture by value and capture by reference.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eNaming the variables captured by a lambda expression clarifies its dependencies. This allows variables captured by reference and pointers captured\nby value to be more easily identified, helping to ensure that they are not dangling when the lambda is called.\u003c/p\u003e\n\u003cp\u003eThis issue cannot occur for a \u003cem\u003etransient lambda\u003c/em\u003e [1], so there is no need to explicitly capture its variables.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nvoid bar( double val, double min, double max )\n{\n  auto const easedVal \u003d [\u0026amp;]()\n  {\n    if ( val \u0026lt; min ) { return ( val + min ) / 2; }\n    if ( val \u0026gt; max ) { return ( val + max ) / 2; }\n    return val;\n  }();                                          // Compliant - called immediately\n\n  auto const ease \u003d [\u0026amp;]()\n  {\n    if ( val \u0026lt; min ) { return ( val + min ) / 2; }\n    if ( val \u0026gt; max ) { return ( val + max ) / 2; }\n    return val;\n  };                                            // Non-compliant\n  ease();                                       //   - not an immediate call\n}\n\ntemplate\u0026lt; typename It, typename Func \u0026gt;\nbool f1( It b, It e, Func f )                   // f1 does not store f\n{\n  for ( It it \u003d b; it !\u003d e; ++it )\n  {\n    if ( f( *it ) )                             // f is called\n    {\n      return true;\n    }\n  }\n\n  return false;\n}\n\ntemplate\u0026lt; typename Cont, typename Func \u0026gt;\nbool f2( Cont const \u0026amp; c, Func f )               // f2 does not store f\n{\n  return f1( std::begin(c), std::end(c), f );   // f passed to non-storing function\n}\n\nvoid foo( std::vector\u0026lt; size_t \u0026gt; const \u0026amp; v, size_t i )\n{\n  bool b1 \u003d f1( v.cbegin(), v.cend(),\n                [\u0026amp;]( size_t elem ) { return elem \u003d\u003d i; } );  // Compliant\n  bool b2 \u003d f2( v,\n                [\u0026amp;]( size_t elem ) { return elem \u003d\u003d i; } );  // Compliant\n}\n\nstruct Speedometer\n{\n  std::vector\u0026lt; std::function\u0026lt; void ( double ) \u0026gt; \u0026gt; observers;\n\n  template\u0026lt; typename Func \u0026gt;\n  void addObserver( Func f )                    // addObserver stores f\n  {\n    observers.push_back( f );                   // Copying f to the std::function\n  }\n};\n\n\nvoid process( std::function\u0026lt; Speedometer() \u0026gt; );\n\nauto f3()\n{\n  Speedometer s;\n\n  process( [\u0026amp;](){ return s; } );                // Non-compliant - conversion to\n                                                //  std::function stores the lambda\n  return [\u003d]() { return s; };                   // Non-compliant - implicit capture\n}\n\n\nvoid addLoggers( Speedometer s, std::ostream \u0026amp; os )\n{\n  s.addObserver( [\u0026amp;]( double speed )            // Non-compliant - implicit capture\n                 { os \u0026lt;\u0026lt; speed; });\n  s.addObserver( [\u0026amp;os]( double speed )          // Compliant - explicit capture\n                 { os \u0026lt;\u0026lt; speed; } );\n  s.addObserver( []( double speed )             // Compliant - no capture\n                 { std::cout \u0026lt;\u0026lt; speed; } );\n}\n\u003c/pre\u003e\n\u003ch3\u003eGlossary\u003c/h3\u003e\n\u003ch4\u003e[1] Transient lambda\u003c/h4\u003e\n\u003cp\u003eA lambda is \u003cem\u003etransient\u003c/em\u003e when:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e It is immediately invoked; or \u003c/li\u003e\n  \u003cli\u003e It is passed to a function that does not \u003cem\u003estore\u003c/em\u003e it. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eA function does not \u003cem\u003estore\u003c/em\u003e a lambda when:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The function is defined in the same \u003cem\u003etranslation unit\u003c/em\u003e as the lambda; and \u003c/li\u003e\n  \u003cli\u003e The lambda is only copied or moved when it is passed as an argument; and \u003c/li\u003e\n  \u003cli\u003e The function only calls the lambda and/or passes the lambda to another function that does not \u003cem\u003estore\u003c/em\u003e it. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S3608} targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:M23_394}: MISRA C++ 2023 Rule\u0026nbsp;8.1.1 ensures that \u003ccode\u003ethis\u003c/code\u003e is not implicit captured in non-transient lambda \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "misra-advisory",
      "misra-c++2023",
      "pitfall",
      "since-c++11"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:M23_356",
    "name": "Variables of array type should not be declared",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 11.3.1\u003c/p\u003e\n\u003cp\u003eCategory: Advisory\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eA variable of array type does not have value semantics and its size has to be managed separately. It is possible to use types that do not have\nthese limitations. For example:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003estd::array\u003c/code\u003e — provides value semantics and manages the size; \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003estd::string_view\u003c/code\u003e — manages the size. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eException\u003c/h3\u003e\n\u003cp\u003eThe declaration of an array of \u003cem\u003econst\u003c/em\u003e character type is permitted when it is immediately initialized with a string literal.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nvoid foo() noexcept\n{\n  const size_t                     size { 10 };\n        wchar_t                    a1 [ size ];  // Non-compliant\n        std::array\u0026lt; wchar_t, size \u0026gt; a2;          // Compliant\n}\n\nvoid bar( int      a[ 10 ],    // Rule does not apply - pointer to int\n          int ( \u0026amp;b )[ 10 ],    // Rule does not apply - reference to array\n          int ( *c )[ 10 ])    // Rule does not apply - pointer to array\n{\n}\n\nstruct S\n{\n  std::uint16_t a3[ 10 ];                        // Non-compliant\n};\n\nusing namespace std::literals;\n\nconst char s1[] \u003d \"abcd\";                        // Compliant by exception\n      char s2[] \u003d \"abcd\";                        // Non-compliant\nconst auto best \u003d \"abcd\"sv;                      // Compliant\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S5945} targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2023 Rule\u0026nbsp;7.11.2 - An array passed as a function argument shall not decay to a pointer \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cp\u003e\u003ca\nhref\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/036324/CppCoreGuidelines.md#slcon1-prefer-using-stl-array-or-vector-instead-of-a-c-array\"\u003eC++\nCore Guidelines SL.con.1\u003c/a\u003e - Prefer using STL array or vector instead of a C array\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 11.3.1\u003c/p\u003e\n\u003cp\u003eCategory: Advisory\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eA variable of array type does not have value semantics and its size has to be managed separately. It is possible to use types that do not have\nthese limitations. For example:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003estd::array\u003c/code\u003e — provides value semantics and manages the size; \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003estd::string_view\u003c/code\u003e — manages the size. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eException\u003c/h3\u003e\n\u003cp\u003eThe declaration of an array of \u003cem\u003econst\u003c/em\u003e character type is permitted when it is immediately initialized with a string literal.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nvoid foo() noexcept\n{\n  const size_t                     size { 10 };\n        wchar_t                    a1 [ size ];  // Non-compliant\n        std::array\u0026lt; wchar_t, size \u0026gt; a2;          // Compliant\n}\n\nvoid bar( int      a[ 10 ],    // Rule does not apply - pointer to int\n          int ( \u0026amp;b )[ 10 ],    // Rule does not apply - reference to array\n          int ( *c )[ 10 ])    // Rule does not apply - pointer to array\n{\n}\n\nstruct S\n{\n  std::uint16_t a3[ 10 ];                        // Non-compliant\n};\n\nusing namespace std::literals;\n\nconst char s1[] \u003d \"abcd\";                        // Compliant by exception\n      char s2[] \u003d \"abcd\";                        // Non-compliant\nconst auto best \u003d \"abcd\"sv;                      // Compliant\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S5945} targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2023 Rule\u0026nbsp;7.11.2 - An array passed as a function argument shall not decay to a pointer \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cp\u003e\u003ca\nhref\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/036324/CppCoreGuidelines.md#slcon1-prefer-using-stl-array-or-vector-instead-of-a-c-array\"\u003eC++\nCore Guidelines SL.con.1\u003c/a\u003e - Prefer using STL array or vector instead of a C array\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "clumsy",
      "misra-advisory",
      "misra-c++2023"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:M23_360",
    "name": "An object shall not be accessed outside of its lifetime",
    "defaultSeverity": "CRITICAL",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 6.8.1\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Undecidable,System\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eTechnically, a C++ object does not exist outside of its lifetime. However, for the purposes of this rule, a violation occurs whenever a memory\nlocation that does not contain a live object of an appropriate type is accessed.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eIt is \u003cem\u003eundefined behaviour\u003c/em\u003e to access an object before it has been initialized or after its lifetime has ended (even if the memory occupied\nby the object has not been released).\u003c/p\u003e\n\u003cp\u003eIt is possible to refer to an object before its lifetime has begun, for example, by referring to a non-active member of a union.\u003c/p\u003e\n\u003cp\u003eCompliance with the rules cross-referenced by this rule helps to prevent lifetime violations.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nstruct X\n{\n  void doSomething() {}\n};\n\nvoid h( X * px )\n{\n  px-\u0026gt;~X();                           // End the lifetime of *px\n  px-\u0026gt;doSomething();                  // Non-compliant\n}\n\nvoid g()\n{\n  X a{};\n  auto \u0026amp; b \u003d ( X{} \u003d a );             // Immediate dangling of b\n  b.doSomething();                    // Non-compliant\n}\n\nvoid f()\n{\n  int32_t * pi \u003d new int32_t { 42 };\n\n  delete pi;\n  std::cout \u0026lt;\u0026lt; *pi;                   // Non-compliant\n}\n\nunion u\n{\n  int32_t  a;\n  uint16_t b[ 2 ];\n};\n\nuint16_t u2()\n{\n  u o;\n\n  o.a \u003d 42;\n  return o.b[ 0 ];                    // Non-compliant - b is not the active member\n}\n\u003c/pre\u003e\n\u003cp\u003eSee the cross-referenced rules for further examples.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S946}, {rule:cpp:S3529}, {rule:cpp:S5553}, {rule:cpp:S6655} target the same defect as this rule but for a non-mission-critical\n  context. \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S6232} detects type-punning performed by accessing inactive member of the union. \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:M23_388}: MISRA C++ 2023 Rule\u0026nbsp;6.7.2 - \u003cem\u003eGlobal variables\u003c/em\u003e shall not be used \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2023 Rule\u0026nbsp;6.8.2 - A function must not return a reference or a pointer to a local variable with automatic storage duration \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2023 Rule\u0026nbsp;6.8.3 - An assignment operator shall not assign the address of an object with automatic storage duration to an object\n  with a greater lifetime \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2023 Rule\u0026nbsp;6.8.4 - Member functions returning references to their object should be \u003cem\u003eref-qualified\u003c/em\u003e appropriately \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2023 Rule\u0026nbsp;9.5.2 - A \u003cem\u003efor-range-initializer\u003c/em\u003e shall contain at most one function call \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:M23_158}: MISRA C++ 2023 Rule\u0026nbsp;12.3.1 - The \u003ccode\u003eunion\u003c/code\u003e keyword shall not be used \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:M23_194}: MISRA C++ 2023 Rule\u0026nbsp;18.3.3 - Handlers for a \u003cem\u003efunction-try-block\u003c/em\u003e of a constructor or destructor shall not refer\n  to non-static members from their class or its bases \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/416\"\u003eMITRE, CWE-416\u003c/a\u003e - Use After Free \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/GdYxBQ\"\u003eCERT, MEM30-C.\u003c/a\u003e - Do not access freed memory \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/onw-BQ\"\u003eCERT, MEM50-CPP.\u003c/a\u003e - Do not access freed memory \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/OXw-BQ\"\u003eCERT, EXP54-CPP.\u003c/a\u003e - Do not access an object outside of its lifetime \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/display/c/DCL30-C.+Declare+objects+with+appropriate+storage+durations\"\u003eCERT, DCL30-C\u003c/a\u003e - Declare\n  objects with appropriate storage durations \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 6.8.1\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Undecidable,System\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eTechnically, a C++ object does not exist outside of its lifetime. However, for the purposes of this rule, a violation occurs whenever a memory\nlocation that does not contain a live object of an appropriate type is accessed.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eIt is \u003cem\u003eundefined behaviour\u003c/em\u003e to access an object before it has been initialized or after its lifetime has ended (even if the memory occupied\nby the object has not been released).\u003c/p\u003e\n\u003cp\u003eIt is possible to refer to an object before its lifetime has begun, for example, by referring to a non-active member of a union.\u003c/p\u003e\n\u003cp\u003eCompliance with the rules cross-referenced by this rule helps to prevent lifetime violations.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nstruct X\n{\n  void doSomething() {}\n};\n\nvoid h( X * px )\n{\n  px-\u0026gt;~X();                           // End the lifetime of *px\n  px-\u0026gt;doSomething();                  // Non-compliant\n}\n\nvoid g()\n{\n  X a{};\n  auto \u0026amp; b \u003d ( X{} \u003d a );             // Immediate dangling of b\n  b.doSomething();                    // Non-compliant\n}\n\nvoid f()\n{\n  int32_t * pi \u003d new int32_t { 42 };\n\n  delete pi;\n  std::cout \u0026lt;\u0026lt; *pi;                   // Non-compliant\n}\n\nunion u\n{\n  int32_t  a;\n  uint16_t b[ 2 ];\n};\n\nuint16_t u2()\n{\n  u o;\n\n  o.a \u003d 42;\n  return o.b[ 0 ];                    // Non-compliant - b is not the active member\n}\n\u003c/pre\u003e\n\u003cp\u003eSee the cross-referenced rules for further examples.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S946}, {rule:cpp:S3529}, {rule:cpp:S5553}, {rule:cpp:S6655} target the same defect as this rule but for a non-mission-critical\n  context. \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S6232} detects type-punning performed by accessing inactive member of the union. \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:M23_388}: MISRA C++ 2023 Rule\u0026nbsp;6.7.2 - \u003cem\u003eGlobal variables\u003c/em\u003e shall not be used \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2023 Rule\u0026nbsp;6.8.2 - A function must not return a reference or a pointer to a local variable with automatic storage duration \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2023 Rule\u0026nbsp;6.8.3 - An assignment operator shall not assign the address of an object with automatic storage duration to an object\n  with a greater lifetime \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2023 Rule\u0026nbsp;6.8.4 - Member functions returning references to their object should be \u003cem\u003eref-qualified\u003c/em\u003e appropriately \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2023 Rule\u0026nbsp;9.5.2 - A \u003cem\u003efor-range-initializer\u003c/em\u003e shall contain at most one function call \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:M23_158}: MISRA C++ 2023 Rule\u0026nbsp;12.3.1 - The \u003ccode\u003eunion\u003c/code\u003e keyword shall not be used \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:M23_194}: MISRA C++ 2023 Rule\u0026nbsp;18.3.3 - Handlers for a \u003cem\u003efunction-try-block\u003c/em\u003e of a constructor or destructor shall not refer\n  to non-static members from their class or its bases \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/416\"\u003eMITRE, CWE-416\u003c/a\u003e - Use After Free \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/GdYxBQ\"\u003eCERT, MEM30-C.\u003c/a\u003e - Do not access freed memory \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/onw-BQ\"\u003eCERT, MEM50-CPP.\u003c/a\u003e - Do not access freed memory \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/OXw-BQ\"\u003eCERT, EXP54-CPP.\u003c/a\u003e - Do not access an object outside of its lifetime \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/display/c/DCL30-C.+Declare+objects+with+appropriate+storage+durations\"\u003eCERT, DCL30-C\u003c/a\u003e - Declare\n  objects with appropriate storage durations \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "misra-c++2023",
      "misra-required",
      "unpredictable"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5356",
    "name": "An object with pointer type shall not be converted to an unrelated pointer type, either directly or indirectly",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThis rule is a strict implementation of a MISRA (Motor Industry Software Reliability Association) rule. MISRA defines best practices for developing\nsafety-critical software. You can learn more about this rule in the MISRA documents referenced below.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++ 2008, 5-2-7 - An object with pointer type shall not be converted to an unrelated pointer type, either directly or indirectly. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThis rule is a strict implementation of a MISRA (Motor Industry Software Reliability Association) rule. MISRA defines best practices for developing\nsafety-critical software. You can learn more about this rule in the MISRA documents referenced below.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C++ 2008, 5-2-7 - An object with pointer type shall not be converted to an unrelated pointer type, either directly or indirectly. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "misra-c++2008",
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S892",
    "name": "A loop-control-variable other than the loop-counter which is modified in statement shall have type bool",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThis rule is a strict implementation of a MISRA (Motor Industry Software Reliability Association) rule. MISRA defines best practices for developing\nsafety-critical software. You can learn more about this rule in the MISRA documents referenced below.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++ 2008, 6-5-6 - A loop-control-variable other than the loop-counter which is modified in statement shall have type bool. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThis rule is a strict implementation of a MISRA (Motor Industry Software Reliability Association) rule. MISRA defines best practices for developing\nsafety-critical software. You can learn more about this rule in the MISRA documents referenced below.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C++ 2008, 6-5-6 - A loop-control-variable other than the loop-counter which is modified in statement shall have type bool. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "misra-c++2008"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5357",
    "name": "An object with integral type or pointer to void type shall not be converted to an object with pointer type",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThis rule is a strict implementation of a MISRA (Motor Industry Software Reliability Association) rule. MISRA defines best practices for developing\nsafety-critical software. You can learn more about this rule in the MISRA documents referenced below.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++ 2008, 5-2-8 - An object with integer type or pointer to void type shall not be converted to an object with pointer type. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThis rule is a strict implementation of a MISRA (Motor Industry Software Reliability Association) rule. MISRA defines best practices for developing\nsafety-critical software. You can learn more about this rule in the MISRA documents referenced below.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C++ 2008, 5-2-8 - An object with integer type or pointer to void type shall not be converted to an object with pointer type. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "misra-c++2008"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S4144",
    "name": "Methods should not have identical implementations",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "DISTINCT",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eTwo methods having the same implementation are suspicious. It might be that something else was intended. Or the duplication is intentional, which\nbecomes a maintenance burden.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nclass Circle : public Shape {\nprivate:\n  int radius;\npublic:\n  void setWidth(int size) {\n    radius \u003d size / 2;\n    updateShape();\n  }\n\n  void setHeight(int size) {  // Noncompliant: duplicates setWidth\n    radius \u003d size / 2;\n    updateShape();\n  }\n};\n\u003c/pre\u003e\n\u003cp\u003eIf the identical logic is intentional, the code should be refactored to avoid duplication. For example, by having both methods call the same method\nor by having one implementation invoke the other.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nclass Circle : public Shape {\nprivate:\n  int radius;\npublic:\n  void setWidth(int size) {\n    setDiameter(size);\n  }\n\n  void setHeight(int size) {\n    setDiameter(size);\n  }\n\nprivate:\n  void setDiameter(int size) { // Implementation is shared\n    radius \u003d size / 2;\n    updateShape();\n  }\n};\n\u003c/pre\u003e\n\u003cp\u003eThis rule raises an issue on methods and not free functions.\u003c/p\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eEmpty methods, methods with the same name (overload) and methods with only one statement are ignored.\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eTwo methods having the same implementation are suspicious. It might be that something else was intended. Or the duplication is intentional, which\nbecomes a maintenance burden.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nclass Circle : public Shape {\nprivate:\n  int radius;\npublic:\n  void setWidth(int size) {\n    radius \u003d size / 2;\n    updateShape();\n  }\n\n  void setHeight(int size) {  // Noncompliant: duplicates setWidth\n    radius \u003d size / 2;\n    updateShape();\n  }\n};\n\u003c/pre\u003e\n\u003cp\u003eIf the identical logic is intentional, the code should be refactored to avoid duplication. For example, by having both methods call the same method\nor by having one implementation invoke the other.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nclass Circle : public Shape {\nprivate:\n  int radius;\npublic:\n  void setWidth(int size) {\n    setDiameter(size);\n  }\n\n  void setHeight(int size) {\n    setDiameter(size);\n  }\n\nprivate:\n  void setDiameter(int size) { // Implementation is shared\n    radius \u003d size / 2;\n    updateShape();\n  }\n};\n\u003c/pre\u003e\n\u003cp\u003eThis rule raises an issue on methods and not free functions.\u003c/p\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eEmpty methods, methods with the same name (overload) and methods with only one statement are ignored.\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "confusing",
      "duplicate",
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S890",
    "name": "The loop-counter should be modified by one of: --, ++, -\u003dn, or +\u003dn; where n remains constant for the duration of the loop",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThis rule is a strict implementation of a MISRA (Motor Industry Software Reliability Association) rule. MISRA defines best practices for developing\nsafety-critical software. You can learn more about this rule in the MISRA documents referenced below.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++ 2008, 6-5-4 \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThis rule is a strict implementation of a MISRA (Motor Industry Software Reliability Association) rule. MISRA defines best practices for developing\nsafety-critical software. You can learn more about this rule in the MISRA documents referenced below.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C++ 2008, 6-5-4 \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "misra-c++2008",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5358",
    "name": "A cast should not convert a pointer type to an integral type",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThis rule is a strict implementation of a MISRA (Motor Industry Software Reliability Association) rule. MISRA defines best practices for developing\nsafety-critical software. You can learn more about this rule in the MISRA documents referenced below.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++ 2008, 5-2-9 - A cast should not convert a pointer type to an integral type. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThis rule is a strict implementation of a MISRA (Motor Industry Software Reliability Association) rule. MISRA defines best practices for developing\nsafety-critical software. You can learn more about this rule in the MISRA documents referenced below.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C++ 2008, 5-2-9 - A cast should not convert a pointer type to an integral type. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "misra-c++2008"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5359",
    "name": "Each operand of the ! operator, the logical \u0026\u0026 or the logical || operators shall have type bool",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThis rule is a strict implementation of a MISRA (Motor Industry Software Reliability Association) rule. MISRA defines best practices for developing\nsafety-critical software. You can learn more about this rule in the MISRA documents referenced below.\u003c/p\u003e\n\u003cp\u003eIf you are not concerned with MISRA compliance or with safety-critical software, you might consider using rule {rule:cpp:S867} instead ; it targets\nthe same kind of issue for general-purpose software.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 5-3-1 - Each operand of the ! operator, the logical \u0026amp;\u0026amp; or the logical || operators shall have type bool. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThis rule is a strict implementation of a MISRA (Motor Industry Software Reliability Association) rule. MISRA defines best practices for developing\nsafety-critical software. You can learn more about this rule in the MISRA documents referenced below.\u003c/p\u003e\n\u003cp\u003eIf you are not concerned with MISRA compliance or with safety-critical software, you might consider using rule {rule:cpp:S867} instead ; it targets\nthe same kind of issue for general-purpose software.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 5-3-1 - Each operand of the ! operator, the logical \u0026amp;\u0026amp; or the logical || operators shall have type bool. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "misra-c++2008"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5381",
    "name": "\"^\" should not be confused with exponentiation",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eIn C and its family of languages, the \u003ccode\u003e^\u003c/code\u003e operator performs the \u003cem\u003eexclusive or\u003c/em\u003e (xor) operation. This can be misleading since\n\u003ccode\u003e^\u003c/code\u003e is also commonly used to designate the exponentiation operation, for instance, in BASIC or R.\u003c/p\u003e\n\u003cp\u003eThis rule will flag uses of \u003ccode\u003e^\u003c/code\u003e in places where exponentiation is suspected to be the intended operation, i.e., on expressions that\nattempt to \u003cem\u003exor\u003c/em\u003e 2 or 10 with a constant expression.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;stdint.h\u0026gt;\n\nuint32_t max_uint16 \u003d 2 ^ 16; // Noncompliant: expression evaluates to 18, instead of the intended 65536\nuint32_t one_billion \u003d 10 ^ 9; // Noncompliant: expression evaluates to 3 instead of the intended 1e9\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;stdint.h\u0026gt;\n#include \u0026lt;math.h\u0026gt;\n\nuint32_t max_uint16 \u003d 1 \u0026lt;\u0026lt; 16; // Compliant: using left shift to generate a power of 2\nuint32_t one_billion \u003d pow(10, 9); // Compliant: using the math pow function\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThe rule does not raise an issue when at least one of the operands is expressed as a binary, octal, or hexadecimal literal. The assumption is that\nthe \u003cem\u003exor\u003c/em\u003e operation is intended in such cases.\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;stdint.h\u0026gt;\n\nuint32_t using_octal \u003d 02 ^ 016; // Compliant by exception\nuint32_t using_binary \u003d 0b10 ^ 9; // Compliant by exception\nuint32_t using_hex \u003d 0xFF ^ 0x09; // Compliant by exception\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e Wikipedia - \u003ca href\u003d\"https://en.wikipedia.org/wiki/Exponentiation#In_programming_languages\"\u003eExponentiation: In programming languages\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e Wikipedia - \u003ca href\u003d\"https://en.wikipedia.org/wiki/Exclusive_or\"\u003eExclusive or (xor)\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eIn C and its family of languages, the \u003ccode\u003e^\u003c/code\u003e operator performs the \u003cem\u003eexclusive or\u003c/em\u003e (xor) operation. This can be misleading since\n\u003ccode\u003e^\u003c/code\u003e is also commonly used to designate the exponentiation operation, for instance, in BASIC or R.\u003c/p\u003e\n\u003cp\u003eThis rule will flag uses of \u003ccode\u003e^\u003c/code\u003e in places where exponentiation is suspected to be the intended operation, i.e., on expressions that\nattempt to \u003cem\u003exor\u003c/em\u003e 2 or 10 with a constant expression.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;stdint.h\u0026gt;\n\nuint32_t max_uint16 \u003d 2 ^ 16; // Noncompliant: expression evaluates to 18, instead of the intended 65536\nuint32_t one_billion \u003d 10 ^ 9; // Noncompliant: expression evaluates to 3 instead of the intended 1e9\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;stdint.h\u0026gt;\n#include \u0026lt;math.h\u0026gt;\n\nuint32_t max_uint16 \u003d 1 \u0026lt;\u0026lt; 16; // Compliant: using left shift to generate a power of 2\nuint32_t one_billion \u003d pow(10, 9); // Compliant: using the math pow function\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThe rule does not raise an issue when at least one of the operands is expressed as a binary, octal, or hexadecimal literal. The assumption is that\nthe \u003cem\u003exor\u003c/em\u003e operation is intended in such cases.\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;stdint.h\u0026gt;\n\nuint32_t using_octal \u003d 02 ^ 016; // Compliant by exception\nuint32_t using_binary \u003d 0b10 ^ 9; // Compliant by exception\nuint32_t using_hex \u003d 0xFF ^ 0x09; // Compliant by exception\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e Wikipedia - \u003ca href\u003d\"https://en.wikipedia.org/wiki/Exponentiation#In_programming_languages\"\u003eExponentiation: In programming languages\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e Wikipedia - \u003ca href\u003d\"https://en.wikipedia.org/wiki/Exclusive_or\"\u003eExclusive or (xor)\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5261",
    "name": "\"else\" statements should be clearly matched with an \"if\"",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe dangling \u003ccode\u003eelse\u003c/code\u003e problem appears when nested \u003ccode\u003eif\u003c/code\u003e/\u003ccode\u003eelse\u003c/code\u003e\u0026nbsp;statements are written without curly braces. In\nthis case, \u003ccode\u003eelse\u003c/code\u003e is associated with the nearest\u0026nbsp;\u003ccode\u003eif\u003c/code\u003e but that is not always obvious and sometimes the indentation can also\nbe misleading.\u003c/p\u003e\n\u003cp\u003eThis rules reports \u003ccode\u003eelse\u003c/code\u003e statements that are difficult to understand, because they are inside nested \u003ccode\u003eif\u003c/code\u003e statements without\ncurly braces.\u003c/p\u003e\n\u003cp\u003eAdding curly braces can generally make the code clearer (see rule {rule:cpp:S121} ), and in this situation of dangling \u003ccode\u003eelse\u003c/code\u003e, it really\nclarifies the intention of the code.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n if (a)\n   if (b)\n     d++;\n else     // Noncompliant, is the \"else\" associated with \"if(a)\" or \"if (b)\"? (the answer is \"if(b)\")\n   e++;\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n if (a) {\n   if (b) {\n     d++;\n   }\n } else { // Compliant, there is no doubt the \"else\" is associated with \"if(a)\"\n   e++;\n }\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Dangling_else\"\u003ehttps://en.wikipedia.org/wiki/Dangling_else\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe dangling \u003ccode\u003eelse\u003c/code\u003e problem appears when nested \u003ccode\u003eif\u003c/code\u003e/\u003ccode\u003eelse\u003c/code\u003e\u0026nbsp;statements are written without curly braces. In\nthis case, \u003ccode\u003eelse\u003c/code\u003e is associated with the nearest\u0026nbsp;\u003ccode\u003eif\u003c/code\u003e but that is not always obvious and sometimes the indentation can also\nbe misleading.\u003c/p\u003e\n\u003cp\u003eThis rules reports \u003ccode\u003eelse\u003c/code\u003e statements that are difficult to understand, because they are inside nested \u003ccode\u003eif\u003c/code\u003e statements without\ncurly braces.\u003c/p\u003e\n\u003cp\u003eAdding curly braces can generally make the code clearer (see rule {rule:cpp:S121} ), and in this situation of dangling \u003ccode\u003eelse\u003c/code\u003e, it really\nclarifies the intention of the code.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n if (a)\n   if (b)\n     d++;\n else     // Noncompliant, is the \"else\" associated with \"if(a)\" or \"if (b)\"? (the answer is \"if(b)\")\n   e++;\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n if (a) {\n   if (b) {\n     d++;\n   }\n } else { // Compliant, there is no doubt the \"else\" is associated with \"if(a)\"\n   e++;\n }\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Dangling_else\"\u003ehttps://en.wikipedia.org/wiki/Dangling_else\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "confusing"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S799",
    "name": "Identifiers should not be longer than 31 characters",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "IDENTIFIABLE",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eIn addition to being difficult to use, too-long variable names can limit code portability. The ISO standard requires that variable, type, function\nand label names be no more than 31 characters long.\u003c/p\u003e\n\u003cp\u003eNote that 31 characters is an upper bound, rather than a length recommendation. Shorter names are better, as long as they’re still\ncommunicative.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint this_is_a_very_long_identifier_that_definitely_should_be_renamed \u003d 0;\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint reasonable_identifier \u003d 0;\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 5.1 - Identifiers (internal and external) shall not rely on the significance of more than 31 character. \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/FtcxBQ\"\u003eCERT, DCL23-C.\u003c/a\u003e - Guarantee that mutually visible identifiers are unique \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eIn addition to being difficult to use, too-long variable names can limit code portability. The ISO standard requires that variable, type, function\nand label names be no more than 31 characters long.\u003c/p\u003e\n\u003cp\u003eNote that 31 characters is an upper bound, rather than a length recommendation. Shorter names are better, as long as they’re still\ncommunicative.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint this_is_a_very_long_identifier_that_definitely_should_be_renamed \u003d 0;\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint reasonable_identifier \u003d 0;\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 5.1 - Identifiers (internal and external) shall not rely on the significance of more than 31 character. \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/FtcxBQ\"\u003eCERT, DCL23-C.\u003c/a\u003e - Guarantee that mutually visible identifiers are unique \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "cert"
    ],
    "deprecatedKeys": [
      "cpp:IdentifierLongerThan31"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6232",
    "name": "Well-defined type-punning method should be used instead of a union-based one",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003cp\u003e\u003ccode\u003eunion\u003c/code\u003e is unsuitable for type-punning in C++ code, leading to undefined behavior. There are well-defined safe alternatives that are\njust as fast.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eIn some performance-oriented algorithms, a solution to certain slow operations is reinterpreting a value as a different type of the same length\nwhile preserving its binary representation.\u003c/p\u003e\n\u003cp\u003eOne of the superseded solutions, known as \"union type-punning\", is to use a \u003ccode\u003eunion\u003c/code\u003e with two members with types corresponding to the\nsource and the target types of the cast. The operation is performed by saving the value in the member of the source type and then reading the value\nfrom the member of the target type. Despite being allowed in C, this operation has undefined behavior according to C++ standard and should be replaced\nby \u003ccode\u003estd::memcpy\u003c/code\u003e (or \u003ccode\u003estd::bit_cast\u003c/code\u003e in C++20).\u003c/p\u003e\n\u003cp\u003eNote: \u003ccode\u003estd::memcpy\u003c/code\u003e has no performance impact on modern compilers when used in type-punning and is optimized during compilation.\u003c/p\u003e\n\u003cp\u003eSometimes \u003ccode\u003eunion\u003c/code\u003e type-punning is used to remove \u003ccode\u003econst\u003c/code\u003e. This can create readability issues and should be replaced with\n\u003ccode\u003econst_cast\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue on any use of a \u003ccode\u003eunion\u003c/code\u003e that should be replaced with \u003ccode\u003estd::memcpy\u003c/code\u003e, \u003ccode\u003estd::bit_cast\u003c/code\u003e, or\n\u003ccode\u003econst_cast\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eThe C++ standard states that only one \u003ccode\u003eunion\u003c/code\u003e member can be \"active\" at any time. A member becomes active once assigned a value, making\nthe other \u003ccode\u003eunion\u003c/code\u003e members \"inactive\". The standard also states that reading from an \"inactive\" member is undefined behavior.\u003c/p\u003e\n\u003cp\u003eSince \u003ccode\u003eunion\u003c/code\u003e type-punning relies on reading the \"inactive\" member, code using it exercises undefined behavior. Such code can be\nunintentionally removed in aggressive levels of optimization.\u003c/p\u003e\n\u003cp\u003eFurther problems could also arise from using \u003ccode\u003eunion\u003c/code\u003e-based type punning in cross-platform solutions. Since this method is mainly used\nwith Built-in Types, which vary in size depending on the underlying architecture, it could hide a portability issue.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eReplace any \"\u003ccode\u003eunion\u003c/code\u003e-based type punning\" solution with a standard-compliant solution.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nfloat fastInvSqrt(float number)\n  constexpr float threehalfs \u003d 1.5F;\n  const float x2 \u003d number * 0.5F;\n\n  union {\n     float f;\n     uint32_t i;\n  } conv;\n  conv.f \u003d number\n  conv.i \u003d 0x5f3759df - (conv.i \u0026gt;\u0026gt; 1);  // Noncompliant: undefined behavior\n  conv.f *\u003d threehalfs - (x2 * conv.f * conv.f); // Noncompliant: undefined behavior\n  return conv.f;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eSolution before C++20:\u003c/p\u003e\n\u003cpre\u003e\nfloat fastInvSqrt(float number) {\n  constexpr float threehalfs \u003d 1.5F;\n  const float x2 \u003d number * 0.5F;\n\n  std::uint32_t i;\n  static_assert(sizeof(i) \u003d\u003d sizeof(number), \"Use equal-size types to achieve safe type-punning\");\n  std::memcpy(\u0026amp;i, \u0026amp;number, sizeof(float)); // Compliant\n  i  \u003d 0x5f3759df - (i \u0026gt;\u0026gt; 1);\n\n  float result;\n  static_assert(sizeof(result) \u003d\u003d sizeof(i), \"Use equal-size types to achieve safe type-punning\");\n  std::memcpy(\u0026amp;result, \u0026amp;i, sizeof(float)); // Compliant\n  result  *\u003d threehalfs - (x2 * result * result);\n  return result;\n}\n\u003c/pre\u003e\n\u003cp\u003eC++20 and after:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nfloat fastInvSqrt(float number) {\n  constexpr float threehalfs \u003d 1.5F;\n  const float x2 \u003d number * 0.5F;\n\n  auto i \u003d std::bit_cast\u0026lt;std::uint32_t\u0026gt;(number); // Compliant\n  i  \u003d 0x5f3759df - (i \u0026gt;\u0026gt; 1);\n  auto result \u003d std::bit_cast\u0026lt;float\u0026gt;(i); // Compliant\n  result  *\u003d threehalfs - (x2 * result * result);\n  return result;\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eConference presentations\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CppCon 2019 - \u003ca href\u003d\"https://www.youtube.com/watch?v\u003d_qzMpk-22cc\"\u003eType punning in modern C++, Timur Doumler\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S6181} - replacing \u003ccode\u003estd::memcpy\u003c/code\u003e with \u003ccode\u003estd::bit_cast\u003c/code\u003e. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003e\u003ccode\u003eunion\u003c/code\u003e is unsuitable for type-punning in C++ code, leading to undefined behavior. There are well-defined safe alternatives that are\njust as fast.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eIn some performance-oriented algorithms, a solution to certain slow operations is reinterpreting a value as a different type of the same length\nwhile preserving its binary representation.\u003c/p\u003e\n\u003cp\u003eOne of the superseded solutions, known as \"union type-punning\", is to use a \u003ccode\u003eunion\u003c/code\u003e with two members with types corresponding to the\nsource and the target types of the cast. The operation is performed by saving the value in the member of the source type and then reading the value\nfrom the member of the target type. Despite being allowed in C, this operation has undefined behavior according to C++ standard and should be replaced\nby \u003ccode\u003estd::memcpy\u003c/code\u003e (or \u003ccode\u003estd::bit_cast\u003c/code\u003e in C++20).\u003c/p\u003e\n\u003cp\u003eNote: \u003ccode\u003estd::memcpy\u003c/code\u003e has no performance impact on modern compilers when used in type-punning and is optimized during compilation.\u003c/p\u003e\n\u003cp\u003eSometimes \u003ccode\u003eunion\u003c/code\u003e type-punning is used to remove \u003ccode\u003econst\u003c/code\u003e. This can create readability issues and should be replaced with\n\u003ccode\u003econst_cast\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue on any use of a \u003ccode\u003eunion\u003c/code\u003e that should be replaced with \u003ccode\u003estd::memcpy\u003c/code\u003e, \u003ccode\u003estd::bit_cast\u003c/code\u003e, or\n\u003ccode\u003econst_cast\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eThe C++ standard states that only one \u003ccode\u003eunion\u003c/code\u003e member can be \"active\" at any time. A member becomes active once assigned a value, making\nthe other \u003ccode\u003eunion\u003c/code\u003e members \"inactive\". The standard also states that reading from an \"inactive\" member is undefined behavior.\u003c/p\u003e\n\u003cp\u003eSince \u003ccode\u003eunion\u003c/code\u003e type-punning relies on reading the \"inactive\" member, code using it exercises undefined behavior. Such code can be\nunintentionally removed in aggressive levels of optimization.\u003c/p\u003e\n\u003cp\u003eFurther problems could also arise from using \u003ccode\u003eunion\u003c/code\u003e-based type punning in cross-platform solutions. Since this method is mainly used\nwith Built-in Types, which vary in size depending on the underlying architecture, it could hide a portability issue.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eReplace any \"\u003ccode\u003eunion\u003c/code\u003e-based type punning\" solution with a standard-compliant solution.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nfloat fastInvSqrt(float number)\n  constexpr float threehalfs \u003d 1.5F;\n  const float x2 \u003d number * 0.5F;\n\n  union {\n     float f;\n     uint32_t i;\n  } conv;\n  conv.f \u003d number\n  conv.i \u003d 0x5f3759df - (conv.i \u0026gt;\u0026gt; 1);  // Noncompliant: undefined behavior\n  conv.f *\u003d threehalfs - (x2 * conv.f * conv.f); // Noncompliant: undefined behavior\n  return conv.f;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eSolution before C++20:\u003c/p\u003e\n\u003cpre\u003e\nfloat fastInvSqrt(float number) {\n  constexpr float threehalfs \u003d 1.5F;\n  const float x2 \u003d number * 0.5F;\n\n  std::uint32_t i;\n  static_assert(sizeof(i) \u003d\u003d sizeof(number), \"Use equal-size types to achieve safe type-punning\");\n  std::memcpy(\u0026amp;i, \u0026amp;number, sizeof(float)); // Compliant\n  i  \u003d 0x5f3759df - (i \u0026gt;\u0026gt; 1);\n\n  float result;\n  static_assert(sizeof(result) \u003d\u003d sizeof(i), \"Use equal-size types to achieve safe type-punning\");\n  std::memcpy(\u0026amp;result, \u0026amp;i, sizeof(float)); // Compliant\n  result  *\u003d threehalfs - (x2 * result * result);\n  return result;\n}\n\u003c/pre\u003e\n\u003cp\u003eC++20 and after:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nfloat fastInvSqrt(float number) {\n  constexpr float threehalfs \u003d 1.5F;\n  const float x2 \u003d number * 0.5F;\n\n  auto i \u003d std::bit_cast\u0026lt;std::uint32_t\u0026gt;(number); // Compliant\n  i  \u003d 0x5f3759df - (i \u0026gt;\u0026gt; 1);\n  auto result \u003d std::bit_cast\u0026lt;float\u0026gt;(i); // Compliant\n  result  *\u003d threehalfs - (x2 * result * result);\n  return result;\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eConference presentations\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CppCon 2019 - \u003ca href\u003d\"https://www.youtube.com/watch?v\u003d_qzMpk-22cc\"\u003eType punning in modern C++, Timur Doumler\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S6181} - replacing \u003ccode\u003estd::memcpy\u003c/code\u003e with \u003ccode\u003estd::bit_cast\u003c/code\u003e. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "bad-practice",
      "pitfall",
      "symbolic-execution"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S797",
    "name": "Trigraphs should not be used",
    "defaultSeverity": "BLOCKER",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eTrigraphs are denoted by a sequence of 2 question marks followed by a specified third character (e.g. ??- represents a \u0027~\u0027 (tilde) character and\n??) represents a \u0027]\u0027). They can cause accidental confusion with other uses of two question marks.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstatic const char str[] \u003d \"(Date should be in the form ??-??-??)\"; // Noncompliant. Evaluates to \"(Date should be in the form ~~]\"\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstatic const char str[] \u003d \"(Date should be in the form ?\" \"?-?\" \"?-?\" ?)\";  // adjacent string literals concatenated at compile time\nstatic const char str2[] \u003d \"(Date should be in the form ?-?-?)\"; // problem avoided by eliminating 2nd \u0027?\u0027 in each sequence\nstatic const char str3[] \u003d \"(Date should be in the form ? ?-? ?-? ?)\"; // problem avoided by spacing \u0027?\u0027s out\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/operator_alternative\"\u003eAlternative operator representations: Trigraphs\u003c/a\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/uNUxBQ\"\u003ePRE07-C. - Avoid using repeated question marks\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 4.2 - Trigraphs shall not be used \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 2-3-1 - Trigraphs shall not be used \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 4.2 - Trigraphs shall not be used \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eTrigraphs are denoted by a sequence of 2 question marks followed by a specified third character (e.g. ??- represents a \u0027~\u0027 (tilde) character and\n??) represents a \u0027]\u0027). They can cause accidental confusion with other uses of two question marks.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstatic const char str[] \u003d \"(Date should be in the form ??-??-??)\"; // Noncompliant. Evaluates to \"(Date should be in the form ~~]\"\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstatic const char str[] \u003d \"(Date should be in the form ?\" \"?-?\" \"?-?\" ?)\";  // adjacent string literals concatenated at compile time\nstatic const char str2[] \u003d \"(Date should be in the form ?-?-?)\"; // problem avoided by eliminating 2nd \u0027?\u0027 in each sequence\nstatic const char str3[] \u003d \"(Date should be in the form ? ?-? ?-? ?)\"; // problem avoided by spacing \u0027?\u0027s out\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/operator_alternative\"\u003eAlternative operator representations: Trigraphs\u003c/a\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/uNUxBQ\"\u003ePRE07-C. - Avoid using repeated question marks\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 4.2 - Trigraphs shall not be used \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 2-3-1 - Trigraphs shall not be used \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 4.2 - Trigraphs shall not be used \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "cert",
      "obsolete",
      "suspicious"
    ],
    "deprecatedKeys": [
      "cpp:TrigraphUsage"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5265",
    "name": "Incomplete types should not be deleted",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhen calling \u003ccode\u003edelete\u003c/code\u003e on an object of incomplete type, the calling code does not have enough information to do the action properly (it\ndoes not know if this object has a trivial or a nontrivial destructor, if it has overloaded the \u003ccode\u003edelete\u003c/code\u003e operator…​). Therefore, deleting a\npointer to such an object can lead to undefined behavior.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass Body;\n\nclass Handle {\n  public:\n    Handle();\n    ~Handle() {\n      delete impl; // Noncompliant, Body is incomplete\n    }\n  private:\n    Body * impl;\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n// In header file\nclass Body;\n\nclass Handle {\n  public:\n    Handle();\n    ~Handle();\n    // Add other special member functions to respect the rule of five\n  private:\n    Body * impl;\n};\n\n// In implementation file\n#include \"Handle.h\"\n#include \"Body.h\" // Now Body is complete\n\nHandle::~Handle(){\n  delete impl; // Compliant, at this point \"Body\" is a complete class\n}\n\u003c/pre\u003e\n\u003cp\u003eOr, with modern resource handling:\u003c/p\u003e\n\u003cpre\u003e\n// In header file\nclass Body;\n\nclass Handle {\n  public:\n    Handle();\n    ~Handle();\n  private:\n    std::unique_ptr\u0026lt;Body\u0026gt; impl; //Compliant\n};\n\n// In implementation file\n#include \"Handle.h\"\n#include \"Body.h\" // Now Body is complete\n\nHandle::Handle() : impl{new Body{}} {}\nHandle::~Handle() \u003d default; // since \"Body\" is complete, it can be destroyed by unique_ptr\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhen calling \u003ccode\u003edelete\u003c/code\u003e on an object of incomplete type, the calling code does not have enough information to do the action properly (it\ndoes not know if this object has a trivial or a nontrivial destructor, if it has overloaded the \u003ccode\u003edelete\u003c/code\u003e operator…​). Therefore, deleting a\npointer to such an object can lead to undefined behavior.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass Body;\n\nclass Handle {\n  public:\n    Handle();\n    ~Handle() {\n      delete impl; // Noncompliant, Body is incomplete\n    }\n  private:\n    Body * impl;\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n// In header file\nclass Body;\n\nclass Handle {\n  public:\n    Handle();\n    ~Handle();\n    // Add other special member functions to respect the rule of five\n  private:\n    Body * impl;\n};\n\n// In implementation file\n#include \"Handle.h\"\n#include \"Body.h\" // Now Body is complete\n\nHandle::~Handle(){\n  delete impl; // Compliant, at this point \"Body\" is a complete class\n}\n\u003c/pre\u003e\n\u003cp\u003eOr, with modern resource handling:\u003c/p\u003e\n\u003cpre\u003e\n// In header file\nclass Body;\n\nclass Handle {\n  public:\n    Handle();\n    ~Handle();\n  private:\n    std::unique_ptr\u0026lt;Body\u0026gt; impl; //Compliant\n};\n\n// In implementation file\n#include \"Handle.h\"\n#include \"Body.h\" // Now Body is complete\n\nHandle::Handle() : impl{new Body{}} {}\nHandle::~Handle() \u003d default; // since \"Body\" is complete, it can be destroyed by unique_ptr\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "unpredictable"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S798",
    "name": "Digraphs should not be used",
    "defaultSeverity": "BLOCKER",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe use of digraphs may not meet developer expectations.\u003c/p\u003e\n\u003cp\u003eThe digraphs are:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003e\u0026lt;%\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003e%\u0026gt;\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003e\u0026lt;:\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003e:\u0026gt;\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003e%:\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003e%:%:\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\ntemplate \u0026lt;typename T\u0026gt;\nclass A\n{\n  public:\n    template\u0026lt;int32_t i\u0026gt;\n    void f2();\n};\n\nvoid f(A\u0026lt;int32_t\u0026gt; * a\u0026lt;:10:\u0026gt;)    /* Noncompliant - usage of \u0027\u0026lt;:\u0027 instead of \u0027[\u0027 and \u0027:\u0026gt;\u0027 instead of \u0027]\u0027 */\n\u0026lt;%                              /* Noncompliant - usage of \u0027\u0026lt;%\u0027 instead of \u0027{\u0027 */\n  a\u0026lt;:0:\u0026gt;-\u0026gt;f2\u0026lt;20\u0026gt;();             /* Noncompliant - usage of \u0027\u0026lt;:\u0027 and \u0027:\u0026gt;\u0027 */\n%\u0026gt;                              /* Noncompliant - usage of \u0027%\u0026gt;\u0027 instead of \u0027}\u0027 */\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n/* ... */\n\nvoid f(A\u0026lt;int32_t\u0026gt; * a[10])      /* Compliant */\n{                               /* Compliant */\n  a[0]-\u0026gt;f2\u0026lt;20\u0026gt;();               /* Compliant */\n}                               /* Compliant */\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 2-5-1 - Digraphs should not be used. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe use of digraphs may not meet developer expectations.\u003c/p\u003e\n\u003cp\u003eThe digraphs are:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003e\u0026lt;%\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003e%\u0026gt;\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003e\u0026lt;:\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003e:\u0026gt;\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003e%:\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003e%:%:\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\ntemplate \u0026lt;typename T\u0026gt;\nclass A\n{\n  public:\n    template\u0026lt;int32_t i\u0026gt;\n    void f2();\n};\n\nvoid f(A\u0026lt;int32_t\u0026gt; * a\u0026lt;:10:\u0026gt;)    /* Noncompliant - usage of \u0027\u0026lt;:\u0027 instead of \u0027[\u0027 and \u0027:\u0026gt;\u0027 instead of \u0027]\u0027 */\n\u0026lt;%                              /* Noncompliant - usage of \u0027\u0026lt;%\u0027 instead of \u0027{\u0027 */\n  a\u0026lt;:0:\u0026gt;-\u0026gt;f2\u0026lt;20\u0026gt;();             /* Noncompliant - usage of \u0027\u0026lt;:\u0027 and \u0027:\u0026gt;\u0027 */\n%\u0026gt;                              /* Noncompliant - usage of \u0027%\u0026gt;\u0027 instead of \u0027}\u0027 */\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n/* ... */\n\nvoid f(A\u0026lt;int32_t\u0026gt; * a[10])      /* Compliant */\n{                               /* Compliant */\n  a[0]-\u0026gt;f2\u0026lt;20\u0026gt;();               /* Compliant */\n}                               /* Compliant */\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 2-5-1 - Digraphs should not be used. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "obsolete"
    ],
    "deprecatedKeys": [
      "cpp:DigraphUsage"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5020",
    "name": "Facilities in \u003crandom\u003e should be used instead of \"srand\", \"rand\" and \"random_shuffle\"",
    "defaultSeverity": "BLOCKER",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe use of \u003ccode\u003esrand\u003c/code\u003e together with \u003ccode\u003erand\u003c/code\u003e to seed the random number generator and then generate numbers usually produces\nlow-quality randomness. Further, \u003ccode\u003erand\u003c/code\u003e can only provide a number between \u003ccode\u003e0\u003c/code\u003e and \u003ccode\u003eRAND_MAX\u003c/code\u003e, and it is left to the\ncaller to transform the result into what is actually required (E.G. a \u003ccode\u003efloat\u003c/code\u003e between 0 and 1 for a random percentage, an \u003ccode\u003eint\u003c/code\u003e\nbetween 1 and 6 for a dice game, …​), and that transformation might introduce additional biases.\u003c/p\u003e\n\u003cp\u003eC++11 introduced the \u003ccode\u003e\u0026lt;random\u0026gt;\u003c/code\u003e library, which contains several high quality random value generators as well as statistical\ndistributions you can use to put the results in the form you need. Those mechanisms should be used instead of \u003ccode\u003erand\u003c/code\u003e and\n\u003ccode\u003esrand\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eAdditionally, \u003ccode\u003estd::random_shuffle\u003c/code\u003e, which is deprecated in C++14 and removed in C++17, uses \u003ccode\u003erand\u003c/code\u003e and should be replaced by\n\u003ccode\u003estd::shuffle\u003c/code\u003e, which uses the random number generators provided by \u003ccode\u003e\u0026lt;random\u0026gt;\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;stdlib.h\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n// ...\n\nvoid f() {\n  srand(time(nullptr)); // Noncompliant\n  vector\u0026lt;int\u0026gt; v;\n  int size \u003d rand() % 1000 + 1000; // Noncompliant, note that this way of coercing the result introduces extra bias\n  for (auto i \u003d 0; i \u0026lt; size; ++i) {\n    v.push_back(i);\n  }\n  random_shuffle(v.begin(), v.end()); // Noncompliant\n  for (auto i : v) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \" \"; }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;algorithm\u0026gt;\n#include \u0026lt;random\u0026gt;\n// ...\n\nvoid f() {\n  random_device rd;  // Will be used to obtain a seed for the random number engine\n  mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()\n  uniform_int_distribution\u0026lt;\u0026gt; dis(1000, 1999); // Same distribution as before, but explicit and without bias\n  vector\u0026lt;int\u0026gt; v;\n  for (auto i \u003d 0; i \u0026lt; dis(gen); ++i) {\n    v.push_back(i);\n  }\n  shuffle(v.begin(), v.end(), gen);\n  for (auto i : v) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \" \"; }\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe use of \u003ccode\u003esrand\u003c/code\u003e together with \u003ccode\u003erand\u003c/code\u003e to seed the random number generator and then generate numbers usually produces\nlow-quality randomness. Further, \u003ccode\u003erand\u003c/code\u003e can only provide a number between \u003ccode\u003e0\u003c/code\u003e and \u003ccode\u003eRAND_MAX\u003c/code\u003e, and it is left to the\ncaller to transform the result into what is actually required (E.G. a \u003ccode\u003efloat\u003c/code\u003e between 0 and 1 for a random percentage, an \u003ccode\u003eint\u003c/code\u003e\nbetween 1 and 6 for a dice game, …​), and that transformation might introduce additional biases.\u003c/p\u003e\n\u003cp\u003eC++11 introduced the \u003ccode\u003e\u0026lt;random\u0026gt;\u003c/code\u003e library, which contains several high quality random value generators as well as statistical\ndistributions you can use to put the results in the form you need. Those mechanisms should be used instead of \u003ccode\u003erand\u003c/code\u003e and\n\u003ccode\u003esrand\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eAdditionally, \u003ccode\u003estd::random_shuffle\u003c/code\u003e, which is deprecated in C++14 and removed in C++17, uses \u003ccode\u003erand\u003c/code\u003e and should be replaced by\n\u003ccode\u003estd::shuffle\u003c/code\u003e, which uses the random number generators provided by \u003ccode\u003e\u0026lt;random\u0026gt;\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;stdlib.h\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n// ...\n\nvoid f() {\n  srand(time(nullptr)); // Noncompliant\n  vector\u0026lt;int\u0026gt; v;\n  int size \u003d rand() % 1000 + 1000; // Noncompliant, note that this way of coercing the result introduces extra bias\n  for (auto i \u003d 0; i \u0026lt; size; ++i) {\n    v.push_back(i);\n  }\n  random_shuffle(v.begin(), v.end()); // Noncompliant\n  for (auto i : v) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \" \"; }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;algorithm\u0026gt;\n#include \u0026lt;random\u0026gt;\n// ...\n\nvoid f() {\n  random_device rd;  // Will be used to obtain a seed for the random number engine\n  mt19937 gen(rd()); // Standard mersenne_twister_engine seeded with rd()\n  uniform_int_distribution\u0026lt;\u0026gt; dis(1000, 1999); // Same distribution as before, but explicit and without bias\n  vector\u0026lt;int\u0026gt; v;\n  for (auto i \u003d 0; i \u0026lt; dis(gen); ++i) {\n    v.push_back(i);\n  }\n  shuffle(v.begin(), v.end(), gen);\n  for (auto i : v) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \" \"; }\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "since-c++11",
      "user-experience"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5262",
    "name": "Dereferenced null pointers should not be bound to references",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eDereferencing a null pointer has undefined behavior, and it is particularly harmful if a reference is then bound to the result, because a reference\nis assumed to refer to a valid object.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid doSomething(A\u0026amp; a);\nvoid f() {\n  A* a \u003d nullptr;\n  // ...\n  doSomething(*a); // Noncompliant\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eDereferencing a null pointer has undefined behavior, and it is particularly harmful if a reference is then bound to the result, because a reference\nis assumed to refer to a valid object.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid doSomething(A\u0026amp; a);\nvoid f() {\n  A* a \u003d nullptr;\n  // ...\n  doSomething(*a); // Noncompliant\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "unpredictable"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6230",
    "name": "Comparision operators (\"\u003c\u003d\u003e\", \"\u003d\u003d\") should be defaulted unless non-default behavior is required",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eComparison operator implementations like \u003ccode\u003e\u003d\u003d\u003c/code\u003e or \u003ccode\u003e\u0026lt;\u003d\u0026gt;\u003c/code\u003e, despite not being hard to write, remain a source of bugs as\nthey must be updated with every change in the class’s member list. For instance, if the operation does not consider a newly introduced member in the\nclass, the issue will only manifest if two instances are identical, except for the freshly introduced member. As a consequence, this type of bug is\nusually hard to spot.\u003c/p\u003e\n\u003cp\u003eC++20 introduced the ability to define both \u003ccode\u003eoperator\u0026lt;\u003d\u0026gt;\u003c/code\u003e and \u003ccode\u003eoperator\u003d\u003d\u003c/code\u003e as defaulted (\u003ccode\u003e\u003d default\u003c/code\u003e) to\nindicate that they should consider all members in the order of their declaration. This makes code concise and makes all the comparison operators\nresilient to the changes to the list of members. Thanks to operator rewriting, all other comparison operations (\u003ccode\u003e!\u003d\u003c/code\u003e, \u003ccode\u003e\u0026lt;\u003c/code\u003e,\n\u003ccode\u003e\u0026gt;\u003c/code\u003e, \u003ccode\u003e\u0026lt;\u003d\u003c/code\u003e, \u003ccode\u003e\u003d\u0026gt;\u003c/code\u003e) can also rely on these robust operators.\u003c/p\u003e\n\u003cp\u003eFurthermore, when \u003ccode\u003eoperator\u0026lt;\u003d\u0026gt;\u003c/code\u003e is defined as defaulted, the compiler will generate a defaulted version of \u003ccode\u003eoperator\u003d\u003d\u003c/code\u003e\nif no other version is declared.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eThis rule raises an issue when the implementation of \u003ccode\u003eoperator\u0026lt;\u003d\u0026gt;\u003c/code\u003e or \u003ccode\u003eoperator\u003d\u003d\u003c/code\u003e has an equivalent semantic to the\ndefaulted implementation. Defining these operators as defaulted is more concise and robust in these cases.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nstruct Comparable {\n    int x;\n    int y;\n};\n\nbool operator\u003d\u003d(const Comparable\u0026amp; lhs, const Comparable\u0026amp; rhs) { // Noncompliant\n    return lhs.x \u003d\u003d rhs.x \u0026amp;\u0026amp; lhs.y \u003d\u003d rhs.y;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nstruct Comparable {\n    int x;\n    int y;\n\n    friend bool operator\u003d\u003d(const Comparable\u0026amp;, const Comparable\u0026amp;) \u003d default;\n};\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\nstruct Ordered {\n    int x;\n    int y;\n};\n\nbool operator\u003d\u003d(const Ordered\u0026amp; lhs, const Ordered\u0026amp; rhs) { // Noncompliant\n    return lhs.x \u003d\u003d rhs.x \u0026amp;\u0026amp; lhs.y \u003d\u003d rhs.y;\n}\n\nauto operator\u0026lt;\u003d\u0026gt;(const Ordered\u0026amp; lhs, const Ordered\u0026amp; rhs) { // Noncompliant\n    if (res \u003d lhs.x \u0026lt;\u003d\u0026gt; rhs.x; res !\u003d 0)\n        return x;\n    return lhs.y \u0026lt;\u003d\u0026gt; rhs.y;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\nstruct Ordered {\n    int x;\n    int y;\n\n    friend auto operator\u0026lt;\u003d\u0026gt;(const Ordered\u0026amp;, const Ordered\u0026amp;) \u003d default;\n};\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/default_comparisons\"\u003eDefault comparisons\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S6186} - removing redundant comparison operators \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S6187} - replacing multiple comparison operators with \u003ccode\u003eoperator\u0026lt;\u003d\u0026gt;\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eComparison operator implementations like \u003ccode\u003e\u003d\u003d\u003c/code\u003e or \u003ccode\u003e\u0026lt;\u003d\u0026gt;\u003c/code\u003e, despite not being hard to write, remain a source of bugs as\nthey must be updated with every change in the class’s member list. For instance, if the operation does not consider a newly introduced member in the\nclass, the issue will only manifest if two instances are identical, except for the freshly introduced member. As a consequence, this type of bug is\nusually hard to spot.\u003c/p\u003e\n\u003cp\u003eC++20 introduced the ability to define both \u003ccode\u003eoperator\u0026lt;\u003d\u0026gt;\u003c/code\u003e and \u003ccode\u003eoperator\u003d\u003d\u003c/code\u003e as defaulted (\u003ccode\u003e\u003d default\u003c/code\u003e) to\nindicate that they should consider all members in the order of their declaration. This makes code concise and makes all the comparison operators\nresilient to the changes to the list of members. Thanks to operator rewriting, all other comparison operations (\u003ccode\u003e!\u003d\u003c/code\u003e, \u003ccode\u003e\u0026lt;\u003c/code\u003e,\n\u003ccode\u003e\u0026gt;\u003c/code\u003e, \u003ccode\u003e\u0026lt;\u003d\u003c/code\u003e, \u003ccode\u003e\u003d\u0026gt;\u003c/code\u003e) can also rely on these robust operators.\u003c/p\u003e\n\u003cp\u003eFurthermore, when \u003ccode\u003eoperator\u0026lt;\u003d\u0026gt;\u003c/code\u003e is defined as defaulted, the compiler will generate a defaulted version of \u003ccode\u003eoperator\u003d\u003d\u003c/code\u003e\nif no other version is declared.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eThis rule raises an issue when the implementation of \u003ccode\u003eoperator\u0026lt;\u003d\u0026gt;\u003c/code\u003e or \u003ccode\u003eoperator\u003d\u003d\u003c/code\u003e has an equivalent semantic to the\ndefaulted implementation. Defining these operators as defaulted is more concise and robust in these cases.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nstruct Comparable {\n    int x;\n    int y;\n};\n\nbool operator\u003d\u003d(const Comparable\u0026amp; lhs, const Comparable\u0026amp; rhs) { // Noncompliant\n    return lhs.x \u003d\u003d rhs.x \u0026amp;\u0026amp; lhs.y \u003d\u003d rhs.y;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nstruct Comparable {\n    int x;\n    int y;\n\n    friend bool operator\u003d\u003d(const Comparable\u0026amp;, const Comparable\u0026amp;) \u003d default;\n};\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\nstruct Ordered {\n    int x;\n    int y;\n};\n\nbool operator\u003d\u003d(const Ordered\u0026amp; lhs, const Ordered\u0026amp; rhs) { // Noncompliant\n    return lhs.x \u003d\u003d rhs.x \u0026amp;\u0026amp; lhs.y \u003d\u003d rhs.y;\n}\n\nauto operator\u0026lt;\u003d\u0026gt;(const Ordered\u0026amp; lhs, const Ordered\u0026amp; rhs) { // Noncompliant\n    if (res \u003d lhs.x \u0026lt;\u003d\u0026gt; rhs.x; res !\u003d 0)\n        return x;\n    return lhs.y \u0026lt;\u003d\u0026gt; rhs.y;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\nstruct Ordered {\n    int x;\n    int y;\n\n    friend auto operator\u0026lt;\u003d\u0026gt;(const Ordered\u0026amp;, const Ordered\u0026amp;) \u003d default;\n};\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/default_comparisons\"\u003eDefault comparisons\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S6186} - removing redundant comparison operators \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S6187} - replacing multiple comparison operators with \u003ccode\u003eoperator\u0026lt;\u003d\u0026gt;\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "pitfall",
      "since-c++20"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5263",
    "name": "Logical operators should not be confused with bitwise operators",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhile working with bitwise operators \u003ccode\u003e\u0026amp;\u003c/code\u003e or \u003ccode\u003e|\u003c/code\u003e, it is easy to make a typo and\u0026nbsp;write the equivalent logical\noperators \u003ccode\u003e\u0026amp;\u0026amp;\u003c/code\u003e or \u003ccode\u003e||\u003c/code\u003e. This rule raises an issue when the right operand of a logical expression \u003ccode\u003e\u0026amp;\u0026amp;\u003c/code\u003e\nor \u003ccode\u003e||\u003c/code\u003e is a constant of integral type, as the developer probably meant to use the corresponding bitwise operator \u003ccode\u003e\u0026amp;\u003c/code\u003e or\n\u003ccode\u003e|\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nint fun(int a) {\n  return a || 4; // Noncompliant: did you mean to use bitwise operator \u0027|\u0027?\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nint fun(int a) {\n return a | 4;\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/operator_arithmetic#Bitwise_logic_operators\"\u003eBitwise logic operators\u003c/a\u003e\n  \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/operator_logical\"\u003eLogical operators\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhile working with bitwise operators \u003ccode\u003e\u0026amp;\u003c/code\u003e or \u003ccode\u003e|\u003c/code\u003e, it is easy to make a typo and\u0026nbsp;write the equivalent logical\noperators \u003ccode\u003e\u0026amp;\u0026amp;\u003c/code\u003e or \u003ccode\u003e||\u003c/code\u003e. This rule raises an issue when the right operand of a logical expression \u003ccode\u003e\u0026amp;\u0026amp;\u003c/code\u003e\nor \u003ccode\u003e||\u003c/code\u003e is a constant of integral type, as the developer probably meant to use the corresponding bitwise operator \u003ccode\u003e\u0026amp;\u003c/code\u003e or\n\u003ccode\u003e|\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nint fun(int a) {\n  return a || 4; // Noncompliant: did you mean to use bitwise operator \u0027|\u0027?\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nint fun(int a) {\n return a | 4;\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/operator_arithmetic#Bitwise_logic_operators\"\u003eBitwise logic operators\u003c/a\u003e\n  \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/operator_logical\"\u003eLogical operators\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6231",
    "name": "\"std::string_view\" and \"std::span\" parameters should be directly constructed from sequences",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003estd::string_view\u003c/code\u003e (introduced in C++17) and \u003ccode\u003estd::span\u003c/code\u003e (introduced in C++20) are thin generic wrappers for a contiguous\nsequence of elements. These wrappers can be used to unify the interface of functions that were previously accepting references to specific container\ntypes: \u003ccode\u003econst std::string\u0026amp;\u003c/code\u003e, \u003ccode\u003econst std::vector\u0026lt;int\u0026gt;\u0026amp;\u003c/code\u003e…​\u003c/p\u003e\n\u003cp\u003eOne of the benefits of such modernization is that it eliminates the need to explicitly create a temporary container. This happens in situations\nwhere part of the sequence is passed as an argument: \u003ccode\u003esubstr\u003c/code\u003e is called on \u003ccode\u003estd::string\u003c/code\u003e. It can also happen when the type of\nthe container elements needs to be adjusted: converting \u003ccode\u003estd::vector\u0026lt;T*\u0026gt;\u003c/code\u003e to \u003ccode\u003estd::vector\u0026lt;const T*\u0026gt;\u003c/code\u003e. When changing\nthe type of a function parameter to \u003ccode\u003estd::string_view\u003c/code\u003e or \u003ccode\u003estd::span\u003c/code\u003e the modification of the function call site to remove the\nno longer needed temporary might be missed and the code will still compile. This rule will help eliminate these temporaries.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when an unnecessary temporary is passed as an argument to a parameter of \u003ccode\u003estd::string_view\u003c/code\u003e or\n\u003ccode\u003estd::span\u003c/code\u003e type.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid parse(std::string_view sv);\nbool oddAre0(std::span\u0026lt;int const* const\u0026gt; nums);\nstd::vector\u0026lt;int*\u0026gt; getNums();\n\nvoid caller(std::string const\u0026amp; s) {\n  parse(s.substr(10)); // Noncompliant\n  parse(std::string(s, 2, 5)); // Noncompliant\n  parse(std::string(s.data(), 20)); // Noncompliant\n  parse(std::string(s.data(), 10)); // Noncompliant\n\n  std::vector\u0026lt;int*\u0026gt; nums \u003d getNums();\n  if (oddAre0(std::vector\u0026lt;int const*\u0026gt;{nums.begin(), nums.end()})) { // Noncompliant: This copy is verbose and slow\n    // ...\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid parse(std::string_view sv);\nbool oddAre0(std::span\u0026lt;int const* const\u0026gt; nums);\nstd::vector\u0026lt;int*\u0026gt; getNums();\n\nvoid caller(std::string const\u0026amp; s) {\n  parse(std::string_view(s).substr(10));\n  parse(std::string_view(s).substr(2, 5));\n  parse(std::string_view(s.data(), 20));\n  parse({ s.data(), 10 });\n\n  std::vector\u0026lt;int*\u0026gt; nums \u003d getNums();\n  if (oddAre0(nums)) {\n      // ...\n  }\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e RSPEC-6009 - using \u003ccode\u003estd::string_view\u003c/code\u003e as a parameter type \u003c/li\u003e\n  \u003cli\u003e RSPEC-6188 - using \u003ccode\u003estd::span\u003c/code\u003e as a parameter type \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003ccode\u003estd::string_view\u003c/code\u003e (introduced in C++17) and \u003ccode\u003estd::span\u003c/code\u003e (introduced in C++20) are thin generic wrappers for a contiguous\nsequence of elements. These wrappers can be used to unify the interface of functions that were previously accepting references to specific container\ntypes: \u003ccode\u003econst std::string\u0026amp;\u003c/code\u003e, \u003ccode\u003econst std::vector\u0026lt;int\u0026gt;\u0026amp;\u003c/code\u003e…​\u003c/p\u003e\n\u003cp\u003eOne of the benefits of such modernization is that it eliminates the need to explicitly create a temporary container. This happens in situations\nwhere part of the sequence is passed as an argument: \u003ccode\u003esubstr\u003c/code\u003e is called on \u003ccode\u003estd::string\u003c/code\u003e. It can also happen when the type of\nthe container elements needs to be adjusted: converting \u003ccode\u003estd::vector\u0026lt;T*\u0026gt;\u003c/code\u003e to \u003ccode\u003estd::vector\u0026lt;const T*\u0026gt;\u003c/code\u003e. When changing\nthe type of a function parameter to \u003ccode\u003estd::string_view\u003c/code\u003e or \u003ccode\u003estd::span\u003c/code\u003e the modification of the function call site to remove the\nno longer needed temporary might be missed and the code will still compile. This rule will help eliminate these temporaries.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when an unnecessary temporary is passed as an argument to a parameter of \u003ccode\u003estd::string_view\u003c/code\u003e or\n\u003ccode\u003estd::span\u003c/code\u003e type.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid parse(std::string_view sv);\nbool oddAre0(std::span\u0026lt;int const* const\u0026gt; nums);\nstd::vector\u0026lt;int*\u0026gt; getNums();\n\nvoid caller(std::string const\u0026amp; s) {\n  parse(s.substr(10)); // Noncompliant\n  parse(std::string(s, 2, 5)); // Noncompliant\n  parse(std::string(s.data(), 20)); // Noncompliant\n  parse(std::string(s.data(), 10)); // Noncompliant\n\n  std::vector\u0026lt;int*\u0026gt; nums \u003d getNums();\n  if (oddAre0(std::vector\u0026lt;int const*\u0026gt;{nums.begin(), nums.end()})) { // Noncompliant: This copy is verbose and slow\n    // ...\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid parse(std::string_view sv);\nbool oddAre0(std::span\u0026lt;int const* const\u0026gt; nums);\nstd::vector\u0026lt;int*\u0026gt; getNums();\n\nvoid caller(std::string const\u0026amp; s) {\n  parse(std::string_view(s).substr(10));\n  parse(std::string_view(s).substr(2, 5));\n  parse(std::string_view(s.data(), 20));\n  parse({ s.data(), 10 });\n\n  std::vector\u0026lt;int*\u0026gt; nums \u003d getNums();\n  if (oddAre0(nums)) {\n      // ...\n  }\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e RSPEC-6009 - using \u003ccode\u003estd::string_view\u003c/code\u003e as a parameter type \u003c/li\u003e\n  \u003cli\u003e RSPEC-6188 - using \u003ccode\u003estd::span\u003c/code\u003e as a parameter type \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "performance",
      "since-c++20"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6352",
    "name": "The return value of \"std::move\" should be used in a function",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003estd::move\u003c/code\u003e is not really moving anything, but tells the compiler that a value can be considered as no longer useful. It is technically\na cast to a RValue, and allows overload resolution to select the version of a function that will perform destructive operations on that value\n(therefore actually moving from it).\u003c/p\u003e\n\u003cpre\u003e\nvoid f(A const \u0026amp;a); // Just reading from a\nvoid f(A\u0026amp;\u0026amp; a); // I can perform destructive operations on a, like resource stealing\n\nvoid g() {\n    A a;\n    f(a); // First overload is selected\n    f(std::move(a)); // Second overload is selected\n}\n\u003c/pre\u003e\n\u003cp\u003eAs a consequence, calling \u003ccode\u003estd::move\u003c/code\u003e on an object and then not directly using the returned value as a function argument is not the\ntypical pattern, and may be indicative of a bug. Note that calling a member function on the result of \u003ccode\u003estd::move\u003c/code\u003e \u003cem\u003eis\u003c/em\u003e considered as\npassing it to a function (as the hidden \u003ccode\u003ethis\u003c/code\u003e parameter), as well as using it as an operand (the called function is the overloaded\noperator) or initializing an object with it (the called function is the constructor).\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid sink(A \u0026amp;\u0026amp;a) {\n  std::move(a); // Noncompliant, and not doing anything\n}\n\nvoid f(A \u0026amp;\u0026amp;a) {\n  // May or may not move the member name, depending on its type, the intent is not clear anyways,\n  // for instance, is `a` supposed to be in a moved-from state after the call?\n  g(std::move(a).name); // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid f(A \u0026amp;\u0026amp;a) {\n  g(std::move(a.name)); // Compliant, `a.name` is in moved-from state, `a` itself is not\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eEven if calling a built-in operator or initializing data of built-in type are not function calls, for consistency with cases that involve\nuser-defined types, this rule will not report in those cases:\u003c/p\u003e\n\u003cpre\u003e\nstruct Data {A a; int b; };\n\nData add(Data \u0026amp;\u0026amp;d1, Data \u0026amp;\u0026amp;d2) {\n  return Data{\n    std::move(d1.a) + std::move(d2.a), // Compliant, operator+ might have an overload for A\u0026amp;\u0026amp;\n    std::move(d1.b) + std::move(d2.b)  // Compliant by exception\n  };\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003ccode\u003estd::move\u003c/code\u003e is not really moving anything, but tells the compiler that a value can be considered as no longer useful. It is technically\na cast to a RValue, and allows overload resolution to select the version of a function that will perform destructive operations on that value\n(therefore actually moving from it).\u003c/p\u003e\n\u003cpre\u003e\nvoid f(A const \u0026amp;a); // Just reading from a\nvoid f(A\u0026amp;\u0026amp; a); // I can perform destructive operations on a, like resource stealing\n\nvoid g() {\n    A a;\n    f(a); // First overload is selected\n    f(std::move(a)); // Second overload is selected\n}\n\u003c/pre\u003e\n\u003cp\u003eAs a consequence, calling \u003ccode\u003estd::move\u003c/code\u003e on an object and then not directly using the returned value as a function argument is not the\ntypical pattern, and may be indicative of a bug. Note that calling a member function on the result of \u003ccode\u003estd::move\u003c/code\u003e \u003cem\u003eis\u003c/em\u003e considered as\npassing it to a function (as the hidden \u003ccode\u003ethis\u003c/code\u003e parameter), as well as using it as an operand (the called function is the overloaded\noperator) or initializing an object with it (the called function is the constructor).\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid sink(A \u0026amp;\u0026amp;a) {\n  std::move(a); // Noncompliant, and not doing anything\n}\n\nvoid f(A \u0026amp;\u0026amp;a) {\n  // May or may not move the member name, depending on its type, the intent is not clear anyways,\n  // for instance, is `a` supposed to be in a moved-from state after the call?\n  g(std::move(a).name); // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid f(A \u0026amp;\u0026amp;a) {\n  g(std::move(a.name)); // Compliant, `a.name` is in moved-from state, `a` itself is not\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eEven if calling a built-in operator or initializing data of built-in type are not function calls, for consistency with cases that involve\nuser-defined types, this rule will not report in those cases:\u003c/p\u003e\n\u003cpre\u003e\nstruct Data {A a; int b; };\n\nData add(Data \u0026amp;\u0026amp;d1, Data \u0026amp;\u0026amp;d2) {\n  return Data{\n    std::move(d1.a) + std::move(d2.a), // Compliant, operator+ might have an overload for A\u0026amp;\u0026amp;\n    std::move(d1.b) + std::move(d2.b)  // Compliant by exception\n  };\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S796",
    "name": "Only escape sequences defined in the ISO C standard should be used",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe use of an undefined escape sequence leads to undefined behavior. The defined escape sequences (ISO/IEC 14882:2003 [1] §2.13.2) are:\n\u003ccode\u003e\\n\u003c/code\u003e, \u003ccode\u003e\\t\u003c/code\u003e, \u003ccode\u003e\\v\u003c/code\u003e, \u003ccode\u003e\\b\u003c/code\u003e, \u003ccode\u003e\\r\u003c/code\u003e, \u003ccode\u003e\\f\u003c/code\u003e, \u003ccode\u003e\\a\u003c/code\u003e, \u003ccode\u003e\\\\\u003c/code\u003e,\n\u003ccode\u003e?\u003c/code\u003e, \u003ccode\u003e\\\u0027\u003c/code\u003e, \u003ccode\u003e\\\"\u003c/code\u003e, \u003ccode\u003e\\\u0026lt;Octal Number\u0026gt;\u003c/code\u003e, and \u003ccode\u003e\\x\u0026lt;Hexadecimal Number\u0026gt;\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nconst char_t a[ 2 ] \u003d \"\\k\";   // Noncompliant\nconst char_t b[ 2 ] \u003d \"\\b\";   // Compliant\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 4.1 - Only those escape sequences that are defined in ISO C standard shall be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 2-13-1 - Only those escape sequences that are defined in ISO/IEC 14882:2003 shall be used. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe use of an undefined escape sequence leads to undefined behavior. The defined escape sequences (ISO/IEC 14882:2003 [1] §2.13.2) are:\n\u003ccode\u003e\\n\u003c/code\u003e, \u003ccode\u003e\\t\u003c/code\u003e, \u003ccode\u003e\\v\u003c/code\u003e, \u003ccode\u003e\\b\u003c/code\u003e, \u003ccode\u003e\\r\u003c/code\u003e, \u003ccode\u003e\\f\u003c/code\u003e, \u003ccode\u003e\\a\u003c/code\u003e, \u003ccode\u003e\\\\\u003c/code\u003e,\n\u003ccode\u003e?\u003c/code\u003e, \u003ccode\u003e\\\u0027\u003c/code\u003e, \u003ccode\u003e\\\"\u003c/code\u003e, \u003ccode\u003e\\\u0026lt;Octal Number\u0026gt;\u003c/code\u003e, and \u003ccode\u003e\\x\u0026lt;Hexadecimal Number\u0026gt;\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nconst char_t a[ 2 ] \u003d \"\\k\";   // Noncompliant\nconst char_t b[ 2 ] \u003d \"\\b\";   // Compliant\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 4.1 - Only those escape sequences that are defined in ISO C standard shall be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 2-13-1 - Only those escape sequences that are defined in ISO/IEC 14882:2003 shall be used. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "based-on-misra"
    ],
    "deprecatedKeys": [
      "cpp:InvalidEscapeSequence"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:M23_126",
    "name": "The \"goto\" statement shall jump to a label declared later in the function body",
    "defaultSeverity": "BLOCKER",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 9.6.3\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eThe unconstrained use of \u003ccode\u003egoto\u003c/code\u003e can lead to programs that are extremely difficult to comprehend and analyse. However, flags may need to\nbe introduced to give the required control flow when it is not used, with the possibility that the flags may themselves make the code less transparent\nthan if \u003ccode\u003egoto\u003c/code\u003e were used. The restricted use of \u003ccode\u003egoto\u003c/code\u003e is therefore allowed where that use will not lead to semantics contrary\nto developer expectations.\u003c/p\u003e\n\u003cp\u003eThis rule prohibits the use of back jumps as they can be used to introduce iteration without using the well-defined iteration statements supplied\nby the language.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e the C++ Standard places restrictions on the uses of forward jumps. For example, it is not permitted to jump from a point\nwhere a local variable with initialization is not in scope to a point where it is in scope.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nvoid f()\n{\n  int32_t x \u003d 0;\n\nL1:\n  if ( x \u003d\u003d 10 )\n  {\n    goto L2;       // Compliant\n  }\n  else\n  {\n    ++x;\n    goto L1;       // Non-compliant\n  }\n\nL2:\n  return;\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S999} targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:M23_403}: MISRA C++ 2023 Rule\u0026nbsp;9.6.1 - The \u003ccode\u003egoto\u003c/code\u003e statement should not be used \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2023 Rule\u0026nbsp;9.6.2 - A \u003ccode\u003egoto\u003c/code\u003e statement shall reference a label in a surrounding block \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 9.6.3\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eThe unconstrained use of \u003ccode\u003egoto\u003c/code\u003e can lead to programs that are extremely difficult to comprehend and analyse. However, flags may need to\nbe introduced to give the required control flow when it is not used, with the possibility that the flags may themselves make the code less transparent\nthan if \u003ccode\u003egoto\u003c/code\u003e were used. The restricted use of \u003ccode\u003egoto\u003c/code\u003e is therefore allowed where that use will not lead to semantics contrary\nto developer expectations.\u003c/p\u003e\n\u003cp\u003eThis rule prohibits the use of back jumps as they can be used to introduce iteration without using the well-defined iteration statements supplied\nby the language.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e the C++ Standard places restrictions on the uses of forward jumps. For example, it is not permitted to jump from a point\nwhere a local variable with initialization is not in scope to a point where it is in scope.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nvoid f()\n{\n  int32_t x \u003d 0;\n\nL1:\n  if ( x \u003d\u003d 10 )\n  {\n    goto L2;       // Compliant\n  }\n  else\n  {\n    ++x;\n    goto L1;       // Non-compliant\n  }\n\nL2:\n  return;\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S999} targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:M23_403}: MISRA C++ 2023 Rule\u0026nbsp;9.6.1 - The \u003ccode\u003egoto\u003c/code\u003e statement should not be used \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2023 Rule\u0026nbsp;9.6.2 - A \u003ccode\u003egoto\u003c/code\u003e statement shall reference a label in a surrounding block \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "misra-c++2023",
      "misra-required",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:M23_007",
    "name": "The value returned by a function shall be \"used\"",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 0.1.2\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eThis rule only applies when the function is called explicitly using \u003cem\u003efunction call\u003c/em\u003e syntax.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eIt is possible to call a function without \u003cem\u003eusing\u003c/em\u003e [1] the return value, which may be an error. If the return value of a function is intended\nto be explicitly discarded, it should be cast to \u003ccode\u003evoid\u003c/code\u003e to ensure that it is \u003cem\u003eused\u003c/em\u003e [1].\u003c/p\u003e\n\u003cp\u003eOverloaded operators are excluded from this requirement, as they should behave in the same way as built-in operators.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e this rule effectively requires all non-\u003ccode\u003evoid\u003c/code\u003e functions to be treated as if they were declared\n\u003ccode\u003e[[nodiscard]]\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nuint16_t func();\n\nvoid discarded()\n{\n  func();                         // Non-compliant - implicitly discarded\n  ( void )func();                 // Compliant - void cast is a use\n  auto b \u003d func();                // Compliant - used as initializer\n}\n\nvoid f1( std::string q )\n{\n  std::string s { q } ;           // Rule does not apply - not function call syntax\n  s \u003d q;                          // Rule does not apply - not function call syntax\n  s.operator\u003d( q );               // Non-compliant\n}\n\nvoid f2( std::function\u0026lt; int() \u0026gt; \u0026amp; f )\n{\n  f();                            // Non-compliant - using function call syntax\n\n  auto a \u003d []() { return 10; };\n  a();                            // Non-compliant - using function call syntax\n}\n\u003c/pre\u003e\n\u003ch3\u003eGlossary\u003c/h3\u003e\n\u003ch4\u003e[1] Use / used / using\u003c/h4\u003e\n\u003cp\u003eAn object is \u003cem\u003eused\u003c/em\u003e if:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e It is the subject of a cast; or \u003c/li\u003e\n  \u003cli\u003e It is explicitly initialized at declaration time; or \u003c/li\u003e\n  \u003cli\u003e It is an operand in an expression; or \u003c/li\u003e\n  \u003cli\u003e It is referenced. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eA function is \u003cem\u003eused\u003c/em\u003e as defined in {rule:cpp:M23_331}: MISRA C++ 2023 Rule\u0026nbsp;0.2.4.\u003c/p\u003e\n\u003cp\u003eA type is \u003cem\u003eused\u003c/em\u003e as defined in MISRA C++ 2023 Rule\u0026nbsp;0.2.3 (Types with \u003cem\u003elimited visibility\u003c/em\u003e should be \u003cem\u003eused\u003c/em\u003e at least\nonce).\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:M23_287}: MISRA C++ 2023 Rule\u0026nbsp;28.6.4 - The result of \u003ccode\u003estd::remove\u003c/code\u003e, \u003ccode\u003estd::remove_if\u003c/code\u003e,\n  \u003ccode\u003estd::unique\u003c/code\u003e and \u003ccode\u003eempty\u003c/code\u003e shall be \u003cem\u003eused\u003c/em\u003e \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S6007} targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 0.1.2\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eThis rule only applies when the function is called explicitly using \u003cem\u003efunction call\u003c/em\u003e syntax.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eIt is possible to call a function without \u003cem\u003eusing\u003c/em\u003e [1] the return value, which may be an error. If the return value of a function is intended\nto be explicitly discarded, it should be cast to \u003ccode\u003evoid\u003c/code\u003e to ensure that it is \u003cem\u003eused\u003c/em\u003e [1].\u003c/p\u003e\n\u003cp\u003eOverloaded operators are excluded from this requirement, as they should behave in the same way as built-in operators.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e this rule effectively requires all non-\u003ccode\u003evoid\u003c/code\u003e functions to be treated as if they were declared\n\u003ccode\u003e[[nodiscard]]\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nuint16_t func();\n\nvoid discarded()\n{\n  func();                         // Non-compliant - implicitly discarded\n  ( void )func();                 // Compliant - void cast is a use\n  auto b \u003d func();                // Compliant - used as initializer\n}\n\nvoid f1( std::string q )\n{\n  std::string s { q } ;           // Rule does not apply - not function call syntax\n  s \u003d q;                          // Rule does not apply - not function call syntax\n  s.operator\u003d( q );               // Non-compliant\n}\n\nvoid f2( std::function\u0026lt; int() \u0026gt; \u0026amp; f )\n{\n  f();                            // Non-compliant - using function call syntax\n\n  auto a \u003d []() { return 10; };\n  a();                            // Non-compliant - using function call syntax\n}\n\u003c/pre\u003e\n\u003ch3\u003eGlossary\u003c/h3\u003e\n\u003ch4\u003e[1] Use / used / using\u003c/h4\u003e\n\u003cp\u003eAn object is \u003cem\u003eused\u003c/em\u003e if:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e It is the subject of a cast; or \u003c/li\u003e\n  \u003cli\u003e It is explicitly initialized at declaration time; or \u003c/li\u003e\n  \u003cli\u003e It is an operand in an expression; or \u003c/li\u003e\n  \u003cli\u003e It is referenced. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eA function is \u003cem\u003eused\u003c/em\u003e as defined in {rule:cpp:M23_331}: MISRA C++ 2023 Rule\u0026nbsp;0.2.4.\u003c/p\u003e\n\u003cp\u003eA type is \u003cem\u003eused\u003c/em\u003e as defined in MISRA C++ 2023 Rule\u0026nbsp;0.2.3 (Types with \u003cem\u003elimited visibility\u003c/em\u003e should be \u003cem\u003eused\u003c/em\u003e at least\nonce).\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:M23_287}: MISRA C++ 2023 Rule\u0026nbsp;28.6.4 - The result of \u003ccode\u003estd::remove\u003c/code\u003e, \u003ccode\u003estd::remove_if\u003c/code\u003e,\n  \u003ccode\u003estd::unique\u003c/code\u003e and \u003ccode\u003eempty\u003c/code\u003e shall be \u003cem\u003eused\u003c/em\u003e \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S6007} targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "misra-c++2023",
      "misra-required",
      "unused"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:M23_003",
    "name": "Variables with \"limited visibility\" should be \"used\" at least once",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 0.2.1\u003c/p\u003e\n\u003cp\u003eCategory: Advisory\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eA variable has \u003cem\u003elimited visibility\u003c/em\u003e if it is not a function parameter, and it has internal linkage or no linkage.\u003c/p\u003e\n\u003cp\u003eA variable is \u003cem\u003eused\u003c/em\u003e [1] when:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e It is part of an \u003cem\u003eid-expression\u003c/em\u003e; or \u003c/li\u003e\n  \u003cli\u003e The variable is of class type and has a \u003cem\u003euser-provided\u003c/em\u003e constructor or a \u003cem\u003euser-provided\u003c/em\u003e destructor. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eVariables that are declared and never used within a project do not contribute to program output; they constitute noise and may indicate that the\nwrong variable name has been used or that one or more statements are missing.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e this rule allows the introduction of variables for the sole purpose of providing scoped resource allocation and release. For\nexample:\u003c/p\u003e\n\u003cpre\u003e\n{\n  std::lock_guard\u0026lt; std::mutex \u0026gt; lock { mutex };    // Compliant - has user-provided\n                                                   //             constructor\n  // ...\n} // User-provided destructor implicitly called here\n\u003c/pre\u003e\n\u003ch3\u003eException\u003c/h3\u003e\n\u003cp\u003eThis rule does not apply to:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Variables that have at least one \u003cem\u003edeclaration\u003c/em\u003e [2] with the \u003ccode\u003e[[maybe_unused]]\u003c/code\u003e attribute. \u003c/li\u003e\n  \u003cli\u003e Constant variables at namespace scope that are declared within a \u003cem\u003eheader file\u003c/em\u003e [3]. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nclass C { };                  // No user-provided constructor or destructor\n\nnamespace\n{\n  C c;                        // Non-compliant - unused\n}\n\nvoid maybeUnused( int32_t a )\n{\n  [[maybe_unused]]\n    bool b \u003d a \u0026gt; 0;           // Compliant (by exception #1 if NDEBUG is defined)\n\n  assert( b );                // Does not use b if NDEBUG is defined\n\n  usefn( a );\n}\n\nconst int16_t x \u003d 19;         // Compliant - x is read in initializedButNotUsed\nconst int16_t y \u003d 21;         // Non-compliant - would be compliant by exception #2\n                              //                 if declared in a header file\n\nvoid initializedButNotUsed()\n{\n  int16_t local_1 \u003d 42;       // Non-compliant - local_1 is never read\n  int16_t local_2;            // Compliant\n\n  local_2 \u003d x;                // Use of local_2 for the purposes of this rule\n}\n\nvoid userProvidedCtor()\n{\n  std::ifstream fs { \"cfg.ini\" };    // Compliant - user-provided constructor\n}\n\u003c/pre\u003e\n\u003ch3\u003eGlossary\u003c/h3\u003e\n\u003ch4\u003e[1] Use / used / using\u003c/h4\u003e\n\u003cp\u003eAn object is \u003cem\u003eused\u003c/em\u003e if:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e It is the subject of a cast; or \u003c/li\u003e\n  \u003cli\u003e It is explicitly initialized at declaration time; or \u003c/li\u003e\n  \u003cli\u003e It is an operand in an expression; or \u003c/li\u003e\n  \u003cli\u003e It is referenced. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eA function is \u003cem\u003eused\u003c/em\u003e as defined in {rule:cpp:M23_331}: MISRA C++ 2023 Rule\u0026nbsp;0.2.4.\u003c/p\u003e\n\u003cp\u003eA type is \u003cem\u003eused\u003c/em\u003e as defined in MISRA C++ 2023 Rule\u0026nbsp;0.2.3 (Types with \u003cem\u003elimited visibility\u003c/em\u003e should be \u003cem\u003eused\u003c/em\u003e at least\nonce).\u003c/p\u003e\n\u003ch4\u003e[2] Declaration\u003c/h4\u003e\n\u003cp\u003eA \u003cem\u003edeclaration\u003c/em\u003e introduces the name of an \u003cem\u003eentity\u003c/em\u003e into a \u003cem\u003etranslation unit\u003c/em\u003e (see [basic.def]/1).\u003c/p\u003e\n\u003cp\u003eAn \u003cem\u003eentity\u003c/em\u003e may be \u003cem\u003edeclared\u003c/em\u003e several times. The first \u003cem\u003edeclaration\u003c/em\u003e of an \u003cem\u003eentity\u003c/em\u003e in a \u003cem\u003etranslation unit\u003c/em\u003e is\ncalled an \u003cem\u003eintroduction\u003c/em\u003e [4]. All subsequent \u003cem\u003edeclarations\u003c/em\u003e are called \u003cem\u003eredeclarations\u003c/em\u003e [5].\u003c/p\u003e\n\u003cp\u003eA \u003cem\u003edefinition\u003c/em\u003e [6] is a \u003cem\u003edeclaration\u003c/em\u003e, as described in [basic.def]/2.\u003c/p\u003e\n\u003ch4\u003e[3] Header file\u003c/h4\u003e\n\u003cp\u003eA \u003cem\u003eheader file\u003c/em\u003e is considered to be any file that is included during preprocessing (for example via the \u003ccode\u003e#include\u003c/code\u003e directive),\nregardless of its name or suffix.\u003c/p\u003e\n\u003ch4\u003e[4] Introduction\u003c/h4\u003e\n\u003cp\u003eSee \u003cem\u003edeclaration\u003c/em\u003e [2].\u003c/p\u003e\n\u003ch4\u003e[5] Redeclaration\u003c/h4\u003e\n\u003cp\u003eSee \u003cem\u003edeclaration\u003c/em\u003e [2].\u003c/p\u003e\n\u003ch4\u003e[6] Definition\u003c/h4\u003e\n\u003cp\u003eSee \u003cem\u003edeclaration\u003c/em\u003e [2].\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S1481} targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2023 Rule\u0026nbsp;0.2.2 - A named function parameter shall be \u003cem\u003eused\u003c/em\u003e at least once \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 0.2.1\u003c/p\u003e\n\u003cp\u003eCategory: Advisory\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eA variable has \u003cem\u003elimited visibility\u003c/em\u003e if it is not a function parameter, and it has internal linkage or no linkage.\u003c/p\u003e\n\u003cp\u003eA variable is \u003cem\u003eused\u003c/em\u003e [1] when:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e It is part of an \u003cem\u003eid-expression\u003c/em\u003e; or \u003c/li\u003e\n  \u003cli\u003e The variable is of class type and has a \u003cem\u003euser-provided\u003c/em\u003e constructor or a \u003cem\u003euser-provided\u003c/em\u003e destructor. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eVariables that are declared and never used within a project do not contribute to program output; they constitute noise and may indicate that the\nwrong variable name has been used or that one or more statements are missing.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e this rule allows the introduction of variables for the sole purpose of providing scoped resource allocation and release. For\nexample:\u003c/p\u003e\n\u003cpre\u003e\n{\n  std::lock_guard\u0026lt; std::mutex \u0026gt; lock { mutex };    // Compliant - has user-provided\n                                                   //             constructor\n  // ...\n} // User-provided destructor implicitly called here\n\u003c/pre\u003e\n\u003ch3\u003eException\u003c/h3\u003e\n\u003cp\u003eThis rule does not apply to:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Variables that have at least one \u003cem\u003edeclaration\u003c/em\u003e [2] with the \u003ccode\u003e[[maybe_unused]]\u003c/code\u003e attribute. \u003c/li\u003e\n  \u003cli\u003e Constant variables at namespace scope that are declared within a \u003cem\u003eheader file\u003c/em\u003e [3]. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nclass C { };                  // No user-provided constructor or destructor\n\nnamespace\n{\n  C c;                        // Non-compliant - unused\n}\n\nvoid maybeUnused( int32_t a )\n{\n  [[maybe_unused]]\n    bool b \u003d a \u0026gt; 0;           // Compliant (by exception #1 if NDEBUG is defined)\n\n  assert( b );                // Does not use b if NDEBUG is defined\n\n  usefn( a );\n}\n\nconst int16_t x \u003d 19;         // Compliant - x is read in initializedButNotUsed\nconst int16_t y \u003d 21;         // Non-compliant - would be compliant by exception #2\n                              //                 if declared in a header file\n\nvoid initializedButNotUsed()\n{\n  int16_t local_1 \u003d 42;       // Non-compliant - local_1 is never read\n  int16_t local_2;            // Compliant\n\n  local_2 \u003d x;                // Use of local_2 for the purposes of this rule\n}\n\nvoid userProvidedCtor()\n{\n  std::ifstream fs { \"cfg.ini\" };    // Compliant - user-provided constructor\n}\n\u003c/pre\u003e\n\u003ch3\u003eGlossary\u003c/h3\u003e\n\u003ch4\u003e[1] Use / used / using\u003c/h4\u003e\n\u003cp\u003eAn object is \u003cem\u003eused\u003c/em\u003e if:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e It is the subject of a cast; or \u003c/li\u003e\n  \u003cli\u003e It is explicitly initialized at declaration time; or \u003c/li\u003e\n  \u003cli\u003e It is an operand in an expression; or \u003c/li\u003e\n  \u003cli\u003e It is referenced. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eA function is \u003cem\u003eused\u003c/em\u003e as defined in {rule:cpp:M23_331}: MISRA C++ 2023 Rule\u0026nbsp;0.2.4.\u003c/p\u003e\n\u003cp\u003eA type is \u003cem\u003eused\u003c/em\u003e as defined in MISRA C++ 2023 Rule\u0026nbsp;0.2.3 (Types with \u003cem\u003elimited visibility\u003c/em\u003e should be \u003cem\u003eused\u003c/em\u003e at least\nonce).\u003c/p\u003e\n\u003ch4\u003e[2] Declaration\u003c/h4\u003e\n\u003cp\u003eA \u003cem\u003edeclaration\u003c/em\u003e introduces the name of an \u003cem\u003eentity\u003c/em\u003e into a \u003cem\u003etranslation unit\u003c/em\u003e (see [basic.def]/1).\u003c/p\u003e\n\u003cp\u003eAn \u003cem\u003eentity\u003c/em\u003e may be \u003cem\u003edeclared\u003c/em\u003e several times. The first \u003cem\u003edeclaration\u003c/em\u003e of an \u003cem\u003eentity\u003c/em\u003e in a \u003cem\u003etranslation unit\u003c/em\u003e is\ncalled an \u003cem\u003eintroduction\u003c/em\u003e [4]. All subsequent \u003cem\u003edeclarations\u003c/em\u003e are called \u003cem\u003eredeclarations\u003c/em\u003e [5].\u003c/p\u003e\n\u003cp\u003eA \u003cem\u003edefinition\u003c/em\u003e [6] is a \u003cem\u003edeclaration\u003c/em\u003e, as described in [basic.def]/2.\u003c/p\u003e\n\u003ch4\u003e[3] Header file\u003c/h4\u003e\n\u003cp\u003eA \u003cem\u003eheader file\u003c/em\u003e is considered to be any file that is included during preprocessing (for example via the \u003ccode\u003e#include\u003c/code\u003e directive),\nregardless of its name or suffix.\u003c/p\u003e\n\u003ch4\u003e[4] Introduction\u003c/h4\u003e\n\u003cp\u003eSee \u003cem\u003edeclaration\u003c/em\u003e [2].\u003c/p\u003e\n\u003ch4\u003e[5] Redeclaration\u003c/h4\u003e\n\u003cp\u003eSee \u003cem\u003edeclaration\u003c/em\u003e [2].\u003c/p\u003e\n\u003ch4\u003e[6] Definition\u003c/h4\u003e\n\u003cp\u003eSee \u003cem\u003edeclaration\u003c/em\u003e [2].\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S1481} targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2023 Rule\u0026nbsp;0.2.2 - A named function parameter shall be \u003cem\u003eused\u003c/em\u003e at least once \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "misra-advisory",
      "misra-c++2023",
      "unused"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6236",
    "name": "rvalue reference members should not be copied accidentally",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "EFFICIENT",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eC++11 introduced the concept of \u003cem\u003eforwarding-reference\u003c/em\u003e, as a way to transfer values efficiently. In combination with\n\u003ccode\u003estd::forward\u003c/code\u003e, their usage allows passing values without unnecessary copies.\u003c/p\u003e\n\u003cp\u003eThe expression \u003ccode\u003estd::forward\u0026lt;T\u0026gt;(obj).mem\u003c/code\u003e, can be used to forward the value of the member, according to the type of\n\u003ccode\u003eobj\u003c/code\u003e: move the value of member \u003ccode\u003emem\u003c/code\u003e if the \u003ccode\u003eobj\u003c/code\u003e is an rvalue reference and copy it otherwise. However, in the\ncorner case, when the member \u003ccode\u003emem\u003c/code\u003e is of rvalue reference type, the value it references will be copied even if \u003ccode\u003eobj\u003c/code\u003e itself is\nan rvalue, the referenced value will not be moved.\u003c/p\u003e\n\u003cp\u003eSimilarly for \u003ccode\u003estd::move\u003c/code\u003e: if \u003ccode\u003emem\u003c/code\u003e is of rvalue reference type, \u003ccode\u003estd::move(obj).mem\u003c/code\u003e will copy the value\nreferenced by \u003ccode\u003emem\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThis rule raises issues when a templates is instantiated with a type that leads to an accidental copy of members of forwarded objects.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\ntemplate\u0026lt;typename... Ts\u0026gt;\nvoid consume(Ts\u0026amp;\u0026amp;... ts)\n\n\ntemplate\u0026lt;typename T, typename U\u0026gt;\nvoid consumePair(std::pair\u0026lt;T, U\u0026gt;\u0026amp;\u0026amp; p) {\n  consume(std::move(p).first, std::move(p).second); // Noncompliant (see later)\n}\nvoid use1() {\n  std::string x \u003d \"x\", y \u003d \"y\";\n  std::pair\u0026lt;std:string\u0026amp;\u0026amp;, std::string\u0026amp;\u0026amp;\u0026gt; rRefPair(std::move(x), std::move(y));\n  consumePair(std::move(rRefPair)); // Triggers noncompliant instantiation of consumePair\n                                    // with T \u003d std:::string\u0026amp;\u0026amp; and U \u003d std::string\u0026amp;\u0026amp;\n}\n\n\ntemplate\u0026lt;typename Pair\u0026gt;\nvoid forwardPair(Pair\u0026amp;\u0026amp; p) {\n  consume(std::forward\u0026lt;Pair\u0026gt;(p).first, std::forward\u0026lt;Pair\u0026gt;(p).second); // Noncompliant (see later)\n}\nvoid use2() {\n  std::string x \u003d \"x\", y \u003d \"y\";\n  std::pair\u0026lt;std:string\u0026amp;\u0026amp;, std::string\u0026amp;\u0026amp;\u0026gt; rRefPair(std::move(x), std::move(y));\n  forwardPair(rRefPair); // OK, lvalue is passed, and the members should and are copied\n                         // Pair \u003d std::pair\u0026lt;std:string\u0026amp;\u0026amp;, std::string\u0026amp;\u0026amp;\u0026gt;\u0026amp;\n  forwardPair(std::move(rRefPair)); // Triggers noncompliant instantiation of forwardPair\n                                    // with Pair \u003d std::pair\u0026lt;std:string\u0026amp;\u0026amp;, std::string\u0026amp;\u0026amp;\u0026gt;\n}\n\n\ntemplate\u0026lt;typename Pair\u0026gt;\nvoid forwardStruct(T\u0026amp;\u0026amp; p) {\n  consume(std::forward\u0026lt;T\u0026gt;(p).mem); // Noncompliant (see later)\n}\nstruct Proxy {\n    std::vector\u0026lt;int\u0026gt;\u0026amp;\u0026amp; mem;\n};\nvoid use3() {\n  std::vector\u0026lt;int\u0026gt; v;\n  Proxy proxy{std::move(v)};\n  forwardStruct(proxy); // OK, lvalue is passed, and the members should and are copied\n                        // T \u003d Proxy\u0026amp;\n  forwardStruct(std::move(proxy)); // Triggers noncompliant instantiation of forwardStruct\n                                   // with T \u003d Proxy\n}\n\n\nvoid compiler_error() {\n  std::unique_ptr\u0026lt;int\u0026gt; u;\n  std::pair\u0026lt;std::unique_ptr\u0026lt;int\u0026gt;\u0026amp;\u0026amp;, int\u0026gt; pair(std::move(u), 1);\n  // std::unique_ptr\u0026lt;int\u0026gt; u2 \u003d std::move(pair).first; // ill-formed trying to copy\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\ntemplate\u0026lt;typename T, typename U\u0026gt;\nvoid consumePair(std::pair\u0026lt;T, U\u0026gt;\u0026amp;\u0026amp; p) {\n    consume(std::get\u0026lt;0\u0026gt;(std::move(p)), std::get\u0026lt;1\u0026gt;(std::move(p)));\n}\n\n\ntemplate\u0026lt;typename Pair\u0026gt;\nvoid forwardPair(Pair\u0026amp;\u0026amp; p) {\n    consume(std::get\u0026lt;0\u0026gt;(std::forward\u0026lt;Pair\u0026gt;(p)), std::get\u0026lt;1\u0026gt;(std::forward\u0026lt;Pair\u0026gt;(p)));\n}\n\n\ntemplate\u0026lt;typename Pair\u0026gt;\nvoid forwardStruct(T\u0026amp;\u0026amp; t) {\n  constexpr bool isMoveOfRvalueReferenceMember\n      \u003d std::is_rvalue_reference_v\u0026lt;decltype(t.mem)\u0026gt; \u0026amp;\u0026amp; std::is_rvalue_reference_v\u0026lt;T\u0026amp;\u0026amp;\u0026gt;;\n  if constexpr (isMoveOfRvalueReferenceMember) {\n    consume(std::move(t.mem));\n  } else {\n    consume(std::forward\u0026lt;T\u0026gt;(t).mem);\n  }\n}\n\n\nvoid compiler_error() {\n  std::unique_ptr\u0026lt;int\u0026gt; u;\n  std::pair\u0026lt;std::unique_ptr\u0026lt;int\u0026gt;\u0026amp;\u0026amp;, int\u0026gt; pair(std::move(u), 1);\n  std::unique_ptr\u0026lt;int\u0026gt; u2 \u003d std::move(pair.first);\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eC++11 introduced the concept of \u003cem\u003eforwarding-reference\u003c/em\u003e, as a way to transfer values efficiently. In combination with\n\u003ccode\u003estd::forward\u003c/code\u003e, their usage allows passing values without unnecessary copies.\u003c/p\u003e\n\u003cp\u003eThe expression \u003ccode\u003estd::forward\u0026lt;T\u0026gt;(obj).mem\u003c/code\u003e, can be used to forward the value of the member, according to the type of\n\u003ccode\u003eobj\u003c/code\u003e: move the value of member \u003ccode\u003emem\u003c/code\u003e if the \u003ccode\u003eobj\u003c/code\u003e is an rvalue reference and copy it otherwise. However, in the\ncorner case, when the member \u003ccode\u003emem\u003c/code\u003e is of rvalue reference type, the value it references will be copied even if \u003ccode\u003eobj\u003c/code\u003e itself is\nan rvalue, the referenced value will not be moved.\u003c/p\u003e\n\u003cp\u003eSimilarly for \u003ccode\u003estd::move\u003c/code\u003e: if \u003ccode\u003emem\u003c/code\u003e is of rvalue reference type, \u003ccode\u003estd::move(obj).mem\u003c/code\u003e will copy the value\nreferenced by \u003ccode\u003emem\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThis rule raises issues when a templates is instantiated with a type that leads to an accidental copy of members of forwarded objects.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\ntemplate\u0026lt;typename... Ts\u0026gt;\nvoid consume(Ts\u0026amp;\u0026amp;... ts)\n\n\ntemplate\u0026lt;typename T, typename U\u0026gt;\nvoid consumePair(std::pair\u0026lt;T, U\u0026gt;\u0026amp;\u0026amp; p) {\n  consume(std::move(p).first, std::move(p).second); // Noncompliant (see later)\n}\nvoid use1() {\n  std::string x \u003d \"x\", y \u003d \"y\";\n  std::pair\u0026lt;std:string\u0026amp;\u0026amp;, std::string\u0026amp;\u0026amp;\u0026gt; rRefPair(std::move(x), std::move(y));\n  consumePair(std::move(rRefPair)); // Triggers noncompliant instantiation of consumePair\n                                    // with T \u003d std:::string\u0026amp;\u0026amp; and U \u003d std::string\u0026amp;\u0026amp;\n}\n\n\ntemplate\u0026lt;typename Pair\u0026gt;\nvoid forwardPair(Pair\u0026amp;\u0026amp; p) {\n  consume(std::forward\u0026lt;Pair\u0026gt;(p).first, std::forward\u0026lt;Pair\u0026gt;(p).second); // Noncompliant (see later)\n}\nvoid use2() {\n  std::string x \u003d \"x\", y \u003d \"y\";\n  std::pair\u0026lt;std:string\u0026amp;\u0026amp;, std::string\u0026amp;\u0026amp;\u0026gt; rRefPair(std::move(x), std::move(y));\n  forwardPair(rRefPair); // OK, lvalue is passed, and the members should and are copied\n                         // Pair \u003d std::pair\u0026lt;std:string\u0026amp;\u0026amp;, std::string\u0026amp;\u0026amp;\u0026gt;\u0026amp;\n  forwardPair(std::move(rRefPair)); // Triggers noncompliant instantiation of forwardPair\n                                    // with Pair \u003d std::pair\u0026lt;std:string\u0026amp;\u0026amp;, std::string\u0026amp;\u0026amp;\u0026gt;\n}\n\n\ntemplate\u0026lt;typename Pair\u0026gt;\nvoid forwardStruct(T\u0026amp;\u0026amp; p) {\n  consume(std::forward\u0026lt;T\u0026gt;(p).mem); // Noncompliant (see later)\n}\nstruct Proxy {\n    std::vector\u0026lt;int\u0026gt;\u0026amp;\u0026amp; mem;\n};\nvoid use3() {\n  std::vector\u0026lt;int\u0026gt; v;\n  Proxy proxy{std::move(v)};\n  forwardStruct(proxy); // OK, lvalue is passed, and the members should and are copied\n                        // T \u003d Proxy\u0026amp;\n  forwardStruct(std::move(proxy)); // Triggers noncompliant instantiation of forwardStruct\n                                   // with T \u003d Proxy\n}\n\n\nvoid compiler_error() {\n  std::unique_ptr\u0026lt;int\u0026gt; u;\n  std::pair\u0026lt;std::unique_ptr\u0026lt;int\u0026gt;\u0026amp;\u0026amp;, int\u0026gt; pair(std::move(u), 1);\n  // std::unique_ptr\u0026lt;int\u0026gt; u2 \u003d std::move(pair).first; // ill-formed trying to copy\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\ntemplate\u0026lt;typename T, typename U\u0026gt;\nvoid consumePair(std::pair\u0026lt;T, U\u0026gt;\u0026amp;\u0026amp; p) {\n    consume(std::get\u0026lt;0\u0026gt;(std::move(p)), std::get\u0026lt;1\u0026gt;(std::move(p)));\n}\n\n\ntemplate\u0026lt;typename Pair\u0026gt;\nvoid forwardPair(Pair\u0026amp;\u0026amp; p) {\n    consume(std::get\u0026lt;0\u0026gt;(std::forward\u0026lt;Pair\u0026gt;(p)), std::get\u0026lt;1\u0026gt;(std::forward\u0026lt;Pair\u0026gt;(p)));\n}\n\n\ntemplate\u0026lt;typename Pair\u0026gt;\nvoid forwardStruct(T\u0026amp;\u0026amp; t) {\n  constexpr bool isMoveOfRvalueReferenceMember\n      \u003d std::is_rvalue_reference_v\u0026lt;decltype(t.mem)\u0026gt; \u0026amp;\u0026amp; std::is_rvalue_reference_v\u0026lt;T\u0026amp;\u0026amp;\u0026gt;;\n  if constexpr (isMoveOfRvalueReferenceMember) {\n    consume(std::move(t.mem));\n  } else {\n    consume(std::forward\u0026lt;T\u0026gt;(t).mem);\n  }\n}\n\n\nvoid compiler_error() {\n  std::unique_ptr\u0026lt;int\u0026gt; u;\n  std::pair\u0026lt;std::unique_ptr\u0026lt;int\u0026gt;\u0026amp;\u0026amp;, int\u0026gt; pair(std::move(u), 1);\n  std::unique_ptr\u0026lt;int\u0026gt; u2 \u003d std::move(pair.first);\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "performance",
      "pitfall",
      "since-c++11"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5269",
    "name": "Class members should not be initialized with dangling references",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eSpecial attention should be paid when initializing class members: it is easy to get it wrong and initialize them with references that are going to\nbe invalidated at the end of the constructor, known as dangling references.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstruct S {\n  int *x;\n  int \u0026amp;y;\n  S(int i, int j) :\n    x(\u0026amp;i),  // Noncompliant, initializing x to the stack address of i\n    y(j)  // Noncompliant, y is bound to variable j which has a shorter lifetime\n  {}\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstruct S {\n  int *x;\n  int \u0026amp;y;\n  S(int *i, int \u0026amp;j) : x(i), y(j) {}\n};\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eSpecial attention should be paid when initializing class members: it is easy to get it wrong and initialize them with references that are going to\nbe invalidated at the end of the constructor, known as dangling references.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstruct S {\n  int *x;\n  int \u0026amp;y;\n  S(int i, int j) :\n    x(\u0026amp;i),  // Noncompliant, initializing x to the stack address of i\n    y(j)  // Noncompliant, y is bound to variable j which has a shorter lifetime\n  {}\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstruct S {\n  int *x;\n  int \u0026amp;y;\n  S(int *i, int \u0026amp;j) : x(i), y(j) {}\n};\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5266",
    "name": "Keywords shall not be used as macros identifiers",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eIn programming languages, keywords have a special meaning and are reserved for the language. Hence, it is a bad idea to define macros with keywords\nas macro identifiers as it can easily lead to undefined behavior:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The same object might be defined differently in different places, which violates the One Definition Rule \u003c/li\u003e\n  \u003cli\u003e If you include any header from the standard library, it is undefined behavior to define such macros \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eAdditionally, it is awkward for anyone reading the code to have a keyword that means something different.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#define int some_other_type // Noncompliant\n#include \u0026lt;stdlib.h\u0026gt;\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Wikipedia - \u003ca href\u003d\"https://en.wikipedia.org/wiki/One_Definition_Rule\"\u003eOne Definition Rule\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/definition\"\u003eDefinitions and ODR (One Definition Rule)\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2012, 20.4 -\u0026nbsp;A macro shall not be defined with the same name as a keyword \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eIn programming languages, keywords have a special meaning and are reserved for the language. Hence, it is a bad idea to define macros with keywords\nas macro identifiers as it can easily lead to undefined behavior:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The same object might be defined differently in different places, which violates the One Definition Rule \u003c/li\u003e\n  \u003cli\u003e If you include any header from the standard library, it is undefined behavior to define such macros \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eAdditionally, it is awkward for anyone reading the code to have a keyword that means something different.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#define int some_other_type // Noncompliant\n#include \u0026lt;stdlib.h\u0026gt;\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Wikipedia - \u003ca href\u003d\"https://en.wikipedia.org/wiki/One_Definition_Rule\"\u003eOne Definition Rule\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/definition\"\u003eDefinitions and ODR (One Definition Rule)\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2012, 20.4 -\u0026nbsp;A macro shall not be defined with the same name as a keyword \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "pitfall",
      "unpredictable"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6234",
    "name": "\"auto\" should be used to store a result of functions that conventionally return an iterator or a range",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eauto\u003c/code\u003e\u0026nbsp;is a type placeholder that may be used in variable declarations to instruct the compiler to infer the type from the\ninitializer.\u003c/p\u003e\n\u003cp\u003eThe use of \u003ccode\u003eauto\u003c/code\u003e reduces unnecessary boilerplate in situations where the type of the variable is apparent from the context (see rule\n{rule:cpp:S5827}). In other situations, though, whether \u003ccode\u003eauto\u003c/code\u003e increases or decreases readability is a matter of personal taste.\u003c/p\u003e\n\u003cp\u003eIn the case of variables initialized from a function that conventionally returns an iterator (e.g., \u003ccode\u003ebegin\u003c/code\u003e, \u003ccode\u003eend\u003c/code\u003e,\n\u003ccode\u003estd::find\u003c/code\u003e), it is clear that the type of the variable is some iterator. Spelling the exact type of the iterator in such a situation does\nnot improve the clarity of the code, especially considering the usual verbosity of such types. The same can be said for functions returning\nranges.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue on the declaration of a variable that is initialized with the return value of a function that conventionally returns an\niterator when the variable is declared with an explicit type equal to the function’s return type. The detected functions are:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003ebegin\u003c/code\u003e and \u003ccode\u003eend\u003c/code\u003e functions and their const and reverse variants \u003c/li\u003e\n  \u003cli\u003e standard algorithms that return iterators or ranges \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstd::vector\u0026lt;int\u0026gt;::iterator someFunction(std::vector\u0026lt;int\u0026gt;\u0026amp; v);\n\nvoid f() {\n  std::vector\u0026lt;int\u0026gt; v;\n  const std::vector\u0026lt;int\u0026gt;\u0026amp; cv \u003d v;\n\n  std::vector\u0026lt;int\u0026gt;::iterator it1 \u003d v.begin(); // Noncompliant\n  std::vector\u0026lt;int\u0026gt;::const_iterator it2 \u003d v.cbegin(); // Noncompliant\n  std::vector\u0026lt;int\u0026gt;::const_iterator it3 \u003d cv.cbegin(); // Noncompliant\n  std::vector\u0026lt;int\u0026gt;::const_iterator it4 \u003d std::begin(cv); // Noncompliant\n\n  std::vector\u0026lt;int\u0026gt;::iterator it5 \u003d std::find(v.begin(), v.end(), 10);  // Noncompliant\n\n   std::map\u0026lt;int, std::string\u0026gt; m;\n   if (std::map\u0026lt;int, std::string\u0026gt;::iterator it \u003d m.find(20); it !\u003d m.end()) { // Noncompliant\n      // do something\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstd::vector\u0026lt;int\u0026gt;::iterator someFunction(std::vector\u0026lt;int\u0026gt;\u0026amp; v);\n\nvoid f() {\n  std::vector\u0026lt;int\u0026gt; v;\n  const std::vector\u0026lt;int\u0026gt;\u0026amp; cv \u003d v;\n\n  auto it1 \u003d v.begin();\n  auto it2 \u003d v.cbegin();\n  auto it3 \u003d cv.cbegin();\n  auto it4 \u003d std::begin(cv);\n\n  std::vector\u0026lt;int\u0026gt;::const_iterator it5 \u003d v.begin(); // Compliant, the type is different\n  std::vector\u0026lt;int\u0026gt;::iterator it6 \u003d someFunction(10);  // Compliant, the function is not a well-known function returning an iterator\n\n  auto it7 \u003d std::find(v.begin(), v.end(), 10);\n  std::vector\u0026lt;int\u0026gt;::iterator it8 \u003d someFunction(10);\n\n   std::map\u0026lt;int, std::string\u0026gt; m;\n   if (auto it \u003d m.find(20); it !\u003d m.end()) {\n      // do something\n  }\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S5827} - use auto to avoid repetition of types \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003ccode\u003eauto\u003c/code\u003e\u0026nbsp;is a type placeholder that may be used in variable declarations to instruct the compiler to infer the type from the\ninitializer.\u003c/p\u003e\n\u003cp\u003eThe use of \u003ccode\u003eauto\u003c/code\u003e reduces unnecessary boilerplate in situations where the type of the variable is apparent from the context (see rule\n{rule:cpp:S5827}). In other situations, though, whether \u003ccode\u003eauto\u003c/code\u003e increases or decreases readability is a matter of personal taste.\u003c/p\u003e\n\u003cp\u003eIn the case of variables initialized from a function that conventionally returns an iterator (e.g., \u003ccode\u003ebegin\u003c/code\u003e, \u003ccode\u003eend\u003c/code\u003e,\n\u003ccode\u003estd::find\u003c/code\u003e), it is clear that the type of the variable is some iterator. Spelling the exact type of the iterator in such a situation does\nnot improve the clarity of the code, especially considering the usual verbosity of such types. The same can be said for functions returning\nranges.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue on the declaration of a variable that is initialized with the return value of a function that conventionally returns an\niterator when the variable is declared with an explicit type equal to the function’s return type. The detected functions are:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003ebegin\u003c/code\u003e and \u003ccode\u003eend\u003c/code\u003e functions and their const and reverse variants \u003c/li\u003e\n  \u003cli\u003e standard algorithms that return iterators or ranges \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstd::vector\u0026lt;int\u0026gt;::iterator someFunction(std::vector\u0026lt;int\u0026gt;\u0026amp; v);\n\nvoid f() {\n  std::vector\u0026lt;int\u0026gt; v;\n  const std::vector\u0026lt;int\u0026gt;\u0026amp; cv \u003d v;\n\n  std::vector\u0026lt;int\u0026gt;::iterator it1 \u003d v.begin(); // Noncompliant\n  std::vector\u0026lt;int\u0026gt;::const_iterator it2 \u003d v.cbegin(); // Noncompliant\n  std::vector\u0026lt;int\u0026gt;::const_iterator it3 \u003d cv.cbegin(); // Noncompliant\n  std::vector\u0026lt;int\u0026gt;::const_iterator it4 \u003d std::begin(cv); // Noncompliant\n\n  std::vector\u0026lt;int\u0026gt;::iterator it5 \u003d std::find(v.begin(), v.end(), 10);  // Noncompliant\n\n   std::map\u0026lt;int, std::string\u0026gt; m;\n   if (std::map\u0026lt;int, std::string\u0026gt;::iterator it \u003d m.find(20); it !\u003d m.end()) { // Noncompliant\n      // do something\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstd::vector\u0026lt;int\u0026gt;::iterator someFunction(std::vector\u0026lt;int\u0026gt;\u0026amp; v);\n\nvoid f() {\n  std::vector\u0026lt;int\u0026gt; v;\n  const std::vector\u0026lt;int\u0026gt;\u0026amp; cv \u003d v;\n\n  auto it1 \u003d v.begin();\n  auto it2 \u003d v.cbegin();\n  auto it3 \u003d cv.cbegin();\n  auto it4 \u003d std::begin(cv);\n\n  std::vector\u0026lt;int\u0026gt;::const_iterator it5 \u003d v.begin(); // Compliant, the type is different\n  std::vector\u0026lt;int\u0026gt;::iterator it6 \u003d someFunction(10);  // Compliant, the function is not a well-known function returning an iterator\n\n  auto it7 \u003d std::find(v.begin(), v.end(), 10);\n  std::vector\u0026lt;int\u0026gt;::iterator it8 \u003d someFunction(10);\n\n   std::map\u0026lt;int, std::string\u0026gt; m;\n   if (auto it \u003d m.find(20); it !\u003d m.end()) {\n      // do something\n  }\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S5827} - use auto to avoid repetition of types \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "since-c++11"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5025",
    "name": "Memory should not be managed manually",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "FOCUSED",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eIf you manage memory manually, it’s your responsibility to \u003ccode\u003edelete\u003c/code\u003e all memory created with \u003ccode\u003enew\u003c/code\u003e, and to make sure it’s\n\u003ccode\u003edelete\u003c/code\u003ed once and only once. Ensuring this is done is error-prone, especially when your function can have early exit points.\u003c/p\u003e\n\u003cp\u003eFortunately, the C++ language provides tools that automatically manage memory for you. Using them systematically makes the code simpler and more\nrobust without sacrificing performance.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when you use:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003enew\u003c/code\u003e - you should prefer a factory function that returns a smart pointer, such as \u003ccode\u003estd::make_unique\u003c/code\u003e or, if shared\n  ownership is required, \u003ccode\u003estd::make_shared\u003c/code\u003e, \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003enew[]\u003c/code\u003e - you should prefer a container class, such as \u003ccode\u003estd::vector\u003c/code\u003e, \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003edelete\u003c/code\u003e or \u003ccode\u003edelete[]\u003c/code\u003e - if you followed the previous advice, there is no need to manually release memory. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIf your compiler does not support \u003ccode\u003emake_unique\u003c/code\u003e, it’s easy to write your own:\u003c/p\u003e\n\u003cpre\u003e\ntemplate\u0026lt;typename T, typename... Args\u0026gt;\nstd::unique_ptr\u0026lt;T\u0026gt; make_unique(Args\u0026amp;\u0026amp;... args) {\n    return std::unique_ptr\u0026lt;T\u0026gt;(new T(std::forward\u0026lt;Args\u0026gt;(args)...));\n}\n\u003c/pre\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid f() {\n  auto c \u003d new Circle(0, 0, 5);\n  c-\u0026gt;draw();\n  delete c;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid f() {\n  auto c \u003d make_unique\u0026lt;Circle\u0026gt;(0, 0, 5);\n  c-\u0026gt;draw();\n  unique_ptr\u0026lt;Circle\u0026gt; c2{new Circle(0, 0, 5)}; // Clumsy, but still compliant by exception\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eIf the result of a new is immediately passed as an argument to a function, we assume that the function takes ownership of the newly created object,\nand won’t raise an issue.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#r11-avoid-calling-new-and-delete-explicitly\"\u003eR.11: Avoid calling\n  \u003ccode\u003enew\u003c/code\u003e and \u003ccode\u003edelete\u003c/code\u003e explicitly\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c149-use-unique_ptr-or-shared_ptr-to-avoid-forgetting-to-delete-objects-created-using-new\"\u003eC.149: Use \u003ccode\u003eunique_ptr\u003c/code\u003e or \u003ccode\u003eshared_ptr\u003c/code\u003e to avoid forgetting to \u003ccode\u003edelete\u003c/code\u003e objects created using \u003ccode\u003enew\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eIf you manage memory manually, it’s your responsibility to \u003ccode\u003edelete\u003c/code\u003e all memory created with \u003ccode\u003enew\u003c/code\u003e, and to make sure it’s\n\u003ccode\u003edelete\u003c/code\u003ed once and only once. Ensuring this is done is error-prone, especially when your function can have early exit points.\u003c/p\u003e\n\u003cp\u003eFortunately, the C++ language provides tools that automatically manage memory for you. Using them systematically makes the code simpler and more\nrobust without sacrificing performance.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when you use:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003enew\u003c/code\u003e - you should prefer a factory function that returns a smart pointer, such as \u003ccode\u003estd::make_unique\u003c/code\u003e or, if shared\n  ownership is required, \u003ccode\u003estd::make_shared\u003c/code\u003e, \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003enew[]\u003c/code\u003e - you should prefer a container class, such as \u003ccode\u003estd::vector\u003c/code\u003e, \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003edelete\u003c/code\u003e or \u003ccode\u003edelete[]\u003c/code\u003e - if you followed the previous advice, there is no need to manually release memory. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIf your compiler does not support \u003ccode\u003emake_unique\u003c/code\u003e, it’s easy to write your own:\u003c/p\u003e\n\u003cpre\u003e\ntemplate\u0026lt;typename T, typename... Args\u0026gt;\nstd::unique_ptr\u0026lt;T\u0026gt; make_unique(Args\u0026amp;\u0026amp;... args) {\n    return std::unique_ptr\u0026lt;T\u0026gt;(new T(std::forward\u0026lt;Args\u0026gt;(args)...));\n}\n\u003c/pre\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid f() {\n  auto c \u003d new Circle(0, 0, 5);\n  c-\u0026gt;draw();\n  delete c;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid f() {\n  auto c \u003d make_unique\u0026lt;Circle\u0026gt;(0, 0, 5);\n  c-\u0026gt;draw();\n  unique_ptr\u0026lt;Circle\u0026gt; c2{new Circle(0, 0, 5)}; // Clumsy, but still compliant by exception\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eIf the result of a new is immediately passed as an argument to a function, we assume that the function takes ownership of the newly created object,\nand won’t raise an issue.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#r11-avoid-calling-new-and-delete-explicitly\"\u003eR.11: Avoid calling\n  \u003ccode\u003enew\u003c/code\u003e and \u003ccode\u003edelete\u003c/code\u003e explicitly\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c149-use-unique_ptr-or-shared_ptr-to-avoid-forgetting-to-delete-objects-created-using-new\"\u003eC.149: Use \u003ccode\u003eunique_ptr\u003c/code\u003e or \u003ccode\u003eshared_ptr\u003c/code\u003e to avoid forgetting to \u003ccode\u003edelete\u003c/code\u003e objects created using \u003ccode\u003enew\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "bad-practice",
      "cppcoreguidelines",
      "since-c++11"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5267",
    "name": "Functions with \"noreturn\" attribute should not return",
    "defaultSeverity": "BLOCKER",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe \"noreturn\" attribute should be used to indicate that a function does not return to its caller: it may terminate the program, enter an infinite\nloop, or throw an exception.\u003c/p\u003e\n\u003cp\u003eThis attribute is typically used for functions that perform critical operations, such as exiting the program or handling an error condition. For\nexample, the \"exit\" function is marked with the \"noreturn\" attribute because it terminates the program and does not return to its caller.\u003c/p\u003e\n\u003cp\u003eUsing this attribute allows the compiler to make some assumptions that can lead to optimizations. However, functions marked with the \"noreturn\"\nattribute should not have a return statement because it leads to undefined behavior and unexpected results.\u003c/p\u003e\n\u003cp\u003eThis rules equally applies to C++11 \u003ccode\u003e[[noreturn]]\u003c/code\u003e notation or C11 \u003ccode\u003e_Noreturn\u003c/code\u003e keyword notation. It raises an issue when the\nattribute is incorrectly used.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eThere are two opposite approaches to fix this issue: remove the \"noreturn\" attribute or update the function to never return.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre\u003e\nint global;\n\n[[noreturn]]\nvoid longRunningTask() {\n  while (true) {\n    // ...\n    if (global \u003d\u003d 0) {\n      return; // Noncompliant: this function should not return.\n    }\n  }\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eThere are many ways to address the issue in the previous code snippet. Here are some examples.\u003c/p\u003e\n\u003cp\u003eIt can be updated to never return:\u003c/p\u003e\n\u003cpre\u003e\n[[noreturn]]\nvoid longRunningTask() {\n  while (true) {\n    // ...\n  }\n}\n\u003c/pre\u003e\n\u003cp\u003eOr the \"noreturn\" attribute can be removed:\u003c/p\u003e\n\u003cpre\u003e\nvoid longRunningTask() {\n  while (true) {\n    // ...\n    if (global \u003d\u003d 0) {\n      return;\n    }\n  }\n}\n\u003c/pre\u003e\n\u003cp\u003eOr, in C++, the return statement can be turned into a throw expression:\u003c/p\u003e\n\u003cpre\u003e\n[[noreturn]]\nvoid longRunningTask() {\n  while (true) {\n    // ...\n    if (global \u003d\u003d 0) {\n      throw std::runtime_error(\"invalid global state\");\n    }\n  }\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/attributes/noreturn\"\u003eC++ attribute: noreturn\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/c/language/_Noreturn\"\u003e_Noreturn function specifier\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe \"noreturn\" attribute should be used to indicate that a function does not return to its caller: it may terminate the program, enter an infinite\nloop, or throw an exception.\u003c/p\u003e\n\u003cp\u003eThis attribute is typically used for functions that perform critical operations, such as exiting the program or handling an error condition. For\nexample, the \"exit\" function is marked with the \"noreturn\" attribute because it terminates the program and does not return to its caller.\u003c/p\u003e\n\u003cp\u003eUsing this attribute allows the compiler to make some assumptions that can lead to optimizations. However, functions marked with the \"noreturn\"\nattribute should not have a return statement because it leads to undefined behavior and unexpected results.\u003c/p\u003e\n\u003cp\u003eThis rules equally applies to C++11 \u003ccode\u003e[[noreturn]]\u003c/code\u003e notation or C11 \u003ccode\u003e_Noreturn\u003c/code\u003e keyword notation. It raises an issue when the\nattribute is incorrectly used.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eThere are two opposite approaches to fix this issue: remove the \"noreturn\" attribute or update the function to never return.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre\u003e\nint global;\n\n[[noreturn]]\nvoid longRunningTask() {\n  while (true) {\n    // ...\n    if (global \u003d\u003d 0) {\n      return; // Noncompliant: this function should not return.\n    }\n  }\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eThere are many ways to address the issue in the previous code snippet. Here are some examples.\u003c/p\u003e\n\u003cp\u003eIt can be updated to never return:\u003c/p\u003e\n\u003cpre\u003e\n[[noreturn]]\nvoid longRunningTask() {\n  while (true) {\n    // ...\n  }\n}\n\u003c/pre\u003e\n\u003cp\u003eOr the \"noreturn\" attribute can be removed:\u003c/p\u003e\n\u003cpre\u003e\nvoid longRunningTask() {\n  while (true) {\n    // ...\n    if (global \u003d\u003d 0) {\n      return;\n    }\n  }\n}\n\u003c/pre\u003e\n\u003cp\u003eOr, in C++, the return statement can be turned into a throw expression:\u003c/p\u003e\n\u003cpre\u003e\n[[noreturn]]\nvoid longRunningTask() {\n  while (true) {\n    // ...\n    if (global \u003d\u003d 0) {\n      throw std::runtime_error(\"invalid global state\");\n    }\n  }\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/attributes/noreturn\"\u003eC++ attribute: noreturn\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/c/language/_Noreturn\"\u003e_Noreturn function specifier\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "confusing"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5028",
    "name": "Macros should not be used to define constants",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eA macro is a textual replacement, which means that it’s not respecting the type system, it’s not respecting scoping rules…​ There is no reason not\nto use a constant instead.\u003c/p\u003e\n\u003cp\u003eMost of the time, a macro can be replaced by a \u003ccode\u003econstexpr\u003c/code\u003e declaration (a constant that is guaranteed to be computed during\ncompilation). If your compiler is too old to properly handle \u003ccode\u003econstexpr\u003c/code\u003e, you may use \u003ccode\u003econst\u003c/code\u003e instead.\u003c/p\u003e\n\u003cp\u003eIf you have a series of related integer macros, you might also consider replacing them by an \u003ccode\u003eenum\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#define MAX_MEMORY 640 // Noncompliant\n\n#define LEFT   0 // Noncompliant\n#define RIGHT  1 // Noncompliant\n#define JUMP   2 // Noncompliant\n#define SHOOT  3 // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nconstexpr size_t MAX_MEMORY \u003d 640;\nenum class Actions {Left, Right, Jump, Shoot};\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es31-dont-use-macros-for-constants-or-functions\"\u003eES.31: Don’t\n  use macros for constants or \"functions\"\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#enum1-prefer-enumerations-over-macros\"\u003eEnum.1: Prefer\n  enumerations over macros\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eA macro is a textual replacement, which means that it’s not respecting the type system, it’s not respecting scoping rules…​ There is no reason not\nto use a constant instead.\u003c/p\u003e\n\u003cp\u003eMost of the time, a macro can be replaced by a \u003ccode\u003econstexpr\u003c/code\u003e declaration (a constant that is guaranteed to be computed during\ncompilation). If your compiler is too old to properly handle \u003ccode\u003econstexpr\u003c/code\u003e, you may use \u003ccode\u003econst\u003c/code\u003e instead.\u003c/p\u003e\n\u003cp\u003eIf you have a series of related integer macros, you might also consider replacing them by an \u003ccode\u003eenum\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#define MAX_MEMORY 640 // Noncompliant\n\n#define LEFT   0 // Noncompliant\n#define RIGHT  1 // Noncompliant\n#define JUMP   2 // Noncompliant\n#define SHOOT  3 // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nconstexpr size_t MAX_MEMORY \u003d 640;\nenum class Actions {Left, Right, Jump, Shoot};\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es31-dont-use-macros-for-constants-or-functions\"\u003eES.31: Don’t\n  use macros for constants or \"functions\"\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#enum1-prefer-enumerations-over-macros\"\u003eEnum.1: Prefer\n  enumerations over macros\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "bad-practice",
      "clumsy",
      "cppcoreguidelines"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5491",
    "name": "Enums should be consistent with the bit fields they initialize",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eBit fields can only have integral or enumeration type. If it is quite straightforward to check if an integral type can initialize a bit field, it\nis however trickier with an enum type: the bit field has to be wide enough to store all the possible values of the enum.\u003c/p\u003e\n\u003cp\u003eIn addition to this, the signedness of the enum should be consistent with the signedness of the bit field:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e an unsigned bit field can not be initialized with a signed enum type \u003c/li\u003e\n  \u003cli\u003e a signed bit field uses one bit to store the sign and this needs to be taken into account while comparing the size of the enum type with the\n  size of the bit field. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nenum Color {\n  BLUE \u003d 16\n} myColor;\n\nenum Fruit {\n  ORANGE \u003d 1,\n  APPLE \u003d 2\n} myFruit;\n\nstruct BitStructForColor {\n    unsigned int b : 2;\n};\n\nstruct BitStructForFruit {\n    signed int b : 2;\n};\n\nvoid f(BitStructForColor  \u0026amp;bColorStruct, BitStructForFruit  \u0026amp;bFruitStruct) {\n  bColorStruct.b \u003d myColor; // Noncompliant, myColor is too wide for the bit field\n  bFruitStruct.b \u003d myFruit; // Noncompliant, one bit of the bit field is used to store the sign\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nenum Color {\n  BLUE \u003d 16\n} myColor;\n\nenum Fruit {\n  ORANGE \u003d 1,\n  APPLE \u003d 2\n} myFruit;\n\nstruct BitStructForColor {\n    unsigned int b : 5;\n};\n\nstruct BitStructForFruit {\n    signed int b : 3;\n};\n\nvoid f(BitStructForColor  \u0026amp;bColorStruct, BitStructForFruit  \u0026amp;bFruitStruct) {\n  bColorStruct.b \u003d myColor;\n  bFruitStruct.b \u003d myFruit;\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eBit fields can only have integral or enumeration type. If it is quite straightforward to check if an integral type can initialize a bit field, it\nis however trickier with an enum type: the bit field has to be wide enough to store all the possible values of the enum.\u003c/p\u003e\n\u003cp\u003eIn addition to this, the signedness of the enum should be consistent with the signedness of the bit field:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e an unsigned bit field can not be initialized with a signed enum type \u003c/li\u003e\n  \u003cli\u003e a signed bit field uses one bit to store the sign and this needs to be taken into account while comparing the size of the enum type with the\n  size of the bit field. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nenum Color {\n  BLUE \u003d 16\n} myColor;\n\nenum Fruit {\n  ORANGE \u003d 1,\n  APPLE \u003d 2\n} myFruit;\n\nstruct BitStructForColor {\n    unsigned int b : 2;\n};\n\nstruct BitStructForFruit {\n    signed int b : 2;\n};\n\nvoid f(BitStructForColor  \u0026amp;bColorStruct, BitStructForFruit  \u0026amp;bFruitStruct) {\n  bColorStruct.b \u003d myColor; // Noncompliant, myColor is too wide for the bit field\n  bFruitStruct.b \u003d myFruit; // Noncompliant, one bit of the bit field is used to store the sign\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nenum Color {\n  BLUE \u003d 16\n} myColor;\n\nenum Fruit {\n  ORANGE \u003d 1,\n  APPLE \u003d 2\n} myFruit;\n\nstruct BitStructForColor {\n    unsigned int b : 5;\n};\n\nstruct BitStructForFruit {\n    signed int b : 3;\n};\n\nvoid f(BitStructForColor  \u0026amp;bColorStruct, BitStructForFruit  \u0026amp;bFruitStruct) {\n  bColorStruct.b \u003d myColor;\n  bFruitStruct.b \u003d myFruit;\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6460",
    "name": "Template should not be constrained with ad-hoc requires-expression",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eSince C++20, it is possible to add a \u003cem\u003erequires-clause\u003c/em\u003e to a template as a way to express requirements (constraints) on the template\narguments. This construct is versatile and allows any expression that evaluates to either \u003ccode\u003etrue\u003c/code\u003e or \u003ccode\u003efalse\u003c/code\u003e at compile time to\nbe used. One of these expressions is the \u003cem\u003erequires-expression\u003c/em\u003e, which can be used to express required operations on types:\u003c/p\u003e\n\u003cpre\u003e\ntemplate\u0026lt;typename M\u0026gt;\n  requires requires(M a, M b) {\n    { a + b };\n    { a * b };\n  }\nM fma(M a, M b, M c) {\n  return a + (b * c);\n}\n\u003c/pre\u003e\n\u003cp\u003eWhile the use of an ad-hoc \u003cem\u003erequires-expression\u003c/em\u003e provides a way to quickly constrain a template, it limits the readability of the code:\nWhile it conveys the required syntax requirements, it fails to express the semantics associated with the operations. For instance, the above template\nexpects that \u003ccode\u003e+\u003c/code\u003e and \u003ccode\u003e*\u003c/code\u003e perform mathematical additions and multiplications, not a concatenation of strings.\u003c/p\u003e\n\u003cp\u003eUsing a concept with a well-chosen name solves this issue and meaningful concepts that are reused in different parts of the codebase increase the\nlevel of abstraction of the code: You don’t need to check individual operations, you just need to know that your type is \u003cem\u003eintegral\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eMoreover, one interesting feature of concepts is called \u003cem\u003esubsumption\u003c/em\u003e. It means that when a function overload is constrained with a list of\nconcepts, and another overload is constrained with the same concepts plus additional constraints, then the second function is considered as more\nconstrained than the first one, and will be selected by overload resolution if the concepts are satisfied.\u003c/p\u003e\n\u003cp\u003eThis feature only works with concepts: a \u003cem\u003erequires-expression\u003c/em\u003e is never considered to be more constrained than another one, even if both\ncontain identical subexpressions. For instance, the following overloads of \u003ccode\u003erotate\u003c/code\u003e are ambiguous for any iterator that is at least\nbidirectional, as constraints for both of them are satisfied:\u003c/p\u003e\n\u003cpre\u003e\ntemplate\u0026lt;typename ForwardIt\u0026gt;\n  requires requires(ForwardIt it) {\n    /* dereference and others */\n    ++it;\n  }\nForwardIt rotate(ForwardIt first, ForwardIt mid, ForwardIt last);\n\ntemplate\u0026lt;typename BidirectionalIt\u0026gt;\n  requires requires(BidirectionalIt it) {\n    /* dereference and others */\n    ++it;\n    --it;\n  }\nBidirectionalIt rotate(BidirectionalIt first, BidirectionalIt mid,  BidirectionalIt last);\n\u003c/pre\u003e\n\u003cp\u003eThis rule raises an issue for any use of an ad-hoc \u003cem\u003erequires-expression\u003c/em\u003e in the requirements of template functions, classes, or\nvariables.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\ntemplate\u0026lt;typename M\u0026gt;\n  requires requires(M a, M b) { // noncompliant\n    { a + b };\n    { a * b };\n  }\nM fma(M a, M b, M c) {\n  return a + (b * c);\n}\n\ntemplate\u0026lt;typename ForwardIt\u0026gt;\n  requires requires(ForwardIt it) { // noncompliant\n    /* dereference and others */\n    ++it;\n  }\nForwardIt rotate(ForwardIt first, ForwardIt mid, ForwardIt last);\n\ntemplate\u0026lt;typename BidirectionalIt\u0026gt;\n  requires requires(BidirectionalIt it) { // noncompliant\n    /* dereference and others */\n    ++it;\n    --it;\n  }\nBidirectionalIt rotate(BidirectionalIt first, BidirectionalIt mid, BidirectionalIt last);\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\ntemplate\u0026lt;typename T\u0026gt;\nconcept Multiplicative \u003d requires(const T a, const T b) {\n  { a + b };\n  { a * b };\n}\n\ntemplate\u0026lt;Multiplicative M\u0026gt;\nM fma(M a, M b, M c) {\n  return a + (b * c);\n}\n\ntemplate\u0026lt;class ForwardIt\u0026gt;\n  requires std::forward_iterator\u0026lt;ForwardIt\u0026gt;\nForwardIt rotate(ForwardIt first, ForwardIt mid, ForwardIt last);\n\n// std::bidirectional_iterator subsumes std::forward_iterator, as it is defined as:\n// template\u0026lt;class I\u0026gt;\n//   concept bidirectional_iterator \u003d forward_iterator\u0026lt;I\u0026gt; \u0026amp;\u0026amp; additional requirements;\ntemplate\u0026lt;class BidirectionalIt\u0026gt;\n  requires std::bidirectional_iterator\u0026lt;BidirectionalIt\u0026gt;\nBidirectionalIt rotate(BidirectionalIt first, BidirectionalIt mid, BidirectionalIt last);\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eSince C++20, it is possible to add a \u003cem\u003erequires-clause\u003c/em\u003e to a template as a way to express requirements (constraints) on the template\narguments. This construct is versatile and allows any expression that evaluates to either \u003ccode\u003etrue\u003c/code\u003e or \u003ccode\u003efalse\u003c/code\u003e at compile time to\nbe used. One of these expressions is the \u003cem\u003erequires-expression\u003c/em\u003e, which can be used to express required operations on types:\u003c/p\u003e\n\u003cpre\u003e\ntemplate\u0026lt;typename M\u0026gt;\n  requires requires(M a, M b) {\n    { a + b };\n    { a * b };\n  }\nM fma(M a, M b, M c) {\n  return a + (b * c);\n}\n\u003c/pre\u003e\n\u003cp\u003eWhile the use of an ad-hoc \u003cem\u003erequires-expression\u003c/em\u003e provides a way to quickly constrain a template, it limits the readability of the code:\nWhile it conveys the required syntax requirements, it fails to express the semantics associated with the operations. For instance, the above template\nexpects that \u003ccode\u003e+\u003c/code\u003e and \u003ccode\u003e*\u003c/code\u003e perform mathematical additions and multiplications, not a concatenation of strings.\u003c/p\u003e\n\u003cp\u003eUsing a concept with a well-chosen name solves this issue and meaningful concepts that are reused in different parts of the codebase increase the\nlevel of abstraction of the code: You don’t need to check individual operations, you just need to know that your type is \u003cem\u003eintegral\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eMoreover, one interesting feature of concepts is called \u003cem\u003esubsumption\u003c/em\u003e. It means that when a function overload is constrained with a list of\nconcepts, and another overload is constrained with the same concepts plus additional constraints, then the second function is considered as more\nconstrained than the first one, and will be selected by overload resolution if the concepts are satisfied.\u003c/p\u003e\n\u003cp\u003eThis feature only works with concepts: a \u003cem\u003erequires-expression\u003c/em\u003e is never considered to be more constrained than another one, even if both\ncontain identical subexpressions. For instance, the following overloads of \u003ccode\u003erotate\u003c/code\u003e are ambiguous for any iterator that is at least\nbidirectional, as constraints for both of them are satisfied:\u003c/p\u003e\n\u003cpre\u003e\ntemplate\u0026lt;typename ForwardIt\u0026gt;\n  requires requires(ForwardIt it) {\n    /* dereference and others */\n    ++it;\n  }\nForwardIt rotate(ForwardIt first, ForwardIt mid, ForwardIt last);\n\ntemplate\u0026lt;typename BidirectionalIt\u0026gt;\n  requires requires(BidirectionalIt it) {\n    /* dereference and others */\n    ++it;\n    --it;\n  }\nBidirectionalIt rotate(BidirectionalIt first, BidirectionalIt mid,  BidirectionalIt last);\n\u003c/pre\u003e\n\u003cp\u003eThis rule raises an issue for any use of an ad-hoc \u003cem\u003erequires-expression\u003c/em\u003e in the requirements of template functions, classes, or\nvariables.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\ntemplate\u0026lt;typename M\u0026gt;\n  requires requires(M a, M b) { // noncompliant\n    { a + b };\n    { a * b };\n  }\nM fma(M a, M b, M c) {\n  return a + (b * c);\n}\n\ntemplate\u0026lt;typename ForwardIt\u0026gt;\n  requires requires(ForwardIt it) { // noncompliant\n    /* dereference and others */\n    ++it;\n  }\nForwardIt rotate(ForwardIt first, ForwardIt mid, ForwardIt last);\n\ntemplate\u0026lt;typename BidirectionalIt\u0026gt;\n  requires requires(BidirectionalIt it) { // noncompliant\n    /* dereference and others */\n    ++it;\n    --it;\n  }\nBidirectionalIt rotate(BidirectionalIt first, BidirectionalIt mid, BidirectionalIt last);\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\ntemplate\u0026lt;typename T\u0026gt;\nconcept Multiplicative \u003d requires(const T a, const T b) {\n  { a + b };\n  { a * b };\n}\n\ntemplate\u0026lt;Multiplicative M\u0026gt;\nM fma(M a, M b, M c) {\n  return a + (b * c);\n}\n\ntemplate\u0026lt;class ForwardIt\u0026gt;\n  requires std::forward_iterator\u0026lt;ForwardIt\u0026gt;\nForwardIt rotate(ForwardIt first, ForwardIt mid, ForwardIt last);\n\n// std::bidirectional_iterator subsumes std::forward_iterator, as it is defined as:\n// template\u0026lt;class I\u0026gt;\n//   concept bidirectional_iterator \u003d forward_iterator\u0026lt;I\u0026gt; \u0026amp;\u0026amp; additional requirements;\ntemplate\u0026lt;class BidirectionalIt\u0026gt;\n  requires std::bidirectional_iterator\u0026lt;BidirectionalIt\u0026gt;\nBidirectionalIt rotate(BidirectionalIt first, BidirectionalIt mid, BidirectionalIt last);\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "bad-practice",
      "confusing",
      "since-c++20"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5495",
    "name": "Capture by reference in lambdas used locally",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "EFFICIENT",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eIf the lifetime of the arguments passed to a lambda function is longer than the lifetime of the lambda itself, these arguments can be passed by\nreference.\u003c/p\u003e\n\u003cp\u003eDoing so avoids copying potentially big objects and it should be preferred over using copy capture.\u003c/p\u003e\n\u003cp\u003eThis rule reports an issue if a lambda passed into an algorithm that uses it locally (all algorithms in headers \u003ccode\u003e\u0026lt;algorithm\u0026gt;\u003c/code\u003e and\n\u003ccode\u003e\u0026lt;numeric\u0026gt;\u003c/code\u003e) captures some values.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nusing Vec \u003d vector\u0026lt;int\u0026gt;;\n\nVec applyPermutation(const Vec\u0026amp; v, const Vec\u0026amp; permutation) {\n    assert(v.size() \u003d\u003d permutation.size());\n\n    const auto n \u003d v.size();\n    Vec result(n);\n\n    // Noncompliant: this will copy the entire v vector for each iteration, resulting in n^2 operations\n    transform(permutation.begin(), permutation.end(), back_inserter(result),\n      [v](int position){ return v[position]; });\n\n     return result;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nusing Vec \u003d vector\u0026lt;int\u0026gt;;\n\nVec applyPermutation(const Vec\u0026amp; v, const Vec\u0026amp; permutation) {\n    assert(v.size() \u003d\u003d permutation.size());\n\n    const auto n \u003d v.size();\n    Vec result(n);\n\n    // Compliant: this will NOT copy the entire v vector for each iteration, resulting in n operations\n    transform(permutation.begin(), permutation.end(), back_inserter(result),\n      [\u0026amp;v](int position){ return v[position]; });\n\n     return result;\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f52-prefer-capturing-by-reference-in-lambdas-that-will-be-used-locally-including-passed-to-algorithms\"\u003eF.52: Prefer capturing by reference in lambdas that will be used locally, including passed to algorithms\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eIf the lifetime of the arguments passed to a lambda function is longer than the lifetime of the lambda itself, these arguments can be passed by\nreference.\u003c/p\u003e\n\u003cp\u003eDoing so avoids copying potentially big objects and it should be preferred over using copy capture.\u003c/p\u003e\n\u003cp\u003eThis rule reports an issue if a lambda passed into an algorithm that uses it locally (all algorithms in headers \u003ccode\u003e\u0026lt;algorithm\u0026gt;\u003c/code\u003e and\n\u003ccode\u003e\u0026lt;numeric\u0026gt;\u003c/code\u003e) captures some values.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nusing Vec \u003d vector\u0026lt;int\u0026gt;;\n\nVec applyPermutation(const Vec\u0026amp; v, const Vec\u0026amp; permutation) {\n    assert(v.size() \u003d\u003d permutation.size());\n\n    const auto n \u003d v.size();\n    Vec result(n);\n\n    // Noncompliant: this will copy the entire v vector for each iteration, resulting in n^2 operations\n    transform(permutation.begin(), permutation.end(), back_inserter(result),\n      [v](int position){ return v[position]; });\n\n     return result;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nusing Vec \u003d vector\u0026lt;int\u0026gt;;\n\nVec applyPermutation(const Vec\u0026amp; v, const Vec\u0026amp; permutation) {\n    assert(v.size() \u003d\u003d permutation.size());\n\n    const auto n \u003d v.size();\n    Vec result(n);\n\n    // Compliant: this will NOT copy the entire v vector for each iteration, resulting in n operations\n    transform(permutation.begin(), permutation.end(), back_inserter(result),\n      [\u0026amp;v](int position){ return v[position]; });\n\n     return result;\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f52-prefer-capturing-by-reference-in-lambdas-that-will-be-used-locally-including-passed-to-algorithms\"\u003eF.52: Prefer capturing by reference in lambdas that will be used locally, including passed to algorithms\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "bad-practice",
      "cppcoreguidelines",
      "performance",
      "since-c++11"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6221",
    "name": "Concept names should comply with a naming convention",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "IDENTIFIABLE",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eShared coding conventions allow teams to collaborate effectively. This rule checks that all C++ concept names match a provided regular\nexpression.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cp\u003eWith default provided regular expression \u003ccode\u003e^[A-Z][a-zA-Z0-9]*$\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\ntemplate \u0026lt;class T\u0026gt;\nconcept integral \u003d std::is_integral_v\u0026lt;T\u0026gt;; // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\ntemplate \u0026lt;class T\u0026gt;\nconcept Integral \u003d std::is_integral_v\u0026lt;T\u0026gt;; // Compliant\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eShared coding conventions allow teams to collaborate effectively. This rule checks that all C++ concept names match a provided regular\nexpression.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cp\u003eWith default provided regular expression \u003ccode\u003e^[A-Z][a-zA-Z0-9]*$\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\ntemplate \u0026lt;class T\u0026gt;\nconcept integral \u003d std::is_integral_v\u0026lt;T\u0026gt;; // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\ntemplate \u0026lt;class T\u0026gt;\nconcept Integral \u003d std::is_integral_v\u0026lt;T\u0026gt;; // Compliant\n\u003c/pre\u003e"
      }
    ],
    "params": {
      "format": {
        "key": "format",
        "name": "format",
        "description": "POSIX regular expression used to check the concept name against",
        "defaultValue": "^[A-Z][a-zA-Z0-9]*$",
        "type": "STRING",
        "multiple": false,
        "possibleValues": []
      }
    },
    "defaultParams": {
      "format": "^[A-Z][a-zA-Z0-9]*$"
    },
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "convention",
      "since-c++20"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6222",
    "name": "\"[[nodiscard]]\" attributes on types should include explanations",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003e[[nodiscard]]\u003c/code\u003e attribute can be placed on type declarations to indicate that any value of such type should not be discarded when\nreturned from a function. Accompanying the attribute with the message, explaining why values should not be ignored, contributes to a better\nunderstanding of code. This is especially important in the case of types, as the reason for which values of the type should not be discarded is a\ndefining property of that type (information about failure, handle owning a scarce resource).\u003c/p\u003e\n\u003cp\u003eMoreover, marking a type as \u003ccode\u003enodiscard\u003c/code\u003e, causes a warning to be reported for invocation of every function that returns this type. As a\nconsequence, the cause of the warning is not directly visible from the declaration of the function and requires further investigation from the\nuser.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when \u003ccode\u003e[[nodiscard]]\u003c/code\u003e is used on a type without any explanation.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstruct [[nodiscard]] status_code {  // Noncompliant\n   int code();\n};\n\nstatus_code open(std::string_view path);\n\nint main()\n{\n   open(\"/home/user/list.txt\");  // warning is raised here\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstruct [[nodiscard(\"Possible errors should be checked\")]] status_code {\n   int code();\n};\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S6166} - introducing messages for \u003ccode\u003e[[nodiscard]]\u003c/code\u003e on functions \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S6007} - marking functions as \u003ccode\u003e[[nodicard]]\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe \u003ccode\u003e[[nodiscard]]\u003c/code\u003e attribute can be placed on type declarations to indicate that any value of such type should not be discarded when\nreturned from a function. Accompanying the attribute with the message, explaining why values should not be ignored, contributes to a better\nunderstanding of code. This is especially important in the case of types, as the reason for which values of the type should not be discarded is a\ndefining property of that type (information about failure, handle owning a scarce resource).\u003c/p\u003e\n\u003cp\u003eMoreover, marking a type as \u003ccode\u003enodiscard\u003c/code\u003e, causes a warning to be reported for invocation of every function that returns this type. As a\nconsequence, the cause of the warning is not directly visible from the declaration of the function and requires further investigation from the\nuser.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when \u003ccode\u003e[[nodiscard]]\u003c/code\u003e is used on a type without any explanation.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstruct [[nodiscard]] status_code {  // Noncompliant\n   int code();\n};\n\nstatus_code open(std::string_view path);\n\nint main()\n{\n   open(\"/home/user/list.txt\");  // warning is raised here\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstruct [[nodiscard(\"Possible errors should be checked\")]] status_code {\n   int code();\n};\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S6166} - introducing messages for \u003ccode\u003e[[nodiscard]]\u003c/code\u003e on functions \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S6007} - marking functions as \u003ccode\u003e[[nodicard]]\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "brain-overload",
      "since-c++20"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S787",
    "name": "Source code should only use /* ... */ style comments",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThis excludes the use of \u003ccode\u003e//\u003c/code\u003e C99 style comments and C++ style comments, since these are not permitted in C90. Many compilers support\nthe \u003ccode\u003e//\u003c/code\u003e style of comments as an extension to C90. The use of \u003ccode\u003e//\u003c/code\u003e in preprocessor directives (e.g. \u003ccode\u003e#define\u003c/code\u003e) can\nvary. Also the mixing of \u003ccode\u003e/* ... */\u003c/code\u003e and \u003ccode\u003e//\u003c/code\u003e is not consistent. This is more than a style issue, since different (pre C99)\ncompilers may behave differently.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint main(int argc, char* argv[])\n{\n  // Do nothing - Noncompliant\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint main(int argc, char* argv[])\n{\n  /* Do nothing - Compliant */\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 2.2 - Source code shall only use /* …​ */ style comments. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThis excludes the use of \u003ccode\u003e//\u003c/code\u003e C99 style comments and C++ style comments, since these are not permitted in C90. Many compilers support\nthe \u003ccode\u003e//\u003c/code\u003e style of comments as an extension to C90. The use of \u003ccode\u003e//\u003c/code\u003e in preprocessor directives (e.g. \u003ccode\u003e#define\u003c/code\u003e) can\nvary. Also the mixing of \u003ccode\u003e/* ... */\u003c/code\u003e and \u003ccode\u003e//\u003c/code\u003e is not consistent. This is more than a style issue, since different (pre C99)\ncompilers may behave differently.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint main(int argc, char* argv[])\n{\n  // Do nothing - Noncompliant\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint main(int argc, char* argv[])\n{\n  /* Do nothing - Compliant */\n  return 0;\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 2.2 - Source code shall only use /* …​ */ style comments. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "convention"
    ],
    "deprecatedKeys": [
      "cpp:C99CommentUsage"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6461",
    "name": "\"std::declval\" should not be used within requires-expression",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eA \u003cem\u003erequires-expression\u003c/em\u003e is used to express constraints on template arguments. A basic building block of these constraints is the capability\nto generate a subexpression whose type depends on a template argument.\u003c/p\u003e\n\u003cp\u003eThe traditional way to write such a subexpression is by using \u003ccode\u003estd::declval\u0026lt;\u0026gt;\u003c/code\u003e (doing something more naive such as\n\u003ccode\u003eT{}\u003c/code\u003e is not as generic, for instance, it requires T to be default-constructible). This is, however, very verbose and can be error prone:\n\u003ccode\u003edeclval\u0026lt;T\u0026gt;()\u003c/code\u003e yields an expression of type \u003ccode\u003eT\u0026amp;\u0026amp;\u003c/code\u003e, while referencing a variable directly produces an lvalue\n(\u003ccode\u003eT\u0026amp;\u003c/code\u003e). This, in many cases, leads to concepts incorrectly requiring only \u003cem\u003emove-construction\u003c/em\u003e, while copies are made by the\nimplementation.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eRequire-expressions\u003c/em\u003e introduce a more natural way to achieve that. When writing a \u003cem\u003erequires-expression\u003c/em\u003e, it is possible to add a\nparameter list, similar to function parameters, and these parameters can be used later in the expression. This syntax is less verbose, more\nexpressive, and less error-prone and should be preferred over calling \u003ccode\u003estd::declval\u003c/code\u003e in requires-expressions.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\ntemplate\u0026lt;typename T\u0026gt;\nconcept C1 \u003d requires {\n  std::declval\u0026lt;T const\u0026amp;\u0026gt;() + // Noncompliant\n  std::declval\u0026lt;T const\u0026amp;\u0026gt;(); // Noncompliant\n};\n\ntemplate\u0026lt;typename T\u0026gt;\nconcept C2 \u003d requires {\n  std::declval\u0026lt;T const\u0026amp;\u0026gt;() + // Noncompliant\n  std::declval\u0026lt;typename T::type const\u0026amp;\u0026gt;(); // Noncompliant\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\ntemplate\u0026lt;typename T\u0026gt;\nconcept C1 \u003d requires (T const \u0026amp;t) {\n  t + t;\n};\n\n// Note that if T::type is not a valid expression, no syntax error is\n// triggered, the concept will simply not be satisfied\ntemplate\u0026lt;typename T\u0026gt;\nconcept C2 \u003d requires (T const t, typename T::type const u) {\n  t + u;\n};\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eA \u003cem\u003erequires-expression\u003c/em\u003e is used to express constraints on template arguments. A basic building block of these constraints is the capability\nto generate a subexpression whose type depends on a template argument.\u003c/p\u003e\n\u003cp\u003eThe traditional way to write such a subexpression is by using \u003ccode\u003estd::declval\u0026lt;\u0026gt;\u003c/code\u003e (doing something more naive such as\n\u003ccode\u003eT{}\u003c/code\u003e is not as generic, for instance, it requires T to be default-constructible). This is, however, very verbose and can be error prone:\n\u003ccode\u003edeclval\u0026lt;T\u0026gt;()\u003c/code\u003e yields an expression of type \u003ccode\u003eT\u0026amp;\u0026amp;\u003c/code\u003e, while referencing a variable directly produces an lvalue\n(\u003ccode\u003eT\u0026amp;\u003c/code\u003e). This, in many cases, leads to concepts incorrectly requiring only \u003cem\u003emove-construction\u003c/em\u003e, while copies are made by the\nimplementation.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eRequire-expressions\u003c/em\u003e introduce a more natural way to achieve that. When writing a \u003cem\u003erequires-expression\u003c/em\u003e, it is possible to add a\nparameter list, similar to function parameters, and these parameters can be used later in the expression. This syntax is less verbose, more\nexpressive, and less error-prone and should be preferred over calling \u003ccode\u003estd::declval\u003c/code\u003e in requires-expressions.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\ntemplate\u0026lt;typename T\u0026gt;\nconcept C1 \u003d requires {\n  std::declval\u0026lt;T const\u0026amp;\u0026gt;() + // Noncompliant\n  std::declval\u0026lt;T const\u0026amp;\u0026gt;(); // Noncompliant\n};\n\ntemplate\u0026lt;typename T\u0026gt;\nconcept C2 \u003d requires {\n  std::declval\u0026lt;T const\u0026amp;\u0026gt;() + // Noncompliant\n  std::declval\u0026lt;typename T::type const\u0026amp;\u0026gt;(); // Noncompliant\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\ntemplate\u0026lt;typename T\u0026gt;\nconcept C1 \u003d requires (T const \u0026amp;t) {\n  t + t;\n};\n\n// Note that if T::type is not a valid expression, no syntax error is\n// triggered, the concept will simply not be satisfied\ntemplate\u0026lt;typename T\u0026gt;\nconcept C2 \u003d requires (T const t, typename T::type const u) {\n  t + u;\n};\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "clumsy",
      "confusing",
      "since-c++20"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S784",
    "name": "Assembly language should be encapsulated and isolated",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "MODULAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eEnsuring that assembly language code is encapsulated and isolated aids portability. Where assembly language instructions are needed, they shall be\nencapsulated and isolated in either assembler functions or C++ functions.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid fn ( void )\n{\n  DoSomething ( );\n  asm ( \"NOP\" ); // Noncompliant, asm mixed with C/C++ statements\n  DoSomething ( );\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid Delay ( void )\n{\n  asm ( \"NOP\" ); // Compliant, asm not mixed with C/C++ statements\n}\n\nvoid fn ( void )\n{\n  DoSomething ( );\n  Delay ( ); // Compliant, Assembler is encapsulated\n  DoSomething ( );\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C 2004, 2.1 - Assembly language shall be encapsulated and isolated. \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2008, 7-4-3 - Assembly language shall be encapsulated and isolated. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eEnsuring that assembly language code is encapsulated and isolated aids portability. Where assembly language instructions are needed, they shall be\nencapsulated and isolated in either assembler functions or C++ functions.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid fn ( void )\n{\n  DoSomething ( );\n  asm ( \"NOP\" ); // Noncompliant, asm mixed with C/C++ statements\n  DoSomething ( );\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid Delay ( void )\n{\n  asm ( \"NOP\" ); // Compliant, asm not mixed with C/C++ statements\n}\n\nvoid fn ( void )\n{\n  DoSomething ( );\n  Delay ( ); // Compliant, Assembler is encapsulated\n  DoSomething ( );\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C 2004, 2.1 - Assembly language shall be encapsulated and isolated. \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2008, 7-4-3 - Assembly language shall be encapsulated and isolated. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "misra-c++2008",
      "misra-c2004"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5494",
    "name": "Size of bit fields should not exceed the size of their types",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eBit fields allow the developers to declare a class member with a specific size.\u003c/p\u003e\n\u003cp\u003eHowever, the size of a bit field is also constrained by its type: even if the specified size is greater than the size of the type, the value of the\nbit field will not exceed the maximum value of this type. The extra bits will just create unused padding.\u003c/p\u003e\n\u003cp\u003eThe incompatibility of the size of the type with the specified size can have two causes: either the specified size is a typo error (that is the\nmost probable cause) or the developer did not realize the size of the type he chose was too small.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass A {\n  unsigned int b : 55; // Noncompliant, specified size is greater than the size of unsigned int\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nclass A {\n  unsigned int b : 32;\n};\n\u003c/pre\u003e\n\u003cp\u003eOr\u003c/p\u003e\n\u003cpre\u003e\nclass A {\n  unsigned long long int b : 55;\n};\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eBit fields allow the developers to declare a class member with a specific size.\u003c/p\u003e\n\u003cp\u003eHowever, the size of a bit field is also constrained by its type: even if the specified size is greater than the size of the type, the value of the\nbit field will not exceed the maximum value of this type. The extra bits will just create unused padding.\u003c/p\u003e\n\u003cp\u003eThe incompatibility of the size of the type with the specified size can have two causes: either the specified size is a typo error (that is the\nmost probable cause) or the developer did not realize the size of the type he chose was too small.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass A {\n  unsigned int b : 55; // Noncompliant, specified size is greater than the size of unsigned int\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nclass A {\n  unsigned int b : 32;\n};\n\u003c/pre\u003e\n\u003cp\u003eOr\u003c/p\u003e\n\u003cpre\u003e\nclass A {\n  unsigned long long int b : 55;\n};\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "bad-practice"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6462",
    "name": "Generic iterator-based algorithms should be constrained",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eEach template requires certain operations to be provided by the types it is instantiated with. Before C++20, the only way to describe those\nrequirements was through documentation. Concepts, introduced in C++20, provide a way to express requirements in a way that can be checked by the\ncompiler.\u003c/p\u003e\n\u003cp\u003eThis improves the readability and maintainability of the code, most notably:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e It makes it clear from the declaration what types are accepted and what operations they should support. This benefit is even higher when the\n  concepts used to constrain the code are well-known, such as concepts defined in the standard library. \u003c/li\u003e\n  \u003cli\u003e Errors from incorrect instantiations point at the call site (code produced by the programmer), and not at some obscure details in the middle of\n  the implementation of an algorithm. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eShould all template code be exhaustively constrained? Probably not, especially if that would lead to defining single-use concepts. But in the case\nof templates designed to work with standard-style iterators, there is no good reason not to use the standard library concepts describing them. Even\nadding a simple set of basic constraints, such as the required category of iterators, without covering all the operations needed for the algorithm, is\nalready providing value.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue for generic iterator-pair algorithms that are not constrained.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\ntemplate\u0026lt;typename Iter, typename Func\u0026gt;\nvoid adjacent_for_each(Iter first, Iter last, Func func) {\n  auto prev \u003d first;\n  for (++first; first !\u003d last; ++first) {\n    func(*prev, *first);\n    prev \u003d first;\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\ntemplate\u0026lt;std::forward_iterator Iter, typename Func\u0026gt;\n// Compliant, even though this template needs additional operations, for instance:\n//   requires std::invocable\u0026lt;Func\u0026amp;, std::iter_reference_t\u0026lt;Iter\u0026gt;, std::iter_reference_t\u0026lt;Iter\u0026gt;\u0026gt;\nvoid adjacent_for_each(Iter first, Iter last, Func func) {\n  auto prev \u003d first;\n  for (++first; first !\u003d last; ++first) {\n    func(*prev, *first);\n    prev \u003d first;\n  }\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eEach template requires certain operations to be provided by the types it is instantiated with. Before C++20, the only way to describe those\nrequirements was through documentation. Concepts, introduced in C++20, provide a way to express requirements in a way that can be checked by the\ncompiler.\u003c/p\u003e\n\u003cp\u003eThis improves the readability and maintainability of the code, most notably:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e It makes it clear from the declaration what types are accepted and what operations they should support. This benefit is even higher when the\n  concepts used to constrain the code are well-known, such as concepts defined in the standard library. \u003c/li\u003e\n  \u003cli\u003e Errors from incorrect instantiations point at the call site (code produced by the programmer), and not at some obscure details in the middle of\n  the implementation of an algorithm. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eShould all template code be exhaustively constrained? Probably not, especially if that would lead to defining single-use concepts. But in the case\nof templates designed to work with standard-style iterators, there is no good reason not to use the standard library concepts describing them. Even\nadding a simple set of basic constraints, such as the required category of iterators, without covering all the operations needed for the algorithm, is\nalready providing value.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue for generic iterator-pair algorithms that are not constrained.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\ntemplate\u0026lt;typename Iter, typename Func\u0026gt;\nvoid adjacent_for_each(Iter first, Iter last, Func func) {\n  auto prev \u003d first;\n  for (++first; first !\u003d last; ++first) {\n    func(*prev, *first);\n    prev \u003d first;\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\ntemplate\u0026lt;std::forward_iterator Iter, typename Func\u0026gt;\n// Compliant, even though this template needs additional operations, for instance:\n//   requires std::invocable\u0026lt;Func\u0026amp;, std::iter_reference_t\u0026lt;Iter\u0026gt;, std::iter_reference_t\u0026lt;Iter\u0026gt;\u0026gt;\nvoid adjacent_for_each(Iter first, Iter last, Func func) {\n  auto prev \u003d first;\n  for (++first; first !\u003d last; ++first) {\n    func(*prev, *first);\n    prev \u003d first;\n  }\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "since-c++20"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:M23_134",
    "name": "The identifier \"main\" shall not be used for a function other than the global function \"main\"",
    "defaultSeverity": "BLOCKER",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 6.0.4\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eThis rule also applies to any other entry points defined by the implementation.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003emain\u003c/code\u003e (or its equivalent) is the entry point to the program and is the only identifier which must be in the global namespace. The use\nof \u003cem\u003emain\u003c/em\u003e for other functions may not meet developer expectations.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nint main()        // Compliant\n{\n}\n\nnamespace\n{\n  int main()      // Non-compliant\n  {\n  }\n}\n\nnamespace NS\n{\n  int main()      // Non-compliant\n  {\n  }\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003e{rule:cpp:S998} targets the same defect as this rule but for a non-mission-critical context.\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 6.0.4\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eThis rule also applies to any other entry points defined by the implementation.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003emain\u003c/code\u003e (or its equivalent) is the entry point to the program and is the only identifier which must be in the global namespace. The use\nof \u003cem\u003emain\u003c/em\u003e for other functions may not meet developer expectations.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nint main()        // Compliant\n{\n}\n\nnamespace\n{\n  int main()      // Non-compliant\n  {\n  }\n}\n\nnamespace NS\n{\n  int main()      // Non-compliant\n  {\n  }\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003e{rule:cpp:S998} targets the same defect as this rule but for a non-mission-critical context.\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "misra-c++2023",
      "misra-required",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:M23_135",
    "name": "There should be no unnamed namespaces in \"header files\"",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 10.3.1\u003c/p\u003e\n\u003cp\u003eCategory: Advisory\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eAn unnamed namespace is unique within each \u003cem\u003etranslation unit\u003c/em\u003e. Any \u003cem\u003edeclarations\u003c/em\u003e [1] appearing in an unnamed namespace within a\n\u003cem\u003eheader file\u003c/em\u003e [2] refer to different \u003cem\u003eentities\u003c/em\u003e in each \u003cem\u003etranslation unit\u003c/em\u003e, which might not be consistent with developer\nexpectations.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\n// Header.hpp\nnamespace            // Non-compliant\n{\n  inline int32_t x;\n}\n\nvoid fn_a();\n\n\n// File1.cpp\n#include \"Header.hpp\"\n\nvoid fn_a()\n{\n  x \u003d 42;\n}\n\n// File2.cpp\n#include \"Header.hpp\"\n\nvoid fn_b()\n{\n  fn_a();            // Assigns 42 to \u0027x\u0027 in translation unit for \u0027File1.cpp\u0027\n\n  if ( x \u003d\u003d 42 ) {}  // \u0027x\u0027 within this translation unit will not have the value 42\n}\n\u003c/pre\u003e\n\u003ch3\u003eGlossary\u003c/h3\u003e\n\u003ch4\u003e[1] Declaration\u003c/h4\u003e\n\u003cp\u003eA \u003cem\u003edeclaration\u003c/em\u003e introduces the name of an \u003cem\u003eentity\u003c/em\u003e into a \u003cem\u003etranslation unit\u003c/em\u003e (see [basic.def]/1).\u003c/p\u003e\n\u003cp\u003eAn \u003cem\u003eentity\u003c/em\u003e may be \u003cem\u003edeclared\u003c/em\u003e several times. The first \u003cem\u003edeclaration\u003c/em\u003e of an \u003cem\u003eentity\u003c/em\u003e in a \u003cem\u003etranslation unit\u003c/em\u003e is\ncalled an \u003cem\u003eintroduction\u003c/em\u003e [3]. All subsequent \u003cem\u003edeclarations\u003c/em\u003e are called \u003cem\u003eredeclarations\u003c/em\u003e [4].\u003c/p\u003e\n\u003cp\u003eA \u003cem\u003edefinition\u003c/em\u003e [5] is a \u003cem\u003edeclaration\u003c/em\u003e, as described in [basic.def]/2.\u003c/p\u003e\n\u003ch4\u003e[2] Header file\u003c/h4\u003e\n\u003cp\u003eA \u003cem\u003eheader file\u003c/em\u003e is considered to be any file that is included during preprocessing (for example via the \u003ccode\u003e#include\u003c/code\u003e directive),\nregardless of its name or suffix.\u003c/p\u003e\n\u003ch4\u003e[3] Introduction\u003c/h4\u003e\n\u003cp\u003eSee \u003cem\u003edeclaration\u003c/em\u003e [1].\u003c/p\u003e\n\u003ch4\u003e[4] Redeclaration\u003c/h4\u003e\n\u003cp\u003eSee \u003cem\u003edeclaration\u003c/em\u003e [1].\u003c/p\u003e\n\u003ch4\u003e[5] Definition\u003c/h4\u003e\n\u003cp\u003eSee \u003cem\u003edeclaration\u003c/em\u003e [1].\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003e{rule:cpp:S1000} targets the same defect as this rule but for a non-mission-critical context.\u003c/p\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cp\u003e\u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/VXs-BQ\"\u003eCERT, DCL59-CPP.\u003c/a\u003e - Do not define an unnamed namespace in a header file\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 10.3.1\u003c/p\u003e\n\u003cp\u003eCategory: Advisory\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eAn unnamed namespace is unique within each \u003cem\u003etranslation unit\u003c/em\u003e. Any \u003cem\u003edeclarations\u003c/em\u003e [1] appearing in an unnamed namespace within a\n\u003cem\u003eheader file\u003c/em\u003e [2] refer to different \u003cem\u003eentities\u003c/em\u003e in each \u003cem\u003etranslation unit\u003c/em\u003e, which might not be consistent with developer\nexpectations.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\n// Header.hpp\nnamespace            // Non-compliant\n{\n  inline int32_t x;\n}\n\nvoid fn_a();\n\n\n// File1.cpp\n#include \"Header.hpp\"\n\nvoid fn_a()\n{\n  x \u003d 42;\n}\n\n// File2.cpp\n#include \"Header.hpp\"\n\nvoid fn_b()\n{\n  fn_a();            // Assigns 42 to \u0027x\u0027 in translation unit for \u0027File1.cpp\u0027\n\n  if ( x \u003d\u003d 42 ) {}  // \u0027x\u0027 within this translation unit will not have the value 42\n}\n\u003c/pre\u003e\n\u003ch3\u003eGlossary\u003c/h3\u003e\n\u003ch4\u003e[1] Declaration\u003c/h4\u003e\n\u003cp\u003eA \u003cem\u003edeclaration\u003c/em\u003e introduces the name of an \u003cem\u003eentity\u003c/em\u003e into a \u003cem\u003etranslation unit\u003c/em\u003e (see [basic.def]/1).\u003c/p\u003e\n\u003cp\u003eAn \u003cem\u003eentity\u003c/em\u003e may be \u003cem\u003edeclared\u003c/em\u003e several times. The first \u003cem\u003edeclaration\u003c/em\u003e of an \u003cem\u003eentity\u003c/em\u003e in a \u003cem\u003etranslation unit\u003c/em\u003e is\ncalled an \u003cem\u003eintroduction\u003c/em\u003e [3]. All subsequent \u003cem\u003edeclarations\u003c/em\u003e are called \u003cem\u003eredeclarations\u003c/em\u003e [4].\u003c/p\u003e\n\u003cp\u003eA \u003cem\u003edefinition\u003c/em\u003e [5] is a \u003cem\u003edeclaration\u003c/em\u003e, as described in [basic.def]/2.\u003c/p\u003e\n\u003ch4\u003e[2] Header file\u003c/h4\u003e\n\u003cp\u003eA \u003cem\u003eheader file\u003c/em\u003e is considered to be any file that is included during preprocessing (for example via the \u003ccode\u003e#include\u003c/code\u003e directive),\nregardless of its name or suffix.\u003c/p\u003e\n\u003ch4\u003e[3] Introduction\u003c/h4\u003e\n\u003cp\u003eSee \u003cem\u003edeclaration\u003c/em\u003e [1].\u003c/p\u003e\n\u003ch4\u003e[4] Redeclaration\u003c/h4\u003e\n\u003cp\u003eSee \u003cem\u003edeclaration\u003c/em\u003e [1].\u003c/p\u003e\n\u003ch4\u003e[5] Definition\u003c/h4\u003e\n\u003cp\u003eSee \u003cem\u003edeclaration\u003c/em\u003e [1].\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003e{rule:cpp:S1000} targets the same defect as this rule but for a non-mission-critical context.\u003c/p\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cp\u003e\u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/VXs-BQ\"\u003eCERT, DCL59-CPP.\u003c/a\u003e - Do not define an unnamed namespace in a header file\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "misra-advisory",
      "misra-c++2023",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6225",
    "name": "\"std::to_address\" should be used to convert iterators to raw pointers",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eFor the integration with the C or just older APIs, it may be useful to convert a contiguous iterator to a raw pointer to the element. In C++20\n\u003ccode\u003estd::to_address\u003c/code\u003e was introduced to perform this operation on both iterators and smart pointers, which supersedes non-portable and\npotentially buggy workarounds, that were required before:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The first option was to take the address of the element pointed by the iterator: \u003ccode\u003e\u0026amp;*it\u003c/code\u003e. However, this operation has undefined\n  behavior if the iterator is not pointing to any element. This may happen for the iterator returned by a call to \u003ccode\u003eend()\u003c/code\u003e on the container.\n  This may also be the case when we need the address to construct a new object (via placement new) at the location pointed to by the iterator.\n  \u003ccode\u003estd::to_address(it)\u003c/code\u003e works in such cases. \u003c/li\u003e\n  \u003cli\u003e The second option was to exploit the nature of \u003ccode\u003eoperator-\u0026gt;\u003c/code\u003e overloading and call it explicitly on the iterator:\n  \u003ccode\u003eit.operator-\u0026gt;()\u003c/code\u003e. This option avoids the pitfalls of the previous one, at the cost of not being portable. It would fail on the\n  implementations that use raw-pointers as iterators for contiguous ranges like \u003ccode\u003estd::vector\u003c/code\u003e or \u003ccode\u003estd::span\u003c/code\u003e. Moreover, it is\n  confusing, as this functional notation syntax for operators is rarely used. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWhile both \u003ccode\u003estd::to_address\u003c/code\u003e and above workarounds, can be always used to get the address of the element that the iterator is pointing\nto (if any), incrementing or decrementing may have undefined behavior. Performing pointer arithmetic on pointer to elements is safe only in the case\nof contiguous iterators (e.g. iterators of \u003ccode\u003estd::vector\u003c/code\u003e, \u003ccode\u003estd::array\u003c/code\u003e, \u003ccode\u003estd::span\u003c/code\u003e, \u003ccode\u003estd::string\u003c/code\u003e or\n\u003ccode\u003estd::string_view\u003c/code\u003e).\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when dereferencing a pointer-like object is immediately followed by taking the address of the result\n(\u003ccode\u003e\u0026amp;*x\u003c/code\u003e or \u003ccode\u003estd::addressof(*x)\u003c/code\u003e) or when \u003ccode\u003eoperator-\u0026gt;\u003c/code\u003e is called through an explicit functional notation\n(\u003ccode\u003ex.operator-\u0026gt;()\u003c/code\u003e).\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid check(int* b, int* e);\n\nvoid func1(std::vector\u0026lt;int\u0026gt;\u0026amp; v) {\n    check(v.begin().operator-\u0026gt;(), v.end().operator-\u0026gt;()); // Noncompliant\n}\n\nvoid func2(span\u0026lt;int\u0026gt; s) {\n     check(\u0026amp;*s.begin(), \u0026amp;*s.end()); // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid func1(std::vector\u0026lt;int\u0026gt;\u0026amp; v) {\n    check(std::to_address(v.begin()), std::to_address(v.end()));\n}\n\nvoid func2(span\u0026lt;int\u0026gt; s) {\n     check(std::to_address(s.begin()), std::to_address(s.end()));\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eFor the integration with the C or just older APIs, it may be useful to convert a contiguous iterator to a raw pointer to the element. In C++20\n\u003ccode\u003estd::to_address\u003c/code\u003e was introduced to perform this operation on both iterators and smart pointers, which supersedes non-portable and\npotentially buggy workarounds, that were required before:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The first option was to take the address of the element pointed by the iterator: \u003ccode\u003e\u0026amp;*it\u003c/code\u003e. However, this operation has undefined\n  behavior if the iterator is not pointing to any element. This may happen for the iterator returned by a call to \u003ccode\u003eend()\u003c/code\u003e on the container.\n  This may also be the case when we need the address to construct a new object (via placement new) at the location pointed to by the iterator.\n  \u003ccode\u003estd::to_address(it)\u003c/code\u003e works in such cases. \u003c/li\u003e\n  \u003cli\u003e The second option was to exploit the nature of \u003ccode\u003eoperator-\u0026gt;\u003c/code\u003e overloading and call it explicitly on the iterator:\n  \u003ccode\u003eit.operator-\u0026gt;()\u003c/code\u003e. This option avoids the pitfalls of the previous one, at the cost of not being portable. It would fail on the\n  implementations that use raw-pointers as iterators for contiguous ranges like \u003ccode\u003estd::vector\u003c/code\u003e or \u003ccode\u003estd::span\u003c/code\u003e. Moreover, it is\n  confusing, as this functional notation syntax for operators is rarely used. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWhile both \u003ccode\u003estd::to_address\u003c/code\u003e and above workarounds, can be always used to get the address of the element that the iterator is pointing\nto (if any), incrementing or decrementing may have undefined behavior. Performing pointer arithmetic on pointer to elements is safe only in the case\nof contiguous iterators (e.g. iterators of \u003ccode\u003estd::vector\u003c/code\u003e, \u003ccode\u003estd::array\u003c/code\u003e, \u003ccode\u003estd::span\u003c/code\u003e, \u003ccode\u003estd::string\u003c/code\u003e or\n\u003ccode\u003estd::string_view\u003c/code\u003e).\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when dereferencing a pointer-like object is immediately followed by taking the address of the result\n(\u003ccode\u003e\u0026amp;*x\u003c/code\u003e or \u003ccode\u003estd::addressof(*x)\u003c/code\u003e) or when \u003ccode\u003eoperator-\u0026gt;\u003c/code\u003e is called through an explicit functional notation\n(\u003ccode\u003ex.operator-\u0026gt;()\u003c/code\u003e).\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid check(int* b, int* e);\n\nvoid func1(std::vector\u0026lt;int\u0026gt;\u0026amp; v) {\n    check(v.begin().operator-\u0026gt;(), v.end().operator-\u0026gt;()); // Noncompliant\n}\n\nvoid func2(span\u0026lt;int\u0026gt; s) {\n     check(\u0026amp;*s.begin(), \u0026amp;*s.end()); // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid func1(std::vector\u0026lt;int\u0026gt;\u0026amp; v) {\n    check(std::to_address(v.begin()), std::to_address(v.end()));\n}\n\nvoid func2(span\u0026lt;int\u0026gt; s) {\n     check(std::to_address(s.begin()), std::to_address(s.end()));\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "confusing",
      "since-c++20",
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S793",
    "name": "All uses of the #pragma directive should be documented",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003e#pragma\u003c/code\u003e directive is implementation-defined, hence it is important both to demonstrate that all uses are correct, and to minimize,\nlocalize and encapsulate any use of pragmas within dedicated functions whenever possible.\u003c/p\u003e\n\u003cp\u003eThe meaning of each pragma shall be documented.\u003c/p\u003e\n\u003cp\u003eThere shall be sufficient supporting description to demonstrate that the behavior of the pragma and its implications for the application, have been\nfully understood.\u003c/p\u003e\n\u003cp\u003eThis rule flags all instances of \u003ccode\u003e#pragma\u003c/code\u003e directives, and leaves it to the user to determine whether they have been properly\ndocumented.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 3.4 - All uses of the #pragma directive shall be documented and explained \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 16-6-1 - All uses of the #pragma directive shall be documented \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/6NUxBQ\"\u003eCERT, MSC00-C\u003c/a\u003e - Compile cleanly at high warning levels \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe \u003ccode\u003e#pragma\u003c/code\u003e directive is implementation-defined, hence it is important both to demonstrate that all uses are correct, and to minimize,\nlocalize and encapsulate any use of pragmas within dedicated functions whenever possible.\u003c/p\u003e\n\u003cp\u003eThe meaning of each pragma shall be documented.\u003c/p\u003e\n\u003cp\u003eThere shall be sufficient supporting description to demonstrate that the behavior of the pragma and its implications for the application, have been\nfully understood.\u003c/p\u003e\n\u003cp\u003eThis rule flags all instances of \u003ccode\u003e#pragma\u003c/code\u003e directives, and leaves it to the user to determine whether they have been properly\ndocumented.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 3.4 - All uses of the #pragma directive shall be documented and explained \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 16-6-1 - All uses of the #pragma directive shall be documented \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/6NUxBQ\"\u003eCERT, MSC00-C\u003c/a\u003e - Compile cleanly at high warning levels \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "cert"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6226",
    "name": "Empty class members should be marked as \"[[no_unique_address]]\"",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "EFFICIENT",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eIn C++, every independent object needs to have a unique address, which implies that its size cannot be null. Sub-objects of another object,\nhowever, do not have this constraint. Empty base class subobjects usually don’t take any space in the final object, but empty member variables, by\ndefault, take at least one byte. The impact on the object’s size may be even larger due to padding and alignment requirements.\u003c/p\u003e\n\u003cp\u003eC++20 introduces the \u003ccode\u003e[[no_unique_address]]\u003c/code\u003e attribute. It indicates that preserving the uniqueness of the address guarantee is not\nimportant for the decorated member variable. If the variable type is empty, no storage needs to be reserved for it in the class.\u003c/p\u003e\n\u003cp\u003eIf the type is not empty, this attribute is still valid and has no effect. This allows placing this attribute on dependent member variables in\ntemplate classes and having the exact behavior depend on the template parameters.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue on each member of a class that has an empty or potentially empty (in case of templates) type and does not have a\n\u003ccode\u003e[[no_unique_address]]\u003c/code\u003e attribute.\u003c/p\u003e\n\u003cp\u003eNote: This rule is disabled on Windows because \u003ccode\u003e[[no_unique_address]]\u003c/code\u003e \u003ca\nhref\u003d\"https://devblogs.microsoft.com/cppblog/msvc-cpp20-and-the-std-cpp20-switch/#c20-no_unique_address\"\u003eisn’t well supported by MSVC and Clang on\nthis platform\u003c/a\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nstruct Empty {};\nstruct Wrapped {\n  int* ptr;\n  Empty e; // Noncompliant\n}; // sizeof(Wrapped) is \u0026gt; sizeof(int*)\n\ntemplate\u0026lt;typename K, typename V, typename Hash, typename Equal\u0026gt;\nclass HashMap {\n  /* ... */\n  Hash hash; // Noncompliant if HashMap is instantiated with an empty Hash\n  Equal equal; // Noncompliant if HashMap is instantiated with an empty Equal\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nstruct Empty {};\nstruct Wrapped {\n  int* ptr;\n  [[no_unique_address]] Empty e;\n}; // sizeof(Wrapped) can be equal to sizeof(int*)\n\ntemplate\u0026lt;typename K, typename V, typename Hash, typename Equal\u0026gt;\nclass HashMap {\n  /* ... */\n  [[no_unique_address]] Hash hash;\n  [[no_unique_address]] Equal equal;\n};\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThis rule does not apply to fields whose class has a non-default alignment.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/attributes/no_unique_address\"\u003eC++ attribute: no_unique_address\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eIn C++, every independent object needs to have a unique address, which implies that its size cannot be null. Sub-objects of another object,\nhowever, do not have this constraint. Empty base class subobjects usually don’t take any space in the final object, but empty member variables, by\ndefault, take at least one byte. The impact on the object’s size may be even larger due to padding and alignment requirements.\u003c/p\u003e\n\u003cp\u003eC++20 introduces the \u003ccode\u003e[[no_unique_address]]\u003c/code\u003e attribute. It indicates that preserving the uniqueness of the address guarantee is not\nimportant for the decorated member variable. If the variable type is empty, no storage needs to be reserved for it in the class.\u003c/p\u003e\n\u003cp\u003eIf the type is not empty, this attribute is still valid and has no effect. This allows placing this attribute on dependent member variables in\ntemplate classes and having the exact behavior depend on the template parameters.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue on each member of a class that has an empty or potentially empty (in case of templates) type and does not have a\n\u003ccode\u003e[[no_unique_address]]\u003c/code\u003e attribute.\u003c/p\u003e\n\u003cp\u003eNote: This rule is disabled on Windows because \u003ccode\u003e[[no_unique_address]]\u003c/code\u003e \u003ca\nhref\u003d\"https://devblogs.microsoft.com/cppblog/msvc-cpp20-and-the-std-cpp20-switch/#c20-no_unique_address\"\u003eisn’t well supported by MSVC and Clang on\nthis platform\u003c/a\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nstruct Empty {};\nstruct Wrapped {\n  int* ptr;\n  Empty e; // Noncompliant\n}; // sizeof(Wrapped) is \u0026gt; sizeof(int*)\n\ntemplate\u0026lt;typename K, typename V, typename Hash, typename Equal\u0026gt;\nclass HashMap {\n  /* ... */\n  Hash hash; // Noncompliant if HashMap is instantiated with an empty Hash\n  Equal equal; // Noncompliant if HashMap is instantiated with an empty Equal\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nstruct Empty {};\nstruct Wrapped {\n  int* ptr;\n  [[no_unique_address]] Empty e;\n}; // sizeof(Wrapped) can be equal to sizeof(int*)\n\ntemplate\u0026lt;typename K, typename V, typename Hash, typename Equal\u0026gt;\nclass HashMap {\n  /* ... */\n  [[no_unique_address]] Hash hash;\n  [[no_unique_address]] Equal equal;\n};\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThis rule does not apply to fields whose class has a non-default alignment.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/attributes/no_unique_address\"\u003eC++ attribute: no_unique_address\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "performance",
      "since-c++20"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6223",
    "name": "Result of the standard remove algorithms should not be ignored",
    "defaultSeverity": "BLOCKER",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eDespite their names, the standard remove algorithms (\u003ccode\u003estd::remove\u003c/code\u003e, \u003ccode\u003estd::remove_if\u003c/code\u003e, \u003ccode\u003estd::unique\u003c/code\u003e) do not erase\nelements from a given range. Instead, they shift the preserved (not removed) elements to the beginning of the range and return an iterator after the\nlast preserved element. The \"removed\" elements have unspecified values.\u003c/p\u003e\n\u003cp\u003eC++20 introduced functions in the \u003ccode\u003estd::ranges\u003c/code\u003e namespace with the same names. Aside from returning a subrange instead of an iterator,\nthey exhibit the same behavior.\u003c/p\u003e\n\u003cp\u003eIgnoring the result of any of these functions indicates a bug: It is impossible to distinguish removed elements in the container from the others.\nAs a result, any further operations on the container may access elements with unspecified values. And this may lead to invalid program states, data\ncorruption, or crashes.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eThe rule raises an issue when the result of \u003ccode\u003eremove\u003c/code\u003e, \u003ccode\u003eremove_if\u003c/code\u003e, or \u003ccode\u003eunique\u003c/code\u003e from the \u003ccode\u003estd\u003c/code\u003e or\n\u003ccode\u003estd::ranges\u003c/code\u003e namespace is ignored.\u003c/p\u003e\n\u003cp\u003eThere are essentially three ways to fix this problem:\u003c/p\u003e\n\u003col\u003e\n  \u003cli\u003e Use the returned iterator or subrange to consider only the relevant elements.\u003cbr\u003e This solution can be sufficient. It is also efficient but\n  non-trivial and error-prone, as explained in the first example below. \u003c/li\u003e\n  \u003cli\u003e Use the \u003cem\u003eerase-remove\u003c/em\u003e idiom to drop elements from a container.\n    \u003cul\u003e\n      \u003cli\u003e It consists of calling the container’s \u003ccode\u003eerase\u003c/code\u003e member function using the produced iterator or subrange.\u003cbr\u003e \u003c/li\u003e\n      \u003cli\u003e Since C++20, \u003ccode\u003estd::erase\u003c/code\u003e and \u003ccode\u003estd::erase_if\u003c/code\u003e provide a more concise alternative to the \u003cem\u003eerase-remove\u003c/em\u003e idiom.\n      \u003c/li\u003e\n    \u003c/ul\u003e  \u003c/li\u003e\n  \u003cli\u003e Use other algorithms:\n    \u003cul\u003e\n      \u003cli\u003e The member functions of \u003ccode\u003estd::list\u003c/code\u003e and \u003ccode\u003estd::forward_list\u003c/code\u003e of the same name \u003cem\u003edo\u003c/em\u003e erase the desired elements\n      from the container.\u003cbr\u003e However, changing the type of containers should not be driven solely by the syntax to remove elements. Instead, this\n      decision should factor in the runtime and memory complexities of the operation provided by the container and how it is typically used. \u003c/li\u003e\n      \u003cli\u003e \u003ccode\u003estd::remove_copy\u003c/code\u003e and \u003ccode\u003estd::remove_copy_if\u003c/code\u003e (and their \u003ccode\u003estd::ranges\u003c/code\u003e siblings) avoid the problem by\n      copying the relevant values to another container.\u003cbr\u003e This solution requires more memory and usually requires more computation since elements\n      are not moved but copied. This can be relevant when you want to avoid modifying the original container. \u003c/li\u003e\n      \u003cli\u003e \u003ccode\u003estd::views::filter\u003c/code\u003e is also a good candidate when modifying the original container is not desired. This solution is\n      particularly suited when iterating over the container only once. \u003c/li\u003e\n      \u003cli\u003e Consider using \u003ccode\u003estd::partition\u003c/code\u003e or \u003ccode\u003estd::stable_partition\u003c/code\u003e if preserving elements that don’t satisfy the predicate is\n      actually desired. These functions (and their \u003ccode\u003estd::ranges\u003c/code\u003e siblings) reorder elements inside the same container without resulting in\n      unspecified values. \u003c/li\u003e\n    \u003c/ul\u003e  \u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eWhich technique to use depends on the context, as we illustrate with the following examples.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cp\u003eThis first example takes a collection of names, filters out the invalid ones, and returns the longest.\u003c/p\u003e\n\u003cpre\u003e\nchar const* longestName(std::vector\u0026lt;char const*\u0026gt; names) {\n  // Noncompliant: some elements in \"names\" are left with an unspecified value.\n  std::remove(names.begin(), names.end(), nullptr);\n\n  if (names.empty()) { // Flaw: invalid names are still in the container.\n    // No valid names.\n    return nullptr;\n  }\n\n  auto longestNameIterator \u003d std::max_element(\n    names.begin(), names.end(), // Flaw: unspecified values are iterated over.\n    [](auto f1, auto f2) {\n      // Undefined behavior:\n      // * accessing unspecified elements\n      // * potentially dereferencing null pointers\n      return std::strlen(f1) \u0026lt; std::strlen(f2);\n    }\n  );\n  return *longestNameIterator;\n}\n\u003c/pre\u003e\n\u003cp\u003eAs explained in the comments, this code is flawed and can result in a crash.\u003c/p\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eTo fix the flaws of the previous code snippet, we can use the value returned by \u003ccode\u003estd::remove\u003c/code\u003e to consider only the relevant elements.\nThis solution is sufficient because the container \u003ccode\u003enames\u003c/code\u003e is getting destroyed at the end of the function. Therefore, there is no risk of\naccessing unspecified values in other parts of the software. Furthermore, this solution is relatively efficient as it does not perform unnecessary\nwork on the container beyond the \u003ccode\u003estd::remove\u003c/code\u003e call.\u003c/p\u003e\n\u003cpre\u003e\nchar const* longestName(std::vector\u0026lt;char const*\u0026gt; names) {\n  // Compliant: the returned iterator is used to limit the subsequent search.\n  auto end \u003d std::remove(names.begin(), names.end(), nullptr);\n\n  if (end \u003d\u003d names.begin()) { // Correct: invalid names are not considered.\n    // No valid names.\n    return nullptr;\n  }\n\n  auto longestNameIterator \u003d std::max_element(\n    names.begin(), end, // Correct: only valid names are iterated over.\n    [](auto f1, auto f2) {\n      return std::strlen(f1) \u0026lt; std::strlen(f2);\n    }\n  );\n  return *longestNameIterator;\n}\n\u003c/pre\u003e\n\u003cp\u003eAnother more modern approach is to use C++20’s \u003ccode\u003estd::views::filter\u003c/code\u003e instead. Since this solution does not mutate the argument, it can be\na const-reference or even a view.\u003c/p\u003e\n\u003cpre\u003e\nchar const* longestName(std::vector\u0026lt;char const*\u0026gt; const\u0026amp; names) {\n  // Compliant: std::views::filter is used instead.\n  auto validNames \u003d names | std::views::filter([](char const* e) { return e !\u003d nullptr; });\n\n  if (std::ranges::empty(validNames)) {\n    // No valid names.\n    return nullptr;\n  }\n\n  auto longestNameIterator \u003d std::ranges::max_element(\n    validNames, // Correct: the following lambda is only called with valid names.\n    [](auto f1, auto f2) {\n      return std::strlen(f1) \u0026lt; std::strlen(f2);\n    }\n  );\n  return *longestNameIterator;\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cp\u003eThe following example looks like it removes even values from a given vector passed by reference. In fact, the vector \u003ccode\u003ev\u003c/code\u003e is left with\nthe same number of elements.\u003c/p\u003e\n\u003cpre\u003e\nvoid filterOutEvenNumbers(std::vector\u0026lt;int\u0026gt;\u0026amp; v) {\n  // Noncompliant: some elements in \"v\" have an unspecified value.\n  std::remove_if(v.begin(), v.end(), [](int x) { return x % 2 \u003d\u003d 0; });\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eHere are two ways of fixing the bug in the previous snippet:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e With C++20, \u003ccode\u003estd::remove_if\u003c/code\u003e can be replaced by \u003ccode\u003estd::erase_if\u003c/code\u003e: \u003cpre\u003e\nvoid filterOutEvenNumbers(std::vector\u0026lt;int\u0026gt;\u0026amp; v) {\n  // Compliant: elements are erased as expected.\n  std::erase_if(v, [](int x) { return x % 2 \u003d\u003d 0; });\n}\n\u003c/pre\u003e  This solution is sufficient, reliable, and more readable than the original code.  \u003c/li\u003e\n  \u003cli\u003e Before C++20, we can apply the \u003cem\u003eerase-remove\u003c/em\u003e idiom and use the \u003ccode\u003eerase\u003c/code\u003e member function of the container: \u003cpre\u003e\nvoid filterOutEvenNumbers(std::vector\u0026lt;int\u0026gt;\u0026amp; v) {\n  auto newEnd \u003d std::remove_if(v.begin(), v.end(), [](int x) { return x % 2 \u003d\u003d 0; });\n  // Compliant: elements are erased as expected.\n  v.erase(newEnd, v.end());\n}\n\u003c/pre\u003e  This solution is semantically identical to the C++20 version but more verbose.  \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cp\u003eThis example shows an incorrect use of the \u003ccode\u003estd::ranges::unique\u003c/code\u003e function: \u003ccode\u003ev\u003c/code\u003e is left with indeterminate values.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid removeDuplicateValues(std::vector\u0026lt;int\u0026gt;\u0026amp; v) {\n  std::ranges::sort(v);\n  // Noncompliant: some elements in \"v\" have an unspecified value.\n  std::ranges::unique(v);\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eWe apply the \u003cem\u003eremove-erase\u003c/em\u003e idiom in this fixed version using the subrange returned by \u003ccode\u003estd::ranges::unique\u003c/code\u003e.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\nvoid removeDuplicateValues(std::vector\u0026lt;int\u0026gt;\u0026amp; v) {\n  std::ranges::sort(v);\n  // Compliant: the returned range is used to erase duplicated elements.\n  auto [duplicateBegin, duplicateEnd] \u003d std::ranges::unique(v);\n  v.erase(duplicateBegin, duplicateEnd);\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Wikipedia - \u003ca href\u003d\"https://en.wikipedia.org/wiki/Erase%E2%80%93remove_idiom\"\u003eErase-remove idiom\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/algorithm/remove\"\u003e\u003ccode\u003estd::remove\u003c/code\u003e, \u003ccode\u003estd::remove_if\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/algorithm/unique\"\u003e\u003ccode\u003estd::unique\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/ranges/filter_view\"\u003e\u003ccode\u003estd::views::filter\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/algorithm/ranges/remove\"\u003e\u003ccode\u003estd::ranges::remove\u003c/code\u003e,\n  \u003ccode\u003estd::ranges::remove_if\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/algorithm/ranges/unique\"\u003e\u003ccode\u003estd::ranges::unique\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/container/vector/erase2\"\u003e\u003ccode\u003estd::erase\u003c/code\u003e, \u003ccode\u003estd::erase_if\u003c/code\u003e (for\n  \u003ccode\u003estd::vector\u003c/code\u003e)\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S6165} for C++20 helps replacing the \u003cem\u003eerase-remove\u003c/em\u003e idiom with \u003ccode\u003estd::erase\u003c/code\u003e/\u003ccode\u003estd::erase_if\u003c/code\u003e. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eDespite their names, the standard remove algorithms (\u003ccode\u003estd::remove\u003c/code\u003e, \u003ccode\u003estd::remove_if\u003c/code\u003e, \u003ccode\u003estd::unique\u003c/code\u003e) do not erase\nelements from a given range. Instead, they shift the preserved (not removed) elements to the beginning of the range and return an iterator after the\nlast preserved element. The \"removed\" elements have unspecified values.\u003c/p\u003e\n\u003cp\u003eC++20 introduced functions in the \u003ccode\u003estd::ranges\u003c/code\u003e namespace with the same names. Aside from returning a subrange instead of an iterator,\nthey exhibit the same behavior.\u003c/p\u003e\n\u003cp\u003eIgnoring the result of any of these functions indicates a bug: It is impossible to distinguish removed elements in the container from the others.\nAs a result, any further operations on the container may access elements with unspecified values. And this may lead to invalid program states, data\ncorruption, or crashes.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eThe rule raises an issue when the result of \u003ccode\u003eremove\u003c/code\u003e, \u003ccode\u003eremove_if\u003c/code\u003e, or \u003ccode\u003eunique\u003c/code\u003e from the \u003ccode\u003estd\u003c/code\u003e or\n\u003ccode\u003estd::ranges\u003c/code\u003e namespace is ignored.\u003c/p\u003e\n\u003cp\u003eThere are essentially three ways to fix this problem:\u003c/p\u003e\n\u003col\u003e\n  \u003cli\u003e Use the returned iterator or subrange to consider only the relevant elements.\u003cbr\u003e This solution can be sufficient. It is also efficient but\n  non-trivial and error-prone, as explained in the first example below. \u003c/li\u003e\n  \u003cli\u003e Use the \u003cem\u003eerase-remove\u003c/em\u003e idiom to drop elements from a container.\n    \u003cul\u003e\n      \u003cli\u003e It consists of calling the container’s \u003ccode\u003eerase\u003c/code\u003e member function using the produced iterator or subrange.\u003cbr\u003e \u003c/li\u003e\n      \u003cli\u003e Since C++20, \u003ccode\u003estd::erase\u003c/code\u003e and \u003ccode\u003estd::erase_if\u003c/code\u003e provide a more concise alternative to the \u003cem\u003eerase-remove\u003c/em\u003e idiom.\n      \u003c/li\u003e\n    \u003c/ul\u003e  \u003c/li\u003e\n  \u003cli\u003e Use other algorithms:\n    \u003cul\u003e\n      \u003cli\u003e The member functions of \u003ccode\u003estd::list\u003c/code\u003e and \u003ccode\u003estd::forward_list\u003c/code\u003e of the same name \u003cem\u003edo\u003c/em\u003e erase the desired elements\n      from the container.\u003cbr\u003e However, changing the type of containers should not be driven solely by the syntax to remove elements. Instead, this\n      decision should factor in the runtime and memory complexities of the operation provided by the container and how it is typically used. \u003c/li\u003e\n      \u003cli\u003e \u003ccode\u003estd::remove_copy\u003c/code\u003e and \u003ccode\u003estd::remove_copy_if\u003c/code\u003e (and their \u003ccode\u003estd::ranges\u003c/code\u003e siblings) avoid the problem by\n      copying the relevant values to another container.\u003cbr\u003e This solution requires more memory and usually requires more computation since elements\n      are not moved but copied. This can be relevant when you want to avoid modifying the original container. \u003c/li\u003e\n      \u003cli\u003e \u003ccode\u003estd::views::filter\u003c/code\u003e is also a good candidate when modifying the original container is not desired. This solution is\n      particularly suited when iterating over the container only once. \u003c/li\u003e\n      \u003cli\u003e Consider using \u003ccode\u003estd::partition\u003c/code\u003e or \u003ccode\u003estd::stable_partition\u003c/code\u003e if preserving elements that don’t satisfy the predicate is\n      actually desired. These functions (and their \u003ccode\u003estd::ranges\u003c/code\u003e siblings) reorder elements inside the same container without resulting in\n      unspecified values. \u003c/li\u003e\n    \u003c/ul\u003e  \u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eWhich technique to use depends on the context, as we illustrate with the following examples.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cp\u003eThis first example takes a collection of names, filters out the invalid ones, and returns the longest.\u003c/p\u003e\n\u003cpre\u003e\nchar const* longestName(std::vector\u0026lt;char const*\u0026gt; names) {\n  // Noncompliant: some elements in \"names\" are left with an unspecified value.\n  std::remove(names.begin(), names.end(), nullptr);\n\n  if (names.empty()) { // Flaw: invalid names are still in the container.\n    // No valid names.\n    return nullptr;\n  }\n\n  auto longestNameIterator \u003d std::max_element(\n    names.begin(), names.end(), // Flaw: unspecified values are iterated over.\n    [](auto f1, auto f2) {\n      // Undefined behavior:\n      // * accessing unspecified elements\n      // * potentially dereferencing null pointers\n      return std::strlen(f1) \u0026lt; std::strlen(f2);\n    }\n  );\n  return *longestNameIterator;\n}\n\u003c/pre\u003e\n\u003cp\u003eAs explained in the comments, this code is flawed and can result in a crash.\u003c/p\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eTo fix the flaws of the previous code snippet, we can use the value returned by \u003ccode\u003estd::remove\u003c/code\u003e to consider only the relevant elements.\nThis solution is sufficient because the container \u003ccode\u003enames\u003c/code\u003e is getting destroyed at the end of the function. Therefore, there is no risk of\naccessing unspecified values in other parts of the software. Furthermore, this solution is relatively efficient as it does not perform unnecessary\nwork on the container beyond the \u003ccode\u003estd::remove\u003c/code\u003e call.\u003c/p\u003e\n\u003cpre\u003e\nchar const* longestName(std::vector\u0026lt;char const*\u0026gt; names) {\n  // Compliant: the returned iterator is used to limit the subsequent search.\n  auto end \u003d std::remove(names.begin(), names.end(), nullptr);\n\n  if (end \u003d\u003d names.begin()) { // Correct: invalid names are not considered.\n    // No valid names.\n    return nullptr;\n  }\n\n  auto longestNameIterator \u003d std::max_element(\n    names.begin(), end, // Correct: only valid names are iterated over.\n    [](auto f1, auto f2) {\n      return std::strlen(f1) \u0026lt; std::strlen(f2);\n    }\n  );\n  return *longestNameIterator;\n}\n\u003c/pre\u003e\n\u003cp\u003eAnother more modern approach is to use C++20’s \u003ccode\u003estd::views::filter\u003c/code\u003e instead. Since this solution does not mutate the argument, it can be\na const-reference or even a view.\u003c/p\u003e\n\u003cpre\u003e\nchar const* longestName(std::vector\u0026lt;char const*\u0026gt; const\u0026amp; names) {\n  // Compliant: std::views::filter is used instead.\n  auto validNames \u003d names | std::views::filter([](char const* e) { return e !\u003d nullptr; });\n\n  if (std::ranges::empty(validNames)) {\n    // No valid names.\n    return nullptr;\n  }\n\n  auto longestNameIterator \u003d std::ranges::max_element(\n    validNames, // Correct: the following lambda is only called with valid names.\n    [](auto f1, auto f2) {\n      return std::strlen(f1) \u0026lt; std::strlen(f2);\n    }\n  );\n  return *longestNameIterator;\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cp\u003eThe following example looks like it removes even values from a given vector passed by reference. In fact, the vector \u003ccode\u003ev\u003c/code\u003e is left with\nthe same number of elements.\u003c/p\u003e\n\u003cpre\u003e\nvoid filterOutEvenNumbers(std::vector\u0026lt;int\u0026gt;\u0026amp; v) {\n  // Noncompliant: some elements in \"v\" have an unspecified value.\n  std::remove_if(v.begin(), v.end(), [](int x) { return x % 2 \u003d\u003d 0; });\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eHere are two ways of fixing the bug in the previous snippet:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e With C++20, \u003ccode\u003estd::remove_if\u003c/code\u003e can be replaced by \u003ccode\u003estd::erase_if\u003c/code\u003e: \u003cpre\u003e\nvoid filterOutEvenNumbers(std::vector\u0026lt;int\u0026gt;\u0026amp; v) {\n  // Compliant: elements are erased as expected.\n  std::erase_if(v, [](int x) { return x % 2 \u003d\u003d 0; });\n}\n\u003c/pre\u003e  This solution is sufficient, reliable, and more readable than the original code.  \u003c/li\u003e\n  \u003cli\u003e Before C++20, we can apply the \u003cem\u003eerase-remove\u003c/em\u003e idiom and use the \u003ccode\u003eerase\u003c/code\u003e member function of the container: \u003cpre\u003e\nvoid filterOutEvenNumbers(std::vector\u0026lt;int\u0026gt;\u0026amp; v) {\n  auto newEnd \u003d std::remove_if(v.begin(), v.end(), [](int x) { return x % 2 \u003d\u003d 0; });\n  // Compliant: elements are erased as expected.\n  v.erase(newEnd, v.end());\n}\n\u003c/pre\u003e  This solution is semantically identical to the C++20 version but more verbose.  \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cp\u003eThis example shows an incorrect use of the \u003ccode\u003estd::ranges::unique\u003c/code\u003e function: \u003ccode\u003ev\u003c/code\u003e is left with indeterminate values.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid removeDuplicateValues(std::vector\u0026lt;int\u0026gt;\u0026amp; v) {\n  std::ranges::sort(v);\n  // Noncompliant: some elements in \"v\" have an unspecified value.\n  std::ranges::unique(v);\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eWe apply the \u003cem\u003eremove-erase\u003c/em\u003e idiom in this fixed version using the subrange returned by \u003ccode\u003estd::ranges::unique\u003c/code\u003e.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\nvoid removeDuplicateValues(std::vector\u0026lt;int\u0026gt;\u0026amp; v) {\n  std::ranges::sort(v);\n  // Compliant: the returned range is used to erase duplicated elements.\n  auto [duplicateBegin, duplicateEnd] \u003d std::ranges::unique(v);\n  v.erase(duplicateBegin, duplicateEnd);\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Wikipedia - \u003ca href\u003d\"https://en.wikipedia.org/wiki/Erase%E2%80%93remove_idiom\"\u003eErase-remove idiom\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/algorithm/remove\"\u003e\u003ccode\u003estd::remove\u003c/code\u003e, \u003ccode\u003estd::remove_if\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/algorithm/unique\"\u003e\u003ccode\u003estd::unique\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/ranges/filter_view\"\u003e\u003ccode\u003estd::views::filter\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/algorithm/ranges/remove\"\u003e\u003ccode\u003estd::ranges::remove\u003c/code\u003e,\n  \u003ccode\u003estd::ranges::remove_if\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/algorithm/ranges/unique\"\u003e\u003ccode\u003estd::ranges::unique\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/container/vector/erase2\"\u003e\u003ccode\u003estd::erase\u003c/code\u003e, \u003ccode\u003estd::erase_if\u003c/code\u003e (for\n  \u003ccode\u003estd::vector\u003c/code\u003e)\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S6165} for C++20 helps replacing the \u003cem\u003eerase-remove\u003c/em\u003e idiom with \u003ccode\u003estd::erase\u003c/code\u003e/\u003ccode\u003estd::erase_if\u003c/code\u003e. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5019",
    "name": "Lambdas that capture \"this\" should capture everything explicitly",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eA lambda can only capture local variables. When a lambda is defined within a member function, you may believe that you are capturing a member\nvariable of the current class, but in fact, what you are capturing is \u003ccode\u003ethis\u003c/code\u003e. This may be very surprising, and lead to bugs if the lambda\nis then used after the current object has been destroyed.\u003c/p\u003e\n\u003cp\u003eTherefore, it’s better to be explicit about exactly what is captured as soon as \u003ccode\u003ethis\u003c/code\u003e is captured.\u003c/p\u003e\n\u003cp\u003eIf the lambda is used immediately (for instance, called or passed as an argument to \u003ccode\u003estd::sort\u003c/code\u003e), there is no such risk and no issue is\nraised.\u003c/p\u003e\n\u003cp\u003eIn C++20, capturing \u003ccode\u003ethis\u003c/code\u003e via [\u003d] has been deprecated. An issue is raised in that case, even if the lambda is used immediately.\u003c/p\u003e\n\u003cp\u003eNote: This rule does not apply if the capture list of the lambda contains \u003ccode\u003e*this\u003c/code\u003e (possible since C++17). In that situation, what is\ncaptured is not the pointer \u003ccode\u003ethis\u003c/code\u003e, but a local copy of the object pointed-to by \u003ccode\u003ethis\u003c/code\u003e and any reference to \u003ccode\u003ethis\u003c/code\u003e\n(explicit or implicit) in the lambda body then refers to this local copy (see {rule:cpp:S6016}).\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid useLambda(std::function\u0026lt;int,int\u0026gt; lambda);\n\nclass A {\n  int i;\n  void f(int j) {\n    auto l \u003d [\u003d](int k) { return i+j+k;}; // Noncompliant, someone reading the code might believe that i is captured by copy\n    useLambda(l);\n  }\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid useLambda(std::function\u0026lt;int,int\u0026gt; lambda);\n\nclass A {\n  int i;\n  void f(int j) {\n    auto l \u003d [this, j](int k) { return i+j+k;}; // It is now clearer that i is not directly captured\n    useLambda(l);\n    // auto l \u003d [i, j](int k) { return i+j+k;}; // Would not compile\n\n    auto l2 \u003d [\u003d, *this](int k) { return i+j+k;}; // Compliant, i refers to the member i of the captured copy\n    useLambda(l2);\n\n    auto l3 \u003d [\u003d](int k) { return i+j+k;}; // Compliant because l3 is only used immediately\n    int ijk \u003d l3(i,j,k);\n  }\n};\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f54-when-writing-a-lambda-that-captures-this-or-any-class-data-member-dont-use—​default-capture\"\u003eF.54: When writing a lambda that captures \u003ccode\u003ethis\u003c/code\u003e or any class data member, don’t use \u003ccode\u003e[\u003d]\u003c/code\u003e default capture\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eA lambda can only capture local variables. When a lambda is defined within a member function, you may believe that you are capturing a member\nvariable of the current class, but in fact, what you are capturing is \u003ccode\u003ethis\u003c/code\u003e. This may be very surprising, and lead to bugs if the lambda\nis then used after the current object has been destroyed.\u003c/p\u003e\n\u003cp\u003eTherefore, it’s better to be explicit about exactly what is captured as soon as \u003ccode\u003ethis\u003c/code\u003e is captured.\u003c/p\u003e\n\u003cp\u003eIf the lambda is used immediately (for instance, called or passed as an argument to \u003ccode\u003estd::sort\u003c/code\u003e), there is no such risk and no issue is\nraised.\u003c/p\u003e\n\u003cp\u003eIn C++20, capturing \u003ccode\u003ethis\u003c/code\u003e via [\u003d] has been deprecated. An issue is raised in that case, even if the lambda is used immediately.\u003c/p\u003e\n\u003cp\u003eNote: This rule does not apply if the capture list of the lambda contains \u003ccode\u003e*this\u003c/code\u003e (possible since C++17). In that situation, what is\ncaptured is not the pointer \u003ccode\u003ethis\u003c/code\u003e, but a local copy of the object pointed-to by \u003ccode\u003ethis\u003c/code\u003e and any reference to \u003ccode\u003ethis\u003c/code\u003e\n(explicit or implicit) in the lambda body then refers to this local copy (see {rule:cpp:S6016}).\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid useLambda(std::function\u0026lt;int,int\u0026gt; lambda);\n\nclass A {\n  int i;\n  void f(int j) {\n    auto l \u003d [\u003d](int k) { return i+j+k;}; // Noncompliant, someone reading the code might believe that i is captured by copy\n    useLambda(l);\n  }\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid useLambda(std::function\u0026lt;int,int\u0026gt; lambda);\n\nclass A {\n  int i;\n  void f(int j) {\n    auto l \u003d [this, j](int k) { return i+j+k;}; // It is now clearer that i is not directly captured\n    useLambda(l);\n    // auto l \u003d [i, j](int k) { return i+j+k;}; // Would not compile\n\n    auto l2 \u003d [\u003d, *this](int k) { return i+j+k;}; // Compliant, i refers to the member i of the captured copy\n    useLambda(l2);\n\n    auto l3 \u003d [\u003d](int k) { return i+j+k;}; // Compliant because l3 is only used immediately\n    int ijk \u003d l3(i,j,k);\n  }\n};\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f54-when-writing-a-lambda-that-captures-this-or-any-class-data-member-dont-use—​default-capture\"\u003eF.54: When writing a lambda that captures \u003ccode\u003ethis\u003c/code\u003e or any class data member, don’t use \u003ccode\u003e[\u003d]\u003c/code\u003e default capture\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "confusing",
      "cppcoreguidelines",
      "pitfall",
      "since-c++11"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6229",
    "name": "\"std::chrono\" components should be used to operate on time",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003echrono\u003c/code\u003e library, introduced in C++20, provides support for calendars, time zones, and i/o formatting and parsing operations on\ntime-related objects.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003echrono\u003c/code\u003e is a better alternative to the C/POSIX functions that operate on \u003ccode\u003etime_t\u003c/code\u003e, \u003ccode\u003etm\u003c/code\u003e, or \u003ccode\u003etimespec\u003c/code\u003e\ntypes. In comparison to C facilities, it provides a better integration with other components of the C++ standard library: (\u003ccode\u003eiostreams\u003c/code\u003e and\n\u003ccode\u003eformat\u003c/code\u003e). Also, it supports compile-time computation and it is thread safe.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue on any use of C/POSIX functions that can be replaced with one of the \u003ccode\u003estd::chrono\u003c/code\u003e components:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e querying for current time (\u003ccode\u003etime\u003c/code\u003e, \u003ccode\u003etimespec_get\u003c/code\u003e, \u003ccode\u003eclock_gettime\u003c/code\u003e) \u003c/li\u003e\n  \u003cli\u003e date to time-point conversion (\u003ccode\u003emktime\u003c/code\u003e, \u003ccode\u003egmtime\u003c/code\u003e, \u003ccode\u003elocaltime\u003c/code\u003e) \u003c/li\u003e\n  \u003cli\u003e time serialization (\u003ccode\u003ectime\u003c/code\u003e, \u003ccode\u003easctime\u003c/code\u003e, \u003ccode\u003estrftime\u003c/code\u003e) \u003c/li\u003e\n  \u003cli\u003e time parsing (\u003ccode\u003estrptime\u003c/code\u003e) \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint currentMonth() {\n  std::time_t tp;\n  std::time(\u0026amp;tp);\n  std::tm* date \u003d std::gmtime(\u0026amp;tp);\n  return date-\u0026gt;tm_mon + 1;\n}\n\nstd::chrono::system_clock::time_point makeSomeDay() {\n  // Creates time_point corresponding to 2020-09-04\n  std::tm date{};\n  date.tm_year \u003d 120;\n  date.tm_mon \u003d 8;\n  date.tm_mday \u003d 4;\n  std::time_t t \u003d std::mktime(\u0026amp;date); // Noncompliant\n  return std::chrono::system_clock::from_time_t(t);\n}\n\nstd::optional\u0026lt;int\u0026gt; yearOfTimePoint(std::chrono::system_clock::time_point tp) {\n  std::time_t t \u003d std::chrono::system_clock::to_time_t(tp);\n  std::tm* date \u003d std::gmtime(\u0026amp;t); // Noncompliant\n  if (!date)\n    return std::nullopt;\n  return date-\u0026gt;tm_year + 1900;\n}\n\nstd::string toIsoString(std::chrono::system_clock::time_point tp) {\n  std::time_t t \u003d std::chrono::system_clock::to_time_t(tp);\n  std::tm* date \u003d std::gmtime(\u0026amp;t);  // Noncompliant\n  if (!date)\n    throw InvalidDate();\n\n  std::string buffer(100, \u0027 \u0027);\n  std::size_t written \u003d std::strftime(buffer.data(), buffer.size(), \"%F\", date);\n  buffer.resize(written);\n  return buffer;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstd::chrono::month currentMonth() {\n  using namespace std::chrono;\n  auto dp \u003d floor\u0026lt;days\u0026gt;(system_clock::now());\n  return year_month_day(dp).month();\n}\n\nstd::chrono::system_clock::time_point makeSomeDay() {\n  using namespace std::chrono;\n  return sys_days(2020y/September/4);\n}\n\nstd::optional\u0026lt;std::chrono::year\u0026gt; yearOfTimePoint(std::chrono::system_clock::time_point tp) {\n  using namespace std::chrono;\n  year_month_day date(floor\u0026lt;days\u0026gt;(tp));\n  if (!date.ok())\n    return std::nullopt;\n  return date.year();\n}\n\nstd::string toIsoString(std::chrono::system_clock::time_point tp) {\n  return std::format(\"{:%F}\", tp);\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe \u003ccode\u003echrono\u003c/code\u003e library, introduced in C++20, provides support for calendars, time zones, and i/o formatting and parsing operations on\ntime-related objects.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003echrono\u003c/code\u003e is a better alternative to the C/POSIX functions that operate on \u003ccode\u003etime_t\u003c/code\u003e, \u003ccode\u003etm\u003c/code\u003e, or \u003ccode\u003etimespec\u003c/code\u003e\ntypes. In comparison to C facilities, it provides a better integration with other components of the C++ standard library: (\u003ccode\u003eiostreams\u003c/code\u003e and\n\u003ccode\u003eformat\u003c/code\u003e). Also, it supports compile-time computation and it is thread safe.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue on any use of C/POSIX functions that can be replaced with one of the \u003ccode\u003estd::chrono\u003c/code\u003e components:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e querying for current time (\u003ccode\u003etime\u003c/code\u003e, \u003ccode\u003etimespec_get\u003c/code\u003e, \u003ccode\u003eclock_gettime\u003c/code\u003e) \u003c/li\u003e\n  \u003cli\u003e date to time-point conversion (\u003ccode\u003emktime\u003c/code\u003e, \u003ccode\u003egmtime\u003c/code\u003e, \u003ccode\u003elocaltime\u003c/code\u003e) \u003c/li\u003e\n  \u003cli\u003e time serialization (\u003ccode\u003ectime\u003c/code\u003e, \u003ccode\u003easctime\u003c/code\u003e, \u003ccode\u003estrftime\u003c/code\u003e) \u003c/li\u003e\n  \u003cli\u003e time parsing (\u003ccode\u003estrptime\u003c/code\u003e) \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint currentMonth() {\n  std::time_t tp;\n  std::time(\u0026amp;tp);\n  std::tm* date \u003d std::gmtime(\u0026amp;tp);\n  return date-\u0026gt;tm_mon + 1;\n}\n\nstd::chrono::system_clock::time_point makeSomeDay() {\n  // Creates time_point corresponding to 2020-09-04\n  std::tm date{};\n  date.tm_year \u003d 120;\n  date.tm_mon \u003d 8;\n  date.tm_mday \u003d 4;\n  std::time_t t \u003d std::mktime(\u0026amp;date); // Noncompliant\n  return std::chrono::system_clock::from_time_t(t);\n}\n\nstd::optional\u0026lt;int\u0026gt; yearOfTimePoint(std::chrono::system_clock::time_point tp) {\n  std::time_t t \u003d std::chrono::system_clock::to_time_t(tp);\n  std::tm* date \u003d std::gmtime(\u0026amp;t); // Noncompliant\n  if (!date)\n    return std::nullopt;\n  return date-\u0026gt;tm_year + 1900;\n}\n\nstd::string toIsoString(std::chrono::system_clock::time_point tp) {\n  std::time_t t \u003d std::chrono::system_clock::to_time_t(tp);\n  std::tm* date \u003d std::gmtime(\u0026amp;t);  // Noncompliant\n  if (!date)\n    throw InvalidDate();\n\n  std::string buffer(100, \u0027 \u0027);\n  std::size_t written \u003d std::strftime(buffer.data(), buffer.size(), \"%F\", date);\n  buffer.resize(written);\n  return buffer;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstd::chrono::month currentMonth() {\n  using namespace std::chrono;\n  auto dp \u003d floor\u0026lt;days\u0026gt;(system_clock::now());\n  return year_month_day(dp).month();\n}\n\nstd::chrono::system_clock::time_point makeSomeDay() {\n  using namespace std::chrono;\n  return sys_days(2020y/September/4);\n}\n\nstd::optional\u0026lt;std::chrono::year\u0026gt; yearOfTimePoint(std::chrono::system_clock::time_point tp) {\n  using namespace std::chrono;\n  year_month_day date(floor\u0026lt;days\u0026gt;(tp));\n  if (!date.ok())\n    return std::nullopt;\n  return date.year();\n}\n\nstd::string toIsoString(std::chrono::system_clock::time_point tp) {\n  return std::format(\"{:%F}\", tp);\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "confusing",
      "since-c++20"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5259",
    "name": "Header guards should be followed by according \"#define\" macro",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eUsing include guards, wrapping around the entire content of a header file, is a best practice ensuring that no matter how many times the header is\nincluded in a translation unit, its content will only be seen once.\u0026nbsp;\u003c/p\u003e\n\u003cp\u003eThe include guard pattern is made up of four parts:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003e#ifndef\u003c/code\u003e at the top of the file, with a unique macro name (usually, the name relates to the file’s name to ensure uniqueness).\n  \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003e#define\u003c/code\u003e\u0026nbsp;with the same macro name. \u003c/li\u003e\n  \u003cli\u003e The content of the file \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003e#endif\u003c/code\u003e at the end of the file \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe rule raises an issue when the name in the second part differs from the first (usually because of a typo or a copy/paste issue).\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#ifndef MYFILE_H\n#define MY_FILE_H // Noncompliant\n//...\n#endif\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#ifndef MYFILE_H\n#define MYFILE_H\n//...\n#endif\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eUsing include guards, wrapping around the entire content of a header file, is a best practice ensuring that no matter how many times the header is\nincluded in a translation unit, its content will only be seen once.\u0026nbsp;\u003c/p\u003e\n\u003cp\u003eThe include guard pattern is made up of four parts:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003e#ifndef\u003c/code\u003e at the top of the file, with a unique macro name (usually, the name relates to the file’s name to ensure uniqueness).\n  \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003e#define\u003c/code\u003e\u0026nbsp;with the same macro name. \u003c/li\u003e\n  \u003cli\u003e The content of the file \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003e#endif\u003c/code\u003e at the end of the file \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe rule raises an issue when the name in the second part differs from the first (usually because of a typo or a copy/paste issue).\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#ifndef MYFILE_H\n#define MY_FILE_H // Noncompliant\n//...\n#endif\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#ifndef MYFILE_H\n#define MYFILE_H\n//...\n#endif\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "unpredictable"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5018",
    "name": "Move and swap operations should be \"noexcept\"",
    "defaultSeverity": "BLOCKER",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "EFFICIENT",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eMove operations (move constructor, move assignment operator) are about efficiently transferring resource ownership. When transferring resources\nfrom the source, you don’t have to allocate any memory or perform any other operation that might fail. This is why most people will expect move\noperations to be non-throwing.\u003c/p\u003e\n\u003cp\u003eAdditionally, if a move operation fails, the source object can have been partially altered by the move, making recovery very tricky or just\nimpossible. Therefore, to ensure robustness, some functions (for instance, \u003ccode\u003estd::move_if_noexcept\u003c/code\u003e, used by \u003ccode\u003estd::vector\u003c/code\u003e) will\ndecide to copy your object if its move operations are not decorated with \u003ccode\u003enoexcept\u003c/code\u003e. This can significantly slow down your program.\u003c/p\u003e\n\u003cp\u003eIf you can not implement your move operations so that they never throw, you may only provide copy operations that will be safer to use.\u003c/p\u003e\n\u003cp\u003eSwap operations are similar to move operations in that they should be equivalent to moving two objects into each other. So if you add a swap\nfunction to your type, it should be \u003ccode\u003enoexcept\u003c/code\u003e too.\u003c/p\u003e\n\u003cp\u003eNote that you should not write your move operations for most classes but rely on the \"Rule-of-Zero\" ({rule:cpp:S4963}).\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when a move or swap operation is not \u003ccode\u003enoexcept\u003c/code\u003e, which can happen in two cases:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The operation is user-defined and is not unconditionally declared as \u003ccode\u003enoexcept\u003c/code\u003e, \u003c/li\u003e\n  \u003cli\u003e The operation is implicitly defined, and one of the class’s base classes or member variables does not have \u003ccode\u003enoexcept\u003c/code\u003e move\n  operations. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nstruct A {\n  A (A const \u0026amp;a);\n  A (A \u0026amp;\u0026amp; a); // Noncompliant\n  ~A();\n  A \u0026amp;operator\u003d(A const \u0026amp;a);\n  A \u0026amp;operator\u003d(A \u0026amp;\u0026amp;a); // Noncompliant\n};\n\nvoid swap(A\u0026amp; a1, A\u0026amp; a2); // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nstruct A {\n  A (A const \u0026amp;a);\n  A (A \u0026amp;\u0026amp; a) noexcept;\n  ~A();\n  A \u0026amp;operator\u003d(A const \u0026amp;a);\n  A \u0026amp;operator\u003d(A \u0026amp;\u0026amp;a) noexcept;\n};\n\nvoid swap(A\u0026amp; a1, A\u0026amp; a2) noexcept;\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c66-make-move-operations-noexcept\"\u003eC.66: Make move operations\n  \u003ccode\u003enoexcept\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c85-make-swap-noexcept\"\u003eC.85: Make\n  \u003ccode\u003eswap\u003c/code\u003e \u003ccode\u003enoexcept\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eMove operations (move constructor, move assignment operator) are about efficiently transferring resource ownership. When transferring resources\nfrom the source, you don’t have to allocate any memory or perform any other operation that might fail. This is why most people will expect move\noperations to be non-throwing.\u003c/p\u003e\n\u003cp\u003eAdditionally, if a move operation fails, the source object can have been partially altered by the move, making recovery very tricky or just\nimpossible. Therefore, to ensure robustness, some functions (for instance, \u003ccode\u003estd::move_if_noexcept\u003c/code\u003e, used by \u003ccode\u003estd::vector\u003c/code\u003e) will\ndecide to copy your object if its move operations are not decorated with \u003ccode\u003enoexcept\u003c/code\u003e. This can significantly slow down your program.\u003c/p\u003e\n\u003cp\u003eIf you can not implement your move operations so that they never throw, you may only provide copy operations that will be safer to use.\u003c/p\u003e\n\u003cp\u003eSwap operations are similar to move operations in that they should be equivalent to moving two objects into each other. So if you add a swap\nfunction to your type, it should be \u003ccode\u003enoexcept\u003c/code\u003e too.\u003c/p\u003e\n\u003cp\u003eNote that you should not write your move operations for most classes but rely on the \"Rule-of-Zero\" ({rule:cpp:S4963}).\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when a move or swap operation is not \u003ccode\u003enoexcept\u003c/code\u003e, which can happen in two cases:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The operation is user-defined and is not unconditionally declared as \u003ccode\u003enoexcept\u003c/code\u003e, \u003c/li\u003e\n  \u003cli\u003e The operation is implicitly defined, and one of the class’s base classes or member variables does not have \u003ccode\u003enoexcept\u003c/code\u003e move\n  operations. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nstruct A {\n  A (A const \u0026amp;a);\n  A (A \u0026amp;\u0026amp; a); // Noncompliant\n  ~A();\n  A \u0026amp;operator\u003d(A const \u0026amp;a);\n  A \u0026amp;operator\u003d(A \u0026amp;\u0026amp;a); // Noncompliant\n};\n\nvoid swap(A\u0026amp; a1, A\u0026amp; a2); // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nstruct A {\n  A (A const \u0026amp;a);\n  A (A \u0026amp;\u0026amp; a) noexcept;\n  ~A();\n  A \u0026amp;operator\u003d(A const \u0026amp;a);\n  A \u0026amp;operator\u003d(A \u0026amp;\u0026amp;a) noexcept;\n};\n\nvoid swap(A\u0026amp; a1, A\u0026amp; a2) noexcept;\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c66-make-move-operations-noexcept\"\u003eC.66: Make move operations\n  \u003ccode\u003enoexcept\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c85-make-swap-noexcept\"\u003eC.85: Make\n  \u003ccode\u003eswap\u003c/code\u003e \u003ccode\u003enoexcept\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cppcoreguidelines",
      "error-handling",
      "since-c++11"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6228",
    "name": "\"std::has_single_bit\" should be used to test if an integer is a power of two",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eSince integers are usually represented in binary form in computers, it is efficient to check if a given number is a power of two by checking if its\n\u003ccode\u003eunsigned\u003c/code\u003e representation has a single-bit set.\u003c/p\u003e\n\u003cp\u003eIn C++ such check could be expressed as \u003ccode\u003ex \u0026amp; (x-1) \u003d\u003d 0\u003c/code\u003e. However, the intent of this expression is unclear. Furthermore, it\nrequires special care for the value \u003ccode\u003e0\u003c/code\u003e, which would pass the above check without having any bit set or being a power of two.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003estd::has_single_bit\u003c/code\u003e function template, introduced in C++20 that checks if an integer is a power of two, expresses the intent more\nclearly.\u003c/p\u003e\n\u003cp\u003eThis rule reports computations that could be replaced with \u003ccode\u003estd::has_single_bit\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid f(unsigned x) {\n  if ((x \u0026gt; 0) \u0026amp;\u0026amp; !(x \u0026amp; (x-1))) { // Noncompliant\n    // Special algorithm for powers of 2\n  }\n  // Normal algorithm\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid f(unsigned x) {\n  if (std::has_single_bit(x)) {\n    // Special algorithm for powers of 2\n  }\n  // Normal algorithm\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/numeric/has_single_bit\"\u003estd::has_single_bit\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eSince integers are usually represented in binary form in computers, it is efficient to check if a given number is a power of two by checking if its\n\u003ccode\u003eunsigned\u003c/code\u003e representation has a single-bit set.\u003c/p\u003e\n\u003cp\u003eIn C++ such check could be expressed as \u003ccode\u003ex \u0026amp; (x-1) \u003d\u003d 0\u003c/code\u003e. However, the intent of this expression is unclear. Furthermore, it\nrequires special care for the value \u003ccode\u003e0\u003c/code\u003e, which would pass the above check without having any bit set or being a power of two.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003estd::has_single_bit\u003c/code\u003e function template, introduced in C++20 that checks if an integer is a power of two, expresses the intent more\nclearly.\u003c/p\u003e\n\u003cp\u003eThis rule reports computations that could be replaced with \u003ccode\u003estd::has_single_bit\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid f(unsigned x) {\n  if ((x \u0026gt; 0) \u0026amp;\u0026amp; !(x \u0026amp; (x-1))) { // Noncompliant\n    // Special algorithm for powers of 2\n  }\n  // Normal algorithm\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid f(unsigned x) {\n  if (std::has_single_bit(x)) {\n    // Special algorithm for powers of 2\n  }\n  // Normal algorithm\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/numeric/has_single_bit\"\u003estd::has_single_bit\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "confusing",
      "since-c++20"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1081",
    "name": "Insecure functions should not be used",
    "defaultSeverity": "CRITICAL",
    "type": "VULNERABILITY",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "SECURITY": "HIGH"
    },
    "description": "\u003cp\u003eInsecure functions often involve handling data, such as strings and memory operations. The vulnerability arises when these functions do not\nproperly check or limit the size of the data they are handling.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eAn attacker typically provides input that exceeds the expected size. This could be through a text field in a user interface, a file that the\nprogram reads, or data sent over a network. The insecure function processes this input and places the result into a provided buffer.\u003c/p\u003e\n\u003cp\u003eIf the input is larger than the buffer can handle, the insecure function will overwrite the memory following the buffer. This situation is known as\na buffer overflow vulnerability.\u003c/p\u003e\n\u003cp\u003eWhen using typical C or C++ functions, it’s up to the developer to make sure the size of the buffer to be written to is large enough to avoid\nbuffer overflows.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003ch4\u003eCode execution\u003c/h4\u003e\n\u003cp\u003eIn some cases, an attacker can craft input in a way that allows them to gain unauthorized access to your system. For example, they might be able to\noverwrite a function’s return address in memory, causing your program to execute code of the attacker’s choosing. This could potentially give the\nattacker full control over your system.\u003c/p\u003e\n\u003ch4\u003eDenial of service\u003c/h4\u003e\n\u003cp\u003eIf an attacker can trigger a buffer overflow by providing oversized input, it can cause the program to crash. If the attacker repeats this process,\nit can continually disrupt the service, denying access to other users. This can be particularly damaging for services that require high availability,\nsuch as online platforms or databases.\u003c/p\u003e\n\u003cp\u003eIn some cases, the input might cause the program to enter an infinite loop or consume excessive memory, slowing down the system or even causing it\nto become unresponsive. This type of attack is known as a resource exhaustion DoS attack.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eInsecure functions should be replaced with safer alternatives that limit how much data can be written to the buffer.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n\nchar str[20];\ngets(str); // Noncompliant; `str` buffer size is not checked and it is vulnerable to overflows\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;string.h\u0026gt;\n\nchar buffer[20];\nstrcpy(buffer, input); // Noncompliant; `input` length is not checked and it may overflow `buffer`\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#define __STDC_WANT_LIB_EXT1__\n#include \u0026lt;stdio.h\u0026gt;\n\nchar str[20];\ngets_s(str, sizeof(str));\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\n#define __STDC_WANT_LIB_EXT1__\n#include \u0026lt;string.h\u0026gt;\n\nchar buffer[20];\nstrcpy_s(buffer, sizeof buffer, input);\n\u003c/pre\u003e\n\u003ch3\u003eHow does this work?\u003c/h3\u003e\n\u003cp\u003eC and C++ have a number of functions that are considered insecure because they do not perform bounds checking. Functions like \u003ccode\u003egets\u003c/code\u003e are\nknown to be risky. Replace these with safer alternatives that include bounds checking. For example, instead of \u003ccode\u003egets\u003c/code\u003e, use\n\u003ccode\u003egets_s\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThe code can also checks if the size of input data is less than or equal to the size of a buffer (including the terminating null byte when dealing\nwith strings).\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003egets_s\u003c/code\u003e function is defined in annex K of C11 and is optional for C11 compilers. It will only be available if the macro\n\u003ccode\u003e__STDC_LIB_EXT1__\u003c/code\u003e is defined, and it must be enabled by defining the macro \u003ccode\u003e__STDC_WANT_LIB_EXT1__\u003c/code\u003e before including\n\u003ccode\u003e\u0026lt;stdio.h\u0026gt;\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eOther platform-specific functions can perform the same operations. For example, \u003ccode\u003estrcpy\u003c/code\u003e can be substituted with \u003ca\nhref\u003d\"https://learn.microsoft.com/en-us/windows/win32/api/strsafe/nf-strsafe-stringcbcopya\"\u003eStringCbCopyA\u003c/a\u003e (Windows) or \u003ca\nhref\u003d\"https://www.freebsd.org/cgi/man.cgi?query\u003dstrlcpy\"\u003estrlcpy\u003c/a\u003e (FreeBSD).\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eArticles \u0026amp; blog posts\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Wikipedia - \u003ca href\u003d\"https://en.wikipedia.org/wiki/Buffer_overflow\"\u003eBuffer overflow\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e OWASP - \u003ca href\u003d\"https://owasp.org/Top10/A06_2021-Vulnerable_and_Outdated_Components/\"\u003eTop 10 2021 - A06 - Vulnerable and Outdated\n  Components\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e OWASP - \u003ca href\u003d\"https://owasp.org/www-project-top-ten/2017/A9_2017-Using_Components_with_Known_Vulnerabilities\"\u003eTop 10 2017 Category A9 -\n  Using Components with Known Vulnerabilities\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/676\"\u003eCWE-676 - Use of Potentially Dangerous Function\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/119\"\u003eCWE-119 - Improper Restriction of Operations within the Bounds of a Memory\n  Buffer\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eInsecure functions often involve handling data, such as strings and memory operations. The vulnerability arises when these functions do not\nproperly check or limit the size of the data they are handling.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eAn attacker typically provides input that exceeds the expected size. This could be through a text field in a user interface, a file that the\nprogram reads, or data sent over a network. The insecure function processes this input and places the result into a provided buffer.\u003c/p\u003e\n\u003cp\u003eIf the input is larger than the buffer can handle, the insecure function will overwrite the memory following the buffer. This situation is known as\na buffer overflow vulnerability.\u003c/p\u003e\n\u003cp\u003eWhen using typical C or C++ functions, it’s up to the developer to make sure the size of the buffer to be written to is large enough to avoid\nbuffer overflows.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003ch4\u003eCode execution\u003c/h4\u003e\n\u003cp\u003eIn some cases, an attacker can craft input in a way that allows them to gain unauthorized access to your system. For example, they might be able to\noverwrite a function’s return address in memory, causing your program to execute code of the attacker’s choosing. This could potentially give the\nattacker full control over your system.\u003c/p\u003e\n\u003ch4\u003eDenial of service\u003c/h4\u003e\n\u003cp\u003eIf an attacker can trigger a buffer overflow by providing oversized input, it can cause the program to crash. If the attacker repeats this process,\nit can continually disrupt the service, denying access to other users. This can be particularly damaging for services that require high availability,\nsuch as online platforms or databases.\u003c/p\u003e\n\u003cp\u003eIn some cases, the input might cause the program to enter an infinite loop or consume excessive memory, slowing down the system or even causing it\nto become unresponsive. This type of attack is known as a resource exhaustion DoS attack.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eInsecure functions should be replaced with safer alternatives that limit how much data can be written to the buffer.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n\nchar str[20];\ngets(str); // Noncompliant; `str` buffer size is not checked and it is vulnerable to overflows\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;string.h\u0026gt;\n\nchar buffer[20];\nstrcpy(buffer, input); // Noncompliant; `input` length is not checked and it may overflow `buffer`\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#define __STDC_WANT_LIB_EXT1__\n#include \u0026lt;stdio.h\u0026gt;\n\nchar str[20];\ngets_s(str, sizeof(str));\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\n#define __STDC_WANT_LIB_EXT1__\n#include \u0026lt;string.h\u0026gt;\n\nchar buffer[20];\nstrcpy_s(buffer, sizeof buffer, input);\n\u003c/pre\u003e\n\u003ch3\u003eHow does this work?\u003c/h3\u003e\n\u003cp\u003eC and C++ have a number of functions that are considered insecure because they do not perform bounds checking. Functions like \u003ccode\u003egets\u003c/code\u003e are\nknown to be risky. Replace these with safer alternatives that include bounds checking. For example, instead of \u003ccode\u003egets\u003c/code\u003e, use\n\u003ccode\u003egets_s\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThe code can also checks if the size of input data is less than or equal to the size of a buffer (including the terminating null byte when dealing\nwith strings).\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003egets_s\u003c/code\u003e function is defined in annex K of C11 and is optional for C11 compilers. It will only be available if the macro\n\u003ccode\u003e__STDC_LIB_EXT1__\u003c/code\u003e is defined, and it must be enabled by defining the macro \u003ccode\u003e__STDC_WANT_LIB_EXT1__\u003c/code\u003e before including\n\u003ccode\u003e\u0026lt;stdio.h\u0026gt;\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eOther platform-specific functions can perform the same operations. For example, \u003ccode\u003estrcpy\u003c/code\u003e can be substituted with \u003ca\nhref\u003d\"https://learn.microsoft.com/en-us/windows/win32/api/strsafe/nf-strsafe-stringcbcopya\"\u003eStringCbCopyA\u003c/a\u003e (Windows) or \u003ca\nhref\u003d\"https://www.freebsd.org/cgi/man.cgi?query\u003dstrlcpy\"\u003estrlcpy\u003c/a\u003e (FreeBSD).\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eArticles \u0026amp; blog posts\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Wikipedia - \u003ca href\u003d\"https://en.wikipedia.org/wiki/Buffer_overflow\"\u003eBuffer overflow\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e OWASP - \u003ca href\u003d\"https://owasp.org/Top10/A06_2021-Vulnerable_and_Outdated_Components/\"\u003eTop 10 2021 - A06 - Vulnerable and Outdated\n  Components\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e OWASP - \u003ca href\u003d\"https://owasp.org/www-project-top-ten/2017/A9_2017-Using_Components_with_Known_Vulnerabilities\"\u003eTop 10 2017 Category A9 -\n  Using Components with Known Vulnerabilities\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/676\"\u003eCWE-676 - Use of Potentially Dangerous Function\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/119\"\u003eCWE-119 - Improper Restriction of Operations within the Bounds of a Memory\n  Buffer\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cert",
      "cwe"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S3261",
    "name": "Namespaces should not be empty",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eNamespaces with no lines of code clutter a project and should be removed.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nnamespace MyEmptyNamespace // Noncompliant\n{\n\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eNamespaces with no lines of code clutter a project and should be removed.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nnamespace MyEmptyNamespace // Noncompliant\n{\n\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "unused"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S100",
    "name": "Function names should comply with a naming convention",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "IDENTIFIABLE",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eShared naming conventions allow teams to collaborate efficiently.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when a function name does not match a provided regular expression.\u003c/p\u003e\n\u003cp\u003eFor example, with the default provided regular expression: \u003ccode\u003e^[a-z][a-zA-Z0-9]*$\u003c/code\u003e, the function:\u003c/p\u003e\n\u003cpre\u003e\nvoid DoSomething(); // Noncompliant\n\u003c/pre\u003e\n\u003cp\u003eshould be renamed to\u003c/p\u003e\n\u003cpre\u003e\nvoid doSomething();\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThe rule ignores the names of:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Overriding methods \u003c/li\u003e\n  \u003cli\u003e Template specializations \u003c/li\u003e\n  \u003cli\u003e When an interface expects a specific name (e.g., \u003ccode\u003ebegin\u003c/code\u003e or \u003ccode\u003eend\u003c/code\u003e for range-based loops, \u003ccode\u003eget\u0026lt;N\u0026gt;\u003c/code\u003e for\n  structural binding, etc.) \u003c/li\u003e\n  \u003cli\u003e Coroutines ({rule:cpp:S6193} covers them) \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S6193} - Coroutine names should comply with a naming convention \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eShared naming conventions allow teams to collaborate efficiently.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when a function name does not match a provided regular expression.\u003c/p\u003e\n\u003cp\u003eFor example, with the default provided regular expression: \u003ccode\u003e^[a-z][a-zA-Z0-9]*$\u003c/code\u003e, the function:\u003c/p\u003e\n\u003cpre\u003e\nvoid DoSomething(); // Noncompliant\n\u003c/pre\u003e\n\u003cp\u003eshould be renamed to\u003c/p\u003e\n\u003cpre\u003e\nvoid doSomething();\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThe rule ignores the names of:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Overriding methods \u003c/li\u003e\n  \u003cli\u003e Template specializations \u003c/li\u003e\n  \u003cli\u003e When an interface expects a specific name (e.g., \u003ccode\u003ebegin\u003c/code\u003e or \u003ccode\u003eend\u003c/code\u003e for range-based loops, \u003ccode\u003eget\u0026lt;N\u0026gt;\u003c/code\u003e for\n  structural binding, etc.) \u003c/li\u003e\n  \u003cli\u003e Coroutines ({rule:cpp:S6193} covers them) \u003c/li\u003e\n\u003c/ul\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S6193} - Coroutine names should comply with a naming convention \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {
      "format": {
        "key": "format",
        "name": "format",
        "description": "POSIX regular expression used to check the function names against",
        "defaultValue": "^[a-z][a-zA-Z0-9]*$",
        "type": "STRING",
        "multiple": false,
        "possibleValues": []
      }
    },
    "defaultParams": {
      "format": "^[a-z][a-zA-Z0-9]*$"
    },
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "convention"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S101",
    "name": "Class names should comply with a naming convention",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "IDENTIFIABLE",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eShared naming conventions allow teams to collaborate efficiently.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when a class name (or an Objective-C interface, protocol, or implementation name) does not match a provided regular\nexpression.\u003c/p\u003e\n\u003cp\u003eFor example, with the default provided regular expression \u003ccode\u003e^[A-Z][a-zA-Z0-9]*$\u003c/code\u003e, the following class and interface:\u003c/p\u003e\n\u003cpre\u003e\n// C++\nclass foo // Noncompliant\n{\n};\n\n// Objective-C\n@interface nonCompliant: NSObject\n@end\n\u003c/pre\u003e\n\u003cp\u003eshould be renamed to\u003c/p\u003e\n\u003cpre\u003e\n// C++\nclass Foo\n{\n};\n\n// Objective-C\n@interface Compliant: NSObject\n@end\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eShared naming conventions allow teams to collaborate efficiently.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when a class name (or an Objective-C interface, protocol, or implementation name) does not match a provided regular\nexpression.\u003c/p\u003e\n\u003cp\u003eFor example, with the default provided regular expression \u003ccode\u003e^[A-Z][a-zA-Z0-9]*$\u003c/code\u003e, the following class and interface:\u003c/p\u003e\n\u003cpre\u003e\n// C++\nclass foo // Noncompliant\n{\n};\n\n// Objective-C\n@interface nonCompliant: NSObject\n@end\n\u003c/pre\u003e\n\u003cp\u003eshould be renamed to\u003c/p\u003e\n\u003cpre\u003e\n// C++\nclass Foo\n{\n};\n\n// Objective-C\n@interface Compliant: NSObject\n@end\n\u003c/pre\u003e"
      }
    ],
    "params": {
      "format": {
        "key": "format",
        "name": "format",
        "description": "POSIX regular expression used to check the class names against.",
        "defaultValue": "^[A-Z][a-zA-Z0-9]*$",
        "type": "STRING",
        "multiple": false,
        "possibleValues": []
      }
    },
    "defaultParams": {
      "format": "^[A-Z][a-zA-Z0-9]*$"
    },
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "convention"
    ],
    "deprecatedKeys": [
      "cpp:ClassName"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5566",
    "name": "STL algorithms and range-based for loops should be preferred to traditional for loops",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003efor\u003c/code\u003e-loops are a very powerful and versatile tool that can be used for many purposes. This flexibility comes with drawbacks:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e It is very easy to make a small mistake when writing them, \u003c/li\u003e\n  \u003cli\u003e They are relatively verbose to write, \u003c/li\u003e\n  \u003cli\u003e They do not express the intent of the code, the reader has to look at loop details to understand what the loop does. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere are algorithms that encapsulate a \u003ccode\u003efor\u003c/code\u003e-loop and give it some meaning (\u003ccode\u003estd::all_of\u003c/code\u003e, \u003ccode\u003estd::count_if\u003c/code\u003e,\n\u003ccode\u003estd::remove_if\u003c/code\u003e…​). These algorithms are well tested, efficient, and explicit and therefore should be your first choice.\u003c/p\u003e\n\u003cp\u003eThis rule detects loops that go through all consecutive elements of a sequence (eg: containers, objects with begin() and end() member functions),\nand deal only with the current element without side-effects on the rest of the sequence.\u003c/p\u003e\n\u003cp\u003eThis rule suggests using one of the supported STL algorithm patterns corresponding to your C++ standard when a loop matches it.\u003c/p\u003e\n\u003cp\u003eCurrently, this rule supports:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003estd::all_of\u003c/code\u003e (since C++11) and \u003ccode\u003estd::ranges::all_of\u003c/code\u003e (since C++20): returns \u003ccode\u003etrue\u003c/code\u003e if all elements in the\n  given range are matching the given predicate, \u003ccode\u003efalse\u003c/code\u003e otherwise \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003estd::none_of\u003c/code\u003e (since C++11) and \u003ccode\u003estd::ranges::none_of\u003c/code\u003e (since C++20): returns \u003ccode\u003etrue\u003c/code\u003e if no elements in the\n  given range are matching the given predicate, \u003ccode\u003efalse\u003c/code\u003e otherwise \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003estd::any_of\u003c/code\u003e (since C++11) and \u003ccode\u003estd::ranges::any_of\u003c/code\u003e (since C++20): returns \u003ccode\u003etrue\u003c/code\u003e if at least one element in\n  the given range is matching the given predicate, \u003ccode\u003efalse\u003c/code\u003e otherwise \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis rule suggests two options below when the loop doesn’t match any of the supported STL algorithm patterns and you just want to iterate over all\nelements of a sequence:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Range-based \u003ccode\u003efor\u003c/code\u003e-loops, which were introduced in C++11 and will run through all elements of a sequence \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003estd::for_each\u003c/code\u003e, an algorithm that performs the same operation between two iterators (allowing more flexibility, for instance by\n  using \u003ccode\u003ereverse_iterator\u003c/code\u003es, or with a variant that can loop in parallel on several elements at a time). \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;iostream\u0026gt;\n\nusing namespace std;\n\nbool asDesired(const int v);\n\nbool areAllDesired(std::vector\u0026lt;int\u0026gt; values) {\n  for (int val : values) { // Noncompliant, replace it by a call to std::all_of\n    if (!asDesired(val)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nint f(vector\u0026lt;int\u0026gt; \u0026amp;v) {\n\n  for (auto it \u003d v.begin(); it !\u003d v.end(); ++it) { // Noncompliant\n    if (*it \u0026gt; 0) {\n      cout \u0026lt;\u0026lt; \"Positive number : \" \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; endl;\n    } else {\n      cout \u0026lt;\u0026lt; \"Negative number : \" \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; endl;\n    }\n  }\n\n  auto sum \u003d 0;\n  for (auto it \u003d v.begin(); it !\u003d v.end(); ++it) { // Noncompliant\n    sum +\u003d *it;\n  }\n  return sum;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n\nusing namespace std;\n\nbool asDesired(const int v);\n\nbool areAllDesired2(std::vector\u0026lt;int\u0026gt; values) {\n  return std::all_of(std::begin(values), std::end(values), asDesired);\n}\n\nbool areAllDesiredCpp20(std::vector\u0026lt;int\u0026gt; values) {\n  return std::ranges::all_of(values, asDesired);\n}\n\nvoid displayNumber(int i) {\n  if (i \u0026gt; 0) {\n    cout \u0026lt;\u0026lt; \"Positive number : \" \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl;\n  } else {\n    cout \u0026lt;\u0026lt; \"Negative number : \" \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl;\n  }\n}\n\nvoid f(vector\u0026lt;int\u0026gt; \u0026amp;v) {\n\n  std::for_each(v.begin(), v.end(), displayNumber);\n  // Or since C++20:\n  std::ranges::for_each(v, displayNumber);\n\n  auto sum \u003d 0;\n  for (auto elt : v) {\n    sum +\u003d elt;\n  }\n  return sum;\n  // An even better way to write this would be:\n  // return std::accumulate(v.begin(), v.end(), 0);\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es71-prefer-a-range-for-statement-to-a-for-statement-when-there-is-a-choice\"\u003eES.71: Prefer a range-\u003ccode\u003efor\u003c/code\u003e-statement to a \u003ccode\u003efor\u003c/code\u003e-statement when there is a choice\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#p3-express-intent\"\u003eP.3: Express\n  intent\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003ccode\u003efor\u003c/code\u003e-loops are a very powerful and versatile tool that can be used for many purposes. This flexibility comes with drawbacks:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e It is very easy to make a small mistake when writing them, \u003c/li\u003e\n  \u003cli\u003e They are relatively verbose to write, \u003c/li\u003e\n  \u003cli\u003e They do not express the intent of the code, the reader has to look at loop details to understand what the loop does. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere are algorithms that encapsulate a \u003ccode\u003efor\u003c/code\u003e-loop and give it some meaning (\u003ccode\u003estd::all_of\u003c/code\u003e, \u003ccode\u003estd::count_if\u003c/code\u003e,\n\u003ccode\u003estd::remove_if\u003c/code\u003e…​). These algorithms are well tested, efficient, and explicit and therefore should be your first choice.\u003c/p\u003e\n\u003cp\u003eThis rule detects loops that go through all consecutive elements of a sequence (eg: containers, objects with begin() and end() member functions),\nand deal only with the current element without side-effects on the rest of the sequence.\u003c/p\u003e\n\u003cp\u003eThis rule suggests using one of the supported STL algorithm patterns corresponding to your C++ standard when a loop matches it.\u003c/p\u003e\n\u003cp\u003eCurrently, this rule supports:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003estd::all_of\u003c/code\u003e (since C++11) and \u003ccode\u003estd::ranges::all_of\u003c/code\u003e (since C++20): returns \u003ccode\u003etrue\u003c/code\u003e if all elements in the\n  given range are matching the given predicate, \u003ccode\u003efalse\u003c/code\u003e otherwise \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003estd::none_of\u003c/code\u003e (since C++11) and \u003ccode\u003estd::ranges::none_of\u003c/code\u003e (since C++20): returns \u003ccode\u003etrue\u003c/code\u003e if no elements in the\n  given range are matching the given predicate, \u003ccode\u003efalse\u003c/code\u003e otherwise \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003estd::any_of\u003c/code\u003e (since C++11) and \u003ccode\u003estd::ranges::any_of\u003c/code\u003e (since C++20): returns \u003ccode\u003etrue\u003c/code\u003e if at least one element in\n  the given range is matching the given predicate, \u003ccode\u003efalse\u003c/code\u003e otherwise \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis rule suggests two options below when the loop doesn’t match any of the supported STL algorithm patterns and you just want to iterate over all\nelements of a sequence:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Range-based \u003ccode\u003efor\u003c/code\u003e-loops, which were introduced in C++11 and will run through all elements of a sequence \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003estd::for_each\u003c/code\u003e, an algorithm that performs the same operation between two iterators (allowing more flexibility, for instance by\n  using \u003ccode\u003ereverse_iterator\u003c/code\u003es, or with a variant that can loop in parallel on several elements at a time). \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;iostream\u0026gt;\n\nusing namespace std;\n\nbool asDesired(const int v);\n\nbool areAllDesired(std::vector\u0026lt;int\u0026gt; values) {\n  for (int val : values) { // Noncompliant, replace it by a call to std::all_of\n    if (!asDesired(val)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nint f(vector\u0026lt;int\u0026gt; \u0026amp;v) {\n\n  for (auto it \u003d v.begin(); it !\u003d v.end(); ++it) { // Noncompliant\n    if (*it \u0026gt; 0) {\n      cout \u0026lt;\u0026lt; \"Positive number : \" \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; endl;\n    } else {\n      cout \u0026lt;\u0026lt; \"Negative number : \" \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; endl;\n    }\n  }\n\n  auto sum \u003d 0;\n  for (auto it \u003d v.begin(); it !\u003d v.end(); ++it) { // Noncompliant\n    sum +\u003d *it;\n  }\n  return sum;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n\nusing namespace std;\n\nbool asDesired(const int v);\n\nbool areAllDesired2(std::vector\u0026lt;int\u0026gt; values) {\n  return std::all_of(std::begin(values), std::end(values), asDesired);\n}\n\nbool areAllDesiredCpp20(std::vector\u0026lt;int\u0026gt; values) {\n  return std::ranges::all_of(values, asDesired);\n}\n\nvoid displayNumber(int i) {\n  if (i \u0026gt; 0) {\n    cout \u0026lt;\u0026lt; \"Positive number : \" \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl;\n  } else {\n    cout \u0026lt;\u0026lt; \"Negative number : \" \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl;\n  }\n}\n\nvoid f(vector\u0026lt;int\u0026gt; \u0026amp;v) {\n\n  std::for_each(v.begin(), v.end(), displayNumber);\n  // Or since C++20:\n  std::ranges::for_each(v, displayNumber);\n\n  auto sum \u003d 0;\n  for (auto elt : v) {\n    sum +\u003d elt;\n  }\n  return sum;\n  // An even better way to write this would be:\n  // return std::accumulate(v.begin(), v.end(), 0);\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es71-prefer-a-range-for-statement-to-a-for-statement-when-there-is-a-choice\"\u003eES.71: Prefer a range-\u003ccode\u003efor\u003c/code\u003e-statement to a \u003ccode\u003efor\u003c/code\u003e-statement when there is a choice\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#p3-express-intent\"\u003eP.3: Express\n  intent\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "clumsy",
      "cppcoreguidelines"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6655",
    "name": "Variables should not be accessed outside of their scope",
    "defaultSeverity": "BLOCKER",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003cp\u003eAccessing local objects outside of their scope (for example, via a pointer taken inside the scope) has undefined behavior. This rule flags such\naccess for local variables and lifetime-extended temporaries.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eLocal variables in C++ are attached to the scope and destroyed when the end of the scope is reached. Any access to a variable outside of their\nscope has undefined behavior.\u003c/p\u003e\n\u003cp\u003eSuch access occurs, for example, when the address of a variable is stored in a pointer that is later dereferenced:\u003c/p\u003e\n\u003cpre\u003e\nint func() {\n  int* ptr \u003d nullptr;\n  {\n    int i \u003d 10;\n    ptr \u003d \u0026amp;i;\n  } // variable i goes out of scope here\n  *ptr \u003d 10; // Noncompliant: writing to out-of-scope-variable\n}\n\u003c/pre\u003e\n\u003cp\u003eA similar defect can occur in code that does not have curly braces (also referred to as a compound statement), but contain control structures, like\n\u003ccode\u003eif\u003c/code\u003e or \u003ccode\u003efor\u003c/code\u003e that also introduce scope:\u003c/p\u003e\n\u003cpre\u003e\nint exampleWithIf() {\n  int* ptr;\n  if (int i \u003d 10)\n    ptr \u003d \u0026amp;i;\n  else\n    ptr \u003d nullptr;\n  // variable i declared in if condition statement goes out of scope here\n  if (ptr)\n    return *ptr; // Noncompliant: reading from out-of-scope variable\n  return 0;\n}\nvoid exampleWithFor() {\n  int* ptr \u003d nullptr;\n  for (int i \u003d 0; i \u0026lt; 10; ++i)\n    ptr \u003d \u0026amp;i;\n  // variable i defined in for init-statement goes out of scope here\n  *ptr \u003d 10; // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eAccessing a dangling reference or pointer causes undefined behavior. This means the compiler is not bound by the language standard anymore and your\nprogram has no meaning assigned to it.\u003c/p\u003e\n\u003cp\u003ePractically this has a wide range of effects. In many cases, the access works by accident and succeeds at writing or reading a value. However, it\ncan start misbehaving at any time. If compilation flags, compiler, platform, or runtime environment change, the same code can crash the application,\ncorrupt memory, or leak a secret.\u003c/p\u003e\n\u003ch3\u003eWhy is the issue raised for reference variables?\u003c/h3\u003e\n\u003cp\u003eWhen a reference variable is directly initialized to a temporary object, such temporary is lifetime-extended by the variable, i.e., the temporary\nobject is destroyed when the variable goes out of scope. Lifetime-extended temporaries have the same behavior as if they were declared as local\nvariables and may lead to the same issues. For example:\u003c/p\u003e\n\u003cpre\u003e\nClazz create();\nvoid refExtension(Clazz const arg) {\n  Clazz const* aPtr;\n  Clazz const* tPtr;\n  {\n    Clazz const\u0026amp; aRef \u003d arg; // bounding reference to object arg\n    Clazz const\u0026amp; tRef \u003d create(); // temporary object is created here and bound to reference,\n                                  // behaves as Clazz const tRef \u003d create();\n    aPtr \u003d \u0026amp;aRef;  // points to arg\n    tPtr \u003d \u0026amp;tRef;  // point to a temporary object that is lifetime extended\n  } // both aRef and tRef go out of scope here, because tRef was extending the lifetime of\n    // temporary variable, the object is destroyed\n  aPtr-\u0026gt;foo(); // OK, a points to arg\n  tPtr-\u0026gt;foo(); // Noncompliant: the pointers point to a dangling temporary\n}\n\u003c/pre\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eCommonly, the use of an out-of-scope local object is an indication of a defect in code, where the local object was used by mistake, and in such\ncase, replacing it with the desired variable or removing the use is sufficient. For other scenarios, two general approaches are possible:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Extending the scope of the referenced variable \u003c/li\u003e\n  \u003cli\u003e Capturing a copy of the object instead of a pointer to it \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWhenever possible, it is preferable to use or create a dedicated algorithm that encapsulates the uses of pointers to local objects.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;span\u0026gt;\n#include \u0026lt;optional\u0026gt;\nstd::optional\u0026lt;int\u0026gt; minimum(std::span\u0026lt;int const\u0026gt; s) {\n  if (s.empty()) {\n    return std::nullopt;\n  }\n  int const* min \u003d nullptr;\n  for (int i \u003d 0; i \u0026lt; s.size(); ++i) {\n    if ((min \u003d\u003d nullptr) || (*min \u0026lt; s[i]))\n      min \u003d \u0026amp;i;  // should be address of \u0026amp;s[i]\n  }\n  return *min; // Noncompliant: dangling\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eFixing the typo, and taking the address of \u003ccode\u003e\u0026amp;s[i]\u003c/code\u003e:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;span\u0026gt;\n#include \u0026lt;optional\u0026gt;\nstd::optional\u0026lt;int\u0026gt; minimum(std::span\u0026lt;int const\u0026gt; s) {\n  if (s.empty()) {\n    return std::nullopt;\n  }\n  int const* min \u003d nullptr;\n  for (int i \u003d 0; i \u0026lt; s.size(); ++i) {\n    if ((min \u003d\u003d nullptr) || (*min \u0026lt; s[i]))\n      min \u003d \u0026amp;s[i];\n  }\n  return *min; // Compliant, points to an element of s\n}\n\u003c/pre\u003e\n\u003cp\u003eStoring a copy instead of a pointer:\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;span\u0026gt;\n#include \u0026lt;optional\u0026gt;\nstd::optional\u0026lt;int\u0026gt; minimum(span\u0026lt;int const\u0026gt; s) {\n   std::optional\u0026lt;int\u0026gt; min;\n   for (int i \u003d 0; i \u0026lt; s.size(); ++i) {\n      if (min.has_value() || (*min \u0026lt; s[i]))\n        min \u003d s[i];\n   }\n   return min; // Compliant, copy of the minimum element\n}\n\u003c/pre\u003e\n\u003cp\u003eUsing a dedicated algorithm that avoids the need to store the pointer:\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;span\u0026gt;\n#include \u0026lt;optional\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\nstd::optional\u0026lt;int\u0026gt; minimum(std::span\u0026lt;int const\u0026gt; s) {\n  auto it \u003d std::min_element(s.begin(), s.end());\n  if (it \u003d\u003d s.end())\n    return std::nullopt;\n  return *it;\n}\n\u003c/pre\u003e\n\u003ch3\u003ePitfalls\u003c/h3\u003e\n\u003cp\u003eReducing the number of nested scopes is not always the right solution to fix the issue because, for the variables that represent resources (using\nRAII idiom), the scope of the variables plays an important role in the correctness of the program. As an illustration, let’s consider the following\nexample that uses \u003ccode\u003estd::unique_lock\u003c/code\u003e that represents a lock of a mutex:\u003c/p\u003e\n\u003cpre\u003e\nstd::mutex dataMutex;\nData data;\nvoid process() {\n  Element e;\n  { // scope A\n    std::unique_lock\u0026lt;std::mutex\u0026gt; l1(dataMutex); // mutex is locked in constructor\n    e \u003d data.fetch();\n  } // l1 destructor is called here, and the lock is unlocked\n  // do processing of the element\n  if (e.finished())\n    return;\n  { // scope B\n    std::unique_lock\u0026lt;std::mutex\u0026gt; l2(dataMutex); // mutex is locked in constructor\n    data.append(std::move(e));\n  } // l2 destructor is called here, and the mutex is unlocked\n}\n\u003c/pre\u003e\n\u003cp\u003eIn the above example, scopes \u003ccode\u003eA\u003c/code\u003e and \u003ccode\u003eB\u003c/code\u003e limit the number of operations performed in the critical section (when the mutex is\nacquired). Removing all nested scopes would lead to deadlock, where \u003ccode\u003el2\u003c/code\u003e will try to lock \u003ccode\u003edataMutex\u003c/code\u003e, already acquired in the\nsame thread by the constructor of \u003ccode\u003el1\u003c/code\u003e.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/lifetime\"\u003eLifetime\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/raii\"\u003eRAII\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/thread/unique_lock\"\u003eunique_lock\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eArticles \u0026amp; blog posts\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Abseil - \u003ca href\u003d\"https://abseil.io/tips/107\"\u003eTip of the Week #107: Reference Lifetime Extension\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S5553} detects uses of reclaimed temporary variables that are not lifetime-extended. \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S946} detects situation when address of reference to local variable is returned from function \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eAccessing local objects outside of their scope (for example, via a pointer taken inside the scope) has undefined behavior. This rule flags such\naccess for local variables and lifetime-extended temporaries.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eLocal variables in C++ are attached to the scope and destroyed when the end of the scope is reached. Any access to a variable outside of their\nscope has undefined behavior.\u003c/p\u003e\n\u003cp\u003eSuch access occurs, for example, when the address of a variable is stored in a pointer that is later dereferenced:\u003c/p\u003e\n\u003cpre\u003e\nint func() {\n  int* ptr \u003d nullptr;\n  {\n    int i \u003d 10;\n    ptr \u003d \u0026amp;i;\n  } // variable i goes out of scope here\n  *ptr \u003d 10; // Noncompliant: writing to out-of-scope-variable\n}\n\u003c/pre\u003e\n\u003cp\u003eA similar defect can occur in code that does not have curly braces (also referred to as a compound statement), but contain control structures, like\n\u003ccode\u003eif\u003c/code\u003e or \u003ccode\u003efor\u003c/code\u003e that also introduce scope:\u003c/p\u003e\n\u003cpre\u003e\nint exampleWithIf() {\n  int* ptr;\n  if (int i \u003d 10)\n    ptr \u003d \u0026amp;i;\n  else\n    ptr \u003d nullptr;\n  // variable i declared in if condition statement goes out of scope here\n  if (ptr)\n    return *ptr; // Noncompliant: reading from out-of-scope variable\n  return 0;\n}\nvoid exampleWithFor() {\n  int* ptr \u003d nullptr;\n  for (int i \u003d 0; i \u0026lt; 10; ++i)\n    ptr \u003d \u0026amp;i;\n  // variable i defined in for init-statement goes out of scope here\n  *ptr \u003d 10; // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eAccessing a dangling reference or pointer causes undefined behavior. This means the compiler is not bound by the language standard anymore and your\nprogram has no meaning assigned to it.\u003c/p\u003e\n\u003cp\u003ePractically this has a wide range of effects. In many cases, the access works by accident and succeeds at writing or reading a value. However, it\ncan start misbehaving at any time. If compilation flags, compiler, platform, or runtime environment change, the same code can crash the application,\ncorrupt memory, or leak a secret.\u003c/p\u003e\n\u003ch3\u003eWhy is the issue raised for reference variables?\u003c/h3\u003e\n\u003cp\u003eWhen a reference variable is directly initialized to a temporary object, such temporary is lifetime-extended by the variable, i.e., the temporary\nobject is destroyed when the variable goes out of scope. Lifetime-extended temporaries have the same behavior as if they were declared as local\nvariables and may lead to the same issues. For example:\u003c/p\u003e\n\u003cpre\u003e\nClazz create();\nvoid refExtension(Clazz const arg) {\n  Clazz const* aPtr;\n  Clazz const* tPtr;\n  {\n    Clazz const\u0026amp; aRef \u003d arg; // bounding reference to object arg\n    Clazz const\u0026amp; tRef \u003d create(); // temporary object is created here and bound to reference,\n                                  // behaves as Clazz const tRef \u003d create();\n    aPtr \u003d \u0026amp;aRef;  // points to arg\n    tPtr \u003d \u0026amp;tRef;  // point to a temporary object that is lifetime extended\n  } // both aRef and tRef go out of scope here, because tRef was extending the lifetime of\n    // temporary variable, the object is destroyed\n  aPtr-\u0026gt;foo(); // OK, a points to arg\n  tPtr-\u0026gt;foo(); // Noncompliant: the pointers point to a dangling temporary\n}\n\u003c/pre\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eCommonly, the use of an out-of-scope local object is an indication of a defect in code, where the local object was used by mistake, and in such\ncase, replacing it with the desired variable or removing the use is sufficient. For other scenarios, two general approaches are possible:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Extending the scope of the referenced variable \u003c/li\u003e\n  \u003cli\u003e Capturing a copy of the object instead of a pointer to it \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWhenever possible, it is preferable to use or create a dedicated algorithm that encapsulates the uses of pointers to local objects.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;span\u0026gt;\n#include \u0026lt;optional\u0026gt;\nstd::optional\u0026lt;int\u0026gt; minimum(std::span\u0026lt;int const\u0026gt; s) {\n  if (s.empty()) {\n    return std::nullopt;\n  }\n  int const* min \u003d nullptr;\n  for (int i \u003d 0; i \u0026lt; s.size(); ++i) {\n    if ((min \u003d\u003d nullptr) || (*min \u0026lt; s[i]))\n      min \u003d \u0026amp;i;  // should be address of \u0026amp;s[i]\n  }\n  return *min; // Noncompliant: dangling\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eFixing the typo, and taking the address of \u003ccode\u003e\u0026amp;s[i]\u003c/code\u003e:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;span\u0026gt;\n#include \u0026lt;optional\u0026gt;\nstd::optional\u0026lt;int\u0026gt; minimum(std::span\u0026lt;int const\u0026gt; s) {\n  if (s.empty()) {\n    return std::nullopt;\n  }\n  int const* min \u003d nullptr;\n  for (int i \u003d 0; i \u0026lt; s.size(); ++i) {\n    if ((min \u003d\u003d nullptr) || (*min \u0026lt; s[i]))\n      min \u003d \u0026amp;s[i];\n  }\n  return *min; // Compliant, points to an element of s\n}\n\u003c/pre\u003e\n\u003cp\u003eStoring a copy instead of a pointer:\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;span\u0026gt;\n#include \u0026lt;optional\u0026gt;\nstd::optional\u0026lt;int\u0026gt; minimum(span\u0026lt;int const\u0026gt; s) {\n   std::optional\u0026lt;int\u0026gt; min;\n   for (int i \u003d 0; i \u0026lt; s.size(); ++i) {\n      if (min.has_value() || (*min \u0026lt; s[i]))\n        min \u003d s[i];\n   }\n   return min; // Compliant, copy of the minimum element\n}\n\u003c/pre\u003e\n\u003cp\u003eUsing a dedicated algorithm that avoids the need to store the pointer:\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;span\u0026gt;\n#include \u0026lt;optional\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\nstd::optional\u0026lt;int\u0026gt; minimum(std::span\u0026lt;int const\u0026gt; s) {\n  auto it \u003d std::min_element(s.begin(), s.end());\n  if (it \u003d\u003d s.end())\n    return std::nullopt;\n  return *it;\n}\n\u003c/pre\u003e\n\u003ch3\u003ePitfalls\u003c/h3\u003e\n\u003cp\u003eReducing the number of nested scopes is not always the right solution to fix the issue because, for the variables that represent resources (using\nRAII idiom), the scope of the variables plays an important role in the correctness of the program. As an illustration, let’s consider the following\nexample that uses \u003ccode\u003estd::unique_lock\u003c/code\u003e that represents a lock of a mutex:\u003c/p\u003e\n\u003cpre\u003e\nstd::mutex dataMutex;\nData data;\nvoid process() {\n  Element e;\n  { // scope A\n    std::unique_lock\u0026lt;std::mutex\u0026gt; l1(dataMutex); // mutex is locked in constructor\n    e \u003d data.fetch();\n  } // l1 destructor is called here, and the lock is unlocked\n  // do processing of the element\n  if (e.finished())\n    return;\n  { // scope B\n    std::unique_lock\u0026lt;std::mutex\u0026gt; l2(dataMutex); // mutex is locked in constructor\n    data.append(std::move(e));\n  } // l2 destructor is called here, and the mutex is unlocked\n}\n\u003c/pre\u003e\n\u003cp\u003eIn the above example, scopes \u003ccode\u003eA\u003c/code\u003e and \u003ccode\u003eB\u003c/code\u003e limit the number of operations performed in the critical section (when the mutex is\nacquired). Removing all nested scopes would lead to deadlock, where \u003ccode\u003el2\u003c/code\u003e will try to lock \u003ccode\u003edataMutex\u003c/code\u003e, already acquired in the\nsame thread by the constructor of \u003ccode\u003el1\u003c/code\u003e.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/lifetime\"\u003eLifetime\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/raii\"\u003eRAII\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/thread/unique_lock\"\u003eunique_lock\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eArticles \u0026amp; blog posts\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Abseil - \u003ca href\u003d\"https://abseil.io/tips/107\"\u003eTip of the Week #107: Reference Lifetime Extension\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S5553} detects uses of reclaimed temporary variables that are not lifetime-extended. \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S946} detects situation when address of reference to local variable is returned from function \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "symbolic-execution"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5443",
    "name": "Using publicly writable directories is security-sensitive",
    "defaultSeverity": "CRITICAL",
    "type": "SECURITY_HOTSPOT",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "SECURITY": "HIGH"
    },
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eOperating systems have global directories where any user has write access. Those folders are mostly used as temporary storage areas like\n\u003ccode\u003e/tmp\u003c/code\u003e in Linux based systems. An application manipulating files from these folders is exposed to race conditions on filenames: a malicious\nuser can try to create a file with a predictable name before the application does. A successful attack can result in other files being accessed,\nmodified, corrupted or deleted. This risk is even higher if the application runs with elevated permissions.\u003c/p\u003e\n\u003cp\u003eIn the past, it has led to the following vulnerabilities:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://nvd.nist.gov/vuln/detail/CVE-2012-2451\"\u003eCVE-2012-2451\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://nvd.nist.gov/vuln/detail/CVE-2015-1838\"\u003eCVE-2015-1838\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis rule raises an issue whenever it detects a hard-coded path to a publicly writable directory like \u003ccode\u003e/tmp\u003c/code\u003e (see examples bellow). It\nalso detects access to environment variables that point to publicly writable directories, e.g., \u003ccode\u003eTMP\u003c/code\u003e and \u003ccode\u003eTMPDIR\u003c/code\u003e.\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003e/tmp\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003e/var/tmp\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003e/usr/tmp\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003e/dev/shm\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003e/dev/mqueue\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003e/run/lock\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003e/var/run/lock\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003e/Library/Caches\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003e/Users/Shared\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003e/private/tmp\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003e/private/var/tmp\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003e\\Windows\\Temp\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003e\\Temp\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003e\\TMP\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      },
      {
        "key": "assess_the_problem",
        "htmlContent": "\u003ch2\u003eAsk Yourself Whether\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e Files are read from or written into a publicly writable folder \u003c/li\u003e\n  \u003cli\u003e The application creates files with predictable names into a publicly writable folder \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere is a risk if you answered yes to any of those questions.\u003c/p\u003e\n\u003ch2\u003eSensitive Code Example\u003c/h2\u003e\n\u003cpre\u003e\n#include \u0026lt;cstdio\u0026gt;\n// ...\n\nvoid f() {\n  FILE * fp \u003d fopen(\"/tmp/temporary_file\", \"r\"); // Sensitive\n}\n\u003c/pre\u003e\n\u003cpre\u003e\n#include \u0026lt;cstdio\u0026gt;\n#include \u0026lt;cstdlib\u0026gt;\n#include \u0026lt;sstream\u0026gt;\n// ...\n\nvoid f() {\n  std::stringstream ss;\n  ss \u0026lt;\u0026lt; getenv(\"TMPDIR\") \u0026lt;\u0026lt; \"/temporary_file\"; // Sensitive\n  FILE * fp \u003d fopen(ss.str().c_str(), \"w\");\n}\n\u003c/pre\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003ch2\u003eRecommended Secure Coding Practices\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e Use a dedicated sub-folder with tightly controlled permissions \u003c/li\u003e\n  \u003cli\u003e Use secure-by-design APIs to create temporary files. Such API will make sure:\n    \u003cul\u003e\n      \u003cli\u003e The generated filename is unpredictable \u003c/li\u003e\n      \u003cli\u003e The file is readable and writable only by the creating user ID \u003c/li\u003e\n      \u003cli\u003e The file descriptor is not inherited by child processes \u003c/li\u003e\n      \u003cli\u003e The file will be destroyed as soon as it is closed \u003c/li\u003e\n    \u003c/ul\u003e  \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eCompliant Solution\u003c/h2\u003e\n\u003cpre\u003e\n#include \u0026lt;cstdio\u0026gt;\n#include \u0026lt;cstdlib\u0026gt;\n// ...\n\nvoid f() {\n  FILE * fp \u003d tmpfile(); // Compliant\n}\n\u003c/pre\u003e\n\u003ch2\u003eSee\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/Top10/A01_2021-Broken_Access_Control/\"\u003eOWASP Top 10 2021 Category A1\u003c/a\u003e - Broken Access Control \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control\"\u003eOWASP Top 10 2017 Category A5\u003c/a\u003e - Broken Access Control\n  \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://www.owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\"\u003eOWASP Top 10 2017 Category A3\u003c/a\u003e - Sensitive Data\n  Exposure \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/377\"\u003eMITRE, CWE-377\u003c/a\u003e - Insecure Temporary File \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/379\"\u003eMITRE, CWE-379\u003c/a\u003e - Creation of Temporary File in Directory with Incorrect Permissions\n  \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/www-community/vulnerabilities/Insecure_Temporary_File\"\u003eOWASP, Insecure Temporary File\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cwe",
      "symbolic-execution"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": [],
    "vulnerabilityProbability": "LOW"
  },
  {
    "key": "cpp:S5205",
    "name": "Function pointers should not be used as function parameters",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhen you want to define a function that can accept a function pointer as an argument, there are three ways in C++ to declare the parameter\ntype:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e A function pointer: \u003ccode\u003evoid f(void (*callback)());\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e A \u003ccode\u003estd::function\u003c/code\u003e: \u003ccode\u003evoid f(std::function\u0026lt;void()\u0026gt; callback);\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e A template argument: \u003ccode\u003etemplate\u0026lt;class Callback\u0026gt; void f(Callback callback);\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eUsing a function pointer is an inferior solution, for the following reasons:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Only a function pointer can be passed as an argument, while the other options offer the caller more flexibility because they can take more\n  advanced functors, such as lambdas with some captured state \u003c/li\u003e\n  \u003cli\u003e The syntax is obscure \u003c/li\u003e\n  \u003cli\u003e It typically has worse performance than the template parameter solution. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSee {rule:cpp:S5213} for a discussion of how to choose between \u003ccode\u003estd::function\u003c/code\u003e and a template parameter.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nusing Criterion \u003d bool (*)(DataPoint const\u0026amp;);\nvoid filter(DataSet* data, Criterion criterion); // Noncompliant\n\nusing Callback \u003d void (*)(EventInfo const\u0026amp;);\nclass Button {\npublic:\n    void addOnClick(Callback c) {myOnClickHandler \u003d c;} // Noncompliant\nprivate:\n    Callback myOnClickHandler;\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\ntemplate\u0026lt;class Criterion\u0026gt;\nvoid filter(DataSet* data, Criterion criterion); // Compliant, uses the more efficient template argument\n\nusing Callback \u003d std::function\u0026lt;void(EventInfo const\u0026amp;)\u0026gt;;\nclass Button {\npublic:\n    void addOnClick(Callback c) {myOnClickHandler \u003d c;} // Compliant, uses the more flexible std::function\nprivate:\n    Callback myOnClickHandler;\n};\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#t40-use-function-objects-to-pass-operations-to-algorithms\"\u003eT.40:\n  Use function objects to pass operations to algorithms\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhen you want to define a function that can accept a function pointer as an argument, there are three ways in C++ to declare the parameter\ntype:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e A function pointer: \u003ccode\u003evoid f(void (*callback)());\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e A \u003ccode\u003estd::function\u003c/code\u003e: \u003ccode\u003evoid f(std::function\u0026lt;void()\u0026gt; callback);\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e A template argument: \u003ccode\u003etemplate\u0026lt;class Callback\u0026gt; void f(Callback callback);\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eUsing a function pointer is an inferior solution, for the following reasons:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Only a function pointer can be passed as an argument, while the other options offer the caller more flexibility because they can take more\n  advanced functors, such as lambdas with some captured state \u003c/li\u003e\n  \u003cli\u003e The syntax is obscure \u003c/li\u003e\n  \u003cli\u003e It typically has worse performance than the template parameter solution. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSee {rule:cpp:S5213} for a discussion of how to choose between \u003ccode\u003estd::function\u003c/code\u003e and a template parameter.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nusing Criterion \u003d bool (*)(DataPoint const\u0026amp;);\nvoid filter(DataSet* data, Criterion criterion); // Noncompliant\n\nusing Callback \u003d void (*)(EventInfo const\u0026amp;);\nclass Button {\npublic:\n    void addOnClick(Callback c) {myOnClickHandler \u003d c;} // Noncompliant\nprivate:\n    Callback myOnClickHandler;\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\ntemplate\u0026lt;class Criterion\u0026gt;\nvoid filter(DataSet* data, Criterion criterion); // Compliant, uses the more efficient template argument\n\nusing Callback \u003d std::function\u0026lt;void(EventInfo const\u0026amp;)\u0026gt;;\nclass Button {\npublic:\n    void addOnClick(Callback c) {myOnClickHandler \u003d c;} // Compliant, uses the more flexible std::function\nprivate:\n    Callback myOnClickHandler;\n};\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#t40-use-function-objects-to-pass-operations-to-algorithms\"\u003eT.40:\n  Use function objects to pass operations to algorithms\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "clumsy",
      "cppcoreguidelines"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S3490",
    "name": "Special member function should not be defined unless a non standard behavior is required",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eAll special member functions (default constructor, copy and move constructors, copy and move assignment operators, destructor) can be automatically\ngenerated by the compiler if you don’t prevent it (for many classes, it is good practice to organize your code so that you can use these default\nversions, see {rule:cpp:S4963}).\u003c/p\u003e\n\u003cp\u003eThere are cases where it’s still useful to manually write such a function, because the default implementation is not doing what you need. But if\nthe manually written function is equivalent to the default implementation, this is an issue:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e It’s more code to write, test and maintain for no good reason \u003c/li\u003e\n  \u003cli\u003e Writing the code of those functions correctly is surprisingly difficult \u003c/li\u003e\n  \u003cli\u003e Once you write one such function, you will typically have to write several (see {rule:cpp:S3624}) \u003c/li\u003e\n  \u003cli\u003e If you want your class to be \u003cem\u003etrivial\u003c/em\u003e or to be an \u003cem\u003eaggregate\u003c/em\u003e, those functions cannot be user-provided anyways \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn most cases, you should just remove the code of the redundant function. In some cases, the compiler will not automatically generate the default\nversion of the function, but you can force it to do so by using the \u003ccode\u003e\u003d default\u003c/code\u003e syntax.\u003c/p\u003e\n\u003cp\u003eFor default constructors, you will often be able to use the default version if you use in-class initialization instead of the initializer list (see\nS5424). You will have to make it explicitly defaulted if your class has any other constructor.\u003c/p\u003e\n\u003cp\u003eFor destructors, you may want to use the \u003ccode\u003e\u003ddefault\u003c/code\u003e syntax to be able to declare it as virtual (see {rule:cpp:S1235}).\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when any of the following is implemented in a way equivalent to the default implementation:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e default constructor \u003c/li\u003e\n  \u003cli\u003e destructor \u003c/li\u003e\n  \u003cli\u003e move constructor \u003c/li\u003e\n  \u003cli\u003e move-assignment operator \u003c/li\u003e\n  \u003cli\u003e copy constructor \u003c/li\u003e\n  \u003cli\u003e copy-assignment operator \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstruct Book {\n  string Name;\n\n  Book() { } // Noncompliant\n  Book(const Book \u0026amp;Other) : Name(Other.Name) { } // Noncompliant\n  Book \u0026amp;operator\u003d(const Book \u0026amp;);\n};\n\nBook \u0026amp;Book::operator\u003d(const Book \u0026amp;Other) { // Noncompliant\n  Name \u003d Other.Name;\n  return *this;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstruct Book {\n  string Name;\n\n  Book() \u003d default; // Restores generation of default\n  Book(const Book \u0026amp;Other) \u003d default;\n  Book \u0026amp;operator\u003d(const Book \u0026amp;) \u003d default;\n};\n\n// Or, more common:\nstruct Book {\n  string Name;\n};\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c30-define-a-destructor-if-a-class-needs-an-explicit-action-at-object-destruction\"\u003eC.30: Define a destructor if a class needs an explicit action at object destruction\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eAll special member functions (default constructor, copy and move constructors, copy and move assignment operators, destructor) can be automatically\ngenerated by the compiler if you don’t prevent it (for many classes, it is good practice to organize your code so that you can use these default\nversions, see {rule:cpp:S4963}).\u003c/p\u003e\n\u003cp\u003eThere are cases where it’s still useful to manually write such a function, because the default implementation is not doing what you need. But if\nthe manually written function is equivalent to the default implementation, this is an issue:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e It’s more code to write, test and maintain for no good reason \u003c/li\u003e\n  \u003cli\u003e Writing the code of those functions correctly is surprisingly difficult \u003c/li\u003e\n  \u003cli\u003e Once you write one such function, you will typically have to write several (see {rule:cpp:S3624}) \u003c/li\u003e\n  \u003cli\u003e If you want your class to be \u003cem\u003etrivial\u003c/em\u003e or to be an \u003cem\u003eaggregate\u003c/em\u003e, those functions cannot be user-provided anyways \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn most cases, you should just remove the code of the redundant function. In some cases, the compiler will not automatically generate the default\nversion of the function, but you can force it to do so by using the \u003ccode\u003e\u003d default\u003c/code\u003e syntax.\u003c/p\u003e\n\u003cp\u003eFor default constructors, you will often be able to use the default version if you use in-class initialization instead of the initializer list (see\nS5424). You will have to make it explicitly defaulted if your class has any other constructor.\u003c/p\u003e\n\u003cp\u003eFor destructors, you may want to use the \u003ccode\u003e\u003ddefault\u003c/code\u003e syntax to be able to declare it as virtual (see {rule:cpp:S1235}).\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when any of the following is implemented in a way equivalent to the default implementation:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e default constructor \u003c/li\u003e\n  \u003cli\u003e destructor \u003c/li\u003e\n  \u003cli\u003e move constructor \u003c/li\u003e\n  \u003cli\u003e move-assignment operator \u003c/li\u003e\n  \u003cli\u003e copy constructor \u003c/li\u003e\n  \u003cli\u003e copy-assignment operator \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstruct Book {\n  string Name;\n\n  Book() { } // Noncompliant\n  Book(const Book \u0026amp;Other) : Name(Other.Name) { } // Noncompliant\n  Book \u0026amp;operator\u003d(const Book \u0026amp;);\n};\n\nBook \u0026amp;Book::operator\u003d(const Book \u0026amp;Other) { // Noncompliant\n  Name \u003d Other.Name;\n  return *this;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstruct Book {\n  string Name;\n\n  Book() \u003d default; // Restores generation of default\n  Book(const Book \u0026amp;Other) \u003d default;\n  Book \u0026amp;operator\u003d(const Book \u0026amp;) \u003d default;\n};\n\n// Or, more common:\nstruct Book {\n  string Name;\n};\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c30-define-a-destructor-if-a-class-needs-an-explicit-action-at-object-destruction\"\u003eC.30: Define a destructor if a class needs an explicit action at object destruction\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "clumsy",
      "cppcoreguidelines",
      "performance",
      "since-c++11"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S3491",
    "name": "Redundant pointer operator sequences should be removed",
    "defaultSeverity": "BLOCKER",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eBy contract, chaining the \u0027Address of\u0027 operator \u003ccode\u003e\u0026amp;\u003c/code\u003e with the \u0027Indirection\u0027 operator \u003ccode\u003e*\u003c/code\u003e results in a return to the\ninitial value. Thus, such combinations are confusing at best, and bugs at worst.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint *ptr \u003d ...;\nint *result1 \u003d \u0026amp;(*ptr); //Noncompliant\nint *result2 \u003d \u0026amp;*ptr; //Noncompliant\n\nint value \u003d 4;\nint result3 \u003d *(\u0026amp;value); //Noncompliant\nint result4 \u003d *\u0026amp;value; //Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint *ptr \u003d ...;\nint *result1 \u003d ptr;\nint *result2 \u003d ptr;\n\nint value \u003d 4;\nint result3 \u003d value;\nint result4 \u003d value;\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eNo issue is raised when the \u003ccode\u003e*\u003c/code\u003e or \u003ccode\u003e\u0026amp;\u003c/code\u003e operators are overloaded or when both operators are not located in the same piece\nof code (one being generated by a macro expansion and the other one located in the main source code for instance).\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eBy contract, chaining the \u0027Address of\u0027 operator \u003ccode\u003e\u0026amp;\u003c/code\u003e with the \u0027Indirection\u0027 operator \u003ccode\u003e*\u003c/code\u003e results in a return to the\ninitial value. Thus, such combinations are confusing at best, and bugs at worst.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint *ptr \u003d ...;\nint *result1 \u003d \u0026amp;(*ptr); //Noncompliant\nint *result2 \u003d \u0026amp;*ptr; //Noncompliant\n\nint value \u003d 4;\nint result3 \u003d *(\u0026amp;value); //Noncompliant\nint result4 \u003d *\u0026amp;value; //Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint *ptr \u003d ...;\nint *result1 \u003d ptr;\nint *result2 \u003d ptr;\n\nint value \u003d 4;\nint result3 \u003d value;\nint result4 \u003d value;\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eNo issue is raised when the \u003ccode\u003e*\u003c/code\u003e or \u003ccode\u003e\u0026amp;\u003c/code\u003e operators are overloaded or when both operators are not located in the same piece\nof code (one being generated by a macro expansion and the other one located in the main source code for instance).\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S3252",
    "name": "\"static\" base class members should not be accessed via derived types",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eIn object-oriented programming, inappropriately accessing static members of a base class via derived types is considered a code smell.\u003c/p\u003e\n\u003cp\u003eStatic members are associated with the class itself, not with any specific instance of the class or its children classes. Accessing through the\nwrong type suggests a misunderstanding of the ownership and role of this member. This can make the maintenance of the code more complicated.\u003c/p\u003e\n\u003cp\u003eTherefore, the access should be done directly through the base class to maintain clarity and avoid potential misunderstandings.\u003c/p\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThis rule doesn’t raise an issue for constants. If the variable is \u003ccode\u003econst\u003c/code\u003e, there is no risk of confusion.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nclass Parent {\npublic:\n  static int count;\n};\n\nclass Child : public Parent {\npublic:\n  Child() {\n    Child::count++;  // Noncompliant\n  }\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nclass Parent {\npublic:\n  static int count;\n};\n\nclass Child : public Parent {\npublic:\n  Child() {\n    Parent::count++;\n  }\n};\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eIn object-oriented programming, inappropriately accessing static members of a base class via derived types is considered a code smell.\u003c/p\u003e\n\u003cp\u003eStatic members are associated with the class itself, not with any specific instance of the class or its children classes. Accessing through the\nwrong type suggests a misunderstanding of the ownership and role of this member. This can make the maintenance of the code more complicated.\u003c/p\u003e\n\u003cp\u003eTherefore, the access should be done directly through the base class to maintain clarity and avoid potential misunderstandings.\u003c/p\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThis rule doesn’t raise an issue for constants. If the variable is \u003ccode\u003econst\u003c/code\u003e, there is no risk of confusion.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nclass Parent {\npublic:\n  static int count;\n};\n\nclass Child : public Parent {\npublic:\n  Child() {\n    Child::count++;  // Noncompliant\n  }\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nclass Parent {\npublic:\n  static int count;\n};\n\nclass Child : public Parent {\npublic:\n  Child() {\n    Parent::count++;\n  }\n};\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "confusing"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5318",
    "name": "using-directives and using-declarations (excluding class scope or function scope using-declarations) shall not be used in header files",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "MODULAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThis rule is a strict implementation of a MISRA (Motor Industry Software Reliability Association) rule. MISRA defines best practices for developing\nsafety-critical software. You can learn more about this rule in the MISRA documents referenced below.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++2008, 7-3-6 \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThis rule is a strict implementation of a MISRA (Motor Industry Software Reliability Association) rule. MISRA defines best practices for developing\nsafety-critical software. You can learn more about this rule in the MISRA documents referenced below.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C++2008, 7-3-6 \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "misra-c++2008"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5319",
    "name": "The identifiers used for the parameters in a re-declaration or override of a function shall be identical to those in the declaration",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThis rule is a strict implementation of a MISRA (Motor Industry Software Reliability Association) rule. MISRA defines best practices for developing\nsafety-critical software. You can learn more about this rule in the MISRA documents referenced below.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++ 2008, 8-4-2: The identifiers used for the parameters in a re-declaration or override of a function shall be identical to those in the\n  declaration. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThis rule is a strict implementation of a MISRA (Motor Industry Software Reliability Association) rule. MISRA defines best practices for developing\nsafety-critical software. You can learn more about this rule in the MISRA documents referenced below.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C++ 2008, 8-4-2: The identifiers used for the parameters in a re-declaration or override of a function shall be identical to those in the\n  declaration. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "misra-c++2008"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5312",
    "name": "If loop-counter is not modified by -- or ++, then, within condition, the loop-counter shall only be used as an operand to \u003c\u003d, \u003c, \u003e or \u003e\u003d",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThis rule is a strict implementation of a MISRA (Motor Industry Software Reliability Association) rule. MISRA defines best practices for developing\nsafety-critical software. You can learn more about this rule in the MISRA documents referenced below.\u003c/p\u003e\n\u003cp\u003eIf you are not concerned with MISRA compliance or with safety-critical software, you might consider using rule S888 instead ; it targets\nthe same kind of issue for general-purpose software.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++2008, 6-5-2 \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThis rule is a strict implementation of a MISRA (Motor Industry Software Reliability Association) rule. MISRA defines best practices for developing\nsafety-critical software. You can learn more about this rule in the MISRA documents referenced below.\u003c/p\u003e\n\u003cp\u003eIf you are not concerned with MISRA compliance or with safety-critical software, you might consider using rule S888 instead ; it targets\nthe same kind of issue for general-purpose software.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C++2008, 6-5-2 \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "misra-c++2008"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5313",
    "name": "The loop-counter shall not be modified within condition or statement",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThis rule is a strict implementation of a MISRA (Motor Industry Software Reliability Association) rule. MISRA defines best practices for developing\nsafety-critical software. You can learn more about this rule in the MISRA documents referenced below.\u003c/p\u003e\n\u003cp\u003eIf you are not concerned with MISRA compliance or with safety-critical software, you might consider using rule {rule:cpp:S127} instead ; it targets\nthe same kind of issue for general-purpose software.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++2008, 6-5-3 \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThis rule is a strict implementation of a MISRA (Motor Industry Software Reliability Association) rule. MISRA defines best practices for developing\nsafety-critical software. You can learn more about this rule in the MISRA documents referenced below.\u003c/p\u003e\n\u003cp\u003eIf you are not concerned with MISRA compliance or with safety-critical software, you might consider using rule {rule:cpp:S127} instead ; it targets\nthe same kind of issue for general-purpose software.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C++2008, 6-5-3 \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "misra-c++2008"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S3135",
    "name": "\"sizeof\" should not be called on pointers",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003esizeof\u003c/code\u003e returns the size in bytes of a type. One common usage pattern, especially in C, is to use \u003ccode\u003esizeof\u003c/code\u003e to determine the\nsize of an array. However, arrays decay to pointers when passed as arguments to a function, and if \u003ccode\u003esizeof\u003c/code\u003e is applied to such an argument,\nit will return the size of the pointer, not of the array. A similar issue happens when the array is used in an arithmetic operation.\u003c/p\u003e\n\u003cp\u003eThis rule raises issues when:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003esizeof\u003c/code\u003e is used to compute the array size of a pointer passed as a function argument. \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003esizeof\u003c/code\u003e is called on the result of an arithmetic operation involving an array. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eNote: C++17 provides a \u003ccode\u003estd::size\u003c/code\u003e function that will correctly compute the number of elements of an array and fail to compile if\nprovided with a pointer. It is simpler and safer to use this variant when available. C++20 also provides the functions \u003ccode\u003estd::ssize\u003c/code\u003e,\n\u003ccode\u003estd::ranges::size\u003c/code\u003e, and \u003ccode\u003estd::ranges::ssize\u003c/code\u003e with similar effects.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid fun(int *data, int array[10]) {\n  size_t const dataSize \u003d sizeof data / sizeof(int); // Noncompliant, type of data is int *\n  size_t const arraySize \u003d sizeof array / sizeof(int); // Noncompliant, type of array is int * too\n  int primes[] \u003d { 1, 2, 3, 5, 7, 13, 17, 19};\n  size_t const primesSize2 \u003d sizeof(primes + 1) / sizeof(int); // Noncompliant, type of primes + 1 is int *\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n// Computing dataSize is now the responsibility of the caller\nvoid fun(int *data, int dataSize, int (\u0026amp;array)[10]) {\n  size_t const arraySize \u003d sizeof array / sizeof(int); // Compliant, no decay\n  int primes[] \u003d { 1, 2, 3, 5, 7, 13, 17, 19};\n  size_t const primesSize \u003d std::size(primes); // Better variant in C++17\n  size_t const primesSize2 \u003d sizeof primes / sizeof(int) + 1; // Compliant, type of primes is int[8]\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/CdYxBQ\"\u003eCERT, ARR01-C.\u003c/a\u003e - Do not apply the \u003ccode\u003esizeof\u003c/code\u003e operator to a pointer when\n  taking the size of an array \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/467\"\u003eMITRE, CWE-467\u003c/a\u003e - Use of sizeof() on a Pointer Type \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003ccode\u003esizeof\u003c/code\u003e returns the size in bytes of a type. One common usage pattern, especially in C, is to use \u003ccode\u003esizeof\u003c/code\u003e to determine the\nsize of an array. However, arrays decay to pointers when passed as arguments to a function, and if \u003ccode\u003esizeof\u003c/code\u003e is applied to such an argument,\nit will return the size of the pointer, not of the array. A similar issue happens when the array is used in an arithmetic operation.\u003c/p\u003e\n\u003cp\u003eThis rule raises issues when:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003esizeof\u003c/code\u003e is used to compute the array size of a pointer passed as a function argument. \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003esizeof\u003c/code\u003e is called on the result of an arithmetic operation involving an array. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eNote: C++17 provides a \u003ccode\u003estd::size\u003c/code\u003e function that will correctly compute the number of elements of an array and fail to compile if\nprovided with a pointer. It is simpler and safer to use this variant when available. C++20 also provides the functions \u003ccode\u003estd::ssize\u003c/code\u003e,\n\u003ccode\u003estd::ranges::size\u003c/code\u003e, and \u003ccode\u003estd::ranges::ssize\u003c/code\u003e with similar effects.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid fun(int *data, int array[10]) {\n  size_t const dataSize \u003d sizeof data / sizeof(int); // Noncompliant, type of data is int *\n  size_t const arraySize \u003d sizeof array / sizeof(int); // Noncompliant, type of array is int * too\n  int primes[] \u003d { 1, 2, 3, 5, 7, 13, 17, 19};\n  size_t const primesSize2 \u003d sizeof(primes + 1) / sizeof(int); // Noncompliant, type of primes + 1 is int *\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n// Computing dataSize is now the responsibility of the caller\nvoid fun(int *data, int dataSize, int (\u0026amp;array)[10]) {\n  size_t const arraySize \u003d sizeof array / sizeof(int); // Compliant, no decay\n  int primes[] \u003d { 1, 2, 3, 5, 7, 13, 17, 19};\n  size_t const primesSize \u003d std::size(primes); // Better variant in C++17\n  size_t const primesSize2 \u003d sizeof primes / sizeof(int) + 1; // Compliant, type of primes is int[8]\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/CdYxBQ\"\u003eCERT, ARR01-C.\u003c/a\u003e - Do not apply the \u003ccode\u003esizeof\u003c/code\u003e operator to a pointer when\n  taking the size of an array \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/467\"\u003eMITRE, CWE-467\u003c/a\u003e - Use of sizeof() on a Pointer Type \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cert",
      "cwe"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1199",
    "name": "Nested code blocks should not be used",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eNested code blocks create new scopes where variables declared within are inaccessible from the outside, and their lifespan ends with the block.\u003c/p\u003e\n\u003cp\u003eAlthough this may appear beneficial, their usage within a function often suggests that the function is overloaded. Thus, it may violate the Single\nResponsibility Principle, and the function needs to be broken down into smaller functions.\u003c/p\u003e\n\u003cp\u003eThe presence of nested blocks that don’t affect the control flow might suggest possible mistakes in the code.\u003c/p\u003e\n\u003cp\u003eHowever, nested code blocks are acceptable when they encapsulate all statements within a \u003ccode\u003eswitch\u003c/code\u003e (a \u003ccode\u003ecase xxx:\u003c/code\u003e or a\n\u003ccode\u003edefault:\u003c/code\u003e) to prevent variable declarations from interfering with other \u003ccode\u003ecases\u003c/code\u003e.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eThe nested code blocks should be extracted into separate methods.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid f(Cache \u0026amp;c, int data) {\n  int value;\n  { // Noncompliant\n    std::scoped_lock l(c.getMutex());\n    if (c.hasKey(data)) {\n      value \u003d c.get(data);\n    } else {\n      value \u003d compute(data);\n      c.set(data, value);\n    }\n  } // Releases the mutex\n\n  switch(value) {\n    case 1:\n    { // Noncompliant, some statements are outside of the block\n       int result \u003d compute(value);\n       save(result);\n    }\n    log();\n    break;\n    case 2:\n    // ...\n  }\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nint getValue(Cache \u0026amp;c, int data) {\n  std::scoped_lock l(c.getMutex());\n  if (c.hasKey(data)) {\n    return c.get(data);\n  } else {\n    value \u003d compute(data);\n    c.set(data, value);\n    return value;\n  }\n}\n\nvoid f(Cache \u0026amp;c, int data) {\n  int value \u003d getValue(c, data);\n\n  switch(value) {\n    case 1:\n    { // Compliant, limits the scope of \"result\"\n       int result \u003d compute(value);\n       save(result);\n       log();\n    }\n    break;\n    case 2:\n    // ...\n  }\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Wikipedia - \u003ca href\u003d\"https://en.wikipedia.org/wiki/Single-responsibility_principle\"\u003eSingle Responsibility Principle\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eNested code blocks create new scopes where variables declared within are inaccessible from the outside, and their lifespan ends with the block.\u003c/p\u003e\n\u003cp\u003eAlthough this may appear beneficial, their usage within a function often suggests that the function is overloaded. Thus, it may violate the Single\nResponsibility Principle, and the function needs to be broken down into smaller functions.\u003c/p\u003e\n\u003cp\u003eThe presence of nested blocks that don’t affect the control flow might suggest possible mistakes in the code.\u003c/p\u003e\n\u003cp\u003eHowever, nested code blocks are acceptable when they encapsulate all statements within a \u003ccode\u003eswitch\u003c/code\u003e (a \u003ccode\u003ecase xxx:\u003c/code\u003e or a\n\u003ccode\u003edefault:\u003c/code\u003e) to prevent variable declarations from interfering with other \u003ccode\u003ecases\u003c/code\u003e.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eThe nested code blocks should be extracted into separate methods.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid f(Cache \u0026amp;c, int data) {\n  int value;\n  { // Noncompliant\n    std::scoped_lock l(c.getMutex());\n    if (c.hasKey(data)) {\n      value \u003d c.get(data);\n    } else {\n      value \u003d compute(data);\n      c.set(data, value);\n    }\n  } // Releases the mutex\n\n  switch(value) {\n    case 1:\n    { // Noncompliant, some statements are outside of the block\n       int result \u003d compute(value);\n       save(result);\n    }\n    log();\n    break;\n    case 2:\n    // ...\n  }\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nint getValue(Cache \u0026amp;c, int data) {\n  std::scoped_lock l(c.getMutex());\n  if (c.hasKey(data)) {\n    return c.get(data);\n  } else {\n    value \u003d compute(data);\n    c.set(data, value);\n    return value;\n  }\n}\n\nvoid f(Cache \u0026amp;c, int data) {\n  int value \u003d getValue(c, data);\n\n  switch(value) {\n    case 1:\n    { // Compliant, limits the scope of \"result\"\n       int result \u003d compute(value);\n       save(result);\n       log();\n    }\n    break;\n    case 2:\n    // ...\n  }\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Wikipedia - \u003ca href\u003d\"https://en.wikipedia.org/wiki/Single-responsibility_principle\"\u003eSingle Responsibility Principle\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "bad-practice"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5311",
    "name": "A for loop shall contain a single loop-counter which shall not have floating type",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThis rule is a strict implementation of a MISRA (Motor Industry Software Reliability Association) rule. MISRA defines best practices for developing\nsafety-critical software. You can learn more about this rule in the MISRA documents referenced below.\u003c/p\u003e\n\u003cp\u003eIf you are not concerned with MISRA compliance or with safety-critical software, you might consider using rule {rule:cpp:S2193} instead ; it\ntargets the same kind of issue for general-purpose software.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++ 2008, 6-5-1 - A for loop shall contain a single loop-counter which shall not have floating type. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThis rule is a strict implementation of a MISRA (Motor Industry Software Reliability Association) rule. MISRA defines best practices for developing\nsafety-critical software. You can learn more about this rule in the MISRA documents referenced below.\u003c/p\u003e\n\u003cp\u003eIf you are not concerned with MISRA compliance or with safety-critical software, you might consider using rule {rule:cpp:S2193} instead ; it\ntargets the same kind of issue for general-purpose software.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C++ 2008, 6-5-1 - A for loop shall contain a single loop-counter which shall not have floating type. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "misra-c++2008"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5553",
    "name": "Immediately dangling references and pointers should not be created",
    "defaultSeverity": "BLOCKER",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003cp\u003eReferences and pointers to temporary objects become dangling after these objects are destroyed. Barring lifetime extension, this happens at the end\nof a full expression.\u003c/p\u003e\n\u003cp\u003eLifetime extension allows even after the end of a full expression the use of the temporaries that are bound to \u003ccode\u003econst\u003c/code\u003e references but\nonly if they are bound directly.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eYou can create a temporary object as part of the evaluation of an expression.\u003c/p\u003e\n\u003cp\u003eFor example:\u003c/p\u003e\n\u003cpre\u003e\nint getOffset(int i) {\n  int x \u003d std::vector{10, 20, 30}[i] / (i + 1);\n  return x +std::stoi(\"15\");\n}\n\u003c/pre\u003e\n\u003cp\u003eThe code above contains two full expressions (declaration of \u003ccode\u003ei\u003c/code\u003e and \u003ccode\u003ereturn\u003c/code\u003e), each contains a temporary:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003estd::vector{10, 20, 30}\u003c/code\u003e is a temporary vector created in-place, and accessed directly. \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003e\"15\"\u003c/code\u003e is implicitly converted to temporary \u003ccode\u003estd::string{\"15\"}\u003c/code\u003e because \u003ccode\u003estd::stoi\u003c/code\u003e accepts \u003ccode\u003estd::string\n  const\u0026amp;\u003c/code\u003e as an argument. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eA temporary object remains valid throughout the single full expression where it was created. It is reclaimed and destroyed (for nontrivial objects)\nat the end of it.\u003c/p\u003e\n\u003cp\u003eIf after the end of a full expression, some references or pointers still refer to a temporary object they immediately become dangling, unless the\nlifetime of the temporary object is extended (see \u003ca href\u003d\"#exceptions\"\u003eExceptions\u003c/a\u003e).\u003c/p\u003e\n\u003cp\u003eDereferencing and even copying such dangling pointers or references causes \u003cstrong\u003eundefined behavior\u003c/strong\u003e.\u003c/p\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eA reference-to-\u003ccode\u003econst\u003c/code\u003e directly bound to a temporary object extends the lifetime of this object. The object enjoys the same lifetime as\nthe reference it is bound to.\u003c/p\u003e\n\u003cp\u003eHowever, lifetime extension is not transitive. If the definition of the temporary relies on another temporary, this second temporary will still be\ndestroyed at the end of the full expression, creating an immediately dangling reference.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eAccessing a dangling reference or pointer causes undefined behavior. This means the compiler is not bound by the language standard anymore and your\nprogram has no meaning assigned to it.\u003c/p\u003e\n\u003cp\u003ePractically this has a wide range of effects. In many cases, the access works by accident and succeeds at writing or reading a value. However, it\ncan start misbehaving at any time. If compilation flags, compiler, platform, or runtime environment change, the same code can crash the application,\ncorrupt memory, or leak a secret.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eYou can either copy the temporary object immediately, allocate it on the stack (as a local variable), on the heap, or as a static object.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;optional\u0026gt;\n\nint f(int i) {\n  // r-value references can also be dangling\n  int \u0026amp;\u0026amp;rval \u003d *std::optional\u0026lt;int\u0026gt;(i);  // Noncompliant: rval is an immediately dangling reference\n  return rval; // dereferencing a dangling reference\n}\n\nint main() {\n    //The vector is a temporary object,\n    // and binding a reference to its first element will not extend the vector lifetime\n    auto const \u0026amp;val \u003d std::vector{1, 2, 3}[0]; // Noncompliant: val is an immediately dangling reference\n    return f(val);\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;optional\u0026gt;\n\nint f(int i) {\n  int rval \u003d *std::optional\u0026lt;int\u0026gt;(i);  // Compliant, rval copies the temporary\n  return rval;\n}\n\nauto const commonIndexValues \u003d std::vector{1, 2, 3};\n\nint main() {\n    auto const \u0026amp;val \u003d commonIndexValues[0]; // Compliant, commonIndexValues is a global constant\n    return f(val);\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;vector\u0026gt;\n\nclass Stats {\n    std::vector\u0026lt;int\u0026gt; playerScores;\n  public:\n    std::vector\u0026lt;int\u0026gt; const\u0026amp; getPlayerScores() const {\n      return playerScores;\n    }\n};\n\nStats getStats();\n\nint getTotalScore() {\n  int sum \u003d 0;\n  // getStats() returns a temporary that is reclaimed before the loop begins\n  // Even though internally the range-based for loop takes a const reference to a subobject of a temporary,\n  // it is not lifetime-extended, because the subobject reference is obtained indirectly\n  for (auto score : getStats().getPlayerScores()) { // Noncompliant\n    sum +\u003d score;\n  }\n  return sum;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;vector\u0026gt;\n\nclass Stats {\n    std::vector\u0026lt;int\u0026gt; playerScores;\n  public:\n    std::vector\u0026lt;int\u0026gt; const\u0026amp; getPlayerScores() const {\n      return playerScores;\n    }\n};\n\nStats getStats();\n\nint getTotalScore() {\n  int sum \u003d 0;\n  // stats is not a temporary and it is alive throughout the loop\n  for (auto stats \u003d getStats(); auto score : stats.getPlayerScores()) { // Compliant\n    sum +\u003d score;\n  }\n  return sum;\n}\n\u003c/pre\u003e\n\u003cp\u003eAlternatively, you can rely on lifetime-extension, if you are accessing the field directly:\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;vector\u0026gt;\n\nclass Stats {\n  public:\n    std::vector\u0026lt;int\u0026gt; playerScores;\n};\n\nStats getStats();\n\nint getTotalScore() {\n  int sum \u003d 0;\n  //The temporary Stats is lifetime extended for the duration of the loop\n  // because a hidden const reference is bound to its field Stats::playerScores\n  for (auto score : getStats().playerScores) { // Compliant\n    sum +\u003d score;\n  }\n  return sum;\n}\n\u003c/pre\u003e\n\u003cp\u003eAnother option is to overload the \u003ccode\u003egetPlayerScores\u003c/code\u003e member function to \"consume\" the temporary and return an independent temporary with\nits own lifetime that can be extended:\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;vector\u0026gt;\n\nclass Stats {\n    std::vector\u0026lt;int\u0026gt; playerScores;\n  public:\n    std::vector\u0026lt;int\u0026gt; const\u0026amp; getPlayerScores() const {\n      return playerScores;\n    }\n    std::vector\u0026lt;int\u0026gt; getPlayerScores() \u0026amp;\u0026amp; { // Note the \u0026amp;\u0026amp;\n      return std::move(playerScores);\n    }\n};\n\nStats getStats();\n\nint getTotalScore() {\n  int sum \u003d 0;\n  // Now, the second overload of getPlayerScores() is used, and it\n  // returns another temporary that can be lifetime extended.\n  for (auto score : getStats().getPlayerScores()) { // Compliant\n    sum +\u003d score;\n  }\n  return sum;\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"5\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;string\u0026gt;\n#include \u0026lt;memory\u0026gt;\nstruct MyStrRef {\n  std::shared_ptr\u0026lt;std::string const\u0026gt; target;\n  MyStrRef(std::string const\u0026amp; target):target (\u0026amp;target) {}\n};\n\nvoid f(Wrapper const\u0026amp; w) {\n  MyStrRef x(std::string{\"string\"}); // Noncompliant\n  std::cout \u0026lt;\u0026lt;*x.target; // Dereferencing a dangling pointer\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eYou can store the temporary as a global, static, or local variable, or on the heap. For the completeness sake, let us put the string on the\nheap:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"5\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;string\u0026gt;\n#include \u0026lt;memory\u0026gt;\nstruct MyStrRef {\n  std::shared_ptr\u0026lt;std::string const\u0026gt; target;\n  MyStrRef(std::shared_ptr\u0026lt;std::string const\u0026gt; target):target (\u0026amp;target) {}\n};\n\nvoid f(Wrapper const\u0026amp; w) {\n  auto s \u003d std::make_shared\u0026lt;std::string\u0026gt;(\"string\");\n  MyStrRef x(s); // Compliant\n  std::cout \u0026lt;\u0026lt;*x.target;\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;string\u0026gt;\nclass Wrapper {\n    std::string contents;\n  public:\n    std::string const\u0026amp; getOr(std::string const\u0026amp; backup) const {\n      return contents.empty() ? backup : contents;\n    }\n};\n\nvoid f(Wrapper const\u0026amp; w) {\n  // If w.contents is empty, c will be a dangling reference to the former std::string{\"\u0026lt;empty\u0026gt;\"}\n  auto const\u0026amp; c \u003d w.getOr(\"\u0026lt;empty\u0026gt;\"); // Noncompliant\n  std::cout \u0026lt;\u0026lt;c \u0026lt;\u0026lt;std::endl;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;string\u0026gt;\nclass Wrapper {\n    std::string contents;\n  public:\n    std::string const\u0026amp; getOr(std::string const\u0026amp; backup) const {\n      return contents.empty() ? backup : contents;\n    }\n};\n\nvoid f(Wrapper const\u0026amp; w) {\n  std::string c \u003d w.getOr(\"\u0026lt;empty\u0026gt;\"); // Compliant, c is an independent copy\n  std::cout \u0026lt;\u0026lt;c \u0026lt;\u0026lt;std::endl;\n}\n\u003c/pre\u003e\n\u003ch2\u003eGoing the extra mile\u003c/h2\u003e\n\u003cp\u003eThe interface of \u003ccode\u003eWrapper::getOr\u003c/code\u003e from the example above is dangerous, since it is bound to create subtle bugs. Instead of fixing every\ncall, it is better to make the interface less error-prone.\u003c/p\u003e\n\u003cp\u003eFor example, always return the \u003ccode\u003estd::string\u003c/code\u003e by value.\u003c/p\u003e\n\u003cpre\u003e\n  std::string Wrapper::getOr(std::string backup) const {\n    return contents.empty() ? backup : contents;\n  }\n\u003c/pre\u003e\n\u003cp\u003eThere is no reference involved, so no risk of having it dangling.\u003c/p\u003e\n\u003cp\u003eThis safer solution does involve some performance overhead of potentially unnecessarily copying \u003ccode\u003ew.contents\u003c/code\u003e string but in many cases it\nis acceptable.\u003c/p\u003e\n\u003cp\u003eAlternatively, using \u003ccode\u003estd::string_view\u003c/code\u003e does not escape this flaw in all cases (see below) but it avoids the performance impact of\n\u003ccode\u003estd::string\u003c/code\u003e creation.\u003c/p\u003e\n\u003cp\u003eHere is a possible implementation using \u003ccode\u003estd::string_view\u003c/code\u003e (or its equivalent before C++17):\u003c/p\u003e\n\u003cpre\u003e\n  std::string_view Wrapper::getOr(std::string_view backup) const {\n    return contents.empty() ? backup : contents;\n  }\n\u003c/pre\u003e\n\u003cp\u003eIn this case, \u003ccode\u003ew.getOr(\"str\")\u003c/code\u003e creates and passes \u003ccode\u003estd::string_view\u003c/code\u003e by value, and the temporary\n\u003ccode\u003estd::string_view\u003c/code\u003e stores a pointer to the string literal \u003ccode\u003e\"str\"\u003c/code\u003e. When \u003ccode\u003egetOr\u003c/code\u003e returns \u003ccode\u003econtents\u003c/code\u003e it\ncopies the \u003ccode\u003ebackup\u003c/code\u003e value, which is fast, and the result is copied to a variable in the caller’s stack frame.\u003c/p\u003e\n\u003cp\u003eYet, the following code would still create a dangling pointer because it creates a temporary \u003ccode\u003estd::string\u003c/code\u003e and the\n\u003ccode\u003estd::string_view\u003c/code\u003e refers to this temporary object that gets destroyed at the end of the full expression:\u003c/p\u003e\n\u003cpre\u003e\nstd::string_view c \u003d w.getOr(std::string{\"str\"}); // Noncompliant\nstd::cout \u0026lt;\u0026lt;c \u0026lt;\u0026lt;std::endl; // c refers to the memory formerly occupied by a temporary string\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/lifetime\"\u003eLifetime\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/range-for\"\u003eRange-based for loop / Temporary range expression\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/header/string_view\"\u003estring_view\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eArticles \u0026amp; blog posts\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Abseil - \u003ca href\u003d\"https://abseil.io/tips/107\"\u003eTip of the Week #107: Reference Lifetime Extension\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eReferences and pointers to temporary objects become dangling after these objects are destroyed. Barring lifetime extension, this happens at the end\nof a full expression.\u003c/p\u003e\n\u003cp\u003eLifetime extension allows even after the end of a full expression the use of the temporaries that are bound to \u003ccode\u003econst\u003c/code\u003e references but\nonly if they are bound directly.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eYou can create a temporary object as part of the evaluation of an expression.\u003c/p\u003e\n\u003cp\u003eFor example:\u003c/p\u003e\n\u003cpre\u003e\nint getOffset(int i) {\n  int x \u003d std::vector{10, 20, 30}[i] / (i + 1);\n  return x +std::stoi(\"15\");\n}\n\u003c/pre\u003e\n\u003cp\u003eThe code above contains two full expressions (declaration of \u003ccode\u003ei\u003c/code\u003e and \u003ccode\u003ereturn\u003c/code\u003e), each contains a temporary:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003estd::vector{10, 20, 30}\u003c/code\u003e is a temporary vector created in-place, and accessed directly. \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003e\"15\"\u003c/code\u003e is implicitly converted to temporary \u003ccode\u003estd::string{\"15\"}\u003c/code\u003e because \u003ccode\u003estd::stoi\u003c/code\u003e accepts \u003ccode\u003estd::string\n  const\u0026amp;\u003c/code\u003e as an argument. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eA temporary object remains valid throughout the single full expression where it was created. It is reclaimed and destroyed (for nontrivial objects)\nat the end of it.\u003c/p\u003e\n\u003cp\u003eIf after the end of a full expression, some references or pointers still refer to a temporary object they immediately become dangling, unless the\nlifetime of the temporary object is extended (see \u003ca href\u003d\"#exceptions\"\u003eExceptions\u003c/a\u003e).\u003c/p\u003e\n\u003cp\u003eDereferencing and even copying such dangling pointers or references causes \u003cstrong\u003eundefined behavior\u003c/strong\u003e.\u003c/p\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eA reference-to-\u003ccode\u003econst\u003c/code\u003e directly bound to a temporary object extends the lifetime of this object. The object enjoys the same lifetime as\nthe reference it is bound to.\u003c/p\u003e\n\u003cp\u003eHowever, lifetime extension is not transitive. If the definition of the temporary relies on another temporary, this second temporary will still be\ndestroyed at the end of the full expression, creating an immediately dangling reference.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eAccessing a dangling reference or pointer causes undefined behavior. This means the compiler is not bound by the language standard anymore and your\nprogram has no meaning assigned to it.\u003c/p\u003e\n\u003cp\u003ePractically this has a wide range of effects. In many cases, the access works by accident and succeeds at writing or reading a value. However, it\ncan start misbehaving at any time. If compilation flags, compiler, platform, or runtime environment change, the same code can crash the application,\ncorrupt memory, or leak a secret.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eYou can either copy the temporary object immediately, allocate it on the stack (as a local variable), on the heap, or as a static object.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;optional\u0026gt;\n\nint f(int i) {\n  // r-value references can also be dangling\n  int \u0026amp;\u0026amp;rval \u003d *std::optional\u0026lt;int\u0026gt;(i);  // Noncompliant: rval is an immediately dangling reference\n  return rval; // dereferencing a dangling reference\n}\n\nint main() {\n    //The vector is a temporary object,\n    // and binding a reference to its first element will not extend the vector lifetime\n    auto const \u0026amp;val \u003d std::vector{1, 2, 3}[0]; // Noncompliant: val is an immediately dangling reference\n    return f(val);\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;vector\u0026gt;\n#include \u0026lt;optional\u0026gt;\n\nint f(int i) {\n  int rval \u003d *std::optional\u0026lt;int\u0026gt;(i);  // Compliant, rval copies the temporary\n  return rval;\n}\n\nauto const commonIndexValues \u003d std::vector{1, 2, 3};\n\nint main() {\n    auto const \u0026amp;val \u003d commonIndexValues[0]; // Compliant, commonIndexValues is a global constant\n    return f(val);\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;vector\u0026gt;\n\nclass Stats {\n    std::vector\u0026lt;int\u0026gt; playerScores;\n  public:\n    std::vector\u0026lt;int\u0026gt; const\u0026amp; getPlayerScores() const {\n      return playerScores;\n    }\n};\n\nStats getStats();\n\nint getTotalScore() {\n  int sum \u003d 0;\n  // getStats() returns a temporary that is reclaimed before the loop begins\n  // Even though internally the range-based for loop takes a const reference to a subobject of a temporary,\n  // it is not lifetime-extended, because the subobject reference is obtained indirectly\n  for (auto score : getStats().getPlayerScores()) { // Noncompliant\n    sum +\u003d score;\n  }\n  return sum;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;vector\u0026gt;\n\nclass Stats {\n    std::vector\u0026lt;int\u0026gt; playerScores;\n  public:\n    std::vector\u0026lt;int\u0026gt; const\u0026amp; getPlayerScores() const {\n      return playerScores;\n    }\n};\n\nStats getStats();\n\nint getTotalScore() {\n  int sum \u003d 0;\n  // stats is not a temporary and it is alive throughout the loop\n  for (auto stats \u003d getStats(); auto score : stats.getPlayerScores()) { // Compliant\n    sum +\u003d score;\n  }\n  return sum;\n}\n\u003c/pre\u003e\n\u003cp\u003eAlternatively, you can rely on lifetime-extension, if you are accessing the field directly:\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;vector\u0026gt;\n\nclass Stats {\n  public:\n    std::vector\u0026lt;int\u0026gt; playerScores;\n};\n\nStats getStats();\n\nint getTotalScore() {\n  int sum \u003d 0;\n  //The temporary Stats is lifetime extended for the duration of the loop\n  // because a hidden const reference is bound to its field Stats::playerScores\n  for (auto score : getStats().playerScores) { // Compliant\n    sum +\u003d score;\n  }\n  return sum;\n}\n\u003c/pre\u003e\n\u003cp\u003eAnother option is to overload the \u003ccode\u003egetPlayerScores\u003c/code\u003e member function to \"consume\" the temporary and return an independent temporary with\nits own lifetime that can be extended:\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;vector\u0026gt;\n\nclass Stats {\n    std::vector\u0026lt;int\u0026gt; playerScores;\n  public:\n    std::vector\u0026lt;int\u0026gt; const\u0026amp; getPlayerScores() const {\n      return playerScores;\n    }\n    std::vector\u0026lt;int\u0026gt; getPlayerScores() \u0026amp;\u0026amp; { // Note the \u0026amp;\u0026amp;\n      return std::move(playerScores);\n    }\n};\n\nStats getStats();\n\nint getTotalScore() {\n  int sum \u003d 0;\n  // Now, the second overload of getPlayerScores() is used, and it\n  // returns another temporary that can be lifetime extended.\n  for (auto score : getStats().getPlayerScores()) { // Compliant\n    sum +\u003d score;\n  }\n  return sum;\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"5\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;string\u0026gt;\n#include \u0026lt;memory\u0026gt;\nstruct MyStrRef {\n  std::shared_ptr\u0026lt;std::string const\u0026gt; target;\n  MyStrRef(std::string const\u0026amp; target):target (\u0026amp;target) {}\n};\n\nvoid f(Wrapper const\u0026amp; w) {\n  MyStrRef x(std::string{\"string\"}); // Noncompliant\n  std::cout \u0026lt;\u0026lt;*x.target; // Dereferencing a dangling pointer\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eYou can store the temporary as a global, static, or local variable, or on the heap. For the completeness sake, let us put the string on the\nheap:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"5\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;string\u0026gt;\n#include \u0026lt;memory\u0026gt;\nstruct MyStrRef {\n  std::shared_ptr\u0026lt;std::string const\u0026gt; target;\n  MyStrRef(std::shared_ptr\u0026lt;std::string const\u0026gt; target):target (\u0026amp;target) {}\n};\n\nvoid f(Wrapper const\u0026amp; w) {\n  auto s \u003d std::make_shared\u0026lt;std::string\u0026gt;(\"string\");\n  MyStrRef x(s); // Compliant\n  std::cout \u0026lt;\u0026lt;*x.target;\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;string\u0026gt;\nclass Wrapper {\n    std::string contents;\n  public:\n    std::string const\u0026amp; getOr(std::string const\u0026amp; backup) const {\n      return contents.empty() ? backup : contents;\n    }\n};\n\nvoid f(Wrapper const\u0026amp; w) {\n  // If w.contents is empty, c will be a dangling reference to the former std::string{\"\u0026lt;empty\u0026gt;\"}\n  auto const\u0026amp; c \u003d w.getOr(\"\u0026lt;empty\u0026gt;\"); // Noncompliant\n  std::cout \u0026lt;\u0026lt;c \u0026lt;\u0026lt;std::endl;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;string\u0026gt;\nclass Wrapper {\n    std::string contents;\n  public:\n    std::string const\u0026amp; getOr(std::string const\u0026amp; backup) const {\n      return contents.empty() ? backup : contents;\n    }\n};\n\nvoid f(Wrapper const\u0026amp; w) {\n  std::string c \u003d w.getOr(\"\u0026lt;empty\u0026gt;\"); // Compliant, c is an independent copy\n  std::cout \u0026lt;\u0026lt;c \u0026lt;\u0026lt;std::endl;\n}\n\u003c/pre\u003e\n\u003ch2\u003eGoing the extra mile\u003c/h2\u003e\n\u003cp\u003eThe interface of \u003ccode\u003eWrapper::getOr\u003c/code\u003e from the example above is dangerous, since it is bound to create subtle bugs. Instead of fixing every\ncall, it is better to make the interface less error-prone.\u003c/p\u003e\n\u003cp\u003eFor example, always return the \u003ccode\u003estd::string\u003c/code\u003e by value.\u003c/p\u003e\n\u003cpre\u003e\n  std::string Wrapper::getOr(std::string backup) const {\n    return contents.empty() ? backup : contents;\n  }\n\u003c/pre\u003e\n\u003cp\u003eThere is no reference involved, so no risk of having it dangling.\u003c/p\u003e\n\u003cp\u003eThis safer solution does involve some performance overhead of potentially unnecessarily copying \u003ccode\u003ew.contents\u003c/code\u003e string but in many cases it\nis acceptable.\u003c/p\u003e\n\u003cp\u003eAlternatively, using \u003ccode\u003estd::string_view\u003c/code\u003e does not escape this flaw in all cases (see below) but it avoids the performance impact of\n\u003ccode\u003estd::string\u003c/code\u003e creation.\u003c/p\u003e\n\u003cp\u003eHere is a possible implementation using \u003ccode\u003estd::string_view\u003c/code\u003e (or its equivalent before C++17):\u003c/p\u003e\n\u003cpre\u003e\n  std::string_view Wrapper::getOr(std::string_view backup) const {\n    return contents.empty() ? backup : contents;\n  }\n\u003c/pre\u003e\n\u003cp\u003eIn this case, \u003ccode\u003ew.getOr(\"str\")\u003c/code\u003e creates and passes \u003ccode\u003estd::string_view\u003c/code\u003e by value, and the temporary\n\u003ccode\u003estd::string_view\u003c/code\u003e stores a pointer to the string literal \u003ccode\u003e\"str\"\u003c/code\u003e. When \u003ccode\u003egetOr\u003c/code\u003e returns \u003ccode\u003econtents\u003c/code\u003e it\ncopies the \u003ccode\u003ebackup\u003c/code\u003e value, which is fast, and the result is copied to a variable in the caller’s stack frame.\u003c/p\u003e\n\u003cp\u003eYet, the following code would still create a dangling pointer because it creates a temporary \u003ccode\u003estd::string\u003c/code\u003e and the\n\u003ccode\u003estd::string_view\u003c/code\u003e refers to this temporary object that gets destroyed at the end of the full expression:\u003c/p\u003e\n\u003cpre\u003e\nstd::string_view c \u003d w.getOr(std::string{\"str\"}); // Noncompliant\nstd::cout \u0026lt;\u0026lt;c \u0026lt;\u0026lt;std::endl; // c refers to the memory formerly occupied by a temporary string\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/lifetime\"\u003eLifetime\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/range-for\"\u003eRange-based for loop / Temporary range expression\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/header/string_view\"\u003estring_view\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eArticles \u0026amp; blog posts\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Abseil - \u003ca href\u003d\"https://abseil.io/tips/107\"\u003eTip of the Week #107: Reference Lifetime Extension\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1079",
    "name": "\"scanf()\" and \"fscanf()\" format strings should specify a field width for the \"%s\" string placeholder",
    "defaultSeverity": "CRITICAL",
    "type": "VULNERABILITY",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "SECURITY": "HIGH"
    },
    "description": "\u003cp\u003eThe \u003ccode\u003e%s\u003c/code\u003e format specifier is used to read a string into a buffer. If the input string exceeds the size of this buffer, a buffer overflow\ncan occur.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eBy default, there is no limit on the length of the string being read. The \u003ccode\u003escanf\u003c/code\u003e family of functions will continue to read characters\ninto the buffer until they encounter a whitespace character.\u003c/p\u003e\n\u003cp\u003eIf the input contains a string that is long enough and lacks whitespace characters, it can result in memory beyond the end of the buffer being\noverwritten. This situation is known as a buffer overflow vulnerability.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eAn attacker could exploit this vulnerability to overwrite memory used by the application. This could result in the modification of application\ndata, unexpected behavior, or even cause the application to become unstable or crash. In some cases, the attacker might also gain control over the\nexecution flow of the application, leading to arbitrary code execution.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eA field width can be used together with the \u003ccode\u003e%s\u003c/code\u003e format specifier. This places an upper limit on the number of characters that will be\nread into the buffer.\u003c/p\u003e\n\u003cp\u003eNote that the \u003ccode\u003e%s\u003c/code\u003e format specifier always null-terminates the string in the buffer. You will need to ensure that the buffer is large\nenough to hold the required input and the null terminator.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nchar buffer[10];\nscanf(\"%s\", buffer);  // Noncompliant\n\u003c/pre\u003e\n\u003cp\u003eIf this code is given the word \u003ccode\u003enoncompliant\u003c/code\u003e as an input, \u003ccode\u003enoncomplia\u003c/code\u003e will be stored in \u003ccode\u003ebuffer\u003c/code\u003e and\n\u003ccode\u003ent␀\u003c/code\u003e will overwrite the contents of the memory immediately following \u003ccode\u003ebuffer\u003c/code\u003e.\u003c/p\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nchar buffer[10];\nscanf(\"%9s\", buffer);\n\u003c/pre\u003e\n\u003cp\u003eIf this code is given the word \u003ccode\u003enoncompliant\u003c/code\u003e as an input, \u003ccode\u003enoncompli␀\u003c/code\u003e will be stored in \u003ccode\u003ebuffer\u003c/code\u003e.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eArticles \u0026amp; blog posts\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Wikipedia - \u003ca href\u003d\"https://en.wikipedia.org/wiki/Buffer_overflow\"\u003eBuffer overflow\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e OWASP - \u003ca href\u003d\"https://owasp.org/www-project-top-ten/2017/A9_2017-Using_Components_with_Known_Vulnerabilities\"\u003eTop 10 2017 Category A9 -\n  Using Components with Known Vulnerabilities\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e MITRE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/120\"\u003eCWE-120 - Buffer Copy without Checking Size of Input\u003c/a\u003e (\u0027Classic Buffer\n  Overflow\u0027) \u003c/li\u003e\n  \u003cli\u003e MITRE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/676\"\u003eCWE-676 - Use of Potentially Dangerous Function\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eThe \u003ccode\u003e%s\u003c/code\u003e format specifier is used to read a string into a buffer. If the input string exceeds the size of this buffer, a buffer overflow\ncan occur.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eBy default, there is no limit on the length of the string being read. The \u003ccode\u003escanf\u003c/code\u003e family of functions will continue to read characters\ninto the buffer until they encounter a whitespace character.\u003c/p\u003e\n\u003cp\u003eIf the input contains a string that is long enough and lacks whitespace characters, it can result in memory beyond the end of the buffer being\noverwritten. This situation is known as a buffer overflow vulnerability.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eAn attacker could exploit this vulnerability to overwrite memory used by the application. This could result in the modification of application\ndata, unexpected behavior, or even cause the application to become unstable or crash. In some cases, the attacker might also gain control over the\nexecution flow of the application, leading to arbitrary code execution.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eA field width can be used together with the \u003ccode\u003e%s\u003c/code\u003e format specifier. This places an upper limit on the number of characters that will be\nread into the buffer.\u003c/p\u003e\n\u003cp\u003eNote that the \u003ccode\u003e%s\u003c/code\u003e format specifier always null-terminates the string in the buffer. You will need to ensure that the buffer is large\nenough to hold the required input and the null terminator.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nchar buffer[10];\nscanf(\"%s\", buffer);  // Noncompliant\n\u003c/pre\u003e\n\u003cp\u003eIf this code is given the word \u003ccode\u003enoncompliant\u003c/code\u003e as an input, \u003ccode\u003enoncomplia\u003c/code\u003e will be stored in \u003ccode\u003ebuffer\u003c/code\u003e and\n\u003ccode\u003ent␀\u003c/code\u003e will overwrite the contents of the memory immediately following \u003ccode\u003ebuffer\u003c/code\u003e.\u003c/p\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nchar buffer[10];\nscanf(\"%9s\", buffer);\n\u003c/pre\u003e\n\u003cp\u003eIf this code is given the word \u003ccode\u003enoncompliant\u003c/code\u003e as an input, \u003ccode\u003enoncompli␀\u003c/code\u003e will be stored in \u003ccode\u003ebuffer\u003c/code\u003e.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eArticles \u0026amp; blog posts\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Wikipedia - \u003ca href\u003d\"https://en.wikipedia.org/wiki/Buffer_overflow\"\u003eBuffer overflow\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e OWASP - \u003ca href\u003d\"https://owasp.org/www-project-top-ten/2017/A9_2017-Using_Components_with_Known_Vulnerabilities\"\u003eTop 10 2017 Category A9 -\n  Using Components with Known Vulnerabilities\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e MITRE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/120\"\u003eCWE-120 - Buffer Copy without Checking Size of Input\u003c/a\u003e (\u0027Classic Buffer\n  Overflow\u0027) \u003c/li\u003e\n  \u003cli\u003e MITRE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/676\"\u003eCWE-676 - Use of Potentially Dangerous Function\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cwe",
      "injection"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5316",
    "name": "A loop-control-variable other than the loop-counter shall not be modified within condition or expression",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThis rule is a strict implementation of a MISRA (Motor Industry Software Reliability Association) rule. MISRA defines best practices for developing\nsafety-critical software. You can learn more about this rule in the MISRA documents referenced below.\u003c/p\u003e\n\u003cp\u003eIf you are not concerned with MISRA compliance or with safety-critical software, you might consider using rule {rule:cpp:S886} instead ; it targets\nthe same kind of issue for general-purpose software.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++ 2008, 6-5-5 - A \u003cem\u003eloop-control-variable\u003c/em\u003e other than the \u003cem\u003eloop-counter\u003c/em\u003e shall not be modified within \u003cem\u003econdition\u003c/em\u003e\n  or \u003cem\u003eexpression\u003c/em\u003e. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThis rule is a strict implementation of a MISRA (Motor Industry Software Reliability Association) rule. MISRA defines best practices for developing\nsafety-critical software. You can learn more about this rule in the MISRA documents referenced below.\u003c/p\u003e\n\u003cp\u003eIf you are not concerned with MISRA compliance or with safety-critical software, you might consider using rule {rule:cpp:S886} instead ; it targets\nthe same kind of issue for general-purpose software.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C++ 2008, 6-5-5 - A \u003cem\u003eloop-control-variable\u003c/em\u003e other than the \u003cem\u003eloop-counter\u003c/em\u003e shall not be modified within \u003cem\u003econdition\u003c/em\u003e\n  or \u003cem\u003eexpression\u003c/em\u003e. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "misra-c++2008"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5314",
    "name": "Blocking functions should not be called inside critical sections",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "EFFICIENT",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003cp\u003eBlocking functions should not be called inside critical sections\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eConcurrent accesses to shared resources are guarded by synchronization primitives such as mutexes to prevent data races. The section of code where\na mutex is held is called the critical section. Critical sections are generally designed to be as small as possible, allowing concurrent threads to\nprogress.\u003c/p\u003e\n\u003cp\u003eIt’s usually unintentional to perform blocking operations inside a critical section because the operation might block for long or even\nindefinitely, degrading performance or causing a deadlock.\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;cstdio\u0026gt;    // printf()\n#include \u0026lt;cstdlib\u0026gt;   // atoi()\n#include \u0026lt;mutex\u0026gt;\n#include \u0026lt;unistd.h\u0026gt;  // sleep()\n\nstd::mutex m;\nint load_shared_resource(); // Guarded by mutex \u0027m\u0027\n\n// Some time-intensive computation.\nvoid do_expensive_work(int value, FILE *fd) {\n  char buf[4] \u003d \"\";\n  std::fgets(buf, sizeof(buf), fd);\n  int sum \u003d value + std::atoi(buf);\n  std::printf(\"value + line: %d\\n\", sum);\n}\n\nvoid worker_thread(FILE *fd) {\n  std::scoped_lock guard(m);\n  int value \u003d load_shared_resource();\n  // Mutex \u0027m\u0027 could have been released here.\n  do_expensive_work(value, fd);\n} // Mutex \u0027m\u0027 only released here, after \u0027do_expensive_work\u0027 is returned.\n\u003c/pre\u003e\n\u003cp\u003eUsually, blocking operations involve I/O operations, such as reading or writing a file or socket or sleeping for some specified time.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eDoing time-intensive operations while holding one or multiple locks will prevent concurrent threads from making progress updating the shared\nresource. This can lead to \"bottlenecks\" and the under-utilization of the hardware capabilities.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eUsually, one can move blocking or expensive computations from critical sections. This leads to smaller and cleaner critical sections in\ngeneral,\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;unistd.h\u0026gt;  // sleep()\n#include \u0026lt;mutex\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n\nint magic_number;\nstd::mutex m;\n\nvoid consumer_thread() {\n  int current;\n  for (int items_processed \u003d 0; items_processed \u0026lt; 100; ++items_processed) {\n    std::scoped_lock guard(m);\n    current \u003d magic_number;\n\n    sleep(std::clamp(current, 0, 10)); // Noncompliant: \u0027sleep\u0027 blocks while holding mutext \u0027m\u0027\n  }\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;unistd.h\u0026gt;  // sleep()\n#include \u0026lt;pthread.h\u0026gt; // pthread_mutex_*()\n\nint magic_number;\npthread_mutex_t m \u003d PTHREAD_MUTEX_INITIALIZER;\n\nvoid consumer_thread() {\n  int current;\n  for (int items_processed \u003d 0; items_processed \u0026lt; 100; ++items_processed) {\n    pthread_mutex_lock(\u0026amp;m);\n    current \u003d magic_number;\n    // Could have \u0027unlocked\u0027 mutex \u0027m\u0027 here.\n    sleep(current); // Noncompliant: \u0027sleep\u0027 blocks while holding mutex \u0027m\u0027\n    pthread_mutex_unlock(\u0026amp;m);\n  }\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;unistd.h\u0026gt;  // sleep()\n#include \u0026lt;mutex\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n\nint magic_number;\nstd::mutex m;\n\nvoid consumer_thread() {\n  int current;\n  for (int items_processed \u003d 0; items_processed \u0026lt; 100; ++items_processed) {\n    {\n      std::scoped_lock guard(m);\n      current \u003d magic_number;\n    }\n\n    sleep(std::clamp(current, 0, 10)); // Ok, blocking without holding any mutexes.\n  }\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;unistd.h\u0026gt;  // sleep()\n#include \u0026lt;pthread.h\u0026gt; // pthread_mutex_*()\n\nint magic_number;\npthread_mutex_t m \u003d PTHREAD_MUTEX_INITIALIZER;\n\nvoid consumer_thread() {\n  int current;\n  for (int items_processed \u003d 0; items_processed \u0026lt; 100; ++items_processed) {\n    pthread_mutex_lock(\u0026amp;m);\n    current \u003d magic_number;\n    pthread_mutex_unlock(\u0026amp;m);\n    sleep(current); // Ok, blocking without holding any mutexes.\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003ePitfalls\u003c/h3\u003e\n\u003cp\u003eIt’s important to note that not all operations can be moved out from the critical section without redesigning the algorithm. It’s tempting to read,\ncompute and commit back the result to some shared resource, but that coding pattern is vulnerable to Time-Of-Check-To-Time-Of-Use (TOCTOU) bugs.\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;unistd.h\u0026gt;  // sleep()\n#include \u0026lt;mutex\u0026gt;\n\nint input;\nstd::mutex input_mutex;\n\nint output;\nstd::mutex output_mutex;\n\nint expensive_computation(int in);\n\nvoid worker_thread() {\n  int previous_input \u003d -1;\n  int previous_result \u003d -1;\n\n  for (int items_processed \u003d 0; items_processed \u0026lt; 100; ++items_processed) {\n    int current;\n    {\n      // Read an input.\n      std::scoped_lock guard(input_mutex);\n      current \u003d input;\n    }\n\n    // Potentially perform an expensive computation.\n    // The \u0027input\u0027 might have changed during the computation,\n    // in which case, we just drop the result without committing it.\n    if (current !\u003d previous_input) {\n      previous_input \u003d current;\n      previous_result \u003d expensive_computation(current);\n\n      // Verify that the \u0027input\u0027 didn\u0027t change, and we can commit our result.\n      std::scoped_lock in_guard(input_mutex);\n      if (input \u003d\u003d previous_input) {\n        std::scoped_lock out_guard(output_mutex);\n        output \u003d previous_result; // Commit the result.\n      }\n    }\n  }\n}\n\u003c/pre\u003e\n\u003cp\u003eIt might not always be correct to commit the result even if the \u003ccode\u003einput\u003c/code\u003e didn’t change since we last checked. It could be that it was\nchanged but restored, as we are rechecking it. This is commonly known as the ABA problem, where \u003ccode\u003eA\u003c/code\u003e and \u003ccode\u003eB\u003c/code\u003e refers to the values\nof the resource.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#cp43-minimize-time-spent-in-a-critical-section\"\u003eCP.43: Minimize\n  time spent in a critical section\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S5184} enforces that guard objects are not temporary. \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S5506} detects direct calls to \u003ccode\u003elock\u003c/code\u003e and \u003ccode\u003eunlock\u003c/code\u003e on mutexes. \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S5524} detects individually locked mutexes. \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S5997} advocates for using \u003ccode\u003estd::scoped_lock\u003c/code\u003e over \u003ccode\u003estd::lock_guard\u003c/code\u003e. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/thread/mutex\"\u003e\u003ccode\u003estd::mutex\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/thread/scoped_lock\"\u003e\u003ccode\u003estd::scoped_lock\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/367\"\u003eMITRE, CWE-367\u003c/a\u003e - Time-of-check Time-of-use (TOCTOU) Race Condition \u003c/li\u003e\n  \u003cli\u003e Wikipedia - \u003ca href\u003d\"https://en.wikipedia.org/wiki/ABA_problem\"\u003eABA problem\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eBlocking functions should not be called inside critical sections\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eConcurrent accesses to shared resources are guarded by synchronization primitives such as mutexes to prevent data races. The section of code where\na mutex is held is called the critical section. Critical sections are generally designed to be as small as possible, allowing concurrent threads to\nprogress.\u003c/p\u003e\n\u003cp\u003eIt’s usually unintentional to perform blocking operations inside a critical section because the operation might block for long or even\nindefinitely, degrading performance or causing a deadlock.\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;cstdio\u0026gt;    // printf()\n#include \u0026lt;cstdlib\u0026gt;   // atoi()\n#include \u0026lt;mutex\u0026gt;\n#include \u0026lt;unistd.h\u0026gt;  // sleep()\n\nstd::mutex m;\nint load_shared_resource(); // Guarded by mutex \u0027m\u0027\n\n// Some time-intensive computation.\nvoid do_expensive_work(int value, FILE *fd) {\n  char buf[4] \u003d \"\";\n  std::fgets(buf, sizeof(buf), fd);\n  int sum \u003d value + std::atoi(buf);\n  std::printf(\"value + line: %d\\n\", sum);\n}\n\nvoid worker_thread(FILE *fd) {\n  std::scoped_lock guard(m);\n  int value \u003d load_shared_resource();\n  // Mutex \u0027m\u0027 could have been released here.\n  do_expensive_work(value, fd);\n} // Mutex \u0027m\u0027 only released here, after \u0027do_expensive_work\u0027 is returned.\n\u003c/pre\u003e\n\u003cp\u003eUsually, blocking operations involve I/O operations, such as reading or writing a file or socket or sleeping for some specified time.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eDoing time-intensive operations while holding one or multiple locks will prevent concurrent threads from making progress updating the shared\nresource. This can lead to \"bottlenecks\" and the under-utilization of the hardware capabilities.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eUsually, one can move blocking or expensive computations from critical sections. This leads to smaller and cleaner critical sections in\ngeneral,\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;unistd.h\u0026gt;  // sleep()\n#include \u0026lt;mutex\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n\nint magic_number;\nstd::mutex m;\n\nvoid consumer_thread() {\n  int current;\n  for (int items_processed \u003d 0; items_processed \u0026lt; 100; ++items_processed) {\n    std::scoped_lock guard(m);\n    current \u003d magic_number;\n\n    sleep(std::clamp(current, 0, 10)); // Noncompliant: \u0027sleep\u0027 blocks while holding mutext \u0027m\u0027\n  }\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;unistd.h\u0026gt;  // sleep()\n#include \u0026lt;pthread.h\u0026gt; // pthread_mutex_*()\n\nint magic_number;\npthread_mutex_t m \u003d PTHREAD_MUTEX_INITIALIZER;\n\nvoid consumer_thread() {\n  int current;\n  for (int items_processed \u003d 0; items_processed \u0026lt; 100; ++items_processed) {\n    pthread_mutex_lock(\u0026amp;m);\n    current \u003d magic_number;\n    // Could have \u0027unlocked\u0027 mutex \u0027m\u0027 here.\n    sleep(current); // Noncompliant: \u0027sleep\u0027 blocks while holding mutex \u0027m\u0027\n    pthread_mutex_unlock(\u0026amp;m);\n  }\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;unistd.h\u0026gt;  // sleep()\n#include \u0026lt;mutex\u0026gt;\n#include \u0026lt;algorithm\u0026gt;\n\nint magic_number;\nstd::mutex m;\n\nvoid consumer_thread() {\n  int current;\n  for (int items_processed \u003d 0; items_processed \u0026lt; 100; ++items_processed) {\n    {\n      std::scoped_lock guard(m);\n      current \u003d magic_number;\n    }\n\n    sleep(std::clamp(current, 0, 10)); // Ok, blocking without holding any mutexes.\n  }\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;unistd.h\u0026gt;  // sleep()\n#include \u0026lt;pthread.h\u0026gt; // pthread_mutex_*()\n\nint magic_number;\npthread_mutex_t m \u003d PTHREAD_MUTEX_INITIALIZER;\n\nvoid consumer_thread() {\n  int current;\n  for (int items_processed \u003d 0; items_processed \u0026lt; 100; ++items_processed) {\n    pthread_mutex_lock(\u0026amp;m);\n    current \u003d magic_number;\n    pthread_mutex_unlock(\u0026amp;m);\n    sleep(current); // Ok, blocking without holding any mutexes.\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003ePitfalls\u003c/h3\u003e\n\u003cp\u003eIt’s important to note that not all operations can be moved out from the critical section without redesigning the algorithm. It’s tempting to read,\ncompute and commit back the result to some shared resource, but that coding pattern is vulnerable to Time-Of-Check-To-Time-Of-Use (TOCTOU) bugs.\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;unistd.h\u0026gt;  // sleep()\n#include \u0026lt;mutex\u0026gt;\n\nint input;\nstd::mutex input_mutex;\n\nint output;\nstd::mutex output_mutex;\n\nint expensive_computation(int in);\n\nvoid worker_thread() {\n  int previous_input \u003d -1;\n  int previous_result \u003d -1;\n\n  for (int items_processed \u003d 0; items_processed \u0026lt; 100; ++items_processed) {\n    int current;\n    {\n      // Read an input.\n      std::scoped_lock guard(input_mutex);\n      current \u003d input;\n    }\n\n    // Potentially perform an expensive computation.\n    // The \u0027input\u0027 might have changed during the computation,\n    // in which case, we just drop the result without committing it.\n    if (current !\u003d previous_input) {\n      previous_input \u003d current;\n      previous_result \u003d expensive_computation(current);\n\n      // Verify that the \u0027input\u0027 didn\u0027t change, and we can commit our result.\n      std::scoped_lock in_guard(input_mutex);\n      if (input \u003d\u003d previous_input) {\n        std::scoped_lock out_guard(output_mutex);\n        output \u003d previous_result; // Commit the result.\n      }\n    }\n  }\n}\n\u003c/pre\u003e\n\u003cp\u003eIt might not always be correct to commit the result even if the \u003ccode\u003einput\u003c/code\u003e didn’t change since we last checked. It could be that it was\nchanged but restored, as we are rechecking it. This is commonly known as the ABA problem, where \u003ccode\u003eA\u003c/code\u003e and \u003ccode\u003eB\u003c/code\u003e refers to the values\nof the resource.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#cp43-minimize-time-spent-in-a-critical-section\"\u003eCP.43: Minimize\n  time spent in a critical section\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S5184} enforces that guard objects are not temporary. \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S5506} detects direct calls to \u003ccode\u003elock\u003c/code\u003e and \u003ccode\u003eunlock\u003c/code\u003e on mutexes. \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S5524} detects individually locked mutexes. \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S5997} advocates for using \u003ccode\u003estd::scoped_lock\u003c/code\u003e over \u003ccode\u003estd::lock_guard\u003c/code\u003e. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/thread/mutex\"\u003e\u003ccode\u003estd::mutex\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/thread/scoped_lock\"\u003e\u003ccode\u003estd::scoped_lock\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/367\"\u003eMITRE, CWE-367\u003c/a\u003e - Time-of-check Time-of-use (TOCTOU) Race Condition \u003c/li\u003e\n  \u003cli\u003e Wikipedia - \u003ca href\u003d\"https://en.wikipedia.org/wiki/ABA_problem\"\u003eABA problem\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cwe",
      "multi-threading",
      "symbolic-execution"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5798",
    "name": "\"memset\" should not be used to delete sensitive data",
    "defaultSeverity": "BLOCKER",
    "type": "VULNERABILITY",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "SECURITY": "HIGH"
    },
    "description": "\u003cp\u003eIf a buffer contains sensitive data, such as passwords or access tokens, it is good practice to overwrite the buffer before releasing the memory.\nThis ensures that the sensitive data is not available when that memory is reallocated. The \u003ccode\u003ememset\u003c/code\u003e function is commonly used for this\npurpose.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe C language specification allows the compiler to remove unnecessary code during the optimization phase. For example, when a memory buffer is\nabout to be destroyed, any writes to that buffer may be seen as unnecessary to the operation of the program. The compiler may choose to remove these\nwrite operations.\u003c/p\u003e\n\u003cp\u003eWhen the \u003ccode\u003ememset\u003c/code\u003e function is used to clear sensitive data from memory and that memory is destroyed immediately afterward, the compiler\nmay see the \u003ccode\u003ememset\u003c/code\u003e call as unnecessary and remove it. The sensitive data will, therefore, remain in memory.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when a call to \u003ccode\u003ememset\u003c/code\u003e is followed by the destruction of the buffer.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eThe function \u003ca href\u003d\"https://en.cppreference.com/w/c/string/byte/memset\"\u003e\u003ccode\u003ememset_s\u003c/code\u003e\u003c/a\u003e behaves similarly to \u003ccode\u003ememset\u003c/code\u003e. The\nmain difference is that it cannot be optimized away and the memory will be overwritten in all cases. You should use \u003ccode\u003ememset_s\u003c/code\u003e to clear\nsecurity-sensitive data.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003ememset_s\u003c/code\u003e function is defined in annex K of C11 and is optional for C11 compilers. It will only be available if the macro\n\u003ccode\u003e__STDC_LIB_EXT1__\u003c/code\u003e is defined, and it must be enabled by defining the macro \u003ccode\u003e__STDC_WANT_LIB_EXT1__\u003c/code\u003e before including\n\u003ccode\u003e\u0026lt;string.h\u0026gt;\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eOther platform-specific functions can perform the same operation, such as \u003ca\nhref\u003d\"https://docs.microsoft.com/en-us/previous-versions/windows/desktop/legacy/aa366877(v\u003dvs.85)?redirectedfrom\u003dMSDN\"\u003eSecureZeroMemory\u003c/a\u003e (Windows)\nor \u003ca href\u003d\"https://www.freebsd.org/cgi/man.cgi?query\u003dexplicit_bzero\"\u003eexplicit_bzero\u003c/a\u003e (FreeBSD).\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;string\u0026gt;\n\nvoid f(char *password, size_t bufferSize) {\n  char localToken[256];\n  init(localToken, password);\n  memset(password, 0, strlen(password));  // Noncompliant\n  memset(localToken, 0, strlen(localToken));  // Noncompliant\n  free(password);\n}\n\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003ememset\u003c/code\u003e calls may be optimized away because \u003ccode\u003epassword\u003c/code\u003e is about to be freed and \u003ccode\u003elocalToken\u003c/code\u003e is about to go\nout of scope.\u003c/p\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#define __STDC_WANT_LIB_EXT1__\n#include \u0026lt;string\u0026gt;\n\nvoid f(char *password, size_t bufferSize) {\n  char localToken[256];\n  init(localToken, password);\n  memset_s(password, bufferSize, 0, strlen(password));\n  memset_s(localToken, sizeof(localToken), 0, strlen(localToken));\n  free(password);\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/c/string/byte/memset\"\u003e\u003ccode\u003ememset\u003c/code\u003e, \u003ccode\u003ememset_s\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e OWASP - \u003ca href\u003d\"https://www.owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\"\u003eTop 10 2017 Category A3 - Sensitive Data\n  Exposure\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e OWASP - \u003ca href\u003d\"https://github.com/OWASP/ASVS/blob/master/4.0/en/0x16-V8-Data-Protection.md#v83-sensitive-private-data\"\u003eApplication Security\n  Verification Standard 4.0 - 8.3.6\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e MITRE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/14\"\u003eCWE-14 - Compiler Removal of Code to Clear Buffers\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eIf a buffer contains sensitive data, such as passwords or access tokens, it is good practice to overwrite the buffer before releasing the memory.\nThis ensures that the sensitive data is not available when that memory is reallocated. The \u003ccode\u003ememset\u003c/code\u003e function is commonly used for this\npurpose.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe C language specification allows the compiler to remove unnecessary code during the optimization phase. For example, when a memory buffer is\nabout to be destroyed, any writes to that buffer may be seen as unnecessary to the operation of the program. The compiler may choose to remove these\nwrite operations.\u003c/p\u003e\n\u003cp\u003eWhen the \u003ccode\u003ememset\u003c/code\u003e function is used to clear sensitive data from memory and that memory is destroyed immediately afterward, the compiler\nmay see the \u003ccode\u003ememset\u003c/code\u003e call as unnecessary and remove it. The sensitive data will, therefore, remain in memory.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when a call to \u003ccode\u003ememset\u003c/code\u003e is followed by the destruction of the buffer.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eThe function \u003ca href\u003d\"https://en.cppreference.com/w/c/string/byte/memset\"\u003e\u003ccode\u003ememset_s\u003c/code\u003e\u003c/a\u003e behaves similarly to \u003ccode\u003ememset\u003c/code\u003e. The\nmain difference is that it cannot be optimized away and the memory will be overwritten in all cases. You should use \u003ccode\u003ememset_s\u003c/code\u003e to clear\nsecurity-sensitive data.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003ememset_s\u003c/code\u003e function is defined in annex K of C11 and is optional for C11 compilers. It will only be available if the macro\n\u003ccode\u003e__STDC_LIB_EXT1__\u003c/code\u003e is defined, and it must be enabled by defining the macro \u003ccode\u003e__STDC_WANT_LIB_EXT1__\u003c/code\u003e before including\n\u003ccode\u003e\u0026lt;string.h\u0026gt;\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eOther platform-specific functions can perform the same operation, such as \u003ca\nhref\u003d\"https://docs.microsoft.com/en-us/previous-versions/windows/desktop/legacy/aa366877(v\u003dvs.85)?redirectedfrom\u003dMSDN\"\u003eSecureZeroMemory\u003c/a\u003e (Windows)\nor \u003ca href\u003d\"https://www.freebsd.org/cgi/man.cgi?query\u003dexplicit_bzero\"\u003eexplicit_bzero\u003c/a\u003e (FreeBSD).\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;string\u0026gt;\n\nvoid f(char *password, size_t bufferSize) {\n  char localToken[256];\n  init(localToken, password);\n  memset(password, 0, strlen(password));  // Noncompliant\n  memset(localToken, 0, strlen(localToken));  // Noncompliant\n  free(password);\n}\n\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003ememset\u003c/code\u003e calls may be optimized away because \u003ccode\u003epassword\u003c/code\u003e is about to be freed and \u003ccode\u003elocalToken\u003c/code\u003e is about to go\nout of scope.\u003c/p\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#define __STDC_WANT_LIB_EXT1__\n#include \u0026lt;string\u0026gt;\n\nvoid f(char *password, size_t bufferSize) {\n  char localToken[256];\n  init(localToken, password);\n  memset_s(password, bufferSize, 0, strlen(password));\n  memset_s(localToken, sizeof(localToken), 0, strlen(localToken));\n  free(password);\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/c/string/byte/memset\"\u003e\u003ccode\u003ememset\u003c/code\u003e, \u003ccode\u003ememset_s\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e OWASP - \u003ca href\u003d\"https://www.owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\"\u003eTop 10 2017 Category A3 - Sensitive Data\n  Exposure\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e OWASP - \u003ca href\u003d\"https://github.com/OWASP/ASVS/blob/master/4.0/en/0x16-V8-Data-Protection.md#v83-sensitive-private-data\"\u003eApplication Security\n  Verification Standard 4.0 - 8.3.6\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e MITRE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/14\"\u003eCWE-14 - Compiler Removal of Code to Clear Buffers\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cwe"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S2190",
    "name": "Recursion should not be infinite",
    "defaultSeverity": "BLOCKER",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eRecursion happens when control enters a loop that has no exit. It can occur when a method invokes itself, when two methods invoke each other, or\nwhen \u003ccode\u003egoto\u003c/code\u003e statements are used to move between two code segments. Recursion can be a useful tool, but unless the method includes a\nprovision to break out the recursion and \u003ccode\u003ereturn\u003c/code\u003e, the recursion will continue until the stack overflows and the program crashes.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint pow(int num, int exponent) {  // Noncompliant: pow is always re-called\n  num \u003d num * pow(num, exponent-1);\n  return num;  // this is never reached\n}\n\nvoid internalRecursion(int i) {\n  start:\n    goto end;\n  end:\n    goto start;  // Noncompliant: there is no way to break out of this method\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint pow(int num, int exponent) {\n  if (exponent \u0026gt; 1) {  // recursion is now conditional and stop-able\n    num \u003d num * pow(num, exponent-1);\n  }\n  return num;\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eRecursion happens when control enters a loop that has no exit. It can occur when a method invokes itself, when two methods invoke each other, or\nwhen \u003ccode\u003egoto\u003c/code\u003e statements are used to move between two code segments. Recursion can be a useful tool, but unless the method includes a\nprovision to break out the recursion and \u003ccode\u003ereturn\u003c/code\u003e, the recursion will continue until the stack overflows and the program crashes.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint pow(int num, int exponent) {  // Noncompliant: pow is always re-called\n  num \u003d num * pow(num, exponent-1);\n  return num;  // this is never reached\n}\n\nvoid internalRecursion(int i) {\n  start:\n    goto end;\n  end:\n    goto start;  // Noncompliant: there is no way to break out of this method\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint pow(int num, int exponent) {\n  if (exponent \u0026gt; 1) {  // recursion is now conditional and stop-able\n    num \u003d num * pow(num, exponent-1);\n  }\n  return num;\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S117",
    "name": "Local variable and function parameter names should comply with a naming convention",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "IDENTIFIABLE",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003cp\u003eLocal variables and function parameters should be named consistently to communicate intent and improve maintainability. Rename your local variable\nor function parameter to follow your project’s naming convention to address this issue.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eA naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.\u003cbr\u003e Local\nvariables and function parameters hold the meaning of the written code. Their names should be meaningful and follow a consistent and easily\nrecognizable pattern.\u003cbr\u003e Adhering to a consistent naming convention helps to make the code more readable and understandable, which makes it easier to\nmaintain and debug. It also ensures consistency in the code, especially when multiple developers are working on the same project.\u003c/p\u003e\n\u003cp\u003eThis rule checks that local variable and function parameter names match a provided regular expression.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eInconsistent naming of local variables and function parameters can lead to several issues in your code:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Reduced Readability: inconsistent local variable and function parameter names make the code harder to read and understand; consequently, it is\n  more difficult to identify the purpose of each variable, spot errors, or comprehend the logic. \u003c/li\u003e\n  \u003cli\u003e Difficulty in Identifying Variables: local variables and function parameters that don’t adhere to a standard naming convention are challenging\n  to identify; thus, the coding process slows down, especially when dealing with a large codebase. \u003c/li\u003e\n  \u003cli\u003e Increased Risk of Errors: inconsistent or unclear local variable and function parameter names lead to misunderstandings about what the variable\n  represents. This ambiguity leads to incorrect assumptions and, consequently, bugs in the code. \u003c/li\u003e\n  \u003cli\u003e Collaboration Difficulties: in a team setting, inconsistent naming conventions lead to confusion and miscommunication among team members. \u003c/li\u003e\n  \u003cli\u003e Difficulty in Code Maintenance: inconsistent naming leads to an inconsistent codebase. The code is difficult to understand, and making changes\n  feels like refactoring constantly, as you face different naming methods. Ultimately, it makes the codebase harder to maintain. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn summary, not adhering to a naming convention for local variables and function parameters can lead to confusion, errors, and inefficiencies,\nmaking the code harder to read, understand, and maintain.\u003c/p\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThis rule ignores \u003ccode\u003econst\u003c/code\u003e variables.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eFirst, familiarize yourself with the particular naming convention of the project in question. Then, update the name to match the convention, as\nwell as all usages of the name. For many IDEs, you can use built-in renaming and refactoring features to update all usages at once.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cp\u003eWith the default regular expression \u003ccode\u003e^[a-z][a-zA-Z0-9]*$\u003c/code\u003e:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid doSomething(int my_param) {\n  int LOCAL;\n  ...\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid doSomething(int myParam) {\n  int local;\n  ...\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Wikipedia - \u003ca href\u003d\"https://en.wikipedia.org/wiki/Naming_convention_(programming)\"\u003eNaming Convention (programming)\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S100} - Function names should comply with a naming convention \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S101} - Class names should comply with a naming convention \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S116} - Field names should comply with a naming convention \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S1543} - Macro names should comply with a naming convention \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S1578} - File names should comply with a naming convention \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S1642} - \u003ccode\u003estruct\u003c/code\u003e names should comply with a naming convention \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S1878} - \u003ccode\u003eunion\u003c/code\u003e names should comply with a naming convention \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S2304} - Namespace names should comply with a naming convention \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S2342} - Enumeration names should comply with a naming convention \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S2343} - Enumeration values should comply with a naming convention \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S3222} - Label names should comply with a naming convention \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S6193} - Coroutine names should comply with a naming convention \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S6221} - Concept names should comply with a naming convention \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eLocal variables and function parameters should be named consistently to communicate intent and improve maintainability. Rename your local variable\nor function parameter to follow your project’s naming convention to address this issue.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eA naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.\u003cbr\u003e Local\nvariables and function parameters hold the meaning of the written code. Their names should be meaningful and follow a consistent and easily\nrecognizable pattern.\u003cbr\u003e Adhering to a consistent naming convention helps to make the code more readable and understandable, which makes it easier to\nmaintain and debug. It also ensures consistency in the code, especially when multiple developers are working on the same project.\u003c/p\u003e\n\u003cp\u003eThis rule checks that local variable and function parameter names match a provided regular expression.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eInconsistent naming of local variables and function parameters can lead to several issues in your code:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Reduced Readability: inconsistent local variable and function parameter names make the code harder to read and understand; consequently, it is\n  more difficult to identify the purpose of each variable, spot errors, or comprehend the logic. \u003c/li\u003e\n  \u003cli\u003e Difficulty in Identifying Variables: local variables and function parameters that don’t adhere to a standard naming convention are challenging\n  to identify; thus, the coding process slows down, especially when dealing with a large codebase. \u003c/li\u003e\n  \u003cli\u003e Increased Risk of Errors: inconsistent or unclear local variable and function parameter names lead to misunderstandings about what the variable\n  represents. This ambiguity leads to incorrect assumptions and, consequently, bugs in the code. \u003c/li\u003e\n  \u003cli\u003e Collaboration Difficulties: in a team setting, inconsistent naming conventions lead to confusion and miscommunication among team members. \u003c/li\u003e\n  \u003cli\u003e Difficulty in Code Maintenance: inconsistent naming leads to an inconsistent codebase. The code is difficult to understand, and making changes\n  feels like refactoring constantly, as you face different naming methods. Ultimately, it makes the codebase harder to maintain. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn summary, not adhering to a naming convention for local variables and function parameters can lead to confusion, errors, and inefficiencies,\nmaking the code harder to read, understand, and maintain.\u003c/p\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThis rule ignores \u003ccode\u003econst\u003c/code\u003e variables.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eFirst, familiarize yourself with the particular naming convention of the project in question. Then, update the name to match the convention, as\nwell as all usages of the name. For many IDEs, you can use built-in renaming and refactoring features to update all usages at once.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cp\u003eWith the default regular expression \u003ccode\u003e^[a-z][a-zA-Z0-9]*$\u003c/code\u003e:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid doSomething(int my_param) {\n  int LOCAL;\n  ...\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid doSomething(int myParam) {\n  int local;\n  ...\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Wikipedia - \u003ca href\u003d\"https://en.wikipedia.org/wiki/Naming_convention_(programming)\"\u003eNaming Convention (programming)\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S100} - Function names should comply with a naming convention \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S101} - Class names should comply with a naming convention \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S116} - Field names should comply with a naming convention \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S1543} - Macro names should comply with a naming convention \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S1578} - File names should comply with a naming convention \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S1642} - \u003ccode\u003estruct\u003c/code\u003e names should comply with a naming convention \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S1878} - \u003ccode\u003eunion\u003c/code\u003e names should comply with a naming convention \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S2304} - Namespace names should comply with a naming convention \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S2342} - Enumeration names should comply with a naming convention \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S2343} - Enumeration values should comply with a naming convention \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S3222} - Label names should comply with a naming convention \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S6193} - Coroutine names should comply with a naming convention \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S6221} - Concept names should comply with a naming convention \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {
      "format": {
        "key": "format",
        "name": "format",
        "description": "POSIX regular expression used to check the names against.",
        "defaultValue": "^[a-z][a-zA-Z0-9]*$",
        "type": "STRING",
        "multiple": false,
        "possibleValues": []
      }
    },
    "defaultParams": {
      "format": "^[a-z][a-zA-Z0-9]*$"
    },
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "convention"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:M23_328",
    "name": "Reads and writes on the same file stream shall be separated by a positioning operation",
    "defaultSeverity": "BLOCKER",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 30.0.2\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Undecidable, System\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eAn explicit, interleaving stream positioning operation shall be used between input operations and output operations on a\n\u003ccode\u003estd::basic_filebuf\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThis rule applies to direct and indirect calls (e.g. from \u003ccode\u003estd::fstream\u003c/code\u003e) to \u003ccode\u003estd::basic_filebuf\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e for the purposes of this rule, a call to \u003ccode\u003efflush\u003c/code\u003e after an output operation is considered to be an explicit file\npositioning operation.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eThe C \u003ccode\u003eFILE *\u003c/code\u003e abstraction, used as the underlying system file I/O for \u003ccode\u003estd::basic_filebuf\u003c/code\u003e, holds a single file position\nthat is used when reading from or writing to the file. Using an input operation on a \u003ccode\u003eFILE *\u003c/code\u003e immediately after an output operation (or\nvice versa) results in \u003cem\u003eundefined behaviour\u003c/em\u003e, unless an interleaving file positioning operation is used to update the file’s position.\u003c/p\u003e\n\u003cp\u003eIn addition, a \u003ccode\u003estreambuf\u003c/code\u003e object keeps separate buffer positions for reading and writing characters from its internal buffer. A\n\u003ccode\u003ebasic_filebuf\u003c/code\u003e object is only guaranteed to synchronize the separate internal \u003ccode\u003estreambuf\u003c/code\u003e read and write positions that it\nmaintains when a positioning operation is called when alternating between reading and writing (and vice versa). Failure to include such a positioning\noperation leads to \u003cem\u003eundefined behaviour\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eThe accessible positioning operations for \u003ccode\u003estreambuf\u003c/code\u003e are \u003ccode\u003epubseekoff\u003c/code\u003e and \u003ccode\u003epubseekpos\u003c/code\u003e, whilst for file streams\nthey are \u003ccode\u003etellg\u003c/code\u003e, \u003ccode\u003eseekg\u003c/code\u003e, \u003ccode\u003etellp\u003c/code\u003e, and \u003ccode\u003eseekp\u003c/code\u003e. One of these functions shall be called when switching\nfrom output to input, or vice versa.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nvoid show_fstream_non_compliant()\n{\n  std::fstream f { \"hello.txt\" };\n\n  f \u0026lt;\u0026lt; \"Hello world!\\n\" \u0026lt;\u0026lt; std::flush;   // flush is not a positioning operation\n\n  std::string s {};\n\n  std::getline( f, s );                  // Non-compliant - undefined behaviour\n}\n\nvoid show_fstream_compliant()\n{\n  std::fstream f { \"hello.txt\" };\n\n  f \u0026lt;\u0026lt; \"Hello world!\\n\";\n\n  std::string s {};\n\n  f.seekg( 0, std::ios_base::beg );\n\n  std::getline(f, s);                    // Compliant - s holds \"Hello world!\"\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/L9YxBQ\"\u003eCERT, FIO39-C.\u003c/a\u003e - Do not alternately input and output from a stream without an\n  intervening flush or positioning call \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/2Hw-BQ\"\u003eCERT, FIO50-CPP.\u003c/a\u003e - Do not alternately input and output from a file stream without an\n  intervening positioning call \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 30.0.2\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Undecidable, System\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eAn explicit, interleaving stream positioning operation shall be used between input operations and output operations on a\n\u003ccode\u003estd::basic_filebuf\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThis rule applies to direct and indirect calls (e.g. from \u003ccode\u003estd::fstream\u003c/code\u003e) to \u003ccode\u003estd::basic_filebuf\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e for the purposes of this rule, a call to \u003ccode\u003efflush\u003c/code\u003e after an output operation is considered to be an explicit file\npositioning operation.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eThe C \u003ccode\u003eFILE *\u003c/code\u003e abstraction, used as the underlying system file I/O for \u003ccode\u003estd::basic_filebuf\u003c/code\u003e, holds a single file position\nthat is used when reading from or writing to the file. Using an input operation on a \u003ccode\u003eFILE *\u003c/code\u003e immediately after an output operation (or\nvice versa) results in \u003cem\u003eundefined behaviour\u003c/em\u003e, unless an interleaving file positioning operation is used to update the file’s position.\u003c/p\u003e\n\u003cp\u003eIn addition, a \u003ccode\u003estreambuf\u003c/code\u003e object keeps separate buffer positions for reading and writing characters from its internal buffer. A\n\u003ccode\u003ebasic_filebuf\u003c/code\u003e object is only guaranteed to synchronize the separate internal \u003ccode\u003estreambuf\u003c/code\u003e read and write positions that it\nmaintains when a positioning operation is called when alternating between reading and writing (and vice versa). Failure to include such a positioning\noperation leads to \u003cem\u003eundefined behaviour\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eThe accessible positioning operations for \u003ccode\u003estreambuf\u003c/code\u003e are \u003ccode\u003epubseekoff\u003c/code\u003e and \u003ccode\u003epubseekpos\u003c/code\u003e, whilst for file streams\nthey are \u003ccode\u003etellg\u003c/code\u003e, \u003ccode\u003eseekg\u003c/code\u003e, \u003ccode\u003etellp\u003c/code\u003e, and \u003ccode\u003eseekp\u003c/code\u003e. One of these functions shall be called when switching\nfrom output to input, or vice versa.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nvoid show_fstream_non_compliant()\n{\n  std::fstream f { \"hello.txt\" };\n\n  f \u0026lt;\u0026lt; \"Hello world!\\n\" \u0026lt;\u0026lt; std::flush;   // flush is not a positioning operation\n\n  std::string s {};\n\n  std::getline( f, s );                  // Non-compliant - undefined behaviour\n}\n\nvoid show_fstream_compliant()\n{\n  std::fstream f { \"hello.txt\" };\n\n  f \u0026lt;\u0026lt; \"Hello world!\\n\";\n\n  std::string s {};\n\n  f.seekg( 0, std::ios_base::beg );\n\n  std::getline(f, s);                    // Compliant - s holds \"Hello world!\"\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/L9YxBQ\"\u003eCERT, FIO39-C.\u003c/a\u003e - Do not alternately input and output from a stream without an\n  intervening flush or positioning call \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/2Hw-BQ\"\u003eCERT, FIO50-CPP.\u003c/a\u003e - Do not alternately input and output from a file stream without an\n  intervening positioning call \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "misra-c++2023",
      "misra-required",
      "unpredictable"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S116",
    "name": "Field names should comply with a naming convention",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "IDENTIFIABLE",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eA naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.\u003c/p\u003e\n\u003cp\u003eThe goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures\nconsistency in the code, especially when multiple developers are working on the same project.\u003c/p\u003e\n\u003cp\u003eThis rule checks that field names match a provided regular expression.\u003c/p\u003e\n\u003cp\u003eUsing the regular expression \u003ccode\u003e^[a-z][a-zA-Z0-9]*$\u003c/code\u003e, the noncompliant code below:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nclass MyClass {\n  int my_field; // Noncompliant\n};\n\u003c/pre\u003e\n\u003cp\u003eShould be replaced with:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nclass MyClass {\n  int myField;  // Compliant\n};\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Geeksforgeeks - \u003ca href\u003d\"https://www.geeksforgeeks.org/naming-convention-in-c/\"\u003eNaming convention in C++\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e Wikipedia - \u003ca href\u003d\"https://en.wikipedia.org/wiki/Naming_convention_(programming)\"\u003eNaming Convention (programming)\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eA naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.\u003c/p\u003e\n\u003cp\u003eThe goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures\nconsistency in the code, especially when multiple developers are working on the same project.\u003c/p\u003e\n\u003cp\u003eThis rule checks that field names match a provided regular expression.\u003c/p\u003e\n\u003cp\u003eUsing the regular expression \u003ccode\u003e^[a-z][a-zA-Z0-9]*$\u003c/code\u003e, the noncompliant code below:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nclass MyClass {\n  int my_field; // Noncompliant\n};\n\u003c/pre\u003e\n\u003cp\u003eShould be replaced with:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nclass MyClass {\n  int myField;  // Compliant\n};\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Geeksforgeeks - \u003ca href\u003d\"https://www.geeksforgeeks.org/naming-convention-in-c/\"\u003eNaming convention in C++\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e Wikipedia - \u003ca href\u003d\"https://en.wikipedia.org/wiki/Naming_convention_(programming)\"\u003eNaming Convention (programming)\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {
      "format": {
        "key": "format",
        "name": "format",
        "description": "POSIX regular expression used to check the field names against.",
        "defaultValue": "^[a-z][a-zA-Z0-9]*$",
        "type": "STRING",
        "multiple": false,
        "possibleValues": []
      }
    },
    "defaultParams": {
      "format": "^[a-z][a-zA-Z0-9]*$"
    },
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "convention"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S2193",
    "name": "\"for\" loop counters should not have essentially floating type",
    "defaultSeverity": "MINOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhen using a floating-point \u003ccode\u003efor\u003c/code\u003e loop counter, an accumulation of rounding errors may result in a mismatch between the expected and\nactual number of iterations.\u003c/p\u003e\n\u003cp\u003eEven if floating-point loop counters appears to behave correctly on one implementation, it may give a different number of iterations on another\nimplementation.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nfor (float counter \u003d 0.0f; counter \u0026lt; 1.0f; counter +\u003d 0.001f) {\n  ...\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nfor (int counter \u003d 0; counter \u0026lt; 1000; ++counter) {\n  ...\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 13.4 - The controlling expression of a for statement shall not contain any objects of floating type. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 6-5-1 - A \u003cem\u003efor\u003c/em\u003e loop shall contain a single \u003cem\u003eloop-counter\u003c/em\u003e which shall not have floating type. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 14.1 - A \u003cem\u003eloop counter\u003c/em\u003e shall not have essentially \u003cem\u003efloating type\u003c/em\u003e. \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/display/c/FLP30-C.+Do+not+use+floating-point+variables+as+loop+counters\"\u003eCERT, FLP30-C.\u003c/a\u003e - Do\n  not use floating-point variables as loop counters \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhen using a floating-point \u003ccode\u003efor\u003c/code\u003e loop counter, an accumulation of rounding errors may result in a mismatch between the expected and\nactual number of iterations.\u003c/p\u003e\n\u003cp\u003eEven if floating-point loop counters appears to behave correctly on one implementation, it may give a different number of iterations on another\nimplementation.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nfor (float counter \u003d 0.0f; counter \u0026lt; 1.0f; counter +\u003d 0.001f) {\n  ...\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nfor (int counter \u003d 0; counter \u0026lt; 1000; ++counter) {\n  ...\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 13.4 - The controlling expression of a for statement shall not contain any objects of floating type. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 6-5-1 - A \u003cem\u003efor\u003c/em\u003e loop shall contain a single \u003cem\u003eloop-counter\u003c/em\u003e which shall not have floating type. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 14.1 - A \u003cem\u003eloop counter\u003c/em\u003e shall not have essentially \u003cem\u003efloating type\u003c/em\u003e. \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/display/c/FLP30-C.+Do+not+use+floating-point+variables+as+loop+counters\"\u003eCERT, FLP30-C.\u003c/a\u003e - Do\n  not use floating-point variables as loop counters \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "cert"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:M23_329",
    "name": "\"Advanced memory management\" shall not be used",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 21.6.3\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eAll overloads of \u003ccode\u003eoperator new\u003c/code\u003e and \u003ccode\u003eoperator delete\u003c/code\u003e that are not listed below are \u003cem\u003eadvanced memory management\u003c/em\u003e\nfunctions:\u003c/p\u003e\n\u003cpre\u003e\nvoid * operator new  ( std::size_t count );\nvoid * operator new[]( std::size_t count );\nvoid * operator new  ( std::size_t count, const std::nothrow_t \u0026amp; tag );\nvoid * operator new[]( std::size_t count, const std::nothrow_t \u0026amp; tag );\n\nvoid operator delete  ( void * ptr ) noexcept;\nvoid operator delete[]( void * ptr ) noexcept;\nvoid operator delete  ( void * ptr, std::size_t sz ) noexcept;\nvoid operator delete[]( void * ptr, std::size_t sz ) noexcept;\nvoid operator delete  ( void * ptr, const std::nothrow_t \u0026amp; tag ) noexcept;\nvoid operator delete[]( void * ptr, const std::nothrow_t \u0026amp; tag ) noexcept;\n\u003c/pre\u003e\n\u003cp\u003eAdditionally, \u003ccode\u003estd::launder\u003c/code\u003e and the following functions from the \u003ccode\u003e\u0026lt;memory\u0026gt;\u003c/code\u003e \u003cem\u003eheader file\u003c/em\u003e [1] are also\n\u003cem\u003eadvanced memory management\u003c/em\u003e functions:\u003c/p\u003e\n\u003cpre\u003e\nuninitialized_default_construct   uninitialized_default_construct_n   destroy\nuninitialized_value_construct     uninitialized_value_construct_n     destroy_at\nuninitialized_copy                uninitialized_copy_n                destroy_n\nuninitialized_move                uninitialized_move_n\nuninitialized_fill                uninitialized_fill_n\n\u003c/pre\u003e\n\u003cp\u003e\u003cem\u003eAdvanced memory management\u003c/em\u003e occurs when:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e An \u003cem\u003eadvanced memory management\u003c/em\u003e function is either called directly or through a \u003cem\u003enew-expression\u003c/em\u003e or a \u003cem\u003edelete-expression\u003c/em\u003e;\n  or \u003c/li\u003e\n  \u003cli\u003e The address of an \u003cem\u003eadvanced memory management\u003c/em\u003e function is taken; or \u003c/li\u003e\n  \u003cli\u003e A destructor is called explicitly; or \u003c/li\u003e\n  \u003cli\u003e Any \u003ccode\u003eoperator new\u003c/code\u003e or \u003ccode\u003eoperator delete\u003c/code\u003e is user-declared. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eThere are a number of complex issues, such as alignment, object lifetimes and the need to use \u003ccode\u003estd::launder\u003c/code\u003e, that must be considered\nwhen using \u003cem\u003eadvanced memory management\u003c/em\u003e. Failure to deal with these appropriately results in the introduction of \u003cem\u003eundefined behaviour\u003c/em\u003e\nthat is hard to identify.\u003c/p\u003e\n\u003cp\u003eIn addition, \u003cem\u003eundefined behaviour\u003c/em\u003e results if a user does not provide matching versions of \u003ccode\u003eoperator new\u003c/code\u003e and \u003ccode\u003eoperator\ndelete\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThese features are generally only used (requiring a deviation) for low-level programming. Ideally, they should be encapsulated to reduce the amount\nof additional code review that will be required.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nauto f() noexcept\n{\n  return new( std::nothrow ) int{ 42 }; // Compliant\n}\n\nstruct X { int32_t a; };\n\nint32_t g()\n{\n  alignas( X ) std::byte mem[ sizeof( X ) ];\n\n  X * px \u003d new( \u0026amp;mem ) X{ 1 };          // Non-compliant - placement new\n\n  px-\u0026gt;~X();                             // Non-compliant - explicit destructor call\n\n  new( px ) X { 2 };                    // Non-compliant - placement new\n\n  return px-\u0026gt;a ;                        // Undefined behaviour\n}\n\nstruct A\n{\n  void * operator new( size_t );        // Non-compliant\n};\n\u003c/pre\u003e\n\u003ch3\u003eGlossary\u003c/h3\u003e\n\u003ch4\u003e[1] Header file\u003c/h4\u003e\n\u003cp\u003eA \u003cem\u003eheader file\u003c/em\u003e is considered to be any file that is included during preprocessing (for example via the \u003ccode\u003e#include\u003c/code\u003e directive),\nregardless of its name or suffix.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S3432} focuses on explicit destructor calls. \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2023 Rule\u0026nbsp;21.6.2 (Dynamic memory shall be managed automatically) constraints the use of non-advanced memory management functions\n  to ensure automatic management of dynamic memory \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2023 Rule\u0026nbsp;21.6.1 (\u003cem\u003eDynamic memory\u003c/em\u003e should not be used) applies in contexts where dynamic memory should not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2023 Rule\u0026nbsp;21.6.4 - If a project defines either a sized or unsized version of a global \u003ccode\u003eoperator delete\u003c/code\u003e, then both\n  shall be defined \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 21.6.3\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eAll overloads of \u003ccode\u003eoperator new\u003c/code\u003e and \u003ccode\u003eoperator delete\u003c/code\u003e that are not listed below are \u003cem\u003eadvanced memory management\u003c/em\u003e\nfunctions:\u003c/p\u003e\n\u003cpre\u003e\nvoid * operator new  ( std::size_t count );\nvoid * operator new[]( std::size_t count );\nvoid * operator new  ( std::size_t count, const std::nothrow_t \u0026amp; tag );\nvoid * operator new[]( std::size_t count, const std::nothrow_t \u0026amp; tag );\n\nvoid operator delete  ( void * ptr ) noexcept;\nvoid operator delete[]( void * ptr ) noexcept;\nvoid operator delete  ( void * ptr, std::size_t sz ) noexcept;\nvoid operator delete[]( void * ptr, std::size_t sz ) noexcept;\nvoid operator delete  ( void * ptr, const std::nothrow_t \u0026amp; tag ) noexcept;\nvoid operator delete[]( void * ptr, const std::nothrow_t \u0026amp; tag ) noexcept;\n\u003c/pre\u003e\n\u003cp\u003eAdditionally, \u003ccode\u003estd::launder\u003c/code\u003e and the following functions from the \u003ccode\u003e\u0026lt;memory\u0026gt;\u003c/code\u003e \u003cem\u003eheader file\u003c/em\u003e [1] are also\n\u003cem\u003eadvanced memory management\u003c/em\u003e functions:\u003c/p\u003e\n\u003cpre\u003e\nuninitialized_default_construct   uninitialized_default_construct_n   destroy\nuninitialized_value_construct     uninitialized_value_construct_n     destroy_at\nuninitialized_copy                uninitialized_copy_n                destroy_n\nuninitialized_move                uninitialized_move_n\nuninitialized_fill                uninitialized_fill_n\n\u003c/pre\u003e\n\u003cp\u003e\u003cem\u003eAdvanced memory management\u003c/em\u003e occurs when:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e An \u003cem\u003eadvanced memory management\u003c/em\u003e function is either called directly or through a \u003cem\u003enew-expression\u003c/em\u003e or a \u003cem\u003edelete-expression\u003c/em\u003e;\n  or \u003c/li\u003e\n  \u003cli\u003e The address of an \u003cem\u003eadvanced memory management\u003c/em\u003e function is taken; or \u003c/li\u003e\n  \u003cli\u003e A destructor is called explicitly; or \u003c/li\u003e\n  \u003cli\u003e Any \u003ccode\u003eoperator new\u003c/code\u003e or \u003ccode\u003eoperator delete\u003c/code\u003e is user-declared. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eThere are a number of complex issues, such as alignment, object lifetimes and the need to use \u003ccode\u003estd::launder\u003c/code\u003e, that must be considered\nwhen using \u003cem\u003eadvanced memory management\u003c/em\u003e. Failure to deal with these appropriately results in the introduction of \u003cem\u003eundefined behaviour\u003c/em\u003e\nthat is hard to identify.\u003c/p\u003e\n\u003cp\u003eIn addition, \u003cem\u003eundefined behaviour\u003c/em\u003e results if a user does not provide matching versions of \u003ccode\u003eoperator new\u003c/code\u003e and \u003ccode\u003eoperator\ndelete\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThese features are generally only used (requiring a deviation) for low-level programming. Ideally, they should be encapsulated to reduce the amount\nof additional code review that will be required.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nauto f() noexcept\n{\n  return new( std::nothrow ) int{ 42 }; // Compliant\n}\n\nstruct X { int32_t a; };\n\nint32_t g()\n{\n  alignas( X ) std::byte mem[ sizeof( X ) ];\n\n  X * px \u003d new( \u0026amp;mem ) X{ 1 };          // Non-compliant - placement new\n\n  px-\u0026gt;~X();                             // Non-compliant - explicit destructor call\n\n  new( px ) X { 2 };                    // Non-compliant - placement new\n\n  return px-\u0026gt;a ;                        // Undefined behaviour\n}\n\nstruct A\n{\n  void * operator new( size_t );        // Non-compliant\n};\n\u003c/pre\u003e\n\u003ch3\u003eGlossary\u003c/h3\u003e\n\u003ch4\u003e[1] Header file\u003c/h4\u003e\n\u003cp\u003eA \u003cem\u003eheader file\u003c/em\u003e is considered to be any file that is included during preprocessing (for example via the \u003ccode\u003e#include\u003c/code\u003e directive),\nregardless of its name or suffix.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S3432} focuses on explicit destructor calls. \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2023 Rule\u0026nbsp;21.6.2 (Dynamic memory shall be managed automatically) constraints the use of non-advanced memory management functions\n  to ensure automatic management of dynamic memory \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2023 Rule\u0026nbsp;21.6.1 (\u003cem\u003eDynamic memory\u003c/em\u003e should not be used) applies in contexts where dynamic memory should not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2023 Rule\u0026nbsp;21.6.4 - If a project defines either a sized or unsized version of a global \u003ccode\u003eoperator delete\u003c/code\u003e, then both\n  shall be defined \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "misra-c++2023",
      "misra-required",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S113",
    "name": "Files should end with a newline",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eSome tools work better when files end with a newline.\u003c/p\u003e\n\u003cp\u003eThis rule simply generates an issue if it is missing.\u003c/p\u003e\n\u003cp\u003eFor example, a Git diff looks like this if the empty line is missing at the end of the file:\u003c/p\u003e\n\u003cpre\u003e\n+class Test {\n+}\n\\ No newline at end of file\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eSome tools work better when files end with a newline.\u003c/p\u003e\n\u003cp\u003eThis rule simply generates an issue if it is missing.\u003c/p\u003e\n\u003cp\u003eFor example, a Git diff looks like this if the empty line is missing at the end of the file:\u003c/p\u003e\n\u003cpre\u003e\n+class Test {\n+}\n\\ No newline at end of file\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "convention"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:M23_324",
    "name": "A pointer to an incomplete class type shall not be deleted",
    "defaultSeverity": "BLOCKER",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 21.6.5\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eAn incomplete class type is a forward declared class type for which the compiler has not yet seen a complete definition.\u003c/p\u003e\n\u003cp\u003eDeleting a pointer to an incomplete class type results in \u003cem\u003eundefined behaviour\u003c/em\u003e when the complete class has a \u003cem\u003enon-trivial\u003c/em\u003e\ndestructor or a deallocation function.\u003c/p\u003e\n\u003cp\u003eThis rule prohibits deletion of a pointer to an incomplete class type even when it is a trivially destructible class without a deallocation\nfunction. This restriction defends against a \u003cem\u003enon-trivial\u003c/em\u003e destructor or a deallocation function being added during development.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cp\u003eThe following examples violate MISRA C++ 2023 Rule\u0026nbsp;21.6.2 (Dynamic memory shall be managed automatically).\u003c/p\u003e\n\u003cpre\u003e\nclass Bad\n{\n  class Impl;\n\n  Impl * pImpl;\n\npublic:\n  ~Bad()\n  {\n    delete pImpl;   // Non-compliant - at the point of deletion, pImpl points\n                    // to an object of incomplete class type.\n  }\n};\n\n// Header file\nclass Good\n{\n  class Impl;\n\n  Impl * pImpl;\n\npublic:\n  ~Good();\n};\n\n// Implementation file\nclass Good::Impl\n{\n};\n\n// Good::Impl is a complete type now\nGood::~Good()\n{\n  delete pImpl;   // Compliant - at the point of deletion, pImpl points to\n                  // a complete class type.\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003e{rule:cpp:S5265} targets the same defect as this rule but for a non-mission-critical context.\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 21.6.5\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eAn incomplete class type is a forward declared class type for which the compiler has not yet seen a complete definition.\u003c/p\u003e\n\u003cp\u003eDeleting a pointer to an incomplete class type results in \u003cem\u003eundefined behaviour\u003c/em\u003e when the complete class has a \u003cem\u003enon-trivial\u003c/em\u003e\ndestructor or a deallocation function.\u003c/p\u003e\n\u003cp\u003eThis rule prohibits deletion of a pointer to an incomplete class type even when it is a trivially destructible class without a deallocation\nfunction. This restriction defends against a \u003cem\u003enon-trivial\u003c/em\u003e destructor or a deallocation function being added during development.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cp\u003eThe following examples violate MISRA C++ 2023 Rule\u0026nbsp;21.6.2 (Dynamic memory shall be managed automatically).\u003c/p\u003e\n\u003cpre\u003e\nclass Bad\n{\n  class Impl;\n\n  Impl * pImpl;\n\npublic:\n  ~Bad()\n  {\n    delete pImpl;   // Non-compliant - at the point of deletion, pImpl points\n                    // to an object of incomplete class type.\n  }\n};\n\n// Header file\nclass Good\n{\n  class Impl;\n\n  Impl * pImpl;\n\npublic:\n  ~Good();\n};\n\n// Implementation file\nclass Good::Impl\n{\n};\n\n// Good::Impl is a complete type now\nGood::~Good()\n{\n  delete pImpl;   // Compliant - at the point of deletion, pImpl points to\n                  // a complete class type.\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003e{rule:cpp:S5265} targets the same defect as this rule but for a non-mission-critical context.\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "misra-c++2023",
      "misra-required",
      "unpredictable"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:M23_325",
    "name": "Line-splicing shall not be used in \"//\" comments",
    "defaultSeverity": "CRITICAL",
    "type": "BUG",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 5.7.3\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eThis rule is applied in translation phase 2, after multibyte characters have been mapped to the basic source character set during translation phase\n1 (see [lex.phases]).\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eLine-splicing occurs when the \u003ccode\u003e\\\u003c/code\u003e character is immediately followed by a new-line character. If a source line containing a\n\u003ccode\u003e//\u003c/code\u003e comment ends with a \u003ccode\u003e\\\u003c/code\u003e character in the basic source character set, the next line becomes part of the comment. This may\nresult in the unintentional removal of code.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cp\u003eIn the following non-compliant example, the physical line containing the \u003ccode\u003eif\u003c/code\u003e keyword is logically part of the previous line and is\ntherefore part of a comment.\u003c/p\u003e\n\u003cpre\u003e\nvoid f( bool b )\n{\n  uint16_t x \u003d 0U;   // comment \\\n  if ( b )\n  {\n    ++x;             // This is always executed\n  }\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003e{rule:cpp:S2323} targets the same defect as this rule but for a non-mission-critical context.\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 5.7.3\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eThis rule is applied in translation phase 2, after multibyte characters have been mapped to the basic source character set during translation phase\n1 (see [lex.phases]).\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eLine-splicing occurs when the \u003ccode\u003e\\\u003c/code\u003e character is immediately followed by a new-line character. If a source line containing a\n\u003ccode\u003e//\u003c/code\u003e comment ends with a \u003ccode\u003e\\\u003c/code\u003e character in the basic source character set, the next line becomes part of the comment. This may\nresult in the unintentional removal of code.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cp\u003eIn the following non-compliant example, the physical line containing the \u003ccode\u003eif\u003c/code\u003e keyword is logically part of the previous line and is\ntherefore part of a comment.\u003c/p\u003e\n\u003cpre\u003e\nvoid f( bool b )\n{\n  uint16_t x \u003d 0U;   // comment \\\n  if ( b )\n  {\n    ++x;             // This is always executed\n  }\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003e{rule:cpp:S2323} targets the same defect as this rule but for a non-mission-critical context.\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "misra-c++2023",
      "misra-required"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:M23_321",
    "name": "All variables should be initialized",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 11.6.1\u003c/p\u003e\n\u003cp\u003eCategory: Advisory\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eAll variables should either be explicitly or implicitly initialized.\u003c/p\u003e\n\u003cp\u003eApart from the following, all variables should be explicitly initialized with an associated initializer in their definition:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Variables of a class type, or \u003c/li\u003e\n  \u003cli\u003e Function parameters (which are initialized with the corresponding argument value), or \u003c/li\u003e\n  \u003cli\u003e Variables with static storage duration (which are \u003cem\u003ezero-initialized\u003c/em\u003e by default). \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eHaving several states within a program increases the risk of defects being introduced. Each variable that is first uninitialized, then set to a\nvalue creates two program states. It is therefore better to initialize the variable directly to a value that is to be used. The intent of this rule is\nnot that each variable is initialized with some value, but that it is initialized with its real value; the one that will be used when the variable is\nnext read.\u003c/p\u003e\n\u003cp\u003eIn order to achieve this, the variable definition can be delayed until the \"right\" value is available. This naturally leads to reducing the\nvariable’s scope, reducing the risk of the variable being used inappropriately. An immediately evaluated lambda can be used to compute a value when a\nvariable’s initialization is more complex.\u003c/p\u003e\n\u003cp\u003eIn many cases, initializing the variable within its definition allows it to be a constant definition.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e there are many ways to explicitly initialize a variable. When possible, the list-initialization syntax (with curly braces)\nshould be used as it does not suffer from the issues that arise from the use of other syntactic forms (e.g. narrowing or declaring a function while\ntrying to define a variable, aka \"the most vexing parse\").\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nvoid f( bool cond )\n{\n  int32_t i;                        // Non-compliant\n\n  if ( cond ) { i \u003d  42; }\n  else        { i \u003d -1;  }\n\n  int32_t j \u003d cond ? 42 : -1;       // Compliant\n  int32_t k \u003d [\u0026amp;]()                 // Compliant\n    {\n      if ( cond ) { return 42; }\n      else        { return -1; }\n    }();\n\n  string s;                         // Compliant - default-initialized\n}\n\nint32_t g;                          // Compliant - static initialization applies\n\nvoid f()\n{\n  thread_local int32_t i;           // Compliant - static initialization applies\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S5523} targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S836} reports only when an uninitialized variable is read before being set \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:M23_152}: MISRA C++ 2023 Rule\u0026nbsp;11.6.2 - The value of an object must not be read before it has been set \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2023 Rule\u0026nbsp;15.1.4 - All direct, non-static data members of a class should be initialized before the class object is\n  \u003cem\u003eaccessible\u003c/em\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cp\u003e\u003ca\nhref\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/036324/CppCoreGuidelines.md#es20-always-initialize-an-object\"\u003ehttps://github.com/isocpp/CppCoreGuidelines/blob/036324/CppCoreGuidelines.md#es20-always-initialize-an-object\u003c/a\u003e\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 11.6.1\u003c/p\u003e\n\u003cp\u003eCategory: Advisory\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eAll variables should either be explicitly or implicitly initialized.\u003c/p\u003e\n\u003cp\u003eApart from the following, all variables should be explicitly initialized with an associated initializer in their definition:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Variables of a class type, or \u003c/li\u003e\n  \u003cli\u003e Function parameters (which are initialized with the corresponding argument value), or \u003c/li\u003e\n  \u003cli\u003e Variables with static storage duration (which are \u003cem\u003ezero-initialized\u003c/em\u003e by default). \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eHaving several states within a program increases the risk of defects being introduced. Each variable that is first uninitialized, then set to a\nvalue creates two program states. It is therefore better to initialize the variable directly to a value that is to be used. The intent of this rule is\nnot that each variable is initialized with some value, but that it is initialized with its real value; the one that will be used when the variable is\nnext read.\u003c/p\u003e\n\u003cp\u003eIn order to achieve this, the variable definition can be delayed until the \"right\" value is available. This naturally leads to reducing the\nvariable’s scope, reducing the risk of the variable being used inappropriately. An immediately evaluated lambda can be used to compute a value when a\nvariable’s initialization is more complex.\u003c/p\u003e\n\u003cp\u003eIn many cases, initializing the variable within its definition allows it to be a constant definition.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e there are many ways to explicitly initialize a variable. When possible, the list-initialization syntax (with curly braces)\nshould be used as it does not suffer from the issues that arise from the use of other syntactic forms (e.g. narrowing or declaring a function while\ntrying to define a variable, aka \"the most vexing parse\").\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nvoid f( bool cond )\n{\n  int32_t i;                        // Non-compliant\n\n  if ( cond ) { i \u003d  42; }\n  else        { i \u003d -1;  }\n\n  int32_t j \u003d cond ? 42 : -1;       // Compliant\n  int32_t k \u003d [\u0026amp;]()                 // Compliant\n    {\n      if ( cond ) { return 42; }\n      else        { return -1; }\n    }();\n\n  string s;                         // Compliant - default-initialized\n}\n\nint32_t g;                          // Compliant - static initialization applies\n\nvoid f()\n{\n  thread_local int32_t i;           // Compliant - static initialization applies\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S5523} targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S836} reports only when an uninitialized variable is read before being set \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:M23_152}: MISRA C++ 2023 Rule\u0026nbsp;11.6.2 - The value of an object must not be read before it has been set \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2023 Rule\u0026nbsp;15.1.4 - All direct, non-static data members of a class should be initialized before the class object is\n  \u003cem\u003eaccessible\u003c/em\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cp\u003e\u003ca\nhref\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/036324/CppCoreGuidelines.md#es20-always-initialize-an-object\"\u003ehttps://github.com/isocpp/CppCoreGuidelines/blob/036324/CppCoreGuidelines.md#es20-always-initialize-an-object\u003c/a\u003e\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "misra-advisory",
      "misra-c++2023",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:M23_201",
    "name": "A \"noexcept\" function should not attempt to propagate an exception to the calling function",
    "defaultSeverity": "CRITICAL",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 18.5.1\u003c/p\u003e\n\u003cp\u003eCategory: Advisory\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Undecidable,System\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eA \u003ccode\u003enoexcept\u003c/code\u003e function attempts to propagate an exception when it directly or indirectly throws an exception that is not caught within\nthe function. Any exception that would escape the function causes the program to terminate.\u003c/p\u003e\n\u003cp\u003eThis rule also applies to all functions that are implicitly \u003ccode\u003enoexcept\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eIf a function’s \u003cem\u003eexception-specifier\u003c/em\u003e is of the form \u003ccode\u003enoexcept( condition )\u003c/code\u003e, then the function is only permitted to throw an\nexception when the condition is \u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eA function’s compliance with this rule is independent of the context in which it is called.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eMarking a function \u003ccode\u003enoexcept\u003c/code\u003e or \u003ccode\u003enoexcept( true )\u003c/code\u003e does not prevent an exception from being raised in the body of the\nfunction. However, if the function attempts to propagate an exception to a calling function, the program will be terminated through a call to\n\u003ccode\u003estd::terminate\u003c/code\u003e. This results in \u003cem\u003eimplementation-defined\u003c/em\u003e behaviour, including whether or not the stack is unwound before the\nprogram terminates (which may result in dangling resources).\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nvoid mayThrow( int32_t x )\n{\n  if ( x \u0026lt; 0 )\n  {\n    throw std::exception {};\n  }\n}\n\nvoid notThrowing()\n{\n}\n\nvoid f1( int32_t x ) noexcept    // Compliant\n{\n  notThrowing();\n}\n\nvoid f2( int32_t x ) noexcept    // Compliant\n{\n  if ( x \u0026gt; 0 )                   // This guard ...\n  {\n    mayThrow( x );               // ... ensures the call to mayThrow cannot throw\n  }\n}\n\nvoid f3( int32_t x ) noexcept    // Non-compliant - even if f3 is only called in\n{                                // contexts where x \u0026gt; 0\n  mayThrow( x );\n}\n\nvoid f4( int32_t x ) noexcept    // Compliant - any exception will not propagate\n{\n  try\n  {\n    mayThrow( x );\n  }\n  catch( ... )\n  {\n  }\n}\n\nvoid f5( int32_t x ) noexcept    // Non-compliant - exception is rethrown\n{\n  try\n  {\n    mayThrow( x );\n  }\n  catch ( ... )\n  {\n    throw;\n  }\n}\n\u003c/pre\u003e\n\u003cp\u003eInstantiations of the following template are compliant as they will only be \u003ccode\u003enoexcept( true )\u003c/code\u003e when the addition is non-throwing:\u003c/p\u003e\n\u003cpre\u003e\ntemplate \u0026lt; class T \u0026gt;                                // Compliant\nT plus( T a, T b ) noexcept( noexcept( a + b ) )\n{\n  return a + b;\n}\n\nclass A\n{\n  ~A()\n  {\n    throw std::exception {};   // Non-compliant - destructor is implicitly noexcept\n  }\n};\n\nvoid f6( int32_t x ) throw()   // throw() makes function noexcept\n{\n  throw std::exception {};     // Non-compliant\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003e{rule:cpp:S3743} targets the same defect as this rule but for a non-mission-critical context.\u003c/p\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cp\u003e\u003ca\nhref\u003d\"https://www.hlsl.co.uk/blog/2017/12/1/c-noexcept-and-move-constructors-effect-on-performance-in-stl-containers\"\u003ehttps://www.hlsl.co.uk/blog/2017/12/1/c-noexcept-and-move-constructors-effect-on-performance-in-stl-containers\u003c/a\u003e\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 18.5.1\u003c/p\u003e\n\u003cp\u003eCategory: Advisory\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Undecidable,System\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eA \u003ccode\u003enoexcept\u003c/code\u003e function attempts to propagate an exception when it directly or indirectly throws an exception that is not caught within\nthe function. Any exception that would escape the function causes the program to terminate.\u003c/p\u003e\n\u003cp\u003eThis rule also applies to all functions that are implicitly \u003ccode\u003enoexcept\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eIf a function’s \u003cem\u003eexception-specifier\u003c/em\u003e is of the form \u003ccode\u003enoexcept( condition )\u003c/code\u003e, then the function is only permitted to throw an\nexception when the condition is \u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eA function’s compliance with this rule is independent of the context in which it is called.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eMarking a function \u003ccode\u003enoexcept\u003c/code\u003e or \u003ccode\u003enoexcept( true )\u003c/code\u003e does not prevent an exception from being raised in the body of the\nfunction. However, if the function attempts to propagate an exception to a calling function, the program will be terminated through a call to\n\u003ccode\u003estd::terminate\u003c/code\u003e. This results in \u003cem\u003eimplementation-defined\u003c/em\u003e behaviour, including whether or not the stack is unwound before the\nprogram terminates (which may result in dangling resources).\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nvoid mayThrow( int32_t x )\n{\n  if ( x \u0026lt; 0 )\n  {\n    throw std::exception {};\n  }\n}\n\nvoid notThrowing()\n{\n}\n\nvoid f1( int32_t x ) noexcept    // Compliant\n{\n  notThrowing();\n}\n\nvoid f2( int32_t x ) noexcept    // Compliant\n{\n  if ( x \u0026gt; 0 )                   // This guard ...\n  {\n    mayThrow( x );               // ... ensures the call to mayThrow cannot throw\n  }\n}\n\nvoid f3( int32_t x ) noexcept    // Non-compliant - even if f3 is only called in\n{                                // contexts where x \u0026gt; 0\n  mayThrow( x );\n}\n\nvoid f4( int32_t x ) noexcept    // Compliant - any exception will not propagate\n{\n  try\n  {\n    mayThrow( x );\n  }\n  catch( ... )\n  {\n  }\n}\n\nvoid f5( int32_t x ) noexcept    // Non-compliant - exception is rethrown\n{\n  try\n  {\n    mayThrow( x );\n  }\n  catch ( ... )\n  {\n    throw;\n  }\n}\n\u003c/pre\u003e\n\u003cp\u003eInstantiations of the following template are compliant as they will only be \u003ccode\u003enoexcept( true )\u003c/code\u003e when the addition is non-throwing:\u003c/p\u003e\n\u003cpre\u003e\ntemplate \u0026lt; class T \u0026gt;                                // Compliant\nT plus( T a, T b ) noexcept( noexcept( a + b ) )\n{\n  return a + b;\n}\n\nclass A\n{\n  ~A()\n  {\n    throw std::exception {};   // Non-compliant - destructor is implicitly noexcept\n  }\n};\n\nvoid f6( int32_t x ) throw()   // throw() makes function noexcept\n{\n  throw std::exception {};     // Non-compliant\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003e{rule:cpp:S3743} targets the same defect as this rule but for a non-mission-critical context.\u003c/p\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cp\u003e\u003ca\nhref\u003d\"https://www.hlsl.co.uk/blog/2017/12/1/c-noexcept-and-move-constructors-effect-on-performance-in-stl-containers\"\u003ehttps://www.hlsl.co.uk/blog/2017/12/1/c-noexcept-and-move-constructors-effect-on-performance-in-stl-containers\u003c/a\u003e\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "misra-advisory",
      "misra-c++2023"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:M23_330",
    "name": "An \"explicit type conversion\" shall not be an \"expression statement\"",
    "defaultSeverity": "BLOCKER",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 9.2.1\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable, Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eThis rule only applies to \u003cem\u003eexplicit type conversions\u003c/em\u003e that use \u003cem\u003efunctional notation\u003c/em\u003e.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eAn \u003cem\u003eexplicit type conversion\u003c/em\u003e that uses \u003cem\u003efunctional notation\u003c/em\u003e is composed of a type name followed by parentheses or braces. It\ncreates a temporary object that is discarded at the end of the statement. This notation can appear to be very similar to the declaration of a\nvariable, except that it does not contain a variable name.\u003c/p\u003e\n\u003cp\u003eIf the intent was to declare a variable for scope-based resource management (e.g. \u003ccode\u003estd::lock_guard\u003c/code\u003e), the destruction side effects which\nwere expected to occur at the end of the containing block will instead occur immediately (e.g. the lock is prematurely released).\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cp\u003eIn the following example, the redundant parentheses surrounding \u003ccode\u003eb_mutex\u003c/code\u003e violate MISRA C++ 2023 Rule\u0026nbsp;6.0.1 (Block scope\n\u003cem\u003edeclarations\u003c/em\u003e shall not be \u003cem\u003evisually ambiguous\u003c/em\u003e).\u003c/p\u003e\n\u003cpre\u003e\nvoid f1()\n{\n  std::unique_lock\u0026lt; std::mutex \u0026gt;   a_mutex;    // Declaration, rule does not apply\n  std::unique_lock\u0026lt; std::mutex \u0026gt; ( b_mutex );  // Declaration, rule does not apply\n}\n\nvoid f2()\n{\n  std::scoped_lock { a_mutex };                // Non-compliant\n                                               //   - locks and unlocks here\n  // Unprotected\n}\n\nvoid f3()\n{\n  std::scoped_lock ( a_mutex, other_mutex );   // Non-compliant\n                                               //   - locks and unlocks here\n  // Unprotected\n}\n\nvoid f4()\n{\n  f( std::unique_lock { a_mutex } );           // Compliant - type conversion is\n                                               //   not an expression statement\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S5184} targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S905} targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2023 Rule\u0026nbsp;6.0.1 - Block scope \u003cem\u003edeclarations\u003c/em\u003e shall not be \u003cem\u003evisually ambiguous\u003c/em\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 9.2.1\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable, Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eThis rule only applies to \u003cem\u003eexplicit type conversions\u003c/em\u003e that use \u003cem\u003efunctional notation\u003c/em\u003e.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eAn \u003cem\u003eexplicit type conversion\u003c/em\u003e that uses \u003cem\u003efunctional notation\u003c/em\u003e is composed of a type name followed by parentheses or braces. It\ncreates a temporary object that is discarded at the end of the statement. This notation can appear to be very similar to the declaration of a\nvariable, except that it does not contain a variable name.\u003c/p\u003e\n\u003cp\u003eIf the intent was to declare a variable for scope-based resource management (e.g. \u003ccode\u003estd::lock_guard\u003c/code\u003e), the destruction side effects which\nwere expected to occur at the end of the containing block will instead occur immediately (e.g. the lock is prematurely released).\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cp\u003eIn the following example, the redundant parentheses surrounding \u003ccode\u003eb_mutex\u003c/code\u003e violate MISRA C++ 2023 Rule\u0026nbsp;6.0.1 (Block scope\n\u003cem\u003edeclarations\u003c/em\u003e shall not be \u003cem\u003evisually ambiguous\u003c/em\u003e).\u003c/p\u003e\n\u003cpre\u003e\nvoid f1()\n{\n  std::unique_lock\u0026lt; std::mutex \u0026gt;   a_mutex;    // Declaration, rule does not apply\n  std::unique_lock\u0026lt; std::mutex \u0026gt; ( b_mutex );  // Declaration, rule does not apply\n}\n\nvoid f2()\n{\n  std::scoped_lock { a_mutex };                // Non-compliant\n                                               //   - locks and unlocks here\n  // Unprotected\n}\n\nvoid f3()\n{\n  std::scoped_lock ( a_mutex, other_mutex );   // Non-compliant\n                                               //   - locks and unlocks here\n  // Unprotected\n}\n\nvoid f4()\n{\n  f( std::unique_lock { a_mutex } );           // Compliant - type conversion is\n                                               //   not an expression statement\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S5184} targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S905} targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2023 Rule\u0026nbsp;6.0.1 - Block scope \u003cem\u003edeclarations\u003c/em\u003e shall not be \u003cem\u003evisually ambiguous\u003c/em\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "misra-c++2023",
      "misra-required"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S122",
    "name": "Statements should be on separate lines",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "FORMATTED",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003ePutting multiple statements on a single line lowers the code readability and makes debugging the code more complex.\u003c/p\u003e\n\u003cpre\u003e\nfoo(); bar(); // Noncompliant\n\u003c/pre\u003e\n\u003cp\u003eWrite one statement per line to improve readability.\u003c/p\u003e\n\u003cpre\u003e\nfoo();\nbar();\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThe rule ignores:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e control flow statements with a single nested statement \u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\nif (condition) doSomething();     // Compliant by exception\nwhile (condition) doSomething();  // Compliant by exception\n\u003c/pre\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003ecase\u003c/code\u003e or \u003ccode\u003edefault\u003c/code\u003e statements containing a single statement followed by \u003ccode\u003ebreak\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\nswitch (foo) {\n  case  0: doSomething(); break;    // Compliant by exception\n  default: doSomething(); break;    // Compliant by exception\n}\n\u003c/pre\u003e\n\u003cul\u003e\n  \u003cli\u003e statements enclosed in curly braces on the same line \u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\nauto lambda \u003d [](int x) { doSomething(x); return x; }; // Compliant by exception\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003ePutting multiple statements on a single line lowers the code readability and makes debugging the code more complex.\u003c/p\u003e\n\u003cpre\u003e\nfoo(); bar(); // Noncompliant\n\u003c/pre\u003e\n\u003cp\u003eWrite one statement per line to improve readability.\u003c/p\u003e\n\u003cpre\u003e\nfoo();\nbar();\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThe rule ignores:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e control flow statements with a single nested statement \u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\nif (condition) doSomething();     // Compliant by exception\nwhile (condition) doSomething();  // Compliant by exception\n\u003c/pre\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003ecase\u003c/code\u003e or \u003ccode\u003edefault\u003c/code\u003e statements containing a single statement followed by \u003ccode\u003ebreak\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\nswitch (foo) {\n  case  0: doSomething(); break;    // Compliant by exception\n  default: doSomething(); break;    // Compliant by exception\n}\n\u003c/pre\u003e\n\u003cul\u003e\n  \u003cli\u003e statements enclosed in curly braces on the same line \u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\nauto lambda \u003d [](int x) { doSomething(x); return x; }; // Compliant by exception\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "convention"
    ],
    "deprecatedKeys": [
      "cpp:OneStatementPerLine"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S4136",
    "name": "Method overloads should be grouped together in the interface",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "FORMATTED",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eFor clarity, all overloads of the same method should be grouped together. That lets both users and maintainers quickly understand all the current\navailable options.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass Example {\npublic:\n  void foo(int x); // NonCompliant\n  void notFoo(int x);\n  void foo(double x); // Should be moved next to its overload\nprivate:\n  void foo(long x); // Okay since the function has different access specifier\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nclass Example {\npublic:\n  void foo(int x); // Compliant\n  void foo(double x);\n  void notFoo(int x);\nprivate:\n  void foo(long x); // Okay since the function has different access specifier\n};\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eFor clarity, all overloads of the same method should be grouped together. That lets both users and maintainers quickly understand all the current\navailable options.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass Example {\npublic:\n  void foo(int x); // NonCompliant\n  void notFoo(int x);\n  void foo(double x); // Should be moved next to its overload\nprivate:\n  void foo(long x); // Okay since the function has different access specifier\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nclass Example {\npublic:\n  void foo(int x); // Compliant\n  void foo(double x);\n  void notFoo(int x);\nprivate:\n  void foo(long x); // Okay since the function has different access specifier\n};\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "convention"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S121",
    "name": "Control structures should use curly braces",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003cp\u003eControl structures are code statements that impact the program’s control flow (e.g., if statements, for loops, etc.)\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhile not technically incorrect, the omission of curly braces can be misleading and may lead to the introduction of errors during maintenance.\u003c/p\u003e\n\u003cp\u003eIn the following example, the two calls seem to be attached to the \u003ccode\u003eif\u003c/code\u003e statement, but only the first one is, and\n\u003ccode\u003echeckSomething\u003c/code\u003e will always be executed:\u003c/p\u003e\n\u003cpre\u003e\nif (condition)  // Noncompliant\n  executeSomething();\n  checkSomething();\n\u003c/pre\u003e\n\u003cp\u003eAdding curly braces improves the code readability and its robustness:\u003c/p\u003e\n\u003cpre\u003e\nif (condition) {\n  executeSomething();\n  checkSomething();\n}\n\u003c/pre\u003e\n\u003cp\u003eThe rule raises an issue when a control structure has no curly braces.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 14.8 - The statement forming the body of a switch, while, do …​ while or for statement shall be a compound statement \u003c/li\u003e\n  \u003cli\u003e MISRA C:2004, 14.9 - An if (expression) construct shall be followed by a compound statement. The else keyword shall be followed by either a\n  compound statement, or another if statement \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 6-3-1 - The statement forming the body of a switch, while, do …​ while or for statement shall be a compound statement \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 6-4-1 - An if (condition) construct shall be followed by a compound statement. The else keyword shall be followed by either a\n  compound statement, or another if statement \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 15.6 - The body of an iteration-statement or a selection-statement shall be a compound-statement \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/g9YxBQ\"\u003eCERT, EXP19-C.\u003c/a\u003e - Use braces for the body of an if, for, or while statement \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eControl structures are code statements that impact the program’s control flow (e.g., if statements, for loops, etc.)\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhile not technically incorrect, the omission of curly braces can be misleading and may lead to the introduction of errors during maintenance.\u003c/p\u003e\n\u003cp\u003eIn the following example, the two calls seem to be attached to the \u003ccode\u003eif\u003c/code\u003e statement, but only the first one is, and\n\u003ccode\u003echeckSomething\u003c/code\u003e will always be executed:\u003c/p\u003e\n\u003cpre\u003e\nif (condition)  // Noncompliant\n  executeSomething();\n  checkSomething();\n\u003c/pre\u003e\n\u003cp\u003eAdding curly braces improves the code readability and its robustness:\u003c/p\u003e\n\u003cpre\u003e\nif (condition) {\n  executeSomething();\n  checkSomething();\n}\n\u003c/pre\u003e\n\u003cp\u003eThe rule raises an issue when a control structure has no curly braces.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 14.8 - The statement forming the body of a switch, while, do …​ while or for statement shall be a compound statement \u003c/li\u003e\n  \u003cli\u003e MISRA C:2004, 14.9 - An if (expression) construct shall be followed by a compound statement. The else keyword shall be followed by either a\n  compound statement, or another if statement \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 6-3-1 - The statement forming the body of a switch, while, do …​ while or for statement shall be a compound statement \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 6-4-1 - An if (condition) construct shall be followed by a compound statement. The else keyword shall be followed by either a\n  compound statement, or another if statement \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 15.6 - The body of an iteration-statement or a selection-statement shall be a compound-statement \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/g9YxBQ\"\u003eCERT, EXP19-C.\u003c/a\u003e - Use braces for the body of an if, for, or while statement \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "cert",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S108",
    "name": "Nested blocks of code should not be left empty",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eAn empty code block is confusing. It will require some effort from maintainers to determine if it is intentional or indicates the implementation is\nincomplete.\u003c/p\u003e\n\u003cpre\u003e\nvoid foo()\n{\n  int x;\n  if (x \u003d\u003d 42)\n  // Noncompliant - the following nested block is empty\n  {\n  }\n  else\n  {\n    doSomething();\n  }\n}\n\u003c/pre\u003e\n\u003cp\u003eRemoving or filling the empty code blocks takes away ambiguity and generally results in a more straightforward and less surprising code.\u003c/p\u003e\n\u003cpre\u003e\nvoid foo()\n{\n  int x;\n  if (x !\u003d 42)\n  {\n    doSomething();\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e The rule ignores code blocks that contain comments. \u003c/li\u003e\n  \u003cli\u003e Functions are not nested blocks, so they can be empty. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\nvoid bar()\n// Compliant - functions are not nested blocks\n{\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eAn empty code block is confusing. It will require some effort from maintainers to determine if it is intentional or indicates the implementation is\nincomplete.\u003c/p\u003e\n\u003cpre\u003e\nvoid foo()\n{\n  int x;\n  if (x \u003d\u003d 42)\n  // Noncompliant - the following nested block is empty\n  {\n  }\n  else\n  {\n    doSomething();\n  }\n}\n\u003c/pre\u003e\n\u003cp\u003eRemoving or filling the empty code blocks takes away ambiguity and generally results in a more straightforward and less surprising code.\u003c/p\u003e\n\u003cpre\u003e\nvoid foo()\n{\n  int x;\n  if (x !\u003d 42)\n  {\n    doSomething();\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e The rule ignores code blocks that contain comments. \u003c/li\u003e\n  \u003cli\u003e Functions are not nested blocks, so they can be empty. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\nvoid bar()\n// Compliant - functions are not nested blocks\n{\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "suspicious"
    ],
    "deprecatedKeys": [
      "cpp:EmptyCompoundStatement"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S109",
    "name": "Magic numbers should not be used",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003cp\u003eA magic number is a hard-coded numerical value that may lack context or meaning. They should not be used because they can make the code less\nreadable and maintainable.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eMagic numbers make the code more complex to understand as it requires the reader to have knowledge about the global context to understand the\nnumber itself. Their usage may seem obvious when writing the code, but it may not be the case for another developer or later once the context faded\naway. -1, 0, and 1 are not considered magic numbers.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eReplacing them with a constant allows us to provide a meaningful name associated with the value. Instead of adding complexity to the code, it\nbrings clarity and helps to understand the context and the global meaning.\u003c/p\u003e\n\u003cp\u003eThis is classically done by using a constant (\u003ccode\u003econstexpr\u003c/code\u003e or \u003ccode\u003econst\u003c/code\u003e if your compiler does not support \u003ccode\u003econstexpr\u003c/code\u003e\nyet) or an enumeration. Note that since C++20, some well-known mathematical constants, such as pi, are defined in the\nheader\u0026nbsp;\u003ccode\u003e\u0026lt;numbers\u0026gt;\u003c/code\u003e, and should be preferred over defining your own version (see {rule:cpp:S6164}).\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid doSomething(int var) {\n  for (int i \u003d 0; i \u0026lt; 42; i++) { // Noncompliant - 42 is a magic number\n    // ...\n  }\n\n  if (42 \u003d\u003d var) { // Noncompliant - magic number\n    // ...\n  }\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nenum Status {\n  STATUS_OK \u003d 0,\n  STATUS_ERROR \u003d 42\n};\n\nvoid doSomething(Status var) {\n  constexpr int maxIterations \u003d 42; // Compliant - in a declaration\n  for (int i \u003d 0; i \u0026lt; maxIterations; i++) { // Compliant - 0 is excluded, and maxIterations is a named constant\n    // ...\n  }\n\n  if (STATUS_OK \u003d\u003d var) { // Compliant - number comes from an enum\n    // ...\n  }\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eA magic number is a hard-coded numerical value that may lack context or meaning. They should not be used because they can make the code less\nreadable and maintainable.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eMagic numbers make the code more complex to understand as it requires the reader to have knowledge about the global context to understand the\nnumber itself. Their usage may seem obvious when writing the code, but it may not be the case for another developer or later once the context faded\naway. -1, 0, and 1 are not considered magic numbers.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eReplacing them with a constant allows us to provide a meaningful name associated with the value. Instead of adding complexity to the code, it\nbrings clarity and helps to understand the context and the global meaning.\u003c/p\u003e\n\u003cp\u003eThis is classically done by using a constant (\u003ccode\u003econstexpr\u003c/code\u003e or \u003ccode\u003econst\u003c/code\u003e if your compiler does not support \u003ccode\u003econstexpr\u003c/code\u003e\nyet) or an enumeration. Note that since C++20, some well-known mathematical constants, such as pi, are defined in the\nheader\u0026nbsp;\u003ccode\u003e\u0026lt;numbers\u0026gt;\u003c/code\u003e, and should be preferred over defining your own version (see {rule:cpp:S6164}).\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid doSomething(int var) {\n  for (int i \u003d 0; i \u0026lt; 42; i++) { // Noncompliant - 42 is a magic number\n    // ...\n  }\n\n  if (42 \u003d\u003d var) { // Noncompliant - magic number\n    // ...\n  }\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nenum Status {\n  STATUS_OK \u003d 0,\n  STATUS_ERROR \u003d 42\n};\n\nvoid doSomething(Status var) {\n  constexpr int maxIterations \u003d 42; // Compliant - in a declaration\n  for (int i \u003d 0; i \u0026lt; maxIterations; i++) { // Compliant - 0 is excluded, and maxIterations is a named constant\n    // ...\n  }\n\n  if (STATUS_OK \u003d\u003d var) { // Compliant - number comes from an enum\n    // ...\n  }\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "brain-overload"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S106",
    "name": "Standard outputs should not be used directly to log anything",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "MODULAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eIn software development, logs serve as a record of events within an application, providing crucial insights for debugging. When logging, it is\nessential to ensure that the logs are:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e easily accessible \u003c/li\u003e\n  \u003cli\u003e uniformly formatted for readability \u003c/li\u003e\n  \u003cli\u003e properly recorded \u003c/li\u003e\n  \u003cli\u003e securely logged when dealing with sensitive data \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThose requirements are not met if a program directly writes to the standard outputs (e.g., std::cout, std::cerr, printf). That is why defining and\nusing a dedicated logger is highly recommended.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003cp\u003eThe following noncompliant code:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid doSomething()\n{\n    // ...\n    std::cout \u0026lt;\u0026lt; \"My Message\";                // Noncompliant\n    // ...\n}\n\u003c/pre\u003e\n\u003cp\u003eCould be replaced by:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid doSomething()\n{\n    // ...\n    Log().Get(logINFO) \u0026lt;\u0026lt; \"My Message\";\n    // ...\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/Top10/A09_2021-Security_Logging_and_Monitoring_Failures/\"\u003eOWASP Top 10 2021 Category A9\u003c/a\u003e - Security Logging and\n  Monitoring Failures \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://www.owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\"\u003eOWASP Top 10 2017 Category A3\u003c/a\u003e - Sensitive Data\n  Exposure \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eIn software development, logs serve as a record of events within an application, providing crucial insights for debugging. When logging, it is\nessential to ensure that the logs are:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e easily accessible \u003c/li\u003e\n  \u003cli\u003e uniformly formatted for readability \u003c/li\u003e\n  \u003cli\u003e properly recorded \u003c/li\u003e\n  \u003cli\u003e securely logged when dealing with sensitive data \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThose requirements are not met if a program directly writes to the standard outputs (e.g., std::cout, std::cerr, printf). That is why defining and\nusing a dedicated logger is highly recommended.\u003c/p\u003e\n\n\u003cp\u003eThe following noncompliant code:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid doSomething()\n{\n    // ...\n    std::cout \u0026lt;\u0026lt; \"My Message\";                // Noncompliant\n    // ...\n}\n\u003c/pre\u003e\n\u003cp\u003eCould be replaced by:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid doSomething()\n{\n    // ...\n    Log().Get(logINFO) \u0026lt;\u0026lt; \"My Message\";\n    // ...\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/Top10/A09_2021-Security_Logging_and_Monitoring_Failures/\"\u003eOWASP Top 10 2021 Category A9\u003c/a\u003e - Security Logging and\n  Monitoring Failures \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://www.owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\"\u003eOWASP Top 10 2017 Category A3\u003c/a\u003e - Sensitive Data\n  Exposure \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "bad-practice",
      "cert"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S107",
    "name": "Functions should not have too many parameters",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "FOCUSED",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eFunctions with a long parameter list are difficult to use, as maintainers must figure out the role of each parameter and keep track of their\nposition.\u003c/p\u003e\n\u003cpre\u003e\nvoid setCoordinates(int x1, int y1, int z1, int x2, int y2, int z2) { // Noncompliant\n    // ...\n}\n\u003c/pre\u003e\n\u003cp\u003eThe solution can be to:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Split the function into smaller ones \u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\n// Each function does a part of what the original setCoordinates function was doing, so confusion risks are lower\nvoid setOrigin(int x, int y, int z) {\n   // ...\n}\n\nvoid setSize(int width, int height, int depth) {\n   // ...\n}\n\u003c/pre\u003e\n\u003cul\u003e\n  \u003cli\u003e Find a better data structure for the parameters that group data in a way that makes sense for the specific application domain \u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\nstruct Point {  // In geometry, Point is a logical structure to group data\n    int x;\n    int y;\n    int z;\n};\n\nvoid setCoordinates(Point p1, Point p2) {\n    // ...\n}\n\u003c/pre\u003e\n\u003cp\u003eThis rule raises an issue when a function has more parameters than the provided threshold.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#i23-keep-the-number-of-function-arguments-low\"\u003eI.23: Keep the\n  number of function arguments low\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eFunctions with a long parameter list are difficult to use, as maintainers must figure out the role of each parameter and keep track of their\nposition.\u003c/p\u003e\n\u003cpre\u003e\nvoid setCoordinates(int x1, int y1, int z1, int x2, int y2, int z2) { // Noncompliant\n    // ...\n}\n\u003c/pre\u003e\n\u003cp\u003eThe solution can be to:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Split the function into smaller ones \u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\n// Each function does a part of what the original setCoordinates function was doing, so confusion risks are lower\nvoid setOrigin(int x, int y, int z) {\n   // ...\n}\n\nvoid setSize(int width, int height, int depth) {\n   // ...\n}\n\u003c/pre\u003e\n\u003cul\u003e\n  \u003cli\u003e Find a better data structure for the parameters that group data in a way that makes sense for the specific application domain \u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\nstruct Point {  // In geometry, Point is a logical structure to group data\n    int x;\n    int y;\n    int z;\n};\n\nvoid setCoordinates(Point p1, Point p2) {\n    // ...\n}\n\u003c/pre\u003e\n\u003cp\u003eThis rule raises an issue when a function has more parameters than the provided threshold.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#i23-keep-the-number-of-function-arguments-low\"\u003eI.23: Keep the\n  number of function arguments low\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {
      "max": {
        "key": "max",
        "name": "max",
        "description": "Maximum authorized number of parameters",
        "defaultValue": "7",
        "type": "INTEGER",
        "multiple": false,
        "possibleValues": []
      }
    },
    "defaultParams": {
      "max": "7"
    },
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "brain-overload"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S104",
    "name": "Files should not have too many lines of code",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "FOCUSED",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhen a source file grows too much, it can accumulate numerous responsibilities and become challenging to understand and maintain.\u003c/p\u003e\n\u003cp\u003eAbove a specific threshold, refactor the file into smaller files whose code focuses on well-defined tasks. Those smaller files will be easier to\nunderstand and test.\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhen a source file grows too much, it can accumulate numerous responsibilities and become challenging to understand and maintain.\u003c/p\u003e\n\u003cp\u003eAbove a specific threshold, refactor the file into smaller files whose code focuses on well-defined tasks. Those smaller files will be easier to\nunderstand and test.\u003c/p\u003e"
      }
    ],
    "params": {
      "maximumFileLocThreshold": {
        "key": "maximumFileLocThreshold",
        "name": "maximumFileLocThreshold",
        "description": "The maximum authorized lines",
        "defaultValue": "1000",
        "type": "INTEGER",
        "multiple": false,
        "possibleValues": []
      }
    },
    "defaultParams": {
      "maximumFileLocThreshold": "1000"
    },
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "brain-overload"
    ],
    "deprecatedKeys": [
      "cpp:FileLoc"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:M23_218",
    "name": "The standard \"header file\" \"\u003ccsetjmp\u003e\" shall not be used",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 21.10.2\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eIn addition, none of the facilities that are specified as being provided by \u003ccode\u003e\u0026lt;csetjmp\u0026gt;\u003c/code\u003e shall be used.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e use of \u003ccode\u003e\u0026lt;setjmp.h\u0026gt;\u003c/code\u003e and the facilities it provides are also prohibited by this rule.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eThe use of \u003ccode\u003esetjmp\u003c/code\u003e and \u003ccode\u003elongjmp\u003c/code\u003e allow the normal function return mechanisms to be bypassed. Their use may result in\n\u003cem\u003eundefined\u003c/em\u003e and \u003cem\u003eunspecified behaviour\u003c/em\u003e. For example, it is \u003cem\u003eundefined behaviour\u003c/em\u003e if \u003ccode\u003elongjmp\u003c/code\u003e results in the omission\nof non-trivial object destruction.\u003c/p\u003e\n\u003cp\u003eSafety standards, such as IEC\u0026nbsp;61508\u0026nbsp; (Part 6, Table 6), encourage the use of the \"single-entry single-exit\" principle as part of the\n\"modular approach\". Unstructured languages, such as assembly, allow jumps between arbitrary points in a program, violating this principle. C++, with\nits concept of functions and the corresponding calling mechanism, enforces the \"single-entry single-exit\" principle through its language definition —\nfor example, multiple return statements within a function all return to the call site.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e the C++ Standard states that aspects of the behaviour associated with these facilities are defined in the related version of\nISO\u0026nbsp;9899\u0026nbsp;.\u003c/p\u003e\n\u003ch3\u003eGlossary\u003c/h3\u003e\n\u003ch4\u003e[1] Header file\u003c/h4\u003e\n\u003cp\u003eA \u003cem\u003eheader file\u003c/em\u003e is considered to be any file that is included during preprocessing (for example via the \u003ccode\u003e#include\u003c/code\u003e directive),\nregardless of its name or suffix.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003e{rule:cpp:S982} targets the same defect as this rule but for a non-mission-critical context.\u003c/p\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/ktYxBQ\"\u003eCERT, MSC22-C.\u003c/a\u003e - Use the setjmp(), longjmp() facility securely \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/nHs-BQ\"\u003eCERT, ERR52-CPP.\u003c/a\u003e - Do not use setjmp() or longjmp() \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 21.10.2\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eIn addition, none of the facilities that are specified as being provided by \u003ccode\u003e\u0026lt;csetjmp\u0026gt;\u003c/code\u003e shall be used.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e use of \u003ccode\u003e\u0026lt;setjmp.h\u0026gt;\u003c/code\u003e and the facilities it provides are also prohibited by this rule.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eThe use of \u003ccode\u003esetjmp\u003c/code\u003e and \u003ccode\u003elongjmp\u003c/code\u003e allow the normal function return mechanisms to be bypassed. Their use may result in\n\u003cem\u003eundefined\u003c/em\u003e and \u003cem\u003eunspecified behaviour\u003c/em\u003e. For example, it is \u003cem\u003eundefined behaviour\u003c/em\u003e if \u003ccode\u003elongjmp\u003c/code\u003e results in the omission\nof non-trivial object destruction.\u003c/p\u003e\n\u003cp\u003eSafety standards, such as IEC\u0026nbsp;61508\u0026nbsp; (Part 6, Table 6), encourage the use of the \"single-entry single-exit\" principle as part of the\n\"modular approach\". Unstructured languages, such as assembly, allow jumps between arbitrary points in a program, violating this principle. C++, with\nits concept of functions and the corresponding calling mechanism, enforces the \"single-entry single-exit\" principle through its language definition —\nfor example, multiple return statements within a function all return to the call site.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e the C++ Standard states that aspects of the behaviour associated with these facilities are defined in the related version of\nISO\u0026nbsp;9899\u0026nbsp;.\u003c/p\u003e\n\u003ch3\u003eGlossary\u003c/h3\u003e\n\u003ch4\u003e[1] Header file\u003c/h4\u003e\n\u003cp\u003eA \u003cem\u003eheader file\u003c/em\u003e is considered to be any file that is included during preprocessing (for example via the \u003ccode\u003e#include\u003c/code\u003e directive),\nregardless of its name or suffix.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003e{rule:cpp:S982} targets the same defect as this rule but for a non-mission-critical context.\u003c/p\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/ktYxBQ\"\u003eCERT, MSC22-C.\u003c/a\u003e - Use the setjmp(), longjmp() facility securely \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/nHs-BQ\"\u003eCERT, ERR52-CPP.\u003c/a\u003e - Do not use setjmp() or longjmp() \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "misra-c++2023",
      "misra-required",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S105",
    "name": "Tabulation characters should not be used",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "FORMATTED",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe tab width can differ from one development environment to another. Using tabs may require other developers to configure their environment (text\neditor, preferences, etc.) to read source code.\u003c/p\u003e\n\u003cp\u003eThat is why using spaces is preferable.\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe tab width can differ from one development environment to another. Using tabs may require other developers to configure their environment (text\neditor, preferences, etc.) to read source code.\u003c/p\u003e\n\u003cp\u003eThat is why using spaces is preferable.\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "convention"
    ],
    "deprecatedKeys": [
      "cpp:TabCharacter"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5570",
    "name": "Arguments evaluation order should not be relied on",
    "defaultSeverity": "CRITICAL",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eArguments evaluation order in a function call is not specified:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Before C++17, the evaluation of each argument was unsequenced with the evaluation of other arguments, which can lead to undefined behavior if\n  the same value is modified in several arguments, \u003c/li\u003e\n  \u003cli\u003e After C++17, it is sequenced, but in an unspecified order: the behavior is not longer undefined, but the values passed to the function will be\n  non portable. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eBoth cases should be avoided, because the code will probably not be what was expected.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid f(int i, int j);\n\nvoid g() {\n  int i \u003d 0;\n  f(++i, ++i); // Noncompliant, the call could either be f(1,2) or f(2,1) (since C++17) or undefined behavior (before C++17)\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThis rule does not apply to overloaded operators because they respect the sequencing order rules of the operator they overload (since C++17).\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es44-dont-depend-on-order-of-evaluation-of-function-arguments\"\u003eES.44: Don’t depend on order of evaluation of function arguments\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/eval_order\"\u003ecppreference.com - order of evaluation\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eArguments evaluation order in a function call is not specified:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Before C++17, the evaluation of each argument was unsequenced with the evaluation of other arguments, which can lead to undefined behavior if\n  the same value is modified in several arguments, \u003c/li\u003e\n  \u003cli\u003e After C++17, it is sequenced, but in an unspecified order: the behavior is not longer undefined, but the values passed to the function will be\n  non portable. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eBoth cases should be avoided, because the code will probably not be what was expected.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid f(int i, int j);\n\nvoid g() {\n  int i \u003d 0;\n  f(++i, ++i); // Noncompliant, the call could either be f(1,2) or f(2,1) (since C++17) or undefined behavior (before C++17)\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThis rule does not apply to overloaded operators because they respect the sequencing order rules of the operator they overload (since C++17).\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es44-dont-depend-on-order-of-evaluation-of-function-arguments\"\u003eES.44: Don’t depend on order of evaluation of function arguments\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/eval_order\"\u003ecppreference.com - order of evaluation\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cppcoreguidelines",
      "lock-in",
      "unpredictable"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S103",
    "name": "Lines should not be too long",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "FORMATTED",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eScrolling horizontally to see a full line of code lowers the code readability.\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eScrolling horizontally to see a full line of code lowers the code readability.\u003c/p\u003e"
      }
    ],
    "params": {
      "maximumLineLength": {
        "key": "maximumLineLength",
        "name": "maximumLineLength",
        "description": "The maximum authorized line length",
        "defaultValue": "80",
        "type": "INTEGER",
        "multiple": false,
        "possibleValues": []
      }
    },
    "defaultParams": {
      "maximumLineLength": "80"
    },
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "convention"
    ],
    "deprecatedKeys": [
      "cpp:LineLength"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:M23_338",
    "name": "\"Unscoped enumerations\" should not be declared",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "MODULAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 10.2.2\u003c/p\u003e\n\u003cp\u003eCategory: Advisory\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eIf an \u003cem\u003eunscoped enumeration\u003c/em\u003e type is declared, its enumerators may hide an \u003cem\u003eentity\u003c/em\u003e declared with the same name in an outer scope.\nThis may lead to developer confusion.\u003c/p\u003e\n\u003cp\u003eUsing a \u003cem\u003escoped enumeration\u003c/em\u003e restricts the scope of its enumerators\u0027 names, which can only be referenced as qualified names. In addition,\nits enumerators cannot be implicitly converted to numeric values.\u003c/p\u003e\n\u003ch3\u003eException\u003c/h3\u003e\n\u003cp\u003eThis rule does not apply to an \u003cem\u003eunscoped enumeration\u003c/em\u003e type declared as a class member as any name hiding would be reported as a violation of\nMISRA C++ 2023 Rule\u0026nbsp;6.4.1 (A variable declared in an \u003cem\u003einner scope\u003c/em\u003e shall not hide a variable declared in an \u003cem\u003eouter scope\u003c/em\u003e). This\nidiom was commonly used before \u003cem\u003escoped enumeration\u003c/em\u003e types were introduced.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nstatic int32_t E10 \u003d 5;\nstatic int32_t E20 \u003d 5;\n\nenum       E1 : int32_t { E10, E11, E12 };    // Non-compliant - ill-formed as\n                                              // E10 already declared\nenum class E2 : int32_t { E20, E21, E22 };    // Compliant\n\nvoid f1( int32_t number );\n\nvoid f2()\n{\n  f1( 0 );\n  f1( E11 );        // Implicit conversion from enum to int32_t type\n  f1( E2::E21 );    // Ill-formed - implicit conversion of scoped enumeration\n\n  f1( static_cast\u0026lt; int32_t \u0026gt;( E2::E21 ) );    // Explicit conversion needed\n}\n\nclass C1\n{\npublic:\n  enum Cstyle { E10, E20, E30 };              // Compliant by exception\n};\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S3642} targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2023 Rule\u0026nbsp;6.4.1 - A variable declared in an \u003cem\u003einner scope\u003c/em\u003e shall not hide a variable declared in an \u003cem\u003eouter scope\u003c/em\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 10.2.2\u003c/p\u003e\n\u003cp\u003eCategory: Advisory\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eIf an \u003cem\u003eunscoped enumeration\u003c/em\u003e type is declared, its enumerators may hide an \u003cem\u003eentity\u003c/em\u003e declared with the same name in an outer scope.\nThis may lead to developer confusion.\u003c/p\u003e\n\u003cp\u003eUsing a \u003cem\u003escoped enumeration\u003c/em\u003e restricts the scope of its enumerators\u0027 names, which can only be referenced as qualified names. In addition,\nits enumerators cannot be implicitly converted to numeric values.\u003c/p\u003e\n\u003ch3\u003eException\u003c/h3\u003e\n\u003cp\u003eThis rule does not apply to an \u003cem\u003eunscoped enumeration\u003c/em\u003e type declared as a class member as any name hiding would be reported as a violation of\nMISRA C++ 2023 Rule\u0026nbsp;6.4.1 (A variable declared in an \u003cem\u003einner scope\u003c/em\u003e shall not hide a variable declared in an \u003cem\u003eouter scope\u003c/em\u003e). This\nidiom was commonly used before \u003cem\u003escoped enumeration\u003c/em\u003e types were introduced.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nstatic int32_t E10 \u003d 5;\nstatic int32_t E20 \u003d 5;\n\nenum       E1 : int32_t { E10, E11, E12 };    // Non-compliant - ill-formed as\n                                              // E10 already declared\nenum class E2 : int32_t { E20, E21, E22 };    // Compliant\n\nvoid f1( int32_t number );\n\nvoid f2()\n{\n  f1( 0 );\n  f1( E11 );        // Implicit conversion from enum to int32_t type\n  f1( E2::E21 );    // Ill-formed - implicit conversion of scoped enumeration\n\n  f1( static_cast\u0026lt; int32_t \u0026gt;( E2::E21 ) );    // Explicit conversion needed\n}\n\nclass C1\n{\npublic:\n  enum Cstyle { E10, E20, E30 };              // Compliant by exception\n};\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S3642} targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2023 Rule\u0026nbsp;6.4.1 - A variable declared in an \u003cem\u003einner scope\u003c/em\u003e shall not hide a variable declared in an \u003cem\u003eouter scope\u003c/em\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "misra-advisory",
      "misra-c++2023",
      "pitfall",
      "since-c++11"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:M23_210",
    "name": "The \"#include\" directive shall be followed by either a \"\u003cfilename\u003e\" or  \"\"filename\"\" sequence",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 19.2.2\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eThis rule applies after macro replacement has been performed.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003e\u003cem\u003eUndefined behaviour\u003c/em\u003e occurs if a \u003ccode\u003e#include\u003c/code\u003e directive does not use one of the following forms:\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;filename\u0026gt;\n#include \"filename\"\n\u003c/pre\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;filename.h\u0026gt;         // Compliant\n#include \"filename.h\"         // Compliant\n#include \"./include/cpu.h\"    // Compliant - filename may include a path\n#include another.h            // Non-compliant\n\n#define HEADER \"filename.h\"\n#include HEADER               // Compliant\n#define FILENAME file2.h\n#include FILENAME             // Non-compliant\n\n#define BASE \"base\"\n#define EXT  \".ext\"\n#include BASE EXT             // Non-compliant - expands to an invalid form\n                              //   #include \"base\" \".ext\"\n                              // - string concatenation occurs after preprocessing\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003e{rule:cpp:S956} targets the same defect as this rule but for a non-mission-critical context.\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 19.2.2\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eThis rule applies after macro replacement has been performed.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003e\u003cem\u003eUndefined behaviour\u003c/em\u003e occurs if a \u003ccode\u003e#include\u003c/code\u003e directive does not use one of the following forms:\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;filename\u0026gt;\n#include \"filename\"\n\u003c/pre\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;filename.h\u0026gt;         // Compliant\n#include \"filename.h\"         // Compliant\n#include \"./include/cpu.h\"    // Compliant - filename may include a path\n#include another.h            // Non-compliant\n\n#define HEADER \"filename.h\"\n#include HEADER               // Compliant\n#define FILENAME file2.h\n#include FILENAME             // Non-compliant\n\n#define BASE \"base\"\n#define EXT  \".ext\"\n#include BASE EXT             // Non-compliant - expands to an invalid form\n                              //   #include \"base\" \".ext\"\n                              // - string concatenation occurs after preprocessing\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003e{rule:cpp:S956} targets the same defect as this rule but for a non-mission-critical context.\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "convention",
      "misra-c++2023",
      "misra-required"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:M23_331",
    "name": "Functions with \"limited visibility\" should be \"used\" at least once",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 0.2.4\u003c/p\u003e\n\u003cp\u003eCategory: Advisory\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,System\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eA function has \u003cem\u003elimited visibility\u003c/em\u003e if it:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Is declared in an anonymous namespace; or \u003c/li\u003e\n  \u003cli\u003e Is a member of a class in an anonymous namespace; or \u003c/li\u003e\n  \u003cli\u003e Has namespace scope and is declared \u003ccode\u003estatic\u003c/code\u003e; or \u003c/li\u003e\n  \u003cli\u003e Is a \u003ccode\u003eprivate\u003c/code\u003e, non-\u003ccode\u003evirtual\u003c/code\u003e member. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eA function is \u003cem\u003eused\u003c/em\u003e [1] when:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Its address is taken (including by reference); or \u003c/li\u003e\n  \u003cli\u003e It is called; or \u003c/li\u003e\n  \u003cli\u003e It is an operand of an expression in an unevaluated context; or \u003c/li\u003e\n  \u003cli\u003e Another function in the same overload set is \u003cem\u003eused\u003c/em\u003e [1]. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis rule does not apply to:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003cem\u003eSpecial member functions\u003c/em\u003e; \u003c/li\u003e\n  \u003cli\u003e Functions defined as \u003ccode\u003e\u003d delete\u003c/code\u003e. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eFunctions with \u003cem\u003elimited visibility\u003c/em\u003e are not generally used within an extensible API. If they are present but remain unused, then there may\nbe an issue in the software design.\u003c/p\u003e\n\u003cp\u003eUnused functions in an overload set are acceptable as it allows the set to be internally consistent.\u003c/p\u003e\n\u003ch3\u003eException\u003c/h3\u003e\n\u003cp\u003eFunctions that have at least one \u003cem\u003edeclaration\u003c/em\u003e [2] with the \u003ccode\u003e[[maybe_unused]]\u003c/code\u003e attribute are permitted to be unused as the intent\nis explicit.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nstruct Foo\n{\n  int32_t m1()                      // Public - rule does not apply\n  {\n    return -1;\n  }\n\n  static int32_t m2()               // Class scope - rule does not apply\n  {\n    return 42;\n  }\n\n  Foo()\n  {\n    m3();\n  }\n\nprivate:\n  void m3() { }                     // Compliant - called\n  void m4() { }                     // Non-compliant - not used\n  void m5() { }                     // Compliant - used by a friend\n\n  friend void ( *f4() )();\n\nprotected:\n  void m6() { }                     // Protected - rule does not apply\n};\n\nstatic void f1() { }                // Non-compliant - not used\n\nnamespace\n{\n  void f2() { }                     // Non-compliant - not used\n}\n\nstatic void f3() { }                // Compliant - address taken in f4()\n\nvoid ( *f4() )()                    // Rule does not apply - visibility not limited\n{\n  Foo bar;\n\n  bar.m5();\n\n  return \u0026amp;f3;\n}\n\nnamespace A\n{\n  struct C1 {};\n  static void swap( C1 \u0026amp;, C1 \u0026amp; );   // Compliant - overload set for call in f5\n}\n\nnamespace B\n{\n  struct C2 {};\n  static void swap( C2 \u0026amp;, C2 \u0026amp; );   // Non-compliant\n}\n\nnamespace\n{\n  template\u0026lt; typename T \u0026gt;\n  void swap( T \u0026amp;, T \u0026amp; );            // Compliant - overload set for call in f5\n}\n\nvoid f5( A::C1 c1, A::C1 c2 )       // Rule does not apply - visibility not limited\n{\n  swap( c1, c2 );\n}\n\u003c/pre\u003e\n\u003ch3\u003eGlossary\u003c/h3\u003e\n\u003ch4\u003e[1] Use / used / using\u003c/h4\u003e\n\u003cp\u003eAn object is \u003cem\u003eused\u003c/em\u003e if:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e It is the subject of a cast; or \u003c/li\u003e\n  \u003cli\u003e It is explicitly initialized at declaration time; or \u003c/li\u003e\n  \u003cli\u003e It is an operand in an expression; or \u003c/li\u003e\n  \u003cli\u003e It is referenced. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eA function is \u003cem\u003eused\u003c/em\u003e as defined in {rule:cpp:M23_331}: MISRA C++ 2023 Rule\u0026nbsp;0.2.4.\u003c/p\u003e\n\u003cp\u003eA type is \u003cem\u003eused\u003c/em\u003e as defined in MISRA C++ 2023 Rule\u0026nbsp;0.2.3 (Types with \u003cem\u003elimited visibility\u003c/em\u003e should be \u003cem\u003eused\u003c/em\u003e at least\nonce).\u003c/p\u003e\n\u003ch4\u003e[2] Declaration\u003c/h4\u003e\n\u003cp\u003eA \u003cem\u003edeclaration\u003c/em\u003e introduces the name of an \u003cem\u003eentity\u003c/em\u003e into a \u003cem\u003etranslation unit\u003c/em\u003e (see [basic.def]/1).\u003c/p\u003e\n\u003cp\u003eAn \u003cem\u003eentity\u003c/em\u003e may be \u003cem\u003edeclared\u003c/em\u003e several times. The first \u003cem\u003edeclaration\u003c/em\u003e of an \u003cem\u003eentity\u003c/em\u003e in a \u003cem\u003etranslation unit\u003c/em\u003e is\ncalled an \u003cem\u003eintroduction\u003c/em\u003e [3]. All subsequent \u003cem\u003edeclarations\u003c/em\u003e are called \u003cem\u003eredeclarations\u003c/em\u003e [4].\u003c/p\u003e\n\u003cp\u003eA \u003cem\u003edefinition\u003c/em\u003e [5] is a \u003cem\u003edeclaration\u003c/em\u003e, as described in [basic.def]/2.\u003c/p\u003e\n\u003ch4\u003e[3] Introduction\u003c/h4\u003e\n\u003cp\u003eSee \u003cem\u003edeclaration\u003c/em\u003e [2].\u003c/p\u003e\n\u003ch4\u003e[4] Redeclaration\u003c/h4\u003e\n\u003cp\u003eSee \u003cem\u003edeclaration\u003c/em\u003e [2].\u003c/p\u003e\n\u003ch4\u003e[5] Definition\u003c/h4\u003e\n\u003cp\u003eSee \u003cem\u003edeclaration\u003c/em\u003e [2].\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003e{rule:cpp:S1144} targets the same defect as this rule but for a non-mission-critical context.\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 0.2.4\u003c/p\u003e\n\u003cp\u003eCategory: Advisory\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,System\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eA function has \u003cem\u003elimited visibility\u003c/em\u003e if it:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Is declared in an anonymous namespace; or \u003c/li\u003e\n  \u003cli\u003e Is a member of a class in an anonymous namespace; or \u003c/li\u003e\n  \u003cli\u003e Has namespace scope and is declared \u003ccode\u003estatic\u003c/code\u003e; or \u003c/li\u003e\n  \u003cli\u003e Is a \u003ccode\u003eprivate\u003c/code\u003e, non-\u003ccode\u003evirtual\u003c/code\u003e member. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eA function is \u003cem\u003eused\u003c/em\u003e [1] when:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Its address is taken (including by reference); or \u003c/li\u003e\n  \u003cli\u003e It is called; or \u003c/li\u003e\n  \u003cli\u003e It is an operand of an expression in an unevaluated context; or \u003c/li\u003e\n  \u003cli\u003e Another function in the same overload set is \u003cem\u003eused\u003c/em\u003e [1]. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis rule does not apply to:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003cem\u003eSpecial member functions\u003c/em\u003e; \u003c/li\u003e\n  \u003cli\u003e Functions defined as \u003ccode\u003e\u003d delete\u003c/code\u003e. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eFunctions with \u003cem\u003elimited visibility\u003c/em\u003e are not generally used within an extensible API. If they are present but remain unused, then there may\nbe an issue in the software design.\u003c/p\u003e\n\u003cp\u003eUnused functions in an overload set are acceptable as it allows the set to be internally consistent.\u003c/p\u003e\n\u003ch3\u003eException\u003c/h3\u003e\n\u003cp\u003eFunctions that have at least one \u003cem\u003edeclaration\u003c/em\u003e [2] with the \u003ccode\u003e[[maybe_unused]]\u003c/code\u003e attribute are permitted to be unused as the intent\nis explicit.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nstruct Foo\n{\n  int32_t m1()                      // Public - rule does not apply\n  {\n    return -1;\n  }\n\n  static int32_t m2()               // Class scope - rule does not apply\n  {\n    return 42;\n  }\n\n  Foo()\n  {\n    m3();\n  }\n\nprivate:\n  void m3() { }                     // Compliant - called\n  void m4() { }                     // Non-compliant - not used\n  void m5() { }                     // Compliant - used by a friend\n\n  friend void ( *f4() )();\n\nprotected:\n  void m6() { }                     // Protected - rule does not apply\n};\n\nstatic void f1() { }                // Non-compliant - not used\n\nnamespace\n{\n  void f2() { }                     // Non-compliant - not used\n}\n\nstatic void f3() { }                // Compliant - address taken in f4()\n\nvoid ( *f4() )()                    // Rule does not apply - visibility not limited\n{\n  Foo bar;\n\n  bar.m5();\n\n  return \u0026amp;f3;\n}\n\nnamespace A\n{\n  struct C1 {};\n  static void swap( C1 \u0026amp;, C1 \u0026amp; );   // Compliant - overload set for call in f5\n}\n\nnamespace B\n{\n  struct C2 {};\n  static void swap( C2 \u0026amp;, C2 \u0026amp; );   // Non-compliant\n}\n\nnamespace\n{\n  template\u0026lt; typename T \u0026gt;\n  void swap( T \u0026amp;, T \u0026amp; );            // Compliant - overload set for call in f5\n}\n\nvoid f5( A::C1 c1, A::C1 c2 )       // Rule does not apply - visibility not limited\n{\n  swap( c1, c2 );\n}\n\u003c/pre\u003e\n\u003ch3\u003eGlossary\u003c/h3\u003e\n\u003ch4\u003e[1] Use / used / using\u003c/h4\u003e\n\u003cp\u003eAn object is \u003cem\u003eused\u003c/em\u003e if:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e It is the subject of a cast; or \u003c/li\u003e\n  \u003cli\u003e It is explicitly initialized at declaration time; or \u003c/li\u003e\n  \u003cli\u003e It is an operand in an expression; or \u003c/li\u003e\n  \u003cli\u003e It is referenced. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eA function is \u003cem\u003eused\u003c/em\u003e as defined in {rule:cpp:M23_331}: MISRA C++ 2023 Rule\u0026nbsp;0.2.4.\u003c/p\u003e\n\u003cp\u003eA type is \u003cem\u003eused\u003c/em\u003e as defined in MISRA C++ 2023 Rule\u0026nbsp;0.2.3 (Types with \u003cem\u003elimited visibility\u003c/em\u003e should be \u003cem\u003eused\u003c/em\u003e at least\nonce).\u003c/p\u003e\n\u003ch4\u003e[2] Declaration\u003c/h4\u003e\n\u003cp\u003eA \u003cem\u003edeclaration\u003c/em\u003e introduces the name of an \u003cem\u003eentity\u003c/em\u003e into a \u003cem\u003etranslation unit\u003c/em\u003e (see [basic.def]/1).\u003c/p\u003e\n\u003cp\u003eAn \u003cem\u003eentity\u003c/em\u003e may be \u003cem\u003edeclared\u003c/em\u003e several times. The first \u003cem\u003edeclaration\u003c/em\u003e of an \u003cem\u003eentity\u003c/em\u003e in a \u003cem\u003etranslation unit\u003c/em\u003e is\ncalled an \u003cem\u003eintroduction\u003c/em\u003e [3]. All subsequent \u003cem\u003edeclarations\u003c/em\u003e are called \u003cem\u003eredeclarations\u003c/em\u003e [4].\u003c/p\u003e\n\u003cp\u003eA \u003cem\u003edefinition\u003c/em\u003e [5] is a \u003cem\u003edeclaration\u003c/em\u003e, as described in [basic.def]/2.\u003c/p\u003e\n\u003ch4\u003e[3] Introduction\u003c/h4\u003e\n\u003cp\u003eSee \u003cem\u003edeclaration\u003c/em\u003e [2].\u003c/p\u003e\n\u003ch4\u003e[4] Redeclaration\u003c/h4\u003e\n\u003cp\u003eSee \u003cem\u003edeclaration\u003c/em\u003e [2].\u003c/p\u003e\n\u003ch4\u003e[5] Definition\u003c/h4\u003e\n\u003cp\u003eSee \u003cem\u003edeclaration\u003c/em\u003e [2].\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003e{rule:cpp:S1144} targets the same defect as this rule but for a non-mission-critical context.\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "misra-advisory",
      "misra-c++2023",
      "unused"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:M23_212",
    "name": "The \"#\" and \"##\" preprocessor operators should not be used",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 19.3.1\u003c/p\u003e\n\u003cp\u003eCategory: Advisory\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eThe order of evaluation associated with multiple \u003ccode\u003e#\u003c/code\u003e, multiple \u003ccode\u003e##\u003c/code\u003e or a mix of \u003ccode\u003e#\u003c/code\u003e and \u003ccode\u003e##\u003c/code\u003e\npreprocessor operators is unspecified. It is therefore not always possible to predict the result of macro expansion.\u003c/p\u003e\n\u003cp\u003eThe use of the \u003ccode\u003e##\u003c/code\u003e operator can result in code that is hard to understand.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e MISRA C++ 2023 Rule\u0026nbsp;4.1.3 (There shall be no occurrence of \u003cem\u003eundefined\u003c/em\u003e or \u003cem\u003ecritical unspecified\nbehaviour\u003c/em\u003e) covers the \u003cem\u003eundefined behaviour\u003c/em\u003e that arises if either:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The result of a \u003ccode\u003e#\u003c/code\u003e operator is not a valid string literal; or \u003c/li\u003e\n  \u003cli\u003e The result of a \u003ccode\u003e##\u003c/code\u003e operator is not a valid preprocessing token. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S968} targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2023 Rule\u0026nbsp;4.1.3 - There shall be no occurrence of \u003cem\u003eundefined\u003c/em\u003e or \u003cem\u003ecritical unspecified behaviour\u003c/em\u003e \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2023 Rule\u0026nbsp;19.3.2 - A macro parameter immediately following a \u003ccode\u003e#\u003c/code\u003e operator shall not be immediately followed by a\n  \u003ccode\u003e##\u003c/code\u003e operator \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2023 Rule\u0026nbsp;19.3.3 - The argument to a \u003cem\u003emixed-use macro parameter\u003c/em\u003e shall not be subject to further expansion \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 19.3.1\u003c/p\u003e\n\u003cp\u003eCategory: Advisory\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eThe order of evaluation associated with multiple \u003ccode\u003e#\u003c/code\u003e, multiple \u003ccode\u003e##\u003c/code\u003e or a mix of \u003ccode\u003e#\u003c/code\u003e and \u003ccode\u003e##\u003c/code\u003e\npreprocessor operators is unspecified. It is therefore not always possible to predict the result of macro expansion.\u003c/p\u003e\n\u003cp\u003eThe use of the \u003ccode\u003e##\u003c/code\u003e operator can result in code that is hard to understand.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e MISRA C++ 2023 Rule\u0026nbsp;4.1.3 (There shall be no occurrence of \u003cem\u003eundefined\u003c/em\u003e or \u003cem\u003ecritical unspecified\nbehaviour\u003c/em\u003e) covers the \u003cem\u003eundefined behaviour\u003c/em\u003e that arises if either:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The result of a \u003ccode\u003e#\u003c/code\u003e operator is not a valid string literal; or \u003c/li\u003e\n  \u003cli\u003e The result of a \u003ccode\u003e##\u003c/code\u003e operator is not a valid preprocessing token. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S968} targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2023 Rule\u0026nbsp;4.1.3 - There shall be no occurrence of \u003cem\u003eundefined\u003c/em\u003e or \u003cem\u003ecritical unspecified behaviour\u003c/em\u003e \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2023 Rule\u0026nbsp;19.3.2 - A macro parameter immediately following a \u003ccode\u003e#\u003c/code\u003e operator shall not be immediately followed by a\n  \u003ccode\u003e##\u003c/code\u003e operator \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2023 Rule\u0026nbsp;19.3.3 - The argument to a \u003cem\u003emixed-use macro parameter\u003c/em\u003e shall not be subject to further expansion \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "lock-in",
      "misra-advisory",
      "misra-c++2023"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5213",
    "name": "Template parameters should be preferred to \"std::function\" when configuring behavior at compile time",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "EFFICIENT",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eTo configure an algorithm with a function in C++, you can use one of the following techniques:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e A function pointer (see {rule:cpp:S5205} that explains why it is a bad idea) \u003c/li\u003e\n  \u003cli\u003e An \u003ccode\u003estd::function\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e A template argument \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eHow do you select between an \u003ccode\u003estd::function\u003c/code\u003e and a template argument?\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003estd::function\u003c/code\u003e offers the most flexibility. You can store them in a variable, in a container (as \u003ccode\u003estd::map\u0026lt;string,\nstd::function\u0026lt;void(void)\u0026gt;\u0026gt;\u003c/code\u003e for instance…​ This flexibility is provided by type erasure: A single \u003ccode\u003estd::function\u003c/code\u003e can wrap\nany kind of functor, as long as the signature is compatible. It also comes with a cost: Due to this type erasure, a compiler will typically not be\nable to inline a call to a \u003ccode\u003estd::function\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eTemplate parameters, on the other hand, are less flexible. Each functor has its own type, which prevents storing several of them together even if\nthey all have compatible signatures. But since each template instance knows the type of the functor, calls can be inlined making this a zero-cost\nabstraction.\u003c/p\u003e\n\u003cp\u003eAs a conclusion, if the functor can be known at compile-time, you should prefer using a template parameter, if it has to be dynamic,\n\u003ccode\u003estd::function\u003c/code\u003e will give you greater flexibility.\u003c/p\u003e\n\u003cp\u003eThis rule detects function parameters of type \u003ccode\u003estd::function\u003c/code\u003e that would probably benefit from being replaced by a template parameter.\nIt does so by looking if the functor is only called inside the function, or if it participates in other operations.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nusing Criterion \u003d std::function\u0026lt;bool(DataPoint const\u0026amp;)\u0026gt;;\nvoid filter(DataSet* data, Criterion criterion) { // Noncompliant\n  for (auto \u0026amp;dataPoint : data) {\n    if (criterion(dataPoint)) {\n      data.markForRemoval(dataPoint);\n    }\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\ntemplate\u0026lt;class Criterion\u0026gt;\nvoid filter(DataSet* data, Criterion criterion) { // Compliant\n  for (auto \u0026amp;dataPoint : data) {\n    if (criterion(dataPoint)) {\n      data.markForRemoval(dataPoint);\n    }\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThis rule ignores virtual functions, that don’t work well with templates.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#t49-where-possible-avoid-type-erasure\"\u003eT.49: Where possible,\n  avoid type-erasure\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eTo configure an algorithm with a function in C++, you can use one of the following techniques:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e A function pointer (see {rule:cpp:S5205} that explains why it is a bad idea) \u003c/li\u003e\n  \u003cli\u003e An \u003ccode\u003estd::function\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e A template argument \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eHow do you select between an \u003ccode\u003estd::function\u003c/code\u003e and a template argument?\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003estd::function\u003c/code\u003e offers the most flexibility. You can store them in a variable, in a container (as \u003ccode\u003estd::map\u0026lt;string,\nstd::function\u0026lt;void(void)\u0026gt;\u0026gt;\u003c/code\u003e for instance…​ This flexibility is provided by type erasure: A single \u003ccode\u003estd::function\u003c/code\u003e can wrap\nany kind of functor, as long as the signature is compatible. It also comes with a cost: Due to this type erasure, a compiler will typically not be\nable to inline a call to a \u003ccode\u003estd::function\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eTemplate parameters, on the other hand, are less flexible. Each functor has its own type, which prevents storing several of them together even if\nthey all have compatible signatures. But since each template instance knows the type of the functor, calls can be inlined making this a zero-cost\nabstraction.\u003c/p\u003e\n\u003cp\u003eAs a conclusion, if the functor can be known at compile-time, you should prefer using a template parameter, if it has to be dynamic,\n\u003ccode\u003estd::function\u003c/code\u003e will give you greater flexibility.\u003c/p\u003e\n\u003cp\u003eThis rule detects function parameters of type \u003ccode\u003estd::function\u003c/code\u003e that would probably benefit from being replaced by a template parameter.\nIt does so by looking if the functor is only called inside the function, or if it participates in other operations.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nusing Criterion \u003d std::function\u0026lt;bool(DataPoint const\u0026amp;)\u0026gt;;\nvoid filter(DataSet* data, Criterion criterion) { // Noncompliant\n  for (auto \u0026amp;dataPoint : data) {\n    if (criterion(dataPoint)) {\n      data.markForRemoval(dataPoint);\n    }\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\ntemplate\u0026lt;class Criterion\u0026gt;\nvoid filter(DataSet* data, Criterion criterion) { // Compliant\n  for (auto \u0026amp;dataPoint : data) {\n    if (criterion(dataPoint)) {\n      data.markForRemoval(dataPoint);\n    }\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThis rule ignores virtual functions, that don’t work well with templates.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#t49-where-possible-avoid-type-erasure\"\u003eT.49: Where possible,\n  avoid type-erasure\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "bad-practice",
      "cppcoreguidelines",
      "performance"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S112",
    "name": "Generic exceptions should never be thrown",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003cp\u003eThis rule raises an issue when a generic exception (such as \u003ccode\u003estd::exception\u003c/code\u003e, \u003ccode\u003estd::logic_error\u003c/code\u003e or\n\u003ccode\u003estd::runtime_error\u003c/code\u003e) is thrown.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThrowing generic exceptions such as \u003ccode\u003estd::exception\u003c/code\u003e, \u003ccode\u003estd::logic_error\u003c/code\u003e and \u003ccode\u003estd::runtime_error\u003c/code\u003e will have a\nnegative impact on any code trying to catch these exceptions.\u003c/p\u003e\n\u003cp\u003eFrom a consumer perspective, it is generally a best practice to only catch exceptions you intend to handle. Other exceptions should ideally not be\ncaught and let propagate up the stack trace so that they can be dealt with appropriately. When a generic exception is thrown, it forces consumers to\ncatch exceptions they do not intend to handle, which they then have to re-throw.\u003c/p\u003e\n\u003cp\u003eBesides, when working with a generic type of exception, the only way to distinguish between multiple exceptions is to check their message, which is\nerror-prone and difficult to maintain. Legitimate exceptions may be unintentionally silenced and errors may be hidden.\u003c/p\u003e\n\u003cp\u003eFor instance, in the following code, the fact that \u003ccode\u003echeckState\u003c/code\u003e throws a generic exception leads us to catch a permission error that\nshouldn’t have been caught:\u003c/p\u003e\n\u003cpre\u003e\nvoid openFile(File\u0026amp; file) {\n  if (!has_permissions(file)) {\n    throw std::invalid_argument(\"Couldn\u0027t open file\");\n  }\n  // ...\n}\n\nvoid checkState(File const\u0026amp; file) {\n  if (!file.is_valid()) {\n    throw std::exception();  // Noncompliant\n  }\n  // ...\n}\n\nvoid test(File file) {\n  try {\n    openFile(file);\n    checkState(false);\n    closeFile(file);\n  } catch (std::exception\u0026amp; s) {\n    // If we don\u0027t have the correct permissions to open, the\n    // invalid_argument exception will be caught and we will try closing a\n    // file that was never opened\n    closeFile(file);\n  }\n}\n\u003c/pre\u003e\n\u003cp\u003eTherefore, throwing the most specific exception possible is recommended so consumers can handle it intentionally.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eTo fix this issue, make sure to throw specific exceptions that are relevant to the context in which they arise. It is recommended to either:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Throw a subtype of \u003ccode\u003estd::exception\u003c/code\u003e when one matches. For instance, \u003ccode\u003estd::invalid_argument\u003c/code\u003e could be raised when an\n  unexpected argument is provided to a function. \u003c/li\u003e\n  \u003cli\u003e Define a custom exception type that derives from \u003ccode\u003estd::exception\u003c/code\u003e or one of its subclasses. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;stdexcept\u0026gt;\n\nvoid checkState(S state) {\n    if (!state.is_valid()) {\n        throw std::exception(\"State is invalid\"); // Noncompliant: this will be difficult for consumers to handle\n    }\n    // ...\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eThe solution below involves throwing \u003ccode\u003estd::invalid_argument\u003c/code\u003e, which is an appropriate exception type for this situation:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;stdexcept\u0026gt;\n\nvoid checkState(S state) {\n    if (!state.is_valid()) {\n        throw std::invalid_argument(\"State is invalid\"); // Compliant\n    }\n    // ...\n}\n\u003c/pre\u003e\n\u003cp\u003eAlternatively, one can define a custom \u003ccode\u003einvalid_state\u003c/code\u003e exception that can be caught specifically:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nstruct invalid_state : public std::exception {};\n\nvoid checkState(S state) {\n    if (!state.is_valid()) {\n        throw invalide_state(); // Compliant\n    }\n    // ...\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/397\"\u003e397 Declaration of Throws for Generic Exception\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#e14-use-purpose-designed-user-defined-types-as-exceptions-not-built-in-types\"\u003eE.14: Use purpose-designed user-defined types as exceptions (not built-in types)\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S1181} - Generic exceptions should not be caught \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eThis rule raises an issue when a generic exception (such as \u003ccode\u003estd::exception\u003c/code\u003e, \u003ccode\u003estd::logic_error\u003c/code\u003e or\n\u003ccode\u003estd::runtime_error\u003c/code\u003e) is thrown.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThrowing generic exceptions such as \u003ccode\u003estd::exception\u003c/code\u003e, \u003ccode\u003estd::logic_error\u003c/code\u003e and \u003ccode\u003estd::runtime_error\u003c/code\u003e will have a\nnegative impact on any code trying to catch these exceptions.\u003c/p\u003e\n\u003cp\u003eFrom a consumer perspective, it is generally a best practice to only catch exceptions you intend to handle. Other exceptions should ideally not be\ncaught and let propagate up the stack trace so that they can be dealt with appropriately. When a generic exception is thrown, it forces consumers to\ncatch exceptions they do not intend to handle, which they then have to re-throw.\u003c/p\u003e\n\u003cp\u003eBesides, when working with a generic type of exception, the only way to distinguish between multiple exceptions is to check their message, which is\nerror-prone and difficult to maintain. Legitimate exceptions may be unintentionally silenced and errors may be hidden.\u003c/p\u003e\n\u003cp\u003eFor instance, in the following code, the fact that \u003ccode\u003echeckState\u003c/code\u003e throws a generic exception leads us to catch a permission error that\nshouldn’t have been caught:\u003c/p\u003e\n\u003cpre\u003e\nvoid openFile(File\u0026amp; file) {\n  if (!has_permissions(file)) {\n    throw std::invalid_argument(\"Couldn\u0027t open file\");\n  }\n  // ...\n}\n\nvoid checkState(File const\u0026amp; file) {\n  if (!file.is_valid()) {\n    throw std::exception();  // Noncompliant\n  }\n  // ...\n}\n\nvoid test(File file) {\n  try {\n    openFile(file);\n    checkState(false);\n    closeFile(file);\n  } catch (std::exception\u0026amp; s) {\n    // If we don\u0027t have the correct permissions to open, the\n    // invalid_argument exception will be caught and we will try closing a\n    // file that was never opened\n    closeFile(file);\n  }\n}\n\u003c/pre\u003e\n\u003cp\u003eTherefore, throwing the most specific exception possible is recommended so consumers can handle it intentionally.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eTo fix this issue, make sure to throw specific exceptions that are relevant to the context in which they arise. It is recommended to either:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Throw a subtype of \u003ccode\u003estd::exception\u003c/code\u003e when one matches. For instance, \u003ccode\u003estd::invalid_argument\u003c/code\u003e could be raised when an\n  unexpected argument is provided to a function. \u003c/li\u003e\n  \u003cli\u003e Define a custom exception type that derives from \u003ccode\u003estd::exception\u003c/code\u003e or one of its subclasses. \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;stdexcept\u0026gt;\n\nvoid checkState(S state) {\n    if (!state.is_valid()) {\n        throw std::exception(\"State is invalid\"); // Noncompliant: this will be difficult for consumers to handle\n    }\n    // ...\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eThe solution below involves throwing \u003ccode\u003estd::invalid_argument\u003c/code\u003e, which is an appropriate exception type for this situation:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;stdexcept\u0026gt;\n\nvoid checkState(S state) {\n    if (!state.is_valid()) {\n        throw std::invalid_argument(\"State is invalid\"); // Compliant\n    }\n    // ...\n}\n\u003c/pre\u003e\n\u003cp\u003eAlternatively, one can define a custom \u003ccode\u003einvalid_state\u003c/code\u003e exception that can be caught specifically:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nstruct invalid_state : public std::exception {};\n\nvoid checkState(S state) {\n    if (!state.is_valid()) {\n        throw invalide_state(); // Compliant\n    }\n    // ...\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/397\"\u003e397 Declaration of Throws for Generic Exception\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#e14-use-purpose-designed-user-defined-types-as-exceptions-not-built-in-types\"\u003eE.14: Use purpose-designed user-defined types as exceptions (not built-in types)\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S1181} - Generic exceptions should not be caught \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cert",
      "cppcoreguidelines",
      "cwe",
      "error-handling"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S2068",
    "name": "Hard-coded credentials are security-sensitive",
    "defaultSeverity": "BLOCKER",
    "type": "SECURITY_HOTSPOT",
    "cleanCodeAttribute": "TRUSTWORTHY",
    "defaultImpacts": {
      "SECURITY": "HIGH"
    },
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eBecause it is easy to extract strings from an application source code or binary, credentials should not be hard-coded. This is particularly true\nfor applications that are distributed or that are open-source.\u003c/p\u003e\n\u003cp\u003eIn the past, it has led to the following vulnerabilities:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"http://cve.mitre.org/cgi-bin/cvename.cgi?name\u003dCVE-2019-13466\"\u003eCVE-2019-13466\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"http://cve.mitre.org/cgi-bin/cvename.cgi?name\u003dCVE-2018-15389\"\u003eCVE-2018-15389\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eCredentials should be stored outside of the code in a configuration file, a database, or a management service for secrets.\u003c/p\u003e\n\u003cp\u003eThis rule looks for hard-coded credentials in variable names that match any of the patterns from the provided list.\u003c/p\u003e"
      },
      {
        "key": "assess_the_problem",
        "htmlContent": "\u003ch2\u003eAsk Yourself Whether\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e Credentials allow access to a sensitive component like a database, a file storage, an API or a service. \u003c/li\u003e\n  \u003cli\u003e Credentials are used in production environments. \u003c/li\u003e\n  \u003cli\u003e Application re-distribution is required before updating the credentials. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere is a risk if you answered yes to any of those questions.\u003c/p\u003e\n\u003ch2\u003eSensitive Code Example\u003c/h2\u003e\n\u003cpre\u003e\ndbi_conn conn \u003d dbi_conn_new(\"mysql\");\nstring password \u003d \"secret\"; // Sensitive\ndbi_conn_set_option(conn, \"password\", password.c_str());\n\u003c/pre\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003ch2\u003eRecommended Secure Coding Practices\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e Store the credentials in a configuration file that is not pushed to the code repository. \u003c/li\u003e\n  \u003cli\u003e Store the credentials in a database. \u003c/li\u003e\n  \u003cli\u003e Use your cloud provider’s service for managing secrets. \u003c/li\u003e\n  \u003cli\u003e If a password has been disclosed through the source code: change it. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eCompliant Solution\u003c/h2\u003e\n\u003cpre\u003e\ndbi_conn conn \u003d dbi_conn_new(\"mysql\");\nstring password \u003d getDatabasePassword(); // Compliant\ndbi_conn_set_option(conn, \"password\", password.c_str()); // Compliant\n\u003c/pre\u003e\n\u003ch2\u003eSee\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures/\"\u003eOWASP Top 10 2021 Category A7\u003c/a\u003e - Identification and\n  Authentication Failures \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/www-project-top-ten/2017/A2_2017-Broken_Authentication\"\u003eOWASP Top 10 2017 Category A2\u003c/a\u003e - Broken Authentication\n  \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/798\"\u003eMITRE, CWE-798\u003c/a\u003e - Use of Hard-coded Credentials \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/259\"\u003eMITRE, CWE-259\u003c/a\u003e - Use of Hard-coded Password \u003c/li\u003e\n  \u003cli\u003e Derived from FindSecBugs rule \u003ca href\u003d\"https://h3xstream.github.io/find-sec-bugs/bugs.htm#HARD_CODE_PASSWORD\"\u003eHard Coded Password\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cert",
      "cwe"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": [],
    "vulnerabilityProbability": "HIGH"
  },
  {
    "key": "cpp:S5332",
    "name": "Using clear-text protocols is security-sensitive",
    "defaultSeverity": "CRITICAL",
    "type": "SECURITY_HOTSPOT",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "SECURITY": "HIGH"
    },
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eClear-text protocols such as \u003ccode\u003eftp\u003c/code\u003e, \u003ccode\u003etelnet\u003c/code\u003e, or \u003ccode\u003ehttp\u003c/code\u003e lack encryption of transported data, as well as the\ncapability to build an authenticated connection. It means that an attacker able to sniff traffic from the network can read, modify, or corrupt the\ntransported content. These protocols are not secure as they expose applications to an extensive range of risks:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e sensitive data exposure \u003c/li\u003e\n  \u003cli\u003e traffic redirected to a malicious endpoint \u003c/li\u003e\n  \u003cli\u003e malware-infected software update or installer \u003c/li\u003e\n  \u003cli\u003e execution of client-side code \u003c/li\u003e\n  \u003cli\u003e corruption of critical information \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eEven in the context of isolated networks like offline environments or segmented cloud environments, the insider threat exists. Thus, attacks\ninvolving communications being sniffed or tampered with can still happen.\u003c/p\u003e\n\u003cp\u003eFor example, attackers could successfully compromise prior security layers by:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e bypassing isolation mechanisms \u003c/li\u003e\n  \u003cli\u003e compromising a component of the network \u003c/li\u003e\n  \u003cli\u003e getting the credentials of an internal IAM account (either from a service account or an actual person) \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn such cases, encrypting communications would decrease the chances of attackers to successfully leak data or steal credentials from other network\ncomponents. By layering various security practices (segmentation and encryption, for example), the application will follow the\n\u003cem\u003edefense-in-depth\u003c/em\u003e principle.\u003c/p\u003e\n\u003cp\u003eNote that using the \u003ccode\u003ehttp\u003c/code\u003e protocol is being deprecated by \u003ca\nhref\u003d\"https://blog.mozilla.org/security/2015/04/30/deprecating-non-secure-http\"\u003emajor web browsers\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eIn the past, it has led to the following vulnerabilities:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://nvd.nist.gov/vuln/detail/CVE-2019-6169\"\u003eCVE-2019-6169\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://nvd.nist.gov/vuln/detail/CVE-2019-12327\"\u003eCVE-2019-12327\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://nvd.nist.gov/vuln/detail/CVE-2019-11065\"\u003eCVE-2019-11065\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eExceptions\u003c/h2\u003e\n\u003cp\u003eNo issue is reported for the following cases because they are not considered sensitive:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Insecure protocol scheme followed by loopback addresses like 127.0.0.1 or \u003ccode\u003elocalhost\u003c/code\u003e. \u003c/li\u003e\n\u003c/ul\u003e"
      },
      {
        "key": "assess_the_problem",
        "htmlContent": "\u003ch2\u003eAsk Yourself Whether\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e Application data needs to be protected against falsifications or leaks when transiting over the network. \u003c/li\u003e\n  \u003cli\u003e Application data transits over an untrusted network. \u003c/li\u003e\n  \u003cli\u003e Compliance rules require the service to encrypt data in transit. \u003c/li\u003e\n  \u003cli\u003e Your application renders web pages with a relaxed mixed content policy. \u003c/li\u003e\n  \u003cli\u003e OS-level protections against clear-text traffic are deactivated. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere is a risk if you answered yes to any of those questions.\u003c/p\u003e\n\u003ch2\u003eSensitive Code Example\u003c/h2\u003e\n\u003cpre\u003e\nchar* http_url \u003d \"http://example.com\"; // Sensitive\nchar* ftp_url \u003d \"ftp://anonymous@example.com\"; // Sensitive\nchar* telnet_url \u003d \"telnet://anonymous@example.com\"; // Sensitive\n\u003c/pre\u003e\n\u003cpre\u003e\n#include \u0026lt;curl/curl.h\u0026gt;\n\nCURL *curl_ftp \u003d curl_easy_init();\ncurl_easy_setopt(curl_ftp, CURLOPT_URL, \"ftp://example.com/\"); // Sensitive\n\nCURL *curl_smtp \u003d curl_easy_init();\ncurl_easy_setopt(curl_smtp, CURLOPT_URL, \"smtp://example.com:587\"); // Sensitive\n\u003c/pre\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003ch2\u003eRecommended Secure Coding Practices\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e Make application data transit over a secure, authenticated and encrypted protocol like TLS or SSH. Here are a few alternatives to the most\n  common clear-text protocols:\n    \u003cul\u003e\n      \u003cli\u003e Use \u003ccode\u003essh\u003c/code\u003e as an alternative to \u003ccode\u003etelnet\u003c/code\u003e. \u003c/li\u003e\n      \u003cli\u003e Use \u003ccode\u003esftp\u003c/code\u003e, \u003ccode\u003escp\u003c/code\u003e, or \u003ccode\u003eftps\u003c/code\u003e instead of \u003ccode\u003eftp\u003c/code\u003e. \u003c/li\u003e\n      \u003cli\u003e Use \u003ccode\u003ehttps\u003c/code\u003e instead of \u003ccode\u003ehttp\u003c/code\u003e. \u003c/li\u003e\n      \u003cli\u003e Use \u003ccode\u003eSMTP\u003c/code\u003e over \u003ccode\u003eSSL/TLS\u003c/code\u003e or \u003ccode\u003eSMTP\u003c/code\u003e with \u003ccode\u003eSTARTTLS\u003c/code\u003e instead of clear-text SMTP. \u003c/li\u003e\n    \u003c/ul\u003e  \u003c/li\u003e\n  \u003cli\u003e Enable encryption of cloud components communications whenever it is possible. \u003c/li\u003e\n  \u003cli\u003e Configure your application to block mixed content when rendering web pages. \u003c/li\u003e\n  \u003cli\u003e If available, enforce OS-level deactivation of all clear-text traffic. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIt is recommended to secure all transport channels, even on local networks, as it can take a single non-secure connection to compromise an entire\napplication or system.\u003c/p\u003e\n\u003ch2\u003eCompliant Solution\u003c/h2\u003e\n\u003cpre\u003e\nchar* https_url \u003d \"https://example.com\";\nchar* sftp_url \u003d \"sftp://anonymous@example.com\";\nchar* ssh_url \u003d \"ssh://anonymous@example.com\";\n\u003c/pre\u003e\n\u003cpre\u003e\n#include \u0026lt;curl/curl.h\u0026gt;\n\nCURL *curl_ftps \u003d curl_easy_init();\ncurl_easy_setopt(curl_ftps, CURLOPT_URL, \"ftp://example.com/\");\ncurl_easy_setopt(curl_ftps, CURLOPT_USE_SSL, CURLUSESSL_ALL); // FTP transport is done over TLS\n\nCURL *curl_smtp_tls \u003d curl_easy_init();\ncurl_easy_setopt(curl_smtp_tls, CURLOPT_URL, \"smtp://example.com:587\");\ncurl_easy_setopt(curl_smtp_tls, CURLOPT_USE_SSL, CURLUSESSL_ALL); // SMTP with STARTTLS\n\u003c/pre\u003e\n\u003ch2\u003eSee\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/Top10/A02_2021-Cryptographic_Failures/\"\u003eOWASP Top 10 2021 Category A2\u003c/a\u003e - Cryptographic Failures \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://www.owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\"\u003eOWASP Top 10 2017 Category A3\u003c/a\u003e - Sensitive Data\n  Exposure \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://mobile-security.gitbook.io/masvs/security-requirements/0x10-v5-network_communication_requirements\"\u003eMobile AppSec Verification\n  Standard\u003c/a\u003e - Network Communication Requirements \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/www-project-mobile-top-10/2016-risks/m3-insecure-communication\"\u003eOWASP Mobile Top 10 2016 Category M3\u003c/a\u003e - Insecure\n  Communication \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/200\"\u003eMITRE, CWE-200\u003c/a\u003e - Exposure of Sensitive Information to an Unauthorized Actor \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/319\"\u003eMITRE, CWE-319\u003c/a\u003e - Cleartext Transmission of Sensitive Information \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://security.googleblog.com/2016/09/moving-towards-more-secure-web.html\"\u003eGoogle, Moving towards more secure web\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://blog.mozilla.org/security/2015/04/30/deprecating-non-secure-http/\"\u003eMozilla, Deprecating non secure http\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://docs.aws.amazon.com/elasticloadbalancing/latest/application/load-balancer-listeners.html\"\u003eAWS Documentation\u003c/a\u003e - Listeners\n  for your Application Load Balancers \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-kinesis-stream-streamencryption.html\"\u003eAWS\n  Documentation\u003c/a\u003e - Stream Encryption \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cwe",
      "symbolic-execution"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": [],
    "vulnerabilityProbability": "LOW"
  },
  {
    "key": "cpp:S110",
    "name": "Inheritance tree of classes should not be too deep",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "FOCUSED",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eInheritance is one of the most valuable concepts in object-oriented programming. It’s a way to categorize and reuse code by creating collections of\nattributes and behaviors called classes, which can be based on previously created classes.\u003c/p\u003e\n\u003cp\u003eBut abusing this concept by creating a deep inheritance tree can lead to complex and unmaintainable source code. Often, an inheritance tree\nbecoming too deep is the symptom of systematic use of \"inheritance\" when other approaches like \"composition\" would be better suited.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when the inheritance tree has a greater depth than is allowed.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cp\u003e\u003ca href\u003d\"https://en.wikipedia.org/wiki/Composition_over_inheritance\"\u003eComposition over inheritance: difference between composition and inheritance\nin object-oriented programming\u003c/a\u003e\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eInheritance is one of the most valuable concepts in object-oriented programming. It’s a way to categorize and reuse code by creating collections of\nattributes and behaviors called classes, which can be based on previously created classes.\u003c/p\u003e\n\u003cp\u003eBut abusing this concept by creating a deep inheritance tree can lead to complex and unmaintainable source code. Often, an inheritance tree\nbecoming too deep is the symptom of systematic use of \"inheritance\" when other approaches like \"composition\" would be better suited.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when the inheritance tree has a greater depth than is allowed.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cp\u003e\u003ca href\u003d\"https://en.wikipedia.org/wiki/Composition_over_inheritance\"\u003eComposition over inheritance: difference between composition and inheritance\nin object-oriented programming\u003c/a\u003e\u003c/p\u003e"
      }
    ],
    "params": {
      "max": {
        "key": "max",
        "name": "max",
        "description": "Maximum depth of the inheritance tree. (Number)",
        "defaultValue": "5",
        "type": "INTEGER",
        "multiple": false,
        "possibleValues": []
      }
    },
    "defaultParams": {
      "max": "5"
    },
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "design"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6427",
    "name": "Assigning to an optional should directly target the optional",
    "defaultSeverity": "BLOCKER",
    "type": "BUG",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe class \u003ccode\u003estd::optional\u0026lt;T\u0026gt;\u003c/code\u003e either stores a value of type \u003ccode\u003eT\u003c/code\u003e or is empty.\u003c/p\u003e\n\u003cp\u003eOne way to access the value of a non-empty optional is the \u003ccode\u003eoperator*\u003c/code\u003e. But using the dereference operator gives the optional appearance\nof a pointer when it is not: it models an object. Additionally, attempting to call the \u003ccode\u003eoperator*\u003c/code\u003e on an empty optional will result in\nundefined behavior.\u003c/p\u003e\n\u003cp\u003eAnother way to access the value of a non-empty optional is the function \u003ccode\u003evalue()\u003c/code\u003e. But assigning a value to the optional object through\nthis function will throw an exception (\u003ccode\u003estd::bad_optional_access\u003c/code\u003e) if the optional has no value, and the assignment will not happen.\u003c/p\u003e\n\u003cp\u003eFor the assignment of an optional to happen correctly, whatever its state, it is better to:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e assign the value directly with the \u003ccode\u003eoperator\u003d\u003c/code\u003e: e.g. \u003ccode\u003emyOptionalInteger \u003d 3;\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e use the \u003ccode\u003eemplace\u003c/code\u003e function (for example, when the move or copy operation is expensive or forbidden). \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eThe rule raises an issue when the \u003ccode\u003eoperator*\u003c/code\u003e or the \u003ccode\u003evalue()\u003c/code\u003e function are used to assign a new value to an optional.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid g(std::optional\u0026lt;int\u0026gt; \u0026amp;val, bool b) {\n    if (b) {\n      *val \u003d 314; // Noncompliant; the behavior is undefined if the optional is empty.\n    } else {\n      val.value() \u003d 42; // Noncompliant; it will throw if the optional is empty.\n    }\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid g(std::optional\u0026lt;int\u0026gt; \u0026amp;val, bool b) {\n    if (b) {\n      val \u003d 314; // Compliant\n    } else {\n      val \u003d 42; // Compliant\n    }\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/utility/optional\"\u003estd::optional\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe class \u003ccode\u003estd::optional\u0026lt;T\u0026gt;\u003c/code\u003e either stores a value of type \u003ccode\u003eT\u003c/code\u003e or is empty.\u003c/p\u003e\n\u003cp\u003eOne way to access the value of a non-empty optional is the \u003ccode\u003eoperator*\u003c/code\u003e. But using the dereference operator gives the optional appearance\nof a pointer when it is not: it models an object. Additionally, attempting to call the \u003ccode\u003eoperator*\u003c/code\u003e on an empty optional will result in\nundefined behavior.\u003c/p\u003e\n\u003cp\u003eAnother way to access the value of a non-empty optional is the function \u003ccode\u003evalue()\u003c/code\u003e. But assigning a value to the optional object through\nthis function will throw an exception (\u003ccode\u003estd::bad_optional_access\u003c/code\u003e) if the optional has no value, and the assignment will not happen.\u003c/p\u003e\n\u003cp\u003eFor the assignment of an optional to happen correctly, whatever its state, it is better to:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e assign the value directly with the \u003ccode\u003eoperator\u003d\u003c/code\u003e: e.g. \u003ccode\u003emyOptionalInteger \u003d 3;\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e use the \u003ccode\u003eemplace\u003c/code\u003e function (for example, when the move or copy operation is expensive or forbidden). \u003c/li\u003e\n\u003c/ul\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eThe rule raises an issue when the \u003ccode\u003eoperator*\u003c/code\u003e or the \u003ccode\u003evalue()\u003c/code\u003e function are used to assign a new value to an optional.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid g(std::optional\u0026lt;int\u0026gt; \u0026amp;val, bool b) {\n    if (b) {\n      *val \u003d 314; // Noncompliant; the behavior is undefined if the optional is empty.\n    } else {\n      val.value() \u003d 42; // Noncompliant; it will throw if the optional is empty.\n    }\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid g(std::optional\u0026lt;int\u0026gt; \u0026amp;val, bool b) {\n    if (b) {\n      val \u003d 314; // Compliant\n    } else {\n      val \u003d 42; // Compliant\n    }\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/utility/optional\"\u003estd::optional\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "since-c++17"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S139",
    "name": "Comments should not be located at the end of lines of code",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "FORMATTED",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThis rule verifies that single-line comments are not located at the ends of lines of code. The main idea behind this rule is that in order to be\nreally readable, trailing comments would have to be properly written and formatted (correct alignment, no interference with the visual structure of\nthe code, not too long to be visible) but most often, automatic code formatters would not handle this correctly: the code would end up less readable.\nComments are far better placed on the previous empty line of code, where they will always be visible and properly formatted.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\na \u003d b + c;   // This is a trailing comment that could be very very long\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n// This very long comment is better placed before the line of code\na \u003d b + c;\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThe rule will not raise an issue if the trailing comment is preceded by an opening brace, closing brace (optionally followed by a semicolon) or a\npreprocessor directive.\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThis rule verifies that single-line comments are not located at the ends of lines of code. The main idea behind this rule is that in order to be\nreally readable, trailing comments would have to be properly written and formatted (correct alignment, no interference with the visual structure of\nthe code, not too long to be visible) but most often, automatic code formatters would not handle this correctly: the code would end up less readable.\nComments are far better placed on the previous empty line of code, where they will always be visible and properly formatted.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\na \u003d b + c;   // This is a trailing comment that could be very very long\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n// This very long comment is better placed before the line of code\na \u003d b + c;\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThe rule will not raise an issue if the trailing comment is preceded by an opening brace, closing brace (optionally followed by a semicolon) or a\npreprocessor directive.\u003c/p\u003e"
      }
    ],
    "params": {
      "legalTrailingCommentPattern": {
        "key": "legalTrailingCommentPattern",
        "name": "legalTrailingCommentPattern",
        "description": "POSIX regular expression for text of trailing comments that are allowed. By default, comments containing only one word.",
        "defaultValue": "^[ \\t\\n\\r\\f\\v]*[^ \\t\\n\\r\\f\\v]+$",
        "type": "STRING",
        "multiple": false,
        "possibleValues": []
      }
    },
    "defaultParams": {
      "legalTrailingCommentPattern": "^[ \\t\\n\\r\\f\\v]*[^ \\t\\n\\r\\f\\v]+$"
    },
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "convention"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6171",
    "name": "\"contains\" should be used to check if a key exists in a container",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eC++20 introduces the member function \u003ccode\u003econtains\u003c/code\u003e on associative containers to check if an equivalent to a specific key already exists in\nthe container.\u003c/p\u003e\n\u003cp\u003eCalling this function can replace previous ways to check if a key is present in a container:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e call \u003ccode\u003efind()\u003c/code\u003e and check that its result is not the end of the container. This was quite verbose. \u003c/li\u003e\n  \u003cli\u003e call \u003ccode\u003ecount()\u003c/code\u003e. This did not clearly express the intent and was not optimal in terms of performance for containers that allow a key\n  to be present multiple times. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis rule raises an issue when \u003ccode\u003econtains\u003c/code\u003e could be used to simplify the code.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid f1(std::set\u0026lt;int\u0026gt; \u0026amp;s) {\n  if (s.find(1) \u003d\u003d s.end()) { // Noncompliant\n      doSomething();\n  }\n}\n\nvoid f2(std::unordered_map\u0026lt;std::string, int\u0026gt; \u0026amp;m) {\n  if (m.count(\"key\") !\u003d 0) { // Noncompliant\n      doSomething();\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid f1(std::set\u0026lt;int\u0026gt; \u0026amp;s) {\n  if (!s.contains(1)) { // Compliant\n      doSomething();\n  }\n}\n\nvoid f2(std::unordered_map\u0026lt;std::string, int\u0026gt; \u0026amp;m) {\n  if (m.contains(\"key\")) { // Compliant\n      doSomething();\n  }\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eC++20 introduces the member function \u003ccode\u003econtains\u003c/code\u003e on associative containers to check if an equivalent to a specific key already exists in\nthe container.\u003c/p\u003e\n\u003cp\u003eCalling this function can replace previous ways to check if a key is present in a container:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e call \u003ccode\u003efind()\u003c/code\u003e and check that its result is not the end of the container. This was quite verbose. \u003c/li\u003e\n  \u003cli\u003e call \u003ccode\u003ecount()\u003c/code\u003e. This did not clearly express the intent and was not optimal in terms of performance for containers that allow a key\n  to be present multiple times. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis rule raises an issue when \u003ccode\u003econtains\u003c/code\u003e could be used to simplify the code.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid f1(std::set\u0026lt;int\u0026gt; \u0026amp;s) {\n  if (s.find(1) \u003d\u003d s.end()) { // Noncompliant\n      doSomething();\n  }\n}\n\nvoid f2(std::unordered_map\u0026lt;std::string, int\u0026gt; \u0026amp;m) {\n  if (m.count(\"key\") !\u003d 0) { // Noncompliant\n      doSomething();\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid f1(std::set\u0026lt;int\u0026gt; \u0026amp;s) {\n  if (!s.contains(1)) { // Compliant\n      doSomething();\n  }\n}\n\nvoid f2(std::unordered_map\u0026lt;std::string, int\u0026gt; \u0026amp;m) {\n  if (m.contains(\"key\")) { // Compliant\n      doSomething();\n  }\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "clumsy",
      "since-c++20"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6172",
    "name": "Designated initializers should be used in their C++ compliant form",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eC++20 introduced a restricted form of designated initializers for aggregates (i.e., arrays or classes that respect specific criteria). Designated\ninitializers enable the initialization of aggregates by naming their fields explicitly:\u003c/p\u003e\n\u003cpre\u003e\nstruct Point {\n  float x \u003d 0.0;\n  float y \u003d 0.0;\n  float z \u003d 0.0;\n};\n\nPoint p \u003d {\n  .x \u003d 1.0,\n  .y \u003d 2.0,\n  // z will be 0.0\n};\n\u003c/pre\u003e\n\u003cp\u003eThis initialization style is similar to designated initializers in C and many C++ compiler extensions predating C++20.\u003c/p\u003e\n\u003cp\u003eHowever, it is more restricted because some forms are not supported by the C++20 standard, namely:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e listing the fields out of order \u003c/li\u003e\n  \u003cli\u003e array initialization (including sparse array initialization) \u003c/li\u003e\n  \u003cli\u003e initialization of nested fields \u003c/li\u003e\n  \u003cli\u003e mixed initialization \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis rule reports non-C++-compliant forms of designated initializers.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nstruct A { int x, y; };\nstruct B { struct A a; };\n\nstruct A a \u003d {.y \u003d 1, .x \u003d 2}; // Noncompliant: valid C, invalid C++ (out of order)\nint arr[3] \u003d {[1] \u003d 5};        // Noncompliant: valid C, invalid C++ (array)\nstruct B b \u003d {.a.x \u003d 0};       // Noncompliant: valid C, invalid C++ (nested)\nstruct A c \u003d {.x \u003d 1, 2};      // Noncompliant: valid C, invalid C++ (mixed)\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nstruct A { int x, y; };\nstruct B { struct A a; };\n\nstruct A a \u003d {.x \u003d 2, .y \u003d 1};\nint arr[3] \u003d {0, 5};\nstruct B b \u003d {.a \u003d {.x \u003d 0}};\nstruct A c \u003d {.x \u003d 1, .y \u003d 2};\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eC++20 introduced a restricted form of designated initializers for aggregates (i.e., arrays or classes that respect specific criteria). Designated\ninitializers enable the initialization of aggregates by naming their fields explicitly:\u003c/p\u003e\n\u003cpre\u003e\nstruct Point {\n  float x \u003d 0.0;\n  float y \u003d 0.0;\n  float z \u003d 0.0;\n};\n\nPoint p \u003d {\n  .x \u003d 1.0,\n  .y \u003d 2.0,\n  // z will be 0.0\n};\n\u003c/pre\u003e\n\u003cp\u003eThis initialization style is similar to designated initializers in C and many C++ compiler extensions predating C++20.\u003c/p\u003e\n\u003cp\u003eHowever, it is more restricted because some forms are not supported by the C++20 standard, namely:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e listing the fields out of order \u003c/li\u003e\n  \u003cli\u003e array initialization (including sparse array initialization) \u003c/li\u003e\n  \u003cli\u003e initialization of nested fields \u003c/li\u003e\n  \u003cli\u003e mixed initialization \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis rule reports non-C++-compliant forms of designated initializers.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nstruct A { int x, y; };\nstruct B { struct A a; };\n\nstruct A a \u003d {.y \u003d 1, .x \u003d 2}; // Noncompliant: valid C, invalid C++ (out of order)\nint arr[3] \u003d {[1] \u003d 5};        // Noncompliant: valid C, invalid C++ (array)\nstruct B b \u003d {.a.x \u003d 0};       // Noncompliant: valid C, invalid C++ (nested)\nstruct A c \u003d {.x \u003d 1, 2};      // Noncompliant: valid C, invalid C++ (mixed)\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nstruct A { int x, y; };\nstruct B { struct A a; };\n\nstruct A a \u003d {.x \u003d 2, .y \u003d 1};\nint arr[3] \u003d {0, 5};\nstruct B b \u003d {.a \u003d {.x \u003d 0}};\nstruct A c \u003d {.x \u003d 1, .y \u003d 2};\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6177",
    "name": "\"using enum\" should be used in scopes with high concentration of \"enum\" constants",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eC++20 extends the \u003ccode\u003eusing\u003c/code\u003e declaration to \u003ccode\u003eclass enum\u003c/code\u003e. \u003ccode\u003eusing enum\u003c/code\u003e introduces all the \u003ccode\u003eenum\u003c/code\u003e constants\ninto the current scope.\u003c/p\u003e\n\u003cpre\u003e\nenum class rgbaColorChannel { red, green, blue, alpha };\n\nstd::string_view toString(rgbaColorChannel channel) {\n  switch (channel) {\n    using enum rgbaColorChannel;\n    case red:   return \"red\";\n    case green: return \"green\";\n    case blue:  return \"blue\";\n    case alpha: return \"alpha\";\n  }\n}\n\u003c/pre\u003e\n\u003cp\u003eAs with other \u003ccode\u003eusing\u003c/code\u003e declarations, \u003ccode\u003eusing enum\u003c/code\u003e improves readability when used in small scopes yet might generate confusion\nin large scopes.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003eswitch\u003c/code\u003e statement, as in the example above, when applied to a \u003ccode\u003eclass enum\u003c/code\u003e value, is a natural scope for \u003ccode\u003eusing\nenum\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThis rule reports scopes that use a particular \u003ccode\u003eclass enum\u003c/code\u003e extensively and could benefit from \u003ccode\u003eusing enum\u003c/code\u003e declaration. For\nexample, it reports most \u003ccode\u003eswitch\u003c/code\u003e statements applied to an \u003ccode\u003eenum\u003c/code\u003e value.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nenum class DayOfTheWeek { mon, tue, wed, thu, fri, sat, sun };\n\nbool isWorkDay(DayOfTheWeek day) {\n  switch(day) { // Noncompliant: case statements are too verbose\n    case DayOfTheWeek::mon: return true;\n    case DayOfTheWeek::tue: return true;\n    case DayOfTheWeek::wed: return true;\n    case DayOfTheWeek::thu: return true;\n    case DayOfTheWeek::fri: return true;\n    case DayOfTheWeek::sat: return false;\n    case DayOfTheWeek::sun: return false;\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nenum class DayOfTheWeek { mon, tue, wed, thu, fri, sat, sun };\n\nbool isWorkDay(DayOfTheWeek day) {\n  switch(day) {\n    using enum DayOfTheWeek;\n\n    case mon: return true;\n    case tue: return true;\n    case wed: return true;\n    case thu: return true;\n    case fri: return true;\n    case sat: return false;\n    case sun: return false;\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThe rule will not apply if adding the \u003ccode\u003eusing enum\u003c/code\u003e clause would create a name collision or reduce readability by shadowing a name.\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eC++20 extends the \u003ccode\u003eusing\u003c/code\u003e declaration to \u003ccode\u003eclass enum\u003c/code\u003e. \u003ccode\u003eusing enum\u003c/code\u003e introduces all the \u003ccode\u003eenum\u003c/code\u003e constants\ninto the current scope.\u003c/p\u003e\n\u003cpre\u003e\nenum class rgbaColorChannel { red, green, blue, alpha };\n\nstd::string_view toString(rgbaColorChannel channel) {\n  switch (channel) {\n    using enum rgbaColorChannel;\n    case red:   return \"red\";\n    case green: return \"green\";\n    case blue:  return \"blue\";\n    case alpha: return \"alpha\";\n  }\n}\n\u003c/pre\u003e\n\u003cp\u003eAs with other \u003ccode\u003eusing\u003c/code\u003e declarations, \u003ccode\u003eusing enum\u003c/code\u003e improves readability when used in small scopes yet might generate confusion\nin large scopes.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003eswitch\u003c/code\u003e statement, as in the example above, when applied to a \u003ccode\u003eclass enum\u003c/code\u003e value, is a natural scope for \u003ccode\u003eusing\nenum\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThis rule reports scopes that use a particular \u003ccode\u003eclass enum\u003c/code\u003e extensively and could benefit from \u003ccode\u003eusing enum\u003c/code\u003e declaration. For\nexample, it reports most \u003ccode\u003eswitch\u003c/code\u003e statements applied to an \u003ccode\u003eenum\u003c/code\u003e value.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nenum class DayOfTheWeek { mon, tue, wed, thu, fri, sat, sun };\n\nbool isWorkDay(DayOfTheWeek day) {\n  switch(day) { // Noncompliant: case statements are too verbose\n    case DayOfTheWeek::mon: return true;\n    case DayOfTheWeek::tue: return true;\n    case DayOfTheWeek::wed: return true;\n    case DayOfTheWeek::thu: return true;\n    case DayOfTheWeek::fri: return true;\n    case DayOfTheWeek::sat: return false;\n    case DayOfTheWeek::sun: return false;\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nenum class DayOfTheWeek { mon, tue, wed, thu, fri, sat, sun };\n\nbool isWorkDay(DayOfTheWeek day) {\n  switch(day) {\n    using enum DayOfTheWeek;\n\n    case mon: return true;\n    case tue: return true;\n    case wed: return true;\n    case thu: return true;\n    case fri: return true;\n    case sat: return false;\n    case sun: return false;\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThe rule will not apply if adding the \u003ccode\u003eusing enum\u003c/code\u003e clause would create a name collision or reduce readability by shadowing a name.\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "since-c++20"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S138",
    "name": "Functions/methods should not have too many lines",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "FOCUSED",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eA function that grows too large tends to aggregate too many responsibilities.\u003c/p\u003e\n\u003cp\u003eSuch functions inevitably become harder to understand and therefore harder to maintain.\u003c/p\u003e\n\u003cp\u003eAbove a specific threshold, it is strongly advised to refactor into smaller functions which focus on well-defined tasks.\u003c/p\u003e\n\u003cp\u003eThose smaller functions will not only be easier to understand, but also probably easier to test.\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eA function that grows too large tends to aggregate too many responsibilities.\u003c/p\u003e\n\u003cp\u003eSuch functions inevitably become harder to understand and therefore harder to maintain.\u003c/p\u003e\n\u003cp\u003eAbove a specific threshold, it is strongly advised to refactor into smaller functions which focus on well-defined tasks.\u003c/p\u003e\n\u003cp\u003eThose smaller functions will not only be easier to understand, but also probably easier to test.\u003c/p\u003e"
      }
    ],
    "params": {
      "max": {
        "key": "max",
        "name": "max",
        "description": "Maximum authorized lines in a function",
        "defaultValue": "100",
        "type": "INTEGER",
        "multiple": false,
        "possibleValues": []
      }
    },
    "defaultParams": {
      "max": "100"
    },
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "brain-overload"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6178",
    "name": "\"starts_with\" and \"ends_with\" should be used for prefix and postfix checks",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eIn C++20, \u003ccode\u003estd::string\u003c/code\u003e and \u003ccode\u003estd::string_view\u003c/code\u003e gain new member functions \u003ccode\u003estarts_with\u003c/code\u003e and \u003ccode\u003eends_with\u003c/code\u003e\nthat compare their argument to the prefix and postfix of the string.\u003c/p\u003e\n\u003cp\u003eThese two functions introduce a standard, concise, and efficient way of checking the prefix and postfix for strings. The ad-hoc implementations\npredating C++20 are often less readable, less efficient, and less reliable.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when an ad-hoc implementation checks prefixes or postfixes of a string.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nif (6 \u0026lt;\u003d str.size() \u0026amp;\u0026amp; str.substr(0, 6) \u003d\u003d \"prefix\") { // Noncompliant\n  std::cout \u0026lt;\u0026lt;str \u0026lt;\u0026lt;\" starts with the prefix\\n\";\n}\nif (6 \u0026lt;\u003d str.size() \u0026amp;\u0026amp; std::string_view(str.begin(), str.begin() + 6) \u003d\u003d \"prefix\") { // Noncompliant\n  std::cout \u0026lt;\u0026lt;str \u0026lt;\u0026lt;\" starts with the prefix\\n\";\n}\nif (7 \u0026lt;\u003d str.size() \u0026amp;\u0026amp; str.substr(str.size() - 7) \u003d\u003d \"postfix\") { // Noncompliant\n  std::cout \u0026lt;\u0026lt;str \u0026lt;\u0026lt;\" ends with the postfix\\n\";\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nif (str.starts_with(\"prefix\")) {\n  std::cout \u0026lt;\u0026lt;str \u0026lt;\u0026lt;\" starts with the prefix\\n\";\n}\nif (str.ends_with(\"postfix\")) {\n  std::cout \u0026lt;\u0026lt;str \u0026lt;\u0026lt;\" ends with the postfix\\n\";\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eIn C++20, \u003ccode\u003estd::string\u003c/code\u003e and \u003ccode\u003estd::string_view\u003c/code\u003e gain new member functions \u003ccode\u003estarts_with\u003c/code\u003e and \u003ccode\u003eends_with\u003c/code\u003e\nthat compare their argument to the prefix and postfix of the string.\u003c/p\u003e\n\u003cp\u003eThese two functions introduce a standard, concise, and efficient way of checking the prefix and postfix for strings. The ad-hoc implementations\npredating C++20 are often less readable, less efficient, and less reliable.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when an ad-hoc implementation checks prefixes or postfixes of a string.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nif (6 \u0026lt;\u003d str.size() \u0026amp;\u0026amp; str.substr(0, 6) \u003d\u003d \"prefix\") { // Noncompliant\n  std::cout \u0026lt;\u0026lt;str \u0026lt;\u0026lt;\" starts with the prefix\\n\";\n}\nif (6 \u0026lt;\u003d str.size() \u0026amp;\u0026amp; std::string_view(str.begin(), str.begin() + 6) \u003d\u003d \"prefix\") { // Noncompliant\n  std::cout \u0026lt;\u0026lt;str \u0026lt;\u0026lt;\" starts with the prefix\\n\";\n}\nif (7 \u0026lt;\u003d str.size() \u0026amp;\u0026amp; str.substr(str.size() - 7) \u003d\u003d \"postfix\") { // Noncompliant\n  std::cout \u0026lt;\u0026lt;str \u0026lt;\u0026lt;\" ends with the postfix\\n\";\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nif (str.starts_with(\"prefix\")) {\n  std::cout \u0026lt;\u0026lt;str \u0026lt;\u0026lt;\" starts with the prefix\\n\";\n}\nif (str.ends_with(\"postfix\")) {\n  std::cout \u0026lt;\u0026lt;str \u0026lt;\u0026lt;\" ends with the postfix\\n\";\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "bad-practice",
      "since-c++20"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S2808",
    "name": "The \"delete\" operator should only be used for pointers",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003edelete\u003c/code\u003e operator expects a pointer argument. Passing an object to it may compile and seem to run (with an implicit cast to pointer\ntype), but it can result in unexpected behavior at runtime.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nclass CString {\npublic:\n  operator const char*();\n  // ...\n};\n\nvoid fun() {\n  CString str;\n  // ...\n  delete str;  // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nclass CString {\npublic:\n  operator const char*();\n  // ...\n};\n\nvoid fun() {\n  CString *pstr \u003d new CString;\n  // ...\n  delete pstr;\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/memory/new/operator_delete\"\u003eoperator delete\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe \u003ccode\u003edelete\u003c/code\u003e operator expects a pointer argument. Passing an object to it may compile and seem to run (with an implicit cast to pointer\ntype), but it can result in unexpected behavior at runtime.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nclass CString {\npublic:\n  operator const char*();\n  // ...\n};\n\nvoid fun() {\n  CString str;\n  // ...\n  delete str;  // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nclass CString {\npublic:\n  operator const char*();\n  // ...\n};\n\nvoid fun() {\n  CString *pstr \u003d new CString;\n  // ...\n  delete pstr;\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/memory/new/operator_delete\"\u003eoperator delete\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S2807",
    "name": "Binary operators should be overloaded as \"friend\" functions",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eMember functions can only be used with an instance of a class. But \u003ccode\u003efriend\u003c/code\u003e functions can be used with an implicitly converted type. So\nloosening access privileges to \u003ccode\u003efriend\u003c/code\u003e on overloaded binary operators makes them more flexible. Specifically, with a \u003ccode\u003efriend\u003c/code\u003e\nfunction, the class instance can be on either the right or the left of the operator, but with a member function, it can only be on the left.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue for all non-\u003ccode\u003efriend\u003c/code\u003e overloaded binary operators except:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \"\u003ccode\u003e\u003d\u003c/code\u003e\", \"\u003ccode\u003e[ ]\u003c/code\u003e\", and \"\u003ccode\u003e-\u0026gt;\u003c/code\u003e\", which cannot be overloaded as \u003ccode\u003efriend\u003c/code\u003e functions. \u003c/li\u003e\n  \u003cli\u003e \"\u003ccode\u003e+\u003d\u003c/code\u003e\", \"\u003ccode\u003e-\u003d\u003c/code\u003e\", \"\u003ccode\u003e*\u003d\u003c/code\u003e\", \"\u003ccode\u003e/\u003d\u003c/code\u003e\", \"\u003ccode\u003e%\u003d\u003c/code\u003e\", \"\u003ccode\u003e^\u003d\u003c/code\u003e\", \"\u003ccode\u003e\u0026amp;\u003d\u003c/code\u003e\",\n  \"\u003ccode\u003e|\u003d\u003c/code\u003e\", \"\u003ccode\u003e\u0026lt;\u0026lt;\u003d\u003c/code\u003e\", and \"\u003ccode\u003e\u0026gt;\u0026gt;\u003d\u003c/code\u003e\", which are not symmetric operators. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nbool operator\u003d\u003d(const MyClass \u0026amp;RHS);  // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nfriend bool operator\u003d\u003d(const MyClass \u0026amp;LHS, const MyClass \u0026amp;RHS);\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c161-use-non-member-functions-for-symmetric-operators\"\u003eC.161:\n  Use non-member functions for symmetric operators\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eMember functions can only be used with an instance of a class. But \u003ccode\u003efriend\u003c/code\u003e functions can be used with an implicitly converted type. So\nloosening access privileges to \u003ccode\u003efriend\u003c/code\u003e on overloaded binary operators makes them more flexible. Specifically, with a \u003ccode\u003efriend\u003c/code\u003e\nfunction, the class instance can be on either the right or the left of the operator, but with a member function, it can only be on the left.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue for all non-\u003ccode\u003efriend\u003c/code\u003e overloaded binary operators except:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \"\u003ccode\u003e\u003d\u003c/code\u003e\", \"\u003ccode\u003e[ ]\u003c/code\u003e\", and \"\u003ccode\u003e-\u0026gt;\u003c/code\u003e\", which cannot be overloaded as \u003ccode\u003efriend\u003c/code\u003e functions. \u003c/li\u003e\n  \u003cli\u003e \"\u003ccode\u003e+\u003d\u003c/code\u003e\", \"\u003ccode\u003e-\u003d\u003c/code\u003e\", \"\u003ccode\u003e*\u003d\u003c/code\u003e\", \"\u003ccode\u003e/\u003d\u003c/code\u003e\", \"\u003ccode\u003e%\u003d\u003c/code\u003e\", \"\u003ccode\u003e^\u003d\u003c/code\u003e\", \"\u003ccode\u003e\u0026amp;\u003d\u003c/code\u003e\",\n  \"\u003ccode\u003e|\u003d\u003c/code\u003e\", \"\u003ccode\u003e\u0026lt;\u0026lt;\u003d\u003c/code\u003e\", and \"\u003ccode\u003e\u0026gt;\u0026gt;\u003d\u003c/code\u003e\", which are not symmetric operators. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nbool operator\u003d\u003d(const MyClass \u0026amp;RHS);  // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nfriend bool operator\u003d\u003d(const MyClass \u0026amp;LHS, const MyClass \u0026amp;RHS);\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c161-use-non-member-functions-for-symmetric-operators\"\u003eC.161:\n  Use non-member functions for symmetric operators\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "api-design",
      "cppcoreguidelines"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S2813",
    "name": "\"const\" references to numbers should not be made",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThere is no point in creating a \u003ccode\u003econst\u003c/code\u003e reference to a literal numeric value. Most likely the intent was not to create a reference, but\na constant value.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nconst int \u0026amp; weekdayCount \u003d 7;  // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nconst int weekdayCount \u003d 7;\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThere is no point in creating a \u003ccode\u003econst\u003c/code\u003e reference to a literal numeric value. Most likely the intent was not to create a reference, but\na constant value.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nconst int \u0026amp; weekdayCount \u003d 7;  // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nconst int weekdayCount \u003d 7;\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "clumsy"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S2815",
    "name": "\"this\" should not be compared with null",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eAccording to the C++ standard, \u003ccode\u003ethis\u003c/code\u003e can never be null, so comparisons of the two are pointless at best. At worst, because of compiler\noptimizations, such comparisons could lead to null pointer dereferences or obscure, difficult-to-diagnose errors in production.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when \u003ccode\u003ethis\u003c/code\u003e is compared to \u003ccode\u003enullptr\u003c/code\u003e or 0 or anything \u003ccode\u003e#defined\u003c/code\u003e as \u003ccode\u003enullptr\u003c/code\u003e\nor 0, such as \u003ccode\u003eNULL\u003c/code\u003e in most environments.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass MyClass {\n  string name;\n\n  string GetName() {\n    if (this !\u003d 0) {  // Noncompliant\n      return name;\n    }\n    return 0;\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nclass MyClass {\n  string name;\n\n  string GetName() {\n    return name;\n  }\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eAccording to the C++ standard, \u003ccode\u003ethis\u003c/code\u003e can never be null, so comparisons of the two are pointless at best. At worst, because of compiler\noptimizations, such comparisons could lead to null pointer dereferences or obscure, difficult-to-diagnose errors in production.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when \u003ccode\u003ethis\u003c/code\u003e is compared to \u003ccode\u003enullptr\u003c/code\u003e or 0 or anything \u003ccode\u003e#defined\u003c/code\u003e as \u003ccode\u003enullptr\u003c/code\u003e\nor 0, such as \u003ccode\u003eNULL\u003c/code\u003e in most environments.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass MyClass {\n  string name;\n\n  string GetName() {\n    if (this !\u003d 0) {  // Noncompliant\n      return name;\n    }\n    return 0;\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nclass MyClass {\n  string name;\n\n  string GetName() {\n    return name;\n  }\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6179",
    "name": "\"std::midpoint\" and \"std::lerp\" should be used for midpoint computation and linear interpolation",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eC++20 introduced the standard algorithms to compute the midpoint between two values and linear interpolation for a given coefficient.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003estd::midpoint(a, b)\u003c/code\u003e computes the midpoint, or average, or arithmetic mean of two values \u003ccode\u003ea\u003c/code\u003e and \u003ccode\u003eb\u003c/code\u003e:\n\u003ccode\u003e(a+b)/2\u003c/code\u003e. The result is halfway from \u003ccode\u003ea\u003c/code\u003e to \u003ccode\u003eb\u003c/code\u003e, and if \u003ccode\u003ea\u003c/code\u003e and \u003ccode\u003eb\u003c/code\u003e are pointers, it points to\nthe middle of a contiguous memory segment between the two. A naive midpoint computation might suffer from a possible overflow or be inefficient. That\nis why, in most cases, \u003ccode\u003estd::midpoint\u003c/code\u003e is preferable.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003estd::lerp(a, b, t)\u003c/code\u003e returns linear interpolation between values \u003ccode\u003ea\u003c/code\u003e and \u003ccode\u003eb\u003c/code\u003e with a coefficient \u003ccode\u003et\u003c/code\u003e:\n\u003ccode\u003ea+t*(a-b)\u003c/code\u003e, where \u003ccode\u003et\u003c/code\u003e is between 0 and 1.\u003c/p\u003e\n\u003cp\u003eThis rule reports computations that should be replaced with \u003ccode\u003estd::midpoint\u003c/code\u003e or \u003ccode\u003estd::lerp\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nauto avg1 \u003d (a + b)/2; // Noncompliant: might overflow\nauto avg2 \u003d a + (b - a)/2; // Noncompliant\nauto third \u003d a + (b - a)*0.3f; // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nauto avg1 \u003d std::midpoint(a, b);\nauto avg2 \u003d std::midpoint(a, b);\nauto third \u003d std::lerp(a, b, 0.3f);\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/numeric/midpoint\"\u003estd::midpoint\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/numeric/lerp\"\u003estd::lerp\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eC++20 introduced the standard algorithms to compute the midpoint between two values and linear interpolation for a given coefficient.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003estd::midpoint(a, b)\u003c/code\u003e computes the midpoint, or average, or arithmetic mean of two values \u003ccode\u003ea\u003c/code\u003e and \u003ccode\u003eb\u003c/code\u003e:\n\u003ccode\u003e(a+b)/2\u003c/code\u003e. The result is halfway from \u003ccode\u003ea\u003c/code\u003e to \u003ccode\u003eb\u003c/code\u003e, and if \u003ccode\u003ea\u003c/code\u003e and \u003ccode\u003eb\u003c/code\u003e are pointers, it points to\nthe middle of a contiguous memory segment between the two. A naive midpoint computation might suffer from a possible overflow or be inefficient. That\nis why, in most cases, \u003ccode\u003estd::midpoint\u003c/code\u003e is preferable.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003estd::lerp(a, b, t)\u003c/code\u003e returns linear interpolation between values \u003ccode\u003ea\u003c/code\u003e and \u003ccode\u003eb\u003c/code\u003e with a coefficient \u003ccode\u003et\u003c/code\u003e:\n\u003ccode\u003ea+t*(a-b)\u003c/code\u003e, where \u003ccode\u003et\u003c/code\u003e is between 0 and 1.\u003c/p\u003e\n\u003cp\u003eThis rule reports computations that should be replaced with \u003ccode\u003estd::midpoint\u003c/code\u003e or \u003ccode\u003estd::lerp\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nauto avg1 \u003d (a + b)/2; // Noncompliant: might overflow\nauto avg2 \u003d a + (b - a)/2; // Noncompliant\nauto third \u003d a + (b - a)*0.3f; // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nauto avg1 \u003d std::midpoint(a, b);\nauto avg2 \u003d std::midpoint(a, b);\nauto third \u003d std::lerp(a, b, 0.3f);\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/numeric/midpoint\"\u003estd::midpoint\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/numeric/lerp\"\u003estd::lerp\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "confusing",
      "pitfall",
      "since-c++20"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S128",
    "name": "Switch cases should end with an unconditional \"break\" statement",
    "defaultSeverity": "BLOCKER",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhen the execution is not explicitly terminated at the end of a switch case, it continues to execute the statements of the following case. While\nthis is sometimes intentional, it often is a mistake which leads to unexpected behavior.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nswitch (myVariable) {\n  case 1:\n    foo();\n    break;\n  case 2:  // Both \u0027doSomething()\u0027 and \u0027doSomethingElse()\u0027 will be executed. Is it on purpose ?\n    doSomething();\n  default:\n    doSomethingElse();\n    break;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nswitch (myVariable) {\n  case 1:\n    foo();\n    break;\n  case 2:\n    doSomething();\n    break;\n  default:\n    doSomethingElse();\n    break;\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThis rule is relaxed in the following cases:\u003c/p\u003e\n\u003cpre\u003e\nswitch (myVariable) {\n  case 0:                                // Empty case used to specify the same behavior for a group of cases.\n  case 1:\n    doSomething();\n    break;\n  case 2:                                // Use of return statement\n    return;\n  case 3:                                // Use of throw statement\n    throw 1;\n  case 4:                                // Use of an attribute to make explicit the fact that we want to fall through the next case\n    doSomething();\n    [[fallthrough]];\n  case 5:                                // Use of continue statement, if the switch is inside a loop\n    continue;\n  default:                               // For the last case, use of break statement is optional\n    doSomethingElse();\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 15.0 - The MISRA C \u003cem\u003eswitch\u003c/em\u003e syntax shall be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2004, 15.2 - An unconditional break statement shall terminate every non-empty switch clause \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 6-4-3 - A switch statement shall be a well-formed switch statement. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 6-4-5 - An unconditional throw or break statement shall terminate every non-empty switch-clause \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 16.1 - All switch statements shall be well-formed \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 16.3 - An unconditional break statement shall terminate every switch-clause \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/484\"\u003eMITRE, CWE-484\u003c/a\u003e - Omitted Break Statement in Switch \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/ldYxBQ\"\u003eCERT, MSC17-C.\u003c/a\u003e - Finish every set of statements associated with a case label with a\n  break statement \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhen the execution is not explicitly terminated at the end of a switch case, it continues to execute the statements of the following case. While\nthis is sometimes intentional, it often is a mistake which leads to unexpected behavior.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nswitch (myVariable) {\n  case 1:\n    foo();\n    break;\n  case 2:  // Both \u0027doSomething()\u0027 and \u0027doSomethingElse()\u0027 will be executed. Is it on purpose ?\n    doSomething();\n  default:\n    doSomethingElse();\n    break;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nswitch (myVariable) {\n  case 1:\n    foo();\n    break;\n  case 2:\n    doSomething();\n    break;\n  default:\n    doSomethingElse();\n    break;\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThis rule is relaxed in the following cases:\u003c/p\u003e\n\u003cpre\u003e\nswitch (myVariable) {\n  case 0:                                // Empty case used to specify the same behavior for a group of cases.\n  case 1:\n    doSomething();\n    break;\n  case 2:                                // Use of return statement\n    return;\n  case 3:                                // Use of throw statement\n    throw 1;\n  case 4:                                // Use of an attribute to make explicit the fact that we want to fall through the next case\n    doSomething();\n    [[fallthrough]];\n  case 5:                                // Use of continue statement, if the switch is inside a loop\n    continue;\n  default:                               // For the last case, use of break statement is optional\n    doSomethingElse();\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 15.0 - The MISRA C \u003cem\u003eswitch\u003c/em\u003e syntax shall be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2004, 15.2 - An unconditional break statement shall terminate every non-empty switch clause \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 6-4-3 - A switch statement shall be a well-formed switch statement. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 6-4-5 - An unconditional throw or break statement shall terminate every non-empty switch-clause \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 16.1 - All switch statements shall be well-formed \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 16.3 - An unconditional break statement shall terminate every switch-clause \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/484\"\u003eMITRE, CWE-484\u003c/a\u003e - Omitted Break Statement in Switch \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/ldYxBQ\"\u003eCERT, MSC17-C.\u003c/a\u003e - Finish every set of statements associated with a case label with a\n  break statement \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "cert",
      "cwe",
      "suspicious"
    ],
    "deprecatedKeys": [
      "cpp:NonEmptyCaseWithoutBreak"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S126",
    "name": "\"if ... else if\" constructs should end with \"else\" clauses",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThis rule applies whenever an \u003ccode\u003eif\u003c/code\u003e statement is followed by one or more \u003ccode\u003eelse if\u003c/code\u003e statements; the final \u003ccode\u003eelse if\u003c/code\u003e\nshould be followed by an \u003ccode\u003eelse\u003c/code\u003e statement.\u003c/p\u003e\n\u003cp\u003eThe requirement for a final \u003ccode\u003eelse\u003c/code\u003e statement is defensive programming.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003eelse\u003c/code\u003e statement should either take appropriate action or contain a suitable comment as to why no action is taken. This is\nconsistent with the requirement to have a final \u003ccode\u003edefault\u003c/code\u003e clause in a \u003ccode\u003eswitch\u003c/code\u003e statement.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nif (x \u003d\u003d 0) {\n  doSomething();\n} else if (x \u003d\u003d 1) {\n  doSomethingElse();\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nif (x \u003d\u003d 0) {\n  doSomething();\n} else if (x \u003d\u003d 1) {\n  doSomethingElse();\n} else {\n  error();\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eWhen all branches of an \u003ccode\u003eif\u003c/code\u003e-\u003ccode\u003eelse if\u003c/code\u003e end with \u003ccode\u003ereturn\u003c/code\u003e, \u003ccode\u003ebreak\u003c/code\u003e or \u003ccode\u003ethrow\u003c/code\u003e, the code that\ncomes after the \u003ccode\u003eif\u003c/code\u003e implicitly behaves as if it was in an \u003ccode\u003eelse\u003c/code\u003e clause. This rule will therefore ignore that case.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 14.10 - All if…​else if constructs shall be terminated with an else clause. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 6-4-2 - All if…​else if constructs shall be terminated with an else clause. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 15.7 - All if…​else if constructs shall be terminated with an else statement \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/RtYxBQ\"\u003eCERT, MSC01-C.\u003c/a\u003e - Strive for logical completeness \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThis rule applies whenever an \u003ccode\u003eif\u003c/code\u003e statement is followed by one or more \u003ccode\u003eelse if\u003c/code\u003e statements; the final \u003ccode\u003eelse if\u003c/code\u003e\nshould be followed by an \u003ccode\u003eelse\u003c/code\u003e statement.\u003c/p\u003e\n\u003cp\u003eThe requirement for a final \u003ccode\u003eelse\u003c/code\u003e statement is defensive programming.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003eelse\u003c/code\u003e statement should either take appropriate action or contain a suitable comment as to why no action is taken. This is\nconsistent with the requirement to have a final \u003ccode\u003edefault\u003c/code\u003e clause in a \u003ccode\u003eswitch\u003c/code\u003e statement.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nif (x \u003d\u003d 0) {\n  doSomething();\n} else if (x \u003d\u003d 1) {\n  doSomethingElse();\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nif (x \u003d\u003d 0) {\n  doSomething();\n} else if (x \u003d\u003d 1) {\n  doSomethingElse();\n} else {\n  error();\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eWhen all branches of an \u003ccode\u003eif\u003c/code\u003e-\u003ccode\u003eelse if\u003c/code\u003e end with \u003ccode\u003ereturn\u003c/code\u003e, \u003ccode\u003ebreak\u003c/code\u003e or \u003ccode\u003ethrow\u003c/code\u003e, the code that\ncomes after the \u003ccode\u003eif\u003c/code\u003e implicitly behaves as if it was in an \u003ccode\u003eelse\u003c/code\u003e clause. This rule will therefore ignore that case.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 14.10 - All if…​else if constructs shall be terminated with an else clause. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 6-4-2 - All if…​else if constructs shall be terminated with an else clause. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 15.7 - All if…​else if constructs shall be terminated with an else statement \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/RtYxBQ\"\u003eCERT, MSC01-C.\u003c/a\u003e - Strive for logical completeness \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "cert"
    ],
    "deprecatedKeys": [
      "cpp:ElseIfWithoutElse"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6045",
    "name": "Transparent comparator should be used with associative \"std::string\" containers",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "EFFICIENT",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eC++14 has introduced transparent comparators: the function objects that support heterogeneous comparison (i.e., comparison of values of different\ntypes, such as \u003ccode\u003estd::string\u003c/code\u003e and \u003ccode\u003echar const*\u003c/code\u003e). When using such comparator, the search-optimized containers, namely,\n\u003ccode\u003estd::set\u003c/code\u003e, \u003ccode\u003estd::multiset\u003c/code\u003e, \u003ccode\u003estd::map\u003c/code\u003e, and \u003ccode\u003estd::multimap\u003c/code\u003e, enable additional lookup-function overloads\nthat support types different from the \u003ccode\u003ekey_type\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eInvoking a lookup function (such as \u003ccode\u003efind\u003c/code\u003e, \u003ccode\u003ecount\u003c/code\u003e, or \u003ccode\u003elower_bound\u003c/code\u003e) with a non-\u003ccode\u003estd::string\u003c/code\u003e\nargument, i.e., a raw C-string literal (\u003ccode\u003es.find(\"Nemo\")\u003c/code\u003e), or a temporary \u003ccode\u003estd::string\u003c/code\u003e created of an\n\u003ccode\u003estd::string_view\u003c/code\u003e, on a container of \u003ccode\u003estd::string\u003c/code\u003e with non-transparent comparator, leads to a temporary\n\u003ccode\u003estd::string\u003c/code\u003e object, because the lookup function will support only an argument of the \u003ccode\u003ekey_type\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eC++20 extends support for heterogeneous lookup to unordered associative containers (\u003ccode\u003estd::unordered_set\u003c/code\u003e,\n\u003ccode\u003estd::unordered_multiset\u003c/code\u003e, \u003ccode\u003estd::unordered_map\u003c/code\u003e, and \u003ccode\u003estd::unordered_multimap\u003c/code\u003e) that provide additional overloads\nwhen the equality functor and the hasher are both transparent. The standard provides transparent equality functors in the form\n\u003ccode\u003estd::equal_to\u0026lt;\u0026gt;\u003c/code\u003e. However, there is no standard transparent hasher object and one needs to be defined in the program. For\n\u003ccode\u003estd::string\u003c/code\u003e such hasher may be provided by converting each supplied object to \u003ccode\u003estd::string_view\u003c/code\u003e and hashing it using\n\u003ccode\u003estd::hash\u0026lt;std::string_view\u0026gt;\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\nstruct StringHash {\n  using is_transparent \u003d void; // enables heterogeneous lookup\n\n  std::size_t operator()(std::string_view sv) const {\n    std::hash\u0026lt;std::string_view\u0026gt; hasher;\n    return hasher(sv);\n  }\n};\n\u003c/pre\u003e\n\u003cp\u003ePrefer using a transparent comparator with associative \u003ccode\u003estd::string\u003c/code\u003e containers to avoid creating the temporary. Note that transparent\ncomparators are strongly discouraged if used with types that are not directly comparable as it will lead to the creation of\n\u003ccode\u003eO(log(container.size())))\u003c/code\u003e temporaries with lookup functions such as \u003ccode\u003efind\u003c/code\u003e, \u003ccode\u003ecount\u003c/code\u003e, and\n\u003ccode\u003elower_bound\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eCustom non-transparent functor (comparator, equality or hasher) may have different semantics than corresponding operators on\n\u003ccode\u003estd:::string\u003c/code\u003e. In such case, the heterogeneous lookup can still be enabled, by declaring the \u003ccode\u003eis_transparent\u003c/code\u003e nested type in\nthe functor, and adjusting the implementation to accept either \u003ccode\u003estd::string_view\u003c/code\u003e or any type (i.e. turning it into a template). The later\nchange is required to avoid the creation of \u003ccode\u003estd::string\u003c/code\u003e temporaries for each invocation and thus degradation of performance.\u003c/p\u003e\n\u003cp\u003eThis rule will detect \u003ccode\u003estd::set\u003c/code\u003e, \u003ccode\u003estd::multiset\u003c/code\u003e, \u003ccode\u003estd::map\u003c/code\u003e, \u003ccode\u003estd::multimap\u003c/code\u003e, and since C++20\n\u003ccode\u003estd::unordered_set\u003c/code\u003e, \u003ccode\u003estd::unordered_multiset\u003c/code\u003e, \u003ccode\u003estd::unordered_map\u003c/code\u003e, and \u003ccode\u003estd::unordered_multimap\u003c/code\u003e\ntypes, that use \u003ccode\u003estd::string\u003c/code\u003e as key and do not enable heterogeneous lookup.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid f() {\n  // the default std::less\u0026lt;std::string\u0026gt; is not transparent\n  std::set\u0026lt;std::string\u0026gt; m \u003d { \"Dory\", \"Marlin\", \"Nemo\", \"Emo\"}; // Noncompliant\n  m.find(\"Nemo\"); // This leads to a temporary std::string{\"Nemo\"}.\n  std::string_view n{\"Nemo\"};\n  m.find(std::string(n)); // extra temporary std::string\n}\n\nvoid g() {\n  // the default std::equal_to\u0026lt;std::string\u0026gt; and std::hash\u0026lt;std::string\u0026gt; are not transparent\n  std::unordered_set\u0026lt;std::string\u0026gt; m \u003d { \"Dory\", \"Marlin\", \"Nemo\", \"Emo\"}; // Noncompliant\n  m.find(\"Nemo\"); // This leads to a temporary std::string{\"Nemo\"}.\n  std::string_view n{\"Nemo\"};\n  m.find(std::string(n)); // extra temporary std::string\n}\n\nstruct UpToTenLess {\n  bool operator()(const std::string\u0026amp; lhs, const std::string\u0026amp; rhs) const {\n    return lhs.compare(0, 10, rhs, 0, 10);\n  }\n};\n\nvoid g() {\n  // UpToTenLess is not transparent\n  std::set\u0026lt;std::string, UpToTenLess\u0026gt; m \u003d { \"Dory\", \"Marlin\", \"Nemo\", \"Emo\"}; // Noncompliant\n  m.find(\"Nemo\"); // This leads to a temporary std::string{\"Nemo\"}.\n  std::string_view n{\"Nemo\"};\n  m.find(std::string(n)); // extra temporary std::string\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid f() {\n  // std::less\u0026lt;\u0026gt; is transparent\n  std::set\u0026lt;std::string, std::less\u0026lt;\u0026gt;\u0026gt; m \u003d // Compliant\n      { \"Dory\", \"Marlin\", \"Nemo\", \"Emo\"};\n  m.find(\"Nemo\"); // No temporary is created, the raw C-string literal\n                  // is compared directly with std::string elements\n  std::string_view n{\"Nemo\"};\n  m.find(n); // No need to create the std::string\n}\n\nstruct StringHash {\n  using is_transparent \u003d void; // enables heterogenous lookup\n\n  std::size_t operator()(std::string_view sv) const {\n    std::hash\u0026lt;std::string_view\u0026gt; hasher;\n    return hasher(sv);\n  }\n};\n\n\nvoid g() {\n  // std::equal_to\u0026lt;\u0026gt; and StringHash are both transparent\n  std::unordered_set\u0026lt;std::string, StringHash, std::equal_to\u0026lt;\u0026gt;\u0026gt; m \u003d { \"Dory\", \"Marlin\", \"Nemo\", \"Emo\"}; // Compliant\n  m.find(\"Nemo\"); // std::string_view is created out of raw C-string literal\n  std::string_view n{\"Nemo\"};\n  m.find(n); // No need to create a std::string\n}\n\nstruct UpToTenLess {\n  using is_transparent \u003d void;\n\n  bool operator()(std::string_view lhs, std::string_view rhs) const {\n    return lhs.compare(0, 10, rhs, 0, 10);\n  }\n};\n\nvoid g() {\n  // UpToTenLess is now transparent\n  std::set\u0026lt;std::string, UpToTenLess\u0026gt; m \u003d { \"Dory\", \"Marlin\", \"Nemo\", \"Emo\"};\n  m.find(\"Nemo\"); // std::string_view is created out of raw C-string literal\n  std::string_view n{\"Nemo\"};\n  m.find(n); // No need to create a std::string\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cp\u003e{rule:cpp:S6021} for when it might be a bad idea to use transparent comparators.\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eC++14 has introduced transparent comparators: the function objects that support heterogeneous comparison (i.e., comparison of values of different\ntypes, such as \u003ccode\u003estd::string\u003c/code\u003e and \u003ccode\u003echar const*\u003c/code\u003e). When using such comparator, the search-optimized containers, namely,\n\u003ccode\u003estd::set\u003c/code\u003e, \u003ccode\u003estd::multiset\u003c/code\u003e, \u003ccode\u003estd::map\u003c/code\u003e, and \u003ccode\u003estd::multimap\u003c/code\u003e, enable additional lookup-function overloads\nthat support types different from the \u003ccode\u003ekey_type\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eInvoking a lookup function (such as \u003ccode\u003efind\u003c/code\u003e, \u003ccode\u003ecount\u003c/code\u003e, or \u003ccode\u003elower_bound\u003c/code\u003e) with a non-\u003ccode\u003estd::string\u003c/code\u003e\nargument, i.e., a raw C-string literal (\u003ccode\u003es.find(\"Nemo\")\u003c/code\u003e), or a temporary \u003ccode\u003estd::string\u003c/code\u003e created of an\n\u003ccode\u003estd::string_view\u003c/code\u003e, on a container of \u003ccode\u003estd::string\u003c/code\u003e with non-transparent comparator, leads to a temporary\n\u003ccode\u003estd::string\u003c/code\u003e object, because the lookup function will support only an argument of the \u003ccode\u003ekey_type\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eC++20 extends support for heterogeneous lookup to unordered associative containers (\u003ccode\u003estd::unordered_set\u003c/code\u003e,\n\u003ccode\u003estd::unordered_multiset\u003c/code\u003e, \u003ccode\u003estd::unordered_map\u003c/code\u003e, and \u003ccode\u003estd::unordered_multimap\u003c/code\u003e) that provide additional overloads\nwhen the equality functor and the hasher are both transparent. The standard provides transparent equality functors in the form\n\u003ccode\u003estd::equal_to\u0026lt;\u0026gt;\u003c/code\u003e. However, there is no standard transparent hasher object and one needs to be defined in the program. For\n\u003ccode\u003estd::string\u003c/code\u003e such hasher may be provided by converting each supplied object to \u003ccode\u003estd::string_view\u003c/code\u003e and hashing it using\n\u003ccode\u003estd::hash\u0026lt;std::string_view\u0026gt;\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\nstruct StringHash {\n  using is_transparent \u003d void; // enables heterogeneous lookup\n\n  std::size_t operator()(std::string_view sv) const {\n    std::hash\u0026lt;std::string_view\u0026gt; hasher;\n    return hasher(sv);\n  }\n};\n\u003c/pre\u003e\n\u003cp\u003ePrefer using a transparent comparator with associative \u003ccode\u003estd::string\u003c/code\u003e containers to avoid creating the temporary. Note that transparent\ncomparators are strongly discouraged if used with types that are not directly comparable as it will lead to the creation of\n\u003ccode\u003eO(log(container.size())))\u003c/code\u003e temporaries with lookup functions such as \u003ccode\u003efind\u003c/code\u003e, \u003ccode\u003ecount\u003c/code\u003e, and\n\u003ccode\u003elower_bound\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eCustom non-transparent functor (comparator, equality or hasher) may have different semantics than corresponding operators on\n\u003ccode\u003estd:::string\u003c/code\u003e. In such case, the heterogeneous lookup can still be enabled, by declaring the \u003ccode\u003eis_transparent\u003c/code\u003e nested type in\nthe functor, and adjusting the implementation to accept either \u003ccode\u003estd::string_view\u003c/code\u003e or any type (i.e. turning it into a template). The later\nchange is required to avoid the creation of \u003ccode\u003estd::string\u003c/code\u003e temporaries for each invocation and thus degradation of performance.\u003c/p\u003e\n\u003cp\u003eThis rule will detect \u003ccode\u003estd::set\u003c/code\u003e, \u003ccode\u003estd::multiset\u003c/code\u003e, \u003ccode\u003estd::map\u003c/code\u003e, \u003ccode\u003estd::multimap\u003c/code\u003e, and since C++20\n\u003ccode\u003estd::unordered_set\u003c/code\u003e, \u003ccode\u003estd::unordered_multiset\u003c/code\u003e, \u003ccode\u003estd::unordered_map\u003c/code\u003e, and \u003ccode\u003estd::unordered_multimap\u003c/code\u003e\ntypes, that use \u003ccode\u003estd::string\u003c/code\u003e as key and do not enable heterogeneous lookup.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid f() {\n  // the default std::less\u0026lt;std::string\u0026gt; is not transparent\n  std::set\u0026lt;std::string\u0026gt; m \u003d { \"Dory\", \"Marlin\", \"Nemo\", \"Emo\"}; // Noncompliant\n  m.find(\"Nemo\"); // This leads to a temporary std::string{\"Nemo\"}.\n  std::string_view n{\"Nemo\"};\n  m.find(std::string(n)); // extra temporary std::string\n}\n\nvoid g() {\n  // the default std::equal_to\u0026lt;std::string\u0026gt; and std::hash\u0026lt;std::string\u0026gt; are not transparent\n  std::unordered_set\u0026lt;std::string\u0026gt; m \u003d { \"Dory\", \"Marlin\", \"Nemo\", \"Emo\"}; // Noncompliant\n  m.find(\"Nemo\"); // This leads to a temporary std::string{\"Nemo\"}.\n  std::string_view n{\"Nemo\"};\n  m.find(std::string(n)); // extra temporary std::string\n}\n\nstruct UpToTenLess {\n  bool operator()(const std::string\u0026amp; lhs, const std::string\u0026amp; rhs) const {\n    return lhs.compare(0, 10, rhs, 0, 10);\n  }\n};\n\nvoid g() {\n  // UpToTenLess is not transparent\n  std::set\u0026lt;std::string, UpToTenLess\u0026gt; m \u003d { \"Dory\", \"Marlin\", \"Nemo\", \"Emo\"}; // Noncompliant\n  m.find(\"Nemo\"); // This leads to a temporary std::string{\"Nemo\"}.\n  std::string_view n{\"Nemo\"};\n  m.find(std::string(n)); // extra temporary std::string\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid f() {\n  // std::less\u0026lt;\u0026gt; is transparent\n  std::set\u0026lt;std::string, std::less\u0026lt;\u0026gt;\u0026gt; m \u003d // Compliant\n      { \"Dory\", \"Marlin\", \"Nemo\", \"Emo\"};\n  m.find(\"Nemo\"); // No temporary is created, the raw C-string literal\n                  // is compared directly with std::string elements\n  std::string_view n{\"Nemo\"};\n  m.find(n); // No need to create the std::string\n}\n\nstruct StringHash {\n  using is_transparent \u003d void; // enables heterogenous lookup\n\n  std::size_t operator()(std::string_view sv) const {\n    std::hash\u0026lt;std::string_view\u0026gt; hasher;\n    return hasher(sv);\n  }\n};\n\n\nvoid g() {\n  // std::equal_to\u0026lt;\u0026gt; and StringHash are both transparent\n  std::unordered_set\u0026lt;std::string, StringHash, std::equal_to\u0026lt;\u0026gt;\u0026gt; m \u003d { \"Dory\", \"Marlin\", \"Nemo\", \"Emo\"}; // Compliant\n  m.find(\"Nemo\"); // std::string_view is created out of raw C-string literal\n  std::string_view n{\"Nemo\"};\n  m.find(n); // No need to create a std::string\n}\n\nstruct UpToTenLess {\n  using is_transparent \u003d void;\n\n  bool operator()(std::string_view lhs, std::string_view rhs) const {\n    return lhs.compare(0, 10, rhs, 0, 10);\n  }\n};\n\nvoid g() {\n  // UpToTenLess is now transparent\n  std::set\u0026lt;std::string, UpToTenLess\u0026gt; m \u003d { \"Dory\", \"Marlin\", \"Nemo\", \"Emo\"};\n  m.find(\"Nemo\"); // std::string_view is created out of raw C-string literal\n  std::string_view n{\"Nemo\"};\n  m.find(n); // No need to create a std::string\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cp\u003e{rule:cpp:S6021} for when it might be a bad idea to use transparent comparators.\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "performance",
      "since-c++14"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6166",
    "name": "\"nodiscard\" attributes on functions should include explanations",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003enodiscard\u003c/code\u003e attribute can be used with or without explanations, but explaining why a result should not be discarded can only improve\none’s understanding of the code, and would prevent developers from wasting time figuring those things out by themselves.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when \u003ccode\u003enodiscard\u003c/code\u003e is used on function without any explanation.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n[[nodiscard]] std::vector\u0026lt;int\u0026gt; generateRandomValues(int count); // Noncompliant\n\ngenerateRandomValues(100);\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n[[nodiscard(\"Computation of values is expensive\")]] std::vector\u0026lt;int\u0026gt; generateRandomValues(int count);\n\ngenerateRandomValues(100);\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe \u003ccode\u003enodiscard\u003c/code\u003e attribute can be used with or without explanations, but explaining why a result should not be discarded can only improve\none’s understanding of the code, and would prevent developers from wasting time figuring those things out by themselves.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when \u003ccode\u003enodiscard\u003c/code\u003e is used on function without any explanation.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n[[nodiscard]] std::vector\u0026lt;int\u0026gt; generateRandomValues(int count); // Noncompliant\n\ngenerateRandomValues(100);\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n[[nodiscard(\"Computation of values is expensive\")]] std::vector\u0026lt;int\u0026gt; generateRandomValues(int count);\n\ngenerateRandomValues(100);\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "bad-practice",
      "since-c++20"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S127",
    "name": "\"for\" loop stop conditions should be invariant",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eA \u003ccode\u003efor\u003c/code\u003e loop stop condition should test the loop counter against an invariant value (i.e. one that is true at both the beginning and\nending of every loop iteration). Ideally, this means that the stop condition is set to a local variable just before the loop begins.\u003c/p\u003e\n\u003cp\u003eStop conditions that are not invariant are slightly less efficient, as well as being difficult to understand and maintain, and likely lead to the\nintroduction of errors in the future.\u003c/p\u003e\n\u003cp\u003eThis rule tracks three types of non-invariant stop conditions:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e When the loop counters are updated in the body of the \u003ccode\u003efor\u003c/code\u003e loop \u003c/li\u003e\n  \u003cli\u003e When the stop condition depend upon a method call \u003c/li\u003e\n  \u003cli\u003e When the stop condition depends on an object property, since such properties could change during the execution of the loop. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nfor (int i \u003d 0; i \u0026lt; 10; i++) {\n  ...\n  i \u003d i - 1; // Noncompliant\n  ...\n}\n\nfor (int i \u003d 0; i \u0026lt; getMaximumNumber(); i++) {  // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nfor (int i \u003d 0; i \u0026lt; 10; i++) {\n  ...\n}\nint stopCondition \u003d getMaximumNumber();\nfor (int i \u003d 0; i \u0026lt; stopCondition; i++) {\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 13.6 - Numeric variables being used within a \u003cem\u003efor\u003c/em\u003e loop for iteration counting shall not be modified in the body of the\n  loop. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 6-5-3 - The \u003cem\u003eloop-counter\u003c/em\u003e shall not be modified within \u003cem\u003econdition\u003c/em\u003e or \u003cem\u003estatement\u003c/em\u003e. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eA \u003ccode\u003efor\u003c/code\u003e loop stop condition should test the loop counter against an invariant value (i.e. one that is true at both the beginning and\nending of every loop iteration). Ideally, this means that the stop condition is set to a local variable just before the loop begins.\u003c/p\u003e\n\u003cp\u003eStop conditions that are not invariant are slightly less efficient, as well as being difficult to understand and maintain, and likely lead to the\nintroduction of errors in the future.\u003c/p\u003e\n\u003cp\u003eThis rule tracks three types of non-invariant stop conditions:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e When the loop counters are updated in the body of the \u003ccode\u003efor\u003c/code\u003e loop \u003c/li\u003e\n  \u003cli\u003e When the stop condition depend upon a method call \u003c/li\u003e\n  \u003cli\u003e When the stop condition depends on an object property, since such properties could change during the execution of the loop. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nfor (int i \u003d 0; i \u0026lt; 10; i++) {\n  ...\n  i \u003d i - 1; // Noncompliant\n  ...\n}\n\nfor (int i \u003d 0; i \u0026lt; getMaximumNumber(); i++) {  // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nfor (int i \u003d 0; i \u0026lt; 10; i++) {\n  ...\n}\nint stopCondition \u003d getMaximumNumber();\nfor (int i \u003d 0; i \u0026lt; stopCondition; i++) {\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 13.6 - Numeric variables being used within a \u003cem\u003efor\u003c/em\u003e loop for iteration counting shall not be modified in the body of the\n  loop. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 6-5-3 - The \u003cem\u003eloop-counter\u003c/em\u003e shall not be modified within \u003cem\u003econdition\u003c/em\u003e or \u003cem\u003estatement\u003c/em\u003e. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6164",
    "name": "Mathematical constants should not be hardcoded",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eStarting from C++20, mathematical constants are defined in the header \u003ccode\u003e\u0026lt;numbers\u0026gt;\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eYou should prefer using them instead of hardcoding your own constants.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nconst double pi \u003d 3.14159265358979323846; // Noncompliant\n\nauto computeCirclePerimeter(double radius) {\n    return 2 * pi * radius;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;numbers\u0026gt;\n\nauto computeCirclePerimeter(double radius) {\n    return 2 * std::numbers::pi * radius;\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eStarting from C++20, mathematical constants are defined in the header \u003ccode\u003e\u0026lt;numbers\u0026gt;\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eYou should prefer using them instead of hardcoding your own constants.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nconst double pi \u003d 3.14159265358979323846; // Noncompliant\n\nauto computeCirclePerimeter(double radius) {\n    return 2 * pi * radius;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;numbers\u0026gt;\n\nauto computeCirclePerimeter(double radius) {\n    return 2 * std::numbers::pi * radius;\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "clumsy",
      "since-c++20"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S125",
    "name": "Sections of code should not be commented out",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eCommented-out code distracts the focus from the actual executed code. It creates a noise that increases maintenance code. And because it is never\nexecuted, it quickly becomes out of date and invalid.\u003c/p\u003e\n\u003cp\u003eCommented-out code should be deleted and can be retrieved from source control history if required.\u003c/p\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThis rule does not apply to code documentation using Doxygen, QDoc, markdown, or HTML tags.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 2.4 - Sections of code should not be \"commented out\". \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 2-7-2 - Sections of code shall not be \"commented out\" using C-style comments. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 2-7-3 - Sections of code should not be \"commented out\" using C++ comments. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, Dir. 4.4 - Sections of code should not be \"commented out\" \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eCommented-out code distracts the focus from the actual executed code. It creates a noise that increases maintenance code. And because it is never\nexecuted, it quickly becomes out of date and invalid.\u003c/p\u003e\n\u003cp\u003eCommented-out code should be deleted and can be retrieved from source control history if required.\u003c/p\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThis rule does not apply to code documentation using Doxygen, QDoc, markdown, or HTML tags.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 2.4 - Sections of code should not be \"commented out\". \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 2-7-2 - Sections of code shall not be \"commented out\" using C-style comments. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 2-7-3 - Sections of code should not be \"commented out\" using C++ comments. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, Dir. 4.4 - Sections of code should not be \"commented out\" \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "unused"
    ],
    "deprecatedKeys": [
      "cpp:CommentedCode"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6165",
    "name": "Elements in a container should be erased with \"std::erase\" or \"std::erase_if\"",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eRemoving elements with a specific value or that follow a given predicate from a container is a common task. Before C++20, this was not\nstraightforward. The way to do it had to depend on the type of your container.\u003c/p\u003e\n\u003cp\u003eFor sequence containers, you would end up following what is called the \u003cem\u003eerase-remove idiom\u003c/em\u003e:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Call \u003ccode\u003estd::remove\u003c/code\u003e or \u003ccode\u003estd::remove_if\u003c/code\u003e with, as parameters, the container and the criterion to fulfill \u003c/li\u003e\n  \u003cli\u003e Call the container member function \u003ccode\u003eerase\u003c/code\u003e on the result \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eFor associative containers, you would have no other option than looping through all the elements by hand.\u003c/p\u003e\n\u003cp\u003eHowever, C++20 introduced two new methods: \u003ccode\u003estd::erase\u003c/code\u003e (for sequence containers only) and \u003ccode\u003estd::erase_if\u003c/code\u003e which erase all\nelements equal to a value or that satisfy a given predicate.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when \u003ccode\u003estd::erase\u003c/code\u003e or \u003ccode\u003estd::erase_if\u003c/code\u003e could be used to simplify the code.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid removeZeros(std::vector\u0026lt;int\u0026gt; \u0026amp;v) {\n  v.erase(std::remove(v.begin(), v.end(), 0), v.end()); // Noncompliant\n}\n\nvoid removeOddNumbers(std::vector\u0026lt;int\u0026gt; \u0026amp;v) {\n  v.erase(std::remove_if(v.begin(), v.end(), [](auto i) { return i%2 \u003d\u003d 0; }), v.end()); // Noncompliant\n}\n\nvoid removeOddNumbers(std::unordered_map\u0026lt;std::string, int\u0026gt; \u0026amp;m) {\n  auto it \u003d m.begin();\n  while (it !\u003d m.end()) { // Noncompliant\n    if (it-\u0026gt;second % 2 \u003d\u003d 0) {\n      it \u003d m.erase(it);\n    } else {\n      ++it;\n    }\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid removeZeros(std::vector\u0026lt;int\u0026gt; \u0026amp;v) {\n  std::erase(v, 0);\n}\n\nvoid removeOddNumbers(std::vector\u0026lt;int\u0026gt; \u0026amp;v) {\n  std::erase_if(v, [](auto i) { return i%2 \u003d\u003d 0; });\n}\n\nvoid removeOddNumbers(std::unordered_map\u0026lt;std::string, int\u0026gt; \u0026amp;m) {\n  std::erase_if(m, [](auto item) { return item.second % 2 \u003d\u003d 0; });\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eRemoving elements with a specific value or that follow a given predicate from a container is a common task. Before C++20, this was not\nstraightforward. The way to do it had to depend on the type of your container.\u003c/p\u003e\n\u003cp\u003eFor sequence containers, you would end up following what is called the \u003cem\u003eerase-remove idiom\u003c/em\u003e:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Call \u003ccode\u003estd::remove\u003c/code\u003e or \u003ccode\u003estd::remove_if\u003c/code\u003e with, as parameters, the container and the criterion to fulfill \u003c/li\u003e\n  \u003cli\u003e Call the container member function \u003ccode\u003eerase\u003c/code\u003e on the result \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eFor associative containers, you would have no other option than looping through all the elements by hand.\u003c/p\u003e\n\u003cp\u003eHowever, C++20 introduced two new methods: \u003ccode\u003estd::erase\u003c/code\u003e (for sequence containers only) and \u003ccode\u003estd::erase_if\u003c/code\u003e which erase all\nelements equal to a value or that satisfy a given predicate.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when \u003ccode\u003estd::erase\u003c/code\u003e or \u003ccode\u003estd::erase_if\u003c/code\u003e could be used to simplify the code.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid removeZeros(std::vector\u0026lt;int\u0026gt; \u0026amp;v) {\n  v.erase(std::remove(v.begin(), v.end(), 0), v.end()); // Noncompliant\n}\n\nvoid removeOddNumbers(std::vector\u0026lt;int\u0026gt; \u0026amp;v) {\n  v.erase(std::remove_if(v.begin(), v.end(), [](auto i) { return i%2 \u003d\u003d 0; }), v.end()); // Noncompliant\n}\n\nvoid removeOddNumbers(std::unordered_map\u0026lt;std::string, int\u0026gt; \u0026amp;m) {\n  auto it \u003d m.begin();\n  while (it !\u003d m.end()) { // Noncompliant\n    if (it-\u0026gt;second % 2 \u003d\u003d 0) {\n      it \u003d m.erase(it);\n    } else {\n      ++it;\n    }\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid removeZeros(std::vector\u0026lt;int\u0026gt; \u0026amp;v) {\n  std::erase(v, 0);\n}\n\nvoid removeOddNumbers(std::vector\u0026lt;int\u0026gt; \u0026amp;v) {\n  std::erase_if(v, [](auto i) { return i%2 \u003d\u003d 0; });\n}\n\nvoid removeOddNumbers(std::unordered_map\u0026lt;std::string, int\u0026gt; \u0026amp;m) {\n  std::erase_if(m, [](auto item) { return item.second % 2 \u003d\u003d 0; });\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "clumsy",
      "since-c++20"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1707",
    "name": "Track \"TODO\" and \"FIXME\" comments that do not contain a reference to a person",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eTODO and FIXME comments are typically intended to be short-lived; they are placeholders and reminders that programmers leave for themselves.\nUnfortunately, even with the best of intentions, those comments are not always acted on and removed in a timely manner. Thus, they can become\nmysterious, lingering cruft in a code base, reducing both readability and understand-ability.\u003c/p\u003e\n\u003cp\u003eThis rule flags all FIXME and TODO comments that do not have an attribution matching the specified regular expression immediately after the FIXME\nor TODO. Ideally, such comments will also contain information about what needs to be fixed or done, but this rule does not enforce that.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cp\u003eUsing the default regular expression: \u003ccode\u003e[ ]*\\([ _a-zA-Z0-9@.]+\\)\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\n// TODO\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n// TODO(ganncamp) per the business partners, more checks needed\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eTODO and FIXME comments are typically intended to be short-lived; they are placeholders and reminders that programmers leave for themselves.\nUnfortunately, even with the best of intentions, those comments are not always acted on and removed in a timely manner. Thus, they can become\nmysterious, lingering cruft in a code base, reducing both readability and understand-ability.\u003c/p\u003e\n\u003cp\u003eThis rule flags all FIXME and TODO comments that do not have an attribution matching the specified regular expression immediately after the FIXME\nor TODO. Ideally, such comments will also contain information about what needs to be fixed or done, but this rule does not enforce that.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cp\u003eUsing the default regular expression: \u003ccode\u003e[ ]*\\([ _a-zA-Z0-9@.]+\\)\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\n// TODO\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n// TODO(ganncamp) per the business partners, more checks needed\n\u003c/pre\u003e"
      }
    ],
    "params": {
      "pattern": {
        "key": "pattern",
        "name": "pattern",
        "description": "A POSIX regular expression defining the pattern that should be present after \"TODO\" or \"FIXME\"",
        "defaultValue": "[ ]*\\([ _a-zA-Z0-9@.]+\\)",
        "type": "STRING",
        "multiple": false,
        "possibleValues": []
      }
    },
    "defaultParams": {
      "pattern": "[ ]*\\([ _a-zA-Z0-9@.]+\\)"
    },
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "convention"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1708",
    "name": "C++ comments should be used",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eC++ comments (\u003ccode\u003e//\u003c/code\u003e) require fewer keystrokes, and take less space. Perhaps most importantly, they do not have the nesting problems that\nC-style comments do. Therefore C++ comments are preferred.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n/* this is my comment ... */\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n// this is my comment ...\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eBecause a C++ header file may be included by a C source file, header files are ignored by this rule.\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eC++ comments (\u003ccode\u003e//\u003c/code\u003e) require fewer keystrokes, and take less space. Perhaps most importantly, they do not have the nesting problems that\nC-style comments do. Therefore C++ comments are preferred.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n/* this is my comment ... */\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n// this is my comment ...\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eBecause a C++ header file may be included by a C source file, header files are ignored by this rule.\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "convention"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1709",
    "name": "\"explicit\" should be used on single-parameter constructors and conversion operators",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eIf you invoked a method with arguments of the wrong type, you would typically expect an error at compile time (if not in the IDE). However, when\nthe expected parameter is a class with a single-argument constructor, the compiler will implicitly pass the method argument to that constructor to\nimplicitly create an object of the correct type for the method invocation. Alternately, if the wrong type has a conversion operator to the correct\ntype, the operator will be called to create an object of the needed type.\u003c/p\u003e\n\u003cp\u003eBut just because you \u003cem\u003ecan\u003c/em\u003e do something, that doesn’t mean you \u003cem\u003eshould\u003c/em\u003e, and using implicit conversions makes the execution flow\ndifficult to understand. Readers may not notice that a conversion occurs, and if they do notice, it will raise a lot of questions: Is the source type\nable to convert to the destination type? Is the destination type able to construct an instance from the source? Is it both? And if so, which method is\ncalled by the compiler?\u003c/p\u003e\n\u003cp\u003eMoreover, implicit promotions can lead to unexpected behavior, so they should be prevented by using the \u003ccode\u003eexplicit\u003c/code\u003e keyword on\nsingle-argument constructors and (C++11) conversion operators. Doing so will prevent the compiler from performing implicit conversions.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstruct Bar {\n};\n\nstruct Foo {\n  Foo(Bar\u0026amp; bar); // Noncompliant; allow implicit conversion from \u0027Bar\u0027 to \u0027Foo\u0027\n};\n\nstruct Baz {\n  operator Foo(); // Noncompliant; allow implicit conversion from \u0027Baz\u0027 to \u0027Foo\u0027\n};\n\nvoid func(const Foo\u0026amp; b); // this function needs a \u0027Foo\u0027 not a \u0027Bar\u0027 nor a \u0027Baz\u0027\n\nint test(Bar\u0026amp; bar, Baz\u0026amp; baz) {\n  func(bar); // implicit conversion using Foo::Foo(Bar\u0026amp; bar)\n  func(baz); // implicit conversion using Baz::operator Foo()\n  func(baz);\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstruct Bar {\n};\n\nstruct Foo {\n  explicit Foo(Bar\u0026amp; bar); // Compliant, using \"explicit\" keyword\n};\n\nstruct Baz {\n  Foo asFoo();             // Compliant, explicit function\n  explicit operator Foo(); // Compliant, using C++11 \"explicit\" keyword for conversion function\n};\n\nvoid func(const Foo\u0026amp; b); // this function needs a \u0027Foo\u0027 not a \u0027Bar\u0027 nor a \u0027Baz\u0027\n\nint test(Bar\u0026amp; bar, Baz\u0026amp; baz) {\n  func(Foo(bar));              // explicit conversion using Foo::Foo(Bar\u0026amp; bar)\n  func(baz.asFoo());           // explicit conversion using Baz::asFoo()\n  func(static_cast\u0026lt;Foo\u0026gt;(baz)); // explicit conversion using Baz::operator Foo()\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eC++20 introduced conditional \u003ccode\u003eexplicit(expr)\u003c/code\u003e that allows developers to make a constructor or conversion operator conditionally explicit\ndepending on the value of \u003ccode\u003eexpr\u003c/code\u003e. The new syntax allows a constructor or conversion operator declared with an \u003ccode\u003eexplicit(expr)\u003c/code\u003e\nspecifier to be implicit when \u003ccode\u003eexpr\u003c/code\u003e evaluates to \u003ccode\u003efalse\u003c/code\u003e. The issue is not raised in such situation.\u003c/p\u003e\n\u003cp\u003eAdditionally, developers can use \u003ccode\u003eexplicit(false)\u003c/code\u003e to mark constructors or conversion operators as intentionally implicit.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 12-1-3 - All constructors that are callable with a single argument of fundamental type shall be declared \u003ccode\u003eexplicit\u003c/code\u003e.\n  \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c46-by-default-declare-single-argument-constructors-explicit\"\u003eC.46: By default, declare single-argument constructors explicit\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c164-avoid-implicit-conversion-operators\"\u003eC.164: Avoid implicit\n  conversion operators\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eIf you invoked a method with arguments of the wrong type, you would typically expect an error at compile time (if not in the IDE). However, when\nthe expected parameter is a class with a single-argument constructor, the compiler will implicitly pass the method argument to that constructor to\nimplicitly create an object of the correct type for the method invocation. Alternately, if the wrong type has a conversion operator to the correct\ntype, the operator will be called to create an object of the needed type.\u003c/p\u003e\n\u003cp\u003eBut just because you \u003cem\u003ecan\u003c/em\u003e do something, that doesn’t mean you \u003cem\u003eshould\u003c/em\u003e, and using implicit conversions makes the execution flow\ndifficult to understand. Readers may not notice that a conversion occurs, and if they do notice, it will raise a lot of questions: Is the source type\nable to convert to the destination type? Is the destination type able to construct an instance from the source? Is it both? And if so, which method is\ncalled by the compiler?\u003c/p\u003e\n\u003cp\u003eMoreover, implicit promotions can lead to unexpected behavior, so they should be prevented by using the \u003ccode\u003eexplicit\u003c/code\u003e keyword on\nsingle-argument constructors and (C++11) conversion operators. Doing so will prevent the compiler from performing implicit conversions.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstruct Bar {\n};\n\nstruct Foo {\n  Foo(Bar\u0026amp; bar); // Noncompliant; allow implicit conversion from \u0027Bar\u0027 to \u0027Foo\u0027\n};\n\nstruct Baz {\n  operator Foo(); // Noncompliant; allow implicit conversion from \u0027Baz\u0027 to \u0027Foo\u0027\n};\n\nvoid func(const Foo\u0026amp; b); // this function needs a \u0027Foo\u0027 not a \u0027Bar\u0027 nor a \u0027Baz\u0027\n\nint test(Bar\u0026amp; bar, Baz\u0026amp; baz) {\n  func(bar); // implicit conversion using Foo::Foo(Bar\u0026amp; bar)\n  func(baz); // implicit conversion using Baz::operator Foo()\n  func(baz);\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstruct Bar {\n};\n\nstruct Foo {\n  explicit Foo(Bar\u0026amp; bar); // Compliant, using \"explicit\" keyword\n};\n\nstruct Baz {\n  Foo asFoo();             // Compliant, explicit function\n  explicit operator Foo(); // Compliant, using C++11 \"explicit\" keyword for conversion function\n};\n\nvoid func(const Foo\u0026amp; b); // this function needs a \u0027Foo\u0027 not a \u0027Bar\u0027 nor a \u0027Baz\u0027\n\nint test(Bar\u0026amp; bar, Baz\u0026amp; baz) {\n  func(Foo(bar));              // explicit conversion using Foo::Foo(Bar\u0026amp; bar)\n  func(baz.asFoo());           // explicit conversion using Baz::asFoo()\n  func(static_cast\u0026lt;Foo\u0026gt;(baz)); // explicit conversion using Baz::operator Foo()\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eC++20 introduced conditional \u003ccode\u003eexplicit(expr)\u003c/code\u003e that allows developers to make a constructor or conversion operator conditionally explicit\ndepending on the value of \u003ccode\u003eexpr\u003c/code\u003e. The new syntax allows a constructor or conversion operator declared with an \u003ccode\u003eexplicit(expr)\u003c/code\u003e\nspecifier to be implicit when \u003ccode\u003eexpr\u003c/code\u003e evaluates to \u003ccode\u003efalse\u003c/code\u003e. The issue is not raised in such situation.\u003c/p\u003e\n\u003cp\u003eAdditionally, developers can use \u003ccode\u003eexplicit(false)\u003c/code\u003e to mark constructors or conversion operators as intentionally implicit.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 12-1-3 - All constructors that are callable with a single argument of fundamental type shall be declared \u003ccode\u003eexplicit\u003c/code\u003e.\n  \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c46-by-default-declare-single-argument-constructors-explicit\"\u003eC.46: By default, declare single-argument constructors explicit\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c164-avoid-implicit-conversion-operators\"\u003eC.164: Avoid implicit\n  conversion operators\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "cppcoreguidelines"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1712",
    "name": "Default parameters should not be defined",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eSetting method parameter defaults seems like a tidy way to make a method more usable. However, function pointers to methods with defaulted\nparameters can be confusing, because the function signature may not seem to match the call signature. Therefore, the use of multiple, overloaded\nmethods is preferred.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid HelloWorld (string name\u003d\"World\")\n{\n    cout \u0026lt;\u0026lt; \"Hello \" \u0026lt;\u0026lt; name \u0026lt;\u0026lt; endl;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid HelloWorld (string name)\n{\n    cout \u0026lt;\u0026lt; \"Hello \" \u0026lt;\u0026lt; name \u0026lt;\u0026lt; endl;\n}\n\nvoid HelloWorld ()\n{\n    HelloWorld(\"World\");\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S3719} \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eSetting method parameter defaults seems like a tidy way to make a method more usable. However, function pointers to methods with defaulted\nparameters can be confusing, because the function signature may not seem to match the call signature. Therefore, the use of multiple, overloaded\nmethods is preferred.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid HelloWorld (string name\u003d\"World\")\n{\n    cout \u0026lt;\u0026lt; \"Hello \" \u0026lt;\u0026lt; name \u0026lt;\u0026lt; endl;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid HelloWorld (string name)\n{\n    cout \u0026lt;\u0026lt; \"Hello \" \u0026lt;\u0026lt; name \u0026lt;\u0026lt; endl;\n}\n\nvoid HelloWorld ()\n{\n    HelloWorld(\"World\");\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S3719} \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S2806",
    "name": "Bit fields should not be used",
    "defaultSeverity": "BLOCKER",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe real need for bit fields is narrow and highly specialized. Previously, they were used to save memory, but that’s less a concern in modern\nsystems than are the extra instructions required to interact with them. Today, they may be needed in direct hardware interaction, but since their\nbehavior is platform-dependent, getting them right can be tricky, and since their use is increasingly rare these days, they’re likely to confuse\nmaintainers. For these reasons, it’s simpler and more performant to use another field type instead of bit fields.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nunsigned int b1 : 3;  // Noncompliant\nunsigned char b2 : 3;  // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nunsigned int b1;\nunsigned char b2;\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe real need for bit fields is narrow and highly specialized. Previously, they were used to save memory, but that’s less a concern in modern\nsystems than are the extra instructions required to interact with them. Today, they may be needed in direct hardware interaction, but since their\nbehavior is platform-dependent, getting them right can be tricky, and since their use is increasingly rare these days, they’re likely to confuse\nmaintainers. For these reasons, it’s simpler and more performant to use another field type instead of bit fields.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nunsigned int b1 : 3;  // Noncompliant\nunsigned char b2 : 3;  // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nunsigned int b1;\nunsigned char b2;\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "performance",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S134",
    "name": "Control flow statements \"if\", \"for\", \"while\", \"switch\" and \"try\" should not be nested too deeply",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "FOCUSED",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eNested control flow statements \u003ccode\u003eif\u003c/code\u003e, \u003ccode\u003efor\u003c/code\u003e, \u003ccode\u003edo\u003c/code\u003e, \u003ccode\u003ewhile\u003c/code\u003e, \u003ccode\u003eswitch\u003c/code\u003e and \u003ccode\u003etry\u003c/code\u003e are\noften key ingredients in creating what’s known as \"Spaghetti code\". This code smell can make your program difficult to understand and maintain.\u003c/p\u003e\n\u003cp\u003eWhen numerous control structures are placed inside one another, the code becomes a tangled, complex web. This significantly reduces the code’s\nreadability and maintainability, and it also complicates the testing process.\u003c/p\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eEach use of a macro containing control flow statements is counted as one nesting level, even if the macro contains more than one control flow\nstatement.\u003c/p\u003e\n\u003cpre\u003e\n  #define FOREACH(V,ARR) if(ARR!\u003dnullptr) for(int V\u003d0; V\u0026lt;(sizeof(ARR)/sizeof(ARR[0])); V++)\n\n  if (condition1) {       // Compliant; depth \u003d 1\n    if (condition2) {     // Compliant; depth \u003d 2\n      FOREACH(i, arr) {     // Compliant; depth \u003d 3 (not 4)\n        if (condition3) {   // Noncompliant; depth \u003d 4\n          /* ... */\n        }\n      }\n    }\n  }\n\u003c/pre\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003cp\u003eThe following example demonstrates the behavior of the rule with the default threshold of 3 levels of nesting and one of the potential ways to fix\nthe code smell by introducing guard clauses:\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nif (condition1) {                  // Compliant - depth \u003d 1\n  /* ... */\n  if (condition2) {                // Compliant - depth \u003d 2\n    /* ... */\n    for (int i \u003d 0; i \u0026lt; 10; i++) {  // Compliant - depth \u003d 3\n      /* ... */\n      if (condition4) {            // Noncompliant - depth \u003d 4, which exceeds the limit\n        if (condition5) {          // Depth \u003d 5, exceeding the limit, but issues are only reported on depth \u003d 4\n          /* ... */\n        }\n        return;\n      }\n    }\n  }\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nif (!condition1) {\n  return;\n}\n/* ... */\nif (!condition2) {\n  return;\n}\nfor (int i \u003d 0; i \u0026lt; 10; i++) {\n  /* ... */\n  if (condition4) {\n    if (condition5) {\n      /* ... */\n    }\n    return;\n  }\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Guard_(computer_science)\"\u003eGuard clauses in programming\u003c/a\u003e - one of the approaches to reducing the depth\n  of nesting \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eNested control flow statements \u003ccode\u003eif\u003c/code\u003e, \u003ccode\u003efor\u003c/code\u003e, \u003ccode\u003edo\u003c/code\u003e, \u003ccode\u003ewhile\u003c/code\u003e, \u003ccode\u003eswitch\u003c/code\u003e and \u003ccode\u003etry\u003c/code\u003e are\noften key ingredients in creating what’s known as \"Spaghetti code\". This code smell can make your program difficult to understand and maintain.\u003c/p\u003e\n\u003cp\u003eWhen numerous control structures are placed inside one another, the code becomes a tangled, complex web. This significantly reduces the code’s\nreadability and maintainability, and it also complicates the testing process.\u003c/p\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eEach use of a macro containing control flow statements is counted as one nesting level, even if the macro contains more than one control flow\nstatement.\u003c/p\u003e\n\u003cpre\u003e\n  #define FOREACH(V,ARR) if(ARR!\u003dnullptr) for(int V\u003d0; V\u0026lt;(sizeof(ARR)/sizeof(ARR[0])); V++)\n\n  if (condition1) {       // Compliant; depth \u003d 1\n    if (condition2) {     // Compliant; depth \u003d 2\n      FOREACH(i, arr) {     // Compliant; depth \u003d 3 (not 4)\n        if (condition3) {   // Noncompliant; depth \u003d 4\n          /* ... */\n        }\n      }\n    }\n  }\n\u003c/pre\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eThe following example demonstrates the behavior of the rule with the default threshold of 3 levels of nesting and one of the potential ways to fix\nthe code smell by introducing guard clauses:\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nif (condition1) {                  // Compliant - depth \u003d 1\n  /* ... */\n  if (condition2) {                // Compliant - depth \u003d 2\n    /* ... */\n    for (int i \u003d 0; i \u0026lt; 10; i++) {  // Compliant - depth \u003d 3\n      /* ... */\n      if (condition4) {            // Noncompliant - depth \u003d 4, which exceeds the limit\n        if (condition5) {          // Depth \u003d 5, exceeding the limit, but issues are only reported on depth \u003d 4\n          /* ... */\n        }\n        return;\n      }\n    }\n  }\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nif (!condition1) {\n  return;\n}\n/* ... */\nif (!condition2) {\n  return;\n}\nfor (int i \u003d 0; i \u0026lt; 10; i++) {\n  /* ... */\n  if (condition4) {\n    if (condition5) {\n      /* ... */\n    }\n    return;\n  }\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Guard_(computer_science)\"\u003eGuard clauses in programming\u003c/a\u003e - one of the approaches to reducing the depth\n  of nesting \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {
      "max": {
        "key": "max",
        "name": "max",
        "description": "Maximum allowed control flow statement nesting depth.",
        "defaultValue": "3",
        "type": "INTEGER",
        "multiple": false,
        "possibleValues": []
      }
    },
    "defaultParams": {
      "max": "3"
    },
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "brain-overload"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S131",
    "name": "\"switch\" statements should have \"default\" clauses",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe requirement for a final \u003ccode\u003edefault\u003c/code\u003e clause is defensive programming. The clause should either take appropriate action, or contain a\nsuitable comment as to why no action is taken. When the \u003ccode\u003eswitch\u003c/code\u003e covers all current values of an \u003ccode\u003eenum\u003c/code\u003e - and especially when it\ndoesn’t - a \u003ccode\u003edefault\u003c/code\u003e case should still be used because there is no guarantee that the \u003ccode\u003eenum\u003c/code\u003e won’t be extended.\u003c/p\u003e\n\u003cp\u003eNote that there is a more nuanced version of this rule: {rule:cpp:S3562}. Use this rule if you want to require a \u003ccode\u003edefault\u003c/code\u003e case for\nevery \u003ccode\u003eswitch\u003c/code\u003e even if it already handles all enumerators of an \u003ccode\u003eenum\u003c/code\u003e. Otherwise, use {rule:cpp:S3562}.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nswitch (param) { // Noncompliant - default clause is missing\n  case 0:\n    doSomething();\n    break;\n  case 1:\n    doSomethingElse();\n    break;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nswitch (param) {\n  case 0:\n    doSomething();\n    break;\n  case 1:\n    doSomethingElse();\n    break;\n  default:\n    doDefault();\n    break;\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 15.0 - The MISRA C \u003cem\u003eswitch\u003c/em\u003e syntax shall be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2004, 15.3 - The final clause of a switch statement shall be the default clause \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 6-4-3 - A switch statement shall be a well-formed switch statement. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 6-4-6 - The final clause of a switch statement shall be the default-clause \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 16.1 - All switch statements shall be well-formed \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 16.4 - Every \u003cem\u003eswitch\u003c/em\u003e statement shall have a \u003cem\u003edefault\u003c/em\u003e label \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 16.5 - A \u003cem\u003edefault\u003c/em\u003e label shall appear as either the first or the last \u003cem\u003eswitch label\u003c/em\u003e of a \u003cem\u003eswitch\u003c/em\u003e statement\n  \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/478\"\u003eMITRE, CWE-478\u003c/a\u003e - Missing Default Case in Switch Statement \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/RtYxBQ\"\u003eCERT, MSC01-C.\u003c/a\u003e - Strive for logical completeness \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S3562} \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe requirement for a final \u003ccode\u003edefault\u003c/code\u003e clause is defensive programming. The clause should either take appropriate action, or contain a\nsuitable comment as to why no action is taken. When the \u003ccode\u003eswitch\u003c/code\u003e covers all current values of an \u003ccode\u003eenum\u003c/code\u003e - and especially when it\ndoesn’t - a \u003ccode\u003edefault\u003c/code\u003e case should still be used because there is no guarantee that the \u003ccode\u003eenum\u003c/code\u003e won’t be extended.\u003c/p\u003e\n\u003cp\u003eNote that there is a more nuanced version of this rule: {rule:cpp:S3562}. Use this rule if you want to require a \u003ccode\u003edefault\u003c/code\u003e case for\nevery \u003ccode\u003eswitch\u003c/code\u003e even if it already handles all enumerators of an \u003ccode\u003eenum\u003c/code\u003e. Otherwise, use {rule:cpp:S3562}.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nswitch (param) { // Noncompliant - default clause is missing\n  case 0:\n    doSomething();\n    break;\n  case 1:\n    doSomethingElse();\n    break;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nswitch (param) {\n  case 0:\n    doSomething();\n    break;\n  case 1:\n    doSomethingElse();\n    break;\n  default:\n    doDefault();\n    break;\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 15.0 - The MISRA C \u003cem\u003eswitch\u003c/em\u003e syntax shall be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2004, 15.3 - The final clause of a switch statement shall be the default clause \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 6-4-3 - A switch statement shall be a well-formed switch statement. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 6-4-6 - The final clause of a switch statement shall be the default-clause \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 16.1 - All switch statements shall be well-formed \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 16.4 - Every \u003cem\u003eswitch\u003c/em\u003e statement shall have a \u003cem\u003edefault\u003c/em\u003e label \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 16.5 - A \u003cem\u003edefault\u003c/em\u003e label shall appear as either the first or the last \u003cem\u003eswitch label\u003c/em\u003e of a \u003cem\u003eswitch\u003c/em\u003e statement\n  \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/478\"\u003eMITRE, CWE-478\u003c/a\u003e - Missing Default Case in Switch Statement \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/RtYxBQ\"\u003eCERT, MSC01-C.\u003c/a\u003e - Strive for logical completeness \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S3562} \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "cert",
      "cwe"
    ],
    "deprecatedKeys": [
      "cpp:SwitchWithoutDefault"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6168",
    "name": "\"std::jthread\" should be used instead of \"std::thread\"",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003estd::jthread\u003c/code\u003e, introduced in C++20, is a wrapper around \u003ccode\u003estd::thread\u003c/code\u003e. This way, it has the same functionalities as\n\u003ccode\u003estd::thread\u003c/code\u003e, making the substitution straightforward while adding two interesting behaviors:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e It joins by default in its destructor. If a \u003ccode\u003estd::thread\u003c/code\u003e was not joined or detached before being destroyed, a call to\n  \u003ccode\u003estd::terminate\u003c/code\u003e was made. This behavior can’t happen with \u003ccode\u003estd::jthread\u003c/code\u003e. \u003c/li\u003e\n  \u003cli\u003e It can be canceled or stopped in some situations by calling \u003ccode\u003erequest_stop()\u003c/code\u003e. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis rule raises an issue when \u003ccode\u003estd::thread\u003c/code\u003e is used.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid backgroundTask();\nint main() {\n  std::thread t(backgroundTask); // Noncompliant\n  t.join();\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid backgroundTask();\nint main() {\n  std::jthread jt(backgroundTask);\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/thread/jthread\"\u003estd::jthread\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#cp25-prefer-gsljoining_thread-over-stdthread\"\u003eCP.25: Prefer\n  \u003ccode\u003egsl::joining_thread\u003c/code\u003e over \u003ccode\u003estd::thread\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003ccode\u003estd::jthread\u003c/code\u003e, introduced in C++20, is a wrapper around \u003ccode\u003estd::thread\u003c/code\u003e. This way, it has the same functionalities as\n\u003ccode\u003estd::thread\u003c/code\u003e, making the substitution straightforward while adding two interesting behaviors:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e It joins by default in its destructor. If a \u003ccode\u003estd::thread\u003c/code\u003e was not joined or detached before being destroyed, a call to\n  \u003ccode\u003estd::terminate\u003c/code\u003e was made. This behavior can’t happen with \u003ccode\u003estd::jthread\u003c/code\u003e. \u003c/li\u003e\n  \u003cli\u003e It can be canceled or stopped in some situations by calling \u003ccode\u003erequest_stop()\u003c/code\u003e. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis rule raises an issue when \u003ccode\u003estd::thread\u003c/code\u003e is used.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid backgroundTask();\nint main() {\n  std::thread t(backgroundTask); // Noncompliant\n  t.join();\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid backgroundTask();\nint main() {\n  std::jthread jt(backgroundTask);\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/thread/jthread\"\u003estd::jthread\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#cp25-prefer-gsljoining_thread-over-stdthread\"\u003eCP.25: Prefer\n  \u003ccode\u003egsl::joining_thread\u003c/code\u003e over \u003ccode\u003estd::thread\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "bad-practice",
      "cppcoreguidelines",
      "since-c++20"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6169",
    "name": "Call to \"std::is_constant_evaluated\" should not be gratuitous",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003estd::is_constant_evaluated\u003c/code\u003e is used to determine whether or not a context is constant-evaluated. This can be useful when, for example,\ntwo different implementations are provided for an algorithm: one, usually slow, for compile-time and the other one, faster, for runtime.\u003c/p\u003e\n\u003cp\u003eHowever, some contexts are either always constant-evaluated or never constant-evaluated. In these cases, a call to\n\u003ccode\u003estd::is_constant_evaluated\u003c/code\u003e is unnecessary as it will always return the same result.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003estd::is_constant_evaluated\u003c/code\u003e will always return \u003ccode\u003etrue\u003c/code\u003e when called in:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e the condition of \u003ccode\u003eif constexpr\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e the condition of \u003ccode\u003estatic_assert\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003econsteval\u003c/code\u003e functions \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eAnd it will always return \u003ccode\u003efalse\u003c/code\u003e in:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e non-\u003ccode\u003econstexpr\u003c/code\u003e/\u003ccode\u003econsteval\u003c/code\u003e functions \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis rule raises an issue when \u003ccode\u003estd::is_constant_evaluated()\u003c/code\u003e is called in an \u003ccode\u003eif constexpr\u003c/code\u003e or a \u003ccode\u003estatic_assert\u003c/code\u003e\ncondition, where it is always \u003ccode\u003etrue\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nconstexpr double power(double b, int x) {\n  if constexpr (std::is_constant_evaluated()) {  // Noncompliant: will always be true\n    // compile-time implementation\n  } else {\n    // runtime implementation\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nconstexpr double power(double b, int x) {\n  if (std::is_constant_evaluated()) {\n    // compile-time implementation\n  } else {\n    // runtime implementation\n  }\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003ccode\u003estd::is_constant_evaluated\u003c/code\u003e is used to determine whether or not a context is constant-evaluated. This can be useful when, for example,\ntwo different implementations are provided for an algorithm: one, usually slow, for compile-time and the other one, faster, for runtime.\u003c/p\u003e\n\u003cp\u003eHowever, some contexts are either always constant-evaluated or never constant-evaluated. In these cases, a call to\n\u003ccode\u003estd::is_constant_evaluated\u003c/code\u003e is unnecessary as it will always return the same result.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003estd::is_constant_evaluated\u003c/code\u003e will always return \u003ccode\u003etrue\u003c/code\u003e when called in:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e the condition of \u003ccode\u003eif constexpr\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e the condition of \u003ccode\u003estatic_assert\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003econsteval\u003c/code\u003e functions \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eAnd it will always return \u003ccode\u003efalse\u003c/code\u003e in:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e non-\u003ccode\u003econstexpr\u003c/code\u003e/\u003ccode\u003econsteval\u003c/code\u003e functions \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis rule raises an issue when \u003ccode\u003estd::is_constant_evaluated()\u003c/code\u003e is called in an \u003ccode\u003eif constexpr\u003c/code\u003e or a \u003ccode\u003estatic_assert\u003c/code\u003e\ncondition, where it is always \u003ccode\u003etrue\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nconstexpr double power(double b, int x) {\n  if constexpr (std::is_constant_evaluated()) {  // Noncompliant: will always be true\n    // compile-time implementation\n  } else {\n    // runtime implementation\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nconstexpr double power(double b, int x) {\n  if (std::is_constant_evaluated()) {\n    // compile-time implementation\n  } else {\n    // runtime implementation\n  }\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "since-c++20"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6195",
    "name": "\"std::enable_if\" should not be used",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003estd::enable_if\u003c/code\u003e is a very important part of template meta-programming in C++ up to C++17. Based on SFINAE (\"Substitution Failure Is Not\nAn Error\"), it can be used to subtly tune the behavior of overload resolution based on properties of types.\u003c/p\u003e\n\u003cp\u003eHowever, using \u003ccode\u003estd::enable_if\u003c/code\u003e correctly is not easy and requires skills and experience for a resulting code that is not\nstraightforward and costly to maintain. Since C++20, new features replace complex uses of \u003ccode\u003estd::enable_if\u003c/code\u003e:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Concepts allow defining named constraints on types, using a terse syntax to specify that a template argument must adhere to a concept; \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003erequires\u003c/code\u003e clauses can be directly written for one-shot constraints; \u003c/li\u003e\n  \u003cli\u003e In some cases, using \u003ccode\u003eif constexpr\u003c/code\u003e (introduced in C++17) may replace an overload set with just one function (see {rule:cpp:S6017}).\n  \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eAdditionally, since those features provide a higher level of abstraction, compilers understand them better and can provide more straightforward\ndiagnostics when a constraint is violated.\u003c/p\u003e\n\u003cp\u003eConsequently, \u003ccode\u003estd::enable_if\u003c/code\u003e is no longer the right tool and should be replaced with those facilities. Note that the replacement is\nnot always mechanical. For instance, reusing an existing concept defined in the standard is a better alternative than putting the\n\u003ccode\u003estd::enable_if\u003c/code\u003e expression in a \u003ccode\u003erequires\u003c/code\u003e clause.\u003c/p\u003e\n\u003cp\u003eThis rule reports the use of \u003ccode\u003estd::enable_if\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\ntemplate \u0026lt;typename N, class \u003d typename\n  std::enable_if\u0026lt;std::is_integral_v\u0026lt;N\u0026gt; \u0026amp;\u0026amp; std::is_signed_v\u0026lt;N\u0026gt;\u0026gt;::type\u0026gt; // Noncompliant\nauto negate(N n) { return -n; }\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\ntemplate \u0026lt;class N\u0026gt; requires std::signed_integral\u0026lt;N\u0026gt;\nauto negate(N n) { return -n; }\n\u003c/pre\u003e\n\u003cp\u003eOr\u003c/p\u003e\n\u003cpre\u003e\ntemplate \u0026lt;std::signed_integral N\u0026gt;\nauto negate(N n) { return -n; }\n\u003c/pre\u003e\n\u003cp\u003eOr\u003c/p\u003e\n\u003cpre\u003e\nauto negate(std::signed_integral auto n) { return -n; }\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/sfinae\"\u003eSFINAE\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/constraints\"\u003eConstraints and concepts\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e Open Standards - \u003ca href\u003d\"http://open-std.org/JTC1/SC22/WG21/docs/papers/2016/p0225r0.html\"\u003eWhy I want Concepts, and why I want them sooner\n  rather than later\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S6017} to see when \u003ccode\u003estd::enable_if\u003c/code\u003e could be replaced with \u003ccode\u003eif constexpr\u003c/code\u003e. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003ccode\u003estd::enable_if\u003c/code\u003e is a very important part of template meta-programming in C++ up to C++17. Based on SFINAE (\"Substitution Failure Is Not\nAn Error\"), it can be used to subtly tune the behavior of overload resolution based on properties of types.\u003c/p\u003e\n\u003cp\u003eHowever, using \u003ccode\u003estd::enable_if\u003c/code\u003e correctly is not easy and requires skills and experience for a resulting code that is not\nstraightforward and costly to maintain. Since C++20, new features replace complex uses of \u003ccode\u003estd::enable_if\u003c/code\u003e:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Concepts allow defining named constraints on types, using a terse syntax to specify that a template argument must adhere to a concept; \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003erequires\u003c/code\u003e clauses can be directly written for one-shot constraints; \u003c/li\u003e\n  \u003cli\u003e In some cases, using \u003ccode\u003eif constexpr\u003c/code\u003e (introduced in C++17) may replace an overload set with just one function (see {rule:cpp:S6017}).\n  \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eAdditionally, since those features provide a higher level of abstraction, compilers understand them better and can provide more straightforward\ndiagnostics when a constraint is violated.\u003c/p\u003e\n\u003cp\u003eConsequently, \u003ccode\u003estd::enable_if\u003c/code\u003e is no longer the right tool and should be replaced with those facilities. Note that the replacement is\nnot always mechanical. For instance, reusing an existing concept defined in the standard is a better alternative than putting the\n\u003ccode\u003estd::enable_if\u003c/code\u003e expression in a \u003ccode\u003erequires\u003c/code\u003e clause.\u003c/p\u003e\n\u003cp\u003eThis rule reports the use of \u003ccode\u003estd::enable_if\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\ntemplate \u0026lt;typename N, class \u003d typename\n  std::enable_if\u0026lt;std::is_integral_v\u0026lt;N\u0026gt; \u0026amp;\u0026amp; std::is_signed_v\u0026lt;N\u0026gt;\u0026gt;::type\u0026gt; // Noncompliant\nauto negate(N n) { return -n; }\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\ntemplate \u0026lt;class N\u0026gt; requires std::signed_integral\u0026lt;N\u0026gt;\nauto negate(N n) { return -n; }\n\u003c/pre\u003e\n\u003cp\u003eOr\u003c/p\u003e\n\u003cpre\u003e\ntemplate \u0026lt;std::signed_integral N\u0026gt;\nauto negate(N n) { return -n; }\n\u003c/pre\u003e\n\u003cp\u003eOr\u003c/p\u003e\n\u003cpre\u003e\nauto negate(std::signed_integral auto n) { return -n; }\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/sfinae\"\u003eSFINAE\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/constraints\"\u003eConstraints and concepts\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e Open Standards - \u003ca href\u003d\"http://open-std.org/JTC1/SC22/WG21/docs/papers/2016/p0225r0.html\"\u003eWhy I want Concepts, and why I want them sooner\n  rather than later\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S6017} to see when \u003ccode\u003estd::enable_if\u003c/code\u003e could be replaced with \u003ccode\u003eif constexpr\u003c/code\u003e. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "clumsy",
      "since-c++20"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6193",
    "name": "Coroutine names should comply with a naming convention",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "IDENTIFIABLE",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eShared naming conventions allow teams to collaborate efficiently. This rule checks that all coroutine names match a provided regular\nexpression.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cp\u003eWith default provided regular expression: \u003ccode\u003e^[a-z][a-zA-Z0-9]*$\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\ngenerator\u0026lt;int\u0026gt; Iota(int n \u003d 0) {\n  while(true)\n    co_yield n++;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\ngenerator\u0026lt;int\u0026gt; iota(int n \u003d 0) {\n  while(true)\n    co_yield n++;\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eShared naming conventions allow teams to collaborate efficiently. This rule checks that all coroutine names match a provided regular\nexpression.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cp\u003eWith default provided regular expression: \u003ccode\u003e^[a-z][a-zA-Z0-9]*$\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\ngenerator\u0026lt;int\u0026gt; Iota(int n \u003d 0) {\n  while(true)\n    co_yield n++;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\ngenerator\u0026lt;int\u0026gt; iota(int n \u003d 0) {\n  while(true)\n    co_yield n++;\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {
      "format": {
        "key": "format",
        "name": "format",
        "description": "POSIX regular expression used to check the coroutine names against",
        "defaultValue": "^[a-z][a-zA-Z0-9]*$",
        "type": "STRING",
        "multiple": false,
        "possibleValues": []
      }
    },
    "defaultParams": {
      "format": "^[a-z][a-zA-Z0-9]*$"
    },
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "convention",
      "since-c++20"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6194",
    "name": "Cognitive Complexity of coroutines should not be too high",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "FOCUSED",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eCognitive Complexity is a measure of how hard the control flow of a function is to understand. Coroutines with high Cognitive Complexity will be\ndifficult to maintain.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://www.sonarsource.com/docs/CognitiveComplexity.pdf\"\u003eCognitive Complexity\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eCognitive Complexity is a measure of how hard the control flow of a function is to understand. Coroutines with high Cognitive Complexity will be\ndifficult to maintain.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://www.sonarsource.com/docs/CognitiveComplexity.pdf\"\u003eCognitive Complexity\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {
      "maximumCoroutineCognitiveComplexityThreshold": {
        "key": "maximumCoroutineCognitiveComplexityThreshold",
        "name": "maximumCoroutineCognitiveComplexityThreshold",
        "description": "The maximum authorized complexity.",
        "defaultValue": "25",
        "type": "INTEGER",
        "multiple": false,
        "possibleValues": []
      }
    },
    "defaultParams": {
      "maximumCoroutineCognitiveComplexityThreshold": "25"
    },
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "brain-overload",
      "since-c++20"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6197",
    "name": "STL constrained algorithms with range parameter should be used when iterating over the entire range",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eC++20 introduces the ranges library. A range is a group of items that can be iterated over. It should provide a \u003ccode\u003ebegin\u003c/code\u003e iterator and an\n\u003ccode\u003eend\u003c/code\u003e sentinel. All the existing STL containers are ranges.\u003c/p\u003e\n\u003cp\u003eThis new library makes working with the STL library much more powerful by introducing range adaptors and much less verbose by introducing a\nconstrained version of most algorithms in the namespace \u003ccode\u003estd::ranges\u003c/code\u003e. Before the ranges library, you had to specify the \u003ccode\u003ebegin\u003c/code\u003e\nand \u003ccode\u003eend\u003c/code\u003e iterators when calling the STL algorithms, even when you want to iterate over the whole container.\u003c/p\u003e\n\u003cp\u003eThis rule focuses on making your code less verbose and more readable by suggesting range-based over iterator-based algorithms when convenient.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nauto printEven \u003d [](auto i) {\n  if (i % 2 \u003d\u003d 0) {\n    std::cout \u0026lt;\u0026lt; i;\n  }\n};\n\nvoid f1(const std::vector\u0026lt;int\u0026gt;\u0026amp; v) {\n  std::for_each(v.begin(), v.end(), printEven); // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nauto printEven \u003d [](auto i) {\n  if (i % 2 \u003d\u003d 0) {\n    std::cout \u0026lt;\u0026lt; i;\n  }\n};\n\nvoid f2(const std::vector\u0026lt;int\u0026gt;\u0026amp; v) {\n  std::ranges::for_each(v, printEven); // Compliant\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/ranges\"\u003eRanges library\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eC++20 introduces the ranges library. A range is a group of items that can be iterated over. It should provide a \u003ccode\u003ebegin\u003c/code\u003e iterator and an\n\u003ccode\u003eend\u003c/code\u003e sentinel. All the existing STL containers are ranges.\u003c/p\u003e\n\u003cp\u003eThis new library makes working with the STL library much more powerful by introducing range adaptors and much less verbose by introducing a\nconstrained version of most algorithms in the namespace \u003ccode\u003estd::ranges\u003c/code\u003e. Before the ranges library, you had to specify the \u003ccode\u003ebegin\u003c/code\u003e\nand \u003ccode\u003eend\u003c/code\u003e iterators when calling the STL algorithms, even when you want to iterate over the whole container.\u003c/p\u003e\n\u003cp\u003eThis rule focuses on making your code less verbose and more readable by suggesting range-based over iterator-based algorithms when convenient.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nauto printEven \u003d [](auto i) {\n  if (i % 2 \u003d\u003d 0) {\n    std::cout \u0026lt;\u0026lt; i;\n  }\n};\n\nvoid f1(const std::vector\u0026lt;int\u0026gt;\u0026amp; v) {\n  std::for_each(v.begin(), v.end(), printEven); // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nauto printEven \u003d [](auto i) {\n  if (i % 2 \u003d\u003d 0) {\n    std::cout \u0026lt;\u0026lt; i;\n  }\n};\n\nvoid f2(const std::vector\u0026lt;int\u0026gt;\u0026amp; v) {\n  std::ranges::for_each(v, printEven); // Compliant\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/ranges\"\u003eRanges library\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "bad-practice",
      "clumsy",
      "since-c++20"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:M23_403",
    "name": "The \"goto\" statement should not be used",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 9.6.1\u003c/p\u003e\n\u003cp\u003eCategory: Advisory\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eThe use of \u003ccode\u003egoto\u003c/code\u003e is usually regarded as bad programming practice as it can lead to code that is difficult to understand and analyse.\nRestructuring code to avoid its use generally leads to code that has a lower level of complexity.\u003c/p\u003e\n\u003cp\u003eIf this advice is not followed, {rule:cpp:M23_126}: MISRA C++ 2023 Rule\u0026nbsp;9.6.3 ensure that the use of \u003ccode\u003egoto\u003c/code\u003e does not result in code\nthat is considered to be unstructured.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S907} targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2023 Rule\u0026nbsp;9.6.2 - A \u003ccode\u003egoto\u003c/code\u003e statement shall reference a label in a surrounding block \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:M23_126}: MISRA C++ 2023 Rule\u0026nbsp;9.6.3 - The \u003ccode\u003egoto\u003c/code\u003e statement shall jump to a label declared later in the function body\n  \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cp\u003e\u003ca href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/036324/CppCoreGuidelines.md#es76-avoid-goto\"\u003eC++ Core Guidelines ES.76\u003c/a\u003e: Avoid\ngoto\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 9.6.1\u003c/p\u003e\n\u003cp\u003eCategory: Advisory\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eThe use of \u003ccode\u003egoto\u003c/code\u003e is usually regarded as bad programming practice as it can lead to code that is difficult to understand and analyse.\nRestructuring code to avoid its use generally leads to code that has a lower level of complexity.\u003c/p\u003e\n\u003cp\u003eIf this advice is not followed, {rule:cpp:M23_126}: MISRA C++ 2023 Rule\u0026nbsp;9.6.3 ensure that the use of \u003ccode\u003egoto\u003c/code\u003e does not result in code\nthat is considered to be unstructured.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S907} targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2023 Rule\u0026nbsp;9.6.2 - A \u003ccode\u003egoto\u003c/code\u003e statement shall reference a label in a surrounding block \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:M23_126}: MISRA C++ 2023 Rule\u0026nbsp;9.6.3 - The \u003ccode\u003egoto\u003c/code\u003e statement shall jump to a label declared later in the function body\n  \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cp\u003e\u003ca href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/036324/CppCoreGuidelines.md#es76-avoid-goto\"\u003eC++ Core Guidelines ES.76\u003c/a\u003e: Avoid\ngoto\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "misra-advisory",
      "misra-c++2023"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:M23_404",
    "name": "The character handling functions from \"\u003ccctype\u003e\" and \"\u003ccwctype\u003e\" shall not be used",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 24.5.1\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eThis rule applies to the character classification functions and the character case mapping functions from \u003ccode\u003e\u0026lt;cctype\u0026gt;\u003c/code\u003e and\n\u003ccode\u003e\u0026lt;cwctype\u0026gt;\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e this rule also applies to the same functions from \u003ccode\u003e\u0026lt;ctype.h\u0026gt;\u003c/code\u003e and \u003ccode\u003e\u0026lt;wctype.h\u0026gt;\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eThe functions declared within \u003ccode\u003e\u0026lt;cctype\u0026gt;\u003c/code\u003e support the classification and case mapping of characters. \u003cem\u003eUndefined behaviour\u003c/em\u003e\noccurs if these functions are called with arguments that are not representable as an \u003ccode\u003eunsigned char\u003c/code\u003e, or that are not equal to the value of\nthe macro \u003ccode\u003eEOF\u003c/code\u003e. Similar issues exist for the functions provided by \u003ccode\u003e\u0026lt;cwctype\u0026gt;\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThe C++ Standard Library provides equivalent classification and case mapping functions within \u003ccode\u003e\u0026lt;locale\u0026gt;\u003c/code\u003e that are safer to\nuse.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e the C++ Standard states that the behaviour of the functions covered by this rule is defined in the related version of\nISO\u0026nbsp;9899\u0026nbsp;.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nvoid f( char c )\n{\n  if ( std::isdigit( c ) ) {}                    // Non-compliant\n  if ( std::isdigit( a, std::locale {} ) ) {}    // Compliant version of the above\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cp\u003e\u003ca\nhref\u003d\"https://wiki.sei.cmu.edu/confluence/display/c/STR37-C.+Arguments+to+character-handling+functions+must+be+representable+as+an+unsigned+char\"\u003eCERT,\nSTR37-C.\u003c/a\u003e - Arguments to character-handling functions must be representable as an unsigned char\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 24.5.1\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eThis rule applies to the character classification functions and the character case mapping functions from \u003ccode\u003e\u0026lt;cctype\u0026gt;\u003c/code\u003e and\n\u003ccode\u003e\u0026lt;cwctype\u0026gt;\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e this rule also applies to the same functions from \u003ccode\u003e\u0026lt;ctype.h\u0026gt;\u003c/code\u003e and \u003ccode\u003e\u0026lt;wctype.h\u0026gt;\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eThe functions declared within \u003ccode\u003e\u0026lt;cctype\u0026gt;\u003c/code\u003e support the classification and case mapping of characters. \u003cem\u003eUndefined behaviour\u003c/em\u003e\noccurs if these functions are called with arguments that are not representable as an \u003ccode\u003eunsigned char\u003c/code\u003e, or that are not equal to the value of\nthe macro \u003ccode\u003eEOF\u003c/code\u003e. Similar issues exist for the functions provided by \u003ccode\u003e\u0026lt;cwctype\u0026gt;\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThe C++ Standard Library provides equivalent classification and case mapping functions within \u003ccode\u003e\u0026lt;locale\u0026gt;\u003c/code\u003e that are safer to\nuse.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e the C++ Standard states that the behaviour of the functions covered by this rule is defined in the related version of\nISO\u0026nbsp;9899\u0026nbsp;.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nvoid f( char c )\n{\n  if ( std::isdigit( c ) ) {}                    // Non-compliant\n  if ( std::isdigit( a, std::locale {} ) ) {}    // Compliant version of the above\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cp\u003e\u003ca\nhref\u003d\"https://wiki.sei.cmu.edu/confluence/display/c/STR37-C.+Arguments+to+character-handling+functions+must+be+representable+as+an+unsigned+char\"\u003eCERT,\nSTR37-C.\u003c/a\u003e - Arguments to character-handling functions must be representable as an unsigned char\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "misra-c++2023",
      "misra-required",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6191",
    "name": "\"volatile\" types should not be used in compound operations",
    "defaultSeverity": "CRITICAL",
    "type": "BUG",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eIn C++, it usually does not matter how many times you access a variable as long as the variable value is the right one. However, this is not the\ncase when the variable is in a memory region mapped to external hardware. In that case, for instance, several successive reads can yield different\nvalues (if the memory is updated by the hardware in-between), and several writes of the same value may be significant (some hardware trigger events\neach time a memory location is written to).\u003c/p\u003e\n\u003cp\u003eTo specify that every read and write has an impact outside of the abstract machine of the language, access to a variable may be qualified as\n\u003ccode\u003evolatile\u003c/code\u003e: it will oblige the program to perform all specified reads and writes operations without optimizing anything away.\u003c/p\u003e\n\u003cp\u003eWhen a variable appears in a compound expression (for instance, \u003ccode\u003ea++\u003c/code\u003e or \u003ccode\u003ea+\u003d2\u003c/code\u003e), the variable is accessed twice even if it\nis only named once. The standard was not explicit on this topic up until C++23, but this detail matters for \u003ccode\u003evolatile\u003c/code\u003e variables for which\nevery access to the variable matters.\u003c/p\u003e\n\u003cp\u003eConsequently, it is usually clearer to rewrite the code so that the variable appears twice, matching the number of accesses that will happen.\u003c/p\u003e\n\u003cp\u003eNote: In C++20, compound expressions on volatile variables were deprecated. This deprecation was removed in C++23, and the number of accesses was\nmade explicit. The reason for removing the deprecation is that such operations are commonly used in embedded code, especially to access specific\nvariable bits. However, using a function with a dedicated name instead of direct bit manipulation usually leads to code that is easier to read.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eAs every access to a \u003ccode\u003evolatile\u003c/code\u003e variable matters, the number of access should be explicitly visible in the code.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre\u003e\nvoid f1(int volatile* p) {\n  ++(*p); // Noncompliant\n}\n\nvoid f2(volatile int\u0026amp; in) {\n  in +\u003d 2; // Noncompliant\n}\n\nvoid f3(volatile int\u0026amp; in) {\n  int i \u003d in \u003d 2; // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre\u003e\nvoid f1(int volatile* p) {\n  auto val \u003d *p;  // One access to read the register\n  *p \u003d val + 1; // One access to write to it (and potentially overwrite another change)\n}\n\nvoid f2(volatile int\u0026amp; in) {\n  auto val \u003d in;\n  in \u003d val + 2;\n}\n\nvoid f3(volatile int\u0026amp; in) {\n  in \u003d 2;\n  int i \u003d in;\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eIn C++, it usually does not matter how many times you access a variable as long as the variable value is the right one. However, this is not the\ncase when the variable is in a memory region mapped to external hardware. In that case, for instance, several successive reads can yield different\nvalues (if the memory is updated by the hardware in-between), and several writes of the same value may be significant (some hardware trigger events\neach time a memory location is written to).\u003c/p\u003e\n\u003cp\u003eTo specify that every read and write has an impact outside of the abstract machine of the language, access to a variable may be qualified as\n\u003ccode\u003evolatile\u003c/code\u003e: it will oblige the program to perform all specified reads and writes operations without optimizing anything away.\u003c/p\u003e\n\u003cp\u003eWhen a variable appears in a compound expression (for instance, \u003ccode\u003ea++\u003c/code\u003e or \u003ccode\u003ea+\u003d2\u003c/code\u003e), the variable is accessed twice even if it\nis only named once. The standard was not explicit on this topic up until C++23, but this detail matters for \u003ccode\u003evolatile\u003c/code\u003e variables for which\nevery access to the variable matters.\u003c/p\u003e\n\u003cp\u003eConsequently, it is usually clearer to rewrite the code so that the variable appears twice, matching the number of accesses that will happen.\u003c/p\u003e\n\u003cp\u003eNote: In C++20, compound expressions on volatile variables were deprecated. This deprecation was removed in C++23, and the number of accesses was\nmade explicit. The reason for removing the deprecation is that such operations are commonly used in embedded code, especially to access specific\nvariable bits. However, using a function with a dedicated name instead of direct bit manipulation usually leads to code that is easier to read.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eAs every access to a \u003ccode\u003evolatile\u003c/code\u003e variable matters, the number of access should be explicitly visible in the code.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre\u003e\nvoid f1(int volatile* p) {\n  ++(*p); // Noncompliant\n}\n\nvoid f2(volatile int\u0026amp; in) {\n  in +\u003d 2; // Noncompliant\n}\n\nvoid f3(volatile int\u0026amp; in) {\n  int i \u003d in \u003d 2; // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre\u003e\nvoid f1(int volatile* p) {\n  auto val \u003d *p;  // One access to read the register\n  *p \u003d val + 1; // One access to write to it (and potentially overwrite another change)\n}\n\nvoid f2(volatile int\u0026amp; in) {\n  auto val \u003d in;\n  in \u003d val + 2;\n}\n\nvoid f3(volatile int\u0026amp; in) {\n  in \u003d 2;\n  int i \u003d in;\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6192",
    "name": "Cyclomatic Complexity of coroutines should not be too high",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "FOCUSED",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe Cyclomatic Complexity of coroutines should not exceed a defined threshold. Complex code may perform poorly and can be difficult to test\nthoroughly.\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe Cyclomatic Complexity of coroutines should not exceed a defined threshold. Complex code may perform poorly and can be difficult to test\nthoroughly.\u003c/p\u003e"
      }
    ],
    "params": {
      "maximumCoroutineCyclomaticComplexityThreshold": {
        "key": "maximumCoroutineCyclomaticComplexityThreshold",
        "name": "maximumCoroutineCyclomaticComplexityThreshold",
        "description": "The maximum authorized complexity.",
        "defaultValue": "10",
        "type": "INTEGER",
        "multiple": false,
        "possibleValues": []
      }
    },
    "defaultParams": {
      "maximumCoroutineCyclomaticComplexityThreshold": "10"
    },
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "brain-overload",
      "since-c++20"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6190",
    "name": "\"std::source_location\" should be used instead of \"__FILE__\", \"__LINE__\", and \"__func__\" macros",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eC++20 introduced \u003ccode\u003estd::source_location\u003c/code\u003e to represent the information about the code point. This class exposes the same information as\n\u003ccode\u003e__FILE__\u003c/code\u003e, \u003ccode\u003e__LINE__\u003c/code\u003e, and \u003ccode\u003e__func__\u003c/code\u003e and makes passing this information as a single argument possible.\u003c/p\u003e\n\u003cp\u003eFurthermore, the \u003ccode\u003estd::source_location::current()\u003c/code\u003e function, when used as the default argument of the function parameter, will collect\ninformation from the call site. Consequently, this class enables the replacement of various logging macros, with functions accepting\n\u003ccode\u003estd::source_location\u003c/code\u003e as a parameter.\u003c/p\u003e\n\u003cp\u003eThis rule reports the use of source location-related macros like \u003ccode\u003e__FILE__\u003c/code\u003e, \u003ccode\u003e__LINE__\u003c/code\u003e, and \u003ccode\u003e__func__\u003c/code\u003e which can\nbe replaced by \u003ccode\u003estd::source_location\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid log(std::string_view message, std::string_view func, std::uint_least32_t line);\n\n#define TRACE(msg) std::cout \u0026lt;\u0026lt; __FILE__ \u0026lt;\u0026lt; \u0027:\u0027 \u0026lt;\u0026lt;__LINE__ \u0026lt;\u0026lt; \u0027 \u0027 \u0026lt;\u0026lt; msg // Noncompliant\n\nvoid func() {\n    log(\"entering func\", __func__, __LINE__);  // Noncompliant\n    TRACE(\"leaving func\");\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid log(std::string_view message, std::source_location loc \u003d std::source_location::current());\n\nstd::ostream trace(std::string_view msg,\n                   std::source_location location \u003d std::source_location::current()) {\n  return std::cout \u0026lt;\u0026lt; location.file_name() \u0026lt;\u0026lt; \u0027:\u0027 \u0026lt;\u0026lt; location.line() \u0026lt;\u0026lt; \u0027 \u0027 \u0026lt;\u0026lt; msg;\n}\n\nvoid func() {\n    log(\"entering func\");\n    // or equivalently log(\"entering func\", std::source_location::current());\n    trace(\"leaving func\");\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/utility/source_location\"\u003estd::source_location\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eC++20 introduced \u003ccode\u003estd::source_location\u003c/code\u003e to represent the information about the code point. This class exposes the same information as\n\u003ccode\u003e__FILE__\u003c/code\u003e, \u003ccode\u003e__LINE__\u003c/code\u003e, and \u003ccode\u003e__func__\u003c/code\u003e and makes passing this information as a single argument possible.\u003c/p\u003e\n\u003cp\u003eFurthermore, the \u003ccode\u003estd::source_location::current()\u003c/code\u003e function, when used as the default argument of the function parameter, will collect\ninformation from the call site. Consequently, this class enables the replacement of various logging macros, with functions accepting\n\u003ccode\u003estd::source_location\u003c/code\u003e as a parameter.\u003c/p\u003e\n\u003cp\u003eThis rule reports the use of source location-related macros like \u003ccode\u003e__FILE__\u003c/code\u003e, \u003ccode\u003e__LINE__\u003c/code\u003e, and \u003ccode\u003e__func__\u003c/code\u003e which can\nbe replaced by \u003ccode\u003estd::source_location\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid log(std::string_view message, std::string_view func, std::uint_least32_t line);\n\n#define TRACE(msg) std::cout \u0026lt;\u0026lt; __FILE__ \u0026lt;\u0026lt; \u0027:\u0027 \u0026lt;\u0026lt;__LINE__ \u0026lt;\u0026lt; \u0027 \u0027 \u0026lt;\u0026lt; msg // Noncompliant\n\nvoid func() {\n    log(\"entering func\", __func__, __LINE__);  // Noncompliant\n    TRACE(\"leaving func\");\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid log(std::string_view message, std::source_location loc \u003d std::source_location::current());\n\nstd::ostream trace(std::string_view msg,\n                   std::source_location location \u003d std::source_location::current()) {\n  return std::cout \u0026lt;\u0026lt; location.file_name() \u0026lt;\u0026lt; \u0027:\u0027 \u0026lt;\u0026lt; location.line() \u0026lt;\u0026lt; \u0027 \u0027 \u0026lt;\u0026lt; msg;\n}\n\nvoid func() {\n    log(\"entering func\");\n    // or equivalently log(\"entering func\", std::source_location::current());\n    trace(\"leaving func\");\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/utility/source_location\"\u003estd::source_location\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "since-c++20"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:M23_400",
    "name": "An \"integer-literal\" of type \"long long\" shall not use a single \"L\" or \"l\" in any suffix",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 5.13.6\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eThis rule applies to both \u003ccode\u003esigned long long\u003c/code\u003e and \u003ccode\u003eunsigned long long\u003c/code\u003e literals.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e this rule does not apply to \u003cem\u003euser-defined-literals\u003c/em\u003e.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eA literal with a suffix that has a single \u003ccode\u003eL\u003c/code\u003e could be a \u003ccode\u003esigned\u003c/code\u003e or \u003ccode\u003eunsigned long long\u003c/code\u003e. Use of the\n\u003ccode\u003eLL\u003c/code\u003e suffix for \u003ccode\u003elong long\u003c/code\u003e literals is more explicit and less error-prone.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cp\u003eAll of the following examples assume that \u003ccode\u003elong\u003c/code\u003e is 32-bits and \u003ccode\u003elong long\u003c/code\u003e is 64-bits.\u003c/p\u003e\n\u003cpre\u003e\nauto k1 \u003d 12345678998L;        // Non-compliant\nauto k2 \u003d 12345678998UL;       // Non-compliant\nauto k3 \u003d 12345678998ull;      // Compliant\nauto k4 \u003d 0xfeeddeadbeefL;     // Non-compliant\nauto k5 \u003d 0xfeeddeadbeefLL;    // Compliant\n\u003c/pre\u003e\n\u003cp\u003eThe rule does not apply to the following as the value is not \u003ccode\u003elong long\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\nauto k6 \u003d 12345L;\nauto k7 \u003d 12345UL;\nauto k8 \u003d 0x0badc0deL;\n\u003c/pre\u003e\n\u003cp\u003eThe rule does not apply to the following as they do not have \u003ccode\u003eL\u003c/code\u003e or \u003ccode\u003el\u003c/code\u003e suffixes:\u003c/p\u003e\n\u003cpre\u003e\nauto k9 \u003d 12345678998;\nauto kA \u003d 12345678998U;\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003eMISRA C++ 2023 Rule\u0026nbsp;5.13.5 - The lowercase form of \"L\" shall not be used as the first character in a literal suffix\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 5.13.6\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eThis rule applies to both \u003ccode\u003esigned long long\u003c/code\u003e and \u003ccode\u003eunsigned long long\u003c/code\u003e literals.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e this rule does not apply to \u003cem\u003euser-defined-literals\u003c/em\u003e.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eA literal with a suffix that has a single \u003ccode\u003eL\u003c/code\u003e could be a \u003ccode\u003esigned\u003c/code\u003e or \u003ccode\u003eunsigned long long\u003c/code\u003e. Use of the\n\u003ccode\u003eLL\u003c/code\u003e suffix for \u003ccode\u003elong long\u003c/code\u003e literals is more explicit and less error-prone.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cp\u003eAll of the following examples assume that \u003ccode\u003elong\u003c/code\u003e is 32-bits and \u003ccode\u003elong long\u003c/code\u003e is 64-bits.\u003c/p\u003e\n\u003cpre\u003e\nauto k1 \u003d 12345678998L;        // Non-compliant\nauto k2 \u003d 12345678998UL;       // Non-compliant\nauto k3 \u003d 12345678998ull;      // Compliant\nauto k4 \u003d 0xfeeddeadbeefL;     // Non-compliant\nauto k5 \u003d 0xfeeddeadbeefLL;    // Compliant\n\u003c/pre\u003e\n\u003cp\u003eThe rule does not apply to the following as the value is not \u003ccode\u003elong long\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\nauto k6 \u003d 12345L;\nauto k7 \u003d 12345UL;\nauto k8 \u003d 0x0badc0deL;\n\u003c/pre\u003e\n\u003cp\u003eThe rule does not apply to the following as they do not have \u003ccode\u003eL\u003c/code\u003e or \u003ccode\u003el\u003c/code\u003e suffixes:\u003c/p\u003e\n\u003cpre\u003e\nauto k9 \u003d 12345678998;\nauto kA \u003d 12345678998U;\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003eMISRA C++ 2023 Rule\u0026nbsp;5.13.5 - The lowercase form of \"L\" shall not be used as the first character in a literal suffix\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "misra-c++2023",
      "misra-required",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S3923",
    "name": "All branches in a conditional structure should not have exactly the same implementation",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eHaving all branches of a \u003ccode\u003eswitch\u003c/code\u003e or \u003ccode\u003eif\u003c/code\u003e chain with the same implementation indicates a problem.\u003c/p\u003e\n\u003cp\u003eIn the following code:\u003c/p\u003e\n\u003cpre\u003e\nif (b \u003d\u003d 0) {  // Noncompliant\n  doOneMoreThing();\n} else {\n  doOneMoreThing();\n}\n\nint b \u003d a \u0026gt; 12 ? 4 : 4;  // Noncompliant\n\nswitch (i) {  // Noncompliant\n  case 1:\n    doSomething();\n    break;\n  case 2:\n    doSomething();\n    break;\n  case 3:\n    doSomething();\n    break;\n  default:\n    doSomething();\n}\n\u003c/pre\u003e\n\u003cp\u003eEither there is a copy-paste error that needs fixing or an unnecessary \u003ccode\u003eswitch\u003c/code\u003e or \u003ccode\u003eif\u003c/code\u003e chain that needs removing.\u003c/p\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThis rule does not apply to \u003ccode\u003eif\u003c/code\u003e chains without \u003ccode\u003eelse\u003c/code\u003e, nor to \u003ccode\u003eswitch\u003c/code\u003e without a \u003ccode\u003edefault\u003c/code\u003e clause.\u003c/p\u003e\n\u003cpre\u003e\nif(b \u003d\u003d 0) {    //no issue, this could have been done on purpose to make the code more readable\n  doSomething();\n} else if(b \u003d\u003d 1) {\n  doSomething();\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eHaving all branches of a \u003ccode\u003eswitch\u003c/code\u003e or \u003ccode\u003eif\u003c/code\u003e chain with the same implementation indicates a problem.\u003c/p\u003e\n\u003cp\u003eIn the following code:\u003c/p\u003e\n\u003cpre\u003e\nif (b \u003d\u003d 0) {  // Noncompliant\n  doOneMoreThing();\n} else {\n  doOneMoreThing();\n}\n\nint b \u003d a \u0026gt; 12 ? 4 : 4;  // Noncompliant\n\nswitch (i) {  // Noncompliant\n  case 1:\n    doSomething();\n    break;\n  case 2:\n    doSomething();\n    break;\n  case 3:\n    doSomething();\n    break;\n  default:\n    doSomething();\n}\n\u003c/pre\u003e\n\u003cp\u003eEither there is a copy-paste error that needs fixing or an unnecessary \u003ccode\u003eswitch\u003c/code\u003e or \u003ccode\u003eif\u003c/code\u003e chain that needs removing.\u003c/p\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThis rule does not apply to \u003ccode\u003eif\u003c/code\u003e chains without \u003ccode\u003eelse\u003c/code\u003e, nor to \u003ccode\u003eswitch\u003c/code\u003e without a \u003ccode\u003edefault\u003c/code\u003e clause.\u003c/p\u003e\n\u003cpre\u003e\nif(b \u003d\u003d 0) {    //no issue, this could have been done on purpose to make the code more readable\n  doSomething();\n} else if(b \u003d\u003d 1) {\n  doSomething();\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S3805",
    "name": "\"#import\" should not be used",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003e#import\u003c/code\u003e comes from Objective-C and is a variant of \u003ccode\u003e#include\u003c/code\u003e. GCC does support it, but it requires the users of a header\nfile to know that it should only be included once. It is much better for the header file’s implementor to write the file so that users don’t need to\nknow this. Using a wrapper \u003ccode\u003e#ifndef\u003c/code\u003e accomplishes this goal.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#import \"foo.h\" // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#include \"foo.h\"\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003ccode\u003e#import\u003c/code\u003e comes from Objective-C and is a variant of \u003ccode\u003e#include\u003c/code\u003e. GCC does support it, but it requires the users of a header\nfile to know that it should only be included once. It is much better for the header file’s implementor to write the file so that users don’t need to\nknow this. Using a wrapper \u003ccode\u003e#ifndef\u003c/code\u003e accomplishes this goal.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#import \"foo.h\" // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#include \"foo.h\"\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1749",
    "name": "Type specifiers should be listed in a standard order",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eShared coding conventions allow teams to collaborate efficiently. This rule checks that type specifiers always appear in the following order:\u003c/p\u003e\n\u003col\u003e\n  \u003cli\u003e \u003ccode\u003etypedef\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e type name, spelling of built-in types with more than one type-specifier:\n    \u003col\u003e\n      \u003cli\u003e signedness - \u003ccode\u003esigned\u003c/code\u003e or \u003ccode\u003eunsigned\u003c/code\u003e \u003c/li\u003e\n      \u003cli\u003e last single type-specifier or\n        \u003cul\u003e\n          \u003cli\u003e \u003ccode\u003eshort int\u003c/code\u003e \u003c/li\u003e\n          \u003cli\u003e \u003ccode\u003elong int\u003c/code\u003e \u003c/li\u003e\n          \u003cli\u003e \u003ccode\u003elong long int\u003c/code\u003e \u003c/li\u003e\n          \u003cli\u003e \u003ccode\u003elong double\u003c/code\u003e \u003c/li\u003e\n        \u003c/ul\u003e  \u003c/li\u003e\n    \u003c/ol\u003e  \u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eSince the positioning of the \u003ccode\u003econst\u003c/code\u003e keyword is controversial, this rule does not check it.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint typedef T;\n\ndouble long d;\nchar unsigned ch;\nlong signed int i;\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\ntypedef int T;\n\nlong double d;\nunsigned char ch;\nsigned long int i;\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#nl26-use-conventional-const-notation\"\u003eNL.26: Use conventional\n  \u003ccode\u003econst\u003c/code\u003e notation\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eShared coding conventions allow teams to collaborate efficiently. This rule checks that type specifiers always appear in the following order:\u003c/p\u003e\n\u003col\u003e\n  \u003cli\u003e \u003ccode\u003etypedef\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e type name, spelling of built-in types with more than one type-specifier:\n    \u003col\u003e\n      \u003cli\u003e signedness - \u003ccode\u003esigned\u003c/code\u003e or \u003ccode\u003eunsigned\u003c/code\u003e \u003c/li\u003e\n      \u003cli\u003e last single type-specifier or\n        \u003cul\u003e\n          \u003cli\u003e \u003ccode\u003eshort int\u003c/code\u003e \u003c/li\u003e\n          \u003cli\u003e \u003ccode\u003elong int\u003c/code\u003e \u003c/li\u003e\n          \u003cli\u003e \u003ccode\u003elong long int\u003c/code\u003e \u003c/li\u003e\n          \u003cli\u003e \u003ccode\u003elong double\u003c/code\u003e \u003c/li\u003e\n        \u003c/ul\u003e  \u003c/li\u003e\n    \u003c/ol\u003e  \u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eSince the positioning of the \u003ccode\u003econst\u003c/code\u003e keyword is controversial, this rule does not check it.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint typedef T;\n\ndouble long d;\nchar unsigned ch;\nlong signed int i;\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\ntypedef int T;\n\nlong double d;\nunsigned char ch;\nsigned long int i;\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#nl26-use-conventional-const-notation\"\u003eNL.26: Use conventional\n  \u003ccode\u003econst\u003c/code\u003e notation\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "cppcoreguidelines"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S3807",
    "name": "Parameter values should be appropriate",
    "defaultSeverity": "CRITICAL",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003cp\u003ePassing \u003ccode\u003eNULL\u003c/code\u003e to a C library function that requires non-null pointer arguments results in undefined behavior.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe standard C library includes a variety of functions for string and general memory manipulations. Many of these functions require valid\nparameters and when given values outside a function’s domain, the behavior is undefined. Functions like \u003ccode\u003estrlen\u003c/code\u003e, \u003ccode\u003ememset\u003c/code\u003e,\n\u003ccode\u003ememcpy\u003c/code\u003e, \u003ccode\u003eqsort\u003c/code\u003e, \u003ccode\u003efread\u003c/code\u003e, etc., for instance, require non-\u003ccode\u003eNULL\u003c/code\u003e parameters, and passing a\n\u003ccode\u003eNULL\u003c/code\u003e value introduces undefined behavior. In that case, the application may crash or, even worse, silently lose data or produce incorrect\nresults.\u003c/p\u003e\n\u003cp\u003eConsider the following code. If the pointer-typed variable \u003ccode\u003ebuf\u003c/code\u003e is \u003ccode\u003eNULL\u003c/code\u003e due to a failed memory allocation, for instance,\nthe call to \u003ccode\u003ememset()\u003c/code\u003e will cause undefined behavior.\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;string.h\u0026gt;\n\nvoid process_buffer(char *buf, size_t size) {\n  // Call to `memset()` may lead to undefined behavior, if `buf` is NULL.\n  memset(buf, 0, size);\n}\n\u003c/pre\u003e\n\u003cp\u003eSimilarly, if for some reason a \u003ccode\u003eNULL\u003c/code\u003e pointer slips through and reaches the string manipulation code shown in the following, the\napplication’s behavior is undefined.\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;string.h\u0026gt;\n\nint compare_strings(const char *str_a, const char *str_b) {\n  // Both functions `strlen()` and `strncmp()` may not receive a `NULL` pointer.\n  size_t len_a \u003d strlen(str_a);\n  size_t len_b \u003d strlen(str_b);\n  size_t min \u003d (len_a \u0026lt;\u003d len_b) ? len_a : len_b;\n  return strncmp(str_a, str_b, min);\n}\n\u003c/pre\u003e\n\u003cp\u003eHence, users have to ensure that the C standard library functions\u0027 preconditions are met and valid parameters are passed.\u003c/p\u003e\n\u003cp\u003eThe C library functions that are considered by this rule and that require non-\u003ccode\u003eNULL\u003c/code\u003e pointer parameters are listed in this rule’s\nResources section.\u003c/p\u003e\n\u003ch2\u003eWhat is the potential impact?\u003c/h2\u003e\n\u003cp\u003eIf an argument to one of the C library functions mentioned by this rule is a \u003ccode\u003eNULL\u003c/code\u003e pointer, the behavior of the application is\nundefined.\u003c/p\u003e\n\u003cp\u003eWhen a program comprises undefined behavior, the compiler no longer needs to adhere to the language standard, and the program has no meaning\nassigned to it.\u003c/p\u003e\n\u003cp\u003eDue to the resulting \u003ccode\u003eNULL\u003c/code\u003e pointer dereferences in the C library functions, the application might just crash, but in the worst case,\nthe application may appear to execute correctly, while losing data or producing incorrect results.\u003c/p\u003e\n\u003cp\u003eBesides affecting the application’s availability, \u003ccode\u003eNULL\u003c/code\u003e pointer dereferences may lead to code execution, in rare circumstances. If\n\u003ccode\u003eNULL\u003c/code\u003e is equivalent to the \u003ccode\u003e0x0\u003c/code\u003e memory address that can be accessed by privileged code, writing and reading memory is\npossible, which compromises the integrity and confidentiality of the application.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eEnsure that any pointer passed to any of the C library functions mentioned by this rule \u003cem\u003eis not\u003c/em\u003e \u003ccode\u003eNULL\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n#include \u0026lt;string.h\u0026gt;\n\nint process_string() {\n  char buffer[] \u003d \"Hello, World!\";\n  char *str \u003d (char *)malloc(sizeof(buffer));\n  if (!str) {\n    printf(\"Memory allocation failed!\\n\");\n  }\n  // Noncompliant: 1st parameter in the subsequent call to `memcpy()` might be\n  // NULL due to insufficient handling of a potentially failed memory\n  // allocation.\n  memcpy(str, buffer, sizeof(buffer));\n  // Process dynamically alloacted `str` variable.\n  // ...\n  // Free memory, if it is no longer in use.\n  free(str);\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n#include \u0026lt;string.h\u0026gt;\n\nint process_string() {\n  char buffer[] \u003d \"Hello, World!\";\n  char *str \u003d (char *)malloc(sizeof(buffer));\n  if (!str) {\n    printf(\"Memory allocation failed!\\n\");\n    return 1;\n  }\n  // Compliant: 1st parameter will always denote a non-null pointer.\n  memcpy(str, buffer, sizeof(buffer));\n  // Process dynamically alloacted `str` variable.\n  // ...\n  // Free memory, if it is no longer in use.\n  free(str);\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cp\u003eThe list of functions considered by this rule is shown in the following:\u003c/p\u003e\n\u003cpre\u003e\naio_suspend, bcmp, bcopy, bsearch, bzero, confstr, encrypt, erand48,\nexplicit_bzero, explicit_memset, fgetpwent_r, fgets, fgetws, fread, fwrite,\ngetdelim, getgrgid_r, getgrnam_r, gethostbyaddr_r, gethostbyname2_r,\ngethostbyname_r, gethostent_r, gethostname, getline, getlogin_r,\ngetnetbyaddr_r, getnetbyname_r, getnetent_r, getnetgrent_r, getopt,\ngetopt_long, getopt_long_only, getprotobyname_r, getprotobynumber_r,\ngetprotoent_r, getpwent_r, getpwnam_r, getpwuid_r, getservbyname_r,\ngetservbyport_r, getservent_r, iconv, initstate, jrand48, lcong48, lfind,\nlio_listio, lsearch, mblen, mbrlen, mbrtowc, mbsnrtowcs, mbsrtowcs,\nmbstowcs, mbtowc, memccpy, memchr, memcmp, memcpy, memmove, mempcpy,\nmemset, mq_receive, mq_send, mq_timedreceive, mq_timedsend, nrand48,\nposix_trace_event, posix_trace_trygetnext_event, pread, preadv, preadv2,\npthread_attr_setstack, pwrite, pwritev, pwritev2, qsort, qsort_r, read,\nreadlink, readlinkat, readv, realpath, recv, recvfrom, regerror, regexec,\nseed48, semop, semtimedop, send, sendto, setbuf, setbuffer, setvbuf,\nsnprintf, socketpair, std::copy (for C++), std::copy_backward (for C++),\nstpcpy, strcasecmp, strcat, strcmp, strcpy, strfmon, strfmon_l, strftime,\nstrftime_l, strlcat, strlcpy, strlen, strncasecmp, strncat, strncmp, strncpy,\nstrnlen, strsep, swab, swprintf, ttyname_r, utimes, vsnprintf, vswprintf,\nwcpncpy, wcsftime, wcslen, wcsncasecmp, wcsncasecmp_l, wcsncmp, wcsncpy,\nwcsnlen, wcsnrtombs, wcsrtombs, wcstombs, wcswidth, wcsxfrm, wcsxfrm_l,\nwmemchr, wmemcmp, wmemcpy, wmemmove, wmemcpy, wmemset, write, writev\n\u003c/pre\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/476\"\u003e476 NULL Pointer Dereference\u003c/a\u003e CERT - \u003ca\n  href\u003d\"https://wiki.sei.cmu.edu/confluence/x/QdcxBQ\"\u003eEXP34-C.Do not dereference null pointers\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S2259} detects dereferences of null pointers \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S2637} detects uses of null pointers as arguments for parameters that are annotated with \u003ccode\u003enonnull\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003ePassing \u003ccode\u003eNULL\u003c/code\u003e to a C library function that requires non-null pointer arguments results in undefined behavior.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe standard C library includes a variety of functions for string and general memory manipulations. Many of these functions require valid\nparameters and when given values outside a function’s domain, the behavior is undefined. Functions like \u003ccode\u003estrlen\u003c/code\u003e, \u003ccode\u003ememset\u003c/code\u003e,\n\u003ccode\u003ememcpy\u003c/code\u003e, \u003ccode\u003eqsort\u003c/code\u003e, \u003ccode\u003efread\u003c/code\u003e, etc., for instance, require non-\u003ccode\u003eNULL\u003c/code\u003e parameters, and passing a\n\u003ccode\u003eNULL\u003c/code\u003e value introduces undefined behavior. In that case, the application may crash or, even worse, silently lose data or produce incorrect\nresults.\u003c/p\u003e\n\u003cp\u003eConsider the following code. If the pointer-typed variable \u003ccode\u003ebuf\u003c/code\u003e is \u003ccode\u003eNULL\u003c/code\u003e due to a failed memory allocation, for instance,\nthe call to \u003ccode\u003ememset()\u003c/code\u003e will cause undefined behavior.\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;string.h\u0026gt;\n\nvoid process_buffer(char *buf, size_t size) {\n  // Call to `memset()` may lead to undefined behavior, if `buf` is NULL.\n  memset(buf, 0, size);\n}\n\u003c/pre\u003e\n\u003cp\u003eSimilarly, if for some reason a \u003ccode\u003eNULL\u003c/code\u003e pointer slips through and reaches the string manipulation code shown in the following, the\napplication’s behavior is undefined.\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;string.h\u0026gt;\n\nint compare_strings(const char *str_a, const char *str_b) {\n  // Both functions `strlen()` and `strncmp()` may not receive a `NULL` pointer.\n  size_t len_a \u003d strlen(str_a);\n  size_t len_b \u003d strlen(str_b);\n  size_t min \u003d (len_a \u0026lt;\u003d len_b) ? len_a : len_b;\n  return strncmp(str_a, str_b, min);\n}\n\u003c/pre\u003e\n\u003cp\u003eHence, users have to ensure that the C standard library functions\u0027 preconditions are met and valid parameters are passed.\u003c/p\u003e\n\u003cp\u003eThe C library functions that are considered by this rule and that require non-\u003ccode\u003eNULL\u003c/code\u003e pointer parameters are listed in this rule’s\nResources section.\u003c/p\u003e\n\u003ch2\u003eWhat is the potential impact?\u003c/h2\u003e\n\u003cp\u003eIf an argument to one of the C library functions mentioned by this rule is a \u003ccode\u003eNULL\u003c/code\u003e pointer, the behavior of the application is\nundefined.\u003c/p\u003e\n\u003cp\u003eWhen a program comprises undefined behavior, the compiler no longer needs to adhere to the language standard, and the program has no meaning\nassigned to it.\u003c/p\u003e\n\u003cp\u003eDue to the resulting \u003ccode\u003eNULL\u003c/code\u003e pointer dereferences in the C library functions, the application might just crash, but in the worst case,\nthe application may appear to execute correctly, while losing data or producing incorrect results.\u003c/p\u003e\n\u003cp\u003eBesides affecting the application’s availability, \u003ccode\u003eNULL\u003c/code\u003e pointer dereferences may lead to code execution, in rare circumstances. If\n\u003ccode\u003eNULL\u003c/code\u003e is equivalent to the \u003ccode\u003e0x0\u003c/code\u003e memory address that can be accessed by privileged code, writing and reading memory is\npossible, which compromises the integrity and confidentiality of the application.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eEnsure that any pointer passed to any of the C library functions mentioned by this rule \u003cem\u003eis not\u003c/em\u003e \u003ccode\u003eNULL\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n#include \u0026lt;string.h\u0026gt;\n\nint process_string() {\n  char buffer[] \u003d \"Hello, World!\";\n  char *str \u003d (char *)malloc(sizeof(buffer));\n  if (!str) {\n    printf(\"Memory allocation failed!\\n\");\n  }\n  // Noncompliant: 1st parameter in the subsequent call to `memcpy()` might be\n  // NULL due to insufficient handling of a potentially failed memory\n  // allocation.\n  memcpy(str, buffer, sizeof(buffer));\n  // Process dynamically alloacted `str` variable.\n  // ...\n  // Free memory, if it is no longer in use.\n  free(str);\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n#include \u0026lt;string.h\u0026gt;\n\nint process_string() {\n  char buffer[] \u003d \"Hello, World!\";\n  char *str \u003d (char *)malloc(sizeof(buffer));\n  if (!str) {\n    printf(\"Memory allocation failed!\\n\");\n    return 1;\n  }\n  // Compliant: 1st parameter will always denote a non-null pointer.\n  memcpy(str, buffer, sizeof(buffer));\n  // Process dynamically alloacted `str` variable.\n  // ...\n  // Free memory, if it is no longer in use.\n  free(str);\n  return 0;\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cp\u003eThe list of functions considered by this rule is shown in the following:\u003c/p\u003e\n\u003cpre\u003e\naio_suspend, bcmp, bcopy, bsearch, bzero, confstr, encrypt, erand48,\nexplicit_bzero, explicit_memset, fgetpwent_r, fgets, fgetws, fread, fwrite,\ngetdelim, getgrgid_r, getgrnam_r, gethostbyaddr_r, gethostbyname2_r,\ngethostbyname_r, gethostent_r, gethostname, getline, getlogin_r,\ngetnetbyaddr_r, getnetbyname_r, getnetent_r, getnetgrent_r, getopt,\ngetopt_long, getopt_long_only, getprotobyname_r, getprotobynumber_r,\ngetprotoent_r, getpwent_r, getpwnam_r, getpwuid_r, getservbyname_r,\ngetservbyport_r, getservent_r, iconv, initstate, jrand48, lcong48, lfind,\nlio_listio, lsearch, mblen, mbrlen, mbrtowc, mbsnrtowcs, mbsrtowcs,\nmbstowcs, mbtowc, memccpy, memchr, memcmp, memcpy, memmove, mempcpy,\nmemset, mq_receive, mq_send, mq_timedreceive, mq_timedsend, nrand48,\nposix_trace_event, posix_trace_trygetnext_event, pread, preadv, preadv2,\npthread_attr_setstack, pwrite, pwritev, pwritev2, qsort, qsort_r, read,\nreadlink, readlinkat, readv, realpath, recv, recvfrom, regerror, regexec,\nseed48, semop, semtimedop, send, sendto, setbuf, setbuffer, setvbuf,\nsnprintf, socketpair, std::copy (for C++), std::copy_backward (for C++),\nstpcpy, strcasecmp, strcat, strcmp, strcpy, strfmon, strfmon_l, strftime,\nstrftime_l, strlcat, strlcpy, strlen, strncasecmp, strncat, strncmp, strncpy,\nstrnlen, strsep, swab, swprintf, ttyname_r, utimes, vsnprintf, vswprintf,\nwcpncpy, wcsftime, wcslen, wcsncasecmp, wcsncasecmp_l, wcsncmp, wcsncpy,\nwcsnlen, wcsnrtombs, wcsrtombs, wcstombs, wcswidth, wcsxfrm, wcsxfrm_l,\nwmemchr, wmemcmp, wmemcpy, wmemmove, wmemcpy, wmemset, write, writev\n\u003c/pre\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/476\"\u003e476 NULL Pointer Dereference\u003c/a\u003e CERT - \u003ca\n  href\u003d\"https://wiki.sei.cmu.edu/confluence/x/QdcxBQ\"\u003eEXP34-C.Do not dereference null pointers\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S2259} detects dereferences of null pointers \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S2637} detects uses of null pointers as arguments for parameters that are annotated with \u003ccode\u003enonnull\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "symbolic-execution"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S3806",
    "name": "\"#include\" paths should be portable",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe way an \u003ccode\u003e#include\u003c/code\u003e directive finds an actual file is implementation-defined, and in practice, it slightly differs in different\nsystems.\u003c/p\u003e\n\u003cp\u003eTherefore, a good practice is to identify the files to include in the most straightforward way possible to reduce the risk of inconsistent\nbehaviors.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The case of the file in the \u003ccode\u003e#include\u003c/code\u003e directive does not match the case of the file on the disk (the inclusion would not work on a\n  case-sensitive OS), \u003c/li\u003e\n  \u003cli\u003e The file name in the \u003ccode\u003e#include\u003c/code\u003e directive contains trailing spaces (they would be ignored on Windows but considered on Unix). \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include \"Foo.h\" // Noncompliant if the actual file name is \"foo.h\"\n#include \"bar.h \" // Noncompliant, trailing space\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe way an \u003ccode\u003e#include\u003c/code\u003e directive finds an actual file is implementation-defined, and in practice, it slightly differs in different\nsystems.\u003c/p\u003e\n\u003cp\u003eTherefore, a good practice is to identify the files to include in the most straightforward way possible to reduce the risk of inconsistent\nbehaviors.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The case of the file in the \u003ccode\u003e#include\u003c/code\u003e directive does not match the case of the file on the disk (the inclusion would not work on a\n  case-sensitive OS), \u003c/li\u003e\n  \u003cli\u003e The file name in the \u003ccode\u003e#include\u003c/code\u003e directive contains trailing spaces (they would be ignored on Windows but considered on Unix). \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include \"Foo.h\" // Noncompliant if the actual file name is \"foo.h\"\n#include \"bar.h \" // Noncompliant, trailing space\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1862",
    "name": "Related \"if/else if\" statements should not have the same condition",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eA chain of \u003ccode\u003eif\u003c/code\u003e/\u003ccode\u003eelse if\u003c/code\u003e statements is evaluated from top to bottom. At most, only one branch will be executed: the first\none with a condition that evaluates to \u003ccode\u003etrue\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eTherefore, duplicating a condition automatically leads to dead code. Usually, this is due to a copy/paste error. At best, it’s simply dead code and\nat worst, it’s a bug that is likely to induce further bugs as the code is maintained, and obviously it could lead to unexpected behavior.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nif (param \u003d\u003d 1)\n  openWindow();\nelse if (param \u003d\u003d 2)\n  closeWindow();\nelse if (param \u003d\u003d 1)  // Noncompliant\n  moveWindowToTheBackground();\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nif (param \u003d\u003d 1)\n  openWindow();\nelse if (param \u003d\u003d 2)\n  closeWindow();\nelse if (param \u003d\u003d 3)\n  moveWindowToTheBackground();\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/5dUxBQ\"\u003eCERT, MSC12-C.\u003c/a\u003e - Detect and remove code that has no effect or is never executed\n  \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eA chain of \u003ccode\u003eif\u003c/code\u003e/\u003ccode\u003eelse if\u003c/code\u003e statements is evaluated from top to bottom. At most, only one branch will be executed: the first\none with a condition that evaluates to \u003ccode\u003etrue\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eTherefore, duplicating a condition automatically leads to dead code. Usually, this is due to a copy/paste error. At best, it’s simply dead code and\nat worst, it’s a bug that is likely to induce further bugs as the code is maintained, and obviously it could lead to unexpected behavior.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nif (param \u003d\u003d 1)\n  openWindow();\nelse if (param \u003d\u003d 2)\n  closeWindow();\nelse if (param \u003d\u003d 1)  // Noncompliant\n  moveWindowToTheBackground();\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nif (param \u003d\u003d 1)\n  openWindow();\nelse if (param \u003d\u003d 2)\n  closeWindow();\nelse if (param \u003d\u003d 3)\n  moveWindowToTheBackground();\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/5dUxBQ\"\u003eCERT, MSC12-C.\u003c/a\u003e - Detect and remove code that has no effect or is never executed\n  \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cert",
      "pitfall",
      "unused"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6184",
    "name": "Coroutines should not have too many lines of code",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "FOCUSED",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eA coroutine that grows too large tends to aggregate too many responsibilities.\u003c/p\u003e\n\u003cp\u003eSuch coroutines inevitably become harder to understand and therefore harder to maintain.\u003c/p\u003e\n\u003cp\u003eAbove a specific threshold, it is strongly advised to refactor into smaller functions which focus on well-defined tasks. It might be difficult to\nsplit the parts of a coroutine that contain \u003ccode\u003eco_yield\u003c/code\u003e or \u003ccode\u003eco_await\u003c/code\u003e statements, but the other parts can be split into normal\nfunctions.\u003c/p\u003e\n\u003cp\u003eThese smaller functions will not only be easier to understand, but also probably easier to test.\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eA coroutine that grows too large tends to aggregate too many responsibilities.\u003c/p\u003e\n\u003cp\u003eSuch coroutines inevitably become harder to understand and therefore harder to maintain.\u003c/p\u003e\n\u003cp\u003eAbove a specific threshold, it is strongly advised to refactor into smaller functions which focus on well-defined tasks. It might be difficult to\nsplit the parts of a coroutine that contain \u003ccode\u003eco_yield\u003c/code\u003e or \u003ccode\u003eco_await\u003c/code\u003e statements, but the other parts can be split into normal\nfunctions.\u003c/p\u003e\n\u003cp\u003eThese smaller functions will not only be easier to understand, but also probably easier to test.\u003c/p\u003e"
      }
    ],
    "params": {
      "max": {
        "key": "max",
        "name": "max",
        "description": "Maximum authorized lines in a coroutine",
        "defaultValue": "100",
        "type": "INTEGER",
        "multiple": false,
        "possibleValues": []
      }
    },
    "defaultParams": {
      "max": "100"
    },
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "brain-overload",
      "since-c++20"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6185",
    "name": "\"std::format\" should be used instead of string concatenation and \"std::to_string\"",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003estd::format\u003c/code\u003e, introduced by C++20, enables straightforward string construction out of values of various types.\u003c/p\u003e\n\u003cp\u003eBefore C++20, one popular way to obtain the same result was the conversion of the values with \u003ccode\u003estd::to_string\u003c/code\u003e and piecewise string\nconcatenation.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003estd::format\u003c/code\u003e is strictly superior. It is more efficient because it constructs the string in-place instead of copying substrings one by\none. It is also often shorter and easier to read because the format pattern is presented in a single piece and not scattered across the concatenation\nexpression.\u003c/p\u003e\n\u003cp\u003eThis rule reports string concatenation cases that can be replaced by \u003ccode\u003estd::format\u003c/code\u003e and gain in speed and readability.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstd::string greeting(int n) {\n  return \"Hello, player \" + std::to_string(n) + \".\"; // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstd::string greeting(int n) {\n  return std::format(\"Hello, player {}.\", n); // Compliant\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003ccode\u003estd::format\u003c/code\u003e, introduced by C++20, enables straightforward string construction out of values of various types.\u003c/p\u003e\n\u003cp\u003eBefore C++20, one popular way to obtain the same result was the conversion of the values with \u003ccode\u003estd::to_string\u003c/code\u003e and piecewise string\nconcatenation.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003estd::format\u003c/code\u003e is strictly superior. It is more efficient because it constructs the string in-place instead of copying substrings one by\none. It is also often shorter and easier to read because the format pattern is presented in a single piece and not scattered across the concatenation\nexpression.\u003c/p\u003e\n\u003cp\u003eThis rule reports string concatenation cases that can be replaced by \u003ccode\u003estd::format\u003c/code\u003e and gain in speed and readability.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstd::string greeting(int n) {\n  return \"Hello, player \" + std::to_string(n) + \".\"; // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstd::string greeting(int n) {\n  return std::format(\"Hello, player {}.\", n); // Compliant\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "clumsy",
      "since-c++20"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6183",
    "name": "\"std::cmp_*\" functions should be used to compare signed and unsigned values",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003cp\u003eFunctions from the \u003ccode\u003estd::cmp_*\u003c/code\u003e family should be used to compare signed and unsigned values.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eComparisons between \u003ccode\u003esigned\u003c/code\u003e and \u003ccode\u003eunsigned\u003c/code\u003e integers are dangerous because they produce counterintuitive results outside of\ntheir shared value range.\u003c/p\u003e\n\u003cp\u003eWhen a signed integer is compared to an unsigned one, the former might be converted to unsigned. The conversion preserves the two’s-complement bit\npattern of the signed value that often corresponds to a large unsigned result. The expression \u003ccode\u003e2U \u0026lt; -1\u003c/code\u003e evaluates to \u003ccode\u003etrue\u003c/code\u003e,\nfor instance.\u003c/p\u003e\n\u003cp\u003eC++20 introduced remedy to this common pitfall: a family of \u003ccode\u003estd::cmp_*\u003c/code\u003e functions defined in the \u003ccode\u003e\u0026lt;utility\u0026gt;\u003c/code\u003e\nheader:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003estd::cmp_equal\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003estd::cmp_not_equal\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003estd::cmp_less\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003estd::cmp_greater\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003estd::cmp_less_equal\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003estd::cmp_greater_equal\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThese functions correctly handle negative numbers and are safe against lossy integer conversion. For example, the comparison of \u003ccode\u003e2U\u003c/code\u003e and\n\u003ccode\u003e-1\u003c/code\u003e using \u003ccode\u003estd::cmp_less(2U, -1)\u003c/code\u003e evaluates to \u003ccode\u003efalse\u003c/code\u003e and matches common intuition.\u003c/p\u003e\n\u003ch2\u003eWhat is the potential impact?\u003c/h2\u003e\n\u003cp\u003eComparisons between \u003ccode\u003esigned\u003c/code\u003e and \u003ccode\u003eunsigned\u003c/code\u003e integer types produce counterintuitive results.\u003c/p\u003e\n\u003cp\u003eFailing to understand integer conversion rules can lead to tricky bugs and security vulnerabilities. The major integer conversion risks include\nnarrowing types, converting from unsigned to signed and from negative to unsigned.\u003c/p\u003e\n\u003cp\u003eThe following program shall demonstrate the subtlety of the kind of vulnerabilities that integer conversions may introduce. The program is\nvulnerable to buffer overflows due to signed/unsigned integer conversion.\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n#include \u0026lt;string.h\u0026gt;\n#include \u0026lt;unistd.h\u0026gt;\n\nint main(int argc, char **argv) {\n  if (argc !\u003d 3) {\n    printf(\"usage: \u0026lt;prog\u0026gt; \u0026lt;string length - int\u0026gt; \u0026lt;string - const char *\u0026gt;\\n\");\n    return 1;\n  }\n  const int buf_size \u003d 16;\n  char buf[buf_size];\n  int user_input \u003d atoi(argv[1]);\n  if (user_input \u0026gt;\u003d buf_size) {\n    return 1;\n  }\n  // Because `sizeof(*)` returns an unsigned integer, both operands are first\n  // converted to unsigned integers, the multiplication is performed and the\n  // result is of type unsigned integer.\n  memcpy(buf, argv[2], user_input * sizeof(char));\n  if (user_input \u003d\u003d 0xBEEF) {\n    printf(\"Whoopsie daisy, ...\\n\");\n    // A malicious user can craft input arguments such that the flow of control\n    // passes through this call to `execl` which opens a new shell with this\n    // program\u0027s (possibly elevated) permissions.\n    execl(\"/bin/bash\", \"bash\", (char *)NULL);\n  } else {\n    printf(\"Not so fast!\\n\");\n  }\n  return 0;\n}\n\u003c/pre\u003e\n\u003cp\u003eThe program takes as arguments a string and its size, and uses these arguments to copy the string argument into an internal buffer. Before copying\nthe string into its internal buffer it checks whether the user-provided string fits into the buffer. The program also comprises a call to\n\u003ccode\u003eexecl\u003c/code\u003e that opens a shell with the program’s possibly elevated permissions — a potentially dangerous endeavour. Even though the call to\n\u003ccode\u003eexecl\u003c/code\u003e seems unreachable at a first glance, it can actually be reached due to signed/unsigned integer conversion.\u003c/p\u003e\n\u003cp\u003eThe check for the buffer size only validates that the provided string length (\u003ccode\u003euser_input\u003c/code\u003e) is smaller or equal to the buffer’s size.\nSince the \u003ccode\u003eatoi\u003c/code\u003e function returns a signed integer, a user may provide a negative number to withstand that check. The result of\n\u003ccode\u003esizeof(*)\u003c/code\u003e on the other hand returns an unsigned integer which causes the expression \u003ccode\u003euser_input * sizeof(char)\u003c/code\u003e to be\nevaluated by\u003c/p\u003e\n\u003col\u003e\n  \u003cli\u003e converting both operands to unsigned integers, \u003c/li\u003e\n  \u003cli\u003e performing the multiplication, and \u003c/li\u003e\n  \u003cli\u003e returning the result as an unsigned integer type. \u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eA malicious user is hence able to provide carefully crafted negative integer and string to bypass the size check while still arriving at the\nappropriate size argument to not crash \u003ccode\u003ememcpy\u003c/code\u003e. This, in turn, enables the malicious user to overflow the buffer variable \u003ccode\u003ebuf\u003c/code\u003e\nto override the \u003ccode\u003euser_input\u003c/code\u003e variable which allows the second \u003ccode\u003eif\u003c/code\u003e statement to be evaluated to true, eventually opening a new\nshell with the target program’s possibly elevated permissions.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eUse the appropriate function from the \u003ccode\u003estd::cmp_*\u003c/code\u003e family to conduct comparisons between signed and unsigned integer types.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nbool foo(unsigned x, int y) {\n  return x \u0026lt; y; // Noncompliant: y might be negative\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nbool foo(unsigned x, int y) {\n  return std::cmp_less(x, y); // Compliant\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\nbool fun(int x, std::vector\u0026lt;int\u0026gt; const\u0026amp; v) {\n  return x \u0026lt; v.size(); // Noncompliant: x might be negative\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\nbool fun(int x, std::vector\u0026lt;int\u0026gt; const\u0026amp; v) {\n  return std::cmp_less(x, v.size()); // Compliant\n}\n\u003c/pre\u003e\n\u003ch2\u003eInteractions with associated rule {rule:cpp:S6214}\u003c/h2\u003e\n\u003cp\u003eNote that this rule ({rule:cpp:S6183}) deliberately avoids intersection with {rule:cpp:S6214}.\u003c/p\u003e\n\u003cp\u003eWhile {rule:cpp:S6214} raises an issue if the signed value can be proven to be negative (in which case it is definitely a bug), S6281\nwill flag all \u003cstrong\u003eother\u003c/strong\u003e comparisons between signed and unsigned integers. Therefore, if this rule is enabled, {rule:cpp:S6214} should be\nenabled too.\u003c/p\u003e\n\u003cp\u003eThe following code snippet is hence compliant with {rule:cpp:S6183}, but noncompliant with {rule:cpp:S6214} which will raise an issue on this\ndefinite bug.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;iostream\u0026gt;\n\nvoid foo() {\n  if (2U \u0026lt; -1) { // Compliant: the comparison is incorrect but S6214 raises an issue instead of S6183\n    std::cout \u0026lt;\u0026lt; \"2 is less than -1\\n\";\n  } else {\n    std::cout \u0026lt;\u0026lt; \"2 is not less than -1\\n\";\n  }\n}\n\u003c/pre\u003e\n\u003cp\u003eThe fixed version of the code shown in the following is compliant with both rules, {rule:cpp:S6183} and {rule:cpp:S6214}.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;iostream\u0026gt;\n\nvoid foo() {\n  if (std::cmp_less(2U, -1)) { // Compliant: for this rule (S6183) and associated rule S6214\n    std::cout \u0026lt;\u0026lt; \"2 is less than -1\\n\";\n  } else {\n    std::cout \u0026lt;\u0026lt; \"2 is not less than -1\\n\";\n  }\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/utility/intcmp\"\u003eintcmp\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/display/c/INT02-C.+Understand+integer+conversion+rules\"\u003eINT02-C. Understand integer\n  conversion rules\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CERT - \u003ca\n  href\u003d\"https://wiki.sei.cmu.edu/confluence/display/c/INT31-C.+Ensure+that+integer+conversions+do+not+result+in+lost+or+misinterpreted+data\"\u003eINT31-C.\n  Ensure that integer conversions do not result in lost or misinterpreted data\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/195.html\"\u003e195 Signed to Unsigned Conversion Error\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S845} ensures that signed and unsigned types are not mixed in expressions \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S6214} constitutes a version of this rule that only triggers when it detects the involvement of negative values. If {rule:cpp:S6183}\n  is enabled, {rule:cpp:S6214} should be enabled, too. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eFunctions from the \u003ccode\u003estd::cmp_*\u003c/code\u003e family should be used to compare signed and unsigned values.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eComparisons between \u003ccode\u003esigned\u003c/code\u003e and \u003ccode\u003eunsigned\u003c/code\u003e integers are dangerous because they produce counterintuitive results outside of\ntheir shared value range.\u003c/p\u003e\n\u003cp\u003eWhen a signed integer is compared to an unsigned one, the former might be converted to unsigned. The conversion preserves the two’s-complement bit\npattern of the signed value that often corresponds to a large unsigned result. The expression \u003ccode\u003e2U \u0026lt; -1\u003c/code\u003e evaluates to \u003ccode\u003etrue\u003c/code\u003e,\nfor instance.\u003c/p\u003e\n\u003cp\u003eC++20 introduced remedy to this common pitfall: a family of \u003ccode\u003estd::cmp_*\u003c/code\u003e functions defined in the \u003ccode\u003e\u0026lt;utility\u0026gt;\u003c/code\u003e\nheader:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003estd::cmp_equal\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003estd::cmp_not_equal\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003estd::cmp_less\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003estd::cmp_greater\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003estd::cmp_less_equal\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003estd::cmp_greater_equal\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThese functions correctly handle negative numbers and are safe against lossy integer conversion. For example, the comparison of \u003ccode\u003e2U\u003c/code\u003e and\n\u003ccode\u003e-1\u003c/code\u003e using \u003ccode\u003estd::cmp_less(2U, -1)\u003c/code\u003e evaluates to \u003ccode\u003efalse\u003c/code\u003e and matches common intuition.\u003c/p\u003e\n\u003ch2\u003eWhat is the potential impact?\u003c/h2\u003e\n\u003cp\u003eComparisons between \u003ccode\u003esigned\u003c/code\u003e and \u003ccode\u003eunsigned\u003c/code\u003e integer types produce counterintuitive results.\u003c/p\u003e\n\u003cp\u003eFailing to understand integer conversion rules can lead to tricky bugs and security vulnerabilities. The major integer conversion risks include\nnarrowing types, converting from unsigned to signed and from negative to unsigned.\u003c/p\u003e\n\u003cp\u003eThe following program shall demonstrate the subtlety of the kind of vulnerabilities that integer conversions may introduce. The program is\nvulnerable to buffer overflows due to signed/unsigned integer conversion.\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n#include \u0026lt;string.h\u0026gt;\n#include \u0026lt;unistd.h\u0026gt;\n\nint main(int argc, char **argv) {\n  if (argc !\u003d 3) {\n    printf(\"usage: \u0026lt;prog\u0026gt; \u0026lt;string length - int\u0026gt; \u0026lt;string - const char *\u0026gt;\\n\");\n    return 1;\n  }\n  const int buf_size \u003d 16;\n  char buf[buf_size];\n  int user_input \u003d atoi(argv[1]);\n  if (user_input \u0026gt;\u003d buf_size) {\n    return 1;\n  }\n  // Because `sizeof(*)` returns an unsigned integer, both operands are first\n  // converted to unsigned integers, the multiplication is performed and the\n  // result is of type unsigned integer.\n  memcpy(buf, argv[2], user_input * sizeof(char));\n  if (user_input \u003d\u003d 0xBEEF) {\n    printf(\"Whoopsie daisy, ...\\n\");\n    // A malicious user can craft input arguments such that the flow of control\n    // passes through this call to `execl` which opens a new shell with this\n    // program\u0027s (possibly elevated) permissions.\n    execl(\"/bin/bash\", \"bash\", (char *)NULL);\n  } else {\n    printf(\"Not so fast!\\n\");\n  }\n  return 0;\n}\n\u003c/pre\u003e\n\u003cp\u003eThe program takes as arguments a string and its size, and uses these arguments to copy the string argument into an internal buffer. Before copying\nthe string into its internal buffer it checks whether the user-provided string fits into the buffer. The program also comprises a call to\n\u003ccode\u003eexecl\u003c/code\u003e that opens a shell with the program’s possibly elevated permissions — a potentially dangerous endeavour. Even though the call to\n\u003ccode\u003eexecl\u003c/code\u003e seems unreachable at a first glance, it can actually be reached due to signed/unsigned integer conversion.\u003c/p\u003e\n\u003cp\u003eThe check for the buffer size only validates that the provided string length (\u003ccode\u003euser_input\u003c/code\u003e) is smaller or equal to the buffer’s size.\nSince the \u003ccode\u003eatoi\u003c/code\u003e function returns a signed integer, a user may provide a negative number to withstand that check. The result of\n\u003ccode\u003esizeof(*)\u003c/code\u003e on the other hand returns an unsigned integer which causes the expression \u003ccode\u003euser_input * sizeof(char)\u003c/code\u003e to be\nevaluated by\u003c/p\u003e\n\u003col\u003e\n  \u003cli\u003e converting both operands to unsigned integers, \u003c/li\u003e\n  \u003cli\u003e performing the multiplication, and \u003c/li\u003e\n  \u003cli\u003e returning the result as an unsigned integer type. \u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eA malicious user is hence able to provide carefully crafted negative integer and string to bypass the size check while still arriving at the\nappropriate size argument to not crash \u003ccode\u003ememcpy\u003c/code\u003e. This, in turn, enables the malicious user to overflow the buffer variable \u003ccode\u003ebuf\u003c/code\u003e\nto override the \u003ccode\u003euser_input\u003c/code\u003e variable which allows the second \u003ccode\u003eif\u003c/code\u003e statement to be evaluated to true, eventually opening a new\nshell with the target program’s possibly elevated permissions.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eUse the appropriate function from the \u003ccode\u003estd::cmp_*\u003c/code\u003e family to conduct comparisons between signed and unsigned integer types.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nbool foo(unsigned x, int y) {\n  return x \u0026lt; y; // Noncompliant: y might be negative\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nbool foo(unsigned x, int y) {\n  return std::cmp_less(x, y); // Compliant\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\nbool fun(int x, std::vector\u0026lt;int\u0026gt; const\u0026amp; v) {\n  return x \u0026lt; v.size(); // Noncompliant: x might be negative\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\nbool fun(int x, std::vector\u0026lt;int\u0026gt; const\u0026amp; v) {\n  return std::cmp_less(x, v.size()); // Compliant\n}\n\u003c/pre\u003e\n\u003ch2\u003eInteractions with associated rule {rule:cpp:S6214}\u003c/h2\u003e\n\u003cp\u003eNote that this rule ({rule:cpp:S6183}) deliberately avoids intersection with {rule:cpp:S6214}.\u003c/p\u003e\n\u003cp\u003eWhile {rule:cpp:S6214} raises an issue if the signed value can be proven to be negative (in which case it is definitely a bug), S6281\nwill flag all \u003cstrong\u003eother\u003c/strong\u003e comparisons between signed and unsigned integers. Therefore, if this rule is enabled, {rule:cpp:S6214} should be\nenabled too.\u003c/p\u003e\n\u003cp\u003eThe following code snippet is hence compliant with {rule:cpp:S6183}, but noncompliant with {rule:cpp:S6214} which will raise an issue on this\ndefinite bug.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;iostream\u0026gt;\n\nvoid foo() {\n  if (2U \u0026lt; -1) { // Compliant: the comparison is incorrect but S6214 raises an issue instead of S6183\n    std::cout \u0026lt;\u0026lt; \"2 is less than -1\\n\";\n  } else {\n    std::cout \u0026lt;\u0026lt; \"2 is not less than -1\\n\";\n  }\n}\n\u003c/pre\u003e\n\u003cp\u003eThe fixed version of the code shown in the following is compliant with both rules, {rule:cpp:S6183} and {rule:cpp:S6214}.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;iostream\u0026gt;\n\nvoid foo() {\n  if (std::cmp_less(2U, -1)) { // Compliant: for this rule (S6183) and associated rule S6214\n    std::cout \u0026lt;\u0026lt; \"2 is less than -1\\n\";\n  } else {\n    std::cout \u0026lt;\u0026lt; \"2 is not less than -1\\n\";\n  }\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/utility/intcmp\"\u003eintcmp\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/display/c/INT02-C.+Understand+integer+conversion+rules\"\u003eINT02-C. Understand integer\n  conversion rules\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CERT - \u003ca\n  href\u003d\"https://wiki.sei.cmu.edu/confluence/display/c/INT31-C.+Ensure+that+integer+conversions+do+not+result+in+lost+or+misinterpreted+data\"\u003eINT31-C.\n  Ensure that integer conversions do not result in lost or misinterpreted data\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/195.html\"\u003e195 Signed to Unsigned Conversion Error\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S845} ensures that signed and unsigned types are not mixed in expressions \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S6214} constitutes a version of this rule that only triggers when it detects the involvement of negative values. If {rule:cpp:S6183}\n  is enabled, {rule:cpp:S6214} should be enabled, too. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "bad-practice",
      "pitfall",
      "since-c++20",
      "symbolic-execution"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6188",
    "name": "\"std::span\" should be used for a uniform sequence of elements contiguous in memory",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eC++20 introduces \u003ccode\u003estd::span\u003c/code\u003e, a thin generic abstraction for sequences of elements contiguous in memory represented by the beginning and\nlength. \u003ccode\u003estd::span\u003c/code\u003e\u0026nbsp;can unify the interface for such sequences, e.g., for plain arrays, \u003ccode\u003estd::array\u003c/code\u003e,\n\u003ccode\u003estd::vector\u003c/code\u003e, or \u003ccode\u003estd::string\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003estd::span\u0026lt;T const* const\u0026gt;\u003c/code\u003e can be constructed of \u003ccode\u003estd::vector\u0026lt;T*\u0026gt;\u003c/code\u003e without copying it, which makes it well\nsuited for const-correct interfaces.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003estd::span\u003c/code\u003e can have dynamic or static extent (length). The latter is useful for compilers to optimize the handling of arrays of size\nknown at compile time.\u003c/p\u003e\n\u003cp\u003eThis rule reports:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e functions that accept a span by means of a plain array or a pointer to the beginning of a sequence and its length \u003c/li\u003e\n  \u003cli\u003e functions that accept \u003ccode\u003ebegin\u003c/code\u003e and \u003ccode\u003eend\u003c/code\u003e iterators of a \u003ccode\u003estd::array\u003c/code\u003e or a \u003ccode\u003estd::vector\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e functions that accept \u003ccode\u003estd::vector\u0026lt;T const*\u0026gt;\u003c/code\u003e and are called with a temporary copy of \u003ccode\u003estd::vector\u0026lt;T*\u0026gt;\u003c/code\u003e\n  created just to satisfy the type signature of the argument. \u003c/li\u003e\n  \u003cli\u003e functions that accept \u003ccode\u003estd::vector\u0026lt;T*\u0026gt;\u003c/code\u003e and never modify the objects pointed to by its elements. \u003c/li\u003e\n  \u003cli\u003e const member functions that return a reference or a copy of a \u003ccode\u003estd::vector\u0026lt;T*\u0026gt;\u003c/code\u003e field. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid addOdd(int* arr, size_t size) { // Noncompliant: replace ptr+size with std::span\n  for (int i \u003d 0; i*2 + 1 \u0026lt; size; ++i) {\n    arr[i*2] +\u003d arr[i*2 + 1];\n  }\n}\n\u003c/pre\u003e\n\u003cpre\u003e\nvoid addOdd(std::vector\u0026lt;int\u0026gt;::iterator begin, std::vector\u0026lt;int\u0026gt;::iterator end) { // Noncompliant\n  for (auto iter \u003d begin; iter !\u003d end \u0026amp;\u0026amp; iter + 1 !\u003d end; iter +\u003d 2) {\n    *iter +\u003d *(iter + 1);\n  }\n}\n\u003c/pre\u003e\n\u003cpre\u003e\nbool oddAre0(const std::vector\u0026lt;int*\u0026gt;\u0026amp; nums) { // Noncompliant: use std::span\u0026lt;const int*\u0026gt;\n  for (int i \u003d 0; 2*i + 1 \u0026lt; std::size(nums); ++i) {\n    if (0 !\u003d *nums[2*i + 1]) {\n      return false;\n    }\n  }\n  return true;\n}\n\u003c/pre\u003e\n\u003cpre\u003e\nbool oddAre0(const std::vector\u0026lt;int const*\u0026gt;\u0026amp; nums) { // Noncompliant: use std::span\u0026lt;int const*\u0026gt;\n  for (int i \u003d 0; 2*i + 1 \u0026lt; std::size(nums); ++i) {\n    if (0 !\u003d *nums[2*i + 1]) {\n      return false;\n    }\n  }\n  return true;\n}\nstd::vector\u0026lt;int*\u0026gt; getNums();\nvoid caller() {\n  std::vector\u0026lt;int*\u0026gt; nums \u003d getNums();\n  if (oddAre0(std::vector\u0026lt;int const*\u0026gt;{nums.begin(), nums.end()})) { // This copy is verbose and slow\n    // ...\n  }\n}\n\u003c/pre\u003e\n\u003cpre\u003e\nclass A {\n  std::vector\u0026lt;int*\u0026gt; myNums;\npublic:\n  const std::vector\u0026lt;int*\u0026gt;\u0026amp; getMyNums1() const { // Noncompliant: caller can modify *a.myNums[1]\n    return myNums;\n  }\n  std::vector\u0026lt;int const*\u0026gt; getMyNums2() const {\n    return std::vector\u0026lt;int const*\u0026gt;{myNums.begin(), myNums.end()}; // Noncompliant: expensive copy\n  }\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid addOdd(std::span\u0026lt;int\u0026gt; span) { // Compliant\n  for (int i \u003d 0; i*2 + 1 \u0026lt; std::size(span); ++i) {\n    span[i*2] +\u003d span[i*2 + 1];\n  }\n}\n\u003c/pre\u003e\n\u003cpre\u003e\nbool oddAre0(std::span\u0026lt;int const* const\u0026gt; nums) { // Compliant\n  for (int i \u003d 0; 2*i + 1 \u0026lt; std::size(nums); ++i) {\n    if (0 !\u003d *nums[2*i + 1]) {\n      return false;\n    }\n  }\n  return true;\n}\nstd::vector\u0026lt;int*\u0026gt; getNums();\nvoid caller() {\n  std::vector\u0026lt;int*\u0026gt; nums \u003d getNums();\n  if (oddAre0(nums)) { // No copy\n    // ...\n  }\n}\n\u003c/pre\u003e\n\u003cpre\u003e\nclass A {\n  std::vector\u0026lt;int*\u0026gt; myNums;\npublic:\n  std::span\u0026lt;int const* const\u0026gt; getMyNums() const { // Compliant: const-correct\n    return myNums; // No copy\n  }\n};\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eC++20 introduces \u003ccode\u003estd::span\u003c/code\u003e, a thin generic abstraction for sequences of elements contiguous in memory represented by the beginning and\nlength. \u003ccode\u003estd::span\u003c/code\u003e\u0026nbsp;can unify the interface for such sequences, e.g., for plain arrays, \u003ccode\u003estd::array\u003c/code\u003e,\n\u003ccode\u003estd::vector\u003c/code\u003e, or \u003ccode\u003estd::string\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003estd::span\u0026lt;T const* const\u0026gt;\u003c/code\u003e can be constructed of \u003ccode\u003estd::vector\u0026lt;T*\u0026gt;\u003c/code\u003e without copying it, which makes it well\nsuited for const-correct interfaces.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003estd::span\u003c/code\u003e can have dynamic or static extent (length). The latter is useful for compilers to optimize the handling of arrays of size\nknown at compile time.\u003c/p\u003e\n\u003cp\u003eThis rule reports:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e functions that accept a span by means of a plain array or a pointer to the beginning of a sequence and its length \u003c/li\u003e\n  \u003cli\u003e functions that accept \u003ccode\u003ebegin\u003c/code\u003e and \u003ccode\u003eend\u003c/code\u003e iterators of a \u003ccode\u003estd::array\u003c/code\u003e or a \u003ccode\u003estd::vector\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e functions that accept \u003ccode\u003estd::vector\u0026lt;T const*\u0026gt;\u003c/code\u003e and are called with a temporary copy of \u003ccode\u003estd::vector\u0026lt;T*\u0026gt;\u003c/code\u003e\n  created just to satisfy the type signature of the argument. \u003c/li\u003e\n  \u003cli\u003e functions that accept \u003ccode\u003estd::vector\u0026lt;T*\u0026gt;\u003c/code\u003e and never modify the objects pointed to by its elements. \u003c/li\u003e\n  \u003cli\u003e const member functions that return a reference or a copy of a \u003ccode\u003estd::vector\u0026lt;T*\u0026gt;\u003c/code\u003e field. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid addOdd(int* arr, size_t size) { // Noncompliant: replace ptr+size with std::span\n  for (int i \u003d 0; i*2 + 1 \u0026lt; size; ++i) {\n    arr[i*2] +\u003d arr[i*2 + 1];\n  }\n}\n\u003c/pre\u003e\n\u003cpre\u003e\nvoid addOdd(std::vector\u0026lt;int\u0026gt;::iterator begin, std::vector\u0026lt;int\u0026gt;::iterator end) { // Noncompliant\n  for (auto iter \u003d begin; iter !\u003d end \u0026amp;\u0026amp; iter + 1 !\u003d end; iter +\u003d 2) {\n    *iter +\u003d *(iter + 1);\n  }\n}\n\u003c/pre\u003e\n\u003cpre\u003e\nbool oddAre0(const std::vector\u0026lt;int*\u0026gt;\u0026amp; nums) { // Noncompliant: use std::span\u0026lt;const int*\u0026gt;\n  for (int i \u003d 0; 2*i + 1 \u0026lt; std::size(nums); ++i) {\n    if (0 !\u003d *nums[2*i + 1]) {\n      return false;\n    }\n  }\n  return true;\n}\n\u003c/pre\u003e\n\u003cpre\u003e\nbool oddAre0(const std::vector\u0026lt;int const*\u0026gt;\u0026amp; nums) { // Noncompliant: use std::span\u0026lt;int const*\u0026gt;\n  for (int i \u003d 0; 2*i + 1 \u0026lt; std::size(nums); ++i) {\n    if (0 !\u003d *nums[2*i + 1]) {\n      return false;\n    }\n  }\n  return true;\n}\nstd::vector\u0026lt;int*\u0026gt; getNums();\nvoid caller() {\n  std::vector\u0026lt;int*\u0026gt; nums \u003d getNums();\n  if (oddAre0(std::vector\u0026lt;int const*\u0026gt;{nums.begin(), nums.end()})) { // This copy is verbose and slow\n    // ...\n  }\n}\n\u003c/pre\u003e\n\u003cpre\u003e\nclass A {\n  std::vector\u0026lt;int*\u0026gt; myNums;\npublic:\n  const std::vector\u0026lt;int*\u0026gt;\u0026amp; getMyNums1() const { // Noncompliant: caller can modify *a.myNums[1]\n    return myNums;\n  }\n  std::vector\u0026lt;int const*\u0026gt; getMyNums2() const {\n    return std::vector\u0026lt;int const*\u0026gt;{myNums.begin(), myNums.end()}; // Noncompliant: expensive copy\n  }\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid addOdd(std::span\u0026lt;int\u0026gt; span) { // Compliant\n  for (int i \u003d 0; i*2 + 1 \u0026lt; std::size(span); ++i) {\n    span[i*2] +\u003d span[i*2 + 1];\n  }\n}\n\u003c/pre\u003e\n\u003cpre\u003e\nbool oddAre0(std::span\u0026lt;int const* const\u0026gt; nums) { // Compliant\n  for (int i \u003d 0; 2*i + 1 \u0026lt; std::size(nums); ++i) {\n    if (0 !\u003d *nums[2*i + 1]) {\n      return false;\n    }\n  }\n  return true;\n}\nstd::vector\u0026lt;int*\u0026gt; getNums();\nvoid caller() {\n  std::vector\u0026lt;int*\u0026gt; nums \u003d getNums();\n  if (oddAre0(nums)) { // No copy\n    // ...\n  }\n}\n\u003c/pre\u003e\n\u003cpre\u003e\nclass A {\n  std::vector\u0026lt;int*\u0026gt; myNums;\npublic:\n  std::span\u0026lt;int const* const\u0026gt; getMyNums() const { // Compliant: const-correct\n    return myNums; // No copy\n  }\n};\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "clumsy",
      "since-c++20"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6189",
    "name": "Function template parameters should be named if reused",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eC++20 introduces full template support for lambda functions on par with the regular template functions. The full template syntax for a lambda adds\na template-arguments clause after the capture clause completing the panoply of brackets: []\u0026lt;\u0026gt;(){}. For example:\u003c/p\u003e\n\u003cpre\u003e\n[]\u0026lt;typename T\u0026gt;(T arg) { return arg; }\n\u003c/pre\u003e\n\u003cp\u003eAlthough more verbose than using \u003ccode\u003eauto\u003c/code\u003e for the types of the arguments, this syntax enables you to name the types for the parameters,\nconstrain these types (see Concepts), and reuse these types for multiple arguments.\u003c/p\u003e\n\u003cp\u003eOne common use case for the named template argument is a lambda with multiple arguments of the same type. Pre-C++20 code had to resort to the use\nof \u003ccode\u003edecltype\u003c/code\u003e: \u003ccode\u003e[](auto arg1, decltype(arg1) arg2) ... \u003c/code\u003e. Not only is it obscure it also only approximates our goal: it requires\nthe second-argument type to be convertible to the first-argument type.\u003c/p\u003e\n\u003cp\u003eMoreover, similar issues may appear for normal functions, that declare parameters with \u003ccode\u003eauto\u003c/code\u003e in place of type using C++20 abbreviated\ntemplate syntax.\u003c/p\u003e\n\u003cp\u003eThis rule reports the use of \u003ccode\u003edecltype(arg)\u003c/code\u003e for parameters introduced with \u003ccode\u003eauto\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid f1() {\n  auto sum \u003d [](auto fir, decltype(fir) sec) { return fir + sec; }; // Noncompliant\n  std::cout \u0026lt;\u0026lt; sum(true, 1); // Prints 2\n}\n\nvoid f2(auto param) {  // Noncompliant\n   decltype(param) copy \u003d param;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid f1() {\n  auto sum \u003d []\u0026lt;class T\u0026gt;(T fir, T sec) { return fir + sec; }; // Compliant\n  // std::cout \u0026lt;\u0026lt; sum(true, 1); - compilation error\n}\n\ntemplate\u0026lt;class T\u0026gt;\nvoid f2(T param) { // Compliant\n    T copy \u003d param;\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://www.modernescpp.com/index.php/more-powerful-lambdas-with-c-20\"\u003eModern C++: More powerful lambdas with C++20\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eC++20 introduces full template support for lambda functions on par with the regular template functions. The full template syntax for a lambda adds\na template-arguments clause after the capture clause completing the panoply of brackets: []\u0026lt;\u0026gt;(){}. For example:\u003c/p\u003e\n\u003cpre\u003e\n[]\u0026lt;typename T\u0026gt;(T arg) { return arg; }\n\u003c/pre\u003e\n\u003cp\u003eAlthough more verbose than using \u003ccode\u003eauto\u003c/code\u003e for the types of the arguments, this syntax enables you to name the types for the parameters,\nconstrain these types (see Concepts), and reuse these types for multiple arguments.\u003c/p\u003e\n\u003cp\u003eOne common use case for the named template argument is a lambda with multiple arguments of the same type. Pre-C++20 code had to resort to the use\nof \u003ccode\u003edecltype\u003c/code\u003e: \u003ccode\u003e[](auto arg1, decltype(arg1) arg2) ... \u003c/code\u003e. Not only is it obscure it also only approximates our goal: it requires\nthe second-argument type to be convertible to the first-argument type.\u003c/p\u003e\n\u003cp\u003eMoreover, similar issues may appear for normal functions, that declare parameters with \u003ccode\u003eauto\u003c/code\u003e in place of type using C++20 abbreviated\ntemplate syntax.\u003c/p\u003e\n\u003cp\u003eThis rule reports the use of \u003ccode\u003edecltype(arg)\u003c/code\u003e for parameters introduced with \u003ccode\u003eauto\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid f1() {\n  auto sum \u003d [](auto fir, decltype(fir) sec) { return fir + sec; }; // Noncompliant\n  std::cout \u0026lt;\u0026lt; sum(true, 1); // Prints 2\n}\n\nvoid f2(auto param) {  // Noncompliant\n   decltype(param) copy \u003d param;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid f1() {\n  auto sum \u003d []\u0026lt;class T\u0026gt;(T fir, T sec) { return fir + sec; }; // Compliant\n  // std::cout \u0026lt;\u0026lt; sum(true, 1); - compilation error\n}\n\ntemplate\u0026lt;class T\u0026gt;\nvoid f2(T param) { // Compliant\n    T copy \u003d param;\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://www.modernescpp.com/index.php/more-powerful-lambdas-with-c-20\"\u003eModern C++: More powerful lambdas with C++20\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "clumsy",
      "pitfall",
      "since-c++20"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6186",
    "name": "Redundant comparison operators should not be defined",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eC++20 introduces rewriting rules that enable defining only a few operator overloads in a class to be able to compare class instances in many\nways:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e the \"spaceship\" \u003ccode\u003eoperator\u0026lt;\u003d\u0026gt;\u003c/code\u003e can replace all the other comparison operators in most cases: The code \u003ccode\u003ea @ b\u003c/code\u003e (where\n  \u003ccode\u003e@\u003c/code\u003e is one of the following operators: \u003ccode\u003e\u0026lt;\u003c/code\u003e, \u003ccode\u003e\u0026lt;\u003d\u003c/code\u003e, \u003ccode\u003e\u0026gt;\u003c/code\u003e, or \u003ccode\u003e\u0026gt;\u003d\u003c/code\u003e) can be implicitly\n  rewritten to use either \u003ccode\u003ea\u0026lt;\u003d\u0026gt;b\u003c/code\u003e or \u003ccode\u003eb\u0026lt;\u003d\u0026gt;a\u003c/code\u003e, and its three-way comparison semantics instead. \u003c/li\u003e\n  \u003cli\u003e If \u003ccode\u003eoperator\u003d\u003d\u003c/code\u003e is defined, \u003ccode\u003ea!\u003db\u003c/code\u003e can be implicitly rewritten \u003ccode\u003e!(a\u003d\u003db)\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e If an \u003ccode\u003eoperator\u0026lt;\u003d\u0026gt;\u003c/code\u003e is defined as \u003ccode\u003e\u003ddefault\u003c/code\u003e, a matching \u003ccode\u003eoperator\u003d\u003d\u003c/code\u003e is automatically generated if it\n  does not already exist. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIf you define your own version of any particular comparison operator, e.g., \u003ccode\u003eoperator\u0026lt;\u003c/code\u003e in addition to the\n\u003ccode\u003eoperator\u0026lt;\u003d\u0026gt;\u003c/code\u003e, it will supersede the compiler-generated version and might result in a surprising behavior with\n\u003ccode\u003eoperator\u0026lt;\u003c/code\u003e semantics inconsistent with the semantics of other operators defined through \u003ccode\u003eoperator\u0026lt;\u003d\u0026gt;\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eIn most cases, you will only have to define the following set of comparison operators in your class (possibly several of those sets, to allow for\nmixed-type comparison):\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e No comparison operator, if the class should not be compared, or \u003c/li\u003e\n  \u003cli\u003e only \u003ccode\u003eoperator\u003d\u003d\u003c/code\u003e for classes that can only be compared for equality (and inequality), or \u003c/li\u003e\n  \u003cli\u003e only \u003ccode\u003eoperator\u0026lt;\u003d\u0026gt;\u003c/code\u003e, defined as \u003ccode\u003e\u003ddefault\u003c/code\u003e for fully comparable classes that only need to perform comparison member\n  by member, or \u003c/li\u003e\n  \u003cli\u003e both \u003ccode\u003eoperator\u0026lt;\u003d\u0026gt;\u003c/code\u003e and \u003ccode\u003eoperator\u003d\u003d\u003c/code\u003e when the comparison is more complex. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis rule will raise an issue when a class is defined:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e With an \u003ccode\u003eoperator\u0026lt;\u003d\u0026gt;\u003c/code\u003e and any of the four operators \u003ccode\u003e\u0026lt;\u003c/code\u003e, \u003ccode\u003e\u0026lt;\u003d\u003c/code\u003e, \u003ccode\u003e\u0026gt;\u003c/code\u003e,\n  \u003ccode\u003e\u0026gt;\u003d\u003c/code\u003e defined with the same argument type. \u003c/li\u003e\n  \u003cli\u003e With both \u003ccode\u003eoperator\u003d\u003d\u003c/code\u003e and \u003ccode\u003eoperator!\u003d\u003c/code\u003e defined for the same types. \u003c/li\u003e\n  \u003cli\u003e With a defaulted \u003ccode\u003eoperator\u0026lt;\u003d\u0026gt;\u003c/code\u003e and a defaulted \u003ccode\u003eoperator\u003d\u003d\u003c/code\u003e with the same argument types defined. \u003c/li\u003e\n  \u003cli\u003e With two \u003ccode\u003eoperator\u0026lt;\u003d\u0026gt;\u003c/code\u003e or two \u003ccode\u003eoperator\u003d\u003d\u003c/code\u003e that are declared with the same argument types in reverse order. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cp\u003eExample with redundant operations in the same class:\u003c/p\u003e\n\u003cpre\u003e\nclass A {\n  int field;\n  public:\n    auto operator\u0026lt;\u003d\u0026gt;(const A\u0026amp;) const \u003d default;\n    bool operator\u0026lt;(const A\u0026amp; other) const { // Noncompliant: this definition is redundant when operator\u0026lt;\u003d\u0026gt; is present\n      return field \u0026lt; other.field;\n    }\n    bool operator\u003d\u003d(const A\u0026amp;) const \u003d default; // Noncompliant: unnecessary, this line is added implicitly\n};\n\u003c/pre\u003e\n\u003cp\u003eExample with equivalent operations in different order:\u003c/p\u003e\n\u003cpre\u003e\nclass MyStr {\n  friend std::strong_ordering operator\u0026lt;\u003d\u0026gt;(MyStr const \u0026amp;s1, std::string const \u0026amp;s2);\n  friend std::strong_ordering operator\u0026lt;\u003d\u0026gt;(std::string const \u0026amp;s1, MyStr const \u0026amp;s2); // Noncompliant, redundant with the previous line\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cp\u003eThe class has been reduced to a minimal set:\u003c/p\u003e\n\u003cpre\u003e\nclass A {\n  int field;\n  public:\n    auto operator\u0026lt;\u003d\u0026gt;(const A\u0026amp;) const \u003d default; // Compliant: operator\u003d\u003d is implicitly generated, and expressions with \u0026lt; can be written\n};\n\n// The following code is valid:\nvoid f(A const \u0026amp;a1, A const \u0026amp;a2) {\n  bool b1 \u003d a1 \u003d\u003d a2; // Uses implicitly generated operator\u003d\u003d\n  bool b2 \u003d a1 !\u003d a2; // Uses implicitly generated operator\u003d\u003d, rewritten as: !(a1 \u003d\u003d a2)\n  bool b3 \u003d a1 \u0026lt; a2; // Rewritten as: (a1 \u0026lt;\u003d\u0026gt; a2) \u0026lt; 0\n  bool b4 \u003d a1 \u0026gt;\u003d a2; // Uses implicitly generated operator\u003d\u003d\n  bool b1 \u003d a1 \u003d\u003d a2; // Uses implicitly generated operator\u003d\u003d\n}\n\u003c/pre\u003e\n\u003cp\u003eOnly one order needs to be written\u003c/p\u003e\n\u003cpre\u003e\nclass MyStr {\n  friend std::strong_ordering operator\u0026lt;\u003d\u0026gt;(MyStr const \u0026amp;s1, std::string const \u0026amp;s2); // Compliant\n};\n\n// The following code is valid\nvoid f(MyStr const \u0026amp;s1, std::string const \u0026amp;s2) {\n  bool b1 \u003d s1 \u0026lt; s2; // Rewritten as: (s1\u0026lt;\u003d\u0026gt;s2) \u0026lt; 0\n  bool b2 \u003d s2 \u0026gt;\u003d s1; // Rewritten as 0 \u0026gt;\u003d (s1\u0026lt;\u003d\u0026gt;s2);\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eC++20 introduces rewriting rules that enable defining only a few operator overloads in a class to be able to compare class instances in many\nways:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e the \"spaceship\" \u003ccode\u003eoperator\u0026lt;\u003d\u0026gt;\u003c/code\u003e can replace all the other comparison operators in most cases: The code \u003ccode\u003ea @ b\u003c/code\u003e (where\n  \u003ccode\u003e@\u003c/code\u003e is one of the following operators: \u003ccode\u003e\u0026lt;\u003c/code\u003e, \u003ccode\u003e\u0026lt;\u003d\u003c/code\u003e, \u003ccode\u003e\u0026gt;\u003c/code\u003e, or \u003ccode\u003e\u0026gt;\u003d\u003c/code\u003e) can be implicitly\n  rewritten to use either \u003ccode\u003ea\u0026lt;\u003d\u0026gt;b\u003c/code\u003e or \u003ccode\u003eb\u0026lt;\u003d\u0026gt;a\u003c/code\u003e, and its three-way comparison semantics instead. \u003c/li\u003e\n  \u003cli\u003e If \u003ccode\u003eoperator\u003d\u003d\u003c/code\u003e is defined, \u003ccode\u003ea!\u003db\u003c/code\u003e can be implicitly rewritten \u003ccode\u003e!(a\u003d\u003db)\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e If an \u003ccode\u003eoperator\u0026lt;\u003d\u0026gt;\u003c/code\u003e is defined as \u003ccode\u003e\u003ddefault\u003c/code\u003e, a matching \u003ccode\u003eoperator\u003d\u003d\u003c/code\u003e is automatically generated if it\n  does not already exist. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIf you define your own version of any particular comparison operator, e.g., \u003ccode\u003eoperator\u0026lt;\u003c/code\u003e in addition to the\n\u003ccode\u003eoperator\u0026lt;\u003d\u0026gt;\u003c/code\u003e, it will supersede the compiler-generated version and might result in a surprising behavior with\n\u003ccode\u003eoperator\u0026lt;\u003c/code\u003e semantics inconsistent with the semantics of other operators defined through \u003ccode\u003eoperator\u0026lt;\u003d\u0026gt;\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eIn most cases, you will only have to define the following set of comparison operators in your class (possibly several of those sets, to allow for\nmixed-type comparison):\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e No comparison operator, if the class should not be compared, or \u003c/li\u003e\n  \u003cli\u003e only \u003ccode\u003eoperator\u003d\u003d\u003c/code\u003e for classes that can only be compared for equality (and inequality), or \u003c/li\u003e\n  \u003cli\u003e only \u003ccode\u003eoperator\u0026lt;\u003d\u0026gt;\u003c/code\u003e, defined as \u003ccode\u003e\u003ddefault\u003c/code\u003e for fully comparable classes that only need to perform comparison member\n  by member, or \u003c/li\u003e\n  \u003cli\u003e both \u003ccode\u003eoperator\u0026lt;\u003d\u0026gt;\u003c/code\u003e and \u003ccode\u003eoperator\u003d\u003d\u003c/code\u003e when the comparison is more complex. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis rule will raise an issue when a class is defined:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e With an \u003ccode\u003eoperator\u0026lt;\u003d\u0026gt;\u003c/code\u003e and any of the four operators \u003ccode\u003e\u0026lt;\u003c/code\u003e, \u003ccode\u003e\u0026lt;\u003d\u003c/code\u003e, \u003ccode\u003e\u0026gt;\u003c/code\u003e,\n  \u003ccode\u003e\u0026gt;\u003d\u003c/code\u003e defined with the same argument type. \u003c/li\u003e\n  \u003cli\u003e With both \u003ccode\u003eoperator\u003d\u003d\u003c/code\u003e and \u003ccode\u003eoperator!\u003d\u003c/code\u003e defined for the same types. \u003c/li\u003e\n  \u003cli\u003e With a defaulted \u003ccode\u003eoperator\u0026lt;\u003d\u0026gt;\u003c/code\u003e and a defaulted \u003ccode\u003eoperator\u003d\u003d\u003c/code\u003e with the same argument types defined. \u003c/li\u003e\n  \u003cli\u003e With two \u003ccode\u003eoperator\u0026lt;\u003d\u0026gt;\u003c/code\u003e or two \u003ccode\u003eoperator\u003d\u003d\u003c/code\u003e that are declared with the same argument types in reverse order. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cp\u003eExample with redundant operations in the same class:\u003c/p\u003e\n\u003cpre\u003e\nclass A {\n  int field;\n  public:\n    auto operator\u0026lt;\u003d\u0026gt;(const A\u0026amp;) const \u003d default;\n    bool operator\u0026lt;(const A\u0026amp; other) const { // Noncompliant: this definition is redundant when operator\u0026lt;\u003d\u0026gt; is present\n      return field \u0026lt; other.field;\n    }\n    bool operator\u003d\u003d(const A\u0026amp;) const \u003d default; // Noncompliant: unnecessary, this line is added implicitly\n};\n\u003c/pre\u003e\n\u003cp\u003eExample with equivalent operations in different order:\u003c/p\u003e\n\u003cpre\u003e\nclass MyStr {\n  friend std::strong_ordering operator\u0026lt;\u003d\u0026gt;(MyStr const \u0026amp;s1, std::string const \u0026amp;s2);\n  friend std::strong_ordering operator\u0026lt;\u003d\u0026gt;(std::string const \u0026amp;s1, MyStr const \u0026amp;s2); // Noncompliant, redundant with the previous line\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cp\u003eThe class has been reduced to a minimal set:\u003c/p\u003e\n\u003cpre\u003e\nclass A {\n  int field;\n  public:\n    auto operator\u0026lt;\u003d\u0026gt;(const A\u0026amp;) const \u003d default; // Compliant: operator\u003d\u003d is implicitly generated, and expressions with \u0026lt; can be written\n};\n\n// The following code is valid:\nvoid f(A const \u0026amp;a1, A const \u0026amp;a2) {\n  bool b1 \u003d a1 \u003d\u003d a2; // Uses implicitly generated operator\u003d\u003d\n  bool b2 \u003d a1 !\u003d a2; // Uses implicitly generated operator\u003d\u003d, rewritten as: !(a1 \u003d\u003d a2)\n  bool b3 \u003d a1 \u0026lt; a2; // Rewritten as: (a1 \u0026lt;\u003d\u0026gt; a2) \u0026lt; 0\n  bool b4 \u003d a1 \u0026gt;\u003d a2; // Uses implicitly generated operator\u003d\u003d\n  bool b1 \u003d a1 \u003d\u003d a2; // Uses implicitly generated operator\u003d\u003d\n}\n\u003c/pre\u003e\n\u003cp\u003eOnly one order needs to be written\u003c/p\u003e\n\u003cpre\u003e\nclass MyStr {\n  friend std::strong_ordering operator\u0026lt;\u003d\u0026gt;(MyStr const \u0026amp;s1, std::string const \u0026amp;s2); // Compliant\n};\n\n// The following code is valid\nvoid f(MyStr const \u0026amp;s1, std::string const \u0026amp;s2) {\n  bool b1 \u003d s1 \u0026lt; s2; // Rewritten as: (s1\u0026lt;\u003d\u0026gt;s2) \u0026lt; 0\n  bool b2 \u003d s2 \u0026gt;\u003d s1; // Rewritten as 0 \u0026gt;\u003d (s1\u0026lt;\u003d\u0026gt;s2);\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "clumsy",
      "pitfall",
      "since-c++20"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6187",
    "name": "Operator spaceship \"\u003c\u003d\u003e\" should be used to define comparable types",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eC++20 introduces the \"spaceship\" \u003ccode\u003eoperator\u0026lt;\u003d\u0026gt;\u003c/code\u003e that replaces all the other comparison operators in most cases. When this operator\nis defined, the compiler can rewrite expressions using \u003ccode\u003e\u0026lt;\u003c/code\u003e, \u003ccode\u003e\u0026lt;\u003d\u003c/code\u003e, \u003ccode\u003e\u0026gt;\u003c/code\u003e and \u003ccode\u003e\u0026gt;\u003d\u003c/code\u003e to use this\noperator instead. This presents three advantages:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Less code to write (and therefore fewer bugs, too), \u003c/li\u003e\n  \u003cli\u003e Guaranteed consistency between all the comparison operators (for instance, in this situation, \u003ccode\u003ea \u0026lt; b\u003c/code\u003e and \u003ccode\u003e!(a \u0026gt;\u003d\n  b)\u003c/code\u003e will always return the same value). \u003c/li\u003e\n  \u003cli\u003e Guaranteed symmetry for comparisons: if you can write \u003ccode\u003ea \u0026lt; b\u003c/code\u003e, and that operation is resolved through\n  \u003ccode\u003eoperator\u0026lt;\u003d\u0026gt;\u003c/code\u003e, you can also write \u003ccode\u003eb \u0026lt; a\u003c/code\u003e, and get a consistent result. Achieving the same result with classical\n  comparison operators requires twice as many overloads if \u003ccode\u003ea\u003c/code\u003e and \u003ccode\u003eb\u003c/code\u003e have different types. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eAdditionally, if the \u003ccode\u003eoperator\u0026lt;\u003d\u0026gt;\u003c/code\u003e has the defaulted implementation, the compiler can implicitly generate a defaulted\nimplementation of \u003ccode\u003eoperator\u003d\u003d\u003c/code\u003e, simplifying the class definition one step further.\u003c/p\u003e\n\u003cp\u003eBefore C++20, it was common to provide only \u003ccode\u003eoperator\u0026lt;\u003c/code\u003e for a class and ask the users of this class to write all their code only\nusing this operator (this is what \u003ccode\u003estd::map\u003c/code\u003e requires of its key type, for instance). In this case, it is still advised to replace the\noperator with \u003ccode\u003e\u0026lt;\u003d\u0026gt;\u003c/code\u003e: the quantity of required work is similar, and users of the class will benefit from a much greater\nexpressivity.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eThis rule reports user-provided comparison operators (member functions or free functions) \u003ccode\u003e\u0026lt;\u003c/code\u003e, \u003ccode\u003e\u0026lt;\u003d\u003c/code\u003e, \u003ccode\u003e\u0026gt;\u003c/code\u003e\nand \u003ccode\u003e\u0026gt;\u003d\u003c/code\u003e that could be replaced by defining the \u003ccode\u003eoperator\u0026lt;\u003d\u0026gt;\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nclass A { // Noncompliant: defines operator\u0026lt; that can be replaced with operator\u0026lt;\u003d\u0026gt;\n  int field;\n  public:\n    bool operator\u0026lt;(const A\u0026amp; other) const {\n      return field \u0026lt; other.field;\n    }\n};\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nclass A {\n  int field;\n  public:\n    auto operator\u0026lt;\u003d\u0026gt;(const A\u0026amp; other) const \u003d default;\n    // Note that here, operator \u003d\u003d will be implicitly defaulted\n};\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\nclass B;\n\nclass C { // Noncompliant: defines 12 comparison operators that can be replaced with 2 operators\n  int field;\n  public:\n    bool operator\u003d\u003d(const B\u0026amp;) const;\n    bool operator!\u003d(const B\u0026amp;) const;\n    bool operator\u0026lt;\u003d(const B\u0026amp;) const;\n    bool operator\u0026lt;(const B\u0026amp;) const;\n    bool operator\u0026gt;\u003d(const B\u0026amp;) const;\n    bool operator\u0026gt;(const B\u0026amp;) const;\n    friend bool operator\u003d\u003d(const B\u0026amp;, const C\u0026amp;);\n    friend bool operator!\u003d(const B\u0026amp;, const C\u0026amp;);\n    friend bool operator\u0026lt;\u003d(const B\u0026amp;, const C\u0026amp;);\n    friend bool operator\u0026lt;(const B\u0026amp;, const C\u0026amp;);\n    friend bool operator\u0026gt;\u003d(const B\u0026amp;, const C\u0026amp;);\n    friend bool operator\u0026gt;(const B\u0026amp;, const C\u0026amp;);\n};\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\nclass B;\n\nclass C { // Compliant. the same comparisons are possible as with the 12 operators\n  int field;\n  public:\n    auto operator\u0026lt;\u003d\u0026gt;(const B\u0026amp;) const;\n    auto operator\u003d\u003d(const B\u0026amp;) const;\n};\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"noncompliant\"\u003e\nenum class MyEnum {low \u003d 1, high \u003d 2};\n\nbool operator\u0026lt;(MyEnum lhs, MyEnum rhs) { // Noncompliant: can be replaced with operator\u0026lt;\u003d\u0026gt;\n    return static_cast\u0026lt;int\u0026gt;(lhs) \u0026lt; static_cast\u0026lt;int\u0026gt;(rhs);\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"compliant\"\u003e\nenum class MyEnum {low \u003d 1, high \u003d 2};\n\nauto operator\u0026lt;\u003d\u0026gt;(MyEnum lhs, MyEnum rhs) {\n    return static_cast\u0026lt;int\u0026gt;(lhs) \u0026lt;\u003d\u0026gt; static_cast\u0026lt;int\u0026gt;(rhs);\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/operator_comparison#Three-way_comparison\"\u003eThree-way comparison\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S6186} - Redundant comparison operators should not be defined. \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S6230} - Comparision operators (\u003ccode\u003e\u0026lt;\u003d\u0026gt;\u003c/code\u003e, \u003ccode\u003e\u003d\u003d\u003c/code\u003e) should be defaulted unless non-default behavior is required\n  \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eC++20 introduces the \"spaceship\" \u003ccode\u003eoperator\u0026lt;\u003d\u0026gt;\u003c/code\u003e that replaces all the other comparison operators in most cases. When this operator\nis defined, the compiler can rewrite expressions using \u003ccode\u003e\u0026lt;\u003c/code\u003e, \u003ccode\u003e\u0026lt;\u003d\u003c/code\u003e, \u003ccode\u003e\u0026gt;\u003c/code\u003e and \u003ccode\u003e\u0026gt;\u003d\u003c/code\u003e to use this\noperator instead. This presents three advantages:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Less code to write (and therefore fewer bugs, too), \u003c/li\u003e\n  \u003cli\u003e Guaranteed consistency between all the comparison operators (for instance, in this situation, \u003ccode\u003ea \u0026lt; b\u003c/code\u003e and \u003ccode\u003e!(a \u0026gt;\u003d\n  b)\u003c/code\u003e will always return the same value). \u003c/li\u003e\n  \u003cli\u003e Guaranteed symmetry for comparisons: if you can write \u003ccode\u003ea \u0026lt; b\u003c/code\u003e, and that operation is resolved through\n  \u003ccode\u003eoperator\u0026lt;\u003d\u0026gt;\u003c/code\u003e, you can also write \u003ccode\u003eb \u0026lt; a\u003c/code\u003e, and get a consistent result. Achieving the same result with classical\n  comparison operators requires twice as many overloads if \u003ccode\u003ea\u003c/code\u003e and \u003ccode\u003eb\u003c/code\u003e have different types. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eAdditionally, if the \u003ccode\u003eoperator\u0026lt;\u003d\u0026gt;\u003c/code\u003e has the defaulted implementation, the compiler can implicitly generate a defaulted\nimplementation of \u003ccode\u003eoperator\u003d\u003d\u003c/code\u003e, simplifying the class definition one step further.\u003c/p\u003e\n\u003cp\u003eBefore C++20, it was common to provide only \u003ccode\u003eoperator\u0026lt;\u003c/code\u003e for a class and ask the users of this class to write all their code only\nusing this operator (this is what \u003ccode\u003estd::map\u003c/code\u003e requires of its key type, for instance). In this case, it is still advised to replace the\noperator with \u003ccode\u003e\u0026lt;\u003d\u0026gt;\u003c/code\u003e: the quantity of required work is similar, and users of the class will benefit from a much greater\nexpressivity.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eThis rule reports user-provided comparison operators (member functions or free functions) \u003ccode\u003e\u0026lt;\u003c/code\u003e, \u003ccode\u003e\u0026lt;\u003d\u003c/code\u003e, \u003ccode\u003e\u0026gt;\u003c/code\u003e\nand \u003ccode\u003e\u0026gt;\u003d\u003c/code\u003e that could be replaced by defining the \u003ccode\u003eoperator\u0026lt;\u003d\u0026gt;\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nclass A { // Noncompliant: defines operator\u0026lt; that can be replaced with operator\u0026lt;\u003d\u0026gt;\n  int field;\n  public:\n    bool operator\u0026lt;(const A\u0026amp; other) const {\n      return field \u0026lt; other.field;\n    }\n};\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nclass A {\n  int field;\n  public:\n    auto operator\u0026lt;\u003d\u0026gt;(const A\u0026amp; other) const \u003d default;\n    // Note that here, operator \u003d\u003d will be implicitly defaulted\n};\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\nclass B;\n\nclass C { // Noncompliant: defines 12 comparison operators that can be replaced with 2 operators\n  int field;\n  public:\n    bool operator\u003d\u003d(const B\u0026amp;) const;\n    bool operator!\u003d(const B\u0026amp;) const;\n    bool operator\u0026lt;\u003d(const B\u0026amp;) const;\n    bool operator\u0026lt;(const B\u0026amp;) const;\n    bool operator\u0026gt;\u003d(const B\u0026amp;) const;\n    bool operator\u0026gt;(const B\u0026amp;) const;\n    friend bool operator\u003d\u003d(const B\u0026amp;, const C\u0026amp;);\n    friend bool operator!\u003d(const B\u0026amp;, const C\u0026amp;);\n    friend bool operator\u0026lt;\u003d(const B\u0026amp;, const C\u0026amp;);\n    friend bool operator\u0026lt;(const B\u0026amp;, const C\u0026amp;);\n    friend bool operator\u0026gt;\u003d(const B\u0026amp;, const C\u0026amp;);\n    friend bool operator\u0026gt;(const B\u0026amp;, const C\u0026amp;);\n};\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\nclass B;\n\nclass C { // Compliant. the same comparisons are possible as with the 12 operators\n  int field;\n  public:\n    auto operator\u0026lt;\u003d\u0026gt;(const B\u0026amp;) const;\n    auto operator\u003d\u003d(const B\u0026amp;) const;\n};\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"noncompliant\"\u003e\nenum class MyEnum {low \u003d 1, high \u003d 2};\n\nbool operator\u0026lt;(MyEnum lhs, MyEnum rhs) { // Noncompliant: can be replaced with operator\u0026lt;\u003d\u0026gt;\n    return static_cast\u0026lt;int\u0026gt;(lhs) \u0026lt; static_cast\u0026lt;int\u0026gt;(rhs);\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"compliant\"\u003e\nenum class MyEnum {low \u003d 1, high \u003d 2};\n\nauto operator\u0026lt;\u003d\u0026gt;(MyEnum lhs, MyEnum rhs) {\n    return static_cast\u0026lt;int\u0026gt;(lhs) \u0026lt;\u003d\u0026gt; static_cast\u0026lt;int\u0026gt;(rhs);\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/operator_comparison#Three-way_comparison\"\u003eThree-way comparison\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S6186} - Redundant comparison operators should not be defined. \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S6230} - Comparision operators (\u003ccode\u003e\u0026lt;\u003d\u0026gt;\u003c/code\u003e, \u003ccode\u003e\u003d\u003d\u003c/code\u003e) should be defaulted unless non-default behavior is required\n  \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "clumsy",
      "since-c++20"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6180",
    "name": "\"[[likely]]\" and \"[[unlikely]]\" should be used instead of compiler built-ins",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eC++20 introduces two standard attributes to indicate the likelihood of a branch: \u003ccode\u003e[[likely]]\u003c/code\u003e and \u003ccode\u003e[[unlikely]]\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThese attributes replace the non-standard built-in \u003ccode\u003e__builtin_expect\u003c/code\u003e supported by Clang and GCC that was mostly used as part of\n\u003ccode\u003elikely()\u003c/code\u003e and \u003ccode\u003eunlikely()\u003c/code\u003e macros.\u003c/p\u003e\n\u003cp\u003eThe standard annotations should always be preferred because they make the code portable and future-proof.\u003c/p\u003e\n\u003cp\u003eThis rule reports the direct use of \u003ccode\u003e__builtin_expect\u003c/code\u003e built-in and its indirect use through \u003ccode\u003elikely()\u003c/code\u003e and\n\u003ccode\u003eunlikely()\u003c/code\u003e macros.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nif (likely(!v.empty())) { // Noncompliant\n  std::cout \u0026lt;\u0026lt;v[0] \u0026lt;\u0026lt;\u0027\\n\u0027;\n}\n\nif (unlikely(nullptr \u003d\u003d ptr)) { // Noncompliant\n  std::cerr \u0026lt;\u0026lt;\"Unexpected null pointer\\n\";\n  exit(0);\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nif (!v.empty()) [[likely]] {\n  std::cout \u0026lt;\u0026lt;v[0] \u0026lt;\u0026lt;\u0027\\n\u0027;\n}\n\nif (nullptr \u003d\u003d ptr) [[unlikely]] {\n  std::cerr \u0026lt;\u0026lt;\"Unexpected null pointer\\n\";\n  exit(0);\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/attributes/likely\"\u003eC++ attribute: likely, unlikely\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eC++20 introduces two standard attributes to indicate the likelihood of a branch: \u003ccode\u003e[[likely]]\u003c/code\u003e and \u003ccode\u003e[[unlikely]]\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThese attributes replace the non-standard built-in \u003ccode\u003e__builtin_expect\u003c/code\u003e supported by Clang and GCC that was mostly used as part of\n\u003ccode\u003elikely()\u003c/code\u003e and \u003ccode\u003eunlikely()\u003c/code\u003e macros.\u003c/p\u003e\n\u003cp\u003eThe standard annotations should always be preferred because they make the code portable and future-proof.\u003c/p\u003e\n\u003cp\u003eThis rule reports the direct use of \u003ccode\u003e__builtin_expect\u003c/code\u003e built-in and its indirect use through \u003ccode\u003elikely()\u003c/code\u003e and\n\u003ccode\u003eunlikely()\u003c/code\u003e macros.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nif (likely(!v.empty())) { // Noncompliant\n  std::cout \u0026lt;\u0026lt;v[0] \u0026lt;\u0026lt;\u0027\\n\u0027;\n}\n\nif (unlikely(nullptr \u003d\u003d ptr)) { // Noncompliant\n  std::cerr \u0026lt;\u0026lt;\"Unexpected null pointer\\n\";\n  exit(0);\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nif (!v.empty()) [[likely]] {\n  std::cout \u0026lt;\u0026lt;v[0] \u0026lt;\u0026lt;\u0027\\n\u0027;\n}\n\nif (nullptr \u003d\u003d ptr) [[unlikely]] {\n  std::cerr \u0026lt;\u0026lt;\"Unexpected null pointer\\n\";\n  exit(0);\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/attributes/likely\"\u003eC++ attribute: likely, unlikely\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "bad-practice",
      "since-c++20"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6181",
    "name": "\"std::bit_cast\" should be used to reinterpret binary representation instead of \"std::memcpy\"",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003estd::bit_cast\u003c/code\u003e is one of the standard functions working with binary representation. Together with other bit-level functions, it is\ndefined in the \u003ccode\u003e\u0026lt;bit\u0026gt;\u003c/code\u003e header introduced by C++20.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003estd::bit_cast\u003c/code\u003e standardizes the diverse and sub-optimal approaches of reinterpreting a value as being of a different type of the same\nlength, preserving its binary representation.\u003c/p\u003e\n\u003cp\u003eBefore C++20, the correct way to reinterpret a value was a call to \u003ccode\u003estd::memcpy\u003c/code\u003e, copying the exact binary representation from a\nvariable of one type into a variable of another. Although canonical, the use of \u003ccode\u003estd::memcpy\u003c/code\u003e might still be confusing; it is verbose, and\nit might introduce performance overhead if the compiler does not recognize the idiom and does not remove the function call.\u003c/p\u003e\n\u003cp\u003eIn contrast, \u003ccode\u003estd::bit_cast\u003c/code\u003e clearly states the intent and is guaranteed to map to an optimal implementation.\u003c/p\u003e\n\u003cp\u003eThis rule reports the uses of \u003ccode\u003estd::memcpy\u003c/code\u003e that can be replaced by \u003ccode\u003estd::bit_cast\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstatic_assert(sizeof(float) \u003d\u003d sizeof(uint32_t));\nfloat src \u003d 1.0f;\nuint32_t dst;\nstd::memcpy(\u0026amp;dst, \u0026amp;src, sizeof(float)); // Noncompliant: verbose and might incur performance hit\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nfloat src \u003d 1.0f;\nauto dst \u003d std::bit_cast\u0026lt;uint32_t\u0026gt;(src); // Compliant\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/numeric/bit_cast\"\u003estd::bit_cast\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003eOther common patterns predating C++20:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S3630} - replacing \u003ccode\u003estd::reinterpret_cast\u003c/code\u003e with \u003ccode\u003estd::bit_cast\u003c/code\u003e. \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S871} - replacing C-style cast with \u003ccode\u003estd::bit_cast\u003c/code\u003e. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003ccode\u003estd::bit_cast\u003c/code\u003e is one of the standard functions working with binary representation. Together with other bit-level functions, it is\ndefined in the \u003ccode\u003e\u0026lt;bit\u0026gt;\u003c/code\u003e header introduced by C++20.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003estd::bit_cast\u003c/code\u003e standardizes the diverse and sub-optimal approaches of reinterpreting a value as being of a different type of the same\nlength, preserving its binary representation.\u003c/p\u003e\n\u003cp\u003eBefore C++20, the correct way to reinterpret a value was a call to \u003ccode\u003estd::memcpy\u003c/code\u003e, copying the exact binary representation from a\nvariable of one type into a variable of another. Although canonical, the use of \u003ccode\u003estd::memcpy\u003c/code\u003e might still be confusing; it is verbose, and\nit might introduce performance overhead if the compiler does not recognize the idiom and does not remove the function call.\u003c/p\u003e\n\u003cp\u003eIn contrast, \u003ccode\u003estd::bit_cast\u003c/code\u003e clearly states the intent and is guaranteed to map to an optimal implementation.\u003c/p\u003e\n\u003cp\u003eThis rule reports the uses of \u003ccode\u003estd::memcpy\u003c/code\u003e that can be replaced by \u003ccode\u003estd::bit_cast\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstatic_assert(sizeof(float) \u003d\u003d sizeof(uint32_t));\nfloat src \u003d 1.0f;\nuint32_t dst;\nstd::memcpy(\u0026amp;dst, \u0026amp;src, sizeof(float)); // Noncompliant: verbose and might incur performance hit\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nfloat src \u003d 1.0f;\nauto dst \u003d std::bit_cast\u0026lt;uint32_t\u0026gt;(src); // Compliant\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/numeric/bit_cast\"\u003estd::bit_cast\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003eOther common patterns predating C++20:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S3630} - replacing \u003ccode\u003estd::reinterpret_cast\u003c/code\u003e with \u003ccode\u003estd::bit_cast\u003c/code\u003e. \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S871} - replacing C-style cast with \u003ccode\u003estd::bit_cast\u003c/code\u003e. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "bad-practice",
      "pitfall",
      "since-c++20"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1854",
    "name": "Unused assignments should be removed",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003cp\u003eUnused assignments should be removed.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eComputing or retrieving a value only to then immediately overwrite it or throw it away indicates a serious logic error in the code.\u003c/p\u003e\n\u003cp\u003eAssigning a value to a local variable that is not read by any subsequent instruction is called a \u003cem\u003edead store\u003c/em\u003e. The following code snippet\ndepicts a few dead stores.\u003c/p\u003e\n\u003cpre\u003e\nint foo() {\n  int x \u003d 0; // Noncompliant: dead store, next line overwrites x\n  x \u003d 100; // Noncompliant: dead store, next line overwrites x\n  x \u003d 200;\n  int y \u003d 0;\n  y +\u003d 9001; // Noncompliant: dead store, y is never used\n  int z \u003d 300; // Noncompliant: dead store, next line overwrites z\n  z \u003d 400;\n  return x + z * 2;\n}\n\u003c/pre\u003e\n\u003cp\u003eEven if the unnecessary operations do not do any harm in terms of the program’s correctness, they are—​at best—​a waste of computing resources. In\nmost cases, these operations have their intended use but it is not expressed correctly in the code. Therefore, unused values and superfluous code\nshould be removed to prevent logic errors.\u003c/p\u003e\n\u003ch2\u003eWhat is the potential impact?\u003c/h2\u003e\n\u003cp\u003eNot only do unused values and superfluous code make the program unnecessary complex, but also indicate significant logic errors. And even in the\nabsence of logic errors, they waste computing resources in case the compiler is not able to optimize them away.\u003c/p\u003e\n\u003cp\u003eUnused values typically showcase a discrepancy between what a developer intended and what is specified in the code and should be removed to uncover\nand eventually prevent logic errors.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eRemove unused values and superfluous code.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nint foo(int y) {\n  int x \u003d 0;\n  x \u003d 100; // Noncompliant: dead store\n  x \u003d 200;\n  return x + y;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nint foo(int y) {\n  int x \u003d 200; // Compliant: no unnecessary assignment\n  return x + y;\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\nint bar();\nint buz();\n\nint foo(bool b) {\n  int x \u003d 0;\n  if (b) {\n    x \u003d bar();\n    return x;\n  }\n  if (x !\u003d 0) {\n    int y \u003d buz();\n    y +\u003d 9001; // Noncompliant: dead store\n  }\n  return x;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\nint bar();\nint buz();\n\nint foo(bool b) {\n  int x \u003d 0;\n  if (b) {\n    x \u003d bar();\n    return x;\n  }\n  // Compliant: no more dead stores and superfluous code\n  // Assuming call to buz() had no important side effects\n  return x;\n}\n\u003c/pre\u003e\n\u003ch3\u003ePitfalls\u003c/h3\u003e\n\u003cp\u003eWhen removing unused values and superfluous code, make sure that the right-hand side of a given assignment has no side effects.\u003c/p\u003e\n\u003cp\u003eWhile it is safe to remove the call to \u003ccode\u003esquare\u003c/code\u003e in the following code since it has no side effects, removing the call to\n\u003ccode\u003efwrite\u003c/code\u003e changes the program’s behavior. Still, values that are never read such as \u003ccode\u003en\u003c/code\u003e indicate code smells that should be\nmitigated. In this code example, the return value of \u003ccode\u003efwrite\u003c/code\u003e should be checked and any potential error should be handled\nappropriately.\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;string.h\u0026gt;\n\nint square(int n) {\n  return n * n;\n}\n\nint foo(int i) {\n  int sq \u003d square(i); // Noncompliant: dead store, assignment can be removed\n  const char* const str \u003d \"Hello, World!\\n\";\n  // Although `n` is never read, the call to `fwrite` cannot be removed due to side effects\n  size_t n \u003d fwrite(str, sizeof(char), strlen(str), stdout); // Noncompliant: `n` is never read\n  return i + 9001;\n}\n\u003c/pre\u003e\n\u003ch3\u003eGoing the extra mile\u003c/h3\u003e\n\u003cp\u003eIn C++17, the \u003ccode\u003enodiscard\u003c/code\u003e attribute has been introduced which can be used to annotate functions, enumerations and classes.\u003c/p\u003e\n\u003cp\u003eThe attribute serves as a hint to the compiler and to other developers that a function’s return value should not be ignored. A function that is\nmarked \u003ccode\u003enodiscard\u003c/code\u003e whose return value is ignored encourages the compiler to issue a warning. Example usages of the \u003ccode\u003enodiscard\u003c/code\u003e\nattribute are shown in the following:\u003c/p\u003e\n\u003cpre\u003e\n[[nodiscard]] int foo() { return 100; }\nint bar() { return 200; }\n[[nodiscard(\"An explanation on why not to discard the return value\")]] int buz() { return 300; }\n\nenum class [[nodiscard]] important_error_info { OK, WARN, CRITICAL };\nimportant_error_info compute() {\n  // More code ...\n  // In case of a critical error, return corresponding error info:\n  return important_error_info::CRITICAL;\n}\n\nvoid caller() {\n  foo(); // compiler warns on discarding a nodiscard value\n  bar(); // compiler will issue no warning\n  buz(); // compiler warns on discarding a nodiscard value\n  compute(); // compiler warns on discarding a nodiscard value\n}\n\u003c/pre\u003e\n\u003cp\u003eIn case, the return value of a function marked as \u003ccode\u003enodiscard\u003c/code\u003e should be (exceptionally) ignored, a cast to \u003ccode\u003evoid\u003c/code\u003e can be used\nto silence the compiler warning as shown in the following:\u003c/p\u003e\n\u003cpre\u003e\n[[nodiscard]] int foo() { return 100; }\n\nvoid caller() {\n  foo(); // compiler warns on discarding a nodiscard value\n  (void)foo(); // compiler will issue no warning\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/39UxBQ\"\u003eMSC13-C. Detect and remove unused values\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/563\"\u003e563 - Assignment to Variable without Use (\u0027Unused Variable\u0027)\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S1763} - All code should be reachable \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S2583} - Conditionally executed code should be reachable \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S2589} - Boolean expressions should not be gratuitous \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S3516} - Methods returns should not be invariant \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S3626} - Jump statements should not be redundant \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eUnused assignments should be removed.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eComputing or retrieving a value only to then immediately overwrite it or throw it away indicates a serious logic error in the code.\u003c/p\u003e\n\u003cp\u003eAssigning a value to a local variable that is not read by any subsequent instruction is called a \u003cem\u003edead store\u003c/em\u003e. The following code snippet\ndepicts a few dead stores.\u003c/p\u003e\n\u003cpre\u003e\nint foo() {\n  int x \u003d 0; // Noncompliant: dead store, next line overwrites x\n  x \u003d 100; // Noncompliant: dead store, next line overwrites x\n  x \u003d 200;\n  int y \u003d 0;\n  y +\u003d 9001; // Noncompliant: dead store, y is never used\n  int z \u003d 300; // Noncompliant: dead store, next line overwrites z\n  z \u003d 400;\n  return x + z * 2;\n}\n\u003c/pre\u003e\n\u003cp\u003eEven if the unnecessary operations do not do any harm in terms of the program’s correctness, they are—​at best—​a waste of computing resources. In\nmost cases, these operations have their intended use but it is not expressed correctly in the code. Therefore, unused values and superfluous code\nshould be removed to prevent logic errors.\u003c/p\u003e\n\u003ch2\u003eWhat is the potential impact?\u003c/h2\u003e\n\u003cp\u003eNot only do unused values and superfluous code make the program unnecessary complex, but also indicate significant logic errors. And even in the\nabsence of logic errors, they waste computing resources in case the compiler is not able to optimize them away.\u003c/p\u003e\n\u003cp\u003eUnused values typically showcase a discrepancy between what a developer intended and what is specified in the code and should be removed to uncover\nand eventually prevent logic errors.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eRemove unused values and superfluous code.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nint foo(int y) {\n  int x \u003d 0;\n  x \u003d 100; // Noncompliant: dead store\n  x \u003d 200;\n  return x + y;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nint foo(int y) {\n  int x \u003d 200; // Compliant: no unnecessary assignment\n  return x + y;\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\nint bar();\nint buz();\n\nint foo(bool b) {\n  int x \u003d 0;\n  if (b) {\n    x \u003d bar();\n    return x;\n  }\n  if (x !\u003d 0) {\n    int y \u003d buz();\n    y +\u003d 9001; // Noncompliant: dead store\n  }\n  return x;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\nint bar();\nint buz();\n\nint foo(bool b) {\n  int x \u003d 0;\n  if (b) {\n    x \u003d bar();\n    return x;\n  }\n  // Compliant: no more dead stores and superfluous code\n  // Assuming call to buz() had no important side effects\n  return x;\n}\n\u003c/pre\u003e\n\u003ch3\u003ePitfalls\u003c/h3\u003e\n\u003cp\u003eWhen removing unused values and superfluous code, make sure that the right-hand side of a given assignment has no side effects.\u003c/p\u003e\n\u003cp\u003eWhile it is safe to remove the call to \u003ccode\u003esquare\u003c/code\u003e in the following code since it has no side effects, removing the call to\n\u003ccode\u003efwrite\u003c/code\u003e changes the program’s behavior. Still, values that are never read such as \u003ccode\u003en\u003c/code\u003e indicate code smells that should be\nmitigated. In this code example, the return value of \u003ccode\u003efwrite\u003c/code\u003e should be checked and any potential error should be handled\nappropriately.\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;string.h\u0026gt;\n\nint square(int n) {\n  return n * n;\n}\n\nint foo(int i) {\n  int sq \u003d square(i); // Noncompliant: dead store, assignment can be removed\n  const char* const str \u003d \"Hello, World!\\n\";\n  // Although `n` is never read, the call to `fwrite` cannot be removed due to side effects\n  size_t n \u003d fwrite(str, sizeof(char), strlen(str), stdout); // Noncompliant: `n` is never read\n  return i + 9001;\n}\n\u003c/pre\u003e\n\u003ch3\u003eGoing the extra mile\u003c/h3\u003e\n\u003cp\u003eIn C++17, the \u003ccode\u003enodiscard\u003c/code\u003e attribute has been introduced which can be used to annotate functions, enumerations and classes.\u003c/p\u003e\n\u003cp\u003eThe attribute serves as a hint to the compiler and to other developers that a function’s return value should not be ignored. A function that is\nmarked \u003ccode\u003enodiscard\u003c/code\u003e whose return value is ignored encourages the compiler to issue a warning. Example usages of the \u003ccode\u003enodiscard\u003c/code\u003e\nattribute are shown in the following:\u003c/p\u003e\n\u003cpre\u003e\n[[nodiscard]] int foo() { return 100; }\nint bar() { return 200; }\n[[nodiscard(\"An explanation on why not to discard the return value\")]] int buz() { return 300; }\n\nenum class [[nodiscard]] important_error_info { OK, WARN, CRITICAL };\nimportant_error_info compute() {\n  // More code ...\n  // In case of a critical error, return corresponding error info:\n  return important_error_info::CRITICAL;\n}\n\nvoid caller() {\n  foo(); // compiler warns on discarding a nodiscard value\n  bar(); // compiler will issue no warning\n  buz(); // compiler warns on discarding a nodiscard value\n  compute(); // compiler warns on discarding a nodiscard value\n}\n\u003c/pre\u003e\n\u003cp\u003eIn case, the return value of a function marked as \u003ccode\u003enodiscard\u003c/code\u003e should be (exceptionally) ignored, a cast to \u003ccode\u003evoid\u003c/code\u003e can be used\nto silence the compiler warning as shown in the following:\u003c/p\u003e\n\u003cpre\u003e\n[[nodiscard]] int foo() { return 100; }\n\nvoid caller() {\n  foo(); // compiler warns on discarding a nodiscard value\n  (void)foo(); // compiler will issue no warning\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/39UxBQ\"\u003eMSC13-C. Detect and remove unused values\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/563\"\u003e563 - Assignment to Variable without Use (\u0027Unused Variable\u0027)\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S1763} - All code should be reachable \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S2583} - Conditionally executed code should be reachable \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S2589} - Boolean expressions should not be gratuitous \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S3516} - Methods returns should not be invariant \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S3626} - Jump statements should not be redundant \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cert",
      "cwe",
      "symbolic-execution",
      "unused"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6069",
    "name": "\"sprintf\" should not be used",
    "defaultSeverity": "CRITICAL",
    "type": "SECURITY_HOTSPOT",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "SECURITY": "HIGH"
    },
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhen using \u003ccode\u003esprintf\u003c/code\u003e , it’s up to the developer to make sure the size of the buffer to be written to is large enough to avoid buffer\noverflows. Buffer overflows can cause the program to crash at a minimum. At worst, a carefully crafted overflow can cause malicious code to be\nexecuted.\u003c/p\u003e\n\u003ch2\u003eExceptions\u003c/h2\u003e\n\u003cp\u003eIt is a very common and acceptable pattern to compute the required size of the buffer with a call to \u003ccode\u003esnprintf\u003c/code\u003e with the same arguments\ninto an empty buffer (this will fail, but return the necessary size), then to call \u003ccode\u003esprintf\u003c/code\u003e as the bound check is not needed anymore. Note\nthat 1 needs to be added by the size reported by \u003ccode\u003esnprintf\u003c/code\u003e to account for the terminal null character.\u003c/p\u003e\n\u003cpre\u003e\nsize_t buflen \u003d snprintf(0, 0, \"%s\", message);\nchar* buf \u003d malloc(buflen + 1); // For the final 0\nsprintf(buf, \"%s\", message);{code}\n\u003c/pre\u003e"
      },
      {
        "key": "assess_the_problem",
        "htmlContent": "\u003ch2\u003eAsk Yourself Whether\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e if the provided buffer is large enough for the result of any possible call to the \u003ccode\u003esprintf\u003c/code\u003e function (including all possible format\n  strings and all possible additional arguments). \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere is a risk if you answered no to the above question.\u003c/p\u003e\n\u003ch2\u003eSensitive Code Example\u003c/h2\u003e\n\u003cpre\u003e\nsprintf(str, \"%s\", message);   // Sensitive: `str` buffer size is not checked and it is vulnerable to overflows\n\u003c/pre\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003ch2\u003eRecommended Secure Coding Practices\u003c/h2\u003e\n\u003cp\u003eThere are fundamentally safer alternatives. \u003ccode\u003esnprintf\u003c/code\u003e is one of them. It takes the size of the buffer as an additional argument,\npreventing the function from overflowing the buffer.\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Use \u003ccode\u003esnprintf\u003c/code\u003e instead of \u003ccode\u003esprintf\u003c/code\u003e. The slight performance overhead can be afforded in a vast majority of projects.\n  \u003c/li\u003e\n  \u003cli\u003e Check the buffer size passed to \u003ccode\u003esnprintf\u003c/code\u003e. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIf you are working in C++, other safe alternative exist:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003estd::string\u003c/code\u003e should be the prefered type to store strings \u003c/li\u003e\n  \u003cli\u003e You can format to a string using \u003ccode\u003estd::ostringstream\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e Since C++20, \u003ccode\u003estd::format\u003c/code\u003e is also available to format strings \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eCompliant Solution\u003c/h2\u003e\n\u003cpre\u003e\nsnprintf(str, sizeof(str), \"%s\", message); // Prevent overflows by enforcing a maximum size for `str` buffer\n\u003c/pre\u003e\n\u003ch2\u003eSee\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/Top10/A06_2021-Vulnerable_and_Outdated_Components/\"\u003eOWASP Top 10 2021 Category A6\u003c/a\u003e - Vulnerable and Outdated\n  Components \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/www-project-top-ten/2017/A9_2017-Using_Components_with_Known_Vulnerabilities\"\u003eOWASP Top 10 2017 Category\n  A9\u003c/a\u003e\u0026nbsp;- Using Components with Known Vulnerabilities \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/676\"\u003eMITRE, CWE-676\u003c/a\u003e - Use of Potentially Dangerous Function \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/119\"\u003eMITRE, CWE-119\u003c/a\u003e - Improper Restriction of Operations within the Bounds of a Memory\n  Buffer \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cert",
      "cwe"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": [],
    "vulnerabilityProbability": "HIGH"
  },
  {
    "key": "cpp:S6492",
    "name": "Use \"std::format\" rather than \"std::vformat\" when the format string is known at compile time",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003estd::format\u003c/code\u003e and \u003ccode\u003estd::vformat\u003c/code\u003e have the same runtime behavior for well-formed format strings. The difference is exposed\nwhen there is an error in the format string. For instance, if it contains an invalid format specifier:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003estd::vformat\u003c/code\u003e throws a \u003ccode\u003estd::format_error\u003c/code\u003e exception at runtime. \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003estd::format\u003c/code\u003e makes these mistakes ill-formed, causing the compilation to fail. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003estd::format\u003c/code\u003e should be used whenever possible, allowing to catch malformed format strings early during the development process.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when \u003ccode\u003estd::vformat\u003c/code\u003e is used with a constant string known at compile time.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n// Noncompliant, the string is known at compile time.\nstd::cout \u0026lt;\u0026lt; std::vformat(\"{:.1f}\", std::make_format_args(5.2f)) \u0026lt;\u0026lt; std::endl;\n\n// Noncompliant, the string is known at compile time.\nconstexpr std::string_view output_format \u003d \"{} {} {}\";\nstd::cout \u0026lt;\u0026lt; std::vformat(output_format, std::make_format_args(42, 52, 62)) \u0026lt;\u0026lt; std::endl;\n\n// Noncompliant\n// The format specification does not match the type,\n// throws `std::format_error` at run-time.\nstd::cout \u0026lt;\u0026lt; std::vformat(\"{:d}\", std::make_format_args(5.6f)) \u0026lt;\u0026lt; std::endl;\n\n// Noncompliant\n// The number of formatted fields is greater than the number of arguments,\n// throws `std::format_error` at run-time.\nstd::cout \u0026lt;\u0026lt; std::vformat(\"{} {}\", std::make_format_args(\"A string\")) \u0026lt;\u0026lt; std::endl;\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstd::cout \u0026lt;\u0026lt; std::format(\"{:.1f}\", 5.2f) \u0026lt;\u0026lt; std::endl;            // Compliant\n\nconstexpr std::string_view output_format \u003d \"{} {} {}\";\nstd::cout \u0026lt;\u0026lt; std::format(output_format, 42, 52, 62) \u0026lt;\u0026lt; std::endl; // Compliant\n\n// Compile-time error, the format specification does not match the type.\n// std::cout \u0026lt;\u0026lt; std::format(\"{:d}\", 5.6f) \u0026lt;\u0026lt; std::endl;\n\n// Compile-time error, the number of formatted fields is greater than the number of arguments.\n// std::cout \u0026lt;\u0026lt; std::format(\"{} {}\", \"A string\") \u0026lt;\u0026lt; std::endl;\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThis rule will not report the use of \u003ccode\u003estd::vformat\u003c/code\u003e when its arguments are received by the enclosing function wrapped in a\n\u003ccode\u003estd::format_args\u003c/code\u003e object.\u003c/p\u003e\n\u003cpre\u003e\nvoid log_internal (std::format_args const\u0026amp; args) {\n  assert(args.get(3));\n  std::cout \u0026lt;\u0026lt; std::vformat(\"{} {}[{}]: {}\", args);\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003ccode\u003estd::format\u003c/code\u003e and \u003ccode\u003estd::vformat\u003c/code\u003e have the same runtime behavior for well-formed format strings. The difference is exposed\nwhen there is an error in the format string. For instance, if it contains an invalid format specifier:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003estd::vformat\u003c/code\u003e throws a \u003ccode\u003estd::format_error\u003c/code\u003e exception at runtime. \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003estd::format\u003c/code\u003e makes these mistakes ill-formed, causing the compilation to fail. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003estd::format\u003c/code\u003e should be used whenever possible, allowing to catch malformed format strings early during the development process.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when \u003ccode\u003estd::vformat\u003c/code\u003e is used with a constant string known at compile time.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n// Noncompliant, the string is known at compile time.\nstd::cout \u0026lt;\u0026lt; std::vformat(\"{:.1f}\", std::make_format_args(5.2f)) \u0026lt;\u0026lt; std::endl;\n\n// Noncompliant, the string is known at compile time.\nconstexpr std::string_view output_format \u003d \"{} {} {}\";\nstd::cout \u0026lt;\u0026lt; std::vformat(output_format, std::make_format_args(42, 52, 62)) \u0026lt;\u0026lt; std::endl;\n\n// Noncompliant\n// The format specification does not match the type,\n// throws `std::format_error` at run-time.\nstd::cout \u0026lt;\u0026lt; std::vformat(\"{:d}\", std::make_format_args(5.6f)) \u0026lt;\u0026lt; std::endl;\n\n// Noncompliant\n// The number of formatted fields is greater than the number of arguments,\n// throws `std::format_error` at run-time.\nstd::cout \u0026lt;\u0026lt; std::vformat(\"{} {}\", std::make_format_args(\"A string\")) \u0026lt;\u0026lt; std::endl;\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstd::cout \u0026lt;\u0026lt; std::format(\"{:.1f}\", 5.2f) \u0026lt;\u0026lt; std::endl;            // Compliant\n\nconstexpr std::string_view output_format \u003d \"{} {} {}\";\nstd::cout \u0026lt;\u0026lt; std::format(output_format, 42, 52, 62) \u0026lt;\u0026lt; std::endl; // Compliant\n\n// Compile-time error, the format specification does not match the type.\n// std::cout \u0026lt;\u0026lt; std::format(\"{:d}\", 5.6f) \u0026lt;\u0026lt; std::endl;\n\n// Compile-time error, the number of formatted fields is greater than the number of arguments.\n// std::cout \u0026lt;\u0026lt; std::format(\"{} {}\", \"A string\") \u0026lt;\u0026lt; std::endl;\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThis rule will not report the use of \u003ccode\u003estd::vformat\u003c/code\u003e when its arguments are received by the enclosing function wrapped in a\n\u003ccode\u003estd::format_args\u003c/code\u003e object.\u003c/p\u003e\n\u003cpre\u003e\nvoid log_internal (std::format_args const\u0026amp; args) {\n  assert(args.get(3));\n  std::cout \u0026lt;\u0026lt; std::vformat(\"{} {}[{}]: {}\", args);\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "bad-practice",
      "clumsy",
      "since-c++20"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5283",
    "name": "Size of variable length arrays should be greater than zero",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003cp\u003eCreating a Variable Length Array (VLA) with a size that is not greater than zero leads to undefined behavior.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eVariable length arrays are used to allocate a stack size for the number of elements that are known at the runtime, for example:\u003c/p\u003e\n\u003cpre\u003e\nvoid merge(int* tab, int size, int first) {\n  int res[size]; // allocate buffer for merging on stack\n  /* Code that merges two sorted ranges [tab, tab + first) and [tab + first, tab + last)\n   * into res buffer.\n   * ....\n   */\n  // copy merged data into input\n  memcpy(tab, res, size * sizeof(int));\n}\n\u003c/pre\u003e\n\u003cp\u003eThe syntax follows the one used by an array with static size (where size is a constant), and the value placed in the square brackets\n(\u003ccode\u003e[size]\u003c/code\u003e in the above example) determines the size of the array. For both static and runtime-sized arrays, the size is required to be\ngreater than zero. However, in the case of VLAs, this cannot be checked by the compiler, and any program that creates such an array with a size that\nhas a value of zero or is negative, has undefined behavior.\u003c/p\u003e\n\u003cpre\u003e\nvoid example() {\n  int s \u003d -1;\n  int vla[s];  // program compiles, and have undefined behavior\n  int arr[-1]; // program is ill-formed\n}\n\u003c/pre\u003e\n\u003cp\u003eThis defect may also manifest when the variable used as size is not initialized. Uninitialized variables might have zero, negative, or any value at\neach time the program executes.\u003c/p\u003e\n\u003cpre\u003e\nvoid uninitialized() {\n  int s;      // uninitialized, the value is not determined\n  int vla[s]; // program compiles, have undefined behavior if the value read from s is negative or zero\n}\n\u003c/pre\u003e\n\u003cp\u003eA non-positive size of the VLAs may also result from using a value loaded by the program from a file or other external resources used as size\nwithout previous validation. Such values as usually referred to as being \u003cem\u003etainted\u003c/em\u003e.\u003c/p\u003e\n\u003cpre\u003e\nvoid loadFromInput() {\n  int size \u003d -1;\n  scanf(\"%d\", \u0026amp;size); // loads size from input\n  char bytes[size];   // size may be negative\n  /* ... */\n}\n\u003c/pre\u003e\n\u003cp\u003eThe above code will lead to undefined behavior when the value of the \u003ccode\u003esize\u003c/code\u003e load from the input is not greater than zero. This may\nhappen due to source data corruption, accidental user mistake, or malicious action.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eCreating a variable length array with a size smaller or equal to zero leads to undefined behavior. This means the compiler is not bound by the\nlanguage standard anymore, and your program has no meaning assigned to it.\u003c/p\u003e\n\u003cp\u003ePractically this can lead to a wide range of effects and may lead to the following:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e crashes, in particular segmentation faults, when the program access memory that it is not allowed to, \u003c/li\u003e\n  \u003cli\u003e memory corruption and data losses, when the program overwrites bytes responsible for storing data or executable code, \u003c/li\u003e\n  \u003cli\u003e stack overflow, when negative size is interpreted as a large positive number. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eFurthermore, in a situation when VLA size is dependent on the user input, it can lead to vulnerabilities in the program.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eEnsure that the size of the variable length array is always greater than zero. In case of value that depends on user input (is \u003cem\u003etainted\u003c/em\u003e),\nprefer to allocate the memory on heap, or if that is not possible, include appropriate checks to ensure that value is positive and constrained before\nusing it as size for VLA.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cp\u003eZero size VLA is created due of by-one error.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid zeroSize() {\n  for (int i \u003d 0; i \u0026lt;\u003d 5; ++i) {\n    int buffer[5 - i]; // Noncompliant: buffer size is zero for last iteration\n    /* ... */\n  }\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid zeroSize() {\n  for (int i \u003d 0; i \u0026lt; 5; ++i) {\n    int buffer[5 - i]; // Complaint\n    /* ... */\n  }\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cp\u003eSize is not initialized in one of code paths.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\nint countGrapheneClusters(int codeUnits, int bytesInCodeUnit) {\n  int size;\n  if (bytesInCodeUnit \u0026gt; 0) {\n    size \u003d codeUnits * bytesInCodeUnit;\n  }\n  char buffer[size]; // Noncomplaint: size may not be initialized\n  // ....\n  return  0;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\nint countGrapheneClusters(int codeUnits, int bytesInCodeUnit) {\n  int size;\n  if (bytesInCodeUnit \u0026gt; 0) {\n    size \u003d codeUnits * bytesInCodeUnit;\n  } else {\n    return -1;\n  }\n  char buffer[size]; // Complaint: size is always initialized\n  // ....\n  return  0;\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"noncompliant\"\u003e\nint taintedSize() {\n  int size \u003d 0;\n  scanf(\"%d\", \u0026amp;size); // size value is loaded from input, value is tainted here\n  char bytes[size];   // Noncomplaint: size may be negative\n  /* ... */\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eAllocate memory on heap, instead of using variable lenght array.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"compliant\"\u003e\nint taintedSize() {\n  int size \u003d 0;\n  scanf(\"%d\", \u0026amp;size);\n  if (size \u0026lt;\u003d 0 || size \u0026gt; 1000) {\n    return -1;\n  }\n\n  char* bytes \u003d (char*)malloc(size); // Complaint: uses heap allocation\n  /* ... */\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch2\u003eGoing the extra mile\u003c/h2\u003e\n\u003cp\u003eVariable length arrays are allocated on the stack, so in situations when a large value of the size is used, creating such an array may lead to\nstack overflow and undefined behavior:\u003c/p\u003e\n\u003cpre\u003e\nvoid largeVLA() {\n  int s \u003d INT_MAX;\n  int vla[s][100]; // requires allocation of the INT_MAX * 100\n}\n\u003c/pre\u003e\n\u003cp\u003eIn addition, the language does not provide a way to query available stack space, nor the possibility of reporting failure in the creation of such\nan array.\u003c/p\u003e\n\u003cp\u003eWhen applicable, it is recommended to replace the VLA with heap-allocated memory. In contrast to VLA, heap allocation functions report in a\nsituation when sufficient memory cannot be provided, by returning \u003ccode\u003eNULL\u003c/code\u003e or throwing an exception (in C++). Furthermore, the C++ standard\nlibrary provides containers like \u003ccode\u003estd::vector\u003c/code\u003e, that manage the heap-allocated memory.\u003c/p\u003e\n\u003cp\u003eMoreover, the C11 language standard and above only optionally supports VLAs (with \u003ccode\u003e__STDC_NO_VLA__\u003c/code\u003e), and the C++ standard never\nsupported it, however, they are commonly accepted as extensions.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/c/language/array#Variable-length_arrays\"\u003eVariable-length arrays\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/container/vector\"\u003e\u003ccode\u003estd::vector\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca\n  href\u003d\"https://wiki.sei.cmu.edu/confluence/display/c/ARR32-C.+Ensure+size+arguments+for+variable+length+arrays+are+in+a+valid+range\"\u003eARR32-C. Ensure\n  size arguments for variable length arrays are in a valid range\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eCreating a Variable Length Array (VLA) with a size that is not greater than zero leads to undefined behavior.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eVariable length arrays are used to allocate a stack size for the number of elements that are known at the runtime, for example:\u003c/p\u003e\n\u003cpre\u003e\nvoid merge(int* tab, int size, int first) {\n  int res[size]; // allocate buffer for merging on stack\n  /* Code that merges two sorted ranges [tab, tab + first) and [tab + first, tab + last)\n   * into res buffer.\n   * ....\n   */\n  // copy merged data into input\n  memcpy(tab, res, size * sizeof(int));\n}\n\u003c/pre\u003e\n\u003cp\u003eThe syntax follows the one used by an array with static size (where size is a constant), and the value placed in the square brackets\n(\u003ccode\u003e[size]\u003c/code\u003e in the above example) determines the size of the array. For both static and runtime-sized arrays, the size is required to be\ngreater than zero. However, in the case of VLAs, this cannot be checked by the compiler, and any program that creates such an array with a size that\nhas a value of zero or is negative, has undefined behavior.\u003c/p\u003e\n\u003cpre\u003e\nvoid example() {\n  int s \u003d -1;\n  int vla[s];  // program compiles, and have undefined behavior\n  int arr[-1]; // program is ill-formed\n}\n\u003c/pre\u003e\n\u003cp\u003eThis defect may also manifest when the variable used as size is not initialized. Uninitialized variables might have zero, negative, or any value at\neach time the program executes.\u003c/p\u003e\n\u003cpre\u003e\nvoid uninitialized() {\n  int s;      // uninitialized, the value is not determined\n  int vla[s]; // program compiles, have undefined behavior if the value read from s is negative or zero\n}\n\u003c/pre\u003e\n\u003cp\u003eA non-positive size of the VLAs may also result from using a value loaded by the program from a file or other external resources used as size\nwithout previous validation. Such values as usually referred to as being \u003cem\u003etainted\u003c/em\u003e.\u003c/p\u003e\n\u003cpre\u003e\nvoid loadFromInput() {\n  int size \u003d -1;\n  scanf(\"%d\", \u0026amp;size); // loads size from input\n  char bytes[size];   // size may be negative\n  /* ... */\n}\n\u003c/pre\u003e\n\u003cp\u003eThe above code will lead to undefined behavior when the value of the \u003ccode\u003esize\u003c/code\u003e load from the input is not greater than zero. This may\nhappen due to source data corruption, accidental user mistake, or malicious action.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eCreating a variable length array with a size smaller or equal to zero leads to undefined behavior. This means the compiler is not bound by the\nlanguage standard anymore, and your program has no meaning assigned to it.\u003c/p\u003e\n\u003cp\u003ePractically this can lead to a wide range of effects and may lead to the following:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e crashes, in particular segmentation faults, when the program access memory that it is not allowed to, \u003c/li\u003e\n  \u003cli\u003e memory corruption and data losses, when the program overwrites bytes responsible for storing data or executable code, \u003c/li\u003e\n  \u003cli\u003e stack overflow, when negative size is interpreted as a large positive number. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eFurthermore, in a situation when VLA size is dependent on the user input, it can lead to vulnerabilities in the program.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eEnsure that the size of the variable length array is always greater than zero. In case of value that depends on user input (is \u003cem\u003etainted\u003c/em\u003e),\nprefer to allocate the memory on heap, or if that is not possible, include appropriate checks to ensure that value is positive and constrained before\nusing it as size for VLA.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cp\u003eZero size VLA is created due of by-one error.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid zeroSize() {\n  for (int i \u003d 0; i \u0026lt;\u003d 5; ++i) {\n    int buffer[5 - i]; // Noncompliant: buffer size is zero for last iteration\n    /* ... */\n  }\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid zeroSize() {\n  for (int i \u003d 0; i \u0026lt; 5; ++i) {\n    int buffer[5 - i]; // Complaint\n    /* ... */\n  }\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cp\u003eSize is not initialized in one of code paths.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\nint countGrapheneClusters(int codeUnits, int bytesInCodeUnit) {\n  int size;\n  if (bytesInCodeUnit \u0026gt; 0) {\n    size \u003d codeUnits * bytesInCodeUnit;\n  }\n  char buffer[size]; // Noncomplaint: size may not be initialized\n  // ....\n  return  0;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\nint countGrapheneClusters(int codeUnits, int bytesInCodeUnit) {\n  int size;\n  if (bytesInCodeUnit \u0026gt; 0) {\n    size \u003d codeUnits * bytesInCodeUnit;\n  } else {\n    return -1;\n  }\n  char buffer[size]; // Complaint: size is always initialized\n  // ....\n  return  0;\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"noncompliant\"\u003e\nint taintedSize() {\n  int size \u003d 0;\n  scanf(\"%d\", \u0026amp;size); // size value is loaded from input, value is tainted here\n  char bytes[size];   // Noncomplaint: size may be negative\n  /* ... */\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eAllocate memory on heap, instead of using variable lenght array.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"compliant\"\u003e\nint taintedSize() {\n  int size \u003d 0;\n  scanf(\"%d\", \u0026amp;size);\n  if (size \u0026lt;\u003d 0 || size \u0026gt; 1000) {\n    return -1;\n  }\n\n  char* bytes \u003d (char*)malloc(size); // Complaint: uses heap allocation\n  /* ... */\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch2\u003eGoing the extra mile\u003c/h2\u003e\n\u003cp\u003eVariable length arrays are allocated on the stack, so in situations when a large value of the size is used, creating such an array may lead to\nstack overflow and undefined behavior:\u003c/p\u003e\n\u003cpre\u003e\nvoid largeVLA() {\n  int s \u003d INT_MAX;\n  int vla[s][100]; // requires allocation of the INT_MAX * 100\n}\n\u003c/pre\u003e\n\u003cp\u003eIn addition, the language does not provide a way to query available stack space, nor the possibility of reporting failure in the creation of such\nan array.\u003c/p\u003e\n\u003cp\u003eWhen applicable, it is recommended to replace the VLA with heap-allocated memory. In contrast to VLA, heap allocation functions report in a\nsituation when sufficient memory cannot be provided, by returning \u003ccode\u003eNULL\u003c/code\u003e or throwing an exception (in C++). Furthermore, the C++ standard\nlibrary provides containers like \u003ccode\u003estd::vector\u003c/code\u003e, that manage the heap-allocated memory.\u003c/p\u003e\n\u003cp\u003eMoreover, the C11 language standard and above only optionally supports VLAs (with \u003ccode\u003e__STDC_NO_VLA__\u003c/code\u003e), and the C++ standard never\nsupported it, however, they are commonly accepted as extensions.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/c/language/array#Variable-length_arrays\"\u003eVariable-length arrays\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/container/vector\"\u003e\u003ccode\u003estd::vector\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca\n  href\u003d\"https://wiki.sei.cmu.edu/confluence/display/c/ARR32-C.+Ensure+size+arguments+for+variable+length+arrays+are+in+a+valid+range\"\u003eARR32-C. Ensure\n  size arguments for variable length arrays are in a valid range\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "suspicious",
      "symbolic-execution"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6372",
    "name": "Use type-erased \"coroutine_handle\" when applicable",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "MODULAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe implementation of the \u003ccode\u003eawait_suspend\u003c/code\u003e method accepts the handle to the suspended coroutine as the parameter. This parameter can be\ndefined with either specific promise type \u003ccode\u003ecoroutine_handle\u0026lt;PromiseType\u0026gt;\u003c/code\u003e or type erased \u003ccode\u003ecoroutine_handle\u0026lt;\u0026gt;\u003c/code\u003e. The\nformer allows \u003ccode\u003eawait_suspend\u003c/code\u003e to access the promise of the coroutine; however, it ties the implementation to a particular type. In\ncontrast, using \u003ccode\u003ecoroutine_handle\u0026lt;\u0026gt;\u003c/code\u003e increases the reusability of the code because this parameter type supports all promise\ntypes.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue for the implementation of \u003ccode\u003eawait_suspend\u003c/code\u003e that accepts handles to a specific promise type and yet does not use\nthat information.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstruct Awaiter1\n{\n   Event\u0026amp; event;\n   /* ... */\n   bool await_suspend(std::coroutine_handle\u0026lt;Promise\u0026gt; current) { // Noncompliant\n     return event.register_callback([current] {\n              current.resume();\n            });\n   }\n};\n\nstruct Awaiter2\n{\n   Event\u0026amp; event;\n   /* ... */\n   bool await_suspend(std::coroutine_handle\u0026lt;PromiseA\u0026gt; current) { // Noncompliant\n     return event.register_callback([current] {\n              current.resume();\n            });\n   }\n   bool await_suspend(std::coroutine_handle\u0026lt;PromiseB\u0026gt; current) { // Noncompliant\n     return event.register_callback([current] {\n              current.resume();\n            });\n   }\n};\n\nstruct Awaiter3\n{\n   Event\u0026amp; event;\n   /* ... */\n   template\u0026lt;typename PromiseType\u0026gt;\n   bool await_suspend(std::coroutine_handle\u0026lt;PromiseType\u0026gt; current) { // Noncompliant\n     return event.register_callback([current] {\n              current.resume();\n            });\n   }\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstruct Awaiter // Instead of each of Awaiter1, Awaiter2, Awaiter3\n{\n   Event\u0026amp; event;\n   /* ... */\n   bool await_suspend(std::coroutine_handle\u0026lt;\u0026gt; current) {\n     return event.register_callback([current] {\n              current.resume();\n            });\n   }\n};\n\nstruct AwaiterUsingPromise\n{\n  /* ... */\n  void await_suspend(std::coroutine_handle\u0026lt;Promise\u0026gt; current) { // Compliant\n    auto wokeUpTime \u003d std::chrono::system_clock::now() + std::chrono::seconds(10);\n    current.promise().executor().schedule_at(wokeUpTime, current); // promise used here\n  }\n\n};\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe implementation of the \u003ccode\u003eawait_suspend\u003c/code\u003e method accepts the handle to the suspended coroutine as the parameter. This parameter can be\ndefined with either specific promise type \u003ccode\u003ecoroutine_handle\u0026lt;PromiseType\u0026gt;\u003c/code\u003e or type erased \u003ccode\u003ecoroutine_handle\u0026lt;\u0026gt;\u003c/code\u003e. The\nformer allows \u003ccode\u003eawait_suspend\u003c/code\u003e to access the promise of the coroutine; however, it ties the implementation to a particular type. In\ncontrast, using \u003ccode\u003ecoroutine_handle\u0026lt;\u0026gt;\u003c/code\u003e increases the reusability of the code because this parameter type supports all promise\ntypes.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue for the implementation of \u003ccode\u003eawait_suspend\u003c/code\u003e that accepts handles to a specific promise type and yet does not use\nthat information.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstruct Awaiter1\n{\n   Event\u0026amp; event;\n   /* ... */\n   bool await_suspend(std::coroutine_handle\u0026lt;Promise\u0026gt; current) { // Noncompliant\n     return event.register_callback([current] {\n              current.resume();\n            });\n   }\n};\n\nstruct Awaiter2\n{\n   Event\u0026amp; event;\n   /* ... */\n   bool await_suspend(std::coroutine_handle\u0026lt;PromiseA\u0026gt; current) { // Noncompliant\n     return event.register_callback([current] {\n              current.resume();\n            });\n   }\n   bool await_suspend(std::coroutine_handle\u0026lt;PromiseB\u0026gt; current) { // Noncompliant\n     return event.register_callback([current] {\n              current.resume();\n            });\n   }\n};\n\nstruct Awaiter3\n{\n   Event\u0026amp; event;\n   /* ... */\n   template\u0026lt;typename PromiseType\u0026gt;\n   bool await_suspend(std::coroutine_handle\u0026lt;PromiseType\u0026gt; current) { // Noncompliant\n     return event.register_callback([current] {\n              current.resume();\n            });\n   }\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstruct Awaiter // Instead of each of Awaiter1, Awaiter2, Awaiter3\n{\n   Event\u0026amp; event;\n   /* ... */\n   bool await_suspend(std::coroutine_handle\u0026lt;\u0026gt; current) {\n     return event.register_callback([current] {\n              current.resume();\n            });\n   }\n};\n\nstruct AwaiterUsingPromise\n{\n  /* ... */\n  void await_suspend(std::coroutine_handle\u0026lt;Promise\u0026gt; current) { // Compliant\n    auto wokeUpTime \u003d std::chrono::system_clock::now() + std::chrono::seconds(10);\n    current.promise().executor().schedule_at(wokeUpTime, current); // promise used here\n  }\n\n};\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "bad-practice",
      "since-c++20"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6493",
    "name": "The result of \"make_format_args\" should be passed directly as an argument",
    "defaultSeverity": "BLOCKER",
    "type": "BUG",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003estd::make_format_args\u003c/code\u003e and \u003ccode\u003estd::make_wformat_args\u003c/code\u003e return objects containing an array of formatting arguments that can be\nimplicitly converted to \u003ccode\u003estd::basic_format_args\u003c/code\u003e. The type of the returned object cannot be spelled; it can only be accessed through\n\u003ccode\u003eauto\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eA formatting argument has reference semantics for non-built-in types and does not extend the lifetime of the passed arguments. It is your\nresponsibility to ensure that the arguments to \u003ccode\u003estd::make_format_args\u003c/code\u003e and \u003ccode\u003estd::make_wformat_args\u003c/code\u003e outlive their return value.\nSpecifically, be aware that:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Assigning the result of \u003ccode\u003estd::make_format_args\u003c/code\u003e to a variable of type \u003ccode\u003estd::basic_format_args\u003c/code\u003e will always dangle. \u003c/li\u003e\n  \u003cli\u003e Assigning the result of \u003ccode\u003estd::make_format_args\u003c/code\u003e to a variable of type \u003ccode\u003eauto\u003c/code\u003e will dangle when the formatting arguments\n  contain an rvalue of a non-built-in type. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWhile it is possible to assign \u003ccode\u003estd::make_format_args\u003c/code\u003e to a variable declared with \u003ccode\u003eauto\u003c/code\u003e if all the formatting arguments are\nbuilt-in types or lvalues, it is suspicious and error-prone. That is why we recommend that the result of \u003ccode\u003estd::make_format_args\u003c/code\u003e is only\nused as an argument for formatting functions.\u003c/p\u003e\n\u003cp\u003eThis rule detects when the result of \u003ccode\u003estd::make_format_args\u003c/code\u003e or \u003ccode\u003estd::make_wformat_args\u003c/code\u003e isn’t used as an argument.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003ePass the result of \u003ccode\u003estd::make_format_args\u003c/code\u003e or \u003ccode\u003estd::make_wformat_args\u003c/code\u003e directly as an argument.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid helloAndGoodByeReality() {\n  // Noncompliant, dangles\n  std::format_args numberOfHellosAndGoodByes \u003d std::make_format_args(1000, 1);\n  std::cout \u0026lt;\u0026lt; vformat(\"Hello {0} times, and goodbyes {1} times :(\\n\", numberOfHellosAndGoodByes);\n}\n\nvoid helloAndGoodByeExpectation() {\n  // Noncompliant, error-prone but doesn\u0027t dangle due to built-in types\n  auto numberOfHellosAndGoodByes \u003d std::make_format_args(1000, 1000000);\n  std::cout \u0026lt;\u0026lt; vformat(\"Hello {0} times, and goodbyes {1} times :)\\n\", numberOfHellosAndGoodByes);\n}\n\nstd::string getHellosForRemote() {\n  return \"zero\";\n}\n\nstd::string getGoodbyesForRemote() {\n  return \"zero\";\n}\nvoid helloAndGoodByeForRemote() {\n  // Noncompliant, dangles; getHellosForRemote() is an rvalue of non-built-in type std::string\n  auto numberOfHelloAndGoodBye \u003d std::make_format_args(getHellosForRemote(), getGoodbyesForRemote());\n  std::cout \u0026lt;\u0026lt; vformat(\"Hello {0} times, and goodbyes {1} times :|\\n\", numberOfHelloAndGoodBye);\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid helloAndGoodByeReality() {\n  std::cout \u0026lt;\u0026lt; vformat(\"Hello {0} times, and goodbyes {1} times :(\\n\",\n    std::make_format_args(1000, 1));  // Compliant\n}\n\nvoid helloAndGoodByeExpectation() {\n  std::cout \u0026lt;\u0026lt; vformat(\"Hello {0} times, and goodbyes {1} times :)\\n\",\n    std::make_format_args(1000, 1000000));  // Compliant\n}\n\nstd::string getHellosForRemote() {\n  return \"zero\";\n}\n\nstd::string getGoodbyesForRemote() {\n  return \"zero\";\n}\nvoid helloAndGoodByeForRemote() {\n  std::cout \u0026lt;\u0026lt;\n    vformat(\"Hello {0} times, and goodbyes {1} times :|\\n\",\n      std::make_format_args(getHellosForRemote(), getGoodbyesForRemote())); // Compliant\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003ccode\u003estd::make_format_args\u003c/code\u003e and \u003ccode\u003estd::make_wformat_args\u003c/code\u003e return objects containing an array of formatting arguments that can be\nimplicitly converted to \u003ccode\u003estd::basic_format_args\u003c/code\u003e. The type of the returned object cannot be spelled; it can only be accessed through\n\u003ccode\u003eauto\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eA formatting argument has reference semantics for non-built-in types and does not extend the lifetime of the passed arguments. It is your\nresponsibility to ensure that the arguments to \u003ccode\u003estd::make_format_args\u003c/code\u003e and \u003ccode\u003estd::make_wformat_args\u003c/code\u003e outlive their return value.\nSpecifically, be aware that:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Assigning the result of \u003ccode\u003estd::make_format_args\u003c/code\u003e to a variable of type \u003ccode\u003estd::basic_format_args\u003c/code\u003e will always dangle. \u003c/li\u003e\n  \u003cli\u003e Assigning the result of \u003ccode\u003estd::make_format_args\u003c/code\u003e to a variable of type \u003ccode\u003eauto\u003c/code\u003e will dangle when the formatting arguments\n  contain an rvalue of a non-built-in type. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWhile it is possible to assign \u003ccode\u003estd::make_format_args\u003c/code\u003e to a variable declared with \u003ccode\u003eauto\u003c/code\u003e if all the formatting arguments are\nbuilt-in types or lvalues, it is suspicious and error-prone. That is why we recommend that the result of \u003ccode\u003estd::make_format_args\u003c/code\u003e is only\nused as an argument for formatting functions.\u003c/p\u003e\n\u003cp\u003eThis rule detects when the result of \u003ccode\u003estd::make_format_args\u003c/code\u003e or \u003ccode\u003estd::make_wformat_args\u003c/code\u003e isn’t used as an argument.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003ePass the result of \u003ccode\u003estd::make_format_args\u003c/code\u003e or \u003ccode\u003estd::make_wformat_args\u003c/code\u003e directly as an argument.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid helloAndGoodByeReality() {\n  // Noncompliant, dangles\n  std::format_args numberOfHellosAndGoodByes \u003d std::make_format_args(1000, 1);\n  std::cout \u0026lt;\u0026lt; vformat(\"Hello {0} times, and goodbyes {1} times :(\\n\", numberOfHellosAndGoodByes);\n}\n\nvoid helloAndGoodByeExpectation() {\n  // Noncompliant, error-prone but doesn\u0027t dangle due to built-in types\n  auto numberOfHellosAndGoodByes \u003d std::make_format_args(1000, 1000000);\n  std::cout \u0026lt;\u0026lt; vformat(\"Hello {0} times, and goodbyes {1} times :)\\n\", numberOfHellosAndGoodByes);\n}\n\nstd::string getHellosForRemote() {\n  return \"zero\";\n}\n\nstd::string getGoodbyesForRemote() {\n  return \"zero\";\n}\nvoid helloAndGoodByeForRemote() {\n  // Noncompliant, dangles; getHellosForRemote() is an rvalue of non-built-in type std::string\n  auto numberOfHelloAndGoodBye \u003d std::make_format_args(getHellosForRemote(), getGoodbyesForRemote());\n  std::cout \u0026lt;\u0026lt; vformat(\"Hello {0} times, and goodbyes {1} times :|\\n\", numberOfHelloAndGoodBye);\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid helloAndGoodByeReality() {\n  std::cout \u0026lt;\u0026lt; vformat(\"Hello {0} times, and goodbyes {1} times :(\\n\",\n    std::make_format_args(1000, 1));  // Compliant\n}\n\nvoid helloAndGoodByeExpectation() {\n  std::cout \u0026lt;\u0026lt; vformat(\"Hello {0} times, and goodbyes {1} times :)\\n\",\n    std::make_format_args(1000, 1000000));  // Compliant\n}\n\nstd::string getHellosForRemote() {\n  return \"zero\";\n}\n\nstd::string getGoodbyesForRemote() {\n  return \"zero\";\n}\nvoid helloAndGoodByeForRemote() {\n  std::cout \u0026lt;\u0026lt;\n    vformat(\"Hello {0} times, and goodbyes {1} times :|\\n\",\n      std::make_format_args(getHellosForRemote(), getGoodbyesForRemote())); // Compliant\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "since-c++20"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5280",
    "name": "\"mktemp\" family of functions templates should have at least six trailing \"X\"s",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003cp\u003eThe \u003ccode\u003etemplate\u003c/code\u003e parameter for creating temporary files or directories must contain at least six trailing \"X\"s to ensure uniqueness.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe standard C library provides several functions to create temporary files and directories. These functions include \u003ccode\u003emktemp\u003c/code\u003e,\n\u003ccode\u003emkstemp\u003c/code\u003e, \u003ccode\u003emkstemps\u003c/code\u003e and \u003ccode\u003emkdtemp\u003c/code\u003e, and they accept as a parameter a \u003ccode\u003etemplate\u003c/code\u003e that defines the path\nwhere the file (or directory) should be created. The filename part of the \u003ccode\u003etemplate\u003c/code\u003e must contain at least six trailing \"X\"s to ensure the\nuniqueness of the filename, since these \"X\"\u0027s are replaced with a string that makes the filename unique.\u003c/p\u003e\n\u003cp\u003eNote that the \u003ccode\u003etemplate\u003c/code\u003e parameter will be modified and therefore, it may not be a string constant, but should be declared as a\ncharacter array, instead.\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n\nint create_tmp_file() {\n  char tmp_name[] \u003d \"example_XXXXX\"; // `template` parameter only contains five \"X\"s\n  printf(\"raw template: %s\\n\", tmp_name);\n  int fd \u003d mkstemp(tmp_name); // Noncompliant: `mkstemp` will fail due to an invalid template parameter.\n  if (fd \u003d\u003d -1) {\n    perror(\"mkstemp failed\");\n    return 1;\n  }\n  printf(\"unique name: %s\\n\", tmp_name);\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch2\u003eWhat is the potential impact?\u003c/h2\u003e\n\u003cp\u003eIf the last six characters of the \u003ccode\u003etemplate\u003c/code\u003e parameter are different from \"XXXXXX\", \u003ccode\u003emktemp\u003c/code\u003e, \u003ccode\u003emkstemp\u003c/code\u003e,\n\u003ccode\u003emkstemps\u003c/code\u003e and \u003ccode\u003emkdtemp\u003c/code\u003e will fail to create the desired unique temporary file or directory.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eEnsure that the \u003ccode\u003etemplate\u003c/code\u003e parameter ends on at least six \"X\"\u0027s, i.e., \"XXXXXX\".\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n\nint create_tmp_file() {\n  char tmp_name[] \u003d \"/tmp/example_XXXXX\";\n  int fd \u003d mkstemp(tmp_name); // Noncompliant: `mkstemp` will fail due to an invalid template parameter.\n  if (fd \u003d\u003d -1) {\n    perror(\"mkstemp failed\");\n    return 1;\n  }\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n\nint create_tmp_file() {\n  char tmp_name[] \u003d \"/tmp/example_XXXXXX\";\n  int fd \u003d mkstemp(tmp_name); // Compliant: template parameter ends on six \"X\"s.\n  if (fd \u003d\u003d -1) {\n    perror(\"mkstemp failed\");\n    return 1;\n  }\n  printf(\"unique name: %s\\n\", tmp_name); // May print \"/tmp/example_hNjl9G\"\n  return 0;\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eThe \u003ccode\u003etemplate\u003c/code\u003e parameter for creating temporary files or directories must contain at least six trailing \"X\"s to ensure uniqueness.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe standard C library provides several functions to create temporary files and directories. These functions include \u003ccode\u003emktemp\u003c/code\u003e,\n\u003ccode\u003emkstemp\u003c/code\u003e, \u003ccode\u003emkstemps\u003c/code\u003e and \u003ccode\u003emkdtemp\u003c/code\u003e, and they accept as a parameter a \u003ccode\u003etemplate\u003c/code\u003e that defines the path\nwhere the file (or directory) should be created. The filename part of the \u003ccode\u003etemplate\u003c/code\u003e must contain at least six trailing \"X\"s to ensure the\nuniqueness of the filename, since these \"X\"\u0027s are replaced with a string that makes the filename unique.\u003c/p\u003e\n\u003cp\u003eNote that the \u003ccode\u003etemplate\u003c/code\u003e parameter will be modified and therefore, it may not be a string constant, but should be declared as a\ncharacter array, instead.\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n\nint create_tmp_file() {\n  char tmp_name[] \u003d \"example_XXXXX\"; // `template` parameter only contains five \"X\"s\n  printf(\"raw template: %s\\n\", tmp_name);\n  int fd \u003d mkstemp(tmp_name); // Noncompliant: `mkstemp` will fail due to an invalid template parameter.\n  if (fd \u003d\u003d -1) {\n    perror(\"mkstemp failed\");\n    return 1;\n  }\n  printf(\"unique name: %s\\n\", tmp_name);\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch2\u003eWhat is the potential impact?\u003c/h2\u003e\n\u003cp\u003eIf the last six characters of the \u003ccode\u003etemplate\u003c/code\u003e parameter are different from \"XXXXXX\", \u003ccode\u003emktemp\u003c/code\u003e, \u003ccode\u003emkstemp\u003c/code\u003e,\n\u003ccode\u003emkstemps\u003c/code\u003e and \u003ccode\u003emkdtemp\u003c/code\u003e will fail to create the desired unique temporary file or directory.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eEnsure that the \u003ccode\u003etemplate\u003c/code\u003e parameter ends on at least six \"X\"\u0027s, i.e., \"XXXXXX\".\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n\nint create_tmp_file() {\n  char tmp_name[] \u003d \"/tmp/example_XXXXX\";\n  int fd \u003d mkstemp(tmp_name); // Noncompliant: `mkstemp` will fail due to an invalid template parameter.\n  if (fd \u003d\u003d -1) {\n    perror(\"mkstemp failed\");\n    return 1;\n  }\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n\nint create_tmp_file() {\n  char tmp_name[] \u003d \"/tmp/example_XXXXXX\";\n  int fd \u003d mkstemp(tmp_name); // Compliant: template parameter ends on six \"X\"s.\n  if (fd \u003d\u003d -1) {\n    perror(\"mkstemp failed\");\n    return 1;\n  }\n  printf(\"unique name: %s\\n\", tmp_name); // May print \"/tmp/example_hNjl9G\"\n  return 0;\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "suspicious",
      "symbolic-execution"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6490",
    "name": "Arguments corresponding to width and precision formatting options should be integers",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003estd::format\u003c/code\u003e function and related formatting functions allow you to control how to display a value as text, including its width and\nprecision.\u003c/p\u003e\n\u003cp\u003eFor example, you can convert the number \u003ccode\u003e3.14159\u003c/code\u003e to a string with a minimum width of \u003ccode\u003e10\u003c/code\u003e and a precision of \u003ccode\u003e2\u003c/code\u003e\nusing:\u003c/p\u003e\n\u003cpre\u003e\nstd::format(\"{:_\u0026gt;10.2f}\", 3.14159)\n\u003c/pre\u003e\n\u003cp\u003eThe format string uses:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003e_\u003c/code\u003e as the padding character \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003e\u0026gt;\u003c/code\u003e to align the value to the right \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003e10\u003c/code\u003e to specify the width \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003e.2\u003c/code\u003e to specify the precision \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003ef\u003c/code\u003e to use the fixed decimal notation \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe resulting string is \u003ccode\u003e\"______3.14\"\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eFurthermore, there are two ways to specify the width and the precision:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Statically, by embedding the desired values in the format specification, as in the previous example. \u003c/li\u003e\n  \u003cli\u003e Dynamically, by referring to complementary function arguments using \u003ccode\u003e{}\u003c/code\u003e or \u003ccode\u003e{arg-id}\u003c/code\u003e. The previous example becomes: \u003cpre\u003e\nstd::format(\"{0:_\u0026gt;{1}.{2}f}\", 3.14159, 10, 2)\n\u003c/pre\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOn the one hand, using static values is safe and predictable but not very flexible. On the other hand, using dynamic values can result in runtime\nexceptions and unexpected program termination.\u003c/p\u003e\n\u003cp\u003eSpecifically, a \u003ccode\u003estd::format_error\u003c/code\u003e exception is thrown when a dynamic value for the width or the precision specifiers is either\nnegative or not a built-in integer.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eThe rule raises an issue when the width or precision specifier is not an integer.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003cpre\u003e\nvoid example(std::string_view s, double d, int maxLen) {\n  // Noncompliant: the width specifier is a floating point value.\n  std::format(\"{0:*^{1}}\", s, 5.0);\n  // Compliant: the integer 5 is used instead.\n  std::format(\"{0:*^{1}}\", s, 5);\n\n  // Noncompliant: the precision specifier is a string literal.\n  std::format(\"{0:*^10.{1}}\", d, \"3\");\n  // Compliant: the value 3 is inlined.\n  std::format(\"{0:*^10.3}\", d);\n\n  // Noncompliant: the width and precision specifiers are not integers.\n  std::format(\"{0:*^{1}.{2}}\", d, \"12\", 4.0);\n  // Compliant: appropriate integer values are used.\n  std::format(\"{0:*^{1}.{2}}\", d, 12, 4);\n\n  // Noncompliant: \"d\" is interpreted as the width specifier.\n  std::format(\"{:*^{}.{}} {}\", s, d, maxLen, maxLen + 2);\n  // Compliant: use explicit argument index.\n  std::format(\"{0:*^{2}.{3}} {1}\", s, d, maxLen, maxLen + 2);\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/utility/format/format\"\u003e\u003ccode\u003estd::format\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/utility/format/formatter#Standard_format_specification\"\u003estandard format\n  specification\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe \u003ccode\u003estd::format\u003c/code\u003e function and related formatting functions allow you to control how to display a value as text, including its width and\nprecision.\u003c/p\u003e\n\u003cp\u003eFor example, you can convert the number \u003ccode\u003e3.14159\u003c/code\u003e to a string with a minimum width of \u003ccode\u003e10\u003c/code\u003e and a precision of \u003ccode\u003e2\u003c/code\u003e\nusing:\u003c/p\u003e\n\u003cpre\u003e\nstd::format(\"{:_\u0026gt;10.2f}\", 3.14159)\n\u003c/pre\u003e\n\u003cp\u003eThe format string uses:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003e_\u003c/code\u003e as the padding character \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003e\u0026gt;\u003c/code\u003e to align the value to the right \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003e10\u003c/code\u003e to specify the width \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003e.2\u003c/code\u003e to specify the precision \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003ef\u003c/code\u003e to use the fixed decimal notation \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe resulting string is \u003ccode\u003e\"______3.14\"\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eFurthermore, there are two ways to specify the width and the precision:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Statically, by embedding the desired values in the format specification, as in the previous example. \u003c/li\u003e\n  \u003cli\u003e Dynamically, by referring to complementary function arguments using \u003ccode\u003e{}\u003c/code\u003e or \u003ccode\u003e{arg-id}\u003c/code\u003e. The previous example becomes: \u003cpre\u003e\nstd::format(\"{0:_\u0026gt;{1}.{2}f}\", 3.14159, 10, 2)\n\u003c/pre\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOn the one hand, using static values is safe and predictable but not very flexible. On the other hand, using dynamic values can result in runtime\nexceptions and unexpected program termination.\u003c/p\u003e\n\u003cp\u003eSpecifically, a \u003ccode\u003estd::format_error\u003c/code\u003e exception is thrown when a dynamic value for the width or the precision specifiers is either\nnegative or not a built-in integer.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eThe rule raises an issue when the width or precision specifier is not an integer.\u003c/p\u003e\n\n\u003cpre\u003e\nvoid example(std::string_view s, double d, int maxLen) {\n  // Noncompliant: the width specifier is a floating point value.\n  std::format(\"{0:*^{1}}\", s, 5.0);\n  // Compliant: the integer 5 is used instead.\n  std::format(\"{0:*^{1}}\", s, 5);\n\n  // Noncompliant: the precision specifier is a string literal.\n  std::format(\"{0:*^10.{1}}\", d, \"3\");\n  // Compliant: the value 3 is inlined.\n  std::format(\"{0:*^10.3}\", d);\n\n  // Noncompliant: the width and precision specifiers are not integers.\n  std::format(\"{0:*^{1}.{2}}\", d, \"12\", 4.0);\n  // Compliant: appropriate integer values are used.\n  std::format(\"{0:*^{1}.{2}}\", d, 12, 4);\n\n  // Noncompliant: \"d\" is interpreted as the width specifier.\n  std::format(\"{:*^{}.{}} {}\", s, d, maxLen, maxLen + 2);\n  // Compliant: use explicit argument index.\n  std::format(\"{0:*^{2}.{3}} {1}\", s, d, maxLen, maxLen + 2);\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/utility/format/format\"\u003e\u003ccode\u003estd::format\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/utility/format/formatter#Standard_format_specification\"\u003estandard format\n  specification\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "since-c++20"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5281",
    "name": "Argument of \"printf\" should be a format string",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eIt is a security vulnerability to call \u003ccode\u003eprintf\u003c/code\u003e with a unique string argument which is not a string literal. Indeed, if this argument\ncomes from a user input, this user can :\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e make the program crash, by executing code equivalent to: \u003ccode\u003eprintf(\"%s%s%s%s%s%s%s%s\")\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e view the stack or a memory at any location, by executing code equivalent to: \u003ccode\u003eprintf(\"%08x %08x %08x %08x %08x\\n\")\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid f(char* userInput) {\n  printf(userInput); // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid f(char* userInput) {\n  printf(\"%s\", userInput); // Compliant\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/www-community/attacks/Format_string_attack\"\u003eOwasp: format string attack\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eIt is a security vulnerability to call \u003ccode\u003eprintf\u003c/code\u003e with a unique string argument which is not a string literal. Indeed, if this argument\ncomes from a user input, this user can :\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e make the program crash, by executing code equivalent to: \u003ccode\u003eprintf(\"%s%s%s%s%s%s%s%s\")\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e view the stack or a memory at any location, by executing code equivalent to: \u003ccode\u003eprintf(\"%08x %08x %08x %08x %08x\\n\")\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid f(char* userInput) {\n  printf(userInput); // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid f(char* userInput) {\n  printf(\"%s\", userInput); // Compliant\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/www-community/attacks/Format_string_attack\"\u003eOwasp: format string attack\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "bad-practice"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6491",
    "name": "\"std::format\" numeric types should be 0-padded using the numerical padding and not the character padding",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003estd::format\u003c/code\u003e and the related formatting functions provide two different options to pad numerical values up to a specific width:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Custom character padding: this option can align text to the left, center, or right using any character. \u003cbr\u003e For example,\n  \u003ccode\u003estd::format(\"{:*\u0026gt;5}\", num)\u003c/code\u003e aligns \u003ccode\u003enum\u003c/code\u003e to the right (\u003ccode\u003e\u0026gt;\u003c/code\u003e) by inserting \u003ccode\u003e*\u003c/code\u003e characters until it\n  reaches a width of 5. \u003c/li\u003e\n  \u003cli\u003e Numeric padding with \u003ccode\u003e0\u003c/code\u003e: this option is available for most arithmetic types and is enabled by adding \u003ccode\u003e0\u003c/code\u003e before the\n  width specifier.\u003cbr\u003e For example, \u003ccode\u003estd::format(\"{:05}\", num)\u003c/code\u003e adds enough \u003ccode\u003e0\u003c/code\u003e before \u003ccode\u003enum\u003c/code\u003e to align it to the right\n  and reach a width of 5. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003e0\u003c/code\u003e can also be used as a custom character padding, but this syntax is confusing and may produce unexpected results when aligning\nnegative values to the right:\u003c/p\u003e\n\u003cpre\u003e\n// Noncompliant: character padding results in \"00-10\"\nstd::format(\"{:0\u0026gt;5}\", -10) // \"0\" is a custom character padding here.\n\n// Compliant: numeric padding results in \"-0010\"\nstd::format(\"{:05}\", -10) // The \"\u0026gt;\" was removed; \"0\" now means numeric padding.\n\u003c/pre\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eThis rule raises an issue when a format specification uses \u003ccode\u003e0\u003c/code\u003e as a custom padding character to right-align a value instead of using the\nnumeric padding.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003cp\u003eThis example shows how custom character padding and numeric padding differ when formatting a floating-point variable \u003ccode\u003enum\u003c/code\u003e. It uses a\nsign specifier (\u003ccode\u003e+\u003c/code\u003e) and the alternative form (\u003ccode\u003e#\u003c/code\u003e).\u003c/p\u003e\n\u003cp\u003eAs a side note, numeric padding also works with other specifiers to change the type representation, set the precision, apply locale-specific\nformatting, etc.\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nauto stringify(float num) {\n  return std::format(\"{:0\u0026gt;+#5}\", num); // Noncompliant: custom character padding with \"0\"\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eA compliant solution is to remove the alignment specifier (\u003ccode\u003e\u0026gt;\u003c/code\u003e) and move the \u003ccode\u003e0\u003c/code\u003e right before the width specifier\n(\u003ccode\u003e5\u003c/code\u003e) to change its semantics:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nauto stringify(float num) {\n  return std::format(\"{:+#05}\", num); // Numeric padding.\n}\n\u003c/pre\u003e\n\u003cp\u003eHere are examples of outputs for the two code snippets:\u003c/p\u003e\n\u003ctable\u003e\n  \u003ccolgroup\u003e\n    \u003ccol style\u003d\"width: 33.3333%;\"\u003e\n    \u003ccol style\u003d\"width: 33.3333%;\"\u003e\n    \u003ccol style\u003d\"width: 33.3334%;\"\u003e\n  \u003c/colgroup\u003e\n  \u003cthead\u003e\n    \u003ctr\u003e\n      \u003cth\u003eValue of \u003ccode\u003enum\u003c/code\u003e\u003c/th\u003e\n      \u003cth\u003eNoncompliant output\u003c/th\u003e\n      \u003cth\u003eCompliant output\u003c/th\u003e\n    \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003e\u003ccode\u003e10\u003c/code\u003e\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003e\u003ccode\u003e\"0+10.\"\u003c/code\u003e\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003e\u003ccode\u003e\"+010.\"\u003c/code\u003e\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003e\u003ccode\u003e-10\u003c/code\u003e\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003e\u003ccode\u003e\"0-10.\"\u003c/code\u003e\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003e\u003ccode\u003e\"-010.\"\u003c/code\u003e\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003e\u003ccode\u003eNAN\u003c/code\u003e\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003e\u003ccode\u003e\"0+nan\"\u003c/code\u003e\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003e\u003ccode\u003e\" +nan\"\u003c/code\u003e\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003e\u003ccode\u003e-INFINITY\u003c/code\u003e\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003e\u003ccode\u003e\"0-inf\"\u003c/code\u003e\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003e\u003ccode\u003e\" -inf\"\u003c/code\u003e\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/utility/format/format\"\u003e\u003ccode\u003estd::format\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/utility/format/formatter#Standard_format_specification\"\u003estandard format\n  specification\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003e{rule:cpp:S6483} detects incompatible use of numeric and character padding specifiers.\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003ccode\u003estd::format\u003c/code\u003e and the related formatting functions provide two different options to pad numerical values up to a specific width:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Custom character padding: this option can align text to the left, center, or right using any character. \u003cbr\u003e For example,\n  \u003ccode\u003estd::format(\"{:*\u0026gt;5}\", num)\u003c/code\u003e aligns \u003ccode\u003enum\u003c/code\u003e to the right (\u003ccode\u003e\u0026gt;\u003c/code\u003e) by inserting \u003ccode\u003e*\u003c/code\u003e characters until it\n  reaches a width of 5. \u003c/li\u003e\n  \u003cli\u003e Numeric padding with \u003ccode\u003e0\u003c/code\u003e: this option is available for most arithmetic types and is enabled by adding \u003ccode\u003e0\u003c/code\u003e before the\n  width specifier.\u003cbr\u003e For example, \u003ccode\u003estd::format(\"{:05}\", num)\u003c/code\u003e adds enough \u003ccode\u003e0\u003c/code\u003e before \u003ccode\u003enum\u003c/code\u003e to align it to the right\n  and reach a width of 5. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003e0\u003c/code\u003e can also be used as a custom character padding, but this syntax is confusing and may produce unexpected results when aligning\nnegative values to the right:\u003c/p\u003e\n\u003cpre\u003e\n// Noncompliant: character padding results in \"00-10\"\nstd::format(\"{:0\u0026gt;5}\", -10) // \"0\" is a custom character padding here.\n\n// Compliant: numeric padding results in \"-0010\"\nstd::format(\"{:05}\", -10) // The \"\u0026gt;\" was removed; \"0\" now means numeric padding.\n\u003c/pre\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eThis rule raises an issue when a format specification uses \u003ccode\u003e0\u003c/code\u003e as a custom padding character to right-align a value instead of using the\nnumeric padding.\u003c/p\u003e\n\n\u003cp\u003eThis example shows how custom character padding and numeric padding differ when formatting a floating-point variable \u003ccode\u003enum\u003c/code\u003e. It uses a\nsign specifier (\u003ccode\u003e+\u003c/code\u003e) and the alternative form (\u003ccode\u003e#\u003c/code\u003e).\u003c/p\u003e\n\u003cp\u003eAs a side note, numeric padding also works with other specifiers to change the type representation, set the precision, apply locale-specific\nformatting, etc.\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nauto stringify(float num) {\n  return std::format(\"{:0\u0026gt;+#5}\", num); // Noncompliant: custom character padding with \"0\"\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eA compliant solution is to remove the alignment specifier (\u003ccode\u003e\u0026gt;\u003c/code\u003e) and move the \u003ccode\u003e0\u003c/code\u003e right before the width specifier\n(\u003ccode\u003e5\u003c/code\u003e) to change its semantics:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nauto stringify(float num) {\n  return std::format(\"{:+#05}\", num); // Numeric padding.\n}\n\u003c/pre\u003e\n\u003cp\u003eHere are examples of outputs for the two code snippets:\u003c/p\u003e\n\u003ctable\u003e\n  \u003ccolgroup\u003e\n    \u003ccol style\u003d\"width: 33.3333%;\"\u003e\n    \u003ccol style\u003d\"width: 33.3333%;\"\u003e\n    \u003ccol style\u003d\"width: 33.3334%;\"\u003e\n  \u003c/colgroup\u003e\n  \u003cthead\u003e\n    \u003ctr\u003e\n      \u003cth\u003eValue of \u003ccode\u003enum\u003c/code\u003e\u003c/th\u003e\n      \u003cth\u003eNoncompliant output\u003c/th\u003e\n      \u003cth\u003eCompliant output\u003c/th\u003e\n    \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003e\u003ccode\u003e10\u003c/code\u003e\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003e\u003ccode\u003e\"0+10.\"\u003c/code\u003e\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003e\u003ccode\u003e\"+010.\"\u003c/code\u003e\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003e\u003ccode\u003e-10\u003c/code\u003e\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003e\u003ccode\u003e\"0-10.\"\u003c/code\u003e\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003e\u003ccode\u003e\"-010.\"\u003c/code\u003e\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003e\u003ccode\u003eNAN\u003c/code\u003e\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003e\u003ccode\u003e\"0+nan\"\u003c/code\u003e\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003e\u003ccode\u003e\" +nan\"\u003c/code\u003e\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003e\u003ccode\u003e-INFINITY\u003c/code\u003e\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003e\u003ccode\u003e\"0-inf\"\u003c/code\u003e\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003e\u003ccode\u003e\" -inf\"\u003c/code\u003e\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/utility/format/format\"\u003e\u003ccode\u003estd::format\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/utility/format/formatter#Standard_format_specification\"\u003estandard format\n  specification\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003e{rule:cpp:S6483} detects incompatible use of numeric and character padding specifiers.\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "since-c++20",
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6012",
    "name": "Redundant class template arguments should not be used",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eSince C++17, class template arguments can be automatically deduced by the compiler, either by looking at the arguments of the class constructors or\nby using an explicitly defined deduction guide.\u003c/p\u003e\n\u003cp\u003eUsing the class template argument deduction allows to:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Avoid verbose specification of all template parameter types for a class template. \u003c/li\u003e\n  \u003cli\u003e Avoid writing helper function that only serves the purpose of deducing the type of a class from its arguments. For example,\n  \u003ccode\u003estd::make_pair\u003c/code\u003e. \u003c/li\u003e\n  \u003cli\u003e Be able to instantiate a class template with hard-to-spell or unutterable names, such as the closure type of a lambda. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis rule raises an issue when explicit class template arguments that can be automatically deduced are specified.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid f() {\n    std::vector\u0026lt;int\u0026gt; v1 {1, 2, 3}; // Noncompliant, int could have been deduced\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nusing namespace std::literals;\nvoid f() {\n    std::vector v1 {1, 2, 3}; // Compliant, int could be deduced\n    std::vector\u0026lt;std::string\u0026gt; v2 {\"a\", \"b\", \"c\"}; // Compliant, automatic deduction would create a vector\u0026lt;char const *\u0026gt;\n    std::vector v3 {\"a\"s, \"b\"s, \"c\"s}; // Still compliant, another option\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eSince C++17, class template arguments can be automatically deduced by the compiler, either by looking at the arguments of the class constructors or\nby using an explicitly defined deduction guide.\u003c/p\u003e\n\u003cp\u003eUsing the class template argument deduction allows to:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Avoid verbose specification of all template parameter types for a class template. \u003c/li\u003e\n  \u003cli\u003e Avoid writing helper function that only serves the purpose of deducing the type of a class from its arguments. For example,\n  \u003ccode\u003estd::make_pair\u003c/code\u003e. \u003c/li\u003e\n  \u003cli\u003e Be able to instantiate a class template with hard-to-spell or unutterable names, such as the closure type of a lambda. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis rule raises an issue when explicit class template arguments that can be automatically deduced are specified.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid f() {\n    std::vector\u0026lt;int\u0026gt; v1 {1, 2, 3}; // Noncompliant, int could have been deduced\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nusing namespace std::literals;\nvoid f() {\n    std::vector v1 {1, 2, 3}; // Compliant, int could be deduced\n    std::vector\u0026lt;std::string\u0026gt; v2 {\"a\", \"b\", \"c\"}; // Compliant, automatic deduction would create a vector\u0026lt;char const *\u0026gt;\n    std::vector v3 {\"a\"s, \"b\"s, \"c\"s}; // Still compliant, another option\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "clumsy",
      "since-c++17"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6013",
    "name": "\"static_assert\" with no message should be used over \"static_assert\" with empty or redundant message",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eC++11 introduced \u003ccode\u003estatic_assert(expr, message)\u003c/code\u003e to check that the compile-time constant expression \u003ccode\u003eexpr\u003c/code\u003e is true.\u003c/p\u003e\n\u003cp\u003eC++17 has made the second argument \u003ccode\u003emessage\u003c/code\u003e optional. This rule flags occurrences of \u003ccode\u003estd::static_assert\u003c/code\u003e where the second\nargument message is empty or a substring of \u003ccode\u003eexpr\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\ntemplate \u0026lt;class T\u0026gt;\nT f(T i) {\n  static_assert(std::is_integral\u0026lt;T\u0026gt;::value, \"\"); // Noncompliant: remove the empty string second argument.\n  static_assert(std::is_integral\u0026lt;T\u0026gt;::value, \"std::is_integral\"); // Noncompliant: remove the redundant second argument.\n  // ...\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\ntemplate \u0026lt;class T\u0026gt;\nT f(T i) {\n  static_assert(std::is_integral\u0026lt;T\u0026gt;::value); // Compliant\n  static_assert(std::is_integral\u0026lt;T\u0026gt;::value, \"Integral required\"); // Compliant\n  // ...\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eC++11 introduced \u003ccode\u003estatic_assert(expr, message)\u003c/code\u003e to check that the compile-time constant expression \u003ccode\u003eexpr\u003c/code\u003e is true.\u003c/p\u003e\n\u003cp\u003eC++17 has made the second argument \u003ccode\u003emessage\u003c/code\u003e optional. This rule flags occurrences of \u003ccode\u003estd::static_assert\u003c/code\u003e where the second\nargument message is empty or a substring of \u003ccode\u003eexpr\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\ntemplate \u0026lt;class T\u0026gt;\nT f(T i) {\n  static_assert(std::is_integral\u0026lt;T\u0026gt;::value, \"\"); // Noncompliant: remove the empty string second argument.\n  static_assert(std::is_integral\u0026lt;T\u0026gt;::value, \"std::is_integral\"); // Noncompliant: remove the redundant second argument.\n  // ...\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\ntemplate \u0026lt;class T\u0026gt;\nT f(T i) {\n  static_assert(std::is_integral\u0026lt;T\u0026gt;::value); // Compliant\n  static_assert(std::is_integral\u0026lt;T\u0026gt;::value, \"Integral required\"); // Compliant\n  // ...\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "clumsy",
      "since-c++17"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5042",
    "name": "Expanding archive files without controlling resource consumption is security-sensitive",
    "defaultSeverity": "CRITICAL",
    "type": "SECURITY_HOTSPOT",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "SECURITY": "HIGH"
    },
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eSuccessful Zip Bomb attacks occur when an application expands untrusted archive files without controlling the size of the expanded data, which can\nlead to denial of service. A Zip bomb is usually a malicious archive file of a few kilobytes of compressed data but turned into gigabytes of\nuncompressed data. To achieve this extreme \u003ca href\u003d\"https://en.wikipedia.org/wiki/Data_compression_ratio\"\u003ecompression ratio\u003c/a\u003e, attackers will\ncompress irrelevant data (eg: a long string of repeated bytes).\u003c/p\u003e"
      },
      {
        "key": "assess_the_problem",
        "htmlContent": "\u003ch2\u003eAsk Yourself Whether\u003c/h2\u003e\n\u003cp\u003eArchives to expand are untrusted and:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e There is no validation of the number of entries in the archive. \u003c/li\u003e\n  \u003cli\u003e There is no validation of the total size of the uncompressed data. \u003c/li\u003e\n  \u003cli\u003e There is no validation of the ratio between the compressed and uncompressed archive entry. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere is a risk if you answered yes to any of those questions.\u003c/p\u003e\n\u003ch2\u003eSensitive Code Example\u003c/h2\u003e\n\u003cpre\u003e\n#include \u0026lt;archive.h\u0026gt;\n#include \u0026lt;archive_entry.h\u0026gt;\n// ...\n\nvoid f(const char *filename, int flags) {\n  struct archive_entry *entry;\n  struct archive *a \u003d archive_read_new();\n  struct archive *ext \u003d archive_write_disk_new();\n  archive_write_disk_set_options(ext, flags);\n  archive_read_support_format_tar(a);\n\n  if ((archive_read_open_filename(a, filename, 10240))) {\n    return;\n  }\n\n  for (;;) {\n    int r \u003d archive_read_next_header(a, \u0026amp;entry);\n    if (r \u003d\u003d ARCHIVE_EOF) {\n      break;\n    }\n    if (r !\u003d ARCHIVE_OK) {\n      return;\n    }\n  }\n  archive_read_close(a);\n  archive_read_free(a);\n\n  archive_write_close(ext);\n  archive_write_free(ext);\n}\n\u003c/pre\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003ch2\u003eRecommended Secure Coding Practices\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e Define and control the threshold for maximum total size of the uncompressed data. \u003c/li\u003e\n  \u003cli\u003e Count the number of file entries extracted from the archive and abort the extraction if their number is greater than a predefined threshold, in\n  particular it’s not recommended to recursively expand archives (an entry of an archive could be also an archive). \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eCompliant Solution\u003c/h2\u003e\n\u003cpre\u003e\n#include \u0026lt;archive.h\u0026gt;\n#include \u0026lt;archive_entry.h\u0026gt;\n// ...\n\nint f(const char *filename, int flags) {\n  const int max_number_of_extraced_entries \u003d 1000;\n  const int64_t max_file_size \u003d 1000000000; // 1 GB\n\n  int number_of_extraced_entries \u003d 0;\n  int64_t total_file_size \u003d 0;\n\n  struct archive_entry *entry;\n  struct archive *a \u003d archive_read_new();\n  struct archive *ext \u003d archive_write_disk_new();\n  archive_write_disk_set_options(ext, flags);\n  archive_read_support_format_tar(a);\n  int status \u003d 0;\n\n  if ((archive_read_open_filename(a, filename, 10240))) {\n    return -1;\n  }\n\n  for (;;) {\n    number_of_extraced_entries++;\n    if (number_of_extraced_entries \u0026gt; max_number_of_extraced_entries) {\n      status \u003d 1;\n      break;\n    }\n\n    int r \u003d archive_read_next_header(a, \u0026amp;entry);\n    if (r \u003d\u003d ARCHIVE_EOF) {\n      break;\n    }\n    if (r !\u003d ARCHIVE_OK) {\n      status \u003d -1;\n      break;\n    }\n\n    int file_size \u003d archive_entry_size(entry);\n    total_file_size +\u003d file_size;\n    if (total_file_size \u0026gt; max_file_size) {\n      status \u003d 1;\n      break;\n    }\n  }\n  archive_read_close(a);\n  archive_read_free(a);\n\n  archive_write_close(ext);\n  archive_write_free(ext);\n\n  return status;\n}\n\u003c/pre\u003e\n\u003ch2\u003eSee\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/Top10/A01_2021-Broken_Access_Control/\"\u003eOWASP Top 10 2021 Category A1\u003c/a\u003e - Broken Access Control \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/Top10/A05_2021-Security_Misconfiguration/\"\u003eOWASP Top 10 2021 Category A5\u003c/a\u003e - Security Misconfiguration \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A6-Security_Misconfiguration\"\u003eOWASP Top 10 2017 Category A6\u003c/a\u003e -\n  Security Misconfiguration \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/409\"\u003eMITRE, CWE-409\u003c/a\u003e - Improper Handling of Highly Compressed Data (Data Amplification)\n  \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://www.bamsoftware.com/hacks/zipbomb/\"\u003ebamsoftware.com\u003c/a\u003e - A better Zip Bomb \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cert",
      "cwe"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": [],
    "vulnerabilityProbability": "LOW"
  },
  {
    "key": "cpp:S6010",
    "name": "\"std::filesystem::path\" should be used to represent a file path",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eIntroduced in C++17, the class \u003ccode\u003estd::filesystem::path\u003c/code\u003e can store a file path. Compared to a regular string, it offers several\nadvantages:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Having a dedicated type makes the intention clear \u003c/li\u003e\n  \u003cli\u003e This class stores the path with an encoding that is appropriate to the OS where the program runs \u003c/li\u003e\n  \u003cli\u003e It provides several functions that make it more convenient to manipulate than a \u003ccode\u003estring\u003c/code\u003e (for instance, \u003ccode\u003eoperator/\u003c/code\u003e for\n  concatenations) \u003c/li\u003e\n  \u003cli\u003e It provides a normalized way to specify the path, easing the portability of the code (on Windows and Linux, the native way is equivalent to the\n  normalized way, which reduces overhead). \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis rule raises an issue when the same \u003ccode\u003estring\u003c/code\u003e is converted several times to a \u003ccode\u003epath\u003c/code\u003e\u0026nbsp;because it indicates that a\nsingle path object could have been used in all occurrences. It can also be more efficient since conversion from \u003ccode\u003estring\u003c/code\u003e\nto\u0026nbsp;\u003ccode\u003epath\u003c/code\u003e may require a change of encoding and memory allocation.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nstd::string getUserData();\nnamespace fs \u003d std::filesystem;\nvoid f() {\n  std::string const filePath \u003d getUserData();\n  if (fs::exists(filePath)) {\n    logTime(fs::last_write_time(filePath)); // Noncompliant\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nstd::string getUserData();\nnamespace fs \u003d std::filesystem;\nvoid f() {\n  fs::path const filePath \u003d getUserData();\n  if (fs::exists(filePath) {\n    logTime(fs::last_write_time(filePath)); // Compliant\n  }\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/filesystem/path\"\u003estd::filesystem::path\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eIntroduced in C++17, the class \u003ccode\u003estd::filesystem::path\u003c/code\u003e can store a file path. Compared to a regular string, it offers several\nadvantages:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Having a dedicated type makes the intention clear \u003c/li\u003e\n  \u003cli\u003e This class stores the path with an encoding that is appropriate to the OS where the program runs \u003c/li\u003e\n  \u003cli\u003e It provides several functions that make it more convenient to manipulate than a \u003ccode\u003estring\u003c/code\u003e (for instance, \u003ccode\u003eoperator/\u003c/code\u003e for\n  concatenations) \u003c/li\u003e\n  \u003cli\u003e It provides a normalized way to specify the path, easing the portability of the code (on Windows and Linux, the native way is equivalent to the\n  normalized way, which reduces overhead). \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis rule raises an issue when the same \u003ccode\u003estring\u003c/code\u003e is converted several times to a \u003ccode\u003epath\u003c/code\u003e\u0026nbsp;because it indicates that a\nsingle path object could have been used in all occurrences. It can also be more efficient since conversion from \u003ccode\u003estring\u003c/code\u003e\nto\u0026nbsp;\u003ccode\u003epath\u003c/code\u003e may require a change of encoding and memory allocation.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nstd::string getUserData();\nnamespace fs \u003d std::filesystem;\nvoid f() {\n  std::string const filePath \u003d getUserData();\n  if (fs::exists(filePath)) {\n    logTime(fs::last_write_time(filePath)); // Noncompliant\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nstd::string getUserData();\nnamespace fs \u003d std::filesystem;\nvoid f() {\n  fs::path const filePath \u003d getUserData();\n  if (fs::exists(filePath) {\n    logTime(fs::last_write_time(filePath)); // Compliant\n  }\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/filesystem/path\"\u003estd::filesystem::path\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "clumsy",
      "performance",
      "since-c++17"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6494",
    "name": "C++ formatting functions should be used instead of C printf-like functions",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eIn contrast to C printf-like functions, the \u003ccode\u003estd::format\u003c/code\u003e family of formatting functions provides a safer and more robust interface for\nperforming text formatting.\u003c/p\u003e\n\u003cp\u003eFirstly, C++ formatting facilities perform validation of the format string against the type of the formatted argument. If the validation fails, it\nis reported as a compilation error for the calls of \u003ccode\u003estd::format\u003c/code\u003e and via exception for \u003ccode\u003estd::vformat\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eSecondly, the relation between the type and format specifier is more abstract. In particular, \u003ccode\u003e{:d}\u003c/code\u003e can be used to format any integer\ntype, regardless of its size and signedness. Similarly, \u003ccode\u003e{:f}\u003c/code\u003e works for any floating point type. Furthermore, \u003ccode\u003e{}\u003c/code\u003e can be used\nfor any type with default format spec, which makes it usable in the generic context.\u003c/p\u003e\n\u003cp\u003eFinally, the \u003ccode\u003estd::format\u003c/code\u003e API can be extended to support custom types with the dedicated format specification via\n\u003ccode\u003estd::formatter\u003c/code\u003e specializations.\u003c/p\u003e\n\u003cp\u003eThis rule raises issues for calls of the \u003ccode\u003esprintf\u003c/code\u003e and \u003ccode\u003esnprintf\u003c/code\u003e functions that can be replaced by the C++ formatting\nfunctions.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid printFunc(char* out, size_t n) {\n  sprintf(out, \"%u %s\", 10u, “text”); // Noncompliant\n  std::snprintf(out, n, \"%i %% %LG\", 10, 10.0L); // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid printFunc(char* out) {\n  std::format_to(out, “{:d} {:s}”, 10u, text); // Compliant\n  // or\n  std::format_to(out, “{} {}”, 10u, text); // Compliant\n\n  std::format_to_n(out, ”{:d} % {:G}”, 10, 10.0L); // Compliant\n  // or\n  std::format_to_n(out, ”{} % {:G}”, 10, 10.0L); // Compliant\n}\n\u003c/pre\u003e\n\u003cp\u003eOther printf-like functions are not concerned by this rule:\u003c/p\u003e\n\u003cpre\u003e\nvoid printFunc(FILE* f) {\n  printf(\"%i\", 10);  // Compliant, no direct remplacment\n  std::fprintf(f, \"%f\", 10.0);  // Compliant, no direct remplacment\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThe rule does not raise an issue if the format string passed to a printf-like function is computed dynamically instead of being spelled in the\nsource code:\u003c/p\u003e\n\u003cpre\u003e\nchar const* localizedFormatString(unsigned id);\n/* …. */\nsnprintf(buffer, localizedFormatString(123), 10, 20)\n\u003c/pre\u003e\n\u003cp\u003eWhile \u003ccode\u003estd::vformat\u003c/code\u003e may be used in such cases, it would require a change of the format string, which may not be actionable.\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eIn contrast to C printf-like functions, the \u003ccode\u003estd::format\u003c/code\u003e family of formatting functions provides a safer and more robust interface for\nperforming text formatting.\u003c/p\u003e\n\u003cp\u003eFirstly, C++ formatting facilities perform validation of the format string against the type of the formatted argument. If the validation fails, it\nis reported as a compilation error for the calls of \u003ccode\u003estd::format\u003c/code\u003e and via exception for \u003ccode\u003estd::vformat\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eSecondly, the relation between the type and format specifier is more abstract. In particular, \u003ccode\u003e{:d}\u003c/code\u003e can be used to format any integer\ntype, regardless of its size and signedness. Similarly, \u003ccode\u003e{:f}\u003c/code\u003e works for any floating point type. Furthermore, \u003ccode\u003e{}\u003c/code\u003e can be used\nfor any type with default format spec, which makes it usable in the generic context.\u003c/p\u003e\n\u003cp\u003eFinally, the \u003ccode\u003estd::format\u003c/code\u003e API can be extended to support custom types with the dedicated format specification via\n\u003ccode\u003estd::formatter\u003c/code\u003e specializations.\u003c/p\u003e\n\u003cp\u003eThis rule raises issues for calls of the \u003ccode\u003esprintf\u003c/code\u003e and \u003ccode\u003esnprintf\u003c/code\u003e functions that can be replaced by the C++ formatting\nfunctions.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid printFunc(char* out, size_t n) {\n  sprintf(out, \"%u %s\", 10u, “text”); // Noncompliant\n  std::snprintf(out, n, \"%i %% %LG\", 10, 10.0L); // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid printFunc(char* out) {\n  std::format_to(out, “{:d} {:s}”, 10u, text); // Compliant\n  // or\n  std::format_to(out, “{} {}”, 10u, text); // Compliant\n\n  std::format_to_n(out, ”{:d} % {:G}”, 10, 10.0L); // Compliant\n  // or\n  std::format_to_n(out, ”{} % {:G}”, 10, 10.0L); // Compliant\n}\n\u003c/pre\u003e\n\u003cp\u003eOther printf-like functions are not concerned by this rule:\u003c/p\u003e\n\u003cpre\u003e\nvoid printFunc(FILE* f) {\n  printf(\"%i\", 10);  // Compliant, no direct remplacment\n  std::fprintf(f, \"%f\", 10.0);  // Compliant, no direct remplacment\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThe rule does not raise an issue if the format string passed to a printf-like function is computed dynamically instead of being spelled in the\nsource code:\u003c/p\u003e\n\u003cpre\u003e\nchar const* localizedFormatString(unsigned id);\n/* …. */\nsnprintf(buffer, localizedFormatString(123), 10, 20)\n\u003c/pre\u003e\n\u003cp\u003eWhile \u003ccode\u003estd::vformat\u003c/code\u003e may be used in such cases, it would require a change of the format string, which may not be actionable.\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "bad-practice",
      "since-c++20"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6011",
    "name": "Objects should not be created solely to be passed as arguments to functions that perform delegated object creation",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "EFFICIENT",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eIn the standard library, several functions, instead of taking an object as an argument, take a list of arguments that will be used to construct an\nobject in a specific place:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003estd::vector::emplace_back\u003c/code\u003e will create the object directly inside the vector \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003estd::make_unique\u003c/code\u003e will create the object and a \u003ccode\u003eunique_ptr\u003c/code\u003e that points to it \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003estd::make_shared\u003c/code\u003e will create the object in a specially allocated memory area that will also contain bookkeeping information for\n  the shared pointer, and the associated \u003ccode\u003eshared_ptr\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003estd::optional\u003c/code\u003e has a constructor that will create an object inside the optional (this constructor is selected by using\n  \u003ccode\u003estd::in_place\u003c/code\u003e as its first argument) \u003c/li\u003e\n  \u003cli\u003e …​ \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThese functions are said to perform delegated object creation.\u003c/p\u003e\n\u003cp\u003eConstructing an object externally and passing it to one of these functions is possible. They will then create their object by calling the copy\nconstructor to copy the argument. But it defeats the purpose of those functions that try to create the object at the right place directly.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when a function that performs delegated object creation is passed an object of the right type explicitly created for this\npurpose only.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstruct Point {\n  Point(int x, int y);\n  Point(std::string_view serialized);\n};\n\nvoid f() {\n  auto p1 \u003d std::make_unique\u0026lt;Point\u0026gt;(Point(1, 2)); // Noncompliant\n  auto p2 \u003d std::optional\u0026lt;Point\u0026gt;(std::in_place, Point(1, 2)); // Noncompliant\n\n  std::vector\u0026lt;Point\u0026gt; points;\n  points.emplace_back(Point {1, 2}); // Noncompliant\n\n  Point p {3, 4};\n  points.emplace_back(p); // Noncompliant, since p is not used anywhere else\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstruct Point {\n  Point(int x, int y);\n  Point(std::string_view serialized);\n};\n\nvoid f() {\n  auto p1 \u003d std::make_unique\u0026lt;Point\u0026gt;(1, 2); // Compliant\n  auto p2 \u003d std::optional\u0026lt;Point\u0026gt;(std::in_place, 1, 2); // Compliant\n\n  std::vector\u0026lt;Point\u0026gt; points;\n  points.emplace_back(1, 2); // Compliant\n\n  Point p {3, 4};\n  points.emplace_back(p); // Compliant\n  someFunction(p);\n\n  auto buffer \u003d \"1,3\";\n  points.emplace_back(std::string_view{buffer, 3}) // Compliant, the constructed object is of a different type\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eIn the standard library, several functions, instead of taking an object as an argument, take a list of arguments that will be used to construct an\nobject in a specific place:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003estd::vector::emplace_back\u003c/code\u003e will create the object directly inside the vector \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003estd::make_unique\u003c/code\u003e will create the object and a \u003ccode\u003eunique_ptr\u003c/code\u003e that points to it \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003estd::make_shared\u003c/code\u003e will create the object in a specially allocated memory area that will also contain bookkeeping information for\n  the shared pointer, and the associated \u003ccode\u003eshared_ptr\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003estd::optional\u003c/code\u003e has a constructor that will create an object inside the optional (this constructor is selected by using\n  \u003ccode\u003estd::in_place\u003c/code\u003e as its first argument) \u003c/li\u003e\n  \u003cli\u003e …​ \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThese functions are said to perform delegated object creation.\u003c/p\u003e\n\u003cp\u003eConstructing an object externally and passing it to one of these functions is possible. They will then create their object by calling the copy\nconstructor to copy the argument. But it defeats the purpose of those functions that try to create the object at the right place directly.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when a function that performs delegated object creation is passed an object of the right type explicitly created for this\npurpose only.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstruct Point {\n  Point(int x, int y);\n  Point(std::string_view serialized);\n};\n\nvoid f() {\n  auto p1 \u003d std::make_unique\u0026lt;Point\u0026gt;(Point(1, 2)); // Noncompliant\n  auto p2 \u003d std::optional\u0026lt;Point\u0026gt;(std::in_place, Point(1, 2)); // Noncompliant\n\n  std::vector\u0026lt;Point\u0026gt; points;\n  points.emplace_back(Point {1, 2}); // Noncompliant\n\n  Point p {3, 4};\n  points.emplace_back(p); // Noncompliant, since p is not used anywhere else\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstruct Point {\n  Point(int x, int y);\n  Point(std::string_view serialized);\n};\n\nvoid f() {\n  auto p1 \u003d std::make_unique\u0026lt;Point\u0026gt;(1, 2); // Compliant\n  auto p2 \u003d std::optional\u0026lt;Point\u0026gt;(std::in_place, 1, 2); // Compliant\n\n  std::vector\u0026lt;Point\u0026gt; points;\n  points.emplace_back(1, 2); // Compliant\n\n  Point p {3, 4};\n  points.emplace_back(p); // Compliant\n  someFunction(p);\n\n  auto buffer \u003d \"1,3\";\n  points.emplace_back(std::string_view{buffer, 3}) // Compliant, the constructed object is of a different type\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "clumsy",
      "performance",
      "since-c++11"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6495",
    "name": "\"std::format\" should be used instead of standard output manipulators",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eC++20 introduces a new text formatting API with the \u003ccode\u003e\u0026lt;format\u0026gt;\u003c/code\u003e header, joining the \u003ccode\u003eprintf\u003c/code\u003e family of\nfunctions — inherited from C — and \u003ccode\u003eiostreams\u003c/code\u003e. \u003ccode\u003estd::format\u003c/code\u003e combines the convenience of \u003ccode\u003eprintf\u003c/code\u003e, separating\nformatting and arguments, with the type-safety of \u003ccode\u003eiostreams\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eBefore C++20, if you wanted to format an output stream, you had to use standard manipulators that control the output streams. This approach is very\nverbose, is often stateful, and is not thread-safe. That is why we recommend replacing them with \u003ccode\u003estd::format\u003c/code\u003e when possible.\u003c/p\u003e\n\u003cp\u003eSome manipulators will have a temporary effect on the output. For example, \u003ccode\u003estd::setw\u003c/code\u003e. This is due to the resetting of the width\nproperty of the stream when most of the \u003ccode\u003eoperator\u0026lt;\u0026lt;\u003c/code\u003e is called. Other manipulators will have a lasting effect on the output. For\nexample, \u003ccode\u003estd::boolalpha\u003c/code\u003e. It will set the \u003ccode\u003eboolalpha\u003c/code\u003e flag of the output stream without resetting it.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when an output stream is used with standard manipulators to output a formattable type in a way that can be replaced by\n\u003ccode\u003estd::format\u003c/code\u003e. You should be careful to avoid undesirable side effects when replacing a manipulator with lasting effects.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid printBool(bool b) {\n  std::cout \u0026lt;\u0026lt; std::boolalpha \u0026lt;\u0026lt; b; // Noncompliant\n}\n\nvoid printInt(int b) {\n  std::cout \u0026lt;\u0026lt; std::setfill(\u0027*\u0027) \u0026lt;\u0026lt; std::setw(5) \u0026lt;\u0026lt; b; // Noncompliant\n}\n\nint main() {\n  printInt(10);\n  printBool(true);\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid printBool(bool b) {\n  // Compliant, be aware of the side effect of not setting the boolalpha flag\n  std::cout \u0026lt;\u0026lt; std::format(\"{}\", b);\n}\n\nvoid printInt(int b) {\n  // Compliant, no side effect because setw has a temporary effect\n  std::cout \u0026lt;\u0026lt; std::format(\"{:*\u0026gt;5}\", b);\n}\n\nvoid setFlags() {\n  // Compliant, the intention is to set the flags and not to output\n  std::cout \u0026lt;\u0026lt; std::boolalpha \u0026lt;\u0026lt; std::showbase;\n}\n\nint main() {\n  printInt(10);\n  printBool(true);\n  setFlags();\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eManipulators that don’t have a direct equivalent in the format library like \u003ccode\u003estd::quoted\u003c/code\u003e, \u003ccode\u003estd::put_money\u003c/code\u003e, etc.\u003c/p\u003e\n\u003cpre\u003e\nvoid printQuoted(std::string_view s) {\n  // Compliant by exception: no simple format-based alternative\n  std::cout \u0026lt;\u0026lt; std::quoted(s, \u0027$\u0027, \u0027-\u0027);\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eC++20 introduces a new text formatting API with the \u003ccode\u003e\u0026lt;format\u0026gt;\u003c/code\u003e header, joining the \u003ccode\u003eprintf\u003c/code\u003e family of\nfunctions — inherited from C — and \u003ccode\u003eiostreams\u003c/code\u003e. \u003ccode\u003estd::format\u003c/code\u003e combines the convenience of \u003ccode\u003eprintf\u003c/code\u003e, separating\nformatting and arguments, with the type-safety of \u003ccode\u003eiostreams\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eBefore C++20, if you wanted to format an output stream, you had to use standard manipulators that control the output streams. This approach is very\nverbose, is often stateful, and is not thread-safe. That is why we recommend replacing them with \u003ccode\u003estd::format\u003c/code\u003e when possible.\u003c/p\u003e\n\u003cp\u003eSome manipulators will have a temporary effect on the output. For example, \u003ccode\u003estd::setw\u003c/code\u003e. This is due to the resetting of the width\nproperty of the stream when most of the \u003ccode\u003eoperator\u0026lt;\u0026lt;\u003c/code\u003e is called. Other manipulators will have a lasting effect on the output. For\nexample, \u003ccode\u003estd::boolalpha\u003c/code\u003e. It will set the \u003ccode\u003eboolalpha\u003c/code\u003e flag of the output stream without resetting it.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when an output stream is used with standard manipulators to output a formattable type in a way that can be replaced by\n\u003ccode\u003estd::format\u003c/code\u003e. You should be careful to avoid undesirable side effects when replacing a manipulator with lasting effects.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid printBool(bool b) {\n  std::cout \u0026lt;\u0026lt; std::boolalpha \u0026lt;\u0026lt; b; // Noncompliant\n}\n\nvoid printInt(int b) {\n  std::cout \u0026lt;\u0026lt; std::setfill(\u0027*\u0027) \u0026lt;\u0026lt; std::setw(5) \u0026lt;\u0026lt; b; // Noncompliant\n}\n\nint main() {\n  printInt(10);\n  printBool(true);\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid printBool(bool b) {\n  // Compliant, be aware of the side effect of not setting the boolalpha flag\n  std::cout \u0026lt;\u0026lt; std::format(\"{}\", b);\n}\n\nvoid printInt(int b) {\n  // Compliant, no side effect because setw has a temporary effect\n  std::cout \u0026lt;\u0026lt; std::format(\"{:*\u0026gt;5}\", b);\n}\n\nvoid setFlags() {\n  // Compliant, the intention is to set the flags and not to output\n  std::cout \u0026lt;\u0026lt; std::boolalpha \u0026lt;\u0026lt; std::showbase;\n}\n\nint main() {\n  printInt(10);\n  printBool(true);\n  setFlags();\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eManipulators that don’t have a direct equivalent in the format library like \u003ccode\u003estd::quoted\u003c/code\u003e, \u003ccode\u003estd::put_money\u003c/code\u003e, etc.\u003c/p\u003e\n\u003cpre\u003e\nvoid printQuoted(std::string_view s) {\n  // Compliant by exception: no simple format-based alternative\n  std::cout \u0026lt;\u0026lt; std::quoted(s, \u0027$\u0027, \u0027-\u0027);\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "clumsy",
      "performance",
      "since-c++20"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1916",
    "name": "Line continuation characters \u0027\\\u0027 should not be followed by trailing whitespace",
    "defaultSeverity": "MINOR",
    "type": "BUG",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "RELIABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhen a line of code ends with the \u003ccode\u003e\\\u003c/code\u003e (backslash) character, the newline character is deleted. The compiler considers the next line a\ncontinuation of the current line, resulting in only one logical line of code.\u003c/p\u003e\n\u003cp\u003eThis source code transformation, known as \u003cem\u003eline-splicing\u003c/em\u003e, occurs during the second phase of C and C++ translation.\u003c/p\u003e\n\u003cp\u003eSeveral compilers have a loose implementation of \u003cem\u003eline-splicing\u003c/em\u003e and allow whitespace after the \u003ccode\u003e\\\u003c/code\u003e character. While this\npractice was non-portable until C++23, it remains non-portable in C. Furthermore, readers can easily be confused about the meaning of these\nwhitespaces.\u003c/p\u003e\n\u003cp\u003eTherefore, for portability and clarity, \u003ccode\u003e\\\u003c/code\u003e should be immediately followed by a newline character, as in the following example.\u003c/p\u003e\n\u003cpre\u003e\n// Compliant: there is no whitespace after the \u0027\\\u0027\n#define FOO BAR \\\n            BAZ\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/translation_phases\"\u003ePhases of translation\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S2323} - Line-splicing should not be used in \"//\" comments \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhen a line of code ends with the \u003ccode\u003e\\\u003c/code\u003e (backslash) character, the newline character is deleted. The compiler considers the next line a\ncontinuation of the current line, resulting in only one logical line of code.\u003c/p\u003e\n\u003cp\u003eThis source code transformation, known as \u003cem\u003eline-splicing\u003c/em\u003e, occurs during the second phase of C and C++ translation.\u003c/p\u003e\n\u003cp\u003eSeveral compilers have a loose implementation of \u003cem\u003eline-splicing\u003c/em\u003e and allow whitespace after the \u003ccode\u003e\\\u003c/code\u003e character. While this\npractice was non-portable until C++23, it remains non-portable in C. Furthermore, readers can easily be confused about the meaning of these\nwhitespaces.\u003c/p\u003e\n\u003cp\u003eTherefore, for portability and clarity, \u003ccode\u003e\\\u003c/code\u003e should be immediately followed by a newline character, as in the following example.\u003c/p\u003e\n\u003cpre\u003e\n// Compliant: there is no whitespace after the \u0027\\\u0027\n#define FOO BAR \\\n            BAZ\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/translation_phases\"\u003ePhases of translation\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S2323} - Line-splicing should not be used in \"//\" comments \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [],
    "deprecatedKeys": [
      "cpp:PPBackslashNotLastCharacter"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1917",
    "name": "Comment styles \"//\" and \"/* ... */\" should not be mixed within a file",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eUse either the \u003ccode\u003e// ...\u003c/code\u003e or \u003ccode\u003e/* ... */\u003c/code\u003e comment syntax, but be consistent and do not mix them within the same file.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n/* Noncompliant; both comment syntaxes are used in the same file */\n// Foo\n/* Bar */\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n// Compliant; uniform comment syntax\n// Foo\n// Bar\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eUse either the \u003ccode\u003e// ...\u003c/code\u003e or \u003ccode\u003e/* ... */\u003c/code\u003e comment syntax, but be consistent and do not mix them within the same file.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n/* Noncompliant; both comment syntaxes are used in the same file */\n// Foo\n/* Bar */\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n// Compliant; uniform comment syntax\n// Foo\n// Bar\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "cert",
      "convention"
    ],
    "deprecatedKeys": [
      "cpp:CommentMixedStyles"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6016",
    "name": "\"[*this]\" should be used to capture the current object by copy",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhen you are using lambdas in a member function, you can capture \u003ccode\u003ethis\u003c/code\u003e implicitly through \u003ccode\u003e[\u003d]\u003c/code\u003e or \u003ccode\u003e[\u0026amp;]\u003c/code\u003e or\nexplicitly through \u003ccode\u003e[this]\u003c/code\u003e. It will capture\u0026nbsp;the current object pointer by reference or value, but the underlying object will always\nbe captured by reference (see {rule:cpp:S5019}).\u003c/p\u003e\n\u003cp\u003eThis will become a problem:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e When the lifetime of the lambda exceeds the one of the current object. \u003c/li\u003e\n  \u003cli\u003e When you want to capture the current state of the object. \u003c/li\u003e\n  \u003cli\u003e When you want to pass a copy of the object to avoid any concurrency issue. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eC++14 provides a solution to this problem. You can copy the underlying object by using the following pattern:\u003c/p\u003e\n\u003cpre\u003e\nauto lam \u003d [copyOfThis \u003d *this] { std::cout \u0026lt;\u0026lt; copyOfThis.field; };\n\u003c/pre\u003e\n\u003cp\u003eThis is verbose and error-prone, as you might implicitly not use the copied object:\u003c/p\u003e\n\u003cpre\u003e\nauto lam \u003d [\u0026amp; , copyOfThis \u003d *this] {\n  std::cout \u0026lt;\u0026lt; field; // implicitly calling “this” captured by reference\n};\n\u003c/pre\u003e\n\u003cp\u003eC++17 solves this problem by introducing an explicit, consistent way to capture \u003ccode\u003ethis\u003c/code\u003e by copy:\u003c/p\u003e\n\u003cpre\u003e\nauto lam \u003d [\u0026amp;, *this] {\n  std::cout \u0026lt;\u0026lt; field // implicitly calling “this” captured by copy\n};\n\u003c/pre\u003e\n\u003cp\u003eThis rule will flag the C++14 way of capturing the current object by copy and suggest replacing it with the C++17 way.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nstruct A {\n  int field \u003d 0;\n  void memfn() const {\n    auto lam \u003d [copyOfThis \u003d *this] { // Noncompliant\n      std::cout \u0026lt;\u0026lt; copyOfThis.field;\n    };\n  }\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nstruct A {\n  int field \u003d 0;\n  void memfn() const {\n    auto lam \u003d [*this] { // Compliant\n      std::cout \u0026lt;\u0026lt; field;\n    };\n  }\n};\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhen you are using lambdas in a member function, you can capture \u003ccode\u003ethis\u003c/code\u003e implicitly through \u003ccode\u003e[\u003d]\u003c/code\u003e or \u003ccode\u003e[\u0026amp;]\u003c/code\u003e or\nexplicitly through \u003ccode\u003e[this]\u003c/code\u003e. It will capture\u0026nbsp;the current object pointer by reference or value, but the underlying object will always\nbe captured by reference (see {rule:cpp:S5019}).\u003c/p\u003e\n\u003cp\u003eThis will become a problem:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e When the lifetime of the lambda exceeds the one of the current object. \u003c/li\u003e\n  \u003cli\u003e When you want to capture the current state of the object. \u003c/li\u003e\n  \u003cli\u003e When you want to pass a copy of the object to avoid any concurrency issue. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eC++14 provides a solution to this problem. You can copy the underlying object by using the following pattern:\u003c/p\u003e\n\u003cpre\u003e\nauto lam \u003d [copyOfThis \u003d *this] { std::cout \u0026lt;\u0026lt; copyOfThis.field; };\n\u003c/pre\u003e\n\u003cp\u003eThis is verbose and error-prone, as you might implicitly not use the copied object:\u003c/p\u003e\n\u003cpre\u003e\nauto lam \u003d [\u0026amp; , copyOfThis \u003d *this] {\n  std::cout \u0026lt;\u0026lt; field; // implicitly calling “this” captured by reference\n};\n\u003c/pre\u003e\n\u003cp\u003eC++17 solves this problem by introducing an explicit, consistent way to capture \u003ccode\u003ethis\u003c/code\u003e by copy:\u003c/p\u003e\n\u003cpre\u003e\nauto lam \u003d [\u0026amp;, *this] {\n  std::cout \u0026lt;\u0026lt; field // implicitly calling “this” captured by copy\n};\n\u003c/pre\u003e\n\u003cp\u003eThis rule will flag the C++14 way of capturing the current object by copy and suggest replacing it with the C++17 way.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nstruct A {\n  int field \u003d 0;\n  void memfn() const {\n    auto lam \u003d [copyOfThis \u003d *this] { // Noncompliant\n      std::cout \u0026lt;\u0026lt; copyOfThis.field;\n    };\n  }\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nstruct A {\n  int field \u003d 0;\n  void memfn() const {\n    auto lam \u003d [*this] { // Compliant\n      std::cout \u0026lt;\u0026lt; field;\n    };\n  }\n};\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "clumsy",
      "pitfall",
      "since-c++17"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6017",
    "name": "\"if constexpr\" should be preferred to overloading for metaprogramming",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eC++17 version of the standards introduces \u003ccode\u003eif constexpr\u003c/code\u003e. If the \u003ccode\u003econstexpr\u003c/code\u003e keyword follows the \u003ccode\u003eif\u003c/code\u003e keyword in\nan if statement, then the \u003ccode\u003eif\u003c/code\u003e condition must be a constant and the \u003ccode\u003ethen\u003c/code\u003e or \u003ccode\u003eelse\u003c/code\u003e block is discarded at compile\ntime, depending on the value of the constant.\u003c/p\u003e\n\u003cp\u003eMore precisely, \u003ccode\u003eif constexpr\u003c/code\u003e branches that are discarded are not going to be instantiated. This behavior enables us to write some\noverloaded function templates in a more readable way: you don’t need to use complex patterns (eg: by using \u003ccode\u003estd::enable_if\u003c/code\u003e) to make code\ncompile.\u003c/p\u003e\n\u003cp\u003eThis rule points out where\u0026nbsp;a complex overloaded functions template could simply be replaced by \u003ccode\u003eif constexpr\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\ntemplate\u0026lt;typename Type\u0026gt;\ntypename std::enable_if_t\u0026lt;std::is_arithmetic_v\u0026lt;Type\u0026gt;\u0026gt; process(Type\u0026amp;\u0026amp; type); // Noncompliant, this function can be combined with the one below\n\ntemplate\u0026lt;typename Type\u0026gt;\ntypename std::enable_if_t\u0026lt;!std::is_arithmetic_v\u0026lt;Type\u0026gt;\u0026gt; process(Type\u0026amp;\u0026amp; type);\n\ntemplate \u0026lt;typename It, typename Distance\u0026gt;\nvoid moveForward(It\u0026amp; it, Distance d, std::input_iterator_tag); // Noncompliant, this function can be combined with the one below\n\ntemplate \u0026lt;typename It, typename Distance, typename T\u0026gt;\nvoid moveForward(It\u0026amp; it, Distance d, T);\n\ntemplate \u0026lt;typename It, typename Distance\u0026gt;\nvoid moveForward(It\u0026amp; it, Distance d) { // Wrapper of the \"moveForward\" functions\n    moveForward(it, d, typename std::iterator_traits\u0026lt;It\u0026gt;::iterator_category{} );\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\ntemplate\u0026lt;typename Type\u0026gt;\nvoid process(Type\u0026amp;\u0026amp; type) {\n    if constexpr(std::is_arithmetic_v\u0026lt;type\u0026gt;) {\n        // implementation\n    } else {\n        // implementation\n    }\n}\n\ntemplate \u0026lt;typename It, typename Distance\u0026gt;\nvoid moveForward(It\u0026amp; it, Distance d) { // Modifications have been directly done inside the wrapper\n    if constexpr (std::iterator_traits\u0026lt;It\u0026gt;::input_iterator_tag) {\n        // implementation\n    } else {\n        // implementation\n    }\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eC++17 version of the standards introduces \u003ccode\u003eif constexpr\u003c/code\u003e. If the \u003ccode\u003econstexpr\u003c/code\u003e keyword follows the \u003ccode\u003eif\u003c/code\u003e keyword in\nan if statement, then the \u003ccode\u003eif\u003c/code\u003e condition must be a constant and the \u003ccode\u003ethen\u003c/code\u003e or \u003ccode\u003eelse\u003c/code\u003e block is discarded at compile\ntime, depending on the value of the constant.\u003c/p\u003e\n\u003cp\u003eMore precisely, \u003ccode\u003eif constexpr\u003c/code\u003e branches that are discarded are not going to be instantiated. This behavior enables us to write some\noverloaded function templates in a more readable way: you don’t need to use complex patterns (eg: by using \u003ccode\u003estd::enable_if\u003c/code\u003e) to make code\ncompile.\u003c/p\u003e\n\u003cp\u003eThis rule points out where\u0026nbsp;a complex overloaded functions template could simply be replaced by \u003ccode\u003eif constexpr\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\ntemplate\u0026lt;typename Type\u0026gt;\ntypename std::enable_if_t\u0026lt;std::is_arithmetic_v\u0026lt;Type\u0026gt;\u0026gt; process(Type\u0026amp;\u0026amp; type); // Noncompliant, this function can be combined with the one below\n\ntemplate\u0026lt;typename Type\u0026gt;\ntypename std::enable_if_t\u0026lt;!std::is_arithmetic_v\u0026lt;Type\u0026gt;\u0026gt; process(Type\u0026amp;\u0026amp; type);\n\ntemplate \u0026lt;typename It, typename Distance\u0026gt;\nvoid moveForward(It\u0026amp; it, Distance d, std::input_iterator_tag); // Noncompliant, this function can be combined with the one below\n\ntemplate \u0026lt;typename It, typename Distance, typename T\u0026gt;\nvoid moveForward(It\u0026amp; it, Distance d, T);\n\ntemplate \u0026lt;typename It, typename Distance\u0026gt;\nvoid moveForward(It\u0026amp; it, Distance d) { // Wrapper of the \"moveForward\" functions\n    moveForward(it, d, typename std::iterator_traits\u0026lt;It\u0026gt;::iterator_category{} );\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\ntemplate\u0026lt;typename Type\u0026gt;\nvoid process(Type\u0026amp;\u0026amp; type) {\n    if constexpr(std::is_arithmetic_v\u0026lt;type\u0026gt;) {\n        // implementation\n    } else {\n        // implementation\n    }\n}\n\ntemplate \u0026lt;typename It, typename Distance\u0026gt;\nvoid moveForward(It\u0026amp; it, Distance d) { // Modifications have been directly done inside the wrapper\n    if constexpr (std::iterator_traits\u0026lt;It\u0026gt;::input_iterator_tag) {\n        // implementation\n    } else {\n        // implementation\n    }\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "since-c++17"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6015",
    "name": "\"std::uncaught_exception\" should not be used",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003ebool std::uncaught_exception()\u003c/code\u003e allows you to know whether a thread is in an exception stack unwinding context. However, its practical\nfunctionality was restricted.\u003c/p\u003e\n\u003cp\u003eC++17 deprecates \u003ccode\u003ebool std::uncaught_exception()\u003c/code\u003e and introduces \u003ccode\u003eint std::uncaught_exceptions()\u003c/code\u003e which returns the number of\nuncaught exceptions. The code example below shows how you can benefit from this new improved function.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003estd::uncaught_exception\u003c/code\u003e has been removed in C++20.\u003c/p\u003e\n\u003cp\u003eThis rule will flag any usage of \u003ccode\u003estd::uncaught_exception\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass Transaction {\n\n  // ...\n\n  ~Transaction() {\n    if (!std::uncaught_exception()) { // Noncompliant, replace std::uncaught_exception by std::uncaught_exceptions\n      // commit\n    } else {\n      // rollback\n    }\n  }\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cp\u003eThe following example shows how \u003ccode\u003estd::uncaught_exceptions\u003c/code\u003e can be used to determine in \u003ccode\u003e~Transaction\u003c/code\u003e if a new exception was\nthrown since \u003ccode\u003et1\u003c/code\u003e/\u003ccode\u003et2\u003c/code\u003e creation.\u003c/p\u003e\n\u003cpre\u003e\nclass Transaction {\n\n  // ...\n\n  ~Transaction() {\n    if (initialUncaughtExceptions \u003d\u003d std::uncaught_exceptions()) {\n      // commit\n    } else {\n      // rollback\n    }\n  }\n\n  // ...\n\n  int initialUncaughtExceptions \u003d std::uncaught_exceptions();\n};\n\nint f() {\n  try {\n    Transaction t1;\n    // ... something here could throw\n  } catch(...) {\n    Transaction t2;\n    // ... something here could throw\n  }\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003ccode\u003ebool std::uncaught_exception()\u003c/code\u003e allows you to know whether a thread is in an exception stack unwinding context. However, its practical\nfunctionality was restricted.\u003c/p\u003e\n\u003cp\u003eC++17 deprecates \u003ccode\u003ebool std::uncaught_exception()\u003c/code\u003e and introduces \u003ccode\u003eint std::uncaught_exceptions()\u003c/code\u003e which returns the number of\nuncaught exceptions. The code example below shows how you can benefit from this new improved function.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003estd::uncaught_exception\u003c/code\u003e has been removed in C++20.\u003c/p\u003e\n\u003cp\u003eThis rule will flag any usage of \u003ccode\u003estd::uncaught_exception\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass Transaction {\n\n  // ...\n\n  ~Transaction() {\n    if (!std::uncaught_exception()) { // Noncompliant, replace std::uncaught_exception by std::uncaught_exceptions\n      // commit\n    } else {\n      // rollback\n    }\n  }\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cp\u003eThe following example shows how \u003ccode\u003estd::uncaught_exceptions\u003c/code\u003e can be used to determine in \u003ccode\u003e~Transaction\u003c/code\u003e if a new exception was\nthrown since \u003ccode\u003et1\u003c/code\u003e/\u003ccode\u003et2\u003c/code\u003e creation.\u003c/p\u003e\n\u003cpre\u003e\nclass Transaction {\n\n  // ...\n\n  ~Transaction() {\n    if (initialUncaughtExceptions \u003d\u003d std::uncaught_exceptions()) {\n      // commit\n    } else {\n      // rollback\n    }\n  }\n\n  // ...\n\n  int initialUncaughtExceptions \u003d std::uncaught_exceptions();\n};\n\nint f() {\n  try {\n    Transaction t1;\n    // ... something here could throw\n  } catch(...) {\n    Transaction t2;\n    // ... something here could throw\n  }\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "since-c++17"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6018",
    "name": "Inline variables should be used to declare global variables in header files",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eC++17\u003c/code\u003e introduced inline variables. They provide a proper way to define global variables in header files. Before inline variables, it\nwasn’t possible to simply define global variables without compile or link errors:\u003c/p\u003e\n\u003cpre\u003e\nstruct A {\n  static std::string s1 \u003d \"s1\"; // doesn’t compile\n  static std::string s2;\n};\n\nA::s2 \u003d \"s2\"; // doesn’t link, violates the one definition rule\nstd::string s3 \u003d \"s3\"; // doesn’t link, violates the one definition rule\n\u003c/pre\u003e\n\u003cp\u003eInstead, you had to resort to less readable inconvenient workarounds like variable templates or functions that return a static object. These\nworkarounds will initialize the variables when used instead of the start of the program, which might be inconvenient depending on the program.\u003c/p\u003e\n\u003cp\u003eThis rule will detect these workarounds and suggest using inline variables instead.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstruct A {\n  static std::string\u0026amp; getS1() { // Noncompliant\n    static std::string s1 \u003d \"s1\";\n    return s1;\n  }\n};\n\ninline std::string\u0026amp; gets2() { // Noncompliant\n  static std::string s2 \u003d \"s2\";\n  return s2;\n}\n\ntemplate \u0026lt;typename T \u003d std::string\u0026gt;\nT s3 \u003d \"s3\"; // Noncompliant. Available starting C++14\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstruct A {\n  inline static std::string s1 \u003d \"s1\"; // Compliant\n};\n\ninline std::string s2 \u003d \"s2\"; // Compliant\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/inline\"\u003einline specifier\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003ccode\u003eC++17\u003c/code\u003e introduced inline variables. They provide a proper way to define global variables in header files. Before inline variables, it\nwasn’t possible to simply define global variables without compile or link errors:\u003c/p\u003e\n\u003cpre\u003e\nstruct A {\n  static std::string s1 \u003d \"s1\"; // doesn’t compile\n  static std::string s2;\n};\n\nA::s2 \u003d \"s2\"; // doesn’t link, violates the one definition rule\nstd::string s3 \u003d \"s3\"; // doesn’t link, violates the one definition rule\n\u003c/pre\u003e\n\u003cp\u003eInstead, you had to resort to less readable inconvenient workarounds like variable templates or functions that return a static object. These\nworkarounds will initialize the variables when used instead of the start of the program, which might be inconvenient depending on the program.\u003c/p\u003e\n\u003cp\u003eThis rule will detect these workarounds and suggest using inline variables instead.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstruct A {\n  static std::string\u0026amp; getS1() { // Noncompliant\n    static std::string s1 \u003d \"s1\";\n    return s1;\n  }\n};\n\ninline std::string\u0026amp; gets2() { // Noncompliant\n  static std::string s2 \u003d \"s2\";\n  return s2;\n}\n\ntemplate \u0026lt;typename T \u003d std::string\u0026gt;\nT s3 \u003d \"s3\"; // Noncompliant. Available starting C++14\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstruct A {\n  inline static std::string s1 \u003d \"s1\"; // Compliant\n};\n\ninline std::string s2 \u003d \"s2\"; // Compliant\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/inline\"\u003einline specifier\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "clumsy",
      "since-c++17"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5271",
    "name": "Functions which do not return should be declared as \"noreturn\"",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "EFFICIENT",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe attribute \u003ccode\u003enoreturn\u003c/code\u003e indicates that a function does not return. This information clarifies the behavior of the function and it\nallows the compiler to do optimizations.\u003c/p\u003e\n\u003cp\u003eIt can also help the compiler (and static analyzer tools, i.e. us) provide better error messages:\u003c/p\u003e\n\u003cpre\u003e\n__attribute__((noreturn)) void f();\n\nint g(int b) {\n  if (b \u003d\u003d 5) {\n    f();\n    printf(\"Hello world\\n\"); // This is dead code, the compiler/static analyzer can now detect it\n    // There is no returned value, but it is fine, the compiler/static analyzer knows not to warn about it\n  } else {\n    return 3;\n  }\n}\n\u003c/pre\u003e\n\u003cp\u003eThis rule detects when the attribute \u003ccode\u003enoreturn\u003c/code\u003e can be added to a function.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid g() {\u0026nbsp;// Noncompliant\n\u0026nbsp;\u0026nbsp;abort();\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n__attribute__((noreturn)) void g() {\u0026nbsp;// or [[noreturn]] for C++\n  abort(); // Compliant\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe attribute \u003ccode\u003enoreturn\u003c/code\u003e indicates that a function does not return. This information clarifies the behavior of the function and it\nallows the compiler to do optimizations.\u003c/p\u003e\n\u003cp\u003eIt can also help the compiler (and static analyzer tools, i.e. us) provide better error messages:\u003c/p\u003e\n\u003cpre\u003e\n__attribute__((noreturn)) void f();\n\nint g(int b) {\n  if (b \u003d\u003d 5) {\n    f();\n    printf(\"Hello world\\n\"); // This is dead code, the compiler/static analyzer can now detect it\n    // There is no returned value, but it is fine, the compiler/static analyzer knows not to warn about it\n  } else {\n    return 3;\n  }\n}\n\u003c/pre\u003e\n\u003cp\u003eThis rule detects when the attribute \u003ccode\u003enoreturn\u003c/code\u003e can be added to a function.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid g() {\u0026nbsp;// Noncompliant\n\u0026nbsp;\u0026nbsp;abort();\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n__attribute__((noreturn)) void g() {\u0026nbsp;// or [[noreturn]] for C++\n  abort(); // Compliant\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "confusing",
      "since-c++11"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5272",
    "name": "Moved-from objects should not be relied upon",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003cp\u003eRelying on an object that has been moved-from leads to undefined behavior in most cases.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eAfter a move took place, the object that has been moved-from is left in a valid \u003cem\u003ebut\u003c/em\u003e unspecified state. Even if in a valid state, the fact\nof an object being in an unspecified state may lead to undefined behavior.\u003c/p\u003e\n\u003cp\u003eMove construction and its respective move semantics has been introduced in C++11. Moving objects becomes interesting if one wishes to get an object\ninto a different scope, while no longer requiring the original object. While one would previously need to make a potentially expensive copy to get an\nobject into another scope and then destroy the original, move constructors allow one to \u003cem\u003emove\u003c/em\u003e objects without performing a copy. Move\nconstructors are typically implemented by \"stealing\" the resources held by another object specified as the move constructor’s parameter, rather than\nmaking a copy. \"Stealing\" resources (e.g. memory) from another object is oftentimes much more efficient than making a copy and destroying the\noriginal, and can frequently be implemented by reassigning a few pointer variables.\u003c/p\u003e\n\u003cp\u003eMove-assignment operators behave analogously, except that they are used once the object that is moved-to has already been constructed. In contrast\nto copy-assignment operators, a move-assignment operator too \"steals\" the moved-from object’s resources without the need for making a potentially\nexpensive copy.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eUsing an object after it has been moved-from typically leads to \u003cstrong\u003eundefined behavior\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eFor programs that exercise undefined behavior, the compiler is no longer bound by the language specification. The application may crash or, even\nworse, the application may appear to execute correctly while losing data or producing incorrect results.\u003c/p\u003e\n\u003cp\u003eTrying to access an object that has been moved-from frequently ends up in a null-pointer dereference, since any pointers to the resources that have\nbeen \"stolen\" are set to \u003ccode\u003enullptr\u003c/code\u003e as part of the move construction or move assignment.\u003c/p\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThere are some C++ standard template library types, such as \u003ccode\u003estd::unique_ptr\u003c/code\u003e, for which the moved-from state is fully specified.\u003c/p\u003e\n\u003ch3\u003eExemplary type with move operations\u003c/h3\u003e\n\u003cp\u003eThe \u003ccode\u003eDynamicIntArray\u003c/code\u003e type defined in the following manages memory (i.e., a resource), and shall serve as an example that showcases how\nmove operations \"steal\" another object’s resources and how they differ from making copies.\u003c/p\u003e\n\u003cp\u003eWhile the copy constructor does make a full copy by allocating memory and then copying the \u003ccode\u003eother\u003c/code\u003e object’s array values into the\nfreshly allocated memory, the move constructor only assigns the pointer to point to \u003ccode\u003eother\u003c/code\u003e\u0027s dynamically allocated memory. It then sets\nthe pointer of the \u003ccode\u003eother\u003c/code\u003e object to \u003ccode\u003enullptr\u003c/code\u003e to allow its correct cleanup by the destructor of the\n\u003ccode\u003eDynamicIntArray\u003c/code\u003e type.\u003c/p\u003e\n\u003cp\u003eThe implementations for the copy- and move-assignment operators are similar with the main difference being that the objects have already been\nconstructed.\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;algorithm\u0026gt; // std::copy, std::fill\n#include \u0026lt;memory\u0026gt;    // std::move\n\nclass DynamicIntArray {\n  size_t size;\n  int *data;\n\npublic:\n  explicit DynamicIntArray(size_t size, int initial_value)\n      : size(size), data(new int[size]) {\n    std::fill(data, \u0026amp;data[size], initial_value);\n  }\n  ~DynamicIntArray() {\n    delete[] data;\n    size \u003d 0;\n  }\n  // Copy constructor (copies object)\n  DynamicIntArray(DynamicIntArray const \u0026amp;other)\n      : size(other.size), data(new int[other.size]) {\n    std::copy(other.data, \u0026amp;other.data[size], data);\n  }\n  // Move constructor (\"steals\" data, no allocation or copy necessary)\n  DynamicIntArray(DynamicIntArray \u0026amp;\u0026amp;other) noexcept\n      : size(other.size), data(other.data) {\n    // Ensure that the moved-from object `other` can be safely destroyed (using\n    // the destructor that calls to delete[]).\n    other.data \u003d nullptr;\n    other.size \u003d 0;\n  }\n  //\n  // Copy- and move-assignment operators are invoked, if _this_ object has\n  // already been constructed.\n  //\n  // Copy-assignment operator (copies object)\n  DynamicIntArray \u0026amp;operator\u003d(DynamicIntArray const \u0026amp;other) {\n    // If the number of elements are equal, we can re-use the existing memory.\n    if (size \u003d\u003d other.size) {\n      std::copy(other.data, \u0026amp;other.data[other.size], data);\n      return *this;\n    }\n    // Otherwise, we need to clean-up and re-allocate the required amount of\n    // memory.\n    delete[] data;\n    data \u003d new int[other.size];\n    size \u003d other.size;\n    std::copy(other.data, \u0026amp;other.data[size], data);\n    return *this;\n  }\n  // Move-assignment operator (\"steals\" data, no allocation or copy necessary)\n  DynamicIntArray \u0026amp;operator\u003d(DynamicIntArray \u0026amp;\u0026amp;other) noexcept {\n    delete[] data; // Clean-up our own data before we \"steal\" from `other`.\n    data \u003d other.data;\n    size \u003d other.size;\n    // Ensure that the moved-from object `other` can be safely destroyed (using\n    // the destructor that calls to delete[]).\n    other.data \u003d nullptr;\n    other.size \u003d 0;\n    return *this;\n  }\n\n  int \u0026amp;getValueAt(size_t idx) { return data[idx]; }\n};\n\nint main() {\n  DynamicIntArray a{/*size\u003d*/128, /*initial_value\u003d*/42};\n  DynamicIntArray b \u003d a;            // Copy constructor.\n  DynamicIntArray c \u003d std::move(b); // Move constructor.\n  // Construct two more objects.\n  DynamicIntArray d{/*size\u003d*/4, /*initial_value\u003d*/0};\n  DynamicIntArray e{/*size\u003d*/8, /*initial_value\u003d*/9001};\n  // Use the assignment operators.\n  a \u003d d;            // Copy-assignment operator.\n  c \u003d std::move(e); // Move-assignment operator.\n  int i \u003d b.getValueAt(0); // Noncompliant: `b` has been moved-from during construction of `c`.\n  int j \u003d e.getValueAt(0); // Noncompliant: `e` has been moved-from during move-assignment to `c`.\n  return i + j;\n}\n\u003c/pre\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eThere are several potential ways to fix this issue, depending on the concrete situation. Potential fixes include:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Use the object \u003cem\u003eonly before\u003c/em\u003e moving it \u003c/li\u003e\n  \u003cli\u003e Create a copy of the desired object and operate on the copy \u003c/li\u003e\n  \u003cli\u003e Completely remove the use of the object \u003cem\u003eafter\u003c/em\u003e is has been moved-from \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nint foo() {\n  DynamicIntArray a{128, 0};\n\n  DynamicIntArray a2 \u003d std::move(a);\n  int x \u003d a.getValueAt(0); // Noncompliant: `a` is moved-from. This particular access will lead to a null pointer dereference.\n  return x;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nint foo() {\n  DynamicIntArray a{128, 0};\n\n  DynamicIntArray a2 \u003d std::move(a);\n  int x \u003d a2.getValueAt(0); // Compliant: the correctly move-constructed variable `a2` can be used, of course.\n  return x;\n}\n\u003c/pre\u003e\n\u003cpre\u003e\nint foo() {\n  DynamicIntArray a{128, 0};\n\n  int x \u003d a.getValueAt(0); // Compliant: remove the move and use original object.\n  return x;\n}\n\u003c/pre\u003e\n\u003cpre\u003e\nint foo() {\n  DynamicIntArray a{128, 0};\n\n  DynamicIntArray a2 \u003d std::move(a);\n  // Compliant: use of `a` removed.\n  return 9001;\n}\n\u003c/pre\u003e\n\u003cpre\u003e\nint foo() {\n  DynamicIntArray a{128, 0};\n\n  DynamicIntArray a2 \u003d a;\n  int x \u003d a.getValueAt(0); // Compliant: `a` has been copied to produce `a2`.\n  return x;\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid array_user(DynamicIntArray \u0026amp;\u0026amp;array);\n\nint bar() {\n  DynamicIntArray a{512, 0};\n  array_user(std::move(a));\n  return a.getValueAt(42); // Noncompliant: `a` has been moved to `array_user()`.\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\nvoid array_user(DynamicIntArray \u0026amp;\u0026amp;array);\n\nint bar() {\n  DynamicIntArray a{512, 0};\n  array_user(DynamicIntArray{a});\n  return a.getValueAt(42); // Compliant: `a` has not been moved-from.\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/move_constructor\"\u003eMove constructors\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eConference presentations\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CppCon 2019 - \u003ca href\u003d\"https://www.youtube.com/watch?v\u003dSt0MNEU5b0o\u0026amp;ab_channel\u003dCppCon\"\u003eBack to Basics: Move Semantics (part 1 of 2)\u003c/a\u003e\n  \u003c/li\u003e\n  \u003cli\u003e CppCon 2019 - \u003ca href\u003d\"https://www.youtube.com/watch?v\u003dpIzaZbKUw2s\u0026amp;ab_channel\u003dCppCon\"\u003eBack to Basics: Move Semantics (part 2 of 2)\u003c/a\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://www.securecoding.cert.org/confluence/x/O3s-BQ\"\u003eEXP63-CPP. Do not rely on the value of a moved-from object\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S5415} ensures that move operations are available when an object is moved using \u003ccode\u003estd::move()\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S5500} ensures that rvalue reference arguments are moved and ownership is transferred \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eRelying on an object that has been moved-from leads to undefined behavior in most cases.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eAfter a move took place, the object that has been moved-from is left in a valid \u003cem\u003ebut\u003c/em\u003e unspecified state. Even if in a valid state, the fact\nof an object being in an unspecified state may lead to undefined behavior.\u003c/p\u003e\n\u003cp\u003eMove construction and its respective move semantics has been introduced in C++11. Moving objects becomes interesting if one wishes to get an object\ninto a different scope, while no longer requiring the original object. While one would previously need to make a potentially expensive copy to get an\nobject into another scope and then destroy the original, move constructors allow one to \u003cem\u003emove\u003c/em\u003e objects without performing a copy. Move\nconstructors are typically implemented by \"stealing\" the resources held by another object specified as the move constructor’s parameter, rather than\nmaking a copy. \"Stealing\" resources (e.g. memory) from another object is oftentimes much more efficient than making a copy and destroying the\noriginal, and can frequently be implemented by reassigning a few pointer variables.\u003c/p\u003e\n\u003cp\u003eMove-assignment operators behave analogously, except that they are used once the object that is moved-to has already been constructed. In contrast\nto copy-assignment operators, a move-assignment operator too \"steals\" the moved-from object’s resources without the need for making a potentially\nexpensive copy.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eUsing an object after it has been moved-from typically leads to \u003cstrong\u003eundefined behavior\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eFor programs that exercise undefined behavior, the compiler is no longer bound by the language specification. The application may crash or, even\nworse, the application may appear to execute correctly while losing data or producing incorrect results.\u003c/p\u003e\n\u003cp\u003eTrying to access an object that has been moved-from frequently ends up in a null-pointer dereference, since any pointers to the resources that have\nbeen \"stolen\" are set to \u003ccode\u003enullptr\u003c/code\u003e as part of the move construction or move assignment.\u003c/p\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThere are some C++ standard template library types, such as \u003ccode\u003estd::unique_ptr\u003c/code\u003e, for which the moved-from state is fully specified.\u003c/p\u003e\n\u003ch3\u003eExemplary type with move operations\u003c/h3\u003e\n\u003cp\u003eThe \u003ccode\u003eDynamicIntArray\u003c/code\u003e type defined in the following manages memory (i.e., a resource), and shall serve as an example that showcases how\nmove operations \"steal\" another object’s resources and how they differ from making copies.\u003c/p\u003e\n\u003cp\u003eWhile the copy constructor does make a full copy by allocating memory and then copying the \u003ccode\u003eother\u003c/code\u003e object’s array values into the\nfreshly allocated memory, the move constructor only assigns the pointer to point to \u003ccode\u003eother\u003c/code\u003e\u0027s dynamically allocated memory. It then sets\nthe pointer of the \u003ccode\u003eother\u003c/code\u003e object to \u003ccode\u003enullptr\u003c/code\u003e to allow its correct cleanup by the destructor of the\n\u003ccode\u003eDynamicIntArray\u003c/code\u003e type.\u003c/p\u003e\n\u003cp\u003eThe implementations for the copy- and move-assignment operators are similar with the main difference being that the objects have already been\nconstructed.\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;algorithm\u0026gt; // std::copy, std::fill\n#include \u0026lt;memory\u0026gt;    // std::move\n\nclass DynamicIntArray {\n  size_t size;\n  int *data;\n\npublic:\n  explicit DynamicIntArray(size_t size, int initial_value)\n      : size(size), data(new int[size]) {\n    std::fill(data, \u0026amp;data[size], initial_value);\n  }\n  ~DynamicIntArray() {\n    delete[] data;\n    size \u003d 0;\n  }\n  // Copy constructor (copies object)\n  DynamicIntArray(DynamicIntArray const \u0026amp;other)\n      : size(other.size), data(new int[other.size]) {\n    std::copy(other.data, \u0026amp;other.data[size], data);\n  }\n  // Move constructor (\"steals\" data, no allocation or copy necessary)\n  DynamicIntArray(DynamicIntArray \u0026amp;\u0026amp;other) noexcept\n      : size(other.size), data(other.data) {\n    // Ensure that the moved-from object `other` can be safely destroyed (using\n    // the destructor that calls to delete[]).\n    other.data \u003d nullptr;\n    other.size \u003d 0;\n  }\n  //\n  // Copy- and move-assignment operators are invoked, if _this_ object has\n  // already been constructed.\n  //\n  // Copy-assignment operator (copies object)\n  DynamicIntArray \u0026amp;operator\u003d(DynamicIntArray const \u0026amp;other) {\n    // If the number of elements are equal, we can re-use the existing memory.\n    if (size \u003d\u003d other.size) {\n      std::copy(other.data, \u0026amp;other.data[other.size], data);\n      return *this;\n    }\n    // Otherwise, we need to clean-up and re-allocate the required amount of\n    // memory.\n    delete[] data;\n    data \u003d new int[other.size];\n    size \u003d other.size;\n    std::copy(other.data, \u0026amp;other.data[size], data);\n    return *this;\n  }\n  // Move-assignment operator (\"steals\" data, no allocation or copy necessary)\n  DynamicIntArray \u0026amp;operator\u003d(DynamicIntArray \u0026amp;\u0026amp;other) noexcept {\n    delete[] data; // Clean-up our own data before we \"steal\" from `other`.\n    data \u003d other.data;\n    size \u003d other.size;\n    // Ensure that the moved-from object `other` can be safely destroyed (using\n    // the destructor that calls to delete[]).\n    other.data \u003d nullptr;\n    other.size \u003d 0;\n    return *this;\n  }\n\n  int \u0026amp;getValueAt(size_t idx) { return data[idx]; }\n};\n\nint main() {\n  DynamicIntArray a{/*size\u003d*/128, /*initial_value\u003d*/42};\n  DynamicIntArray b \u003d a;            // Copy constructor.\n  DynamicIntArray c \u003d std::move(b); // Move constructor.\n  // Construct two more objects.\n  DynamicIntArray d{/*size\u003d*/4, /*initial_value\u003d*/0};\n  DynamicIntArray e{/*size\u003d*/8, /*initial_value\u003d*/9001};\n  // Use the assignment operators.\n  a \u003d d;            // Copy-assignment operator.\n  c \u003d std::move(e); // Move-assignment operator.\n  int i \u003d b.getValueAt(0); // Noncompliant: `b` has been moved-from during construction of `c`.\n  int j \u003d e.getValueAt(0); // Noncompliant: `e` has been moved-from during move-assignment to `c`.\n  return i + j;\n}\n\u003c/pre\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eThere are several potential ways to fix this issue, depending on the concrete situation. Potential fixes include:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Use the object \u003cem\u003eonly before\u003c/em\u003e moving it \u003c/li\u003e\n  \u003cli\u003e Create a copy of the desired object and operate on the copy \u003c/li\u003e\n  \u003cli\u003e Completely remove the use of the object \u003cem\u003eafter\u003c/em\u003e is has been moved-from \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nint foo() {\n  DynamicIntArray a{128, 0};\n\n  DynamicIntArray a2 \u003d std::move(a);\n  int x \u003d a.getValueAt(0); // Noncompliant: `a` is moved-from. This particular access will lead to a null pointer dereference.\n  return x;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nint foo() {\n  DynamicIntArray a{128, 0};\n\n  DynamicIntArray a2 \u003d std::move(a);\n  int x \u003d a2.getValueAt(0); // Compliant: the correctly move-constructed variable `a2` can be used, of course.\n  return x;\n}\n\u003c/pre\u003e\n\u003cpre\u003e\nint foo() {\n  DynamicIntArray a{128, 0};\n\n  int x \u003d a.getValueAt(0); // Compliant: remove the move and use original object.\n  return x;\n}\n\u003c/pre\u003e\n\u003cpre\u003e\nint foo() {\n  DynamicIntArray a{128, 0};\n\n  DynamicIntArray a2 \u003d std::move(a);\n  // Compliant: use of `a` removed.\n  return 9001;\n}\n\u003c/pre\u003e\n\u003cpre\u003e\nint foo() {\n  DynamicIntArray a{128, 0};\n\n  DynamicIntArray a2 \u003d a;\n  int x \u003d a.getValueAt(0); // Compliant: `a` has been copied to produce `a2`.\n  return x;\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid array_user(DynamicIntArray \u0026amp;\u0026amp;array);\n\nint bar() {\n  DynamicIntArray a{512, 0};\n  array_user(std::move(a));\n  return a.getValueAt(42); // Noncompliant: `a` has been moved to `array_user()`.\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\nvoid array_user(DynamicIntArray \u0026amp;\u0026amp;array);\n\nint bar() {\n  DynamicIntArray a{512, 0};\n  array_user(DynamicIntArray{a});\n  return a.getValueAt(42); // Compliant: `a` has not been moved-from.\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/move_constructor\"\u003eMove constructors\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eConference presentations\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CppCon 2019 - \u003ca href\u003d\"https://www.youtube.com/watch?v\u003dSt0MNEU5b0o\u0026amp;ab_channel\u003dCppCon\"\u003eBack to Basics: Move Semantics (part 1 of 2)\u003c/a\u003e\n  \u003c/li\u003e\n  \u003cli\u003e CppCon 2019 - \u003ca href\u003d\"https://www.youtube.com/watch?v\u003dpIzaZbKUw2s\u0026amp;ab_channel\u003dCppCon\"\u003eBack to Basics: Move Semantics (part 2 of 2)\u003c/a\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://www.securecoding.cert.org/confluence/x/O3s-BQ\"\u003eEXP63-CPP. Do not rely on the value of a moved-from object\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S5415} ensures that move operations are available when an object is moved using \u003ccode\u003estd::move()\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S5500} ensures that rvalue reference arguments are moved and ownership is transferred \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cert",
      "since-c++11",
      "symbolic-execution"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6482",
    "name": "Explicit argument indexing in \"std::format\" should be used only for non-trivial ordering",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eCalls to \u003ccode\u003estd::format\u003c/code\u003e and \u003ccode\u003estd::vformat\u003c/code\u003e can receive either format strings whose replacement fields are fully indexed or\nfully non-indexed.\u003c/p\u003e\n\u003cp\u003eExplicitly indexing replacement fields is useful when arguments are not used in order or are used multiple times. Implicit indexing has the\nadvantage of being terse and simple.\u003c/p\u003e\n\u003cp\u003eUsing explicit indexing in a context where implicit indexing would have the same behavior is more verbose and error-prone. It might confuse the\nreader, who might expect the arguments not to be used in order.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue on explicit indexing that should be replaced by implicit indexing.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstd::string printRectangle(Rectangle const\u0026amp; r) {\n    return std::format(\"[{0},{1}]:({2},{3})\", r.x, r.y, r.width, r.height); // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstd::string printRectangle(Rectangle const\u0026amp; r) {\n    return std::format(\"[{},{}]:({},{})\", r.x, r.y, r.width, r.height); // Compliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eFormat strings with nested replacement fields are not considered by this rule as their order is less intuitive.\u003c/p\u003e\n\u003cpre\u003e\nstd::string printNDigits() {\n    return std::format(\"{0:*\u0026lt;{1}} {2:*\u0026gt;{3}}\", 10, 2, 11, 3); // Compliant\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eCalls to \u003ccode\u003estd::format\u003c/code\u003e and \u003ccode\u003estd::vformat\u003c/code\u003e can receive either format strings whose replacement fields are fully indexed or\nfully non-indexed.\u003c/p\u003e\n\u003cp\u003eExplicitly indexing replacement fields is useful when arguments are not used in order or are used multiple times. Implicit indexing has the\nadvantage of being terse and simple.\u003c/p\u003e\n\u003cp\u003eUsing explicit indexing in a context where implicit indexing would have the same behavior is more verbose and error-prone. It might confuse the\nreader, who might expect the arguments not to be used in order.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue on explicit indexing that should be replaced by implicit indexing.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstd::string printRectangle(Rectangle const\u0026amp; r) {\n    return std::format(\"[{0},{1}]:({2},{3})\", r.x, r.y, r.width, r.height); // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstd::string printRectangle(Rectangle const\u0026amp; r) {\n    return std::format(\"[{},{}]:({},{})\", r.x, r.y, r.width, r.height); // Compliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eFormat strings with nested replacement fields are not considered by this rule as their order is less intuitive.\u003c/p\u003e\n\u003cpre\u003e\nstd::string printNDigits() {\n    return std::format(\"{0:*\u0026lt;{1}} {2:*\u0026gt;{3}}\", 10, 2, 11, 3); // Compliant\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "clumsy",
      "since-c++20"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5270",
    "name": "User-defined types should not be passed as variadic arguments",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eVariadic arguments allow a function to accept any number of arguments (in this rule, we are not talking about variadic templates, but about\nfunctions with ellipses). But these arguments have to respect some criteria to be handled properly.\u003c/p\u003e\n\u003cp\u003eThe standard imposes some requirements on the class types that can be passed as variadic arguments, and those requirements vary according to the\nC++ standard version in use:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Before C++11, the standard only allows POD types to be used as variadic arguments. \u003c/li\u003e\n  \u003cli\u003e In C++11, the rules are relaxed such that any class type with an eligible non-trivial copy constructor, an eligible non-trivial move\n  constructor, or a non-trivial destructor can be used in variadic arguments. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe rule detects any violations of these requirements since they can trigger undefined behavior.\u003c/p\u003e\n\u003cp\u003eAdditionally, since using an incorrect type to access the passed parameter within the variadic function can lead to undefined behavior, the rule\ngoes a step further and reports all cases when class types are passed as variadic arguments. The rationale is that, most likely, the user forgot to\ncall a method on the object being passed (\u003ccode\u003estd::string_view::data()\u003c/code\u003e for example) that would get a member of a built-in type.\u003c/p\u003e\n\u003cp\u003eWhen in need to pass class types to functions that take a variable number of arguments, consider using modern type-safe alternatives like C++11\nparameter packs instead of variadic functions.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid my_log(const char* format, ...);\n\nvoid f() {\n  std::string someStr \u003d \"foo\";\n  my_log(\"%s\", someStr);  // Noncompliant; the C++11 standard requires types passed as variadic arguments to have a trivial copy constructor. The user probably meant to pass someStr.c_str() here\n\n  std::string_view someStrView \u003d \"bar\";\n  my_log(\"%s\", someStrView); // Noncompliant; the user probably meant to pass someText.data()\n  std::chrono::duration\u0026lt;float\u0026gt; duration;\n  my_log(\"%f\", duration); // Noncompliant, the user probably meant to pass duration.count()\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid my_log(const char* format, ...);\n\nvoid f() {\n  std::string someStr \u003d \"foo\";\n  my_log(\"%s\", someStr.c_str());  // Compliant\n\n  std::string_view someStrView \u003d \"bar\";\n  my_log(\"%s\", someStrView.data()); // Compliant\n  std::chrono::duration\u0026lt;float\u0026gt; duration;\n  my_log(\"%f\", duration.count()); // Compliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThe rule doesn’t report an issue in the following cases:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e When the called variadic function doesn’t have any non-variadic parameters. This is a common pattern when the function is used as a catch-all\n  net for an overload set. This is also guaranteed to be safe since there is no portable to access the passed arguments. \u003c/li\u003e\n  \u003cli\u003e When the called variadic function is known to accept a class type object as a variadic argument (e.g., the \u003ccode\u003esemctl\u003c/code\u003e system call).\n  \u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\n// This variadic function is used as a catch-all net to terminate recursion\nstd::size_t elementsCount(...) { return 1u; }\n\ntemplate\u0026lt;typename T\u0026gt;\nstd::size_t elementsCount(const std::vector\u0026lt;T\u0026gt;\u0026amp; vec) {\n  // Sum the elements of all nested vectors recursively\n  return std::accumulate(vec.begin(), vec.end(), 0u, [] (const std::size_t count, const T\u0026amp; element) {\n    return count + elementsCount(element); // Compliant (the callee doesn\u0027t have non-variadic arguments)\n  });\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 16.1 - Functions shall not be defined with a variable number of arguments. \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/5ns-BQ\"\u003eCERT, DCL50-CPP.\u003c/a\u003e - Do not define a C-style variadic function \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#-es34-dont-define-a-c-style-variadic-function\"\u003eES.34: Don’t\n  define a (C-style) variadic function\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S2275} and {rule:cpp:S3457} are rules that specialize in detecting type mismatches with format strings. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eVariadic arguments allow a function to accept any number of arguments (in this rule, we are not talking about variadic templates, but about\nfunctions with ellipses). But these arguments have to respect some criteria to be handled properly.\u003c/p\u003e\n\u003cp\u003eThe standard imposes some requirements on the class types that can be passed as variadic arguments, and those requirements vary according to the\nC++ standard version in use:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Before C++11, the standard only allows POD types to be used as variadic arguments. \u003c/li\u003e\n  \u003cli\u003e In C++11, the rules are relaxed such that any class type with an eligible non-trivial copy constructor, an eligible non-trivial move\n  constructor, or a non-trivial destructor can be used in variadic arguments. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe rule detects any violations of these requirements since they can trigger undefined behavior.\u003c/p\u003e\n\u003cp\u003eAdditionally, since using an incorrect type to access the passed parameter within the variadic function can lead to undefined behavior, the rule\ngoes a step further and reports all cases when class types are passed as variadic arguments. The rationale is that, most likely, the user forgot to\ncall a method on the object being passed (\u003ccode\u003estd::string_view::data()\u003c/code\u003e for example) that would get a member of a built-in type.\u003c/p\u003e\n\u003cp\u003eWhen in need to pass class types to functions that take a variable number of arguments, consider using modern type-safe alternatives like C++11\nparameter packs instead of variadic functions.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid my_log(const char* format, ...);\n\nvoid f() {\n  std::string someStr \u003d \"foo\";\n  my_log(\"%s\", someStr);  // Noncompliant; the C++11 standard requires types passed as variadic arguments to have a trivial copy constructor. The user probably meant to pass someStr.c_str() here\n\n  std::string_view someStrView \u003d \"bar\";\n  my_log(\"%s\", someStrView); // Noncompliant; the user probably meant to pass someText.data()\n  std::chrono::duration\u0026lt;float\u0026gt; duration;\n  my_log(\"%f\", duration); // Noncompliant, the user probably meant to pass duration.count()\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid my_log(const char* format, ...);\n\nvoid f() {\n  std::string someStr \u003d \"foo\";\n  my_log(\"%s\", someStr.c_str());  // Compliant\n\n  std::string_view someStrView \u003d \"bar\";\n  my_log(\"%s\", someStrView.data()); // Compliant\n  std::chrono::duration\u0026lt;float\u0026gt; duration;\n  my_log(\"%f\", duration.count()); // Compliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThe rule doesn’t report an issue in the following cases:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e When the called variadic function doesn’t have any non-variadic parameters. This is a common pattern when the function is used as a catch-all\n  net for an overload set. This is also guaranteed to be safe since there is no portable to access the passed arguments. \u003c/li\u003e\n  \u003cli\u003e When the called variadic function is known to accept a class type object as a variadic argument (e.g., the \u003ccode\u003esemctl\u003c/code\u003e system call).\n  \u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\n// This variadic function is used as a catch-all net to terminate recursion\nstd::size_t elementsCount(...) { return 1u; }\n\ntemplate\u0026lt;typename T\u0026gt;\nstd::size_t elementsCount(const std::vector\u0026lt;T\u0026gt;\u0026amp; vec) {\n  // Sum the elements of all nested vectors recursively\n  return std::accumulate(vec.begin(), vec.end(), 0u, [] (const std::size_t count, const T\u0026amp; element) {\n    return count + elementsCount(element); // Compliant (the callee doesn\u0027t have non-variadic arguments)\n  });\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 16.1 - Functions shall not be defined with a variable number of arguments. \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/5ns-BQ\"\u003eCERT, DCL50-CPP.\u003c/a\u003e - Do not define a C-style variadic function \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#-es34-dont-define-a-c-style-variadic-function\"\u003eES.34: Don’t\n  define a (C-style) variadic function\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S2275} and {rule:cpp:S3457} are rules that specialize in detecting type mismatches with format strings. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "cert",
      "cppcoreguidelines",
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5275",
    "name": "\"reinterpret_cast\" should be used carefully",
    "defaultSeverity": "CRITICAL",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eBecause \u003ccode\u003ereinterpret_cast\u003c/code\u003e ignores the type system, it is capable of performing dangerous conversions between unrelated types which can\nlead to undefined behavior.\u003c/p\u003e\n\u003cp\u003eThis rule reports an issue for two problematic uses of \u003ccode\u003ereinterpret_cast\u003c/code\u003e:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e when it is used to make the compiler believe that an object in memory is from a different type from its real type (for instance, casting a\n  \u003ccode\u003elong*\u003c/code\u003e to \u003ccode\u003edouble*\u003c/code\u003e, because accessing a \u003ccode\u003elong\u003c/code\u003e as if it was a \u003ccode\u003edouble\u003c/code\u003e is undefined behavior (even if\n  \u003ccode\u003esizeof(long) \u003d\u003d sizeof(double)\u003c/code\u003e), \u003c/li\u003e\n  \u003cli\u003e when it is used to cast between different levels of a complex inheritance hierarchy (a \u003ccode\u003estatic_cast\u003c/code\u003e would apply pointer offsets to\n  take into account multiple inheritance, for instance, but \u003ccode\u003ereinterpret_cast\u003c/code\u003e does not) \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass X {};\nclass Y : virtual X {};\n\nvoid test() {\n  long l;\n  auto a \u003d reinterpret_cast\u0026lt;double\u0026amp;\u0026gt;(l); // Noncompliant: undefined behavior\n\n  Y* y;\n  auto x \u003d reinterpret_cast\u0026lt;X*\u0026gt;(y); // Noncompliant\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eBecause \u003ccode\u003ereinterpret_cast\u003c/code\u003e ignores the type system, it is capable of performing dangerous conversions between unrelated types which can\nlead to undefined behavior.\u003c/p\u003e\n\u003cp\u003eThis rule reports an issue for two problematic uses of \u003ccode\u003ereinterpret_cast\u003c/code\u003e:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e when it is used to make the compiler believe that an object in memory is from a different type from its real type (for instance, casting a\n  \u003ccode\u003elong*\u003c/code\u003e to \u003ccode\u003edouble*\u003c/code\u003e, because accessing a \u003ccode\u003elong\u003c/code\u003e as if it was a \u003ccode\u003edouble\u003c/code\u003e is undefined behavior (even if\n  \u003ccode\u003esizeof(long) \u003d\u003d sizeof(double)\u003c/code\u003e), \u003c/li\u003e\n  \u003cli\u003e when it is used to cast between different levels of a complex inheritance hierarchy (a \u003ccode\u003estatic_cast\u003c/code\u003e would apply pointer offsets to\n  take into account multiple inheritance, for instance, but \u003ccode\u003ereinterpret_cast\u003c/code\u003e does not) \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass X {};\nclass Y : virtual X {};\n\nvoid test() {\n  long l;\n  auto a \u003d reinterpret_cast\u0026lt;double\u0026amp;\u0026gt;(l); // Noncompliant: undefined behavior\n\n  Y* y;\n  auto x \u003d reinterpret_cast\u0026lt;X*\u0026gt;(y); // Noncompliant\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5276",
    "name": "Implicit casts should not lower precision",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eA narrowing conversion is an implicit conversion to a destination type that cannot represent all values from the source type.\u003c/p\u003e\n\u003cp\u003eIt can be a floating-point type converted to an integer type, or a type with a larger range of values converted to a type with a smaller range.\u003c/p\u003e\n\u003cp\u003eNarrowing conversions can lead to a loss of information and because they are implicit, they are not always obvious.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nint a \u003d 2.1f; // Noncompliant: loss of floating-point precision\n\nlong double f();\ndouble d \u003d 0;\nd +\u003d f(); // Noncompliant: smaller range of values\n\u003c/pre\u003e\n\u003cp\u003eNarrowing conversions should be fixed by either using a destination type that can represent all the source values or by using an explicit\nconversion:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\ndouble a \u003d 2.1f; // Compliant: double can represent all floats\n\nlong double f();\ndouble d \u003d 0;\nd +\u003d static_cast\u0026lt;double\u0026gt;(f()); // Compliant: the intent is clear\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eA narrowing conversion is an implicit conversion to a destination type that cannot represent all values from the source type.\u003c/p\u003e\n\u003cp\u003eIt can be a floating-point type converted to an integer type, or a type with a larger range of values converted to a type with a smaller range.\u003c/p\u003e\n\u003cp\u003eNarrowing conversions can lead to a loss of information and because they are implicit, they are not always obvious.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nint a \u003d 2.1f; // Noncompliant: loss of floating-point precision\n\nlong double f();\ndouble d \u003d 0;\nd +\u003d f(); // Noncompliant: smaller range of values\n\u003c/pre\u003e\n\u003cp\u003eNarrowing conversions should be fixed by either using a destination type that can represent all the source values or by using an explicit\nconversion:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\ndouble a \u003d 2.1f; // Compliant: double can represent all floats\n\nlong double f();\ndouble d \u003d 0;\nd +\u003d static_cast\u0026lt;double\u0026gt;(f()); // Compliant: the intent is clear\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6365",
    "name": "Use symmetric transfer to switch execution between coroutines",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "EFFICIENT",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWith C++20 coroutines, the \u003ccode\u003eco_await\u003c/code\u003e/\u003ccode\u003eco_yield\u003c/code\u003e expression suspends the currently executed coroutine and resumes the\nexecution of either the caller or the coroutine function or to some already suspended coroutine (including the current coroutine).\u003c/p\u003e\n\u003cp\u003eThe resumption of the coroutine represented by the \u003ccode\u003estd::coroutine_handle\u003c/code\u003e object is usually performed by calling the\n\u003ccode\u003e.resume()\u003c/code\u003e on it. However, performing such an operation during the execution of \u003ccode\u003eawait_suspend\u003c/code\u003e (that is part of\n\u003ccode\u003eco_await\u003c/code\u003e expression evaluation) will preserve the activation frame of the \u003ccode\u003eawait_suspend\u003c/code\u003e function and the calling code on the\nstack. This may lead to stack overflows in a situation where the chain of directly resumed coroutines is deep enough.\u003c/p\u003e\n\u003cp\u003eThe use of the symmetric transfer may avoid this problem. When the \u003ccode\u003eawait_suspend\u003c/code\u003e function returns a\n\u003ccode\u003estd::coroutine_handle\u003c/code\u003e, the compiler will automatically use this handle to resume its coroutine after \u003ccode\u003eawait_suspend\u003c/code\u003e returns\n(and its activation frame is removed from the stack). Or, when a \u003ccode\u003estd::noop_coroutine_handle\u003c/code\u003e is returned, the execution will be passed to\nthe caller.\u003c/p\u003e\n\u003cp\u003eSymmetric transfer solution can also be used to resume the current coroutine (by returning handle passed as the parameter). However, in such cases,\nconditional suspension can be a more optimal solution.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue on \u003ccode\u003eawait_suspend\u003c/code\u003e functions that could use symmetric transfer.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstruct InvokeOtherAwaiter {\n  /* .... */\n  void await_suspend(std::coroutine_handle\u0026lt;PromiseType\u0026gt; current) {\n    if (auto other \u003d current.promise().other_handle) {\n      other.resume(); // Noncompliant\n    }\n  }\n};\n\nstruct WaitForAwaiter {\n  Event\u0026amp; event;\n  /* .... */\n  void await_suspend(std::coroutine_handle\u0026lt;\u0026gt; current) {\n    if (bool ready \u003d event.register_callback(current)) {\n      current.resume(); // Noncompliant\n    }\n  }\n};\n\nstruct BufferedExecutionAwaiter {\n  std::queue\u0026lt;std::coroutine_handle\u0026lt;\u0026gt;\u0026gt;\u0026amp; taskQueue;\n  /* .... */\n  void await_suspend(std::coroutine_handle\u0026lt;\u0026gt; current) {\n    if (taskQueue.empty()) {\n      current.resume(); // Noncompliant\n    }\n    auto next \u003d taskQueue.front();\n    taskQueue.pop();\n    taskQueue.push(current);\n    next.resume(); // Noncompliant\n  }\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstruct InvokeOtherAwaiter {\n  /* .... */\n  std::coroutine_handle\u0026lt;\u0026gt; await_suspend(std::coroutine_handle\u0026lt;PromiseType\u0026gt; current) {\n    if (auto other \u003d current.promise().other_handle) {\n      return other;\n    } else {\n      return std::noop_coroutine();\n    }\n  }\n};\n\nstruct WaitForAwaiter {\n  Event\u0026amp; event;\n  /* .... */\n  std::coroutine_handle\u0026lt;\u0026gt; await_suspend(std::coroutine_handle\u0026lt;\u0026gt; current) {\n    if (bool ready \u003d event.register_callback(current)) {\n      return current;\n    } else {\n      return std::noop_coroutine()\n    }\n  }\n  // Alternatively\n  bool await_suspend(std::coroutine_handle\u0026lt;\u0026gt; current) {\n    return !event.register_callback(current);\n  }\n};\n\nstruct BufferedExecutionAwaiter {\n  std::queue\u0026lt;std::coroutine_handle\u0026lt;\u0026gt;\u0026gt;\u0026amp; taskQueue;\n  /* .... */\n  std::coroutine_handle\u0026lt;\u0026gt; await_suspend(std::coroutine_handle\u0026lt;\u0026gt; current) {\n    if (taskQueue.empty()) {\n       return current;\n    }\n    auto next \u003d list.front();\n    taskQueue.pop();\n    taskQueue.push(current);\n    return next;\n  }\n};\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cp\u003e{rule:cpp:S6366} - conditionally suspending current coroutine in optimal way\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWith C++20 coroutines, the \u003ccode\u003eco_await\u003c/code\u003e/\u003ccode\u003eco_yield\u003c/code\u003e expression suspends the currently executed coroutine and resumes the\nexecution of either the caller or the coroutine function or to some already suspended coroutine (including the current coroutine).\u003c/p\u003e\n\u003cp\u003eThe resumption of the coroutine represented by the \u003ccode\u003estd::coroutine_handle\u003c/code\u003e object is usually performed by calling the\n\u003ccode\u003e.resume()\u003c/code\u003e on it. However, performing such an operation during the execution of \u003ccode\u003eawait_suspend\u003c/code\u003e (that is part of\n\u003ccode\u003eco_await\u003c/code\u003e expression evaluation) will preserve the activation frame of the \u003ccode\u003eawait_suspend\u003c/code\u003e function and the calling code on the\nstack. This may lead to stack overflows in a situation where the chain of directly resumed coroutines is deep enough.\u003c/p\u003e\n\u003cp\u003eThe use of the symmetric transfer may avoid this problem. When the \u003ccode\u003eawait_suspend\u003c/code\u003e function returns a\n\u003ccode\u003estd::coroutine_handle\u003c/code\u003e, the compiler will automatically use this handle to resume its coroutine after \u003ccode\u003eawait_suspend\u003c/code\u003e returns\n(and its activation frame is removed from the stack). Or, when a \u003ccode\u003estd::noop_coroutine_handle\u003c/code\u003e is returned, the execution will be passed to\nthe caller.\u003c/p\u003e\n\u003cp\u003eSymmetric transfer solution can also be used to resume the current coroutine (by returning handle passed as the parameter). However, in such cases,\nconditional suspension can be a more optimal solution.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue on \u003ccode\u003eawait_suspend\u003c/code\u003e functions that could use symmetric transfer.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstruct InvokeOtherAwaiter {\n  /* .... */\n  void await_suspend(std::coroutine_handle\u0026lt;PromiseType\u0026gt; current) {\n    if (auto other \u003d current.promise().other_handle) {\n      other.resume(); // Noncompliant\n    }\n  }\n};\n\nstruct WaitForAwaiter {\n  Event\u0026amp; event;\n  /* .... */\n  void await_suspend(std::coroutine_handle\u0026lt;\u0026gt; current) {\n    if (bool ready \u003d event.register_callback(current)) {\n      current.resume(); // Noncompliant\n    }\n  }\n};\n\nstruct BufferedExecutionAwaiter {\n  std::queue\u0026lt;std::coroutine_handle\u0026lt;\u0026gt;\u0026gt;\u0026amp; taskQueue;\n  /* .... */\n  void await_suspend(std::coroutine_handle\u0026lt;\u0026gt; current) {\n    if (taskQueue.empty()) {\n      current.resume(); // Noncompliant\n    }\n    auto next \u003d taskQueue.front();\n    taskQueue.pop();\n    taskQueue.push(current);\n    next.resume(); // Noncompliant\n  }\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstruct InvokeOtherAwaiter {\n  /* .... */\n  std::coroutine_handle\u0026lt;\u0026gt; await_suspend(std::coroutine_handle\u0026lt;PromiseType\u0026gt; current) {\n    if (auto other \u003d current.promise().other_handle) {\n      return other;\n    } else {\n      return std::noop_coroutine();\n    }\n  }\n};\n\nstruct WaitForAwaiter {\n  Event\u0026amp; event;\n  /* .... */\n  std::coroutine_handle\u0026lt;\u0026gt; await_suspend(std::coroutine_handle\u0026lt;\u0026gt; current) {\n    if (bool ready \u003d event.register_callback(current)) {\n      return current;\n    } else {\n      return std::noop_coroutine()\n    }\n  }\n  // Alternatively\n  bool await_suspend(std::coroutine_handle\u0026lt;\u0026gt; current) {\n    return !event.register_callback(current);\n  }\n};\n\nstruct BufferedExecutionAwaiter {\n  std::queue\u0026lt;std::coroutine_handle\u0026lt;\u0026gt;\u0026gt;\u0026amp; taskQueue;\n  /* .... */\n  std::coroutine_handle\u0026lt;\u0026gt; await_suspend(std::coroutine_handle\u0026lt;\u0026gt; current) {\n    if (taskQueue.empty()) {\n       return current;\n    }\n    auto next \u003d list.front();\n    taskQueue.pop();\n    taskQueue.push(current);\n    return next;\n  }\n};\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cp\u003e{rule:cpp:S6366} - conditionally suspending current coroutine in optimal way\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "pitfall",
      "since-c++20"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5273",
    "name": "Appropriate size arguments should be passed to \"strncat\" and \"strlcpy\"",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003cp\u003eSize argument should be based on the size of the destination buffer to to prevent buffer overflows.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe string manipulation functions \u003ccode\u003estrncat\u003c/code\u003e, \u003ccode\u003estrlcat\u003c/code\u003e and \u003ccode\u003estrlcpy\u003c/code\u003e require a size argument that describes how\nmany bytes from the source buffer are used at most. In many situations the size of the source buffer is unknown, which is why the size argument for\nthese functions should be based on the size of the destination buffer. This helps to prevent buffer overflows.\u003c/p\u003e\n\u003cp\u003eNote that \u003ccode\u003estrncat\u003c/code\u003e always adds a terminating null character at the end of the appended characters; therefore, the size argument should\nbe smaller than the size of the destination to leave enough space for the null character.\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;string.h\u0026gt;\n\nvoid foo(const char *src) {\n  char dst[10] \u003d {0};\n  strlcpy(dst, src, sizeof(src)); // Noncompliant: size of destination should be used.\n  printf(\"%s\", dst);\n}\n\u003c/pre\u003e\n\u003ch2\u003eWhat is the potential impact?\u003c/h2\u003e\n\u003cp\u003eBy using the source buffer’s size to determine the size argument for \u003ccode\u003estrncat\u003c/code\u003e, \u003ccode\u003estrlcat\u003c/code\u003e or \u003ccode\u003estrlcpy\u003c/code\u003e, the\nprogram becomes vulnerable to buffer overflows which pose a security risk.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eTo prevent potential buffer overflows, use the size of the destination buffer to determine the correct size argument for \u003ccode\u003estrncat\u003c/code\u003e,\n\u003ccode\u003estrlcat\u003c/code\u003e and \u003ccode\u003estrlcpy\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eGoing the extra mile\u003c/h3\u003e\n\u003cp\u003eBuffer overflows occur when a program writes data beyond the boundaries of a buffer and can lead to memory corruption and potential security\nvulnerabilities. Attackers can use buffer overflows to overwrite critical data, execute arbitrary code, or gain unauthorized access to a system. To\nmitigate this risk, developers must carefully manage buffer sizes (, use secure coding practices, and employ techniques like input validation and\nbounds checking).\u003c/p\u003e\n\u003cp\u003eIn C++, manual string, i.e., buffer manipulations are considered a code smell. Instead, the \u003ccode\u003estd::string\u003c/code\u003e type should be used to manage\nbuffers, which guarantees safe buffer manipulations.\u003c/p\u003e\n\u003cp\u003eInstead of manually concatenating two buffers using \u003ccode\u003estrncat\u003c/code\u003e, for instance, \u003ccode\u003estd::string\u003c/code\u003e allows this operation to be\nperformed in a much more convenient manner as shown in the following code:\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;string\u0026gt;\n\nvoid buz(std::string const \u0026amp;s) {\n  std::string t \u003d \"Hello, \" + s;\n  std::cout \u0026lt;\u0026lt; t \u0026lt;\u0026lt; \u0027\\n\u0027;\n}\n\u003c/pre\u003e\n\u003cp\u003eIn addition, the \u003ccode\u003estd::format\u003c/code\u003e function allows one to format strings according to a user-specified format and returns the result as a\nstring as shown in what follows:\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;format\u0026gt;\n#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;string\u0026gt;\n\nvoid tar(std::string const \u0026amp;s) {\n  std::string t \u003d std::format(\"Hello, World! Greetings {}\\n\", s);\n  std::cout \u0026lt;\u0026lt; t \u0026lt;\u0026lt; \u0027\\n\u0027;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;string.h\u0026gt;\n\nvoid foo(const char *src) {\n  char dst[10] \u003d {0};\n  strlcpy(dst, src, sizeof(src)); // Noncompliant: size of `dst` should be used.\n  printf(\"%s\", dst);\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;string.h\u0026gt;\n\nvoid foo(const char *src) {\n  char dst[10] \u003d {0};\n  // `strlcpy` copies up to size - 1 characters from the NUL-terminated string\n  // src to dst, NUL-terminating the result.\n  strlcpy(dst, src, sizeof(dst)); // Compliant: using `dst`\u0027s size avoid prevents buffer overflows.\n  printf(\"%s\", dst);\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;string.h\u0026gt;\n\nvoid bar(const char *src) {\n  char dst[256] \u003d \"Hello, \";\n  strncat(dst, src, sizeof(src)); // Noncompliant: incorrect size used.\n  printf(\"%s\\n\", dst);\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;string.h\u0026gt;\n\nvoid bar(const char *src) {\n  char dst[256] \u003d \"Hello, \";\n  // `strncat` always adds a terminating null character at the end of the appended\n  // characters, which is the reason for the `- 1`.\n  strncat(dst, src, sizeof(dst) - strlen(dst) - 1); // Compliant: uses only `dst` to compute size.\n  printf(\"%s\\n\", dst);\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eConference presentations\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CppCon 2018 - \u003ca href\u003d\"https://www.youtube.com/watch?v\u003d0S0QgQd75Sw\u0026amp;ab_channel\u003dCppCon\"\u003eSoftware Vulnerabilities in C and C++\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca\n  href\u003d\"https://wiki.sei.cmu.edu/confluence/display/c/STR31-C.+Guarantee+that+storage+for+strings+has+sufficient+space+for+character+data+and+the+null+terminator\"\u003eSTR31-C. Guarantee that storage for strings has sufficient space for character data and the null terminator\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/121.html\"\u003e121 Stack-based Buffer Overflow\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/122.html\"\u003e122 Heap-based Buffer Overflow\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/676.html\"\u003e676 Use of Potentially Dangerous Function\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eSize argument should be based on the size of the destination buffer to to prevent buffer overflows.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe string manipulation functions \u003ccode\u003estrncat\u003c/code\u003e, \u003ccode\u003estrlcat\u003c/code\u003e and \u003ccode\u003estrlcpy\u003c/code\u003e require a size argument that describes how\nmany bytes from the source buffer are used at most. In many situations the size of the source buffer is unknown, which is why the size argument for\nthese functions should be based on the size of the destination buffer. This helps to prevent buffer overflows.\u003c/p\u003e\n\u003cp\u003eNote that \u003ccode\u003estrncat\u003c/code\u003e always adds a terminating null character at the end of the appended characters; therefore, the size argument should\nbe smaller than the size of the destination to leave enough space for the null character.\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;string.h\u0026gt;\n\nvoid foo(const char *src) {\n  char dst[10] \u003d {0};\n  strlcpy(dst, src, sizeof(src)); // Noncompliant: size of destination should be used.\n  printf(\"%s\", dst);\n}\n\u003c/pre\u003e\n\u003ch2\u003eWhat is the potential impact?\u003c/h2\u003e\n\u003cp\u003eBy using the source buffer’s size to determine the size argument for \u003ccode\u003estrncat\u003c/code\u003e, \u003ccode\u003estrlcat\u003c/code\u003e or \u003ccode\u003estrlcpy\u003c/code\u003e, the\nprogram becomes vulnerable to buffer overflows which pose a security risk.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eTo prevent potential buffer overflows, use the size of the destination buffer to determine the correct size argument for \u003ccode\u003estrncat\u003c/code\u003e,\n\u003ccode\u003estrlcat\u003c/code\u003e and \u003ccode\u003estrlcpy\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eGoing the extra mile\u003c/h3\u003e\n\u003cp\u003eBuffer overflows occur when a program writes data beyond the boundaries of a buffer and can lead to memory corruption and potential security\nvulnerabilities. Attackers can use buffer overflows to overwrite critical data, execute arbitrary code, or gain unauthorized access to a system. To\nmitigate this risk, developers must carefully manage buffer sizes (, use secure coding practices, and employ techniques like input validation and\nbounds checking).\u003c/p\u003e\n\u003cp\u003eIn C++, manual string, i.e., buffer manipulations are considered a code smell. Instead, the \u003ccode\u003estd::string\u003c/code\u003e type should be used to manage\nbuffers, which guarantees safe buffer manipulations.\u003c/p\u003e\n\u003cp\u003eInstead of manually concatenating two buffers using \u003ccode\u003estrncat\u003c/code\u003e, for instance, \u003ccode\u003estd::string\u003c/code\u003e allows this operation to be\nperformed in a much more convenient manner as shown in the following code:\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;string\u0026gt;\n\nvoid buz(std::string const \u0026amp;s) {\n  std::string t \u003d \"Hello, \" + s;\n  std::cout \u0026lt;\u0026lt; t \u0026lt;\u0026lt; \u0027\\n\u0027;\n}\n\u003c/pre\u003e\n\u003cp\u003eIn addition, the \u003ccode\u003estd::format\u003c/code\u003e function allows one to format strings according to a user-specified format and returns the result as a\nstring as shown in what follows:\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;format\u0026gt;\n#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;string\u0026gt;\n\nvoid tar(std::string const \u0026amp;s) {\n  std::string t \u003d std::format(\"Hello, World! Greetings {}\\n\", s);\n  std::cout \u0026lt;\u0026lt; t \u0026lt;\u0026lt; \u0027\\n\u0027;\n}\n\u003c/pre\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;string.h\u0026gt;\n\nvoid foo(const char *src) {\n  char dst[10] \u003d {0};\n  strlcpy(dst, src, sizeof(src)); // Noncompliant: size of `dst` should be used.\n  printf(\"%s\", dst);\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;string.h\u0026gt;\n\nvoid foo(const char *src) {\n  char dst[10] \u003d {0};\n  // `strlcpy` copies up to size - 1 characters from the NUL-terminated string\n  // src to dst, NUL-terminating the result.\n  strlcpy(dst, src, sizeof(dst)); // Compliant: using `dst`\u0027s size avoid prevents buffer overflows.\n  printf(\"%s\", dst);\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;string.h\u0026gt;\n\nvoid bar(const char *src) {\n  char dst[256] \u003d \"Hello, \";\n  strncat(dst, src, sizeof(src)); // Noncompliant: incorrect size used.\n  printf(\"%s\\n\", dst);\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;string.h\u0026gt;\n\nvoid bar(const char *src) {\n  char dst[256] \u003d \"Hello, \";\n  // `strncat` always adds a terminating null character at the end of the appended\n  // characters, which is the reason for the `- 1`.\n  strncat(dst, src, sizeof(dst) - strlen(dst) - 1); // Compliant: uses only `dst` to compute size.\n  printf(\"%s\\n\", dst);\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eConference presentations\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CppCon 2018 - \u003ca href\u003d\"https://www.youtube.com/watch?v\u003d0S0QgQd75Sw\u0026amp;ab_channel\u003dCppCon\"\u003eSoftware Vulnerabilities in C and C++\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca\n  href\u003d\"https://wiki.sei.cmu.edu/confluence/display/c/STR31-C.+Guarantee+that+storage+for+strings+has+sufficient+space+for+character+data+and+the+null+terminator\"\u003eSTR31-C. Guarantee that storage for strings has sufficient space for character data and the null terminator\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/121.html\"\u003e121 Stack-based Buffer Overflow\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/122.html\"\u003e122 Heap-based Buffer Overflow\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/676.html\"\u003e676 Use of Potentially Dangerous Function\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "suspicious",
      "symbolic-execution"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6483",
    "name": "Width, alignment, and padding format options should be used consistently",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eIn formatting functions like std::format, replacement fields can add format specifications as a list of options. For example,\n\u003ccode\u003estd::format(\"{:*\u0026gt;5}\", d);\u003c/code\u003e will display \u003ccode\u003ed\u003c/code\u003e aligned to the right with a padding of \u0027*\u0027 to its left so that the display is\nalways at least five characters wide.\u003c/p\u003e\n\u003cp\u003eSome of these options work together, and mentioning one without the other can lead to confusing code where it is unclear to the reader how the\noutput will look. The same can happen if the options have incompatible values.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The alignment or the padding options are set, but the width option is not specified, leading to no actual padding. \u003c/li\u003e\n  \u003cli\u003e Both a character padding and a 0 padding are specified on a numerical value, leading to the 0 padding being ignored. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid print() {\n  // Noncompliant, filling with no width has no effect\n  std::cout \u0026lt;\u0026lt; std::format(\"{:*\u0026gt;}\\n\", \"filled\");\n  // Noncompliant, filling with both * and 0 result in 0 being ignored\n  std::cout \u0026lt;\u0026lt; std::format(\"{:*\u0026gt;05}\\n\", 12);\n  // Noncompliant, padding with 0 when no width is specified does nothing\n  std::cout \u0026lt;\u0026lt; std::format(\"{:0}\\n\", 12);\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid print() {\n  std::cout \u0026lt;\u0026lt; std::format(\"{:*\u0026gt;10}\\n\", \"filled\");\n  std::cout \u0026lt;\u0026lt; std::format(\"{:*\u0026gt;5}\\n\", 12);\n  std::cout \u0026lt;\u0026lt; std::format(\"{:04}\\n\", 12);\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eIn formatting functions like std::format, replacement fields can add format specifications as a list of options. For example,\n\u003ccode\u003estd::format(\"{:*\u0026gt;5}\", d);\u003c/code\u003e will display \u003ccode\u003ed\u003c/code\u003e aligned to the right with a padding of \u0027*\u0027 to its left so that the display is\nalways at least five characters wide.\u003c/p\u003e\n\u003cp\u003eSome of these options work together, and mentioning one without the other can lead to confusing code where it is unclear to the reader how the\noutput will look. The same can happen if the options have incompatible values.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The alignment or the padding options are set, but the width option is not specified, leading to no actual padding. \u003c/li\u003e\n  \u003cli\u003e Both a character padding and a 0 padding are specified on a numerical value, leading to the 0 padding being ignored. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid print() {\n  // Noncompliant, filling with no width has no effect\n  std::cout \u0026lt;\u0026lt; std::format(\"{:*\u0026gt;}\\n\", \"filled\");\n  // Noncompliant, filling with both * and 0 result in 0 being ignored\n  std::cout \u0026lt;\u0026lt; std::format(\"{:*\u0026gt;05}\\n\", 12);\n  // Noncompliant, padding with 0 when no width is specified does nothing\n  std::cout \u0026lt;\u0026lt; std::format(\"{:0}\\n\", 12);\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid print() {\n  std::cout \u0026lt;\u0026lt; std::format(\"{:*\u0026gt;10}\\n\", \"filled\");\n  std::cout \u0026lt;\u0026lt; std::format(\"{:*\u0026gt;5}\\n\", 12);\n  std::cout \u0026lt;\u0026lt; std::format(\"{:04}\\n\", 12);\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "clumsy",
      "since-c++20",
      "unused"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5274",
    "name": "\"std::move\" should only be added when necessary",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eUsually, when copying an object, the source object is unchanged, meaning all resources owned by the source objects must be duplicated during the\ncopy operation. If the source object is no longer used, this duplication is inefficient. Since C++11, a move semantic mechanism has been added to\ndetect such cases and replace the expensive copy with a much cheaper move operation that will transfer resources.\u003c/p\u003e\n\u003cp\u003eThe cornerstone of move semantics is detecting during a \"copy\" whether the source object will be reused or not. There are three situations:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The object is a temporary object with no name, and if it can’t be named, it can’t be used \u003c/li\u003e\n  \u003cli\u003e The object is used in some specific places, such as a return statement \u003c/li\u003e\n  \u003cli\u003e The user explicitly promises to the compiler that they won’t care for the object’s current value any longer. They do so by using the specific\n  cast operation named \u003ccode\u003estd::move\u003c/code\u003e. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIf the user writes \u003ccode\u003estd::move\u003c/code\u003e in one situation that is already handled by the first two cases, it has two drawbacks:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e It is clumsy, useless code, which makes understanding the code more complex \u003c/li\u003e\n  \u003cli\u003e In some cases, it can decrease performances because this can deactivate another optimization of the compiler, named copy elision. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWhen copy elision occurs, the object is neither copied nor moved (even if the copy/move constructors have side effects). The two objects are\ncollapsed into only one memory location. The moment when copy elision occurs is compiler-dependent but is mandatory in the following cases:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e in a return statement, if the returned object is a prvalue of the same class type as the function return type \u003c/li\u003e\n  \u003cli\u003e in the initialization of a variable, if the initializer expression is a prvalue of the same class type as the variable type \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis rule reports an issue when the use of \u003ccode\u003estd::move\u003c/code\u003e prevents the copy elision from happening.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nclass A {};\nA getA();\n\nA f() {\n  A a \u003d std::move(getA()); // Noncompliant, prevents copy elision\n  std::vector\u0026lt;A\u0026gt; v;\n  v.push_back(std::move(getA())); // Noncompliant\n  return std::move(a); // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nclass A {};\nA getA();\n\nA f() {\n  A a \u003d getA(); // Compliant\n  std::vector\u0026lt;A\u0026gt; v;\n  v.push_back(getA()); // Compliant\n  return a; // Compliant\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/copy_elision\"\u003eCopy elision\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/utility/move\"\u003estd::move\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f48-dont-return-stdmovelocal\"\u003eF.48: Don’t \u003ccode\u003ereturn\n  std::move(local)\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eUsually, when copying an object, the source object is unchanged, meaning all resources owned by the source objects must be duplicated during the\ncopy operation. If the source object is no longer used, this duplication is inefficient. Since C++11, a move semantic mechanism has been added to\ndetect such cases and replace the expensive copy with a much cheaper move operation that will transfer resources.\u003c/p\u003e\n\u003cp\u003eThe cornerstone of move semantics is detecting during a \"copy\" whether the source object will be reused or not. There are three situations:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The object is a temporary object with no name, and if it can’t be named, it can’t be used \u003c/li\u003e\n  \u003cli\u003e The object is used in some specific places, such as a return statement \u003c/li\u003e\n  \u003cli\u003e The user explicitly promises to the compiler that they won’t care for the object’s current value any longer. They do so by using the specific\n  cast operation named \u003ccode\u003estd::move\u003c/code\u003e. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIf the user writes \u003ccode\u003estd::move\u003c/code\u003e in one situation that is already handled by the first two cases, it has two drawbacks:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e It is clumsy, useless code, which makes understanding the code more complex \u003c/li\u003e\n  \u003cli\u003e In some cases, it can decrease performances because this can deactivate another optimization of the compiler, named copy elision. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWhen copy elision occurs, the object is neither copied nor moved (even if the copy/move constructors have side effects). The two objects are\ncollapsed into only one memory location. The moment when copy elision occurs is compiler-dependent but is mandatory in the following cases:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e in a return statement, if the returned object is a prvalue of the same class type as the function return type \u003c/li\u003e\n  \u003cli\u003e in the initialization of a variable, if the initializer expression is a prvalue of the same class type as the variable type \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis rule reports an issue when the use of \u003ccode\u003estd::move\u003c/code\u003e prevents the copy elision from happening.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nclass A {};\nA getA();\n\nA f() {\n  A a \u003d std::move(getA()); // Noncompliant, prevents copy elision\n  std::vector\u0026lt;A\u0026gt; v;\n  v.push_back(std::move(getA())); // Noncompliant\n  return std::move(a); // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nclass A {};\nA getA();\n\nA f() {\n  A a \u003d getA(); // Compliant\n  std::vector\u0026lt;A\u0026gt; v;\n  v.push_back(getA()); // Compliant\n  return a; // Compliant\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/copy_elision\"\u003eCopy elision\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/utility/move\"\u003estd::move\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f48-dont-return-stdmovelocal\"\u003eF.48: Don’t \u003ccode\u003ereturn\n  std::move(local)\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "bad-practice",
      "clumsy",
      "cppcoreguidelines",
      "performance",
      "since-c++11"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6000",
    "name": "\"std::visit\" should be used to switch on the type of the current value in a \"std::variant\"",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "MODULAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003estd::variant\u003c/code\u003e is a type-safe union that can hold values of a type out of a fixed list of types.\u003c/p\u003e\n\u003cp\u003eDepending on the current alternative inside a \u003ccode\u003evariant\u003c/code\u003e, it is common to execute dedicated code. There are basically two ways to achieve\nthat:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Writing code that checks the current alternative, then getting it and running specific code \u003c/li\u003e\n  \u003cli\u003e Letting \u003ccode\u003estd::visit\u003c/code\u003e perform the check and select the code to run by using overload resolution with the different alternatives \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe second option is usually preferable:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e It requires less boilerplate code. \u003c/li\u003e\n  \u003cli\u003e It is easy to handle multiple similar alternatives together if desired. \u003c/li\u003e\n  \u003cli\u003e It is usually more robust: if a new alternative is added to the variant, but the visitor does not support it, it will not compile. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis rule raises an issue when \u003ccode\u003evariant::index\u003c/code\u003e is called, or when \u003ccode\u003evariant::holds_alternative\u003c/code\u003e or\n\u003ccode\u003evariant::get_if\u003c/code\u003e is used in a series of \u003ccode\u003eif\u003c/code\u003e - \u003ccode\u003eelse if\u003c/code\u003e (calling one of these functions in isolation can be an\nacceptable lightweight alternative to \u003ccode\u003estd::visit\u003c/code\u003e in some cases).\u003c/p\u003e\n\u003cp\u003eNote: When defining the visitor of a variant, it can be nicer to use a series of lambdas by making use of \u003ca\nhref\u003d\"https://www.bfilipek.com/2019/02/2lines3featuresoverload.html\"\u003ethe \u003cem\u003eoverloaded\u003c/em\u003e pattern\u003c/a\u003e\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nusing Variant \u003d std::variant\u0026lt;int, float, string\u0026gt;;\nvoid printType1(Variant const \u0026amp;v) {\n    switch(v.index()) { // Noncompliant\n        case 0: cout \u0026lt;\u0026lt; \"int \" \u0026lt;\u0026lt;get\u0026lt;int\u0026gt;(v) \u0026lt;\u0026lt; \"\\n\"; break;\n        case 1: cout \u0026lt;\u0026lt; \"float \" \u0026lt;\u0026lt;get\u0026lt;float\u0026gt;(v) \u0026lt;\u0026lt; \"\\n\"; break;\n        case 2: cout \u0026lt;\u0026lt; \"string \" \u0026lt;\u0026lt;get\u0026lt;string\u0026gt;(v) \u0026lt;\u0026lt; \"\\n\";break;\n    }\n}\nvoid printType2(Variant const \u0026amp;v) {\n    if(auto p \u003d get_if\u0026lt;int\u0026gt;(\u0026amp;v)) { // Noncompliant\n        cout \u0026lt;\u0026lt; \"int \" \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; \"\\n\";\n    } else if (auto p \u003d get_if\u0026lt;float\u0026gt;(\u0026amp;v)) {\n        cout \u0026lt;\u0026lt; \"float \" \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; \"\\n\";\n    } else if (auto p \u003d get_if\u0026lt;string\u0026gt;(\u0026amp;v)) {\n        cout \u0026lt;\u0026lt; \"string \" \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; \"\\n\";\n    }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nusing Variant \u003d std::variant\u0026lt;int, float, string\u0026gt;;\n\nstruct VariantPrinter {\n    void operator() (int i) { cout \u0026lt;\u0026lt; \"int \" \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \"\\n\"; }\n    void operator() (float f) { cout \u0026lt;\u0026lt; \"float \" \u0026lt;\u0026lt; f \u0026lt;\u0026lt; \"\\n\"; }\n    void operator() (std::string const \u0026amp;s) { cout \u0026lt;\u0026lt; \"string \" \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \"\\n\"; }\n};\n\nvoid printType3(Variant const \u0026amp;v) {\n    std::visit(VariantPrinter{}, v);\n}\n\n// Same principle, but using the overloaded pattern\nvoid printType4(Variant const \u0026amp;v) {\n    std::visit(overloaded{\n        [](int i){cout \u0026lt;\u0026lt; \"int \" \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \"\\n\";},\n        [](float f){cout \u0026lt;\u0026lt; \"float \" \u0026lt;\u0026lt; f \u0026lt;\u0026lt; \"\\n\";},\n        [](std::string const \u0026amp;s){cout \u0026lt;\u0026lt; \"string \" \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \"\\n\";}\n    }, v);\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003ccode\u003estd::variant\u003c/code\u003e is a type-safe union that can hold values of a type out of a fixed list of types.\u003c/p\u003e\n\u003cp\u003eDepending on the current alternative inside a \u003ccode\u003evariant\u003c/code\u003e, it is common to execute dedicated code. There are basically two ways to achieve\nthat:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Writing code that checks the current alternative, then getting it and running specific code \u003c/li\u003e\n  \u003cli\u003e Letting \u003ccode\u003estd::visit\u003c/code\u003e perform the check and select the code to run by using overload resolution with the different alternatives \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe second option is usually preferable:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e It requires less boilerplate code. \u003c/li\u003e\n  \u003cli\u003e It is easy to handle multiple similar alternatives together if desired. \u003c/li\u003e\n  \u003cli\u003e It is usually more robust: if a new alternative is added to the variant, but the visitor does not support it, it will not compile. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis rule raises an issue when \u003ccode\u003evariant::index\u003c/code\u003e is called, or when \u003ccode\u003evariant::holds_alternative\u003c/code\u003e or\n\u003ccode\u003evariant::get_if\u003c/code\u003e is used in a series of \u003ccode\u003eif\u003c/code\u003e - \u003ccode\u003eelse if\u003c/code\u003e (calling one of these functions in isolation can be an\nacceptable lightweight alternative to \u003ccode\u003estd::visit\u003c/code\u003e in some cases).\u003c/p\u003e\n\u003cp\u003eNote: When defining the visitor of a variant, it can be nicer to use a series of lambdas by making use of \u003ca\nhref\u003d\"https://www.bfilipek.com/2019/02/2lines3featuresoverload.html\"\u003ethe \u003cem\u003eoverloaded\u003c/em\u003e pattern\u003c/a\u003e\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nusing Variant \u003d std::variant\u0026lt;int, float, string\u0026gt;;\nvoid printType1(Variant const \u0026amp;v) {\n    switch(v.index()) { // Noncompliant\n        case 0: cout \u0026lt;\u0026lt; \"int \" \u0026lt;\u0026lt;get\u0026lt;int\u0026gt;(v) \u0026lt;\u0026lt; \"\\n\"; break;\n        case 1: cout \u0026lt;\u0026lt; \"float \" \u0026lt;\u0026lt;get\u0026lt;float\u0026gt;(v) \u0026lt;\u0026lt; \"\\n\"; break;\n        case 2: cout \u0026lt;\u0026lt; \"string \" \u0026lt;\u0026lt;get\u0026lt;string\u0026gt;(v) \u0026lt;\u0026lt; \"\\n\";break;\n    }\n}\nvoid printType2(Variant const \u0026amp;v) {\n    if(auto p \u003d get_if\u0026lt;int\u0026gt;(\u0026amp;v)) { // Noncompliant\n        cout \u0026lt;\u0026lt; \"int \" \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; \"\\n\";\n    } else if (auto p \u003d get_if\u0026lt;float\u0026gt;(\u0026amp;v)) {\n        cout \u0026lt;\u0026lt; \"float \" \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; \"\\n\";\n    } else if (auto p \u003d get_if\u0026lt;string\u0026gt;(\u0026amp;v)) {\n        cout \u0026lt;\u0026lt; \"string \" \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; \"\\n\";\n    }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nusing Variant \u003d std::variant\u0026lt;int, float, string\u0026gt;;\n\nstruct VariantPrinter {\n    void operator() (int i) { cout \u0026lt;\u0026lt; \"int \" \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \"\\n\"; }\n    void operator() (float f) { cout \u0026lt;\u0026lt; \"float \" \u0026lt;\u0026lt; f \u0026lt;\u0026lt; \"\\n\"; }\n    void operator() (std::string const \u0026amp;s) { cout \u0026lt;\u0026lt; \"string \" \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \"\\n\"; }\n};\n\nvoid printType3(Variant const \u0026amp;v) {\n    std::visit(VariantPrinter{}, v);\n}\n\n// Same principle, but using the overloaded pattern\nvoid printType4(Variant const \u0026amp;v) {\n    std::visit(overloaded{\n        [](int i){cout \u0026lt;\u0026lt; \"int \" \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \"\\n\";},\n        [](float f){cout \u0026lt;\u0026lt; \"float \" \u0026lt;\u0026lt; f \u0026lt;\u0026lt; \"\\n\";},\n        [](std::string const \u0026amp;s){cout \u0026lt;\u0026lt; \"string \" \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \"\\n\";}\n    }, v);\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "clumsy",
      "since-c++17"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6484",
    "name": "Concatenated \"std::format\" outputs should be replaced by a single invocation",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003estd::format\u003c/code\u003e accepts a format string composed of ordinary text and replacement fields (surrounded with \u003ccode\u003e{}\u003c/code\u003e) that are\nreplaced with a textual representation of the next \u003ccode\u003estd::format\u003c/code\u003e arguments. This allows generating a complex string with a single\ninvocation of \u003ccode\u003estd::format\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eSince calls to \u003ccode\u003estd::format\u003c/code\u003e produce string objects, it is possible to concatenate them with other string objects or string literals.\nHowever, compared to a single \u003ccode\u003estd::format\u003c/code\u003e invocation with an adjusted format string, this concatenation is inefficient and less\nreadable.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when a concatenation an \u003ccode\u003estd::format\u003c/code\u003e invocation can be replaced with a simple \u003ccode\u003estd::format\u003c/code\u003e\ninvocation.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid formatExamples(std::string str, char const* cstr, int i) {\n  std::string s1 \u003d \"You have been greeted \" + std::format(\"{}\", i) + \" times.\"; // Noncompliant\n  std::string s2 \u003d \"Hello \" + std::format(\"{:*^20}\", str) + \"! \" + std::format(\"{:-\u0026gt;15}\", cstr) + \u0027.\u0027; // Noncompliant\n}\n\nstd::string fullName(std::string name, std::string secondName, std::string surname, std::size_t number) {\n  // Compliant, as the formatted output depends on runtime properties\n  std::string result \u003d std::format(\"({}) {}\", number, name);\n  if (!secondName.empty()) {\n     result +\u003d \" \";\n     result +\u003d secondName.front();\n  }\n  result +\u003d surname;\n  return result;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid formatExamples(std::string str, char const* cstr, int i) {\n  std::string s1 \u003d std::format(\"You have been greeted {} times.\", i); // Compliant\n  std::string s2 \u003d std::format(\"Hello {:*^20}! {:-\u0026gt;15}.\", str, cstr); // Compliant\n  std::string s3 \u003d std::format(\"Welcome {:*^20}! {:-\u0026gt;15}.\", str, cstr); // Compliant\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003ccode\u003estd::format\u003c/code\u003e accepts a format string composed of ordinary text and replacement fields (surrounded with \u003ccode\u003e{}\u003c/code\u003e) that are\nreplaced with a textual representation of the next \u003ccode\u003estd::format\u003c/code\u003e arguments. This allows generating a complex string with a single\ninvocation of \u003ccode\u003estd::format\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eSince calls to \u003ccode\u003estd::format\u003c/code\u003e produce string objects, it is possible to concatenate them with other string objects or string literals.\nHowever, compared to a single \u003ccode\u003estd::format\u003c/code\u003e invocation with an adjusted format string, this concatenation is inefficient and less\nreadable.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when a concatenation an \u003ccode\u003estd::format\u003c/code\u003e invocation can be replaced with a simple \u003ccode\u003estd::format\u003c/code\u003e\ninvocation.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid formatExamples(std::string str, char const* cstr, int i) {\n  std::string s1 \u003d \"You have been greeted \" + std::format(\"{}\", i) + \" times.\"; // Noncompliant\n  std::string s2 \u003d \"Hello \" + std::format(\"{:*^20}\", str) + \"! \" + std::format(\"{:-\u0026gt;15}\", cstr) + \u0027.\u0027; // Noncompliant\n}\n\nstd::string fullName(std::string name, std::string secondName, std::string surname, std::size_t number) {\n  // Compliant, as the formatted output depends on runtime properties\n  std::string result \u003d std::format(\"({}) {}\", number, name);\n  if (!secondName.empty()) {\n     result +\u003d \" \";\n     result +\u003d secondName.front();\n  }\n  result +\u003d surname;\n  return result;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid formatExamples(std::string str, char const* cstr, int i) {\n  std::string s1 \u003d std::format(\"You have been greeted {} times.\", i); // Compliant\n  std::string s2 \u003d std::format(\"Hello {:*^20}! {:-\u0026gt;15}.\", str, cstr); // Compliant\n  std::string s3 \u003d std::format(\"Welcome {:*^20}! {:-\u0026gt;15}.\", str, cstr); // Compliant\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "clumsy",
      "performance",
      "since-c++20"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1905",
    "name": "Redundant casts should not be used",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eCasting expressions are utilized to convert one data type to another, such as transforming an integer into a string. This is especially crucial in\nstrongly typed languages like C, C++, C#, Java, Python, and others.\u003c/p\u003e\n\u003cp\u003eHowever, there are instances where casting expressions are not needed. These include situations like:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e casting a variable to its own type \u003c/li\u003e\n  \u003cli\u003e casting a subclass to a parent class (in the case of polymorphism) \u003c/li\u003e\n  \u003cli\u003e the programming language is capable of automatically converting the given type to another \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThese scenarios are considered unnecessary casting expressions. They can complicate the code and make it more difficult to understand, without\noffering any advantages.\u003c/p\u003e\n\u003cp\u003eAs a result, it’s generally advised to avoid unnecessary casting expressions. Instead, rely on the language’s type system to ensure type safety and\ncode clarity.\u003c/p\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eIn some rare cases, a redundant cast might be justifiable. For example, when casting from platform dependant types: your cast might be redundant on\none platform but not on the others.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eTo fix your code, remove the unnecessary casting expression.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nint example(int i) {\n  int result \u003d static_cast\u0026lt;int\u0026gt;(i + 42); // Noncompliant\n  return (int) result; // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nint example(int i) {\n int result \u003d i + 42;\n return result;\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Wikipedia - \u003ca href\u003d\"https://en.wikipedia.org/wiki/Type_conversion\"\u003eType Conversion\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e Wikipedia - \u003ca href\u003d\"https://en.wikipedia.org/wiki/Strong_and_weak_typing\"\u003eStrong and Weak Typing\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e Wikipedia - \u003ca href\u003d\"https://en.wikipedia.org/wiki/Polymorphism_(computer_science)\"\u003e Polymorphism (Computer Science)\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eCasting expressions are utilized to convert one data type to another, such as transforming an integer into a string. This is especially crucial in\nstrongly typed languages like C, C++, C#, Java, Python, and others.\u003c/p\u003e\n\u003cp\u003eHowever, there are instances where casting expressions are not needed. These include situations like:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e casting a variable to its own type \u003c/li\u003e\n  \u003cli\u003e casting a subclass to a parent class (in the case of polymorphism) \u003c/li\u003e\n  \u003cli\u003e the programming language is capable of automatically converting the given type to another \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThese scenarios are considered unnecessary casting expressions. They can complicate the code and make it more difficult to understand, without\noffering any advantages.\u003c/p\u003e\n\u003cp\u003eAs a result, it’s generally advised to avoid unnecessary casting expressions. Instead, rely on the language’s type system to ensure type safety and\ncode clarity.\u003c/p\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eIn some rare cases, a redundant cast might be justifiable. For example, when casting from platform dependant types: your cast might be redundant on\none platform but not on the others.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eTo fix your code, remove the unnecessary casting expression.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nint example(int i) {\n  int result \u003d static_cast\u0026lt;int\u0026gt;(i + 42); // Noncompliant\n  return (int) result; // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nint example(int i) {\n int result \u003d i + 42;\n return result;\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Wikipedia - \u003ca href\u003d\"https://en.wikipedia.org/wiki/Type_conversion\"\u003eType Conversion\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e Wikipedia - \u003ca href\u003d\"https://en.wikipedia.org/wiki/Strong_and_weak_typing\"\u003eStrong and Weak Typing\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e Wikipedia - \u003ca href\u003d\"https://en.wikipedia.org/wiki/Polymorphism_(computer_science)\"\u003e Polymorphism (Computer Science)\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "clumsy",
      "redundant"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1909",
    "name": "\"goto\" statements should not be used to jump into blocks",
    "defaultSeverity": "BLOCKER",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eUse of \u003ccode\u003egoto\u003c/code\u003e can lead to programs that are extremely difficult to comprehend and analyse, and possibly to unspecified behavior.\u003c/p\u003e\n\u003cp\u003eUnfortunately, removing \u003ccode\u003egoto\u003c/code\u003e from some code can lead to a rewritten version that is even more difficult to understand than the\noriginal. Therefore, limited use of \u003ccode\u003egoto\u003c/code\u003e is sometimes advised.\u003c/p\u003e\n\u003cp\u003eHowever, the use of \u003ccode\u003egoto\u003c/code\u003e to jump into or out of a sub-block of code, such as into the body of a \u003ccode\u003efor\u003c/code\u003e loop is never\nacceptable, because it is extremely difficult to understand and will likely yield results other than what is intended.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid f1 (int a) {\n  if (a \u0026lt;\u003d0) {\n    goto L2;  // Noncompliant; jumps into a different block\n  }\n\n  if (a \u003d\u003d 0) {\n  {\n    goto L1; // Compliant\n  }\n  goto L2;  // Noncompliant; jumps into a block\n\nL1:\n  for (int i \u003d 0; i \u0026lt; a; i++) {\n  L2:\n    //...  Should only have come here with a \u0026gt;\u003d0. Loop is infinite if a \u0026lt; 0\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid f1 (int a) {\n  if (a \u0026lt;\u003d0) {\n    // ...\n  }\n\n  if (a \u003d\u003d 0) {\n  {\n    goto L1; // Compliant\n  }\n\nL1:\n  for (int i \u003d 0; i \u0026lt; a; i++) {\n  L2:\n    //...\n  }\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 6-6-1 - Any label referenced by a goto statement shall be declared in the same block, or in a block enclosing the goto\n  statement \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 15.3 - Any label referenced by a goto statement shall be declared in the same block, or in a block enclosing the goto statement\n  \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eUse of \u003ccode\u003egoto\u003c/code\u003e can lead to programs that are extremely difficult to comprehend and analyse, and possibly to unspecified behavior.\u003c/p\u003e\n\u003cp\u003eUnfortunately, removing \u003ccode\u003egoto\u003c/code\u003e from some code can lead to a rewritten version that is even more difficult to understand than the\noriginal. Therefore, limited use of \u003ccode\u003egoto\u003c/code\u003e is sometimes advised.\u003c/p\u003e\n\u003cp\u003eHowever, the use of \u003ccode\u003egoto\u003c/code\u003e to jump into or out of a sub-block of code, such as into the body of a \u003ccode\u003efor\u003c/code\u003e loop is never\nacceptable, because it is extremely difficult to understand and will likely yield results other than what is intended.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid f1 (int a) {\n  if (a \u0026lt;\u003d0) {\n    goto L2;  // Noncompliant; jumps into a different block\n  }\n\n  if (a \u003d\u003d 0) {\n  {\n    goto L1; // Compliant\n  }\n  goto L2;  // Noncompliant; jumps into a block\n\nL1:\n  for (int i \u003d 0; i \u0026lt; a; i++) {\n  L2:\n    //...  Should only have come here with a \u0026gt;\u003d0. Loop is infinite if a \u0026lt; 0\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid f1 (int a) {\n  if (a \u0026lt;\u003d0) {\n    // ...\n  }\n\n  if (a \u003d\u003d 0) {\n  {\n    goto L1; // Compliant\n  }\n\nL1:\n  for (int i \u003d 0; i \u0026lt; a; i++) {\n  L2:\n    //...\n  }\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 6-6-1 - Any label referenced by a goto statement shall be declared in the same block, or in a block enclosing the goto\n  statement \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 15.3 - Any label referenced by a goto statement shall be declared in the same block, or in a block enclosing the goto statement\n  \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "brain-overload",
      "pitfall"
    ],
    "deprecatedKeys": [
      "cpp:GotoLabelInNestedBlock"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1911",
    "name": "Obsolete POSIX functions should not be used",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eTo ensure future code portability, obsolete POSIX functions should be removed. Those functions, with their replacements are listed below:\u003c/p\u003e\n\u003ctable\u003e\n  \u003ccolgroup\u003e\n    \u003ccol style\u003d\"width: 50%;\"\u003e\n    \u003ccol style\u003d\"width: 50%;\"\u003e\n  \u003c/colgroup\u003e\n  \u003cthead\u003e\n    \u003ctr\u003e\n      \u003cth\u003eObsolete\u003c/th\u003e\n      \u003cth\u003eUse Instead\u003c/th\u003e\n    \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003easctime\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003estrftime\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003easctime_r\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003estrftime\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003ebcmp\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003ememcmp\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003ebcopy\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003ememmove memcpy\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003ebsd_signal\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003esigaction\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003ebzero\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003ememset\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003ectime\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003estrftime\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003eecvt\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003esprintf\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003efcvt\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003esprintf\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003eftime\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003eno replacement function\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003egcvt\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003esprintf\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003egetcontext\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003eRewrite to use POSIX threads.\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003egethostbyaddr\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003egetnameinfo\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003egethostbyname\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003egetaddrinfo\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003egetwd\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003egetcwd\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003eindex\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003estrchr\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003emakecontext\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003eRewrite to use POSIX threads.\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003emktemp\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003emkstemp\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003epthread_attr_getstackaddr\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003epthread_attr_getstack\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003epthread_attr_setstackaddr\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003epthread_attr_setstack\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003erand_r\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003erand\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003erindex\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003estrrchr\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003escalb\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003escalbln\u0027, \u0027scalblnf\u0027 or \u0027scalblnl\u0027 instead of this function\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003eswapcontext\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003eRewrite to use POSIX threads.\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003eualarm\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003e\u0027timer_create\u0027, \u0027timer_delete\u0027, \u0027timer_getoverrun\u0027, \u0027timer_gettime\u0027, or \u0027timer_settime\u0027 instead of this function\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003eusleep\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003e\u0027nanosleep\u0027 or \u0027setitimer\u0027 function\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003eutime\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003eutimensat\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003evfork\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003efork\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003ewcswcs\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003ewcsstr\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eTo ensure future code portability, obsolete POSIX functions should be removed. Those functions, with their replacements are listed below:\u003c/p\u003e\n\u003ctable\u003e\n  \u003ccolgroup\u003e\n    \u003ccol style\u003d\"width: 50%;\"\u003e\n    \u003ccol style\u003d\"width: 50%;\"\u003e\n  \u003c/colgroup\u003e\n  \u003cthead\u003e\n    \u003ctr\u003e\n      \u003cth\u003eObsolete\u003c/th\u003e\n      \u003cth\u003eUse Instead\u003c/th\u003e\n    \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003easctime\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003estrftime\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003easctime_r\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003estrftime\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003ebcmp\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003ememcmp\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003ebcopy\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003ememmove memcpy\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003ebsd_signal\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003esigaction\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003ebzero\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003ememset\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003ectime\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003estrftime\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003eecvt\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003esprintf\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003efcvt\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003esprintf\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003eftime\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003eno replacement function\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003egcvt\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003esprintf\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003egetcontext\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003eRewrite to use POSIX threads.\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003egethostbyaddr\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003egetnameinfo\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003egethostbyname\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003egetaddrinfo\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003egetwd\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003egetcwd\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003eindex\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003estrchr\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003emakecontext\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003eRewrite to use POSIX threads.\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003emktemp\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003emkstemp\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003epthread_attr_getstackaddr\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003epthread_attr_getstack\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003epthread_attr_setstackaddr\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003epthread_attr_setstack\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003erand_r\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003erand\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003erindex\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003estrrchr\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003escalb\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003escalbln\u0027, \u0027scalblnf\u0027 or \u0027scalblnl\u0027 instead of this function\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003eswapcontext\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003eRewrite to use POSIX threads.\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003eualarm\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003e\u0027timer_create\u0027, \u0027timer_delete\u0027, \u0027timer_getoverrun\u0027, \u0027timer_gettime\u0027, or \u0027timer_settime\u0027 instead of this function\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003eusleep\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003e\u0027nanosleep\u0027 or \u0027setitimer\u0027 function\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003eutime\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003eutimensat\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003evfork\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003efork\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003ewcswcs\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003ewcsstr\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cert",
      "obsolete"
    ],
    "deprecatedKeys": [
      "cpp:ObsoletePosixFunction"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1912",
    "name": "Non-reentrant POSIX functions should be replaced with their reentrant versions",
    "defaultSeverity": "BLOCKER",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eA function is called reentrant if it can be interrupted in the middle of its execution and then safely called again (\"re-entered\") before its\nprevious invocations complete execution.\u003c/p\u003e\n\u003cp\u003eIt is especially important that multi-threaded applications do not call the same non-reentrant function from different threads.\u003c/p\u003e\n\u003cp\u003eThis rule will trigger an issue each time a function in the configurable list is invoked.\u003c/p\u003e\n\u003cp\u003eA call will be matched differently depending on the presence of the scope resolution operator \u003ccode\u003e::\u003c/code\u003e in the function name from the\nconfigurable list.\u003c/p\u003e\n\u003cp\u003eFor example, \u003ccode\u003enamespace a { namespace b { void f(); } }\u003c/code\u003e can be matched with \"f\", \"b::f\", \"a::b::f\", \"::a::b::f\" (fully qualified name\nyielding most precise results).\u003c/p\u003e\n\u003cp\u003eIt is recommended to provide fully qualified names to the configurable list (i.e., start each name with \u003ccode\u003e::\u003c/code\u003e), even for the functions in\nthe global namespace.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cp\u003eGiven a function that includes \u003ccode\u003elocaltime\u003c/code\u003e:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;time.h\u0026gt;\n\nvoid print_date_and_time(struct tm *time_ptr)\n{\n  printf(\n    \"Current date and time: %d/%02d/%02d %02d:%02d:%02d\\n\",\n    time_ptr-\u0026gt;tm_year + 1900,\n    time_ptr-\u0026gt;tm_mon,\n    time_ptr-\u0026gt;tm_mday,\n    time_ptr-\u0026gt;tm_hour,\n    time_ptr-\u0026gt;tm_min,\n    time_ptr-\u0026gt;tm_sec);\n}\n\nvoid print_unix_epoch_date_and_time()\n{\n  time_t unix_epoch_time \u003d (time_t)0;\n  struct tm *local_time_ptr \u003d localtime(\u0026amp;unix_epoch_time); // Noncompliant, call to the non-reentrant localtime() function\n  print_date_and_time(local_time_ptr);\n}\n\nint main(int argc, char* argv[])\n{\n  time_t current_time;\n  struct tm *local_time_ptr;\n\n  time(\u0026amp;current_time);\n\n  local_time_ptr \u003d localtime(\u0026amp;current_time); // Noncompliant, call to the non-reentrant localtime() function\n\n  // As expected, this will print: Current date and time: 1970/00/01 01:00:00\n  print_unix_epoch_date_and_time();\n\n  // This will actually also print Current date and time: 1970/00/01 01:00:00\n  // Indeed, localtime() is non-reentrant, and always returns the same pointer\n  print_date_and_time(local_time_ptr);\n\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;time.h\u0026gt;\n\nvoid print_date_and_time(struct tm *time_ptr)\n{\n  printf(\n    \"Current date and time: %d/%02d/%02d %02d:%02d:%02d\\n\",\n    time_ptr-\u0026gt;tm_year + 1900,\n    time_ptr-\u0026gt;tm_mon,\n    time_ptr-\u0026gt;tm_mday,\n    time_ptr-\u0026gt;tm_hour,\n    time_ptr-\u0026gt;tm_min,\n    time_ptr-\u0026gt;tm_sec);\n}\n\nvoid print_unix_epoch_date_and_time()\n{\n  time_t unix_epoch_time \u003d (time_t)0;\n  struct tm local_time;\n  localtime_r(\u0026amp;unix_epoch_time, \u0026amp;local_time); // Compliant\n  print_date_and_time(\u0026amp;local_time);\n}\n\nint main(int argc, char* argv[])\n{\n  time_t current_time;\n  struct tm local_time;\n\n  time(\u0026amp;current_time);\n\n  localtime_r(\u0026amp;current_time, \u0026amp;local_time); // Compliant\n\n  // As expected, this will print: Current date and time: 1970/00/01 01:00:00\n  print_unix_epoch_date_and_time();\n\n  // As expected, this will print the current date and time\n  print_date_and_time(\u0026amp;local_time);\n\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/lookup\"\u003eName Lookup\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eA function is called reentrant if it can be interrupted in the middle of its execution and then safely called again (\"re-entered\") before its\nprevious invocations complete execution.\u003c/p\u003e\n\u003cp\u003eIt is especially important that multi-threaded applications do not call the same non-reentrant function from different threads.\u003c/p\u003e\n\u003cp\u003eThis rule will trigger an issue each time a function in the configurable list is invoked.\u003c/p\u003e\n\u003cp\u003eA call will be matched differently depending on the presence of the scope resolution operator \u003ccode\u003e::\u003c/code\u003e in the function name from the\nconfigurable list.\u003c/p\u003e\n\u003cp\u003eFor example, \u003ccode\u003enamespace a { namespace b { void f(); } }\u003c/code\u003e can be matched with \"f\", \"b::f\", \"a::b::f\", \"::a::b::f\" (fully qualified name\nyielding most precise results).\u003c/p\u003e\n\u003cp\u003eIt is recommended to provide fully qualified names to the configurable list (i.e., start each name with \u003ccode\u003e::\u003c/code\u003e), even for the functions in\nthe global namespace.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cp\u003eGiven a function that includes \u003ccode\u003elocaltime\u003c/code\u003e:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;time.h\u0026gt;\n\nvoid print_date_and_time(struct tm *time_ptr)\n{\n  printf(\n    \"Current date and time: %d/%02d/%02d %02d:%02d:%02d\\n\",\n    time_ptr-\u0026gt;tm_year + 1900,\n    time_ptr-\u0026gt;tm_mon,\n    time_ptr-\u0026gt;tm_mday,\n    time_ptr-\u0026gt;tm_hour,\n    time_ptr-\u0026gt;tm_min,\n    time_ptr-\u0026gt;tm_sec);\n}\n\nvoid print_unix_epoch_date_and_time()\n{\n  time_t unix_epoch_time \u003d (time_t)0;\n  struct tm *local_time_ptr \u003d localtime(\u0026amp;unix_epoch_time); // Noncompliant, call to the non-reentrant localtime() function\n  print_date_and_time(local_time_ptr);\n}\n\nint main(int argc, char* argv[])\n{\n  time_t current_time;\n  struct tm *local_time_ptr;\n\n  time(\u0026amp;current_time);\n\n  local_time_ptr \u003d localtime(\u0026amp;current_time); // Noncompliant, call to the non-reentrant localtime() function\n\n  // As expected, this will print: Current date and time: 1970/00/01 01:00:00\n  print_unix_epoch_date_and_time();\n\n  // This will actually also print Current date and time: 1970/00/01 01:00:00\n  // Indeed, localtime() is non-reentrant, and always returns the same pointer\n  print_date_and_time(local_time_ptr);\n\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;time.h\u0026gt;\n\nvoid print_date_and_time(struct tm *time_ptr)\n{\n  printf(\n    \"Current date and time: %d/%02d/%02d %02d:%02d:%02d\\n\",\n    time_ptr-\u0026gt;tm_year + 1900,\n    time_ptr-\u0026gt;tm_mon,\n    time_ptr-\u0026gt;tm_mday,\n    time_ptr-\u0026gt;tm_hour,\n    time_ptr-\u0026gt;tm_min,\n    time_ptr-\u0026gt;tm_sec);\n}\n\nvoid print_unix_epoch_date_and_time()\n{\n  time_t unix_epoch_time \u003d (time_t)0;\n  struct tm local_time;\n  localtime_r(\u0026amp;unix_epoch_time, \u0026amp;local_time); // Compliant\n  print_date_and_time(\u0026amp;local_time);\n}\n\nint main(int argc, char* argv[])\n{\n  time_t current_time;\n  struct tm local_time;\n\n  time(\u0026amp;current_time);\n\n  localtime_r(\u0026amp;current_time, \u0026amp;local_time); // Compliant\n\n  // As expected, this will print: Current date and time: 1970/00/01 01:00:00\n  print_unix_epoch_date_and_time();\n\n  // As expected, this will print the current date and time\n  print_date_and_time(\u0026amp;local_time);\n\n  return 0;\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/lookup\"\u003eName Lookup\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {
      "nonReentrantFunctionList": {
        "key": "nonReentrantFunctionList",
        "name": "nonReentrantFunctionList",
        "description": "List of non-reentrant functions",
        "defaultValue": "::asctime,::crypt,::ctermid,::ctime,::fgetgrent,::fgetpwent,::fgetspent,::getgrent,::getgrgid,::getgrnam,::gethostbyaddr,::gethostbyname,::gethostbyname2,::gethostent,::getlogin,::getnetbyaddr,::getnetbyname,::getnetent,::getnetgrent,::getprotobyname,::getprotobynumber,::getprotoent,::getpwent,::getpwnam,::getpwuid,::getrpcbyname,::getrpcbynumber,::getrpcent,::getservbyname,::getservbyport,::getservent,::getspent,::getspnam,::gmtime,::localtime,::sgetspent,::strtok,::ttyname",
        "type": "STRING",
        "multiple": false,
        "possibleValues": []
      }
    },
    "defaultParams": {
      "nonReentrantFunctionList": "::asctime,::crypt,::ctermid,::ctime,::fgetgrent,::fgetpwent,::fgetspent,::getgrent,::getgrgid,::getgrnam,::gethostbyaddr,::gethostbyname,::gethostbyname2,::gethostent,::getlogin,::getnetbyaddr,::getnetbyname,::getnetent,::getnetgrent,::getprotobyname,::getprotobynumber,::getprotoent,::getpwent,::getpwnam,::getpwuid,::getrpcbyname,::getrpcbynumber,::getrpcent,::getservbyname,::getservbyport,::getservent,::getspent,::getspnam,::gmtime,::localtime,::sgetspent,::strtok,::ttyname"
    },
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "multi-threading"
    ],
    "deprecatedKeys": [
      "cpp:NonReentrantFunction"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1913",
    "name": "\"sizeof(sizeof(...))\" should not be used",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eGiven an expression \u003ccode\u003ee\u003c/code\u003e of type \u003ccode\u003eT\u003c/code\u003e, \u003ccode\u003esizeof(e)\u003c/code\u003e returns the size in bytes of \u003ccode\u003eT\u003c/code\u003e. The\n\u003ccode\u003esizeof\u003c/code\u003e operator results in a value of type \u003ccode\u003esize_t\u003c/code\u003e. Also, \u003ccode\u003esizeof(e)\u003c/code\u003e has no side effects because \u003ccode\u003ee\u003c/code\u003e\nis not evaluated. Therefore, \u003ccode\u003esizeof(sizeof(e))\u003c/code\u003e is equivalent to \u003ccode\u003esizeof(size_t)\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eIn other words, \u003ccode\u003esizeof(sizeof(e))\u003c/code\u003e always gives the same result and does not depend on \u003ccode\u003ee\u003c/code\u003e, which is unlikely what was\nexpected.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eThis defect is usually the consequence of a typo, and the fix is to remove one level of \u003ccode\u003esizeof\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid function() {\n  char buffer[42];\n  char buffer2[sizeof(sizeof(buffer))]; // Noncompliant: a single sizeof() was intended\n\n  memcpy(buffer, \"Hello, world!\", strlen(\"Hello, world!\")+1);\n  memcpy(buffer2, buffer, sizeof(buffer)); // Buffer overflow\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid function() {\n  char buffer[42];\n  char buffer2[sizeof(buffer)]; // Compliant\n\n  memcpy(buffer, \"Hello, world!\", strlen(\"Hello, world!\")+1);\n  memcpy(buffer2, buffer, sizeof(buffer));\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/sizeof\"\u003e\u003ccode\u003esizeof\u003c/code\u003e operator\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eGiven an expression \u003ccode\u003ee\u003c/code\u003e of type \u003ccode\u003eT\u003c/code\u003e, \u003ccode\u003esizeof(e)\u003c/code\u003e returns the size in bytes of \u003ccode\u003eT\u003c/code\u003e. The\n\u003ccode\u003esizeof\u003c/code\u003e operator results in a value of type \u003ccode\u003esize_t\u003c/code\u003e. Also, \u003ccode\u003esizeof(e)\u003c/code\u003e has no side effects because \u003ccode\u003ee\u003c/code\u003e\nis not evaluated. Therefore, \u003ccode\u003esizeof(sizeof(e))\u003c/code\u003e is equivalent to \u003ccode\u003esizeof(size_t)\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eIn other words, \u003ccode\u003esizeof(sizeof(e))\u003c/code\u003e always gives the same result and does not depend on \u003ccode\u003ee\u003c/code\u003e, which is unlikely what was\nexpected.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eThis defect is usually the consequence of a typo, and the fix is to remove one level of \u003ccode\u003esizeof\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid function() {\n  char buffer[42];\n  char buffer2[sizeof(sizeof(buffer))]; // Noncompliant: a single sizeof() was intended\n\n  memcpy(buffer, \"Hello, world!\", strlen(\"Hello, world!\")+1);\n  memcpy(buffer2, buffer, sizeof(buffer)); // Buffer overflow\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid function() {\n  char buffer[42];\n  char buffer2[sizeof(buffer)]; // Compliant\n\n  memcpy(buffer, \"Hello, world!\", strlen(\"Hello, world!\")+1);\n  memcpy(buffer2, buffer, sizeof(buffer));\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/sizeof\"\u003e\u003ccode\u003esizeof\u003c/code\u003e operator\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [],
    "deprecatedKeys": [
      "cpp:SizeofSizeof"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1914",
    "name": "Track instances of the \"#error\" preprocessor directive being reached",
    "defaultSeverity": "INFO",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThis rule creates a issue whenever an \u003ccode\u003e#error\u003c/code\u003e preprocessor directive is reached during the project’s analysis. In most cases, this\nindicates that the preprocessor was badly configured. Some predefined macros or library include paths might be required to fix the configuration.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#error This is an error\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThis rule creates a issue whenever an \u003ccode\u003e#error\u003c/code\u003e preprocessor directive is reached during the project’s analysis. In most cases, this\nindicates that the preprocessor was badly configured. Some predefined macros or library include paths might be required to fix the configuration.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#error This is an error\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [],
    "deprecatedKeys": [
      "cpp:PPErrorDirectiveReached"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1915",
    "name": "Preprocessor directives should not be indented",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "FORMATTED",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eIndenting preprocessor directives reduces the code readability, because it make preprocessor directives harder to spot.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid optimal()\n{\n  #if INTEL             /* Noncompliant - hard to spot */\n  specificIntelStuff();\n  #endif                /* Noncompliant - hard to spot */\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid optimal()\n{\n#if INTEL               /* Compliant */\n  specificIntelStuff();\n#endif                  /* Compliant */\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eIndenting preprocessor directives reduces the code readability, because it make preprocessor directives harder to spot.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid optimal()\n{\n  #if INTEL             /* Noncompliant - hard to spot */\n  specificIntelStuff();\n  #endif                /* Noncompliant - hard to spot */\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid optimal()\n{\n#if INTEL               /* Compliant */\n  specificIntelStuff();\n#endif                  /* Compliant */\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "convention",
      "pitfall"
    ],
    "deprecatedKeys": [
      "cpp:PPDirectiveIndentation"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5279",
    "name": "Unevaluated operands should not have side effects",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eOperands of \u003ccode\u003esizeof\u003c/code\u003e, \u003ccode\u003enoexcept\u003c/code\u003e and \u003ccode\u003edecltype\u003c/code\u003e are unevaluated. So side effects in these operands (which are all\nthe effects an expression can have in addition to producing a value), will not be applied. And that may be surprising to the reader.\u003c/p\u003e\n\u003cp\u003eAdditionally, the operand of \u003ccode\u003etypeid\u003c/code\u003e may or may not be evaluated, depending on its type: it will be evaluated if it is a function call\nthat returns reference to a polymorphic type, but it will not be evaluated in all the other cases. This difference of behavior is tricky to apprehend\nand that is why both cases are reported here.\u003c/p\u003e\n\u003cp\u003eThis rules reports an issue when operands of such operators have side-effects.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass A {\npublic:\n  virtual ~A();\n  /*...*/\n};\nclass B : public A { /* ....*/ };\nA\u0026amp; create(string const \u0026amp;xml);\n\nvoid test(string const \u0026amp;xml) {\n  int i \u003d 0;\n  cout \u0026lt;\u0026lt; noexcept(++i); // Noncompliant, \"i\" is not incremented\n  cout \u0026lt;\u0026lt; typeid(++i).name(); // Noncompliant, \"i\" is not incremented\n  auto p1 \u003d malloc(sizeof(i \u003d 5)); // Noncompliant, \"i\" is not changed\n\n  cout \u0026lt;\u0026lt; typeid(create(xml)).name(); // Noncompliant, even if the side-effects will be evaluated in this case\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nclass A {\npublic:\n  virtual ~A();\n  /*...*/\n};\nclass B : public A { /* ....*/ };\nA\u0026amp; create(string const \u0026amp;xml);\n\nvoid test(string const \u0026amp;xml) {\n  int i \u003d 0;\n  ++i;\n  cout \u0026lt;\u0026lt; noexcept(i); // Compliant\n  ++i;\n  cout \u0026lt;\u0026lt; typeid(i).name(); // Compliant\n  i \u003d 5;\n  auto p1 \u003d malloc(sizeof(i)); // Compliant\n\n  auto a \u003d create(xml);\n  cout \u0026lt;\u0026lt; typeid(a).name(); // Compliant\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eOperands of \u003ccode\u003esizeof\u003c/code\u003e, \u003ccode\u003enoexcept\u003c/code\u003e and \u003ccode\u003edecltype\u003c/code\u003e are unevaluated. So side effects in these operands (which are all\nthe effects an expression can have in addition to producing a value), will not be applied. And that may be surprising to the reader.\u003c/p\u003e\n\u003cp\u003eAdditionally, the operand of \u003ccode\u003etypeid\u003c/code\u003e may or may not be evaluated, depending on its type: it will be evaluated if it is a function call\nthat returns reference to a polymorphic type, but it will not be evaluated in all the other cases. This difference of behavior is tricky to apprehend\nand that is why both cases are reported here.\u003c/p\u003e\n\u003cp\u003eThis rules reports an issue when operands of such operators have side-effects.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass A {\npublic:\n  virtual ~A();\n  /*...*/\n};\nclass B : public A { /* ....*/ };\nA\u0026amp; create(string const \u0026amp;xml);\n\nvoid test(string const \u0026amp;xml) {\n  int i \u003d 0;\n  cout \u0026lt;\u0026lt; noexcept(++i); // Noncompliant, \"i\" is not incremented\n  cout \u0026lt;\u0026lt; typeid(++i).name(); // Noncompliant, \"i\" is not incremented\n  auto p1 \u003d malloc(sizeof(i \u003d 5)); // Noncompliant, \"i\" is not changed\n\n  cout \u0026lt;\u0026lt; typeid(create(xml)).name(); // Noncompliant, even if the side-effects will be evaluated in this case\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nclass A {\npublic:\n  virtual ~A();\n  /*...*/\n};\nclass B : public A { /* ....*/ };\nA\u0026amp; create(string const \u0026amp;xml);\n\nvoid test(string const \u0026amp;xml) {\n  int i \u003d 0;\n  ++i;\n  cout \u0026lt;\u0026lt; noexcept(i); // Compliant\n  ++i;\n  cout \u0026lt;\u0026lt; typeid(i).name(); // Compliant\n  i \u003d 5;\n  auto p1 \u003d malloc(sizeof(i)); // Compliant\n\n  auto a \u003d create(xml);\n  cout \u0026lt;\u0026lt; typeid(a).name(); // Compliant\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6005",
    "name": "Structured binding should be used",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eC++17 introduced structured binding, a syntax that initializes multiple entities by elements or members of an object. It is handy to emulate\nseveral return values from a function.\u003c/p\u003e\n\u003cp\u003eSuppose you have a function that returns a pair:\u003c/p\u003e\n\u003cpre\u003e\nstd::pair\u0026lt;std::string, std::string\u0026gt; getPair();\n\u003c/pre\u003e\n\u003cp\u003eStructured binding allows you to bind the members of the \u003ccode\u003estd::pair\u003c/code\u003e class directly to new names:\u003c/p\u003e\n\u003cpre\u003e\nauto [firstName, lastName] \u003d getPair();\n\u003c/pre\u003e\n\u003cp\u003eThe names \u003ccode\u003efirstName\u003c/code\u003e and \u003ccode\u003elastName\u003c/code\u003e are called structured bindings. As you can see, structured binding makes the code more\nreadable as it allows binding values to names that carry information about their purpose.\u003c/p\u003e\n\u003cp\u003eStructured binding works with:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Raw arrays, by binding a name to each element \u003c/li\u003e\n  \u003cli\u003e Any type that has a tuple-like API \u003c/li\u003e\n  \u003cli\u003e Classes and structures where all non-static data members are publicly accessible \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis rule will detect places where \u003ccode\u003estd::pair\u003c/code\u003e and \u003ccode\u003estd::tuple\u003c/code\u003e can be effortlessly replaced by a structured binding.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid printingMap(const std::map\u0026lt;int, std::string\u0026gt;\u0026amp; map) {\n  for (const auto\u0026amp; elem : map) { // Noncompliant\n    std::cout \u0026lt;\u0026lt; elem.first \u0026lt;\u0026lt; \": \" \u0026lt;\u0026lt; elem.second \u0026lt;\u0026lt; \"\\n\";\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid printingMap(const std::map\u0026lt;int, std::string\u0026gt;\u0026amp; map) {\n  for (const auto\u0026amp; [key, value] : map) { // Compliant\n    std::cout \u0026lt;\u0026lt; key \u0026lt;\u0026lt; \": \" \u0026lt;\u0026lt; value \u0026lt;\u0026lt; \"\\n\";\n  }\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/structured_binding\"\u003eStructured binding declaration\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f21-to-return-multiple-out-values-prefer-returning-a-struct-or-tuple\"\u003eF.21: To return multiple \"out\" values, prefer returning a struct or tuple\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eC++17 introduced structured binding, a syntax that initializes multiple entities by elements or members of an object. It is handy to emulate\nseveral return values from a function.\u003c/p\u003e\n\u003cp\u003eSuppose you have a function that returns a pair:\u003c/p\u003e\n\u003cpre\u003e\nstd::pair\u0026lt;std::string, std::string\u0026gt; getPair();\n\u003c/pre\u003e\n\u003cp\u003eStructured binding allows you to bind the members of the \u003ccode\u003estd::pair\u003c/code\u003e class directly to new names:\u003c/p\u003e\n\u003cpre\u003e\nauto [firstName, lastName] \u003d getPair();\n\u003c/pre\u003e\n\u003cp\u003eThe names \u003ccode\u003efirstName\u003c/code\u003e and \u003ccode\u003elastName\u003c/code\u003e are called structured bindings. As you can see, structured binding makes the code more\nreadable as it allows binding values to names that carry information about their purpose.\u003c/p\u003e\n\u003cp\u003eStructured binding works with:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Raw arrays, by binding a name to each element \u003c/li\u003e\n  \u003cli\u003e Any type that has a tuple-like API \u003c/li\u003e\n  \u003cli\u003e Classes and structures where all non-static data members are publicly accessible \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis rule will detect places where \u003ccode\u003estd::pair\u003c/code\u003e and \u003ccode\u003estd::tuple\u003c/code\u003e can be effortlessly replaced by a structured binding.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid printingMap(const std::map\u0026lt;int, std::string\u0026gt;\u0026amp; map) {\n  for (const auto\u0026amp; elem : map) { // Noncompliant\n    std::cout \u0026lt;\u0026lt; elem.first \u0026lt;\u0026lt; \": \" \u0026lt;\u0026lt; elem.second \u0026lt;\u0026lt; \"\\n\";\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid printingMap(const std::map\u0026lt;int, std::string\u0026gt;\u0026amp; map) {\n  for (const auto\u0026amp; [key, value] : map) { // Compliant\n    std::cout \u0026lt;\u0026lt; key \u0026lt;\u0026lt; \": \" \u0026lt;\u0026lt; value \u0026lt;\u0026lt; \"\\n\";\n  }\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/structured_binding\"\u003eStructured binding declaration\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f21-to-return-multiple-out-values-prefer-returning-a-struct-or-tuple\"\u003eF.21: To return multiple \"out\" values, prefer returning a struct or tuple\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "clumsy",
      "cppcoreguidelines",
      "since-c++17"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6489",
    "name": "Calls to \"std::format\" with a locale should use the \"L\" flag",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003estd::format\u003c/code\u003e and other formatting functions have an overload that allows specifying a locale to format the arguments. For instance, to\nuse a \u003ccode\u003e.\u003c/code\u003e or a \u003ccode\u003e,\u003c/code\u003e for floating point values, or to spell the months in dates. However, just passing the right locale is not\nenough. You have to mark each argument that is subject to internationalization by specifying the \u003ccode\u003eL\u003c/code\u003e flag in the format specification.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when a locale is passed to a formatting function, but localization is not enabled for any argument.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstd::locale fr{“fr_FR”}; // locale names are platform dependant\nstd::cout \u0026lt;\u0026lt; std::format(fr, \"{}\", 1.2); // Noncompliant, will display 1.2\nstd::cout \u0026lt;\u0026lt; std::format(fr, \"{:%A}\", chrono::system_clock::now()); // Noncompliant, will display weekday in English\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstd::cout \u0026lt;\u0026lt; std::format(fr, \"{:L}\", 1.2); // Compliant, will display 1,2\nstd::cout \u0026lt;\u0026lt; std::format(fr, \"{:L%A}\", chrono::system_clock::now()); // Compliant, will display weekday in French\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/utility/format/formatter#Standard_format_specification\"\u003eStandard format\n  specification\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003ccode\u003estd::format\u003c/code\u003e and other formatting functions have an overload that allows specifying a locale to format the arguments. For instance, to\nuse a \u003ccode\u003e.\u003c/code\u003e or a \u003ccode\u003e,\u003c/code\u003e for floating point values, or to spell the months in dates. However, just passing the right locale is not\nenough. You have to mark each argument that is subject to internationalization by specifying the \u003ccode\u003eL\u003c/code\u003e flag in the format specification.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when a locale is passed to a formatting function, but localization is not enabled for any argument.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstd::locale fr{“fr_FR”}; // locale names are platform dependant\nstd::cout \u0026lt;\u0026lt; std::format(fr, \"{}\", 1.2); // Noncompliant, will display 1.2\nstd::cout \u0026lt;\u0026lt; std::format(fr, \"{:%A}\", chrono::system_clock::now()); // Noncompliant, will display weekday in English\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstd::cout \u0026lt;\u0026lt; std::format(fr, \"{:L}\", 1.2); // Compliant, will display 1,2\nstd::cout \u0026lt;\u0026lt; std::format(fr, \"{:L%A}\", chrono::system_clock::now()); // Compliant, will display weekday in French\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/utility/format/formatter#Standard_format_specification\"\u003eStandard format\n  specification\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "since-c++20",
      "unused"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6006",
    "name": "\"as_const\" should be used to make a value constant",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eC++17 introduced \u003ccode\u003eas_const\u003c/code\u003e: a helper function that converts a value to its corresponding const value succinctly and more\nexplicitly.\u003c/p\u003e\n\u003cp\u003eThis is usually done to force an overloaded function call on a non-const object to resolve to the const alternative. Or to instantiate a template\nwith a const type rather than the original non-const one.\u003c/p\u003e\n\u003cp\u003eThis rule detects casts that can be replaced by \u003ccode\u003eas_const\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid fn(std::vector\u0026lt;int\u0026gt;\u0026amp; vec);\nvoid fn(const std::vector\u0026lt;int\u0026gt;\u0026amp; vec);\n\nvoid constFCaller() {\n  std::vector\u0026lt;int\u0026gt; vec;\n  // Set the content of vec\n  // ...\n  fn(static_cast\u0026lt;const std::vector\u0026lt;int\u0026gt;\u0026amp;\u0026gt;(vec)); // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid fn(std::vector\u0026lt;int\u0026gt;\u0026amp; vec);\nvoid fn(const std::vector\u0026lt;int\u0026gt;\u0026amp; vec);\n\nvoid constFCaller() {\n  std::vector\u0026lt;int\u0026gt; vec;\n  // Set the content of vec\n  // ...\n  fn(as_const(vec)); // Compliant\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/utility/as_const\"\u003estd::as_const\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eC++17 introduced \u003ccode\u003eas_const\u003c/code\u003e: a helper function that converts a value to its corresponding const value succinctly and more\nexplicitly.\u003c/p\u003e\n\u003cp\u003eThis is usually done to force an overloaded function call on a non-const object to resolve to the const alternative. Or to instantiate a template\nwith a const type rather than the original non-const one.\u003c/p\u003e\n\u003cp\u003eThis rule detects casts that can be replaced by \u003ccode\u003eas_const\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid fn(std::vector\u0026lt;int\u0026gt;\u0026amp; vec);\nvoid fn(const std::vector\u0026lt;int\u0026gt;\u0026amp; vec);\n\nvoid constFCaller() {\n  std::vector\u0026lt;int\u0026gt; vec;\n  // Set the content of vec\n  // ...\n  fn(static_cast\u0026lt;const std::vector\u0026lt;int\u0026gt;\u0026amp;\u0026gt;(vec)); // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid fn(std::vector\u0026lt;int\u0026gt;\u0026amp; vec);\nvoid fn(const std::vector\u0026lt;int\u0026gt;\u0026amp; vec);\n\nvoid constFCaller() {\n  std::vector\u0026lt;int\u0026gt; vec;\n  // Set the content of vec\n  // ...\n  fn(as_const(vec)); // Compliant\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/utility/as_const\"\u003estd::as_const\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "clumsy",
      "since-c++17"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6369",
    "name": "Coroutine should have co_return on each execution path or provide return_void",
    "defaultSeverity": "CRITICAL",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhen a regular, non-\u003ccode\u003evoid\u003c/code\u003e function flows off the end of its body without returning a value, the behavior is undefined. With a\ncoroutine, when flowing off the end of its body, \u003ccode\u003ereturn_void()\u003c/code\u003e is invoked on the promise for the said coroutine. If such invocation is\nnot possible (e.g., because the function is not defined), the behavior is undefined.\u003c/p\u003e\n\u003cp\u003eIn other words, a coroutine should either:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e have all its execution paths reach a \u003ccode\u003eco_return\u003c/code\u003e statement or throw an exception; \u003c/li\u003e\n  \u003cli\u003e or its promise type should provide \u003ccode\u003ereturn_void()\u003c/code\u003e. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis rule raises an issue on coroutines that do not meet the above criteria.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstruct IsPrimeTask {\n  struct promise_type {\n    // ... no return_void() definition ...\n    void return_value(bool answer) { /* ... */ }\n  };\n  // ...\n};\n\nIsPrimeTask isPrime(long n) {\n  std::optional\u0026lt;bool\u0026gt; result \u003d co_await Oracle::IsPrime(n);\n  if (result.has_value()) {\n    co_return result.value();\n  }\n  // Noncompliant\n}\n\nstruct UploadFileTask {\n  struct promise_type {\n    // No return_void() definition.\n    // ...\n  };\n  // ...\n};\n\nUploadFileTask upload(ServerHandle server, File file) {\n  co_await server.transfert(file);\n  // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nenum class Tristate { TRUE, FALSE, UNKNOWN };\nTristate toTristate(bool value);\nstruct IsPrimeTask {\n  struct promise_type {\n    // ...\n    void return_value(Tristate answer) { /* ... */ }\n  };\n  // ...\n};\n\nIsPrimeTask isPrime(long n) {\n  std::optional\u0026lt;bool\u0026gt; result \u003d co_await Oracle::IsPrime(n);\n  if (result.has_value()) {\n    co_return toTristate(result.value());\n  }\n  co_return Tristate::UNKNOWN;\n}\n\nstruct UploadFileTask {\n  struct promise_type {\n    void return_void() { /* ... */ }\n    // ...\n  };\n  // ...\n};\n\nUploadFileTask upload(ServerHandle server, File file) {\n  co_await server.transfert(file);\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S935} - function exit paths should have appropriate return values \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhen a regular, non-\u003ccode\u003evoid\u003c/code\u003e function flows off the end of its body without returning a value, the behavior is undefined. With a\ncoroutine, when flowing off the end of its body, \u003ccode\u003ereturn_void()\u003c/code\u003e is invoked on the promise for the said coroutine. If such invocation is\nnot possible (e.g., because the function is not defined), the behavior is undefined.\u003c/p\u003e\n\u003cp\u003eIn other words, a coroutine should either:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e have all its execution paths reach a \u003ccode\u003eco_return\u003c/code\u003e statement or throw an exception; \u003c/li\u003e\n  \u003cli\u003e or its promise type should provide \u003ccode\u003ereturn_void()\u003c/code\u003e. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis rule raises an issue on coroutines that do not meet the above criteria.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstruct IsPrimeTask {\n  struct promise_type {\n    // ... no return_void() definition ...\n    void return_value(bool answer) { /* ... */ }\n  };\n  // ...\n};\n\nIsPrimeTask isPrime(long n) {\n  std::optional\u0026lt;bool\u0026gt; result \u003d co_await Oracle::IsPrime(n);\n  if (result.has_value()) {\n    co_return result.value();\n  }\n  // Noncompliant\n}\n\nstruct UploadFileTask {\n  struct promise_type {\n    // No return_void() definition.\n    // ...\n  };\n  // ...\n};\n\nUploadFileTask upload(ServerHandle server, File file) {\n  co_await server.transfert(file);\n  // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nenum class Tristate { TRUE, FALSE, UNKNOWN };\nTristate toTristate(bool value);\nstruct IsPrimeTask {\n  struct promise_type {\n    // ...\n    void return_value(Tristate answer) { /* ... */ }\n  };\n  // ...\n};\n\nIsPrimeTask isPrime(long n) {\n  std::optional\u0026lt;bool\u0026gt; result \u003d co_await Oracle::IsPrime(n);\n  if (result.has_value()) {\n    co_return toTristate(result.value());\n  }\n  co_return Tristate::UNKNOWN;\n}\n\nstruct UploadFileTask {\n  struct promise_type {\n    void return_void() { /* ... */ }\n    // ...\n  };\n  // ...\n};\n\nUploadFileTask upload(ServerHandle server, File file) {\n  co_await server.transfert(file);\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S935} - function exit paths should have appropriate return values \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "confusing",
      "since-c++20",
      "suspicious",
      "unpredictable"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5277",
    "name": "Return value of \"nodiscard\" functions should not be ignored",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eIf a function is defined with a \u003ccode\u003e[[nodiscard]]\u003c/code\u003e attribute or if it returns an object which is \u003ccode\u003e[[nodiscard]]\u003c/code\u003e, its return\nvalue is very important and should not be silently ignored.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstruct [[nodiscard]] ErrorInfo{ /* ... */};\nErrorInfo getStatus();\n\n[[nodiscard]] int getInfo();\n\nvoid f() {\n  getStatus(); // Noncompliant; we should read the returned struct which is \"nodiscard\"\n  getInfo(); // Noncompliant; we should read the return value of this \"nodiscard\" function\n  // ...\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstruct[[nodiscard]] ErrorInfo{ /* ... */};\nErrorInfo getStatus();\n\n[[nodiscard]] int getInfo();\n\nvoid f() {\n  int status \u003d getStatus(); // Compliant\n  if (getInfo() !\u003d 0) { /*...*/ } // Compliant\n  // ...\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThis rule will ignore return values that are not used, but are cast into void, since this is the standard-approved way to suppress this check.\u003c/p\u003e\n\u003cpre\u003e\n[[nodiscard]] int getInfo();\n\nvoid f() {\n  (void) getInfo(); // Compliant\n  // ...\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eIf a function is defined with a \u003ccode\u003e[[nodiscard]]\u003c/code\u003e attribute or if it returns an object which is \u003ccode\u003e[[nodiscard]]\u003c/code\u003e, its return\nvalue is very important and should not be silently ignored.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstruct [[nodiscard]] ErrorInfo{ /* ... */};\nErrorInfo getStatus();\n\n[[nodiscard]] int getInfo();\n\nvoid f() {\n  getStatus(); // Noncompliant; we should read the returned struct which is \"nodiscard\"\n  getInfo(); // Noncompliant; we should read the return value of this \"nodiscard\" function\n  // ...\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstruct[[nodiscard]] ErrorInfo{ /* ... */};\nErrorInfo getStatus();\n\n[[nodiscard]] int getInfo();\n\nvoid f() {\n  int status \u003d getStatus(); // Compliant\n  if (getInfo() !\u003d 0) { /*...*/ } // Compliant\n  // ...\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThis rule will ignore return values that are not used, but are cast into void, since this is the standard-approved way to suppress this check.\u003c/p\u003e\n\u003cpre\u003e\n[[nodiscard]] int getInfo();\n\nvoid f() {\n  (void) getInfo(); // Compliant\n  // ...\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6003",
    "name": "Emplacement should be preferred when insertion creates a temporary with sequence containers",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "EFFICIENT",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eSometimes, \u003ccode\u003eemplace_back\u003c/code\u003e is more efficient and less verbose than \u003ccode\u003epush_back\u003c/code\u003e. It is expected to be faster when the object is\nconstructed into the container instead of being constructed and assigned. This also happens when the pushed object has a different type from the one\nheld by the container.\u003c/p\u003e\n\u003cp\u003eThis rule supports standard sequence containers: \u003ccode\u003estd::vector\u003c/code\u003e, \u003ccode\u003estd::list\u003c/code\u003e, \u003ccode\u003estd::deque\u003c/code\u003e,\n\u003ccode\u003estd::forward_list\u003c/code\u003e, \u003ccode\u003estd::stack\u003c/code\u003e, \u003ccode\u003estd::queue\u003c/code\u003e and \u003ccode\u003estd::priority_queue\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThe rule raises an issue when an insertion function on a supported container leads to constructing a large temporary object that can be avoided\nusing the provided emplacement member function.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nclass Circle { // Large object\nstd::string s;\nint x;\nint y;\nint radius;\npublic:\n  Circle(int x, int y, int radius);\n}\n\nvoid f() {\n  std::vector\u0026lt;std::pair\u0026lt;int, std::string\u0026gt;\u0026gt; vec1;\n  std::string s;\n  vec1.push_back(std::make_pair(21, s)); // Noncompliant\n  std::vector\u0026lt;std::string\u0026gt; vec2;\n  vec2.push_back(\"randomStr\"); // Noncompliant, conversion from char const * to string\n  std::vector\u0026lt;Circle\u0026gt; circles;\n  circles.push_back(Circle{2, 42, 10}); // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nclass Circle { // Large object\nstd::string s;\nint x;\nint y;\nint radius;\npublic:\n  Circle(int x, int y, int radius);\n}\n\nvoid f() {\n  std::vector\u0026lt;std::pair\u0026lt;int, std::string\u0026gt;\u0026gt; vec1;\n  std::string s;\n  vec1.emplace_back(21, s); // Compliant\n  std::vector\u0026lt;std::string\u0026gt; vec2;\n  vec2.emplace_back(\"randomStr\"); // Compliant\n  std::vector\u0026lt;Circle\u0026gt; circles;\n  circles.emplace_back(2, 42, 10); // Compliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThe rule does not raise an issue when \u003ccode\u003eemplace_back\u003c/code\u003e is not exception-safe. For example, when emplacing a raw new expression in a\ncontainer of smart pointers, the memory will be leaked if \u003ccode\u003eemplace_back\u003c/code\u003e throws an exception.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e Effective modern C++ item 42: Consider emplacement instead of insertion. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eSometimes, \u003ccode\u003eemplace_back\u003c/code\u003e is more efficient and less verbose than \u003ccode\u003epush_back\u003c/code\u003e. It is expected to be faster when the object is\nconstructed into the container instead of being constructed and assigned. This also happens when the pushed object has a different type from the one\nheld by the container.\u003c/p\u003e\n\u003cp\u003eThis rule supports standard sequence containers: \u003ccode\u003estd::vector\u003c/code\u003e, \u003ccode\u003estd::list\u003c/code\u003e, \u003ccode\u003estd::deque\u003c/code\u003e,\n\u003ccode\u003estd::forward_list\u003c/code\u003e, \u003ccode\u003estd::stack\u003c/code\u003e, \u003ccode\u003estd::queue\u003c/code\u003e and \u003ccode\u003estd::priority_queue\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThe rule raises an issue when an insertion function on a supported container leads to constructing a large temporary object that can be avoided\nusing the provided emplacement member function.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nclass Circle { // Large object\nstd::string s;\nint x;\nint y;\nint radius;\npublic:\n  Circle(int x, int y, int radius);\n}\n\nvoid f() {\n  std::vector\u0026lt;std::pair\u0026lt;int, std::string\u0026gt;\u0026gt; vec1;\n  std::string s;\n  vec1.push_back(std::make_pair(21, s)); // Noncompliant\n  std::vector\u0026lt;std::string\u0026gt; vec2;\n  vec2.push_back(\"randomStr\"); // Noncompliant, conversion from char const * to string\n  std::vector\u0026lt;Circle\u0026gt; circles;\n  circles.push_back(Circle{2, 42, 10}); // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nclass Circle { // Large object\nstd::string s;\nint x;\nint y;\nint radius;\npublic:\n  Circle(int x, int y, int radius);\n}\n\nvoid f() {\n  std::vector\u0026lt;std::pair\u0026lt;int, std::string\u0026gt;\u0026gt; vec1;\n  std::string s;\n  vec1.emplace_back(21, s); // Compliant\n  std::vector\u0026lt;std::string\u0026gt; vec2;\n  vec2.emplace_back(\"randomStr\"); // Compliant\n  std::vector\u0026lt;Circle\u0026gt; circles;\n  circles.emplace_back(2, 42, 10); // Compliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThe rule does not raise an issue when \u003ccode\u003eemplace_back\u003c/code\u003e is not exception-safe. For example, when emplacing a raw new expression in a\ncontainer of smart pointers, the memory will be leaked if \u003ccode\u003eemplace_back\u003c/code\u003e throws an exception.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e Effective modern C++ item 42: Consider emplacement instead of insertion. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "clumsy",
      "performance",
      "since-c++11"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6366",
    "name": "Use conditional suspension to resume current coroutine",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "EFFICIENT",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eOne of the use cases for the coroutines is suspending execution until certain conditions are satisfied (e.g. value is produced, flag/event is\ntriggered). In some situations, the expected result may be already available at the point of the \u003ccode\u003eco_await\u003c/code\u003e/\u003ccode\u003eco_yield\u003c/code\u003e\nexpression, and the execution can be resumed immediately.\u003c/p\u003e\n\u003cp\u003eThe C++ standard provides an efficient method to suspend the coroutine conditionally. The result of \u003ccode\u003eawait_ready\u003c/code\u003e is used to determine\nwhether a coroutine should be suspended. Returning \u003ccode\u003etrue\u003c/code\u003e from this function avoids the cost of the coroutine suspension if it is not\nneeded (e.g., the result is already available). Furthermore, the \u003ccode\u003ebool\u003c/code\u003e-returning version of \u003ccode\u003eawait_suspend\u003c/code\u003e allows immediate\nresumption of the current coroutine in the case when \u003ccode\u003efalse\u003c/code\u003e is returned (returning \u003ccode\u003etrue\u003c/code\u003e indicates that the coroutine should\nremain suspended). Compared to symmetric transfer, this method provides better optimization opportunities, as the continuation code is known to the\ncompiler - i.e., it is the code of the current coroutine, while in symmetric transfer the handle could point to an arbitrary coroutine.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue on \u003ccode\u003eawait_suspend\u003c/code\u003e that can benefit from using conditional suspension.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstruct WaitForAwaiter {\n  Event\u0026amp; event;\n  /* .... */\n  std::coroutine_handle\u0026lt;\u0026gt; await_suspend(std::coroutine_handle\u0026lt;\u0026gt; current) { // Noncompliant\n    bool callback_registered \u003d event.register_callback(current);\n    if (!callback_registered) {\n      return current;\n    } else {\n      return std::noop_coroutine();\n    }\n  }\n};\n\nstruct ReadBytesAwaiter {\n  Socket\u0026amp; socket;\n  std::size_t count;\n  std::span\u0026lt;std::byte\u0026gt; buffer;\n  std::error_code error;\n  /* .... */\n  void await_suspend(std::coroutine_handle\u0026lt;\u0026gt; current) { // Noncompliant\n    auto callback \u003d [\u0026amp;error_store\u003derror, current](std::error_code ec) {\n      error_store \u003d ec;\n      current.resume();\n    };\n\n    auto ec \u003d socket.async_read(buffer, count, callback);\n    if (ec) {\n      error \u003d ec;\n      current.resume();\n    }\n  }\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstruct WaitForAwaiter {\n  Event\u0026amp; event;\n  /* .... */\n  bool await_ready() const {\n    return event.is_already_triggered();\n  }\n  bool await_suspend(std::coroutine_handle\u0026lt;\u0026gt; current) {\n    bool callback_registered \u003d event.register_callback(current);\n    return callback_registered;\n  }\n};\n\nstruct ReadBytesAwaiter {\n  Socket\u0026amp; socket;\n  std::size_t count;\n  std::span\u0026lt;std::byte\u0026gt; buffer;\n  std::error_code error;\n  /* .... */\n\n  bool await_ready() const {\n    return false; // no way to query before suspension\n  }\n  bool await_suspend(std::coroutine_handle\u0026lt;\u0026gt; current) {\n    auto callback \u003d [\u0026amp;error_store\u003derror, current](std::error_code ec) {\n      error_store \u003d ec;\n      current.resume();\n    };\n\n    auto ec \u003d socket.async_read(buffer, count, callback);\n    if (ec) {\n      error \u003d ec;\n      return false;\n    }\n\n    return true;\n  }\n};\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cp\u003e{rule:cpp:S6365} - transferring execution to any suspended coroutine\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eOne of the use cases for the coroutines is suspending execution until certain conditions are satisfied (e.g. value is produced, flag/event is\ntriggered). In some situations, the expected result may be already available at the point of the \u003ccode\u003eco_await\u003c/code\u003e/\u003ccode\u003eco_yield\u003c/code\u003e\nexpression, and the execution can be resumed immediately.\u003c/p\u003e\n\u003cp\u003eThe C++ standard provides an efficient method to suspend the coroutine conditionally. The result of \u003ccode\u003eawait_ready\u003c/code\u003e is used to determine\nwhether a coroutine should be suspended. Returning \u003ccode\u003etrue\u003c/code\u003e from this function avoids the cost of the coroutine suspension if it is not\nneeded (e.g., the result is already available). Furthermore, the \u003ccode\u003ebool\u003c/code\u003e-returning version of \u003ccode\u003eawait_suspend\u003c/code\u003e allows immediate\nresumption of the current coroutine in the case when \u003ccode\u003efalse\u003c/code\u003e is returned (returning \u003ccode\u003etrue\u003c/code\u003e indicates that the coroutine should\nremain suspended). Compared to symmetric transfer, this method provides better optimization opportunities, as the continuation code is known to the\ncompiler - i.e., it is the code of the current coroutine, while in symmetric transfer the handle could point to an arbitrary coroutine.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue on \u003ccode\u003eawait_suspend\u003c/code\u003e that can benefit from using conditional suspension.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstruct WaitForAwaiter {\n  Event\u0026amp; event;\n  /* .... */\n  std::coroutine_handle\u0026lt;\u0026gt; await_suspend(std::coroutine_handle\u0026lt;\u0026gt; current) { // Noncompliant\n    bool callback_registered \u003d event.register_callback(current);\n    if (!callback_registered) {\n      return current;\n    } else {\n      return std::noop_coroutine();\n    }\n  }\n};\n\nstruct ReadBytesAwaiter {\n  Socket\u0026amp; socket;\n  std::size_t count;\n  std::span\u0026lt;std::byte\u0026gt; buffer;\n  std::error_code error;\n  /* .... */\n  void await_suspend(std::coroutine_handle\u0026lt;\u0026gt; current) { // Noncompliant\n    auto callback \u003d [\u0026amp;error_store\u003derror, current](std::error_code ec) {\n      error_store \u003d ec;\n      current.resume();\n    };\n\n    auto ec \u003d socket.async_read(buffer, count, callback);\n    if (ec) {\n      error \u003d ec;\n      current.resume();\n    }\n  }\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstruct WaitForAwaiter {\n  Event\u0026amp; event;\n  /* .... */\n  bool await_ready() const {\n    return event.is_already_triggered();\n  }\n  bool await_suspend(std::coroutine_handle\u0026lt;\u0026gt; current) {\n    bool callback_registered \u003d event.register_callback(current);\n    return callback_registered;\n  }\n};\n\nstruct ReadBytesAwaiter {\n  Socket\u0026amp; socket;\n  std::size_t count;\n  std::span\u0026lt;std::byte\u0026gt; buffer;\n  std::error_code error;\n  /* .... */\n\n  bool await_ready() const {\n    return false; // no way to query before suspension\n  }\n  bool await_suspend(std::coroutine_handle\u0026lt;\u0026gt; current) {\n    auto callback \u003d [\u0026amp;error_store\u003derror, current](std::error_code ec) {\n      error_store \u003d ec;\n      current.resume();\n    };\n\n    auto ec \u003d socket.async_read(buffer, count, callback);\n    if (ec) {\n      error \u003d ec;\n      return false;\n    }\n\n    return true;\n  }\n};\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cp\u003e{rule:cpp:S6365} - transferring execution to any suspended coroutine\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "performance",
      "since-c++20"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6487",
    "name": "\"std::format\" should not be missing indexes",
    "defaultSeverity": "MINOR",
    "type": "BUG",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "RELIABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003estd::format\u003c/code\u003e takes as an argument a format string that contains replacement fields (surrounded with \u003ccode\u003e{}\u003c/code\u003e) and a set of extra\narguments that will be formatted inside the replacement fields. Even if the format string is checked at compile-time, it is possible to have a\nmismatch between the format string and the arguments. For example:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The format string contains fewer replacement fields than the number of extra arguments: \u003ccode\u003estd::format(\"{} {}\", 1, 2, 3);\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e The format string uses indexes for the replacement fields, but one index is missing: \u003ccode\u003estd::format(\"{0} {0} {2}\", 1, 2, 3);\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn these cases, the extra arguments are silently ignored. In the best-case scenario, it leads to dead code. Otherwise, it is a typo, and the output\nwill not be intended.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eThis rule raises an issue when:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e An unused argument comes from a complex expression, such as a function call. \u003c/li\u003e\n  \u003cli\u003e A combination of numbered replacement fields, a missing index, and a repeated index exists. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nstd::cout \u0026lt;\u0026lt; std::format(\"{} {}\", 1, 2, sqrt(2));\nstd::cout \u0026lt;\u0026lt; std::format(\"{0} {0} {2}\", 1, 2, 3);\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nstd::cout \u0026lt;\u0026lt; std::format(\"{} {} {}\", 1, 2, sqrt(2));\nstd::cout \u0026lt;\u0026lt; std::format(\"{0} {0} {2} {1}\", 1, 2, 3);\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S6488} - To detect all unused arguments in \u003ccode\u003estd::format\u003c/code\u003e. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003ccode\u003estd::format\u003c/code\u003e takes as an argument a format string that contains replacement fields (surrounded with \u003ccode\u003e{}\u003c/code\u003e) and a set of extra\narguments that will be formatted inside the replacement fields. Even if the format string is checked at compile-time, it is possible to have a\nmismatch between the format string and the arguments. For example:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The format string contains fewer replacement fields than the number of extra arguments: \u003ccode\u003estd::format(\"{} {}\", 1, 2, 3);\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e The format string uses indexes for the replacement fields, but one index is missing: \u003ccode\u003estd::format(\"{0} {0} {2}\", 1, 2, 3);\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn these cases, the extra arguments are silently ignored. In the best-case scenario, it leads to dead code. Otherwise, it is a typo, and the output\nwill not be intended.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eThis rule raises an issue when:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e An unused argument comes from a complex expression, such as a function call. \u003c/li\u003e\n  \u003cli\u003e A combination of numbered replacement fields, a missing index, and a repeated index exists. \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nstd::cout \u0026lt;\u0026lt; std::format(\"{} {}\", 1, 2, sqrt(2));\nstd::cout \u0026lt;\u0026lt; std::format(\"{0} {0} {2}\", 1, 2, 3);\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nstd::cout \u0026lt;\u0026lt; std::format(\"{} {} {}\", 1, 2, sqrt(2));\nstd::cout \u0026lt;\u0026lt; std::format(\"{0} {0} {2} {1}\", 1, 2, 3);\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S6488} - To detect all unused arguments in \u003ccode\u003estd::format\u003c/code\u003e. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "since-c++20",
      "unused"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5278",
    "name": "Size argument of memory functions should be consistent",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe memory functions \u003ccode\u003ememset\u003c/code\u003e, \u003ccode\u003ememcpy\u003c/code\u003e, \u003ccode\u003ememmove\u003c/code\u003e, and \u003ccode\u003ememcmp\u003c/code\u003e take as last argument the number of\nbytes they will work on. If this size argument is badly defined (eg it is greater than the size of the destination object), it can lead to undefined\nbehavior.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when the size argument of a memory function seems inconsistent with the other arguments of the function.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstruct A {};\n\nvoid f() {\n  struct A dest;\n  memset(\u0026amp;dest, 0, sizeof(\u0026amp;dest)); // Noncompliant; size is based on \"A*\" when the destination is of type \"A\"\n  struct A src;\n  memcpy(\u0026amp;dest, \u0026amp;src, sizeof(\u0026amp;dest)); // Noncompliant; size is based on \"A*\" when the source is of type \"A\"\n\n  if (memset(\u0026amp;dest, 0, sizeof(dest) !\u003d 0)) { // Noncompliant; size argument is a comparison\n    // ...\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstruct A {};\n\nvoid f() {\n  struct A dest;\n  memset(\u0026amp;dest, 0, sizeof(dest)); // Compliant\n  struct A src;\n  memcpy(\u0026amp;dest, \u0026amp;src, sizeof(dest)); // Compliant\n\n  if (memset(\u0026amp;dest, 0, sizeof(dest)) !\u003d 0) { // Compliant\n    // ...\n  }\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe memory functions \u003ccode\u003ememset\u003c/code\u003e, \u003ccode\u003ememcpy\u003c/code\u003e, \u003ccode\u003ememmove\u003c/code\u003e, and \u003ccode\u003ememcmp\u003c/code\u003e take as last argument the number of\nbytes they will work on. If this size argument is badly defined (eg it is greater than the size of the destination object), it can lead to undefined\nbehavior.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when the size argument of a memory function seems inconsistent with the other arguments of the function.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstruct A {};\n\nvoid f() {\n  struct A dest;\n  memset(\u0026amp;dest, 0, sizeof(\u0026amp;dest)); // Noncompliant; size is based on \"A*\" when the destination is of type \"A\"\n  struct A src;\n  memcpy(\u0026amp;dest, \u0026amp;src, sizeof(\u0026amp;dest)); // Noncompliant; size is based on \"A*\" when the source is of type \"A\"\n\n  if (memset(\u0026amp;dest, 0, sizeof(dest) !\u003d 0)) { // Noncompliant; size argument is a comparison\n    // ...\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstruct A {};\n\nvoid f() {\n  struct A dest;\n  memset(\u0026amp;dest, 0, sizeof(dest)); // Compliant\n  struct A src;\n  memcpy(\u0026amp;dest, \u0026amp;src, sizeof(dest)); // Compliant\n\n  if (memset(\u0026amp;dest, 0, sizeof(dest)) !\u003d 0) { // Compliant\n    // ...\n  }\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6004",
    "name": "\"if\",\"switch\", and range-based for loop initializer should be used to reduce scope of variables",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eC++17 introduced a construct to create and initialize a variable within the condition of \u003ccode\u003eif\u003c/code\u003e and \u003ccode\u003eswitch\u003c/code\u003e statements and\nC++20 added this construct to range-based \u003ccode\u003efor\u003c/code\u003e loops. Using this new feature simplifies common code patterns and helps in giving variables\nthe right scope.\u003c/p\u003e\n\u003cp\u003ePreviously, variables were either declared before the statement, hence leaked into the ambient scope, or an explicit scope was used to keep the\nscope tight, especially when using RAII objects. This was inconvenient as it would lead to error-prone patterns.\u003c/p\u003e\n\u003cp\u003eFor example, this verbose error-prone initialization:\u003c/p\u003e\n\u003cpre\u003e\nbool error_prone_init() {\n  { // explicit scope\n    std::unique_lock\u0026lt;std::mutex\u0026gt; lock(mtx, std::try_to_lock);\n    if (lock.owns_lock()) {\n       //...\n     }\n  } // mutex unlock\n  // ... code\n  return true;\n}\n\u003c/pre\u003e\n\u003cp\u003ecan now be replaced by the following code, which is safer and more readable:\u003c/p\u003e\n\u003cpre\u003e\nbool better_init() {\n  if (std::unique_lock\u0026lt;std::mutex\u0026gt; lock(mtx, std::try_to_lock); lock.owns_lock()) {\n     //...\n  } // mutex unlock\n  // ... code\n  return true;\n}\n\u003c/pre\u003e\n\u003cp\u003eThis rule raises an issue when:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e a variable is declared just before a statement that allows variable declaration (\u003ccode\u003eif\u003c/code\u003e, \u003ccode\u003eswitch\u003c/code\u003e, or, starting C++20,\n  range-based \u003ccode\u003efor\u003c/code\u003e loop), \u003c/li\u003e\n  \u003cli\u003e this variable is used in the statement header, \u003c/li\u003e\n  \u003cli\u003e there are other statements after this statement where this variable might be used, \u003c/li\u003e\n  \u003cli\u003e yet, it is never used after the statement. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid handle(std::string_view s);\nvoid ifStatement() {\n  std::map\u0026lt;int, std::string\u0026gt; m;\n  int key \u003d 1;\n  std::string value \u003d \"str1\";\n  auto [it, inserted] \u003d m.try_emplace(key, value); // Noncompliant\n  if (!inserted) {\n    std::cout \u0026lt;\u0026lt; \"Already registered\";\n  } else {\n    handle(it-\u0026gt;second);\n  }\n  process(m);\n}\n\u003c/pre\u003e\n\u003cpre\u003e\nenum class State { True, False, Maybe, MaybeNot };\nstd::pair\u0026lt;std::string, State\u0026gt; getStatePair();\n\nvoid switchStatement() {\n  auto state \u003d getStatePair(); // Noncompliant\n  switch (state.second) {\n    case State::True:\n    case State::Maybe:\n      std::cout \u0026lt;\u0026lt; state.first;\n      break;\n    case State::False:\n    case State::MaybeNot:\n      std::cout \u0026lt;\u0026lt; \"No\";\n      break;\n  }\n  std::cout \u0026lt;\u0026lt; \"\\n\";\n}\n\u003c/pre\u003e\n\u003cpre\u003e\nstd::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; getTable();\nvoid printHeadersBad() {\n  auto rows \u003d getTable(); // Noncompliant in C++20: rows is accessible outside of the loop\n  for (int x : rows[0]) {\n    std::cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt;\u0027 \u0027;\n  }\n  std::cout \u0026lt;\u0026lt; \"\\n\";\n}\n\u003c/pre\u003e\n\u003cp\u003eUsing a temporary to avoid leaking of the variable into the ambient scope creates a bigger problem: an undefined behavior. Even though the lifetime\nof a temporary returned by the range expression is extended, the life of a temporary within the range expression terminates before the loop begins to\nexecute.\u003c/p\u003e\n\u003cpre\u003e\nstd::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; getTable();\nvoid printHeadersWorse() {\n  for (int x : getTable()[0]) { // Undefined behavior: return value of getTable() no longer exists in the loop body\n    std::cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt;\u0027 \u0027;\n  }\n  std::cout \u0026lt;\u0026lt; \"\\n\";\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid handle(std::string_view s);\nvoid ifStatement() {\n  std::map\u0026lt;int, std::string\u0026gt; m;\n  int key \u003d 1;\n  std::string value \u003d \"str1\";\n  if (auto [it, inserted] \u003d m.try_emplace(key, value); !inserted) { // Compliant\n    std::cout \u0026lt;\u0026lt; \"Already registered\";\n  } else {\n    handle(it-\u0026gt;second);\n  }\n  process(m);\n}\n\nenum class State { True, False, Maybe, MaybeNot };\nstd::pair\u0026lt;std::string, State\u0026gt; getStatePair();\n\nvoid switchStatement() {\n  switch (auto state \u003d getStatePair(); state.second) { // Compliant\n    case State::True:\n    case State::Maybe:\n      std::cout \u0026lt;\u0026lt; state.first;\n      break;\n    case State::False:\n    case State::MaybeNot:\n      std::cout \u0026lt;\u0026lt; \"No\";\n      break;\n  }\n  std::cout \u0026lt;\u0026lt; \"\\n\";\n}\n\nstd::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; getTable();\nvoid printHeadersGood() {\n  // Compliant: rows is accessible only inside the loop (this code requires at least C++20)\n  for (auto rows \u003d getTable(); int x : table[0]) {\n    std::cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt;\u0027 \u0027;\n  }\n  std::cout \u0026lt;\u0026lt; \"\\n\";\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eWhile an \u003ccode\u003eif\u003c/code\u003e with both an initializer and a condition variable is valid, it is confusing. The rule does not raise an issue if the\n\u003ccode\u003eif\u003c/code\u003e statement already has a condition variable:\u003c/p\u003e\n\u003cpre\u003e\nvoid confusing() {\n  if (int a \u003d 42; std::optional\u0026lt;int\u0026gt; b \u003d lookup(a)) { // Valid but confusing\n    // ...\n  }\n}\n\nvoid exception() {\n  int a \u003d 42; // Compliant by exception\n  if (std::optional\u0026lt;int\u0026gt; b \u003d lookup(a)) {\n    // ...\n  }\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eC++17 introduced a construct to create and initialize a variable within the condition of \u003ccode\u003eif\u003c/code\u003e and \u003ccode\u003eswitch\u003c/code\u003e statements and\nC++20 added this construct to range-based \u003ccode\u003efor\u003c/code\u003e loops. Using this new feature simplifies common code patterns and helps in giving variables\nthe right scope.\u003c/p\u003e\n\u003cp\u003ePreviously, variables were either declared before the statement, hence leaked into the ambient scope, or an explicit scope was used to keep the\nscope tight, especially when using RAII objects. This was inconvenient as it would lead to error-prone patterns.\u003c/p\u003e\n\u003cp\u003eFor example, this verbose error-prone initialization:\u003c/p\u003e\n\u003cpre\u003e\nbool error_prone_init() {\n  { // explicit scope\n    std::unique_lock\u0026lt;std::mutex\u0026gt; lock(mtx, std::try_to_lock);\n    if (lock.owns_lock()) {\n       //...\n     }\n  } // mutex unlock\n  // ... code\n  return true;\n}\n\u003c/pre\u003e\n\u003cp\u003ecan now be replaced by the following code, which is safer and more readable:\u003c/p\u003e\n\u003cpre\u003e\nbool better_init() {\n  if (std::unique_lock\u0026lt;std::mutex\u0026gt; lock(mtx, std::try_to_lock); lock.owns_lock()) {\n     //...\n  } // mutex unlock\n  // ... code\n  return true;\n}\n\u003c/pre\u003e\n\u003cp\u003eThis rule raises an issue when:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e a variable is declared just before a statement that allows variable declaration (\u003ccode\u003eif\u003c/code\u003e, \u003ccode\u003eswitch\u003c/code\u003e, or, starting C++20,\n  range-based \u003ccode\u003efor\u003c/code\u003e loop), \u003c/li\u003e\n  \u003cli\u003e this variable is used in the statement header, \u003c/li\u003e\n  \u003cli\u003e there are other statements after this statement where this variable might be used, \u003c/li\u003e\n  \u003cli\u003e yet, it is never used after the statement. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid handle(std::string_view s);\nvoid ifStatement() {\n  std::map\u0026lt;int, std::string\u0026gt; m;\n  int key \u003d 1;\n  std::string value \u003d \"str1\";\n  auto [it, inserted] \u003d m.try_emplace(key, value); // Noncompliant\n  if (!inserted) {\n    std::cout \u0026lt;\u0026lt; \"Already registered\";\n  } else {\n    handle(it-\u0026gt;second);\n  }\n  process(m);\n}\n\u003c/pre\u003e\n\u003cpre\u003e\nenum class State { True, False, Maybe, MaybeNot };\nstd::pair\u0026lt;std::string, State\u0026gt; getStatePair();\n\nvoid switchStatement() {\n  auto state \u003d getStatePair(); // Noncompliant\n  switch (state.second) {\n    case State::True:\n    case State::Maybe:\n      std::cout \u0026lt;\u0026lt; state.first;\n      break;\n    case State::False:\n    case State::MaybeNot:\n      std::cout \u0026lt;\u0026lt; \"No\";\n      break;\n  }\n  std::cout \u0026lt;\u0026lt; \"\\n\";\n}\n\u003c/pre\u003e\n\u003cpre\u003e\nstd::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; getTable();\nvoid printHeadersBad() {\n  auto rows \u003d getTable(); // Noncompliant in C++20: rows is accessible outside of the loop\n  for (int x : rows[0]) {\n    std::cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt;\u0027 \u0027;\n  }\n  std::cout \u0026lt;\u0026lt; \"\\n\";\n}\n\u003c/pre\u003e\n\u003cp\u003eUsing a temporary to avoid leaking of the variable into the ambient scope creates a bigger problem: an undefined behavior. Even though the lifetime\nof a temporary returned by the range expression is extended, the life of a temporary within the range expression terminates before the loop begins to\nexecute.\u003c/p\u003e\n\u003cpre\u003e\nstd::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; getTable();\nvoid printHeadersWorse() {\n  for (int x : getTable()[0]) { // Undefined behavior: return value of getTable() no longer exists in the loop body\n    std::cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt;\u0027 \u0027;\n  }\n  std::cout \u0026lt;\u0026lt; \"\\n\";\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid handle(std::string_view s);\nvoid ifStatement() {\n  std::map\u0026lt;int, std::string\u0026gt; m;\n  int key \u003d 1;\n  std::string value \u003d \"str1\";\n  if (auto [it, inserted] \u003d m.try_emplace(key, value); !inserted) { // Compliant\n    std::cout \u0026lt;\u0026lt; \"Already registered\";\n  } else {\n    handle(it-\u0026gt;second);\n  }\n  process(m);\n}\n\nenum class State { True, False, Maybe, MaybeNot };\nstd::pair\u0026lt;std::string, State\u0026gt; getStatePair();\n\nvoid switchStatement() {\n  switch (auto state \u003d getStatePair(); state.second) { // Compliant\n    case State::True:\n    case State::Maybe:\n      std::cout \u0026lt;\u0026lt; state.first;\n      break;\n    case State::False:\n    case State::MaybeNot:\n      std::cout \u0026lt;\u0026lt; \"No\";\n      break;\n  }\n  std::cout \u0026lt;\u0026lt; \"\\n\";\n}\n\nstd::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; getTable();\nvoid printHeadersGood() {\n  // Compliant: rows is accessible only inside the loop (this code requires at least C++20)\n  for (auto rows \u003d getTable(); int x : table[0]) {\n    std::cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt;\u0027 \u0027;\n  }\n  std::cout \u0026lt;\u0026lt; \"\\n\";\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eWhile an \u003ccode\u003eif\u003c/code\u003e with both an initializer and a condition variable is valid, it is confusing. The rule does not raise an issue if the\n\u003ccode\u003eif\u003c/code\u003e statement already has a condition variable:\u003c/p\u003e\n\u003cpre\u003e\nvoid confusing() {\n  if (int a \u003d 42; std::optional\u0026lt;int\u0026gt; b \u003d lookup(a)) { // Valid but confusing\n    // ...\n  }\n}\n\nvoid exception() {\n  int a \u003d 42; // Compliant by exception\n  if (std::optional\u0026lt;int\u0026gt; b \u003d lookup(a)) {\n    // ...\n  }\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "clumsy",
      "since-c++17"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6367",
    "name": "Thread local variables should not be used in coroutines",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eIn contrast to normal functions, coroutines can suspend and later resume their execution. Depending on the program, the coroutine may resume on a\ndifferent thread of execution than the one it was started or run previously on.\u003c/p\u003e\n\u003cp\u003eTherefore, the access to the \"same\" variable with \u003ccode\u003ethread_local\u003c/code\u003e storage may produce different values, as illustrated below:\u003c/p\u003e\n\u003cpre\u003e\nthread_local std::vector\u0026lt;Decorator\u0026gt; decorators;\nlazy\u0026lt;Thingy\u0026gt; doSomething() {\n  // evaluation started on thread t1\n  /* .... */\n  const std::size_t decoratorCount \u003d decorators.size(); // value specific to thread t1\n  auto result \u003d co_await produceThingy();\n  // after co_await, execution resumes on thread t2\n  for (std::size_t i \u003d 0; i \u0026lt; decoratorCount; ++i) {\n    decorators[i].modify(result); // access value specific to t2\n    // miss some tasks if t1:decorators.size() \u0026lt; t2:decorators.size()\n    // undefined behavior if t1:decorators.size() \u0026gt; t2:decorators.size()\n  }\n  co_return result;\n}\n\u003c/pre\u003e\n\u003cp\u003eThis behavior is surprising and unintuitive compared to normal functions that are always evaluated on a single thread. The same issue can happen\nfor the use of different \u003ccode\u003ethread_local\u003c/code\u003e variables if their values are interconnected (e.g., one is the address of the buffer, and the other\nis the number of elements in the buffer).\u003c/p\u003e\n\u003cp\u003eMoreover, access to \u003ccode\u003ethread_local\u003c/code\u003e variables defined inside the coroutine may read uninitialized memory. Each such variable is\ninitialized when a specific thread enters the function for the first time, and if the function was never called from a thread on which the coroutine\nis resumed, it is uninitialized.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue on the declaration of \u003ccode\u003ethread_local\u003c/code\u003e variables and access to \u003ccode\u003ethread_local\u003c/code\u003e variables in\ncoroutines.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nthread_local std::vector\u0026lt;Decorator\u0026gt; decorators;\nlazy\u0026lt;Thingy\u0026gt; doSomething() {\n  thread_local Decorator localDecorator; // Noncompliant\n  const std::size_t decoratorCount \u003d decorators.size(); // Noncompliant\n  /* ... */\n  auto result \u003d co_await produceThingy();\n  for (std::size_t i \u003d 0; i \u0026lt; taskCount; ++i) {\n    decorators[i].modify(result);\n  }\n  localDecorator.modify(result); // Noncompliant\n  co_return result;\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/storage_duration\"\u003eStorage class specifiers: thread_local\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eIn contrast to normal functions, coroutines can suspend and later resume their execution. Depending on the program, the coroutine may resume on a\ndifferent thread of execution than the one it was started or run previously on.\u003c/p\u003e\n\u003cp\u003eTherefore, the access to the \"same\" variable with \u003ccode\u003ethread_local\u003c/code\u003e storage may produce different values, as illustrated below:\u003c/p\u003e\n\u003cpre\u003e\nthread_local std::vector\u0026lt;Decorator\u0026gt; decorators;\nlazy\u0026lt;Thingy\u0026gt; doSomething() {\n  // evaluation started on thread t1\n  /* .... */\n  const std::size_t decoratorCount \u003d decorators.size(); // value specific to thread t1\n  auto result \u003d co_await produceThingy();\n  // after co_await, execution resumes on thread t2\n  for (std::size_t i \u003d 0; i \u0026lt; decoratorCount; ++i) {\n    decorators[i].modify(result); // access value specific to t2\n    // miss some tasks if t1:decorators.size() \u0026lt; t2:decorators.size()\n    // undefined behavior if t1:decorators.size() \u0026gt; t2:decorators.size()\n  }\n  co_return result;\n}\n\u003c/pre\u003e\n\u003cp\u003eThis behavior is surprising and unintuitive compared to normal functions that are always evaluated on a single thread. The same issue can happen\nfor the use of different \u003ccode\u003ethread_local\u003c/code\u003e variables if their values are interconnected (e.g., one is the address of the buffer, and the other\nis the number of elements in the buffer).\u003c/p\u003e\n\u003cp\u003eMoreover, access to \u003ccode\u003ethread_local\u003c/code\u003e variables defined inside the coroutine may read uninitialized memory. Each such variable is\ninitialized when a specific thread enters the function for the first time, and if the function was never called from a thread on which the coroutine\nis resumed, it is uninitialized.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue on the declaration of \u003ccode\u003ethread_local\u003c/code\u003e variables and access to \u003ccode\u003ethread_local\u003c/code\u003e variables in\ncoroutines.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nthread_local std::vector\u0026lt;Decorator\u0026gt; decorators;\nlazy\u0026lt;Thingy\u0026gt; doSomething() {\n  thread_local Decorator localDecorator; // Noncompliant\n  const std::size_t decoratorCount \u003d decorators.size(); // Noncompliant\n  /* ... */\n  auto result \u003d co_await produceThingy();\n  for (std::size_t i \u003d 0; i \u0026lt; taskCount; ++i) {\n    decorators[i].modify(result);\n  }\n  localDecorator.modify(result); // Noncompliant\n  co_return result;\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/storage_duration\"\u003eStorage class specifiers: thread_local\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "confusing",
      "since-c++20",
      "suspicious",
      "unpredictable"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6488",
    "name": "\"std::format\" should not have unused arguments",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003estd::format\u003c/code\u003e takes as an argument a format string that contains replacement fields (surrounded with \u003ccode\u003e{}\u003c/code\u003e) and a set of extra\narguments that will be formatted inside the replacement fields. Even if the format string is checked at compile-time, it is possible to have a\nmismatch between the format string and the arguments. For example, when:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The format string contains fewer replacement fields than the number of extra arguments: \u003ccode\u003estd::format(\"{} {}\", 1, 2, 3);\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e The format string uses indexes for the replacement fields, but one index is missing: \u003ccode\u003estd::format(\"{0} {0} {2}\", 1, 2, 3);\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn these cases, the extra arguments are silently ignored. In the best-case scenario, it leads to dead code. Otherwise, it is a typo, and the output\nwill not be intended.\u003c/p\u003e\n\u003cp\u003eThis rule detects when the arguments of \u003ccode\u003estd::format\u003c/code\u003e are unused in a way that doesn’t trigger {rule:cpp:S6487}. Therefore, you should\nmake sure that {rule:cpp:S6487} is enabled with this rule.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstd::cout \u0026lt;\u0026lt; std::format(\"{} {}\", 1, 2, 3); // Noncompliant\nstd::cout \u0026lt;\u0026lt; std::format(\"{0} {2}\", 1, 2, 3); // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstd::cout \u0026lt;\u0026lt; std::format(\"{} {} {}\", 1, 2, 3); // Compliant\nstd::cout \u0026lt;\u0026lt; std::format(\"{0} {1} {2} {1}\", 1, 2, 3); // Compliant\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S6487} - A version of this rule triggers for cases that are likely a bug. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003ccode\u003estd::format\u003c/code\u003e takes as an argument a format string that contains replacement fields (surrounded with \u003ccode\u003e{}\u003c/code\u003e) and a set of extra\narguments that will be formatted inside the replacement fields. Even if the format string is checked at compile-time, it is possible to have a\nmismatch between the format string and the arguments. For example, when:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The format string contains fewer replacement fields than the number of extra arguments: \u003ccode\u003estd::format(\"{} {}\", 1, 2, 3);\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e The format string uses indexes for the replacement fields, but one index is missing: \u003ccode\u003estd::format(\"{0} {0} {2}\", 1, 2, 3);\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn these cases, the extra arguments are silently ignored. In the best-case scenario, it leads to dead code. Otherwise, it is a typo, and the output\nwill not be intended.\u003c/p\u003e\n\u003cp\u003eThis rule detects when the arguments of \u003ccode\u003estd::format\u003c/code\u003e are unused in a way that doesn’t trigger {rule:cpp:S6487}. Therefore, you should\nmake sure that {rule:cpp:S6487} is enabled with this rule.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstd::cout \u0026lt;\u0026lt; std::format(\"{} {}\", 1, 2, 3); // Noncompliant\nstd::cout \u0026lt;\u0026lt; std::format(\"{0} {2}\", 1, 2, 3); // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstd::cout \u0026lt;\u0026lt; std::format(\"{} {} {}\", 1, 2, 3); // Compliant\nstd::cout \u0026lt;\u0026lt; std::format(\"{0} {1} {2} {1}\", 1, 2, 3); // Compliant\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S6487} - A version of this rule triggers for cases that are likely a bug. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "since-c++20",
      "suspicious",
      "unused"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6009",
    "name": "\"std::string_view\" should be used to pass a read-only string to a function",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "EFFICIENT",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003estd::string_view\u003c/code\u003e is a read-only view over a string, it doesn’t hold any data, it only holds a pointer to the first character of the\nstring and its length. \u003ccode\u003estd::string_view\u003c/code\u003e can offer better performance than \u003ccode\u003estd::string\u003c/code\u003e in several cases:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e no memory allocations are required during construction, it is cheap to pass them by value, no need to pass them by reference \u003c/li\u003e\n  \u003cli\u003e no heap allocation when passing a string literal to a \u003ccode\u003estd::string_view\u003c/code\u003e function argument \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003esubstr\u003c/code\u003e operations over a \u003ccode\u003estd::string_view\u003c/code\u003e do not require memory allocation \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWhen using \u003ccode\u003estd::string_view\u003c/code\u003e you shouldn’t however forget that:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e it’s a non-owning range, you should keep into consideration the liveness of the pointed range \u003c/li\u003e\n  \u003cli\u003e it doesn’t guarantee a null-terminated string like \u003ccode\u003estd::string\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis rule flags \u003ccode\u003econst std::string\u0026amp;\u003c/code\u003e function arguments, which can be safely replaced with \u003ccode\u003estd::string_view\u003c/code\u003e ones when\nnot relying on the null-termination character.\u003c/p\u003e\n\u003cp\u003eNote that, if you are calling \u003ccode\u003esubstr\u003c/code\u003e on the parameter, you may have to modify your code to explicitly cast the result to\n\u003ccode\u003estd::string\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid fun(const std::string\u0026amp; name) { // Noncompliant, replace const std::string\u0026amp; by std::string_view\n  // ...\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid fun(std::string_view name) {\n  // ...\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003ccode\u003estd::string_view\u003c/code\u003e is a read-only view over a string, it doesn’t hold any data, it only holds a pointer to the first character of the\nstring and its length. \u003ccode\u003estd::string_view\u003c/code\u003e can offer better performance than \u003ccode\u003estd::string\u003c/code\u003e in several cases:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e no memory allocations are required during construction, it is cheap to pass them by value, no need to pass them by reference \u003c/li\u003e\n  \u003cli\u003e no heap allocation when passing a string literal to a \u003ccode\u003estd::string_view\u003c/code\u003e function argument \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003esubstr\u003c/code\u003e operations over a \u003ccode\u003estd::string_view\u003c/code\u003e do not require memory allocation \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWhen using \u003ccode\u003estd::string_view\u003c/code\u003e you shouldn’t however forget that:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e it’s a non-owning range, you should keep into consideration the liveness of the pointed range \u003c/li\u003e\n  \u003cli\u003e it doesn’t guarantee a null-terminated string like \u003ccode\u003estd::string\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis rule flags \u003ccode\u003econst std::string\u0026amp;\u003c/code\u003e function arguments, which can be safely replaced with \u003ccode\u003estd::string_view\u003c/code\u003e ones when\nnot relying on the null-termination character.\u003c/p\u003e\n\u003cp\u003eNote that, if you are calling \u003ccode\u003esubstr\u003c/code\u003e on the parameter, you may have to modify your code to explicitly cast the result to\n\u003ccode\u003estd::string\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid fun(const std::string\u0026amp; name) { // Noncompliant, replace const std::string\u0026amp; by std::string_view\n  // ...\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid fun(std::string_view name) {\n  // ...\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "since-c++17"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6007",
    "name": "[[nodiscard]] should be used when the return value of a function should not be ignored",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eC++17\u003c/code\u003e introduced \u003ccode\u003e[[nodiscard]]\u003c/code\u003e attribute. When you declare a function \u003ccode\u003e[[nodiscard]]\u003c/code\u003e, you indicate that its\nreturn value should not be ignored.\u0026nbsp;This can help prevent bugs related to:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Memory leak, in case the function returns a pointer to unmanaged memory \u003c/li\u003e\n  \u003cli\u003e Performance, in case the discarded value is costly to construct \u003c/li\u003e\n  \u003cli\u003e Security, in case the return value indicates an error condition that needs to be taken into account \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIf the return value is ignored, the compiler is encouraged to issue a warning. Also, our analyzer will raise an issue, see {rule:cpp:S5277}.\u003c/p\u003e\n\u003cp\u003eNote that you can declare an enumeration or class \u003ccode\u003enodiscard\u003c/code\u003e. In that case, the compiler will warn if the ignored value is coming from\na function that returns a \u003ccode\u003enodiscard\u003c/code\u003e enumeration or class by value.\u003c/p\u003e\n\u003cp\u003eThis rule will suggest adding the \u003ccode\u003e[[nodiscard]]\u003c/code\u003e attribute to functions with no side effects that return a value.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstruct A {\n  std::string name;\n  std::string\u0026amp; getName() { return name;} // Noncompliant\n  std::string const\u0026amp; getName() const {return name;} // Noncompliant\n};\n\nint sum(int x, int y) { // Noncompliant\n  return x + y;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstruct A {\n  std::string name;\n  [[nodiscard]] std::string\u0026amp; getName() { return name;} // Compliant\n  [[nodiscard]] std::string const\u0026amp; getName() const {return name;} // Compliant\n\n};\n\n[[nodiscard]] int sum(int x, int y) { // Compliant\n  return x + y;\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003ccode\u003eC++17\u003c/code\u003e introduced \u003ccode\u003e[[nodiscard]]\u003c/code\u003e attribute. When you declare a function \u003ccode\u003e[[nodiscard]]\u003c/code\u003e, you indicate that its\nreturn value should not be ignored.\u0026nbsp;This can help prevent bugs related to:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Memory leak, in case the function returns a pointer to unmanaged memory \u003c/li\u003e\n  \u003cli\u003e Performance, in case the discarded value is costly to construct \u003c/li\u003e\n  \u003cli\u003e Security, in case the return value indicates an error condition that needs to be taken into account \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIf the return value is ignored, the compiler is encouraged to issue a warning. Also, our analyzer will raise an issue, see {rule:cpp:S5277}.\u003c/p\u003e\n\u003cp\u003eNote that you can declare an enumeration or class \u003ccode\u003enodiscard\u003c/code\u003e. In that case, the compiler will warn if the ignored value is coming from\na function that returns a \u003ccode\u003enodiscard\u003c/code\u003e enumeration or class by value.\u003c/p\u003e\n\u003cp\u003eThis rule will suggest adding the \u003ccode\u003e[[nodiscard]]\u003c/code\u003e attribute to functions with no side effects that return a value.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstruct A {\n  std::string name;\n  std::string\u0026amp; getName() { return name;} // Noncompliant\n  std::string const\u0026amp; getName() const {return name;} // Noncompliant\n};\n\nint sum(int x, int y) { // Noncompliant\n  return x + y;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstruct A {\n  std::string name;\n  [[nodiscard]] std::string\u0026amp; getName() { return name;} // Compliant\n  [[nodiscard]] std::string const\u0026amp; getName() const {return name;} // Compliant\n\n};\n\n[[nodiscard]] int sum(int x, int y) { // Compliant\n  return x + y;\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "since-c++17",
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6008",
    "name": "Fold expressions should be used instead of recursive template instantiations",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eFold expressions, introduced in C++17, are a way to expand a variadic template parameter pack with operators between each pack element. Due to the\nhigh flexibility of this construct, many variadic templates that used to be written by a recursive call can now be written in a more direct way.\u003c/p\u003e\n\u003cp\u003eIn addition to a usually simpler code, fold expressions results in far less functions instantiated, which can improve compilation time.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when a recursive template instantiation that could be easily be replaced by a fold expression is detected\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\ntemplate\u0026lt;class Cont\u0026gt;\nvoid addElementsToContainer(Cont \u0026amp;C) {\n}\n\ntemplate\u0026lt;class Cont, class T, class ...U\u0026gt;\nvoid addElementsToContainer(Cont \u0026amp;C, T \u0026amp;\u0026amp;t, U \u0026amp;\u0026amp;...us) {\n    C.push_back(forward\u0026lt;T\u0026gt;(t));\n    addElementsToContainer(C, forward\u0026lt;U\u0026gt;(us)...); // Noncompliant recursive call\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\ntemplate\u0026lt;class Cont, class ...T\u0026gt;\nvoid addElementsToContainer(Cont \u0026amp;C, T \u0026amp;\u0026amp;...ts) {\n    (C.push_back(std::forward\u0026lt;T\u0026gt;(ts)),...); // Compliant fold expression over the operator \u0027,\u0027\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eFold expressions, introduced in C++17, are a way to expand a variadic template parameter pack with operators between each pack element. Due to the\nhigh flexibility of this construct, many variadic templates that used to be written by a recursive call can now be written in a more direct way.\u003c/p\u003e\n\u003cp\u003eIn addition to a usually simpler code, fold expressions results in far less functions instantiated, which can improve compilation time.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when a recursive template instantiation that could be easily be replaced by a fold expression is detected\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\ntemplate\u0026lt;class Cont\u0026gt;\nvoid addElementsToContainer(Cont \u0026amp;C) {\n}\n\ntemplate\u0026lt;class Cont, class T, class ...U\u0026gt;\nvoid addElementsToContainer(Cont \u0026amp;C, T \u0026amp;\u0026amp;t, U \u0026amp;\u0026amp;...us) {\n    C.push_back(forward\u0026lt;T\u0026gt;(t));\n    addElementsToContainer(C, forward\u0026lt;U\u0026gt;(us)...); // Noncompliant recursive call\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\ntemplate\u0026lt;class Cont, class ...T\u0026gt;\nvoid addElementsToContainer(Cont \u0026amp;C, T \u0026amp;\u0026amp;...ts) {\n    (C.push_back(std::forward\u0026lt;T\u0026gt;(ts)),...); // Compliant fold expression over the operator \u0027,\u0027\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "clumsy",
      "since-c++17"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6030",
    "name": "\"try_emplace\" should be used with \"std::map\" and \"std::unordered_map\"",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "EFFICIENT",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eemplace\u003c/code\u003e and \u003ccode\u003einsert\u003c/code\u003e in \u003ccode\u003estd::map\u003c/code\u003e and \u003ccode\u003estd::unordered_map\u003c/code\u003e might construct the (key, value) pair,\nincluding the value object, even when it is not necessary.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eemplace\u003c/code\u003e destroys the constructed pair if the key is already present, wasting the effort on construction and destruction of the\nvalue.\u003c/p\u003e\n\u003cp\u003eIf \u003ccode\u003einsert\u003c/code\u003e was called with a temporary, it leads to an extra copy or move construction and destruction of the temporary.\u003c/p\u003e\n\u003cp\u003eC++17 introduced \u003ccode\u003etry_emplace\u003c/code\u003e that does not construct the value if the key is already present in the map and constructs the value in\nplace if necessary.\u003c/p\u003e\n\u003cp\u003eIn most cases, you should use \u003ccode\u003etry_emplace\u003c/code\u003e. In particular, if two conditions hold:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e You are inserting a single object at a time. \u003c/li\u003e\n  \u003cli\u003e You are creating a new mapped-to value and/or (key, value) pair just to insert it into the map. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eYou should keep the \u003ccode\u003einsert\u003c/code\u003e if one of the conditions holds:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The (key, value) pair is already constructed (for another purpose). \u003c/li\u003e\n  \u003cli\u003e You want to insert multiple (key, value) pairs with a single call. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eYou should keep \u003ccode\u003eemplace\u003c/code\u003e and \u003ccode\u003eemplace_hint\u003c/code\u003e if\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e You use piecewise construction with \u003ccode\u003estd::piecewise_construct\u003c/code\u003e. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis rule detects calls to \u003ccode\u003einsert\u003c/code\u003e that lead to the construction of a large temporary object, as well as calls to \u003ccode\u003eemplace\u003c/code\u003e\nand \u003ccode\u003eemplace_hint\u003c/code\u003e with no piecewise construction.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid f() {\n  std::map\u0026lt;int, std::string\u0026gt; bodies({{3, \"Lorem ipsum...\"}});\n  bodies.emplace(3, \"Lorem ipsum...\"); // Noncompliant\n  bodies.insert({3, \"Lorem ipsum...\"}); // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid f() {\n  std::map\u0026lt;int, std::string\u0026gt; bodies({{3, \"Lorem ipsum...\"}});\n  bodies.try_emplace(3, \"Lorem ipsum...\"); // Compliant\n  auto p \u003d std::make_pair(3, \"Lorem ipsum...\"); // The (key, value) pair is already constructed for another purpose\n  bodies.insert(p); // Compliant\n  use_the_pair(p);\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eYou should keep \u003ccode\u003einsert\u003c/code\u003e for exception safety if your mapped-to type is a smart pointer and the argument is a \u003ccode\u003enew\u003c/code\u003e\nexpression.\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003ccode\u003eemplace\u003c/code\u003e and \u003ccode\u003einsert\u003c/code\u003e in \u003ccode\u003estd::map\u003c/code\u003e and \u003ccode\u003estd::unordered_map\u003c/code\u003e might construct the (key, value) pair,\nincluding the value object, even when it is not necessary.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eemplace\u003c/code\u003e destroys the constructed pair if the key is already present, wasting the effort on construction and destruction of the\nvalue.\u003c/p\u003e\n\u003cp\u003eIf \u003ccode\u003einsert\u003c/code\u003e was called with a temporary, it leads to an extra copy or move construction and destruction of the temporary.\u003c/p\u003e\n\u003cp\u003eC++17 introduced \u003ccode\u003etry_emplace\u003c/code\u003e that does not construct the value if the key is already present in the map and constructs the value in\nplace if necessary.\u003c/p\u003e\n\u003cp\u003eIn most cases, you should use \u003ccode\u003etry_emplace\u003c/code\u003e. In particular, if two conditions hold:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e You are inserting a single object at a time. \u003c/li\u003e\n  \u003cli\u003e You are creating a new mapped-to value and/or (key, value) pair just to insert it into the map. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eYou should keep the \u003ccode\u003einsert\u003c/code\u003e if one of the conditions holds:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The (key, value) pair is already constructed (for another purpose). \u003c/li\u003e\n  \u003cli\u003e You want to insert multiple (key, value) pairs with a single call. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eYou should keep \u003ccode\u003eemplace\u003c/code\u003e and \u003ccode\u003eemplace_hint\u003c/code\u003e if\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e You use piecewise construction with \u003ccode\u003estd::piecewise_construct\u003c/code\u003e. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis rule detects calls to \u003ccode\u003einsert\u003c/code\u003e that lead to the construction of a large temporary object, as well as calls to \u003ccode\u003eemplace\u003c/code\u003e\nand \u003ccode\u003eemplace_hint\u003c/code\u003e with no piecewise construction.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid f() {\n  std::map\u0026lt;int, std::string\u0026gt; bodies({{3, \"Lorem ipsum...\"}});\n  bodies.emplace(3, \"Lorem ipsum...\"); // Noncompliant\n  bodies.insert({3, \"Lorem ipsum...\"}); // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid f() {\n  std::map\u0026lt;int, std::string\u0026gt; bodies({{3, \"Lorem ipsum...\"}});\n  bodies.try_emplace(3, \"Lorem ipsum...\"); // Compliant\n  auto p \u003d std::make_pair(3, \"Lorem ipsum...\"); // The (key, value) pair is already constructed for another purpose\n  bodies.insert(p); // Compliant\n  use_the_pair(p);\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eYou should keep \u003ccode\u003einsert\u003c/code\u003e for exception safety if your mapped-to type is a smart pointer and the argument is a \u003ccode\u003enew\u003c/code\u003e\nexpression.\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "performance",
      "since-c++17"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5184",
    "name": "RAII objects should not be temporary",
    "defaultSeverity": "BLOCKER",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe RAII idiom associates the lifetime of a resource with the lifetime of an object: The resource is acquired when the object is created, and\nreleased when it is destroyed.\u003c/p\u003e\n\u003cp\u003eIf the object that controls the resource lifetime is a temporary, chances are it will get destroyed while the resource should still be in use,\nleading to resource corruption. This rule detects temporaries that look like RAII objects.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid f() {\n  scoped_lock{myMutex}; // Noncompliant. The mutex will be locked then immediately unlocked\n  protectedCode(); // This code is not protected by the mutex\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid f() {\n  scoped_lock lock{myMutex}; // Compliant\n  protectedCode();\n  // The mutex is correctly released at this point\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es84-dont-try-to-declare-a-local-variable-with-no-name\"\u003eES.84:\n  Don’t try to declare a local variable with no name\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe RAII idiom associates the lifetime of a resource with the lifetime of an object: The resource is acquired when the object is created, and\nreleased when it is destroyed.\u003c/p\u003e\n\u003cp\u003eIf the object that controls the resource lifetime is a temporary, chances are it will get destroyed while the resource should still be in use,\nleading to resource corruption. This rule detects temporaries that look like RAII objects.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid f() {\n  scoped_lock{myMutex}; // Noncompliant. The mutex will be locked then immediately unlocked\n  protectedCode(); // This code is not protected by the mutex\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid f() {\n  scoped_lock lock{myMutex}; // Compliant\n  protectedCode();\n  // The mutex is correctly released at this point\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es84-dont-try-to-declare-a-local-variable-with-no-name\"\u003eES.84:\n  Don’t try to declare a local variable with no name\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cppcoreguidelines",
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6031",
    "name": "The right template argument should be specified for std::forward",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003estd::forward\u003c/code\u003e forwards lvalues either as lvalues or as rvalues based on its template argument.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003estd::forward\u003c/code\u003e should always take as a non-template argument a forwarding reference which is defined by the standard as:\u003c/p\u003e\n\u003cp\u003e\u003cem\u003ervalue reference to a cv-unqualified template parameter that does not represent a template parameter of a class template.\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eIf you don’t pass forwarding reference as an argument to \u003ccode\u003estd::forward\u003c/code\u003e {rule:cpp:S5417} will be triggered.\u003c/p\u003e\n\u003cp\u003eIf you don’t pass the template parameter referred to by the forwarded reference or the \u003ccode\u003edecltype\u003c/code\u003e of the forwarded expression this rule\nwill be triggered.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\ntemplate \u0026lt;class T\u0026gt;\nvoid g(T\u0026amp;\u0026amp; t);\n\ntemplate \u0026lt;class T\u0026gt;\nvoid f(T\u0026amp;\u0026amp; t) {\n g(std::forward\u0026lt;T\u0026amp;\u0026amp;\u0026gt;(t)); // Noncompliant\n g(std::forward\u0026lt;T\u0026amp;\u0026gt;(t)); // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\ntemplate \u0026lt;class T\u0026gt;\nvoid g(T\u0026amp;\u0026amp; t);\n\ntemplate \u0026lt;class T\u0026gt;\nvoid f(T\u0026amp;\u0026amp; t) {\n  g(std::forward\u0026lt;T\u0026gt;(t)); // Compliant\n}\n\nstruct StrWrapper {\n  std::string s \u003d \"rand\";\n  std::string getStr() \u0026amp;\u0026amp; {\n    return s;\n  }\n  std::string\u0026amp; getStr() \u0026amp; {\n    return s;\n  }\n};\ntemplate \u0026lt;class T\u0026gt;\nvoid fstr(T\u0026amp;\u0026amp; str);\n\ntemplate \u0026lt;class T\u0026gt;\nvoid wrapper(T\u0026amp;\u0026amp; strWrapper ) {\n  fstr(forward\u0026lt;decltype(forward\u0026lt;T\u0026gt;(strWrapper).getStr())\u0026gt;(forward\u0026lt;T\u0026gt;(strWrapper).getStr())); // Compliant\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003ccode\u003estd::forward\u003c/code\u003e forwards lvalues either as lvalues or as rvalues based on its template argument.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003estd::forward\u003c/code\u003e should always take as a non-template argument a forwarding reference which is defined by the standard as:\u003c/p\u003e\n\u003cp\u003e\u003cem\u003ervalue reference to a cv-unqualified template parameter that does not represent a template parameter of a class template.\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eIf you don’t pass forwarding reference as an argument to \u003ccode\u003estd::forward\u003c/code\u003e {rule:cpp:S5417} will be triggered.\u003c/p\u003e\n\u003cp\u003eIf you don’t pass the template parameter referred to by the forwarded reference or the \u003ccode\u003edecltype\u003c/code\u003e of the forwarded expression this rule\nwill be triggered.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\ntemplate \u0026lt;class T\u0026gt;\nvoid g(T\u0026amp;\u0026amp; t);\n\ntemplate \u0026lt;class T\u0026gt;\nvoid f(T\u0026amp;\u0026amp; t) {\n g(std::forward\u0026lt;T\u0026amp;\u0026amp;\u0026gt;(t)); // Noncompliant\n g(std::forward\u0026lt;T\u0026amp;\u0026gt;(t)); // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\ntemplate \u0026lt;class T\u0026gt;\nvoid g(T\u0026amp;\u0026amp; t);\n\ntemplate \u0026lt;class T\u0026gt;\nvoid f(T\u0026amp;\u0026amp; t) {\n  g(std::forward\u0026lt;T\u0026gt;(t)); // Compliant\n}\n\nstruct StrWrapper {\n  std::string s \u003d \"rand\";\n  std::string getStr() \u0026amp;\u0026amp; {\n    return s;\n  }\n  std::string\u0026amp; getStr() \u0026amp; {\n    return s;\n  }\n};\ntemplate \u0026lt;class T\u0026gt;\nvoid fstr(T\u0026amp;\u0026amp; str);\n\ntemplate \u0026lt;class T\u0026gt;\nvoid wrapper(T\u0026amp;\u0026amp; strWrapper ) {\n  fstr(forward\u0026lt;decltype(forward\u0026lt;T\u0026gt;(strWrapper).getStr())\u0026gt;(forward\u0026lt;T\u0026gt;(strWrapper).getStr())); // Compliant\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "clumsy",
      "pitfall",
      "since-c++11"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6391",
    "name": "Coroutines should not take const references as parameters",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eCoroutines, introduced in C++20, are functions in which execution can be suspended and resumed. When a coroutine resumes, it takes over where it\nleft thanks to the coroutine state.\u003c/p\u003e\n\u003cp\u003eA \u003cem\u003ecoroutine state\u003c/em\u003e is an object which contains all the information a coroutine needs to resume its execution correctly: local variables,\ncopy of the parameters…​\u003c/p\u003e\n\u003cp\u003eThis means that if a coroutine has a parameter that is a reference to an object, this object must exist as long as the coroutine is not destroyed.\nOtherwise, the reference stored in the \u003cem\u003ecoroutine state\u003c/em\u003e will become a dangling reference and will lead to undefined behavior when the\ncoroutine resumes.\u003c/p\u003e\n\u003cp\u003eThe issue is raised for all coroutine parameters with reference-to-const semantics (such as a \u003ccode\u003econst\u003c/code\u003e reference, a\n\u003ccode\u003estd::string_view\u003c/code\u003e, or a \u003ccode\u003estd::span\u003c/code\u003e with \u003ccode\u003econst\u003c/code\u003e elements) that might be used after the coroutine is suspended.\u003c/p\u003e\n\u003cp\u003eTo fix the issue, you can either pass the parameter by value, or not use the parameter after the first suspension point (\u003ccode\u003eco_await\u003c/code\u003e,\n\u003ccode\u003eco_yield\u003c/code\u003e, or \u003ccode\u003einitial_suspend\u003c/code\u003e).\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\ngenerator\u0026lt;char\u0026gt; spell(const std::string\u0026amp; m) { // Noncompliant\n    for (char letter : m) {\n        co_yield letter;\n    }\n}\n\nvoid print() {\n    for (char letter : spell(\"hello world\")) { // Here the parameter \"m\" binds to a temporary\n        std::cout \u0026lt;\u0026lt; letter \u0026lt;\u0026lt; \u0027\\n\u0027;           // and becomes dangling on the next iteration\n    }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\ngenerator\u0026lt;char\u0026gt; spell(const std::string m) { // Compliant: take the argument by copy\n    for (char letter : m) {\n        co_yield letter;\n    }\n}\n\nvoid print() {\n    for (char letter : spell(\"hello world\")) {\n        std::cout \u0026lt;\u0026lt; letter \u0026lt;\u0026lt; \u0027\\n\u0027;\n    }\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThis rule does not raise an issue for \u003ccode\u003estd::reference_wrapper\u003c/code\u003e parameters taking it as a witness of the care taken to prevent the\nreference to become dangling.\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eCoroutines, introduced in C++20, are functions in which execution can be suspended and resumed. When a coroutine resumes, it takes over where it\nleft thanks to the coroutine state.\u003c/p\u003e\n\u003cp\u003eA \u003cem\u003ecoroutine state\u003c/em\u003e is an object which contains all the information a coroutine needs to resume its execution correctly: local variables,\ncopy of the parameters…​\u003c/p\u003e\n\u003cp\u003eThis means that if a coroutine has a parameter that is a reference to an object, this object must exist as long as the coroutine is not destroyed.\nOtherwise, the reference stored in the \u003cem\u003ecoroutine state\u003c/em\u003e will become a dangling reference and will lead to undefined behavior when the\ncoroutine resumes.\u003c/p\u003e\n\u003cp\u003eThe issue is raised for all coroutine parameters with reference-to-const semantics (such as a \u003ccode\u003econst\u003c/code\u003e reference, a\n\u003ccode\u003estd::string_view\u003c/code\u003e, or a \u003ccode\u003estd::span\u003c/code\u003e with \u003ccode\u003econst\u003c/code\u003e elements) that might be used after the coroutine is suspended.\u003c/p\u003e\n\u003cp\u003eTo fix the issue, you can either pass the parameter by value, or not use the parameter after the first suspension point (\u003ccode\u003eco_await\u003c/code\u003e,\n\u003ccode\u003eco_yield\u003c/code\u003e, or \u003ccode\u003einitial_suspend\u003c/code\u003e).\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\ngenerator\u0026lt;char\u0026gt; spell(const std::string\u0026amp; m) { // Noncompliant\n    for (char letter : m) {\n        co_yield letter;\n    }\n}\n\nvoid print() {\n    for (char letter : spell(\"hello world\")) { // Here the parameter \"m\" binds to a temporary\n        std::cout \u0026lt;\u0026lt; letter \u0026lt;\u0026lt; \u0027\\n\u0027;           // and becomes dangling on the next iteration\n    }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\ngenerator\u0026lt;char\u0026gt; spell(const std::string m) { // Compliant: take the argument by copy\n    for (char letter : m) {\n        co_yield letter;\n    }\n}\n\nvoid print() {\n    for (char letter : spell(\"hello world\")) {\n        std::cout \u0026lt;\u0026lt; letter \u0026lt;\u0026lt; \u0027\\n\u0027;\n    }\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThis rule does not raise an issue for \u003ccode\u003estd::reference_wrapper\u003c/code\u003e parameters taking it as a witness of the care taken to prevent the\nreference to become dangling.\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6032",
    "name": "Unnecessary expensive copy should be avoided when using auto as a placeholder type",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "EFFICIENT",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eUnintentional expensive copy should be avoided when using \u003ccode\u003eauto\u003c/code\u003e as a placeholder type.\u003c/p\u003e\n\u003cp\u003eWhen using \u003ccode\u003econst auto\u003c/code\u003e as a placeholder type, you might unintentionally forget to add an ampersand(\u003ccode\u003e\u0026amp;\u003c/code\u003e) after the\n\u003ccode\u003eauto\u003c/code\u003e keyword. This can silently create a pointless copy and possibly have a bad impact on the performance of your code depending on the\nsize of the created object and its context.\u003c/p\u003e\n\u003cp\u003eFor example, if it happens in a range-based for loop context, it is going to lead to creating as many useless objects as the size of the range.\u003c/p\u003e\n\u003cp\u003eThis rule will detect a declaration of an unmodified local variable with expensive to copy type and \u003ccode\u003eauto\u003c/code\u003e as a placeholder type that is\ninitialized with a non-temporary object.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid printVec(const std::vector\u0026lt;std::string\u0026gt;\u0026amp; namesOfTheEntirePopulation) {\n  for (const auto name : namesOfTheEntirePopulation) { // Noncompliant\n    std::cout \u0026lt;\u0026lt; name;\n  }\n}\n\nvoid ignore(const std::vector\u0026lt;std::string\u0026gt;\u0026amp; vec);\nvoid ignoreAgain(const std::vector\u0026lt;std::string\u0026gt;\u0026amp; vec);\n\nvoid ignore(VecWrapper vec) {\n  const auto namesOfCPPHaters \u003d vec.getNamesOfCPPHaters(); // Noncompliant\n  ignore(namesOfCPPHaters);\n  ignoreAgain(namesOfCPPHaters);\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid modifyName(std::string\u0026amp; a);\nvoid printVec(std::vector\u0026lt;std::string\u0026gt;\u0026amp; namesOfTheEntirePopulation) {\n  for (const auto\u0026amp; name : namesOfTheEntirePopulation) { // Compliant\n    std::cout \u0026lt;\u0026lt; name;\n  }\n\n  for (auto name : namesOfTheEntirePopulation) { // Compliant: a copy is needed to avoid modifying the original list of names\n    modifyName(name);\n    std::cout \u0026lt;\u0026lt; name;\n  }\n}\n\nvoid ignore(const std::vector\u0026lt;std::string\u0026gt;\u0026amp; vec);\nvoid ignoreAgain(const std::vector\u0026lt;std::string\u0026gt;\u0026amp; vec);\n\nvoid ignore(VecWrapper vec) {\n  const auto\u0026amp; namesOfCPPHaters \u003d vec.getNamesOfCPPHaters(); // Compliant\n  ignore(namesOfCPPHaters);\n  ignoreAgain(namesOfCPPHaters);\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eUnintentional expensive copy should be avoided when using \u003ccode\u003eauto\u003c/code\u003e as a placeholder type.\u003c/p\u003e\n\u003cp\u003eWhen using \u003ccode\u003econst auto\u003c/code\u003e as a placeholder type, you might unintentionally forget to add an ampersand(\u003ccode\u003e\u0026amp;\u003c/code\u003e) after the\n\u003ccode\u003eauto\u003c/code\u003e keyword. This can silently create a pointless copy and possibly have a bad impact on the performance of your code depending on the\nsize of the created object and its context.\u003c/p\u003e\n\u003cp\u003eFor example, if it happens in a range-based for loop context, it is going to lead to creating as many useless objects as the size of the range.\u003c/p\u003e\n\u003cp\u003eThis rule will detect a declaration of an unmodified local variable with expensive to copy type and \u003ccode\u003eauto\u003c/code\u003e as a placeholder type that is\ninitialized with a non-temporary object.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid printVec(const std::vector\u0026lt;std::string\u0026gt;\u0026amp; namesOfTheEntirePopulation) {\n  for (const auto name : namesOfTheEntirePopulation) { // Noncompliant\n    std::cout \u0026lt;\u0026lt; name;\n  }\n}\n\nvoid ignore(const std::vector\u0026lt;std::string\u0026gt;\u0026amp; vec);\nvoid ignoreAgain(const std::vector\u0026lt;std::string\u0026gt;\u0026amp; vec);\n\nvoid ignore(VecWrapper vec) {\n  const auto namesOfCPPHaters \u003d vec.getNamesOfCPPHaters(); // Noncompliant\n  ignore(namesOfCPPHaters);\n  ignoreAgain(namesOfCPPHaters);\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid modifyName(std::string\u0026amp; a);\nvoid printVec(std::vector\u0026lt;std::string\u0026gt;\u0026amp; namesOfTheEntirePopulation) {\n  for (const auto\u0026amp; name : namesOfTheEntirePopulation) { // Compliant\n    std::cout \u0026lt;\u0026lt; name;\n  }\n\n  for (auto name : namesOfTheEntirePopulation) { // Compliant: a copy is needed to avoid modifying the original list of names\n    modifyName(name);\n    std::cout \u0026lt;\u0026lt; name;\n  }\n}\n\nvoid ignore(const std::vector\u0026lt;std::string\u0026gt;\u0026amp; vec);\nvoid ignoreAgain(const std::vector\u0026lt;std::string\u0026gt;\u0026amp; vec);\n\nvoid ignore(VecWrapper vec) {\n  const auto\u0026amp; namesOfCPPHaters \u003d vec.getNamesOfCPPHaters(); // Compliant\n  ignore(namesOfCPPHaters);\n  ignoreAgain(namesOfCPPHaters);\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "clumsy",
      "performance",
      "since-c++11"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6033",
    "name": "\"emplace\" should be prefered over \"insert\" with \"std::set\" and \"std::unordered_set\"",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "EFFICIENT",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eemplace\u003c/code\u003e enables you to avoid copying or moving the value you are about to insert and, instead, it constructs it in-place with the\narguments provided.\u003c/p\u003e\n\u003cp\u003ePrefer using \u003ccode\u003eemplace\u003c/code\u003e, or \u003ccode\u003eemplace_hint\u003c/code\u003e if all the conditions hold:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e You are inserting a single value. \u003c/li\u003e\n  \u003cli\u003e You are constructing a fresh temporary value just to insert it into the set. \u003c/li\u003e\n  \u003cli\u003e You expect that the key is not in the set. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eYou should keep the \u003ccode\u003einsert\u003c/code\u003e in any of the cases below:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e You are inserting multiple values in one shot. \u003c/li\u003e\n  \u003cli\u003e You are inserting a pre-existing value that is constructed for another purpose. \u003c/li\u003e\n  \u003cli\u003e You are inserting an object that is cheap to move or to copy (e.g., an integer). \u003c/li\u003e\n  \u003cli\u003e The key you are inserting is likely to be in the set (in this case by using \u003ccode\u003einsert\u003c/code\u003e you avoid creating a useless temporary node).\n  \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis rule detects calls to \u003ccode\u003einsert\u003c/code\u003e that lead to the creation of a large temporary object that\u0026nbsp;can be avoided by using the\n\u003ccode\u003eemplace\u003c/code\u003e member function.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstruct A {\n  int x;\n  std::array\u0026lt;std::string, 100\u0026gt; more;// Expensive to copy or move\npublic:\n  A(int x, const std::string\u0026amp; more) : x(x), more({more}) {}\n  bool operator\u0026lt;(A const \u0026amp;other) const {\n    return x \u0026lt; other.x;\n  }\n};\nstd::array\u0026lt;std::string, 3\u0026gt; strs \u003d {\"big brown fox\", \"little kitten\", \"regular human\"};\nvoid f() {\n  std::set\u0026lt;A\u0026gt; set;\n  for (int i \u003d 0; i \u0026lt; 1\u0027000\u0027000; ++i) {\n    set.insert(A{i, strs[i%3]});// Noncompliant\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstruct A {\n  int x;\n  std::array\u0026lt;std::string, 100\u0026gt; more;// Expensive to copy or move\npublic:\n  A(int x, const std::string\u0026amp; more) : x(x), more({more}) {}\n  bool operator\u0026lt;(A const \u0026amp;other) const {\n    return x \u0026lt; other.x;\n  }\n};\nstd::array\u0026lt;std::string, 3\u0026gt; strs \u003d {\"big brown fox\", \"little kitten\", \"regular human\"};\nvoid f() {\n  std::set\u0026lt;A\u0026gt; set;\n  for (int i \u003d 0; i \u0026lt; 1\u0027000\u0027000; ++i) {\n    set.emplace(i, strs[i%3]);// Compliant\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eYou should keep \u003ccode\u003einsert\u003c/code\u003e for exception safety if your key type is a smart pointer and the argument is a new expression.\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003ccode\u003eemplace\u003c/code\u003e enables you to avoid copying or moving the value you are about to insert and, instead, it constructs it in-place with the\narguments provided.\u003c/p\u003e\n\u003cp\u003ePrefer using \u003ccode\u003eemplace\u003c/code\u003e, or \u003ccode\u003eemplace_hint\u003c/code\u003e if all the conditions hold:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e You are inserting a single value. \u003c/li\u003e\n  \u003cli\u003e You are constructing a fresh temporary value just to insert it into the set. \u003c/li\u003e\n  \u003cli\u003e You expect that the key is not in the set. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eYou should keep the \u003ccode\u003einsert\u003c/code\u003e in any of the cases below:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e You are inserting multiple values in one shot. \u003c/li\u003e\n  \u003cli\u003e You are inserting a pre-existing value that is constructed for another purpose. \u003c/li\u003e\n  \u003cli\u003e You are inserting an object that is cheap to move or to copy (e.g., an integer). \u003c/li\u003e\n  \u003cli\u003e The key you are inserting is likely to be in the set (in this case by using \u003ccode\u003einsert\u003c/code\u003e you avoid creating a useless temporary node).\n  \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis rule detects calls to \u003ccode\u003einsert\u003c/code\u003e that lead to the creation of a large temporary object that\u0026nbsp;can be avoided by using the\n\u003ccode\u003eemplace\u003c/code\u003e member function.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstruct A {\n  int x;\n  std::array\u0026lt;std::string, 100\u0026gt; more;// Expensive to copy or move\npublic:\n  A(int x, const std::string\u0026amp; more) : x(x), more({more}) {}\n  bool operator\u0026lt;(A const \u0026amp;other) const {\n    return x \u0026lt; other.x;\n  }\n};\nstd::array\u0026lt;std::string, 3\u0026gt; strs \u003d {\"big brown fox\", \"little kitten\", \"regular human\"};\nvoid f() {\n  std::set\u0026lt;A\u0026gt; set;\n  for (int i \u003d 0; i \u0026lt; 1\u0027000\u0027000; ++i) {\n    set.insert(A{i, strs[i%3]});// Noncompliant\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstruct A {\n  int x;\n  std::array\u0026lt;std::string, 100\u0026gt; more;// Expensive to copy or move\npublic:\n  A(int x, const std::string\u0026amp; more) : x(x), more({more}) {}\n  bool operator\u0026lt;(A const \u0026amp;other) const {\n    return x \u0026lt; other.x;\n  }\n};\nstd::array\u0026lt;std::string, 3\u0026gt; strs \u003d {\"big brown fox\", \"little kitten\", \"regular human\"};\nvoid f() {\n  std::set\u0026lt;A\u0026gt; set;\n  for (int i \u003d 0; i \u0026lt; 1\u0027000\u0027000; ++i) {\n    set.emplace(i, strs[i%3]);// Compliant\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eYou should keep \u003ccode\u003einsert\u003c/code\u003e for exception safety if your key type is a smart pointer and the argument is a new expression.\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "performance",
      "since-c++11"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5180",
    "name": "The addresses of standard library functions should not be taken",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eTaking the address of a library function is not something robust: The library might make changes to a function that are compatible with a normal\nuse of a function, but not with taking its address (for instance, adding a parameter with a default value, or adding an overload to an overload set).\nMore specifically, the standard library has stated that there would be no barrier against such changes, and that for stability users should not take\nthe address of standard library functions.\u003c/p\u003e\n\u003cp\u003eStarting with C++20, it’s no longer allowed to take the address of a standard library function (with some exceptions with functions for formatting\nstreams).\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint main() {\n  std::unique_ptr\u0026lt;std::FILE, int(*)(std::FILE*)\u0026gt; fp(\n    std::fopen(\"test.txt\", \"r\"),\n    std::fclose); // Noncompliant, address of fclose is implicitly taken\n  // Work with fp\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint main() {\n  std::unique_ptr\u0026lt;std::FILE, int(*)(std::FILE*)\u0026gt; fp(\n    std::fopen(\"test.txt\", \"r\"),\n    [](std::FILE*file){return std::fclose(file);});\n  // Work with fp\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wg21.link/P0921\"\u003eDocument of the C++ standardization committee about change management in the standard library.\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eTaking the address of a library function is not something robust: The library might make changes to a function that are compatible with a normal\nuse of a function, but not with taking its address (for instance, adding a parameter with a default value, or adding an overload to an overload set).\nMore specifically, the standard library has stated that there would be no barrier against such changes, and that for stability users should not take\nthe address of standard library functions.\u003c/p\u003e\n\u003cp\u003eStarting with C++20, it’s no longer allowed to take the address of a standard library function (with some exceptions with functions for formatting\nstreams).\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint main() {\n  std::unique_ptr\u0026lt;std::FILE, int(*)(std::FILE*)\u0026gt; fp(\n    std::fopen(\"test.txt\", \"r\"),\n    std::fclose); // Noncompliant, address of fclose is implicitly taken\n  // Work with fp\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint main() {\n  std::unique_ptr\u0026lt;std::FILE, int(*)(std::FILE*)\u0026gt; fp(\n    std::fopen(\"test.txt\", \"r\"),\n    [](std::FILE*file){return std::fclose(file);});\n  // Work with fp\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wg21.link/P0921\"\u003eDocument of the C++ standardization committee about change management in the standard library.\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1820",
    "name": "Structures should not have too many fields",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "FOCUSED",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eA structure, such as a \u003ccode\u003estruct\u003c/code\u003e, \u003ccode\u003eunion\u003c/code\u003e or \u003ccode\u003eclass\u003c/code\u003e that grows too much tends to aggregate too many\nresponsibilities and inevitably becomes harder to understand and therefore to maintain, and having a lot of fields is an indication that a structure\nhas grown too large.\u003c/p\u003e\n\u003cp\u003eAbove a specific threshold, it is strongly advised to refactor the structure into smaller ones that focus on well defined topics.\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eA structure, such as a \u003ccode\u003estruct\u003c/code\u003e, \u003ccode\u003eunion\u003c/code\u003e or \u003ccode\u003eclass\u003c/code\u003e that grows too much tends to aggregate too many\nresponsibilities and inevitably becomes harder to understand and therefore to maintain, and having a lot of fields is an indication that a structure\nhas grown too large.\u003c/p\u003e\n\u003cp\u003eAbove a specific threshold, it is strongly advised to refactor the structure into smaller ones that focus on well defined topics.\u003c/p\u003e"
      }
    ],
    "params": {
      "maximumFieldThreshold": {
        "key": "maximumFieldThreshold",
        "name": "maximumFieldThreshold",
        "description": "The maximum number of fields",
        "defaultValue": "20",
        "type": "INTEGER",
        "multiple": false,
        "possibleValues": []
      }
    },
    "defaultParams": {
      "maximumFieldThreshold": "20"
    },
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "brain-overload"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1821",
    "name": "\"switch\" statements should not be nested",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "FOCUSED",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eNested \u003ccode\u003eswitch\u003c/code\u003e structures are difficult to understand because you can easily confuse the cases of an inner \u003ccode\u003eswitch\u003c/code\u003e as\nbelonging to an outer statement. Therefore nested \u003ccode\u003eswitch\u003c/code\u003e statements should be avoided.\u003c/p\u003e\n\u003cp\u003eSpecifically, you should structure your code to avoid the need for nested \u003ccode\u003eswitch\u003c/code\u003e statements, but if you cannot, then consider moving\nthe inner \u003ccode\u003eswitch\u003c/code\u003e to another function.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid func(int n, int m) {\n\n  switch (n) {\n    case 1:\n      // ...\n    case 2:\n      // ...\n    case 3:\n      switch (m) {  // Noncompliant\n    case 4:  // Bad indentation makes this particularly hard to read properly\n      // ...\n    case 5:\n      // ...\n    case 6:\n      // ...\n    }\n    case 4:\n      // ...\n    default:\n      // ...\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid func(int n, int m) {\n\n  switch (n) {\n    case 1:\n      // ...\n    case 2:\n      // ...\n    case 3:\n      int m2 \u003d handle_m(m);\n    case 4:\n      // ...\n    default:\n      // ...\n  }\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eNested \u003ccode\u003eswitch\u003c/code\u003e structures are difficult to understand because you can easily confuse the cases of an inner \u003ccode\u003eswitch\u003c/code\u003e as\nbelonging to an outer statement. Therefore nested \u003ccode\u003eswitch\u003c/code\u003e statements should be avoided.\u003c/p\u003e\n\u003cp\u003eSpecifically, you should structure your code to avoid the need for nested \u003ccode\u003eswitch\u003c/code\u003e statements, but if you cannot, then consider moving\nthe inner \u003ccode\u003eswitch\u003c/code\u003e to another function.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid func(int n, int m) {\n\n  switch (n) {\n    case 1:\n      // ...\n    case 2:\n      // ...\n    case 3:\n      switch (m) {  // Noncompliant\n    case 4:  // Bad indentation makes this particularly hard to read properly\n      // ...\n    case 5:\n      // ...\n    case 6:\n      // ...\n    }\n    case 4:\n      // ...\n    default:\n      // ...\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid func(int n, int m) {\n\n  switch (n) {\n    case 1:\n      // ...\n    case 2:\n      // ...\n    case 3:\n      int m2 \u003d handle_m(m);\n    case 4:\n      // ...\n    default:\n      // ...\n  }\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1705",
    "name": "The prefix increment/decrement form should be used",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "EFFICIENT",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003ePostfix increment and decrement typically involves making a copy of the object being incremented or decremented, whereas its prefix form does not.\nTherefore the prefix form is usually the more efficient form, and should be preferred.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue if a postfix increment or decrement operator is used, but its return value is not read.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid myFunc(int lim)\n{\n  int i;\n  for (i \u003d 0; i \u0026lt; lim; i++)\n  {\n    // do something\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid myFunc(int lim)\n{\n  int i;\n  for (i \u003d 0; i \u0026lt; lim; ++i)\n  {\n    // do something\n  }\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003ePostfix increment and decrement typically involves making a copy of the object being incremented or decremented, whereas its prefix form does not.\nTherefore the prefix form is usually the more efficient form, and should be preferred.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue if a postfix increment or decrement operator is used, but its return value is not read.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid myFunc(int lim)\n{\n  int i;\n  for (i \u003d 0; i \u0026lt; lim; i++)\n  {\n    // do something\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid myFunc(int lim)\n{\n  int i;\n  for (i \u003d 0; i \u0026lt; lim; ++i)\n  {\n    // do something\n  }\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "performance"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1706",
    "name": "Exceptions should not be used",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhile exceptions are a common feature of modern languages, there are several reasons to potentially avoid them:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e They make the control flow of a program difficult to understand, because they introduce additional exit points. \u003c/li\u003e\n  \u003cli\u003e The use of exceptions in new code can make that code difficult to integrate with existing, non-exception-safe code. \u003c/li\u003e\n  \u003cli\u003e They add to the size of each binary produced, thereby increasing both compile time and final executable size. \u003c/li\u003e\n  \u003cli\u003e They may incur a small performance penalty. \u003c/li\u003e\n  \u003cli\u003e The time required to handle an exception is not easy to assess, which makes them difficult to use for hard real-time applications. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis rule raises an issue when:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e an exception is \u003ccode\u003ethrow\u003c/code\u003en \u003c/li\u003e\n  \u003cli\u003e a \u003ccode\u003etry\u003c/code\u003e-\u003ccode\u003ecatch\u003c/code\u003e block is used \u003c/li\u003e\n  \u003cli\u003e an exception specification (\u003ccode\u003ethrow(xxx)\u003c/code\u003e) is present. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cp\u003eThis C++ code example also applies to Objective-C.\u003c/p\u003e\n\u003cpre\u003e\ndouble myfunction(char param) throw (int); // Noncompliant\nvoid f {\n  try // Noncompliant\n  {\n    do_something();\n    throw 1; // Noncompliant\n  }\n  catch (...)\n  {\n    // handle exception\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\ndouble myfunction(char param) noexcept;\nbool f {\n  if (!do_something()); {\n    // Handle the situation\n    return false;\n  }\n  // Rest of the code\n  return true;\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003enoexcept\u003c/code\u003e specifications are ignored, because even if you choose not to use exceptions in your code, it’s important to decorate as\n\u003ccode\u003enoexcept\u003c/code\u003e certain functions (for instance, move constructors that do not \u003ccode\u003ethrow\u003c/code\u003e). This decoration can be detected by type\ntraits, and some meta-programming techniques rely on this information.\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhile exceptions are a common feature of modern languages, there are several reasons to potentially avoid them:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e They make the control flow of a program difficult to understand, because they introduce additional exit points. \u003c/li\u003e\n  \u003cli\u003e The use of exceptions in new code can make that code difficult to integrate with existing, non-exception-safe code. \u003c/li\u003e\n  \u003cli\u003e They add to the size of each binary produced, thereby increasing both compile time and final executable size. \u003c/li\u003e\n  \u003cli\u003e They may incur a small performance penalty. \u003c/li\u003e\n  \u003cli\u003e The time required to handle an exception is not easy to assess, which makes them difficult to use for hard real-time applications. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis rule raises an issue when:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e an exception is \u003ccode\u003ethrow\u003c/code\u003en \u003c/li\u003e\n  \u003cli\u003e a \u003ccode\u003etry\u003c/code\u003e-\u003ccode\u003ecatch\u003c/code\u003e block is used \u003c/li\u003e\n  \u003cli\u003e an exception specification (\u003ccode\u003ethrow(xxx)\u003c/code\u003e) is present. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cp\u003eThis C++ code example also applies to Objective-C.\u003c/p\u003e\n\u003cpre\u003e\ndouble myfunction(char param) throw (int); // Noncompliant\nvoid f {\n  try // Noncompliant\n  {\n    do_something();\n    throw 1; // Noncompliant\n  }\n  catch (...)\n  {\n    // handle exception\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\ndouble myfunction(char param) noexcept;\nbool f {\n  if (!do_something()); {\n    // Handle the situation\n    return false;\n  }\n  // Rest of the code\n  return true;\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003enoexcept\u003c/code\u003e specifications are ignored, because even if you choose not to use exceptions in your code, it’s important to decorate as\n\u003ccode\u003enoexcept\u003c/code\u003e certain functions (for instance, move constructors that do not \u003ccode\u003ethrow\u003c/code\u003e). This decoration can be detected by type\ntraits, and some meta-programming techniques rely on this information.\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5293",
    "name": "Format strings should comply with ISO standards",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe possibilities of ISO C \u003ccode\u003eprintf\u003c/code\u003e format strings are limited, this is why many extensions have been added by several implementations.\nEven though they are widespread and similar in many implementations, they are not standard, which means that using them may create portability\nissues.\u003c/p\u003e\n\u003cp\u003eThis rule reports an issue when format strings do not comply with ISO C standards.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid test() {\n  printf(\"%1$d\", 1); // Noncompliant; positional arguments are not supported by ISO C\n  printf(\"%qd\", (long long)1); // Noncompliant; length specifier \"q\" is not supported by ISO C\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe possibilities of ISO C \u003ccode\u003eprintf\u003c/code\u003e format strings are limited, this is why many extensions have been added by several implementations.\nEven though they are widespread and similar in many implementations, they are not standard, which means that using them may create portability\nissues.\u003c/p\u003e\n\u003cp\u003eThis rule reports an issue when format strings do not comply with ISO C standards.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid test() {\n  printf(\"%1$d\", 1); // Noncompliant; positional arguments are not supported by ISO C\n  printf(\"%qd\", (long long)1); // Noncompliant; length specifier \"q\" is not supported by ISO C\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "convention"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6020",
    "name": "The \"_t\" and \"_v\" version of type traits should be used instead of \"::type\" and \"::value\"",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhen they were first introduced in the language, type traits, defined in header \u003ccode\u003e\u0026lt;type_traits\u0026gt;,\u003c/code\u003e\u0026nbsp;required to use nested types\n(with \u003ccode\u003e::type\u003c/code\u003e)\u0026nbsp;or nested values (with \u003ccode\u003e::value\u003c/code\u003e) to access the result of the trait. Since then, the language introduced\ntemplated alias declaration and variable templates that allow to define traits in a more direct and readable way.\u003c/p\u003e\n\u003cp\u003eEven if the old variant still exists, the new one, which uses \u003ccode\u003e_t\u003c/code\u003e (C++14) and \u003ccode\u003e_v\u003c/code\u003e (C++17) suffixes as discriminant, should\nbe preferred.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\ntemplate\u0026lt;class T\u0026gt;\nvoid f(T t) {\n  static_assert (std::is_arithmetic\u0026lt;T\u0026gt;::value); // Noncompliant\n  using rawType \u003d std::remove_cv\u0026lt;T\u0026gt;::type; // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\ntemplate\u0026lt;class T\u0026gt;\nvoid f(T t) {\n  static_assert (std::is_arithmetic_v\u0026lt;T\u0026gt;); // Compliant, C++17\n  using rawType \u003d std::remove_cv_t\u0026lt;T\u0026gt;; // Compliant, C++14\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhen they were first introduced in the language, type traits, defined in header \u003ccode\u003e\u0026lt;type_traits\u0026gt;,\u003c/code\u003e\u0026nbsp;required to use nested types\n(with \u003ccode\u003e::type\u003c/code\u003e)\u0026nbsp;or nested values (with \u003ccode\u003e::value\u003c/code\u003e) to access the result of the trait. Since then, the language introduced\ntemplated alias declaration and variable templates that allow to define traits in a more direct and readable way.\u003c/p\u003e\n\u003cp\u003eEven if the old variant still exists, the new one, which uses \u003ccode\u003e_t\u003c/code\u003e (C++14) and \u003ccode\u003e_v\u003c/code\u003e (C++17) suffixes as discriminant, should\nbe preferred.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\ntemplate\u0026lt;class T\u0026gt;\nvoid f(T t) {\n  static_assert (std::is_arithmetic\u0026lt;T\u0026gt;::value); // Noncompliant\n  using rawType \u003d std::remove_cv\u0026lt;T\u0026gt;::type; // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\ntemplate\u0026lt;class T\u0026gt;\nvoid f(T t) {\n  static_assert (std::is_arithmetic_v\u0026lt;T\u0026gt;); // Compliant, C++17\n  using rawType \u003d std::remove_cv_t\u0026lt;T\u0026gt;; // Compliant, C++14\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "clumsy",
      "since-c++14"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5297",
    "name": "GNU attributes should be used correctly",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003e__attribute__\u003c/code\u003e is a GNU extension that allows to decorate functions, parameters, variables…​ with some attributes. It may help for\ncompiler optimizations or for the writer of some code to better state his intent (and have the compiler check it).\u003c/p\u003e\n\u003cp\u003eIf this extension is used incorrectly, it will usually not break the build, but it still means that the code may not behave as the developer\nexpects. This rule reports such occurrences of bad use of \u003ccode\u003e__attribute__\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint f1() __attribute__((returns_nonnull)); // Noncompliant; \"returns_nonnull\" only applies to return values which are pointers\n\nvoid g(int *a) __attribute__((nonnull(1))){} // Noncompliant; \"nonnull\" position in the function definition is not allowed\n\nvoid h() __attribute__((warn_unused_result)); // Noncompliant; \"warn_unused_result\" does not work with function without return value\n\nvoid test() {\n  int __declspec(empty_bases)i; // Noncompliant; \"empty_bases\" only applies to classes\n  char c \u003d (char __attribute__((aligned(8)))) i; // Noncompliant, attribute is ignored\n}}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003ccode\u003e__attribute__\u003c/code\u003e is a GNU extension that allows to decorate functions, parameters, variables…​ with some attributes. It may help for\ncompiler optimizations or for the writer of some code to better state his intent (and have the compiler check it).\u003c/p\u003e\n\u003cp\u003eIf this extension is used incorrectly, it will usually not break the build, but it still means that the code may not behave as the developer\nexpects. This rule reports such occurrences of bad use of \u003ccode\u003e__attribute__\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint f1() __attribute__((returns_nonnull)); // Noncompliant; \"returns_nonnull\" only applies to return values which are pointers\n\nvoid g(int *a) __attribute__((nonnull(1))){} // Noncompliant; \"nonnull\" position in the function definition is not allowed\n\nvoid h() __attribute__((warn_unused_result)); // Noncompliant; \"warn_unused_result\" does not work with function without return value\n\nvoid test() {\n  int __declspec(empty_bases)i; // Noncompliant; \"empty_bases\" only applies to classes\n  char c \u003d (char __attribute__((aligned(8)))) i; // Noncompliant, attribute is ignored\n}}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "confusing"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6023",
    "name": "\"std::optional\" member function \"value_or\" should be used",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eC++17\u003c/code\u003e introduces \u003ccode\u003estd::optional\u0026lt;T\u0026gt;\u003c/code\u003e, a template class that manages an optional contained value. By default, the\ncontainer doesn’t contain any value. The contained value can be accessed through member functions like \u003ccode\u003evalue()\u003c/code\u003e, \u003ccode\u003eoperator*()\u003c/code\u003e,\nor \u003ccode\u003eoperator-\u0026gt;()\u003c/code\u003e. Before accessing the value, it is a good practice to check its presence using \u003ccode\u003ehas_value()\u003c/code\u003e or\n\u003ccode\u003eoperator bool()\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003evalue_or(default_value)\u003c/code\u003e member function returns the contained value if present or \u003ccode\u003edefault_value\u003c/code\u003e otherwise. This rule\nflags patterns that could be simplified by a single call to \u003ccode\u003evalue_or(default_value)\u003c/code\u003e instead of two steps logic:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e check presence, i.e., with \u003ccode\u003ehas_value\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e use \u003ccode\u003evalue()\u003c/code\u003e if present, \u003ccode\u003edefault_value\u003c/code\u003e otherwise \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid fun(const std::optional\u0026lt;std::string\u0026gt; \u0026amp;arg) {\n  if (arg.has_value()) { // Noncompliant, the entire if statement can be simplified to a simpler statement using \"value_or(default_value)\"\n    std::cout \u0026lt;\u0026lt; arg.value();\n  } else {\n    std::cout \u0026lt;\u0026lt; \"magic\";\n  }\n\n  // another way to check presence and access value\n  std::cout \u0026lt;\u0026lt; (arg ? *arg : \"magic\"); // Noncompliant, replace the ternary operator by using \"value_or(default_value)\"\n}\n\u003c/pre\u003e\n\u003cpre\u003e\nvoid moveFun(std::optional\u0026lt;std::string\u0026gt; arg) {\n  if (arg.has_value()) { // Noncompliant, the entire if statement can be simplified to a simpler statement using \"value_or(default_value)\"\n    sink(std::move(arg.value()));\n  } else {\n    sink(\"magic\");\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid fun(const std::optional\u0026lt;std::string\u0026gt; \u0026amp;arg) {\n  std::cout \u0026lt;\u0026lt; arg.value_or(\"magic\"); // Compliant, neat and simple\n}\n\u003c/pre\u003e\n\u003cpre\u003e\nvoid moveFun(std::optional\u0026lt;std::string\u0026gt; arg) {\n  sink(std::move(arg).value_or(\"magic\"));\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/utility/optional/value_or\"\u003estd::optional\u0026lt;T\u0026gt;::value_or\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003ccode\u003eC++17\u003c/code\u003e introduces \u003ccode\u003estd::optional\u0026lt;T\u0026gt;\u003c/code\u003e, a template class that manages an optional contained value. By default, the\ncontainer doesn’t contain any value. The contained value can be accessed through member functions like \u003ccode\u003evalue()\u003c/code\u003e, \u003ccode\u003eoperator*()\u003c/code\u003e,\nor \u003ccode\u003eoperator-\u0026gt;()\u003c/code\u003e. Before accessing the value, it is a good practice to check its presence using \u003ccode\u003ehas_value()\u003c/code\u003e or\n\u003ccode\u003eoperator bool()\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003evalue_or(default_value)\u003c/code\u003e member function returns the contained value if present or \u003ccode\u003edefault_value\u003c/code\u003e otherwise. This rule\nflags patterns that could be simplified by a single call to \u003ccode\u003evalue_or(default_value)\u003c/code\u003e instead of two steps logic:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e check presence, i.e., with \u003ccode\u003ehas_value\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e use \u003ccode\u003evalue()\u003c/code\u003e if present, \u003ccode\u003edefault_value\u003c/code\u003e otherwise \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid fun(const std::optional\u0026lt;std::string\u0026gt; \u0026amp;arg) {\n  if (arg.has_value()) { // Noncompliant, the entire if statement can be simplified to a simpler statement using \"value_or(default_value)\"\n    std::cout \u0026lt;\u0026lt; arg.value();\n  } else {\n    std::cout \u0026lt;\u0026lt; \"magic\";\n  }\n\n  // another way to check presence and access value\n  std::cout \u0026lt;\u0026lt; (arg ? *arg : \"magic\"); // Noncompliant, replace the ternary operator by using \"value_or(default_value)\"\n}\n\u003c/pre\u003e\n\u003cpre\u003e\nvoid moveFun(std::optional\u0026lt;std::string\u0026gt; arg) {\n  if (arg.has_value()) { // Noncompliant, the entire if statement can be simplified to a simpler statement using \"value_or(default_value)\"\n    sink(std::move(arg.value()));\n  } else {\n    sink(\"magic\");\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid fun(const std::optional\u0026lt;std::string\u0026gt; \u0026amp;arg) {\n  std::cout \u0026lt;\u0026lt; arg.value_or(\"magic\"); // Compliant, neat and simple\n}\n\u003c/pre\u003e\n\u003cpre\u003e\nvoid moveFun(std::optional\u0026lt;std::string\u0026gt; arg) {\n  sink(std::move(arg).value_or(\"magic\"));\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/utility/optional/value_or\"\u003estd::optional\u0026lt;T\u0026gt;::value_or\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "clumsy",
      "since-c++17"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5298",
    "name": "When an array is declared, its size shall either be stated explicitly or defined implicitly by initialization",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThis rule is a strict implementation of a MISRA (Motor Industry Software Reliability Association) rule. MISRA defines best practices for developing\nsafety-critical software. You can learn more about this rule in the MISRA documents referenced below.\u003c/p\u003e\n\u003cp\u003eIf you are not concerned with MISRA compliance or with safety-critical software, you might consider using rule {rule:cpp:S834} instead ; it targets\nthe same kind of issue for general-purpose software.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++ 2008, 3-1-3 \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThis rule is a strict implementation of a MISRA (Motor Industry Software Reliability Association) rule. MISRA defines best practices for developing\nsafety-critical software. You can learn more about this rule in the MISRA documents referenced below.\u003c/p\u003e\n\u003cp\u003eIf you are not concerned with MISRA compliance or with safety-critical software, you might consider using rule {rule:cpp:S834} instead ; it targets\nthe same kind of issue for general-purpose software.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C++ 2008, 3-1-3 \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "misra-c++2008"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6024",
    "name": "Free functions should be preferred to member functions when accessing a container in a generic context",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "MODULAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eIt is often considered a better style to access objects in generic code with free functions than with member functions because it allows one to\nadapt an object to a template without modifying it just by adding the right overload of the free function. This is especially true with containers,\nwhich can come in a wide variety (and some of them can’t even have member functions, for instance, C-style arrays).\u003c/p\u003e\n\u003cp\u003eTherefore, the C++ standard library provides free functions that can be applied on any standard container and that can be adapted for user-defined\ncontainers. They are:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Since C++11: \u003ccode\u003estd::begin\u003c/code\u003e, \u003ccode\u003estd::end\u003c/code\u003e, \u003ccode\u003estd::cbegin\u003c/code\u003e, \u003ccode\u003estd::cend\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e Since C++14: \u003ccode\u003estd::rbegin\u003c/code\u003e, \u003ccode\u003estd::rend\u003c/code\u003e, \u003ccode\u003estd::crbegin\u003c/code\u003e, \u003ccode\u003estd::crend\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e Since C++17: \u003ccode\u003estd::size\u003c/code\u003e, \u003ccode\u003estd::empty\u003c/code\u003e, \u003ccode\u003estd::data\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e Since C++20: \u003ccode\u003estd::ssize\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWhen writing generic code, you should prefer using those functions for objects that depend on the template arguments: it will allow your code to\nwork with a wider variety of containers.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\ntemplate\u0026lt;class T\u0026gt;\nbool f(T const \u0026amp;t, std::vector\u0026lt;int\u0026gt; const \u0026amp;v) {\n  if (!t.empty()) { // Noncompliant in C++17\n    auto val \u003d (t.begin() // Noncompliant in C++11\n      -\u0026gt;size()); // Noncompliant in C++17\n    return val \u003d\u003d v.size(); // Compliant, v does not depend on a template parameter\n  }\n  return false;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\ntemplate\u0026lt;class T\u0026gt;\nbool f(T const \u0026amp;t, std::vector\u0026lt;int\u0026gt; const \u0026amp;v) {\n  if (!std::empty(t)) { // Compliant\n    auto val \u003d std::size(*std::begin(t)); // Compliant\n    return val \u003d\u003d v.size();\n  }\n  return false;\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eIt is often considered a better style to access objects in generic code with free functions than with member functions because it allows one to\nadapt an object to a template without modifying it just by adding the right overload of the free function. This is especially true with containers,\nwhich can come in a wide variety (and some of them can’t even have member functions, for instance, C-style arrays).\u003c/p\u003e\n\u003cp\u003eTherefore, the C++ standard library provides free functions that can be applied on any standard container and that can be adapted for user-defined\ncontainers. They are:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Since C++11: \u003ccode\u003estd::begin\u003c/code\u003e, \u003ccode\u003estd::end\u003c/code\u003e, \u003ccode\u003estd::cbegin\u003c/code\u003e, \u003ccode\u003estd::cend\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e Since C++14: \u003ccode\u003estd::rbegin\u003c/code\u003e, \u003ccode\u003estd::rend\u003c/code\u003e, \u003ccode\u003estd::crbegin\u003c/code\u003e, \u003ccode\u003estd::crend\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e Since C++17: \u003ccode\u003estd::size\u003c/code\u003e, \u003ccode\u003estd::empty\u003c/code\u003e, \u003ccode\u003estd::data\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e Since C++20: \u003ccode\u003estd::ssize\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWhen writing generic code, you should prefer using those functions for objects that depend on the template arguments: it will allow your code to\nwork with a wider variety of containers.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\ntemplate\u0026lt;class T\u0026gt;\nbool f(T const \u0026amp;t, std::vector\u0026lt;int\u0026gt; const \u0026amp;v) {\n  if (!t.empty()) { // Noncompliant in C++17\n    auto val \u003d (t.begin() // Noncompliant in C++11\n      -\u0026gt;size()); // Noncompliant in C++17\n    return val \u003d\u003d v.size(); // Compliant, v does not depend on a template parameter\n  }\n  return false;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\ntemplate\u0026lt;class T\u0026gt;\nbool f(T const \u0026amp;t, std::vector\u0026lt;int\u0026gt; const \u0026amp;v) {\n  if (!std::empty(t)) { // Compliant\n    auto val \u003d std::size(*std::begin(t)); // Compliant\n    return val \u003d\u003d v.size();\n  }\n  return false;\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "clumsy",
      "since-c++11"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6021",
    "name": "Heterogeneous sorted containers should only be used with types that support heterogeneous comparison",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "EFFICIENT",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eHeterogeneous containers were introduced in C++14 to increase performance when working with \u003ccode\u003estd::map\u003c/code\u003e, \u003ccode\u003estd::set\u003c/code\u003e,\n\u003ccode\u003estd::multimap\u003c/code\u003e, \u003ccode\u003estd::multiset\u003c/code\u003e, and since C++20, their \u003ccode\u003eunordered_\u003c/code\u003e counterparts. Before their introduction, when\nworking with a key in such a container, it was required to use an object of the exact key type. This could lead to costly object creations when we\nwould like to work with objects of compatible but different types:\u003c/p\u003e\n\u003cpre\u003e\nstd::map\u0026lt;std::string, int\u0026gt; m;\nm.find(\"abc\"); // Will convert the char const * to a std::string, maybe performing costly memory allocation\n\u003c/pre\u003e\n\u003cp\u003eWith heterogeneous containers, the previous code will not create a \u003ccode\u003estring\u003c/code\u003e, but directly compare keys in the map with the searched\n\u003ccode\u003echar const *\u003c/code\u003e. This is a behavior you can opt-in with providing a \u003cem\u003etransparent\u003c/em\u003e comparison method for the map.\u003c/p\u003e\n\u003cpre\u003e\nstd::map\u0026lt;std::string, int, std::less\u0026lt;\u0026gt;\u0026gt; m; // std::less\u0026lt;\u0026gt; is transparent, std::less\u0026lt;anything\u0026gt; is not\nm.find(\"abc\"); // Will directly compare the char const* with the keys, no object conversion\n\u003c/pre\u003e\n\u003cp\u003eA transparent comparator is one that declares a nested type named \u003ccode\u003eis_transparent\u003c/code\u003e. It is supposed to be able to compare heterogeneous\nobject types, for instance in this case compare a \u003ccode\u003echar const *\u003c/code\u003e with a \u003ccode\u003estring\u003c/code\u003e, without performing any conversion.\u003c/p\u003e\n\u003cp\u003eWhat happens if it cannot? Well, if the types are convertible with each other (which is usually the case when you want to work with a heterogeneous\ncontainer), a conversion will happen, and a homogeneous comparison will be performed instead.\u003c/p\u003e\n\u003cpre\u003e\nclass MyString {\npublic:\n  operator std::string() const {return myData;} // Converts to a string\n  // Other functions to make the class behave correctly\nprivate:\n  std::string myData;\n};\nbool operator\u003d\u003d(const std::string\u0026amp;, const std::string\u0026amp;);\nbool operator\u0026lt;(const std::string\u0026amp;, const std::string\u0026amp;);\n\nvoid f() {\n  std::map\u0026lt;std::string, int, std::less\u0026lt;\u0026gt;\u0026gt; m;\n  MyString str{\"abc\"};\n  m.find(str);\n}\n\u003c/pre\u003e\n\u003cp\u003eIn this case, \u003ccode\u003estr\u003c/code\u003e will not be converted to a \u003ccode\u003estd::string\u003c/code\u003e when calling the function \u003ccode\u003efind\u003c/code\u003e (this function is\nnow a member function template). However, each time during the search when a comparison will be needed between \u003ccode\u003eMyString\u003c/code\u003e and\n\u003ccode\u003estd::string\u003c/code\u003e, a conversion will now happen to convert \u003ccode\u003estr\u003c/code\u003e to always the same \u003ccode\u003estring\u003c/code\u003e. A unique conversion is\nreplaced by \u003ccode\u003eO(ln N)\u003c/code\u003e conversions.\u003c/p\u003e\n\u003cp\u003eThis problem appears also for the case of an unordered container for which heterogeneous lookup is enabled (available since C++20), for which\nequality is used to compare elements in the same bucket (having same or close hashes):\u003c/p\u003e\n\u003cpre\u003e\nvoid g() {\n  std::unordered_map\u0026lt;std::string, int, StringHash, std::equal_to\u0026lt;\u0026gt;\u0026gt; m;\n  MyString str{\"abc\"};\n  m.find(str);\n}\n\u003c/pre\u003e\n\u003cp\u003eIn this case \u003ccode\u003estr\u003c/code\u003e will not be converted to a \u003ccode\u003estd::string\u003c/code\u003e when calling the function \u003ccode\u003efind\u003c/code\u003e, and each element of\nthe bucket that corresponds to the hash of \u003ccode\u003estr\u003c/code\u003e will be compared using homogeneous \u003ccode\u003eoperator\u003d\u003d\u003c/code\u003e, and for each such comparison,\na conversion will now happen. The number of compared elements varies depending on the hash distribution from \u003ccode\u003eO(1)\u003c/code\u003e (on average) to\n\u003ccode\u003eO(N)\u003c/code\u003e (in the worst case). As consequence, the performance of slow runs (when multiple hash collisions happen due to the data\ndistribution) is made even worse.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when a transparent lookup function of a heterogeneous container is used with a type that cannot be directly compared with\nthe container key type. Only standard associative containers with expensive to create key and straightforward comparison functions are considered.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid f() {\n  std::map\u0026lt;std::string, int, std::less\u0026lt;\u0026gt;\u0026gt; m;\n  MyString str{\"abc\"}; // See previous definition of MyString\n  m.find(str); // Noncompliant, O(ln N) conversions\n}\n\nvoid g() {\n  std::unordered_map\u0026lt;std::string, int, StringHash, std::equal_to\u0026lt;\u0026gt;\u0026gt; m;\n  MyString str{\"abc\"}; // See previous definition of MyString\n  m.find(str); // Noncompliant, up to O(N) conversions\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cp\u003eOption 1: Make the container non-heterogeneous\u003c/p\u003e\n\u003cpre\u003e\nvoid f() {\n  std::map\u0026lt;std::string, int\u0026gt; m;\n  MyString str{\"abc\"}; // See previous definition of MyString\n  m.find(str); // Compliant, one conversion at the start\n}\n\nvoid g() {\n  std::unordered_map\u0026lt;std::string, int\u0026gt; m;\n  MyString str{\"abc\"}; // See previous definition of MyString\n  m.find(str); // Compliant, one conversion at the start\n}\n\u003c/pre\u003e\n\u003cp\u003eOption 2: Provide heterogeneous comparisons\u003c/p\u003e\n\u003cpre\u003e\nbool operator\u003d\u003d(const MyString \u0026amp;s1, const std::string \u0026amp;s2) {/*...*/} // invoked for reversed order of arguments since {cpp}20\nbool operator\u0026lt;(const MyString \u0026amp;s1, const std::string \u0026amp;s2) {/*...*/}\nbool operator\u0026lt;(const std::string \u0026amp;s1, const MyString \u0026amp;s2) {/*...*/}\nvoid f() {\n  std::map\u0026lt;std::string, int, std::less\u0026lt;\u0026gt;\u0026gt; m;\n  MyString str{\"abc\"}; // See previous definition of MyString\n  m.find(str); // Compliant, no conversion at all\n}\n\nvoid g() {\n  std::unordered_map\u0026lt;std::string, int, StringHash, std::equal_to\u0026lt;\u0026gt;\u0026gt; m;\n  MyString str{\"abc\"}; // See previous definition of MyString\n  m.find(str); // Compliant, no conversion for equality and possibly one for hash computation\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eHeterogeneous containers were introduced in C++14 to increase performance when working with \u003ccode\u003estd::map\u003c/code\u003e, \u003ccode\u003estd::set\u003c/code\u003e,\n\u003ccode\u003estd::multimap\u003c/code\u003e, \u003ccode\u003estd::multiset\u003c/code\u003e, and since C++20, their \u003ccode\u003eunordered_\u003c/code\u003e counterparts. Before their introduction, when\nworking with a key in such a container, it was required to use an object of the exact key type. This could lead to costly object creations when we\nwould like to work with objects of compatible but different types:\u003c/p\u003e\n\u003cpre\u003e\nstd::map\u0026lt;std::string, int\u0026gt; m;\nm.find(\"abc\"); // Will convert the char const * to a std::string, maybe performing costly memory allocation\n\u003c/pre\u003e\n\u003cp\u003eWith heterogeneous containers, the previous code will not create a \u003ccode\u003estring\u003c/code\u003e, but directly compare keys in the map with the searched\n\u003ccode\u003echar const *\u003c/code\u003e. This is a behavior you can opt-in with providing a \u003cem\u003etransparent\u003c/em\u003e comparison method for the map.\u003c/p\u003e\n\u003cpre\u003e\nstd::map\u0026lt;std::string, int, std::less\u0026lt;\u0026gt;\u0026gt; m; // std::less\u0026lt;\u0026gt; is transparent, std::less\u0026lt;anything\u0026gt; is not\nm.find(\"abc\"); // Will directly compare the char const* with the keys, no object conversion\n\u003c/pre\u003e\n\u003cp\u003eA transparent comparator is one that declares a nested type named \u003ccode\u003eis_transparent\u003c/code\u003e. It is supposed to be able to compare heterogeneous\nobject types, for instance in this case compare a \u003ccode\u003echar const *\u003c/code\u003e with a \u003ccode\u003estring\u003c/code\u003e, without performing any conversion.\u003c/p\u003e\n\u003cp\u003eWhat happens if it cannot? Well, if the types are convertible with each other (which is usually the case when you want to work with a heterogeneous\ncontainer), a conversion will happen, and a homogeneous comparison will be performed instead.\u003c/p\u003e\n\u003cpre\u003e\nclass MyString {\npublic:\n  operator std::string() const {return myData;} // Converts to a string\n  // Other functions to make the class behave correctly\nprivate:\n  std::string myData;\n};\nbool operator\u003d\u003d(const std::string\u0026amp;, const std::string\u0026amp;);\nbool operator\u0026lt;(const std::string\u0026amp;, const std::string\u0026amp;);\n\nvoid f() {\n  std::map\u0026lt;std::string, int, std::less\u0026lt;\u0026gt;\u0026gt; m;\n  MyString str{\"abc\"};\n  m.find(str);\n}\n\u003c/pre\u003e\n\u003cp\u003eIn this case, \u003ccode\u003estr\u003c/code\u003e will not be converted to a \u003ccode\u003estd::string\u003c/code\u003e when calling the function \u003ccode\u003efind\u003c/code\u003e (this function is\nnow a member function template). However, each time during the search when a comparison will be needed between \u003ccode\u003eMyString\u003c/code\u003e and\n\u003ccode\u003estd::string\u003c/code\u003e, a conversion will now happen to convert \u003ccode\u003estr\u003c/code\u003e to always the same \u003ccode\u003estring\u003c/code\u003e. A unique conversion is\nreplaced by \u003ccode\u003eO(ln N)\u003c/code\u003e conversions.\u003c/p\u003e\n\u003cp\u003eThis problem appears also for the case of an unordered container for which heterogeneous lookup is enabled (available since C++20), for which\nequality is used to compare elements in the same bucket (having same or close hashes):\u003c/p\u003e\n\u003cpre\u003e\nvoid g() {\n  std::unordered_map\u0026lt;std::string, int, StringHash, std::equal_to\u0026lt;\u0026gt;\u0026gt; m;\n  MyString str{\"abc\"};\n  m.find(str);\n}\n\u003c/pre\u003e\n\u003cp\u003eIn this case \u003ccode\u003estr\u003c/code\u003e will not be converted to a \u003ccode\u003estd::string\u003c/code\u003e when calling the function \u003ccode\u003efind\u003c/code\u003e, and each element of\nthe bucket that corresponds to the hash of \u003ccode\u003estr\u003c/code\u003e will be compared using homogeneous \u003ccode\u003eoperator\u003d\u003d\u003c/code\u003e, and for each such comparison,\na conversion will now happen. The number of compared elements varies depending on the hash distribution from \u003ccode\u003eO(1)\u003c/code\u003e (on average) to\n\u003ccode\u003eO(N)\u003c/code\u003e (in the worst case). As consequence, the performance of slow runs (when multiple hash collisions happen due to the data\ndistribution) is made even worse.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when a transparent lookup function of a heterogeneous container is used with a type that cannot be directly compared with\nthe container key type. Only standard associative containers with expensive to create key and straightforward comparison functions are considered.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid f() {\n  std::map\u0026lt;std::string, int, std::less\u0026lt;\u0026gt;\u0026gt; m;\n  MyString str{\"abc\"}; // See previous definition of MyString\n  m.find(str); // Noncompliant, O(ln N) conversions\n}\n\nvoid g() {\n  std::unordered_map\u0026lt;std::string, int, StringHash, std::equal_to\u0026lt;\u0026gt;\u0026gt; m;\n  MyString str{\"abc\"}; // See previous definition of MyString\n  m.find(str); // Noncompliant, up to O(N) conversions\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cp\u003eOption 1: Make the container non-heterogeneous\u003c/p\u003e\n\u003cpre\u003e\nvoid f() {\n  std::map\u0026lt;std::string, int\u0026gt; m;\n  MyString str{\"abc\"}; // See previous definition of MyString\n  m.find(str); // Compliant, one conversion at the start\n}\n\nvoid g() {\n  std::unordered_map\u0026lt;std::string, int\u0026gt; m;\n  MyString str{\"abc\"}; // See previous definition of MyString\n  m.find(str); // Compliant, one conversion at the start\n}\n\u003c/pre\u003e\n\u003cp\u003eOption 2: Provide heterogeneous comparisons\u003c/p\u003e\n\u003cpre\u003e\nbool operator\u003d\u003d(const MyString \u0026amp;s1, const std::string \u0026amp;s2) {/*...*/} // invoked for reversed order of arguments since {cpp}20\nbool operator\u0026lt;(const MyString \u0026amp;s1, const std::string \u0026amp;s2) {/*...*/}\nbool operator\u0026lt;(const std::string \u0026amp;s1, const MyString \u0026amp;s2) {/*...*/}\nvoid f() {\n  std::map\u0026lt;std::string, int, std::less\u0026lt;\u0026gt;\u0026gt; m;\n  MyString str{\"abc\"}; // See previous definition of MyString\n  m.find(str); // Compliant, no conversion at all\n}\n\nvoid g() {\n  std::unordered_map\u0026lt;std::string, int, StringHash, std::equal_to\u0026lt;\u0026gt;\u0026gt; m;\n  MyString str{\"abc\"}; // See previous definition of MyString\n  m.find(str); // Compliant, no conversion for equality and possibly one for hash computation\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "performance",
      "since-c++14"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6022",
    "name": "\"std::byte\" should be used when you need byte-oriented memory access",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eC++17 introduced \u003ccode\u003estd::byte\u003c/code\u003e. It allows you to have byte-oriented access to memory in a type-safe, unambiguous manner. Before, you had\nto use either \u003ccode\u003echar\u003c/code\u003e, \u003ccode\u003esigned char\u003c/code\u003e, or \u003ccode\u003eunsigned char\u003c/code\u003e to access memory as bytes. The previous approach was\nerror-prone as the \u003ccode\u003echar\u003c/code\u003e type allows you to accidentally perform arithmetic operations. Also, it was confusing since \u003ccode\u003echar\u003c/code\u003e,\n\u003ccode\u003esigned char\u003c/code\u003e, and \u003ccode\u003eunsigned char\u003c/code\u003e are also used to represent actual characters and arithmetic values.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003estd::byte\u003c/code\u003e is simply a scoped enumeration with bit-wise operators and a helper function \u003ccode\u003eto_integer\u0026lt;T\u0026gt;\u003c/code\u003e to convert\nbyte object to integral type T.\u003c/p\u003e\n\u003cp\u003eThis rule will detect byte-like usage of \u003ccode\u003echar\u003c/code\u003e, \u003ccode\u003esigned char\u003c/code\u003e, and \u003ccode\u003eunsigned char\u003c/code\u003e and suggest replacing them by\n\u003ccode\u003estd::byte\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid handleFirstByte(char* byte);\n\nvoid f(int* i) {\n  char* c \u003d reinterpret_cast\u0026lt;char*\u0026gt;(i); // Noncompliant\n  handleFirstByte(c);\n}\n\nunsigned char negate(unsigned char byte) {\n  return ~byte; // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid handleFirstByte(std::byte* byte);\n\nvoid f(int* i) {\n  std::byte* byte \u003d reinterpret_cast\u0026lt;std::byte*\u0026gt;(i); // Compliant\n  handleFirstByte(byte);\n}\n\nstd::byte negate(std::byte byte) {\n  return ~byte; // Compliant\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/types/byte\"\u003estd::byte\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eC++17 introduced \u003ccode\u003estd::byte\u003c/code\u003e. It allows you to have byte-oriented access to memory in a type-safe, unambiguous manner. Before, you had\nto use either \u003ccode\u003echar\u003c/code\u003e, \u003ccode\u003esigned char\u003c/code\u003e, or \u003ccode\u003eunsigned char\u003c/code\u003e to access memory as bytes. The previous approach was\nerror-prone as the \u003ccode\u003echar\u003c/code\u003e type allows you to accidentally perform arithmetic operations. Also, it was confusing since \u003ccode\u003echar\u003c/code\u003e,\n\u003ccode\u003esigned char\u003c/code\u003e, and \u003ccode\u003eunsigned char\u003c/code\u003e are also used to represent actual characters and arithmetic values.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003estd::byte\u003c/code\u003e is simply a scoped enumeration with bit-wise operators and a helper function \u003ccode\u003eto_integer\u0026lt;T\u0026gt;\u003c/code\u003e to convert\nbyte object to integral type T.\u003c/p\u003e\n\u003cp\u003eThis rule will detect byte-like usage of \u003ccode\u003echar\u003c/code\u003e, \u003ccode\u003esigned char\u003c/code\u003e, and \u003ccode\u003eunsigned char\u003c/code\u003e and suggest replacing them by\n\u003ccode\u003estd::byte\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid handleFirstByte(char* byte);\n\nvoid f(int* i) {\n  char* c \u003d reinterpret_cast\u0026lt;char*\u0026gt;(i); // Noncompliant\n  handleFirstByte(c);\n}\n\nunsigned char negate(unsigned char byte) {\n  return ~byte; // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid handleFirstByte(std::byte* byte);\n\nvoid f(int* i) {\n  std::byte* byte \u003d reinterpret_cast\u0026lt;std::byte*\u0026gt;(i); // Compliant\n  handleFirstByte(byte);\n}\n\nstd::byte negate(std::byte byte) {\n  return ~byte; // Compliant\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/types/byte\"\u003estd::byte\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "clumsy",
      "pitfall",
      "since-c++17"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6025",
    "name": "Use \"std::variant\" instead of unions with non-trivial types.",
    "defaultSeverity": "BLOCKER",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "FOCUSED",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eIn order to save memory, unions allow you to use the same memory to store objects from a list of possible types as long as one object is stored at\na time.\u003c/p\u003e\n\u003cp\u003eIn C and in C++ prior to C++11, unions are restricted to trivial types.\u003c/p\u003e\n\u003cp\u003eStarting from C++11, it is possible to use unions with non-trivial types with the following limitations :\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e You have to manually handle the lifetime of the active member, using placement new and explicit object destruction. \u003c/li\u003e\n  \u003cli\u003e You have to define special members like destructor and copy-constructor while taking into consideration the active member. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn some cases, code that fails to perfectly follow those rules may still compile, but lead to memory corruption.\u003c/p\u003e\n\u003cp\u003eC++17 introduced \u003ccode\u003estd::variant\u003c/code\u003e which can replace unions while removing this burden and the associated risk. As a safer and more\nreadable alternative, they should be preferred.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;new\u0026gt; // Required for placement \u0027new\u0027.\n#include \u0026lt;string\u0026gt;\n#include \u0026lt;iostream\u0026gt;\n\nusing namespace std;\n\nstruct IntOrString {\n  enum {holdsInt, holdsString} currentAlternative;\n  union {\n    int z;\n    string s; // Noncompliant: non-trivial type in Union\n  };\n  IntOrString() : currentAlternative{holdsInt} {\n    z \u003d 0;\n  }\n  IntOrString(char const *s) : currentAlternative{holdsString} {\n    new(\u0026amp;s) string(s);\n  }\n  IntOrString(IntOrString const \u0026amp;src) : currentAlternative{src.currentAlternative}{\n      if (currentAlternative \u003d\u003d holdsString) {\n          new(\u0026amp;s) string(src.s);\n      }\n  }\n  IntOrString \u0026amp;operator\u003d(IntOrString \u0026amp;\u0026amp;) \u003d delete;\n  ~IntOrString() {\n      if (currentAlternative \u003d\u003d holdsString) {\n          s.~string();\n      }\n  }\n};\n\nvoid stringize(IntOrString \u0026amp;ios) {\n    if (ios.currentAlternative \u003d\u003d IntOrString::holdsString) {\n        return;\n    }\n    new (\u0026amp;ios.s) string(std::to_string(ios.z));\n}\n\nint main() {\n  IntOrString ios;\n  auto copy \u003d ios;\n  ios.z \u003d 12;\n  stringize(ios);\n  std::cout\u0026lt;\u0026lt; ios.s \u0026lt;\u0026lt; \"\\n\";\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;variant\u0026gt;\n#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;string\u0026gt;\n\nusing namespace std;\nusing IntOrString \u003d variant\u0026lt;int, string\u0026gt;;\n\nvoid stringize(IntOrString \u0026amp;ios) {\n    if(auto i \u003d get_if\u0026lt;int\u0026gt;(\u0026amp;ios)) {\n        ios \u003d to_string(*i);\n    }\n}\nint main() {\n    IntOrString ios \u003d 12;\n    auto copy \u003d ios;\n    stringize(ios);\n    cout \u0026lt;\u0026lt; std::get\u0026lt;string\u0026gt;(ios) \u0026lt;\u0026lt; \u0027\\n\u0027;\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eIn order to save memory, unions allow you to use the same memory to store objects from a list of possible types as long as one object is stored at\na time.\u003c/p\u003e\n\u003cp\u003eIn C and in C++ prior to C++11, unions are restricted to trivial types.\u003c/p\u003e\n\u003cp\u003eStarting from C++11, it is possible to use unions with non-trivial types with the following limitations :\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e You have to manually handle the lifetime of the active member, using placement new and explicit object destruction. \u003c/li\u003e\n  \u003cli\u003e You have to define special members like destructor and copy-constructor while taking into consideration the active member. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn some cases, code that fails to perfectly follow those rules may still compile, but lead to memory corruption.\u003c/p\u003e\n\u003cp\u003eC++17 introduced \u003ccode\u003estd::variant\u003c/code\u003e which can replace unions while removing this burden and the associated risk. As a safer and more\nreadable alternative, they should be preferred.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;new\u0026gt; // Required for placement \u0027new\u0027.\n#include \u0026lt;string\u0026gt;\n#include \u0026lt;iostream\u0026gt;\n\nusing namespace std;\n\nstruct IntOrString {\n  enum {holdsInt, holdsString} currentAlternative;\n  union {\n    int z;\n    string s; // Noncompliant: non-trivial type in Union\n  };\n  IntOrString() : currentAlternative{holdsInt} {\n    z \u003d 0;\n  }\n  IntOrString(char const *s) : currentAlternative{holdsString} {\n    new(\u0026amp;s) string(s);\n  }\n  IntOrString(IntOrString const \u0026amp;src) : currentAlternative{src.currentAlternative}{\n      if (currentAlternative \u003d\u003d holdsString) {\n          new(\u0026amp;s) string(src.s);\n      }\n  }\n  IntOrString \u0026amp;operator\u003d(IntOrString \u0026amp;\u0026amp;) \u003d delete;\n  ~IntOrString() {\n      if (currentAlternative \u003d\u003d holdsString) {\n          s.~string();\n      }\n  }\n};\n\nvoid stringize(IntOrString \u0026amp;ios) {\n    if (ios.currentAlternative \u003d\u003d IntOrString::holdsString) {\n        return;\n    }\n    new (\u0026amp;ios.s) string(std::to_string(ios.z));\n}\n\nint main() {\n  IntOrString ios;\n  auto copy \u003d ios;\n  ios.z \u003d 12;\n  stringize(ios);\n  std::cout\u0026lt;\u0026lt; ios.s \u0026lt;\u0026lt; \"\\n\";\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;variant\u0026gt;\n#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;string\u0026gt;\n\nusing namespace std;\nusing IntOrString \u003d variant\u0026lt;int, string\u0026gt;;\n\nvoid stringize(IntOrString \u0026amp;ios) {\n    if(auto i \u003d get_if\u0026lt;int\u0026gt;(\u0026amp;ios)) {\n        ios \u003d to_string(*i);\n    }\n}\nint main() {\n    IntOrString ios \u003d 12;\n    auto copy \u003d ios;\n    stringize(ios);\n    cout \u0026lt;\u0026lt; std::get\u0026lt;string\u0026gt;(ios) \u0026lt;\u0026lt; \u0027\\n\u0027;\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "clumsy",
      "pitfall",
      "since-c++17"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6026",
    "name": "\"auto\" should be used for non-type template parameter",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eStarting \u003ccode\u003eC++17\u003c/code\u003e, you can use \u003ccode\u003eauto\u003c/code\u003e and \u003ccode\u003edecltype(auto)\u003c/code\u003e to declare non-type template parameters. This new\nfeature provides a way to write generic code for non-type parameters of different types. Also, it allows, by using variadic templates, to make a\ntemplate take a list of non-type template parameters of different types: \u003ccode\u003etemplate\u0026lt;auto... VS\u0026gt; class A\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eIf the type is used in the template definition, you can replace it with \u003ccode\u003eauto\u003c/code\u003e, or \u003ccode\u003edecltype\u003c/code\u003e if you want to underline that\nthe type is the same as of the template parameter. Note, that you can use \u003ccode\u003etemplate \u0026lt;class T\u0026gt; T packed_t(T...);\u003c/code\u003e to get the type of\narguments in the \u003ccode\u003eauto...\u003c/code\u003e pack (see the \"Compliant Solution\" section below).\u003c/p\u003e\n\u003cp\u003eThis rule detects the common pattern where a type template parameter is introduced only to be used as a type for the next non-type template\nparameter(s).\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\ntemplate \u0026lt;typename T, T value\u0026gt;\nstruct A { // Noncompliant\n  inline static auto field \u003d value;\n  typedef T type;\n  static T anotherField;\n};\n\ntemplate \u0026lt;typename T, T... values\u0026gt;\nstruct MultiA { // Noncompliant\n  inline static std::vector vec \u003d { values... };\n};\n\ntemplate \u0026lt;typename T, T defaultVal\u0026gt;\nT foo(T arg) {\n  return arg \u0026gt; 0 ? arg : defaultVal;\n}\n\nvoid f() {\n  A\u0026lt;int, 1\u0026gt; a1;\n  A\u0026lt;bool, false\u0026gt; a2;\n  MultiA\u0026lt;int, 1, 2, 3, 4\u0026gt; multiA1;\n  MultiA\u0026lt;char, \u0027a\u0027, \u0027b\u0027\u0026gt; multiA2;\n  foo\u0026lt;int, 1\u0026gt;(-1);\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\ntemplate \u0026lt;auto value\u0026gt;\nstruct A { // Compliant\n  inline static auto field \u003d value;\n  typedef decltype(value) type;\n  static type anotherField;\n};\n\ntemplate \u0026lt;auto ... values\u0026gt;\nstruct MultiA { // Compliant\n  inline static std::vector vec \u003d { values... };\n};\n\ntemplate \u0026lt;auto defaultVal\u0026gt;\nauto foo(decltype(defaultVal) arg) {\n  return arg \u0026gt; 0 ? arg : defaultVal;\n}\n\nvoid f() {\n  A\u0026lt;1\u0026gt; a1;\n  A\u0026lt;false\u0026gt; a2;\n  MultiA\u0026lt;1, 2, 3, 4\u0026gt; multiA1;\n  MultiA\u0026lt;\u0027a\u0027, \u0027b\u0027\u0026gt; multiA2;\n  foo\u0026lt;1\u0026gt;(-1);\n}\n\n// Get the type out of auto... declaration\ntemplate \u0026lt;class T\u0026gt;\nT packed_t(T...);\n\ntemplate \u0026lt;auto... Is\u0026gt;\nstd::vector\u0026lt;std::string\u0026gt; name_copy(std::map\u0026lt;decltype(packed_t(Is...)), std::string\u0026gt; names) {\n  return {names[Is]...};\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eStarting \u003ccode\u003eC++17\u003c/code\u003e, you can use \u003ccode\u003eauto\u003c/code\u003e and \u003ccode\u003edecltype(auto)\u003c/code\u003e to declare non-type template parameters. This new\nfeature provides a way to write generic code for non-type parameters of different types. Also, it allows, by using variadic templates, to make a\ntemplate take a list of non-type template parameters of different types: \u003ccode\u003etemplate\u0026lt;auto... VS\u0026gt; class A\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eIf the type is used in the template definition, you can replace it with \u003ccode\u003eauto\u003c/code\u003e, or \u003ccode\u003edecltype\u003c/code\u003e if you want to underline that\nthe type is the same as of the template parameter. Note, that you can use \u003ccode\u003etemplate \u0026lt;class T\u0026gt; T packed_t(T...);\u003c/code\u003e to get the type of\narguments in the \u003ccode\u003eauto...\u003c/code\u003e pack (see the \"Compliant Solution\" section below).\u003c/p\u003e\n\u003cp\u003eThis rule detects the common pattern where a type template parameter is introduced only to be used as a type for the next non-type template\nparameter(s).\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\ntemplate \u0026lt;typename T, T value\u0026gt;\nstruct A { // Noncompliant\n  inline static auto field \u003d value;\n  typedef T type;\n  static T anotherField;\n};\n\ntemplate \u0026lt;typename T, T... values\u0026gt;\nstruct MultiA { // Noncompliant\n  inline static std::vector vec \u003d { values... };\n};\n\ntemplate \u0026lt;typename T, T defaultVal\u0026gt;\nT foo(T arg) {\n  return arg \u0026gt; 0 ? arg : defaultVal;\n}\n\nvoid f() {\n  A\u0026lt;int, 1\u0026gt; a1;\n  A\u0026lt;bool, false\u0026gt; a2;\n  MultiA\u0026lt;int, 1, 2, 3, 4\u0026gt; multiA1;\n  MultiA\u0026lt;char, \u0027a\u0027, \u0027b\u0027\u0026gt; multiA2;\n  foo\u0026lt;int, 1\u0026gt;(-1);\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\ntemplate \u0026lt;auto value\u0026gt;\nstruct A { // Compliant\n  inline static auto field \u003d value;\n  typedef decltype(value) type;\n  static type anotherField;\n};\n\ntemplate \u0026lt;auto ... values\u0026gt;\nstruct MultiA { // Compliant\n  inline static std::vector vec \u003d { values... };\n};\n\ntemplate \u0026lt;auto defaultVal\u0026gt;\nauto foo(decltype(defaultVal) arg) {\n  return arg \u0026gt; 0 ? arg : defaultVal;\n}\n\nvoid f() {\n  A\u0026lt;1\u0026gt; a1;\n  A\u0026lt;false\u0026gt; a2;\n  MultiA\u0026lt;1, 2, 3, 4\u0026gt; multiA1;\n  MultiA\u0026lt;\u0027a\u0027, \u0027b\u0027\u0026gt; multiA2;\n  foo\u0026lt;1\u0026gt;(-1);\n}\n\n// Get the type out of auto... declaration\ntemplate \u0026lt;class T\u0026gt;\nT packed_t(T...);\n\ntemplate \u0026lt;auto... Is\u0026gt;\nstd::vector\u0026lt;std::string\u0026gt; name_copy(std::map\u0026lt;decltype(packed_t(Is...)), std::string\u0026gt; names) {\n  return {names[Is]...};\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "clumsy",
      "since-c++17"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6147",
    "name": "Use discriminated unions or \"std::variant\"",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eIn order to save memory, unions allow you to use the same memory to store objects from a list of possible types as long as one object is stored at\na time. Unions are not inherently safe, as they expect you to externally keep track of the type of value they currently hold.\u003c/p\u003e\n\u003cp\u003eWrong tracking has the potential to corrupt memory or to trigger undefined behaviors.\u003c/p\u003e\n\u003cp\u003eA straightforward way to avoid it is storing the information about the currently active alternative along with the union. Here follow suggested\npatterns to do that:\u003c/p\u003e\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cpre\u003e\ntypedef int   altType1;\ntypedef float altType2;\n\n// Pattern 1\nunion alternativesCommonStartingFieldPattern {\n  struct {\n    bool isAlt1;\n    altType1 a1;\n  } one;\n\n  struct {\n    bool isAlt1;\n    altType2 a2;\n  } two;\n};\n\ndouble getValueAsDouble(alternativesCommonStartingFieldPattern *pattern1) {\n  return pattern1-\u0026gt;one.isAlt1?pattern1-\u0026gt;one.a1:pattern1-\u0026gt;two.a2;\n}\n\u003c/pre\u003e\n\u003cp\u003eThis pattern uses the fact that when two alternatives of a standard layout union are standard-layout-structs that share a common initial sequence,\nit is allowed to read this common initial sequence on one alternative even if the other alternative is the one currently active. This is commonly used\nto limit the number of bits required to store the discriminant.\u003c/p\u003e\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cpre\u003e\n// Pattern 2\nstruct wrappedUnionPattern {\n  enum {ALTTYPE1, ALTTYPE2} type;\n\n  union {\n    altType1 a1;\n    altType2 a2;\n  };\n};\n\ndouble getValueAsDouble(wrappedUnionPattern *pattern2) {\n  return (pattern2-\u0026gt;type\u003d\u003dwrappedUnionPattern::ALTTYPE1)?pattern2-\u0026gt;a1:pattern2-\u0026gt;a2;\n}\n\u003c/pre\u003e\n\u003cp\u003eThis pattern is more straightforward, and wraps the union inside a structure that will also store the discriminant. Note that in this case, the\nunion itself can be anonymous.\u003c/p\u003e\n\u003cpre\u003e\n// Pattern 3 (C++17)\nusing stdVariantPattern \u003d std::variant\u0026lt;altType1, altType2\u0026gt;;\n\ndouble getValueAsDouble(stdVariantPattern *pattern3) {\n  return std::visit([](auto\u0026amp;\u0026amp; alternative) -\u0026gt; double { return alternative;}, *pattern3);\n}\n\u003c/pre\u003e\n\u003cp\u003eThis pattern relies on C++17’s \u003ccode\u003estd::variant\u003c/code\u003e to store the alternative.\u003c/p\u003e\n\u003cp\u003eIn general, \u003ccode\u003estd::variant\u003c/code\u003e is:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Safer as the type of the current value is always known and checked before usage. \u003c/li\u003e\n  \u003cli\u003e More practical as it can have members of any type, including non trivial types (see {rule:cpp:S6025}). It also supports redundant types, which\n  is useful when alternatives have the same type with different semantic meanings. \u003c/li\u003e\n  \u003cli\u003e Easier to use as it provides many member/helper functions. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOne noticeable difference with unions is that the alternatives in a \u003ccode\u003estd::variant\u003c/code\u003e do not have a name. You can access them by type or by\nindex, using \u003ccode\u003estd::get\u003c/code\u003e (throws if the wrong alternative is accessed) or \u003ccode\u003estd::get_if\u003c/code\u003e (returns a null pointer if the wrong\nalternative is used). But very often, instead of accessing a specific alternative, visitors are used to distinguish cases of the variant.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when unions are used outside of the 3 suggested patterns.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid rawUnion() {\n  union IntOrDouble { // Noncompliant: union is not wrapped\n    int i;\n    double d;\n  };\n  IntOrDouble intOrDouble;\n  intOrDouble.d \u003d 10.5;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstruct IntOrChar {\n\u0026nbsp; enum { INT, CHAR } tag;\n\u0026nbsp; union { // Compliant\n\u0026nbsp; \u0026nbsp; int i;\n\u0026nbsp; \u0026nbsp; char c;\n\u0026nbsp; };\n};\n\nvoid simpleVariant() {\n\u0026nbsp; std::variant\u0026lt;int, double\u0026gt; intOrDouble \u003d 10.5; // Compliant\n}{code}\n\u0026nbsp;\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eIn order to save memory, unions allow you to use the same memory to store objects from a list of possible types as long as one object is stored at\na time. Unions are not inherently safe, as they expect you to externally keep track of the type of value they currently hold.\u003c/p\u003e\n\u003cp\u003eWrong tracking has the potential to corrupt memory or to trigger undefined behaviors.\u003c/p\u003e\n\u003cp\u003eA straightforward way to avoid it is storing the information about the currently active alternative along with the union. Here follow suggested\npatterns to do that:\u003c/p\u003e\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cpre\u003e\ntypedef int   altType1;\ntypedef float altType2;\n\n// Pattern 1\nunion alternativesCommonStartingFieldPattern {\n  struct {\n    bool isAlt1;\n    altType1 a1;\n  } one;\n\n  struct {\n    bool isAlt1;\n    altType2 a2;\n  } two;\n};\n\ndouble getValueAsDouble(alternativesCommonStartingFieldPattern *pattern1) {\n  return pattern1-\u0026gt;one.isAlt1?pattern1-\u0026gt;one.a1:pattern1-\u0026gt;two.a2;\n}\n\u003c/pre\u003e\n\u003cp\u003eThis pattern uses the fact that when two alternatives of a standard layout union are standard-layout-structs that share a common initial sequence,\nit is allowed to read this common initial sequence on one alternative even if the other alternative is the one currently active. This is commonly used\nto limit the number of bits required to store the discriminant.\u003c/p\u003e\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003cpre\u003e\n// Pattern 2\nstruct wrappedUnionPattern {\n  enum {ALTTYPE1, ALTTYPE2} type;\n\n  union {\n    altType1 a1;\n    altType2 a2;\n  };\n};\n\ndouble getValueAsDouble(wrappedUnionPattern *pattern2) {\n  return (pattern2-\u0026gt;type\u003d\u003dwrappedUnionPattern::ALTTYPE1)?pattern2-\u0026gt;a1:pattern2-\u0026gt;a2;\n}\n\u003c/pre\u003e\n\u003cp\u003eThis pattern is more straightforward, and wraps the union inside a structure that will also store the discriminant. Note that in this case, the\nunion itself can be anonymous.\u003c/p\u003e\n\u003cpre\u003e\n// Pattern 3 (C++17)\nusing stdVariantPattern \u003d std::variant\u0026lt;altType1, altType2\u0026gt;;\n\ndouble getValueAsDouble(stdVariantPattern *pattern3) {\n  return std::visit([](auto\u0026amp;\u0026amp; alternative) -\u0026gt; double { return alternative;}, *pattern3);\n}\n\u003c/pre\u003e\n\u003cp\u003eThis pattern relies on C++17’s \u003ccode\u003estd::variant\u003c/code\u003e to store the alternative.\u003c/p\u003e\n\u003cp\u003eIn general, \u003ccode\u003estd::variant\u003c/code\u003e is:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Safer as the type of the current value is always known and checked before usage. \u003c/li\u003e\n  \u003cli\u003e More practical as it can have members of any type, including non trivial types (see {rule:cpp:S6025}). It also supports redundant types, which\n  is useful when alternatives have the same type with different semantic meanings. \u003c/li\u003e\n  \u003cli\u003e Easier to use as it provides many member/helper functions. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOne noticeable difference with unions is that the alternatives in a \u003ccode\u003estd::variant\u003c/code\u003e do not have a name. You can access them by type or by\nindex, using \u003ccode\u003estd::get\u003c/code\u003e (throws if the wrong alternative is accessed) or \u003ccode\u003estd::get_if\u003c/code\u003e (returns a null pointer if the wrong\nalternative is used). But very often, instead of accessing a specific alternative, visitors are used to distinguish cases of the variant.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when unions are used outside of the 3 suggested patterns.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid rawUnion() {\n  union IntOrDouble { // Noncompliant: union is not wrapped\n    int i;\n    double d;\n  };\n  IntOrDouble intOrDouble;\n  intOrDouble.d \u003d 10.5;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstruct IntOrChar {\n\u0026nbsp; enum { INT, CHAR } tag;\n\u0026nbsp; union { // Compliant\n\u0026nbsp; \u0026nbsp; int i;\n\u0026nbsp; \u0026nbsp; char c;\n\u0026nbsp; };\n};\n\nvoid simpleVariant() {\n\u0026nbsp; std::variant\u0026lt;int, double\u0026gt; intOrDouble \u003d 10.5; // Compliant\n}{code}\n\u0026nbsp;\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "clumsy",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6029",
    "name": "Exception specifications should be treated as part of the type",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eSince C++17, exception specifications have become a part of a function type. This implies that these two functions, for example, have different\ntypes:\u003c/p\u003e\n\u003cpre\u003e\nvoid first() noexcept;\nvoid second();\n\u003c/pre\u003e\n\u003cp\u003eMaking exception specifications part of the type will, for the right reason, break code where a function that throws an exception is provided in a\ncontext where \u003ccode\u003enoexcept\u003c/code\u003e function is expected.\u003c/p\u003e\n\u003cp\u003eIt is important to note that, like it is not allowed to overload based on the return type, it is also not allowed to overload based on the\nexception specifications.\u003c/p\u003e\n\u003cp\u003eThis rule will trigger on code that will stop compiling starting C++17, and on explicit casts that add \u003ccode\u003enoexcept\u003c/code\u003e to a type.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\ntemplate\u0026lt;typename T\u0026gt;\nvoid callF1(T t1, T t2) {\n  t1();\n  t2();\n}\n\nvoid f1();\nvoid f1NoExcept() noexcept;\n\nint main() {\n  callF1(f1, f1NoExcept); // Noncompliant, f1 and f1NoExcept have different types\n  std::function\u0026lt;void() noexcept\u0026gt; fptr1 \u003d f1; // Noncompliant\n  void (*fptr2)() noexcept \u003d f1; // Noncompliant\n  void (*fptr3)() noexcept \u003d (void (*)() noexcept) f1; // Noncompliant, it works even in c++17\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\ntemplate\u0026lt;typename T1, typename T2\u0026gt;\nvoid callF1(T1 t1, T2 t2) {\n  t1();\n  t2();\n}\n\nvoid f1();\nvoid f1NoExcept() noexcept;\n\nint main() {\n  callF1(f1, f1NoExcept); // Compliant\n  std::function\u0026lt;void() noexcept\u0026gt; fptr1 \u003d f1NoExcept; // Compliant\n  void (*fptr2)() \u003d f1; // Compliant\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eSince C++17, exception specifications have become a part of a function type. This implies that these two functions, for example, have different\ntypes:\u003c/p\u003e\n\u003cpre\u003e\nvoid first() noexcept;\nvoid second();\n\u003c/pre\u003e\n\u003cp\u003eMaking exception specifications part of the type will, for the right reason, break code where a function that throws an exception is provided in a\ncontext where \u003ccode\u003enoexcept\u003c/code\u003e function is expected.\u003c/p\u003e\n\u003cp\u003eIt is important to note that, like it is not allowed to overload based on the return type, it is also not allowed to overload based on the\nexception specifications.\u003c/p\u003e\n\u003cp\u003eThis rule will trigger on code that will stop compiling starting C++17, and on explicit casts that add \u003ccode\u003enoexcept\u003c/code\u003e to a type.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\ntemplate\u0026lt;typename T\u0026gt;\nvoid callF1(T t1, T t2) {\n  t1();\n  t2();\n}\n\nvoid f1();\nvoid f1NoExcept() noexcept;\n\nint main() {\n  callF1(f1, f1NoExcept); // Noncompliant, f1 and f1NoExcept have different types\n  std::function\u0026lt;void() noexcept\u0026gt; fptr1 \u003d f1; // Noncompliant\n  void (*fptr2)() noexcept \u003d f1; // Noncompliant\n  void (*fptr3)() noexcept \u003d (void (*)() noexcept) f1; // Noncompliant, it works even in c++17\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\ntemplate\u0026lt;typename T1, typename T2\u0026gt;\nvoid callF1(T1 t1, T2 t2) {\n  t1();\n  t2();\n}\n\nvoid f1();\nvoid f1NoExcept() noexcept;\n\nint main() {\n  callF1(f1, f1NoExcept); // Compliant\n  std::function\u0026lt;void() noexcept\u0026gt; fptr1 \u003d f1NoExcept; // Compliant\n  void (*fptr2)() \u003d f1; // Compliant\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "clumsy",
      "pitfall",
      "since-c++11"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S3624",
    "name": "When the \"Rule-of-Zero\" is not applicable, the \"Rule-of-Five\" should be followed",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eIn C++, you should not directly manipulate resources (a database transaction, a network connection, a mutex lock) but encapsulate them in RAII\n(\u003cem\u003eResource Acquisition Is Initialization\u003c/em\u003e) wrapper classes that will allow you to manipulate them safely. When defining one of those wrapper\nclasses, you cannot rely on the compiler-generated special member functions to manage the class\u0027 resources for you (see the Rule-of-Zero,\n{rule:cpp:S4963}). You must define those functions yourself to make sure the class\u0027 resources are properly copied, moved, and destroyed.\u003c/p\u003e\n\u003cp\u003eIn that case, make sure you consider what should be done for all five special functions (or only the first three before C++11):\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The destructor: to release the resource when the wrapper is destroyed \u003c/li\u003e\n  \u003cli\u003e The copy constructor and the copy-assignment operator: to handle what should happen to the resource when the wrapper is copied (a valid option\n  is to disable those operations with \u003ccode\u003e\u003ddelete\u003c/code\u003e) \u003c/li\u003e\n  \u003cli\u003e The move constructor and the move-assignment operator: to handle what should happen to the resource when the wrapper is moved (since C++11). If\n  you cannot find a way to implement them more efficiently than the copy operations, as an exception to this rule, you can just leave out these\n  operations: the compiler will not generate them and will use the copy operations as a fallback. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe operations mentioned above are interdependent. Letting the compiler generate some of these operations automatically, but not all of them,\ncreates a situation where calling one of these functions may compromise the integrity of the resource. For example, it could result in a\ndouble-release of a resource when the wrapper is copied.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass FooPointer { // Noncompliant, missing copy constructor and copy-assignment operator\n  Foo* pFoo;\npublic:\n  FooPointer(int initValue) {\n    pFoo \u003d new Foo(initValue);\n  }\n  ~FooPointer() {\n    delete pFoo;\n  }\n};\n\nint main() {\n  FooPointer a(5);\n  FooPointer b \u003d a; // implicit copy constructor gives rise to double free memory error\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nclass FooPointer { // Compliant, although it\u0027s usually better to reuse an existing wrapper for memory\n  Foo* pFoo;\npublic:\n  FooPointer(int initValue) {\n    pFoo \u003d new Foo(initValue);\n  }\n  FooPointer(FooPointer\u0026amp; other) {\n    pFoo \u003d new Foo(other.pFoo-\u0026gt;value);\n  }\n  FooPointer\u0026amp; operator\u003d(const FooPointer\u0026amp; other) {\n    int val \u003d other.pFoo-\u0026gt;value;\n    delete pFoo;\n    pFoo \u003d new Foo(val);\n    return *this;\n  }\n  FooPointer(FooPointer \u0026amp;\u0026amp;fp) noexcept {\n    pFoo \u003d fp.pFoo;\n    fp.pFoo \u003d nullptr;\n  }\n  FooPointer const \u0026amp; operator\u003d(FooPointer \u0026amp;\u0026amp;fp) {\n    FooPointer temp(std::move(fp));\n    std::swap(temp.pFoo, pFoo);\n    return *this;\n  }\n  ~FooPointer() {\n    delete pFoo;\n  }\n};\n\nint main() {\n  FooPointer a(5);\n  FooPointer b \u003d a; // no error\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/raii\"\u003eRAII\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/oHs-BQ\"\u003eOOP54-CPP. - Gracefully handle self-copy assignment\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eIn C++, you should not directly manipulate resources (a database transaction, a network connection, a mutex lock) but encapsulate them in RAII\n(\u003cem\u003eResource Acquisition Is Initialization\u003c/em\u003e) wrapper classes that will allow you to manipulate them safely. When defining one of those wrapper\nclasses, you cannot rely on the compiler-generated special member functions to manage the class\u0027 resources for you (see the Rule-of-Zero,\n{rule:cpp:S4963}). You must define those functions yourself to make sure the class\u0027 resources are properly copied, moved, and destroyed.\u003c/p\u003e\n\u003cp\u003eIn that case, make sure you consider what should be done for all five special functions (or only the first three before C++11):\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The destructor: to release the resource when the wrapper is destroyed \u003c/li\u003e\n  \u003cli\u003e The copy constructor and the copy-assignment operator: to handle what should happen to the resource when the wrapper is copied (a valid option\n  is to disable those operations with \u003ccode\u003e\u003ddelete\u003c/code\u003e) \u003c/li\u003e\n  \u003cli\u003e The move constructor and the move-assignment operator: to handle what should happen to the resource when the wrapper is moved (since C++11). If\n  you cannot find a way to implement them more efficiently than the copy operations, as an exception to this rule, you can just leave out these\n  operations: the compiler will not generate them and will use the copy operations as a fallback. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe operations mentioned above are interdependent. Letting the compiler generate some of these operations automatically, but not all of them,\ncreates a situation where calling one of these functions may compromise the integrity of the resource. For example, it could result in a\ndouble-release of a resource when the wrapper is copied.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass FooPointer { // Noncompliant, missing copy constructor and copy-assignment operator\n  Foo* pFoo;\npublic:\n  FooPointer(int initValue) {\n    pFoo \u003d new Foo(initValue);\n  }\n  ~FooPointer() {\n    delete pFoo;\n  }\n};\n\nint main() {\n  FooPointer a(5);\n  FooPointer b \u003d a; // implicit copy constructor gives rise to double free memory error\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nclass FooPointer { // Compliant, although it\u0027s usually better to reuse an existing wrapper for memory\n  Foo* pFoo;\npublic:\n  FooPointer(int initValue) {\n    pFoo \u003d new Foo(initValue);\n  }\n  FooPointer(FooPointer\u0026amp; other) {\n    pFoo \u003d new Foo(other.pFoo-\u0026gt;value);\n  }\n  FooPointer\u0026amp; operator\u003d(const FooPointer\u0026amp; other) {\n    int val \u003d other.pFoo-\u0026gt;value;\n    delete pFoo;\n    pFoo \u003d new Foo(val);\n    return *this;\n  }\n  FooPointer(FooPointer \u0026amp;\u0026amp;fp) noexcept {\n    pFoo \u003d fp.pFoo;\n    fp.pFoo \u003d nullptr;\n  }\n  FooPointer const \u0026amp; operator\u003d(FooPointer \u0026amp;\u0026amp;fp) {\n    FooPointer temp(std::move(fp));\n    std::swap(temp.pFoo, pFoo);\n    return *this;\n  }\n  ~FooPointer() {\n    delete pFoo;\n  }\n};\n\nint main() {\n  FooPointer a(5);\n  FooPointer b \u003d a; // no error\n  return 0;\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/raii\"\u003eRAII\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/oHs-BQ\"\u003eOOP54-CPP. - Gracefully handle self-copy assignment\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cert",
      "leak",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1448",
    "name": "Classes should not have too many methods",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "FOCUSED",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eA class that grows too much tends to aggregate too many responsibilities and inevitably becomes harder to understand and therefore to maintain.\nAbove a specific threshold, it is strongly advised to refactor the class into smaller ones which focus on well defined topics.\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eA class that grows too much tends to aggregate too many responsibilities and inevitably becomes harder to understand and therefore to maintain.\nAbove a specific threshold, it is strongly advised to refactor the class into smaller ones which focus on well defined topics.\u003c/p\u003e"
      }
    ],
    "params": {
      "maximumMethodThreshold": {
        "key": "maximumMethodThreshold",
        "name": "maximumMethodThreshold",
        "description": "The maximum number of methods authorized in a class.",
        "defaultValue": "35",
        "type": "INTEGER",
        "multiple": false,
        "possibleValues": []
      }
    },
    "defaultParams": {
      "maximumMethodThreshold": "35"
    },
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "brain-overload"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5802",
    "name": "Changing directories improperly when using \"chroot\" is security-sensitive",
    "defaultSeverity": "CRITICAL",
    "type": "SECURITY_HOTSPOT",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "SECURITY": "HIGH"
    },
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe purpose of creating a jail, the \"virtual root directory\" created with chroot-type functions, is to limit access to the file system by isolating\nthe process inside this jail. However, many chroot function implementations don’t modify the current working directory, thus the process has still\naccess to unauthorized resources outside of the \"jail\".\u003c/p\u003e"
      },
      {
        "key": "assess_the_problem",
        "htmlContent": "\u003ch2\u003eAsk Yourself Whether\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e The application changes the working directory before or after running chroot. \u003c/li\u003e\n  \u003cli\u003e The application uses a path inside the jail directory as working directory. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere is a risk if you answered no to any of those questions.\u003c/p\u003e\n\u003ch2\u003eSensitive Code Example\u003c/h2\u003e\n\u003cp\u003eThe current directory is not changed with the \u003ccode\u003echdir\u003c/code\u003e function before or after the creation of a jail with the \u003ccode\u003echroot\u003c/code\u003e\nfunction:\u003c/p\u003e\n\u003cpre\u003e\nconst char* root_dir \u003d \"/jail/\";\nchroot(root_dir); // Sensitive: no chdir before or after chroot, and missing check of return value\n\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003echroot\u003c/code\u003e or \u003ccode\u003echdir\u003c/code\u003e operations could fail and the process still have access to unauthorized resources. The return code\nshould be checked:\u003c/p\u003e\n\u003cpre\u003e\nconst char* root_dir \u003d \"/jail/\";\nchroot(root_dir); // Sensitive: missing check of the return value\nconst char* any_dir \u003d \"/any/\";\nchdir(any_dir); // Sensitive: missing check of the return value\n\u003c/pre\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003ch2\u003eRecommended Secure Coding Practices\u003c/h2\u003e\n\u003cp\u003eChange the current working directory to the root directory after switching to a jail directory.\u003c/p\u003e\n\u003ch2\u003eCompliant Solution\u003c/h2\u003e\n\u003cp\u003eTo correctly isolate the application into a jail, change the current directory with \u003ccode\u003echdir\u003c/code\u003e before the \u003ccode\u003echroot\u003c/code\u003e and check the\nreturn code of both functions:\u003c/p\u003e\n\u003cpre\u003e\nconst char* root_dir \u003d \"/jail/\";\n\nif (chdir(root_dir) \u003d\u003d -1) {\n  exit(-1);\n}\n\nif (chroot(root_dir) \u003d\u003d -1) {  // compliant: the current dir is changed to the jail and the results of both functions are checked\n  exit(-1);\n}\n\u003c/pre\u003e\n\u003ch2\u003eSee\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/Top10/A05_2021-Security_Misconfiguration/\"\u003eOWASP Top 10 2021 Category A5\u003c/a\u003e - Security Misconfiguration \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A5-Broken_Access_Control\"\u003eOWASP Top 10 2017 Category A5\u003c/a\u003e -\n  Broken Access Control \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/243\"\u003eMITRE, CWE-243\u003c/a\u003e - Creation of chroot Jail Without Changing Working Directory \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://man7.org/linux/man-pages/man2/chdir.2.html\"\u003eman7.org\u003c/a\u003e - chdir \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://man7.org/linux/man-pages/man2/chroot.2.html\"\u003eman7.org\u003c/a\u003e - chroot \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cwe",
      "symbolic-execution"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": [],
    "vulnerabilityProbability": "LOW"
  },
  {
    "key": "cpp:S3626",
    "name": "Jump statements should not be redundant",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eJump statements, such as \u003ccode\u003ereturn\u003c/code\u003e, \u003ccode\u003ebreak\u003c/code\u003e, \u003ccode\u003egoto\u003c/code\u003e, and \u003ccode\u003econtinue\u003c/code\u003e let you change the default flow of\nprogram execution, but jump statements that direct the control flow to the original direction are just a waste of keystrokes.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid Foo()\n{\n  goto A; // Noncompliant\n  A:\n  while (condition1)\n  {\n    if (condition2)\n    {\n      continue; // Noncompliant\n    }\n    else\n    {\n      DoTheThing();\n    }\n  }\n  return; // Noncompliant; this is a void method\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid Foo()\n{\n  while (condition1)\n  {\n    if (!condition2)\n    {\n      DoTheThing();\n    }\n  }\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eJump statements, such as \u003ccode\u003ereturn\u003c/code\u003e, \u003ccode\u003ebreak\u003c/code\u003e, \u003ccode\u003egoto\u003c/code\u003e, and \u003ccode\u003econtinue\u003c/code\u003e let you change the default flow of\nprogram execution, but jump statements that direct the control flow to the original direction are just a waste of keystrokes.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid Foo()\n{\n  goto A; // Noncompliant\n  A:\n  while (condition1)\n  {\n    if (condition2)\n    {\n      continue; // Noncompliant\n    }\n    else\n    {\n      DoTheThing();\n    }\n  }\n  return; // Noncompliant; this is a void method\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid Foo()\n{\n  while (condition1)\n  {\n    if (!condition2)\n    {\n      DoTheThing();\n    }\n  }\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "clumsy",
      "redundant"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S3628",
    "name": "Raw string literals should be used",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eSince C++11, raw string literals can be used to avoid the need to escape characters in a string.\u003c/p\u003e\n\u003cp\u003eThis rules raises an issue when using a raw string literal would make a string easier to read. For instance, when a non-raw string contains\ndifferent escaped sequences (among \u003ccode\u003e\\\u0027\u003c/code\u003e, \u003ccode\u003e\\\\\u003c/code\u003e, \u003ccode\u003e\\\"\u003c/code\u003e and \u003ccode\u003e\\?\u003c/code\u003e) or more than two of the same kind.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nconst auto* result \u003d \"a\\?b \\\"\"; // Noncompliant\nconst auto* regEx \u003d \"\\\\\\\\(\\\\\\\\.\\\\\\\\)\"; // Noncompliant\nconst auto* message \u003d \"Use \\\"x\\\" or \\\"y\\\"\"; // Noncompliant\nconst auto* rawLit \u003d R\"(Hello!)\" ...)\"; // Noncompliant, literal contains closing sequence\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nconst auto* result \u003d R\"(a?b \")\";\nconst auto* regEx \u003d R\"(\\\\(\\\\.\\\\))\";\nconst auto* message \u003d R\"(Use \"x\" or \"y\")\";\nconst auto* rawLit \u003d R\"_(Hello!)\" ...)_\"; // Compliant, uses delimiter whose closing sequence does not appear in the literal\n\nconst auto* twoLines \u003d \"one\\r\\ntwo\"; // Compliant, contains \\r\nconst auto* path \u003d \"C:\\\\Program Files\\\\Microsoft Office\\\\Office16\\\\\";  // Compliant, raw strings would not improve readability\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eTo preserve readability, this rule ignores strings containing only one character and strings with escaped whitespace or non-printable\ncharacters:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Non-printable characters: \u003ccode\u003e\\a\u003c/code\u003e \u003ccode\u003e\\b\u003c/code\u003e \u003ccode\u003e\\f\u003c/code\u003e \u003ccode\u003e\\v\u003c/code\u003e \u003ccode\u003e\\nnn\u003c/code\u003e \u003ccode\u003e\\xnn\u003c/code\u003e\n  \u003ccode\u003e\\unnnn\u003c/code\u003e \u003ccode\u003e\\Unnnnnnnn\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e Tab: \u003ccode\u003e\\t\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e Carriage return: \u003ccode\u003e\\r\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eSince C++11, raw string literals can be used to avoid the need to escape characters in a string.\u003c/p\u003e\n\u003cp\u003eThis rules raises an issue when using a raw string literal would make a string easier to read. For instance, when a non-raw string contains\ndifferent escaped sequences (among \u003ccode\u003e\\\u0027\u003c/code\u003e, \u003ccode\u003e\\\\\u003c/code\u003e, \u003ccode\u003e\\\"\u003c/code\u003e and \u003ccode\u003e\\?\u003c/code\u003e) or more than two of the same kind.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nconst auto* result \u003d \"a\\?b \\\"\"; // Noncompliant\nconst auto* regEx \u003d \"\\\\\\\\(\\\\\\\\.\\\\\\\\)\"; // Noncompliant\nconst auto* message \u003d \"Use \\\"x\\\" or \\\"y\\\"\"; // Noncompliant\nconst auto* rawLit \u003d R\"(Hello!)\" ...)\"; // Noncompliant, literal contains closing sequence\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nconst auto* result \u003d R\"(a?b \")\";\nconst auto* regEx \u003d R\"(\\\\(\\\\.\\\\))\";\nconst auto* message \u003d R\"(Use \"x\" or \"y\")\";\nconst auto* rawLit \u003d R\"_(Hello!)\" ...)_\"; // Compliant, uses delimiter whose closing sequence does not appear in the literal\n\nconst auto* twoLines \u003d \"one\\r\\ntwo\"; // Compliant, contains \\r\nconst auto* path \u003d \"C:\\\\Program Files\\\\Microsoft Office\\\\Office16\\\\\";  // Compliant, raw strings would not improve readability\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eTo preserve readability, this rule ignores strings containing only one character and strings with escaped whitespace or non-printable\ncharacters:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Non-printable characters: \u003ccode\u003e\\a\u003c/code\u003e \u003ccode\u003e\\b\u003c/code\u003e \u003ccode\u003e\\f\u003c/code\u003e \u003ccode\u003e\\v\u003c/code\u003e \u003ccode\u003e\\nnn\u003c/code\u003e \u003ccode\u003e\\xnn\u003c/code\u003e\n  \u003ccode\u003e\\unnnn\u003c/code\u003e \u003ccode\u003e\\Unnnnnnnn\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e Tab: \u003ccode\u003e\\t\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e Carriage return: \u003ccode\u003e\\r\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "since-c++11"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5801",
    "name": "Using \"strcpy\" or \"wcscpy\" is security-sensitive",
    "defaultSeverity": "MAJOR",
    "type": "SECURITY_HOTSPOT",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "SECURITY": "MEDIUM"
    },
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eIn C, a string is just a buffer of characters, normally using the \u003ccode\u003enull\u003c/code\u003e character as a sentinel for the end of the string. This means\nthat the developer has to be aware of low-level details such as buffer sizes or having an extra character to store the final \u003ccode\u003enull\u003c/code\u003e\ncharacter. Doing that correctly and consistently is notoriously difficult and any error can lead to a security vulnerability, for instance, giving\naccess to sensitive data or allowing arbitrary code execution.\u003c/p\u003e\n\u003cp\u003eThe function \u003ccode\u003echar *strcpy(char * restrict dest, const char * restrict src);\u003c/code\u003e copies characters from \u003ccode\u003esrc\u003c/code\u003e to\n\u003ccode\u003edest\u003c/code\u003e. The \u003ccode\u003ewcscpy\u003c/code\u003e does the same for wide characters and should be used with the same guidelines.\u003c/p\u003e\n\u003cp\u003eNote: the functions \u003ccode\u003estrncpy\u003c/code\u003e and \u003ccode\u003ewcsncpy\u003c/code\u003e might look like attractive safe replacements for \u003ccode\u003estrcpy\u003c/code\u003e and\n\u003ccode\u003ewcscpy\u003c/code\u003e, but they have their own set of issues (see {rule:cpp:S5816}), and you should probably prefer another more adapted\nalternative.\u003c/p\u003e"
      },
      {
        "key": "assess_the_problem",
        "htmlContent": "\u003ch2\u003eAsk Yourself Whether\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e There is a possibility that either the source or the destination pointer is \u003ccode\u003enull\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e There is a possibility that the source string is not correctly \u003ccode\u003enull\u003c/code\u003e-terminated, or that its length (including the final\n  \u003ccode\u003enull\u003c/code\u003e character) can be larger than the size of the destination buffer. \u003c/li\u003e\n  \u003cli\u003e There is an overlap between source and destination \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere is a risk if you answered yes to any of those questions.\u003c/p\u003e\n\u003ch2\u003eSensitive Code Example\u003c/h2\u003e\n\u003cpre\u003e\nint f(char *src) {\n  char dest[256];\n  strcpy(dest, src); // Sensitive: might overflow\n  return doSomethingWith(dest);\n}\n\u003c/pre\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003ch2\u003eRecommended Secure Coding Practices\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C11 provides, in its annex K, the \u003ccode\u003estrcpy_s\u003c/code\u003e and the \u003ccode\u003ewcscpy_s\u003c/code\u003e that were designed as safer alternatives to\n  \u003ccode\u003estrcpy\u003c/code\u003e and \u003ccode\u003ewcscpy\u003c/code\u003e. It’s not recommended to use them in all circumstances, because they introduce a runtime overhead and\n  require to write more code for error handling, but they perform checks that will limit the consequences of calling the function with bad arguments.\n  \u003c/li\u003e\n  \u003cli\u003e Even if your compiler does not exactly support annex K, you probably have access to similar functions, for example, \u003ccode\u003estrlcpy\u003c/code\u003e in\n  FreeBSD \u003c/li\u003e\n  \u003cli\u003e If you are writing C++ code, using \u003ccode\u003estd::string\u003c/code\u003e to manipulate strings is much simpler and less error-prone \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eCompliant Solution\u003c/h2\u003e\n\u003cpre\u003e\nint f(char *src) {\n  char *dest \u003d malloc(strlen(src) + 1); // For the final 0\n  strcpy(dest, src); // Compliant: we made sure the buffer is large enough\n  int r\u003d doSomethingWith(dest);\n  free(dest);\n  return r;\n}\n\u003c/pre\u003e\n\u003ch2\u003eSee\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/Top10/A06_2021-Vulnerable_and_Outdated_Components/\"\u003eOWASP Top 10 2021 Category A6\u003c/a\u003e - Vulnerable and Outdated\n  Components \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/www-project-top-ten/2017/A9_2017-Using_Components_with_Known_Vulnerabilities\"\u003eOWASP Top 10 2017 Category A9\u003c/a\u003e -\n  Using Components with Known Vulnerabilities \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/120\"\u003eMITRE, CWE-120\u003c/a\u003e - Buffer Copy without Checking Size of Input (\u0027Classic Buffer\n  Overflow\u0027) \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/HdcxBQ\"\u003eCERT, STR07-C.\u003c/a\u003e - Use the bounds-checking interfaces for string manipulation \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cert",
      "cwe"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": [],
    "vulnerabilityProbability": "HIGH"
  },
  {
    "key": "cpp:S3744",
    "name": "Macros should not be redefined",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eA macro definition should not be redefined without marking that intent specifically by un-defining it first.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#define A 1\n#define A 2\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#define A 1\n#undef A\n#define A 2\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eIf the redefinition has the same value as the original one. This is consistent with most C compilers warnings.\u003c/p\u003e\n\u003cpre\u003e\n#define A 1\n#define A 1\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eA macro definition should not be redefined without marking that intent specifically by un-defining it first.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#define A 1\n#define A 2\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#define A 1\n#undef A\n#define A 2\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eIf the redefinition has the same value as the original one. This is consistent with most C compilers warnings.\u003c/p\u003e\n\u003cpre\u003e\n#define A 1\n#define A 1\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "confusing"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S3743",
    "name": "Exceptions should not be thrown in \"noexcept\" functions",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003enoexcept\u003c/code\u003e is a specifier that can be applied to a function declaration to state whether or not this function might throw an\nexception.\u003c/p\u003e\n\u003cp\u003eThis specifier is a crucial information for the compiler as it enables it to perform automatic optimizations. It is also used by the\n\u003ccode\u003enoexcept\u003c/code\u003e operator, so that a developer can know whether an expression can throw, and adapt the code accordingly (for instance, to decide\nto \u003ccode\u003emove\u003c/code\u003e or \u003ccode\u003ecopy\u003c/code\u003e an object).\u003c/p\u003e\n\u003cp\u003eWhen a function is specified \u003ccode\u003enoexcept\u003c/code\u003e, the compiler does not generate any code to throw exceptions and any uncaught exception will\nresult in a call to std::terminate. This means that writing a \u003ccode\u003enoexcept\u003c/code\u003e function is an implicit agreement to the statement : \"my program\nwill terminate if any exception is thrown inside this function\".\u003c/p\u003e\n\u003cp\u003eIt is a very strong commitment as there are so many ways to get an exception including any dynamic allocation.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when an exception is thrown, directly or indirectly, from a function declared \u003ccode\u003enoexcept\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;exception\u0026gt;\n#include \u0026lt;memory\u0026gt;\n\nusing namespace std;\n\nclass SafetyException {};\nclass Engine {};\nunique_ptr\u0026lt;Engine\u0026gt; engine;\n\nbool safety_check() noexcept;\nvoid other_checks();\n\nvoid critical_checks() {\n  if (!safety_check()) {\n    throw SafetyException{};\n  }\n}\n\nvoid do_checks() {\n  critical_checks(); // can throw\n  other_checks(); // can throw\n}\n\nvoid init() noexcept(true) { // noncompliant because...\n  do_checks(); // can throw\n  engine \u003d std::make_unique\u0026lt;Engine\u0026gt;(); // can throw\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;exception\u0026gt;\n#include \u0026lt;memory\u0026gt;\n\nusing namespace std;\n\nclass SafetyException {};\nclass Engine {};\nunique_ptr\u0026lt;Engine\u0026gt; engine;\n\nbool safety_check();\nvoid other_checks();\n\nvoid critical_checks() {\n  if (!safety_check()) {\n    throw SafetyException{};\n  }\n}\n\nvoid do_checks() {\n  critical_checks();\n  other_checks();\n}\n\nvoid init() noexcept(true) { // compliant because ...\n  try {\n    do_checks(); // exception caught\n    engine \u003d std::make_unique\u0026lt;Engine\u0026gt;(); // exception caught\n  } catch(std::exception e) {\n    std::terminate();\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eDestructors are not handled by this rule because there is a specific rule about exceptions in destructors (see ExceptionInDestructor).\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003ccode\u003enoexcept\u003c/code\u003e is a specifier that can be applied to a function declaration to state whether or not this function might throw an\nexception.\u003c/p\u003e\n\u003cp\u003eThis specifier is a crucial information for the compiler as it enables it to perform automatic optimizations. It is also used by the\n\u003ccode\u003enoexcept\u003c/code\u003e operator, so that a developer can know whether an expression can throw, and adapt the code accordingly (for instance, to decide\nto \u003ccode\u003emove\u003c/code\u003e or \u003ccode\u003ecopy\u003c/code\u003e an object).\u003c/p\u003e\n\u003cp\u003eWhen a function is specified \u003ccode\u003enoexcept\u003c/code\u003e, the compiler does not generate any code to throw exceptions and any uncaught exception will\nresult in a call to std::terminate. This means that writing a \u003ccode\u003enoexcept\u003c/code\u003e function is an implicit agreement to the statement : \"my program\nwill terminate if any exception is thrown inside this function\".\u003c/p\u003e\n\u003cp\u003eIt is a very strong commitment as there are so many ways to get an exception including any dynamic allocation.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when an exception is thrown, directly or indirectly, from a function declared \u003ccode\u003enoexcept\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;exception\u0026gt;\n#include \u0026lt;memory\u0026gt;\n\nusing namespace std;\n\nclass SafetyException {};\nclass Engine {};\nunique_ptr\u0026lt;Engine\u0026gt; engine;\n\nbool safety_check() noexcept;\nvoid other_checks();\n\nvoid critical_checks() {\n  if (!safety_check()) {\n    throw SafetyException{};\n  }\n}\n\nvoid do_checks() {\n  critical_checks(); // can throw\n  other_checks(); // can throw\n}\n\nvoid init() noexcept(true) { // noncompliant because...\n  do_checks(); // can throw\n  engine \u003d std::make_unique\u0026lt;Engine\u0026gt;(); // can throw\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;exception\u0026gt;\n#include \u0026lt;memory\u0026gt;\n\nusing namespace std;\n\nclass SafetyException {};\nclass Engine {};\nunique_ptr\u0026lt;Engine\u0026gt; engine;\n\nbool safety_check();\nvoid other_checks();\n\nvoid critical_checks() {\n  if (!safety_check()) {\n    throw SafetyException{};\n  }\n}\n\nvoid do_checks() {\n  critical_checks();\n  other_checks();\n}\n\nvoid init() noexcept(true) { // compliant because ...\n  try {\n    do_checks(); // exception caught\n    engine \u003d std::make_unique\u0026lt;Engine\u0026gt;(); // exception caught\n  } catch(std::exception e) {\n    std::terminate();\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eDestructors are not handled by this rule because there is a specific rule about exceptions in destructors (see ExceptionInDestructor).\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "bad-practice",
      "error-handling",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1314",
    "name": "Octal values should not be used",
    "defaultSeverity": "BLOCKER",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eInteger literals starting with a zero are octal rather than decimal values. While using octal values is fully supported, most developers do not\nhave experience with them. They may not recognize octal values as such, mistaking them instead for decimal values.\u003c/p\u003e\n\u003cp\u003eHexadecimal literals (\u003ccode\u003e0xdeadbeef\u003c/code\u003e) and binary literals (\u003ccode\u003e0b0101\u00270110\u002700011\u003c/code\u003e, available since C++14), on the other hand, have\na clear marker (\u003ccode\u003e0x\u003c/code\u003e or \u003ccode\u003e0b\u003c/code\u003e) and can be used to define the binary representation of a value.\u003c/p\u003e\n\u003cp\u003eCharacter literals starting with \u003ccode\u003e\\\u003c/code\u003e and followed by one to three digits are octal escaped literals. Character literals starting with\n\u003ccode\u003e\\x\u003c/code\u003e and followed by one or more hexits are hexadecimal escaped literals, and are usually more readable.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint myNumber \u003d 010;   // Noncompliant. myNumber will hold 8, not 10 - was this really expected?\n\nchar myChar \u003d \u0027\\40\u0027; // Noncompliant. myChar will hold 32 rather than 40\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint myNumber \u003d 8; // Use decimal when representing the value 8\n// or\nint myNumber \u003d 0b1000; // Use binary or hexadecimal for a bit mask\n\nchar myChar \u003d \u0027\\x20\u0027; // Use hexadecimal\n// or\nchar myChar \u003d \u0027\\n\u0027; // Use the common notation if it exists for the literal\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Octal values have traditionally been used for user permissions in Posix file systems, and this rule will ignore octal literals used in this\n  context. \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003e\u0027\\0\u0027\u003c/code\u003e is a common notation for a null character, so the rule ignores it. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 7.1 - Octal constants (other than zero) and octal escape sequences shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 2-13-2 - Octal constants (other than zero) and octal escape sequences (other than \"\\0\") shall not be used \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 7.1 - Octal constants shall not be used \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/atYxBQ\"\u003eCERT, DCL18-C.\u003c/a\u003e - Do not begin integer constants with 0 when specifying a decimal\n  value \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eInteger literals starting with a zero are octal rather than decimal values. While using octal values is fully supported, most developers do not\nhave experience with them. They may not recognize octal values as such, mistaking them instead for decimal values.\u003c/p\u003e\n\u003cp\u003eHexadecimal literals (\u003ccode\u003e0xdeadbeef\u003c/code\u003e) and binary literals (\u003ccode\u003e0b0101\u00270110\u002700011\u003c/code\u003e, available since C++14), on the other hand, have\na clear marker (\u003ccode\u003e0x\u003c/code\u003e or \u003ccode\u003e0b\u003c/code\u003e) and can be used to define the binary representation of a value.\u003c/p\u003e\n\u003cp\u003eCharacter literals starting with \u003ccode\u003e\\\u003c/code\u003e and followed by one to three digits are octal escaped literals. Character literals starting with\n\u003ccode\u003e\\x\u003c/code\u003e and followed by one or more hexits are hexadecimal escaped literals, and are usually more readable.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint myNumber \u003d 010;   // Noncompliant. myNumber will hold 8, not 10 - was this really expected?\n\nchar myChar \u003d \u0027\\40\u0027; // Noncompliant. myChar will hold 32 rather than 40\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint myNumber \u003d 8; // Use decimal when representing the value 8\n// or\nint myNumber \u003d 0b1000; // Use binary or hexadecimal for a bit mask\n\nchar myChar \u003d \u0027\\x20\u0027; // Use hexadecimal\n// or\nchar myChar \u003d \u0027\\n\u0027; // Use the common notation if it exists for the literal\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Octal values have traditionally been used for user permissions in Posix file systems, and this rule will ignore octal literals used in this\n  context. \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003e\u0027\\0\u0027\u003c/code\u003e is a common notation for a null character, so the rule ignores it. \u003c/li\u003e\n\u003c/ul\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 7.1 - Octal constants (other than zero) and octal escape sequences shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 2-13-2 - Octal constants (other than zero) and octal escape sequences (other than \"\\0\") shall not be used \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 7.1 - Octal constants shall not be used \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/atYxBQ\"\u003eCERT, DCL18-C.\u003c/a\u003e - Do not begin integer constants with 0 when specifying a decimal\n  value \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "cert",
      "pitfall"
    ],
    "deprecatedKeys": [
      "cpp:OctalConstantAndSequence"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1679",
    "name": "The original exception object should be rethrown",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "EFFICIENT",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhen \u003ccode\u003ethrow\u003c/code\u003e is followed by an expression, this expression will be used to create and initialize the exception object. In other words,\nthe exception object is \u003cem\u003ecopy-initialized\u003c/em\u003e from the expression.\u003c/p\u003e\n\u003cpre\u003e\ncatch (const std::exception\u0026amp; ex) {\n  // ...\n  throw ex; // \"throw\" copy-initializes the exception object from \"ex\"\n}\n\u003c/pre\u003e\n\u003cp\u003eRethrowing an unmodified copy of the caught exception is a bad practice because:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The exception already exists, so it is better to reuse it instead of creating a new one and wasting resources. \u003c/li\u003e\n  \u003cli\u003e The copy will be an instance of the exception base class rather than the potentially more specific exception class initially caught. So it may\n  lead to a loss of precision. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eThe rule raises an issue when the argument of the \u003ccode\u003ethrow\u003c/code\u003e expression is an unmodified copy of the caught exception.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\ntry {\n  throw std::invalid_argument(\"x\");\n} catch (const std::exception\u0026amp; ex) {\n  // ...\n  throw ex; // Noncompliant: the received \"std::invalid_argument\" exception is copied into a less specialized class \"std::exception\"\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\ntry {\n  throw std::invalid_argument(\"x\");\n} catch (const std::exception\u0026amp; ex) {\n  // ...\n  throw; // Compliant: rethrows the initial \"std::invalid_argument\" exception\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/throw\"\u003e\u003ccode\u003ethrow\u003c/code\u003e expression\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/copy_initialization\"\u003eCopy initialization\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhen \u003ccode\u003ethrow\u003c/code\u003e is followed by an expression, this expression will be used to create and initialize the exception object. In other words,\nthe exception object is \u003cem\u003ecopy-initialized\u003c/em\u003e from the expression.\u003c/p\u003e\n\u003cpre\u003e\ncatch (const std::exception\u0026amp; ex) {\n  // ...\n  throw ex; // \"throw\" copy-initializes the exception object from \"ex\"\n}\n\u003c/pre\u003e\n\u003cp\u003eRethrowing an unmodified copy of the caught exception is a bad practice because:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The exception already exists, so it is better to reuse it instead of creating a new one and wasting resources. \u003c/li\u003e\n  \u003cli\u003e The copy will be an instance of the exception base class rather than the potentially more specific exception class initially caught. So it may\n  lead to a loss of precision. \u003c/li\u003e\n\u003c/ul\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eThe rule raises an issue when the argument of the \u003ccode\u003ethrow\u003c/code\u003e expression is an unmodified copy of the caught exception.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\ntry {\n  throw std::invalid_argument(\"x\");\n} catch (const std::exception\u0026amp; ex) {\n  // ...\n  throw ex; // Noncompliant: the received \"std::invalid_argument\" exception is copied into a less specialized class \"std::exception\"\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\ntry {\n  throw std::invalid_argument(\"x\");\n} catch (const std::exception\u0026amp; ex) {\n  // ...\n  throw; // Compliant: rethrows the initial \"std::invalid_argument\" exception\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/throw\"\u003e\u003ccode\u003ethrow\u003c/code\u003e expression\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/copy_initialization\"\u003eCopy initialization\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5912",
    "name": "Objects should not be sliced",
    "defaultSeverity": "BLOCKER",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eSlicing happens when an object from a derived type is cast to an object of one of its base classes. When this happens, the new object will not have\nthe data member variables specific to the derived type.\u003c/p\u003e\n\u003cp\u003eThe following example illustrates the unintended loss of information.\u003c/p\u003e\n\u003cpre\u003e\nstruct PartData {\n  int uuid;\n  std::string manufacturer;\n};\n\n// Use inheritance to share common data definitions.\nstruct TireData : PartData {\n  Color color;\n  TireType type;\n};\n\nvoid orderBike(TireData tire, ...) {\n  std::vector\u0026lt;PartData\u0026gt; parts;\n\n  // Noncompliant: the vector does not store the tire color and type.\n  parts.push_back(tire);\n\n  // ...\n}\n\u003c/pre\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eThis code defect usually results from using values instead of references or pointers to pass polymorphic objects to functions.\u003c/p\u003e\n\u003cp\u003eIt is usually a good idea to design a base class so that slicing cannot happen: it can be abstract or non-copiable. The standard library follows\nthis practice and prevents copying, for example, \u003ccode\u003estd::ostream\u003c/code\u003e objects.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cp\u003eThis example illustrates the problem with a \u003ccode\u003eFileStream\u003c/code\u003e concrete class and a derived buffered implementation,\n\u003ccode\u003eBufferedFileStream\u003c/code\u003e.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nclass FileStream {\n  // ...\n\npublic:\n  FileStream(std::string_view file_path);\n  virtual ~Stream() \u003d default;\n  virtual void write(int x);\n};\n\nclass BufferedFileStream : public FileStream {\n  std::array\u0026lt;char, 1024\u0026gt; buffer;\n  // ...\n\npublic:\n  BufferedFileStream(std::string_view file_path);\n  ~BufferedFileStream() { flushBuffer(); }\n  void write(int x) {\n    // Write to the buffer; flush if it is full.\n    // ...\n  }\n};\n\nvoid writeAll(FileStream stream, std::vector\u0026lt;int\u0026gt; const\u0026amp; ints);\n\nvoid application(int userId) {\n  BufferedFileStream stream;\n  stream.write(userId);\n\n  std::vector\u0026lt;int\u0026gt; data \u003d getData();\n\n  writeAll(stream, data); // Noncompliant: stream is sliced, and its buffer may be lost or written out-of-sequence\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eTo prevent slicing from happening, the base class can be made non-copyable. This implies passing a reference instead of a copy to\n\u003ccode\u003ewriteAll\u003c/code\u003e.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nclass FileStream {\n  // ...\n\npublic:\n  FileStream(std::string_view file_path);\n  FileStream(FileStream const\u0026amp;) \u003d delete;\n  virtual ~Stream() \u003d default;\n  virtual void write(int x);\n};\n\nclass BufferedFileStream : public FileStream {\n  std::array\u0026lt;char, 1024\u0026gt; buffer;\n  // ...\n\npublic:\n  BufferedFileStream(std::string_view file_path);\n  ~BufferedFileStream() { flushBuffer(); }\n  void write(int x) {\n    // Write to the buffer; flush if it is full.\n    // ...\n  }\n};\n\nvoid writeAll(FileStream\u0026amp; stream, std::vector\u0026lt;int\u0026gt; const\u0026amp; ints);\n\nvoid application(int userId) {\n  BufferedFileStream stream;\n  stream.write(userId);\n\n  std::vector\u0026lt;int\u0026gt; data \u003d getData();\n\n  writeAll(stream, data); // Compliant, no slicing, no dataloss.\n}\n\u003c/pre\u003e\n\u003ch3\u003eGoing the extra mile\u003c/h3\u003e\n\u003cp\u003eWhen slicing is actually required, it is best to make it explicit to avoid the element of surprise. You can create a dedicated member function for\nthis purpose, with its own documentation. This goes well in hand with non-copyable classes.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es63-dont-slice\"\u003eES.63: Don’t\n  slice\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eSlicing happens when an object from a derived type is cast to an object of one of its base classes. When this happens, the new object will not have\nthe data member variables specific to the derived type.\u003c/p\u003e\n\u003cp\u003eThe following example illustrates the unintended loss of information.\u003c/p\u003e\n\u003cpre\u003e\nstruct PartData {\n  int uuid;\n  std::string manufacturer;\n};\n\n// Use inheritance to share common data definitions.\nstruct TireData : PartData {\n  Color color;\n  TireType type;\n};\n\nvoid orderBike(TireData tire, ...) {\n  std::vector\u0026lt;PartData\u0026gt; parts;\n\n  // Noncompliant: the vector does not store the tire color and type.\n  parts.push_back(tire);\n\n  // ...\n}\n\u003c/pre\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eThis code defect usually results from using values instead of references or pointers to pass polymorphic objects to functions.\u003c/p\u003e\n\u003cp\u003eIt is usually a good idea to design a base class so that slicing cannot happen: it can be abstract or non-copiable. The standard library follows\nthis practice and prevents copying, for example, \u003ccode\u003estd::ostream\u003c/code\u003e objects.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cp\u003eThis example illustrates the problem with a \u003ccode\u003eFileStream\u003c/code\u003e concrete class and a derived buffered implementation,\n\u003ccode\u003eBufferedFileStream\u003c/code\u003e.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nclass FileStream {\n  // ...\n\npublic:\n  FileStream(std::string_view file_path);\n  virtual ~Stream() \u003d default;\n  virtual void write(int x);\n};\n\nclass BufferedFileStream : public FileStream {\n  std::array\u0026lt;char, 1024\u0026gt; buffer;\n  // ...\n\npublic:\n  BufferedFileStream(std::string_view file_path);\n  ~BufferedFileStream() { flushBuffer(); }\n  void write(int x) {\n    // Write to the buffer; flush if it is full.\n    // ...\n  }\n};\n\nvoid writeAll(FileStream stream, std::vector\u0026lt;int\u0026gt; const\u0026amp; ints);\n\nvoid application(int userId) {\n  BufferedFileStream stream;\n  stream.write(userId);\n\n  std::vector\u0026lt;int\u0026gt; data \u003d getData();\n\n  writeAll(stream, data); // Noncompliant: stream is sliced, and its buffer may be lost or written out-of-sequence\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eTo prevent slicing from happening, the base class can be made non-copyable. This implies passing a reference instead of a copy to\n\u003ccode\u003ewriteAll\u003c/code\u003e.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nclass FileStream {\n  // ...\n\npublic:\n  FileStream(std::string_view file_path);\n  FileStream(FileStream const\u0026amp;) \u003d delete;\n  virtual ~Stream() \u003d default;\n  virtual void write(int x);\n};\n\nclass BufferedFileStream : public FileStream {\n  std::array\u0026lt;char, 1024\u0026gt; buffer;\n  // ...\n\npublic:\n  BufferedFileStream(std::string_view file_path);\n  ~BufferedFileStream() { flushBuffer(); }\n  void write(int x) {\n    // Write to the buffer; flush if it is full.\n    // ...\n  }\n};\n\nvoid writeAll(FileStream\u0026amp; stream, std::vector\u0026lt;int\u0026gt; const\u0026amp; ints);\n\nvoid application(int userId) {\n  BufferedFileStream stream;\n  stream.write(userId);\n\n  std::vector\u0026lt;int\u0026gt; data \u003d getData();\n\n  writeAll(stream, data); // Compliant, no slicing, no dataloss.\n}\n\u003c/pre\u003e\n\u003ch3\u003eGoing the extra mile\u003c/h3\u003e\n\u003cp\u003eWhen slicing is actually required, it is best to make it explicit to avoid the element of surprise. You can create a dedicated member function for\nthis purpose, with its own documentation. This goes well in hand with non-copyable classes.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es63-dont-slice\"\u003eES.63: Don’t\n  slice\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cppcoreguidelines"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S2761",
    "name": "Unary prefix operators should not be repeated",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe repetition of a unary operator is usually a typo. The second operator invalidates the first one in most cases:\u003c/p\u003e\n\u003cpre\u003e\nint i \u003d 1;\n\nint j \u003d - - -i;  // Noncompliant: equivalent to \"-i\"\nint k \u003d ~~i;     // Noncompliant: equivalent to \"i\"\n\nbool b \u003d false;\nbool c \u003d !!!b;   // Noncompliant: equivalent to \"!b\"\n\u003c/pre\u003e\n\u003cp\u003eOn the other hand, while repeating the increment and decrement operators is technically correct, it obfuscates the meaning:\u003c/p\u003e\n\u003cpre\u003e\nint i \u003d 1;\nint j \u003d ++ ++i;  // Noncompliant\nint k \u003d ----i; // Noncompliant\n\u003c/pre\u003e\n\u003cp\u003eUsing \u003ccode\u003e+\u003d\u003c/code\u003e or \u003ccode\u003e-\u003d\u003c/code\u003e improves readability:\u003c/p\u003e\n\u003cpre\u003e\nint i \u003d 1;\ni +\u003d 2;\nint j \u003d i;\ni -\u003d2;\nint k \u003d i;\n\u003c/pre\u003e\n\u003cp\u003eThis rule raises an issue for repetitions of:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003e!\u003c/code\u003e, \u003ccode\u003e~\u003c/code\u003e, \u003ccode\u003e-\u003c/code\u003e, and \u003ccode\u003e+\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e the increment \u003ccode\u003e++\u003c/code\u003e and decrement \u003ccode\u003e- -\u003c/code\u003e operators in C++ \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThe rule ignores boolean normalization \u003ccode\u003e!!\u003c/code\u003e.\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe repetition of a unary operator is usually a typo. The second operator invalidates the first one in most cases:\u003c/p\u003e\n\u003cpre\u003e\nint i \u003d 1;\n\nint j \u003d - - -i;  // Noncompliant: equivalent to \"-i\"\nint k \u003d ~~i;     // Noncompliant: equivalent to \"i\"\n\nbool b \u003d false;\nbool c \u003d !!!b;   // Noncompliant: equivalent to \"!b\"\n\u003c/pre\u003e\n\u003cp\u003eOn the other hand, while repeating the increment and decrement operators is technically correct, it obfuscates the meaning:\u003c/p\u003e\n\u003cpre\u003e\nint i \u003d 1;\nint j \u003d ++ ++i;  // Noncompliant\nint k \u003d ----i; // Noncompliant\n\u003c/pre\u003e\n\u003cp\u003eUsing \u003ccode\u003e+\u003d\u003c/code\u003e or \u003ccode\u003e-\u003d\u003c/code\u003e improves readability:\u003c/p\u003e\n\u003cpre\u003e\nint i \u003d 1;\ni +\u003d 2;\nint j \u003d i;\ni -\u003d2;\nint k \u003d i;\n\u003c/pre\u003e\n\u003cp\u003eThis rule raises an issue for repetitions of:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003e!\u003c/code\u003e, \u003ccode\u003e~\u003c/code\u003e, \u003ccode\u003e-\u003c/code\u003e, and \u003ccode\u003e+\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e the increment \u003ccode\u003e++\u003c/code\u003e and decrement \u003ccode\u003e- -\u003c/code\u003e operators in C++ \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThe rule ignores boolean normalization \u003ccode\u003e!!\u003c/code\u003e.\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S3731",
    "name": "\"auto\" should not be used as a storage class specifier",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eBefore C++11, \u003ccode\u003eauto\u003c/code\u003e was used as a storage class specifier that indicated automatic duration. Since that’s the default, the use of\n\u003ccode\u003eauto\u003c/code\u003e in that context was wholly redundant.\u003c/p\u003e\n\u003cp\u003eBecause the keyword was redundant and therefore rarely used, C++11 repurposes it. \u003ccode\u003eauto\u003c/code\u003e is now used to specify that the type of the\nvariable or function should be deduced from its context.\u003c/p\u003e\n\u003cp\u003eSince it is redundant under older standards and problematic under C++11, \u003ccode\u003eauto\u003c/code\u003e\u0027s use as a storage-class identifier should be\nremoved.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nauto int x; // Noncompliant: redundant before C++11, error as of C++11\n\nauto int y;  // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint x;\n\nauto y \u003d 1 + 2; // C++11: type of \u0027y\u0027 will be inferred\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eBefore C++11, \u003ccode\u003eauto\u003c/code\u003e was used as a storage class specifier that indicated automatic duration. Since that’s the default, the use of\n\u003ccode\u003eauto\u003c/code\u003e in that context was wholly redundant.\u003c/p\u003e\n\u003cp\u003eBecause the keyword was redundant and therefore rarely used, C++11 repurposes it. \u003ccode\u003eauto\u003c/code\u003e is now used to specify that the type of the\nvariable or function should be deduced from its context.\u003c/p\u003e\n\u003cp\u003eSince it is redundant under older standards and problematic under C++11, \u003ccode\u003eauto\u003c/code\u003e\u0027s use as a storage-class identifier should be\nremoved.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nauto int x; // Noncompliant: redundant before C++11, error as of C++11\n\nauto int y;  // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint x;\n\nauto y \u003d 1 + 2; // C++11: type of \u0027y\u0027 will be inferred\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "lock-in"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S3973",
    "name": "A conditionally executed single line should be denoted by indentation",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "FORMATTED",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhen the line immediately after a conditional has neither curly braces nor indentation, the intent of the code is unclear and perhaps not what is\nexecuted. Additionally, such code is confusing to maintainers.\u003c/p\u003e\n\u003cpre\u003e\nif (condition)  // Noncompliant\ndoTheThing();\ndoTheOtherThing(); // Was the intent to call this function unconditionally?\n\u003c/pre\u003e\n\u003cp\u003eIt becomes even more confusing and bug-prone if lines get commented out.\u003c/p\u003e\n\u003cpre\u003e\nif (condition)  // Noncompliant\n//  doTheThing();\ndoTheOtherThing(); // Was the intent to call this function conditionally?\n\u003c/pre\u003e\n\u003cp\u003eIndentation alone or together with curly braces makes the intent clear.\u003c/p\u003e\n\u003cpre\u003e\nif (condition)\n  doTheThing();\ndoTheOtherThing(); // Clear intent to call this function unconditionally\n\n// or\n\nif (condition) {\n  doTheThing();\n}\ndoTheOtherThing(); // Clear intent to call this function unconditionally\n\u003c/pre\u003e\n\u003cp\u003eThis rule raises an issue if the line controlled by a conditional has the same indentation as the conditional and is not enclosed in curly\nbraces.\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhen the line immediately after a conditional has neither curly braces nor indentation, the intent of the code is unclear and perhaps not what is\nexecuted. Additionally, such code is confusing to maintainers.\u003c/p\u003e\n\u003cpre\u003e\nif (condition)  // Noncompliant\ndoTheThing();\ndoTheOtherThing(); // Was the intent to call this function unconditionally?\n\u003c/pre\u003e\n\u003cp\u003eIt becomes even more confusing and bug-prone if lines get commented out.\u003c/p\u003e\n\u003cpre\u003e\nif (condition)  // Noncompliant\n//  doTheThing();\ndoTheOtherThing(); // Was the intent to call this function conditionally?\n\u003c/pre\u003e\n\u003cp\u003eIndentation alone or together with curly braces makes the intent clear.\u003c/p\u003e\n\u003cpre\u003e\nif (condition)\n  doTheThing();\ndoTheOtherThing(); // Clear intent to call this function unconditionally\n\n// or\n\nif (condition) {\n  doTheThing();\n}\ndoTheOtherThing(); // Clear intent to call this function unconditionally\n\u003c/pre\u003e\n\u003cp\u003eThis rule raises an issue if the line controlled by a conditional has the same indentation as the conditional and is not enclosed in curly\nbraces.\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "confusing",
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S3730",
    "name": "\"#include_next\" should not be used",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003e#include_next\u003c/code\u003e is a gcc-specific language extension that alters the search path for the specified header file by starting the search\nfrom the header file directory \u003cem\u003eafter\u003c/em\u003e the one in which the directive was encountered. It also ignores the distinction between\n\u003ccode\u003e\"file\"\u003c/code\u003e and \u003ccode\u003e\u0026lt;file\u0026gt;\u003c/code\u003e. It is typically used when you have two (probably related) header files with the same name, although\nthere is nothing in the extension to enforce or limit the use to same-name files.\u003c/p\u003e\n\u003cp\u003eUse of this extension can be tricky to get right, and is almost never justified. Instead, you should use an absolute path in the\n\u003ccode\u003e#include\u003c/code\u003e statement or rename one of the files.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include_next \"foo.h\" // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#include \"/usr/local/include/foo.h\"\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003ccode\u003e#include_next\u003c/code\u003e is a gcc-specific language extension that alters the search path for the specified header file by starting the search\nfrom the header file directory \u003cem\u003eafter\u003c/em\u003e the one in which the directive was encountered. It also ignores the distinction between\n\u003ccode\u003e\"file\"\u003c/code\u003e and \u003ccode\u003e\u0026lt;file\u0026gt;\u003c/code\u003e. It is typically used when you have two (probably related) header files with the same name, although\nthere is nothing in the extension to enforce or limit the use to same-name files.\u003c/p\u003e\n\u003cp\u003eUse of this extension can be tricky to get right, and is almost never justified. Instead, you should use an absolute path in the\n\u003ccode\u003e#include\u003c/code\u003e statement or rename one of the files.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include_next \"foo.h\" // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#include \"/usr/local/include/foo.h\"\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "confusing",
      "lock-in"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S3972",
    "name": "Conditionals should start on new lines",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "FORMATTED",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003ePlacing an \u003ccode\u003eif\u003c/code\u003e statement on the same line as the closing \u003ccode\u003e}\u003c/code\u003e from a preceding \u003ccode\u003eif\u003c/code\u003e, \u003ccode\u003eelse\u003c/code\u003e, or\n\u003ccode\u003eelse if\u003c/code\u003e block can lead to confusion and potential errors. It may indicate a missing \u003ccode\u003eelse\u003c/code\u003e statement or create ambiguity for\nmaintainers who might fail to understand that the two statements are unconnected.\u003c/p\u003e\n\u003cp\u003eThe following code snippet is confusing:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nif (condition1) {\n  // ...\n} if (condition2) {  // Noncompliant\n  //...\n}\n\u003c/pre\u003e\n\u003cp\u003eEither the two conditions are unrelated and they should be visually separated:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nif (condition1) {\n  // ...\n}\n\nif (condition2) {\n  //...\n}\n\u003c/pre\u003e\n\u003cp\u003eOr they were supposed to be exclusive and you should use \u003ccode\u003eelse if\u003c/code\u003e instead:\u003c/p\u003e\n\u003cpre\u003e\nif (condition1) {\n  // ...\n} else if (condition2) {\n  //...\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003ePlacing an \u003ccode\u003eif\u003c/code\u003e statement on the same line as the closing \u003ccode\u003e}\u003c/code\u003e from a preceding \u003ccode\u003eif\u003c/code\u003e, \u003ccode\u003eelse\u003c/code\u003e, or\n\u003ccode\u003eelse if\u003c/code\u003e block can lead to confusion and potential errors. It may indicate a missing \u003ccode\u003eelse\u003c/code\u003e statement or create ambiguity for\nmaintainers who might fail to understand that the two statements are unconnected.\u003c/p\u003e\n\u003cp\u003eThe following code snippet is confusing:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nif (condition1) {\n  // ...\n} if (condition2) {  // Noncompliant\n  //...\n}\n\u003c/pre\u003e\n\u003cp\u003eEither the two conditions are unrelated and they should be visually separated:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nif (condition1) {\n  // ...\n}\n\nif (condition2) {\n  //...\n}\n\u003c/pre\u003e\n\u003cp\u003eOr they were supposed to be exclusive and you should use \u003ccode\u003eelse if\u003c/code\u003e instead:\u003c/p\u003e\n\u003cpre\u003e\nif (condition1) {\n  // ...\n} else if (condition2) {\n  //...\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1313",
    "name": "Using hardcoded IP addresses is security-sensitive",
    "defaultSeverity": "MINOR",
    "type": "SECURITY_HOTSPOT",
    "cleanCodeAttribute": "TRUSTWORTHY",
    "defaultImpacts": {
      "SECURITY": "LOW"
    },
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eHardcoding IP addresses is security-sensitive. It has led in the past to the following vulnerabilities:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"http://cve.mitre.org/cgi-bin/cvename.cgi?name\u003dCVE-2006-5901\"\u003eCVE-2006-5901\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"http://cve.mitre.org/cgi-bin/cvename.cgi?name\u003dCVE-2005-3725\"\u003eCVE-2005-3725\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eToday’s services have an ever-changing architecture due to their scaling and redundancy needs. It is a mistake to think that a service will always\nhave the same IP address. When it does change, the hardcoded IP will have to be modified too. This will have an impact on the product development,\ndelivery, and deployment:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The developers will have to do a rapid fix every time this happens, instead of having an operation team change a configuration file. \u003c/li\u003e\n  \u003cli\u003e It misleads to use the same address in every environment (dev, sys, qa, prod). \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eLast but not least it has an effect on application security. Attackers might be able to decompile the code and thereby discover a potentially\nsensitive address. They can perform a Denial of Service attack on the service, try to get access to the system, or try to spoof the IP address to\nbypass security checks. Such attacks can always be possible, but in the case of a hardcoded IP address solving the issue will take more time, which\nwill increase an attack’s impact.\u003c/p\u003e\n\u003ch2\u003eExceptions\u003c/h2\u003e\n\u003cp\u003eNo issue is reported for the following cases because they are not considered sensitive:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Loopback addresses 127.0.0.0/8 in CIDR notation (from 127.0.0.0 to 127.255.255.255) \u003c/li\u003e\n  \u003cli\u003e Broadcast address 255.255.255.255 \u003c/li\u003e\n  \u003cli\u003e Non-routable address 0.0.0.0 \u003c/li\u003e\n  \u003cli\u003e Strings of the form \u003ccode\u003e2.5.\u0026lt;number\u0026gt;.\u0026lt;number\u0026gt;\u003c/code\u003e as they \u003ca href\u003d\"http://www.oid-info.com/introduction.htm\"\u003eoften match\n  Object Identifiers\u003c/a\u003e (OID) \u003c/li\u003e\n  \u003cli\u003e Addresses in the ranges 192.0.2.0/24, 198.51.100.0/24, 203.0.113.0/24, reserved for documentation purposes by \u003ca\n  href\u003d\"https://datatracker.ietf.org/doc/html/rfc5737\"\u003eRFC 5737\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e Addresses in the range 2001:db8::/32, reserved for documentation purposes by \u003ca href\u003d\"https://datatracker.ietf.org/doc/html/rfc3849\"\u003eRFC\n  3849\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      },
      {
        "key": "assess_the_problem",
        "htmlContent": "\u003ch2\u003eAsk Yourself Whether\u003c/h2\u003e\n\u003cp\u003eThe disclosed IP address is sensitive, e.g.:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Can give information to an attacker about the network topology. \u003c/li\u003e\n  \u003cli\u003e It’s a personal (assigned to an identifiable person) IP address. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere is a risk if you answered yes to any of these questions.\u003c/p\u003e\n\u003ch2\u003eSensitive Code Example\u003c/h2\u003e\n\u003cpre\u003e\ndbi_conn conn \u003d dbi_conn_new(\"mysql\");\nstring host \u003d \"10.10.0.1\"; // Sensitive\ndbi_conn_set_option(conn, \"host\", host.c_str());\ndbi_conn_set_option(conn, \"host\", \"10.10.0.1\"); // Sensitive\n\u003c/pre\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003ch2\u003eRecommended Secure Coding Practices\u003c/h2\u003e\n\u003cp\u003eDon’t hard-code the IP address in the source code, instead make it configurable with environment variables, configuration files, or a similar\napproach. Alternatively, if confidentially is not required a domain name can be used since it allows to change the destination quickly without having\nto rebuild the software.\u003c/p\u003e\n\u003ch2\u003eCompliant Solution\u003c/h2\u003e\n\u003cpre\u003e\ndbi_conn conn \u003d dbi_conn_new(\"mysql\");\nstring host \u003d getDatabaseHost(); // Compliant\ndbi_conn_set_option(conn, \"host\", host.c_str()); // Compliant\n\u003c/pre\u003e\n\u003ch2\u003eSee\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/Top10/A01_2021-Broken_Access_Control/\"\u003eOWASP Top 10 2021 Category A1\u003c/a\u003e - Broken Access Control \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://www.owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\"\u003eOWASP Top 10 2017 Category A3\u003c/a\u003e - Sensitive Data\n  Exposure \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cert"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": [],
    "vulnerabilityProbability": "LOW"
  },
  {
    "key": "cpp:S3732",
    "name": "\u0027extern \"C\"\u0027 should not be used with namespaces",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe C linkage declaration \u003ccode\u003eextern \"C\"\u003c/code\u003e can not be combined with a namespace. In practical terms only one function with that name can be\ndeclared as \u003ccode\u003eextern \"C\"\u003c/code\u003e because the \u003ccode\u003enamespace\u003c/code\u003e is functionally ignored.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nnamespace ns1 {\n    extern \"C\" void doSomething();  // Noncompliant\n    // ...\n}\n\nextern \"C\" {\n  namespace ns2 {  // Noncompliant\n    // ...\n  }\n  // ...\n}\n\nns1::doSomething();\ndoSomething(); // Works too, same as above\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nextern \"C\" void doSomething();\n\nnamespace ns1 {\n  // ...\n}\n\nextern \"C\" {\n  // ...\n}\n\nnamespace ns2 {  // Noncompliant\n  // ...\n}\n\ndoSomething();\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eextern \"C\"\u003c/code\u003e can prefix \u003ccode\u003etypedef\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\nnamespace ns1 {\n    extern \"C\" typedef void c_function();  // Compliant, type named \u0027c_function\u0027 exists only in \u0027ns1\u0027 and not in the global namespace\n    // ...\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe C linkage declaration \u003ccode\u003eextern \"C\"\u003c/code\u003e can not be combined with a namespace. In practical terms only one function with that name can be\ndeclared as \u003ccode\u003eextern \"C\"\u003c/code\u003e because the \u003ccode\u003enamespace\u003c/code\u003e is functionally ignored.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nnamespace ns1 {\n    extern \"C\" void doSomething();  // Noncompliant\n    // ...\n}\n\nextern \"C\" {\n  namespace ns2 {  // Noncompliant\n    // ...\n  }\n  // ...\n}\n\nns1::doSomething();\ndoSomething(); // Works too, same as above\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nextern \"C\" void doSomething();\n\nnamespace ns1 {\n  // ...\n}\n\nextern \"C\" {\n  // ...\n}\n\nnamespace ns2 {  // Noncompliant\n  // ...\n}\n\ndoSomething();\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eextern \"C\"\u003c/code\u003e can prefix \u003ccode\u003etypedef\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\nnamespace ns1 {\n    extern \"C\" typedef void c_function();  // Compliant, type named \u0027c_function\u0027 exists only in \u0027ns1\u0027 and not in the global namespace\n    // ...\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "confusing"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1227",
    "name": "break statements should not be used except for switch cases",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003ebreak;\u003c/code\u003e is an unstructured control flow statement which makes code harder to read.\u003c/p\u003e\n\u003cp\u003eIdeally, every loop should have a single termination condition.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nfor (element \u003d list.first; element !\u003d null; element \u003d element-\u0026gt;next) { // First termination condition\n  if (!matches(element-\u0026gt;value)) {                                      // Second termination condition\n    break; // Noncompliant\n  }\n\n  /* ... */\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n// Compliant\nfor (element \u003d list.first; element !\u003d null \u0026amp;\u0026amp; matches(element-\u0026gt;value); element \u003d element-\u0026gt;next) {\n  /* ... */\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003ccode\u003ebreak;\u003c/code\u003e is an unstructured control flow statement which makes code harder to read.\u003c/p\u003e\n\u003cp\u003eIdeally, every loop should have a single termination condition.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nfor (element \u003d list.first; element !\u003d null; element \u003d element-\u0026gt;next) { // First termination condition\n  if (!matches(element-\u0026gt;value)) {                                      // Second termination condition\n    break; // Noncompliant\n  }\n\n  /* ... */\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n// Compliant\nfor (element \u003d list.first; element !\u003d null \u0026amp;\u0026amp; matches(element-\u0026gt;value); element \u003d element-\u0026gt;next) {\n  /* ... */\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S3646",
    "name": "Types and variables should be declared in separate statements",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "FOCUSED",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eIt is possible in the same statement, to declare a user-defined type (\u003ccode\u003eclass\u003c/code\u003e, \u003ccode\u003estruct\u003c/code\u003e, \u003ccode\u003eunion\u003c/code\u003e or\n\u003ccode\u003eenum\u003c/code\u003e) followed by variable declarations of this type. But mixing more than one concern in a single statement is confusing for\nmaintainers.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when a variable is declared at the end of a user-defined type declaration statement.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstruct Container { int size; } container; // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstruct Container { int size; };\nContainer container;\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c7-dont-define-a-class-or-enum-and-declare-a-variable-of-its-type-in-the-same-statement\"\u003eC.7: Don’t define a class or enum and declare a variable of its type in the same statement\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eIt is possible in the same statement, to declare a user-defined type (\u003ccode\u003eclass\u003c/code\u003e, \u003ccode\u003estruct\u003c/code\u003e, \u003ccode\u003eunion\u003c/code\u003e or\n\u003ccode\u003eenum\u003c/code\u003e) followed by variable declarations of this type. But mixing more than one concern in a single statement is confusing for\nmaintainers.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when a variable is declared at the end of a user-defined type declaration statement.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstruct Container { int size; } container; // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstruct Container { int size; };\nContainer container;\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c7-dont-define-a-class-or-enum-and-declare-a-variable-of-its-type-in-the-same-statement\"\u003eC.7: Don’t define a class or enum and declare a variable of its type in the same statement\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "confusing",
      "cppcoreguidelines"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5827",
    "name": "\"auto\" should be used to avoid repetition of types",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhen used as a type specifier in a declaration, \u003ccode\u003eauto\u003c/code\u003e allows the compiler to deduce the type of a variable based on the type of the\ninitialization expression.\u003c/p\u003e\n\u003cp\u003eWhen the spelling of the initialization expression already contains the type of the declared variable, it leaves no ambiguity and \u003ccode\u003eauto\u003c/code\u003e\nshould be used as it makes the code easier to read and reduces duplication. This includes:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Initializations using \u003ccode\u003enew\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\nvoid f() {\n  LongAndBoringClassName *avoid \u003d new LongAndBoringClassName(); // Noncompliant\n\n  auto prefer \u003d new LongAndBoringClassName(); // Compliant\n}\n\u003c/pre\u003e\n\u003cul\u003e\n  \u003cli\u003e Template factory functions for smart pointers \u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\nvoid f() {\n  std::unique_ptr\u0026lt;LongAndBoringClassName\u0026gt; avoid \u003d std::make_unique\u0026lt;LongAndBoringClassName\u0026gt;(); // Noncompliant\n  auto prefer \u003d std::make_unique\u0026lt;LongAndBoringClassName\u0026gt;(); // Compliant\n}\n\u003c/pre\u003e\n\u003cul\u003e\n  \u003cli\u003e Cast expressions \u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\nvoid f() {\n  C *c \u003d new LongAndBoringClassName(); // Compliant\n\n  LongAndBoringClassName *avoid \u003d static_cast\u0026lt;LongAndBoringClassName*\u0026gt;(c); // Noncompliant\n\n  auto prefer \u003d static_cast\u0026lt;LongAndBoringClassName*\u0026gt;(c); // Compliant\n}\n\u003c/pre\u003e\n\u003cp\u003eThe rule {rule:cpp:S6234} detects other situations where \u003ccode\u003eauto\u003c/code\u003e can improve readability.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es11-use-auto-to-avoid-redundant-repetition-of-type-names\"\u003eES.11: Use \u003ccode\u003eauto\u003c/code\u003e to avoid redundant repetition of type names\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S6234} - \"auto\" should be used to store a result of functions that conventionally return an iterator or a range \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhen used as a type specifier in a declaration, \u003ccode\u003eauto\u003c/code\u003e allows the compiler to deduce the type of a variable based on the type of the\ninitialization expression.\u003c/p\u003e\n\u003cp\u003eWhen the spelling of the initialization expression already contains the type of the declared variable, it leaves no ambiguity and \u003ccode\u003eauto\u003c/code\u003e\nshould be used as it makes the code easier to read and reduces duplication. This includes:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Initializations using \u003ccode\u003enew\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\nvoid f() {\n  LongAndBoringClassName *avoid \u003d new LongAndBoringClassName(); // Noncompliant\n\n  auto prefer \u003d new LongAndBoringClassName(); // Compliant\n}\n\u003c/pre\u003e\n\u003cul\u003e\n  \u003cli\u003e Template factory functions for smart pointers \u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\nvoid f() {\n  std::unique_ptr\u0026lt;LongAndBoringClassName\u0026gt; avoid \u003d std::make_unique\u0026lt;LongAndBoringClassName\u0026gt;(); // Noncompliant\n  auto prefer \u003d std::make_unique\u0026lt;LongAndBoringClassName\u0026gt;(); // Compliant\n}\n\u003c/pre\u003e\n\u003cul\u003e\n  \u003cli\u003e Cast expressions \u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\nvoid f() {\n  C *c \u003d new LongAndBoringClassName(); // Compliant\n\n  LongAndBoringClassName *avoid \u003d static_cast\u0026lt;LongAndBoringClassName*\u0026gt;(c); // Noncompliant\n\n  auto prefer \u003d static_cast\u0026lt;LongAndBoringClassName*\u0026gt;(c); // Compliant\n}\n\u003c/pre\u003e\n\u003cp\u003eThe rule {rule:cpp:S6234} detects other situations where \u003ccode\u003eauto\u003c/code\u003e can improve readability.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es11-use-auto-to-avoid-redundant-repetition-of-type-names\"\u003eES.11: Use \u003ccode\u003eauto\u003c/code\u003e to avoid redundant repetition of type names\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S6234} - \"auto\" should be used to store a result of functions that conventionally return an iterator or a range \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "clumsy",
      "cppcoreguidelines",
      "since-c++11"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5824",
    "name": "Using \"tmpnam\", \"tmpnam_s\" or \"tmpnam_r\" is security-sensitive",
    "defaultSeverity": "CRITICAL",
    "type": "SECURITY_HOTSPOT",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "SECURITY": "HIGH"
    },
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe functions \"tmpnam\", \"tmpnam_s\" and \"tmpnam_r\" are all used to return a file name that does not match an existing file, in order for the\napplication to create a temporary file. However, even if the file did not exist at the time those functions were called, it might exist by the time\nthe application tries to use the file name to create the files. This has been used by hackers to gain access to files that the application believed\nwere trustworthy.\u003c/p\u003e\n\u003cp\u003eThere are alternative functions that, in addition to creating a suitable file name, create and open the file and return the file handler. Such\nfunctions are protected from this attack vector and should be preferred. About the only reason to use these functions would be to create a temporary\nfolder, not a temporary file.\u003c/p\u003e\n\u003cp\u003eAdditionally, these functions might not be thread-safe, and if you don’t provide them buffers of sufficient size, you will have a buffer\noverflow.\u003c/p\u003e"
      },
      {
        "key": "assess_the_problem",
        "htmlContent": "\u003ch2\u003eAsk Yourself Whether\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e There is a possibility that several threads call any of these functions simultaneously \u003c/li\u003e\n  \u003cli\u003e There is a possibility that the resulting file is opened without forcing its creation, meaning that it might have unexpected access rights\n  \u003c/li\u003e\n  \u003cli\u003e The buffers passed to these functions are respectively smaller than\n    \u003cul\u003e\n      \u003cli\u003e \u003ccode\u003eL_tmpnam\u003c/code\u003e for \u003ccode\u003etmpnam\u003c/code\u003e \u003c/li\u003e\n      \u003cli\u003e \u003ccode\u003eL_tmpnam_s\u003c/code\u003e for \u003ccode\u003etmpnam_s\u003c/code\u003e \u003c/li\u003e\n      \u003cli\u003e \u003ccode\u003eL_tmpnam\u003c/code\u003e for \u003ccode\u003etmpnam_r\u003c/code\u003e \u003c/li\u003e\n    \u003c/ul\u003e  \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere is a risk if you answered yes to any of those questions.\u003c/p\u003e\n\u003ch2\u003eSensitive Code Example\u003c/h2\u003e\n\u003cpre\u003e\nint f(char *tempData) {\n  char *path \u003d tmpnam(NULL); // Sensitive\n  FILE* f \u003d fopen(tmpnam, \"w\");\n  fputs(tempData, f);\n  fclose(f);\n}\n\u003c/pre\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003ch2\u003eRecommended Secure Coding Practices\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e Use a function that directly opens the temporary file, such a \u003ccode\u003etmpfile\u003c/code\u003e, \u003ccode\u003etmpfile_s\u003c/code\u003e, \u003ccode\u003emkstemp\u003c/code\u003e or\n  \u003ccode\u003emkstemps\u003c/code\u003e (the last two allow more accurate control of the file name). \u003c/li\u003e\n  \u003cli\u003e If you can’t get rid of these functions, when using the generated name to open the file, use a function that forces the creation of the file\n  and fails if the file already exists. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eCompliant Solution\u003c/h2\u003e\n\u003cpre\u003e\nint f(char *tempData) {\n  // The file will be opened in \"wb+\" mode, and will be automatically removed on normal program exit\n  FILE* f \u003d tmpfile(); // Compliant\n  fputs(tempData, f);\n  fclose(f);\n}\n\u003c/pre\u003e\n\u003ch2\u003eSee\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/Top10/A01_2021-Broken_Access_Control/\"\u003eOWASP Top 10 2021 Category A1\u003c/a\u003e - Broken Access Control \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/Top10/A06_2021-Vulnerable_and_Outdated_Components/\"\u003eOWASP Top 10 2021 Category A6\u003c/a\u003e - Vulnerable and Outdated\n  Components \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/www-project-top-ten/2017/A9_2017-Using_Components_with_Known_Vulnerabilities\"\u003eOWASP Top 10 2017 Category A9\u003c/a\u003e -\n  Using Components with Known Vulnerabilities \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/377\"\u003eMITRE, CWE-377\u003c/a\u003e - Insecure Temporary File \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/display/c/CON33-C.+Avoid+race+conditions+when+using+library+functions\"\u003eCERT, CON33-C.\u003c/a\u003e - Avoid\n  race conditions when using library functions \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/display/c/FIO21-C.+Do+not+create+temporary+files+in+shared+directories\"\u003eCERT, FIO21-C.\u003c/a\u003e - Do\n  not create temporary files in shared directories \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cert",
      "cwe"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": [],
    "vulnerabilityProbability": "LOW"
  },
  {
    "key": "cpp:S5945",
    "name": "C-style array should not be used",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eC-style arrays (such as \u003ccode\u003eint i[10]\u003c/code\u003e) are not very convenient to use:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e They are fixed size (even C Variable Length Arrays are not truly variable size, and they are not supported in C++) \u003c/li\u003e\n  \u003cli\u003e If the number of elements in the array can vary, it will lead to manual memory allocation (or people will use fixed-size arrays that \"should be\n  large enough\", which is both a waste of memory and a limitation of the program) \u003c/li\u003e\n  \u003cli\u003e It is very easy to lose the size of the array since an array passed to a function decays into a pointer \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe C++ standard library proposes two types that are better than C-style arrays and together cover all the use cases of C-style arrays:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e For fixed-size arrays, where the memory is on the stack, use \u003ccode\u003estd::array\u003c/code\u003e. It is like a C-style array, except that it has normal\n  argument passing semantics, and the size is always a part of the type. You can roll your version if \u003ccode\u003estd::array\u003c/code\u003e is unavailable to you\n  (before C++11). \u003c/li\u003e\n  \u003cli\u003e For variable-size arrays, use \u003ccode\u003estd::vector\u003c/code\u003e. It can be resized and handles memory allocation transparently. \u003c/li\u003e\n  \u003cli\u003e For character strings, you should use \u003ccode\u003estd::string\u003c/code\u003e instead of arrays of characters. \u003c/li\u003e\n  \u003cli\u003e For arrays of characters that are not strings (e.g., alphabet, exit codes, keyboard control list), prefer \u003ccode\u003estd::array\u003c/code\u003e or\n  \u003ccode\u003estd::vector\u003c/code\u003e as per the first two bullets. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe rule {rule:cpp:S945} is related to this rule but focuses on passing arguments of an array type. {rule:cpp:S5025} will flag the use of dynamic\nmemory allocation that could be replaced by \u003ccode\u003estd::vector\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid f() {\n  int a[10]; // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid f() {\n  std::array\u0026lt;int, 10\u0026gt; a1; // If the size really is a constant\n  // Or\n  std::vector\u0026lt;int\u0026gt;a2; // For variable size\n\n  auto s \u003d \"Hello!\"; // Compliant by exception\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThis rule will not report the use of C-style arrays in \u003ccode\u003eextern \"C\"\u003c/code\u003e code (since those arrays are often required here for compatibility\nwith external code) and in the arguments of \u003ccode\u003emain\u003c/code\u003e.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#slcon1-prefer-using-stl-array-or-vector-instead-of-a-c-array\"\u003eSL.con.1: Prefer using STL \u003ccode\u003earray\u003c/code\u003e or \u003ccode\u003evector\u003c/code\u003e instead of a C array\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eC-style arrays (such as \u003ccode\u003eint i[10]\u003c/code\u003e) are not very convenient to use:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e They are fixed size (even C Variable Length Arrays are not truly variable size, and they are not supported in C++) \u003c/li\u003e\n  \u003cli\u003e If the number of elements in the array can vary, it will lead to manual memory allocation (or people will use fixed-size arrays that \"should be\n  large enough\", which is both a waste of memory and a limitation of the program) \u003c/li\u003e\n  \u003cli\u003e It is very easy to lose the size of the array since an array passed to a function decays into a pointer \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe C++ standard library proposes two types that are better than C-style arrays and together cover all the use cases of C-style arrays:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e For fixed-size arrays, where the memory is on the stack, use \u003ccode\u003estd::array\u003c/code\u003e. It is like a C-style array, except that it has normal\n  argument passing semantics, and the size is always a part of the type. You can roll your version if \u003ccode\u003estd::array\u003c/code\u003e is unavailable to you\n  (before C++11). \u003c/li\u003e\n  \u003cli\u003e For variable-size arrays, use \u003ccode\u003estd::vector\u003c/code\u003e. It can be resized and handles memory allocation transparently. \u003c/li\u003e\n  \u003cli\u003e For character strings, you should use \u003ccode\u003estd::string\u003c/code\u003e instead of arrays of characters. \u003c/li\u003e\n  \u003cli\u003e For arrays of characters that are not strings (e.g., alphabet, exit codes, keyboard control list), prefer \u003ccode\u003estd::array\u003c/code\u003e or\n  \u003ccode\u003estd::vector\u003c/code\u003e as per the first two bullets. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe rule {rule:cpp:S945} is related to this rule but focuses on passing arguments of an array type. {rule:cpp:S5025} will flag the use of dynamic\nmemory allocation that could be replaced by \u003ccode\u003estd::vector\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid f() {\n  int a[10]; // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid f() {\n  std::array\u0026lt;int, 10\u0026gt; a1; // If the size really is a constant\n  // Or\n  std::vector\u0026lt;int\u0026gt;a2; // For variable size\n\n  auto s \u003d \"Hello!\"; // Compliant by exception\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThis rule will not report the use of C-style arrays in \u003ccode\u003eextern \"C\"\u003c/code\u003e code (since those arrays are often required here for compatibility\nwith external code) and in the arguments of \u003ccode\u003emain\u003c/code\u003e.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#slcon1-prefer-using-stl-array-or-vector-instead-of-a-c-array\"\u003eSL.con.1: Prefer using STL \u003ccode\u003earray\u003c/code\u003e or \u003ccode\u003evector\u003c/code\u003e instead of a C array\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "bad-practice",
      "clumsy",
      "cppcoreguidelines"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5825",
    "name": "Macros should not be used as replacements for \"typedef\" and \"using\"",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eC provides a way of defining or aliasing a type through \u003ccode\u003etypedef\u003c/code\u003e. On top of it, C++ adds \u003ccode\u003eusing\u003c/code\u003e that can do the same and\nmore.\u003c/p\u003e\n\u003cp\u003eUsing a macro to define a type is inferior to the previous ways for two reasons:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e macros cannot be enclosed into scopes. Or at least, doing so is cumbersome and error-prone, as in that case, the macro needs to be defined and\n  undefined manually. \u003c/li\u003e\n  \u003cli\u003e macros are handled by the preprocessor and are not understood by the compiler. They can easily pollute the code in places where types are not\n  expected. \u003ccode\u003etypedef\u003c/code\u003e and \u003ccode\u003eusing\u003c/code\u003e are known to the compiler to define types and can be more strictly checked. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eAs a result, macros should not be used as a replacement for\u0026nbsp;\u003ccode\u003etypedef\u003c/code\u003e or \u003ccode\u003eusing\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#define UINT unsigned int  // Noncompliant\n#define INT int  // Noncompliant\nUINT uabs( INT i );\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\ntypedef unsigned int UINT;\ntypedef int INT;\nUINT uabs( INT i );\n\u003c/pre\u003e\n\u003cp\u003eor\u003c/p\u003e\n\u003cpre\u003e\nusing UINT \u003d unsigned int;\nusing INT \u003d int;\nUINT uabs( INT i );\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/typedef\"\u003etypedef specifier\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/type_alias\"\u003eType alias, alias template\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/display/c/PRE03-C.+Prefer+typedefs+to+defines+for+encoding+non-pointer+types\"\u003ePRE03-C.\n  Prefer typedefs to defines for encoding non-pointer types\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eC provides a way of defining or aliasing a type through \u003ccode\u003etypedef\u003c/code\u003e. On top of it, C++ adds \u003ccode\u003eusing\u003c/code\u003e that can do the same and\nmore.\u003c/p\u003e\n\u003cp\u003eUsing a macro to define a type is inferior to the previous ways for two reasons:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e macros cannot be enclosed into scopes. Or at least, doing so is cumbersome and error-prone, as in that case, the macro needs to be defined and\n  undefined manually. \u003c/li\u003e\n  \u003cli\u003e macros are handled by the preprocessor and are not understood by the compiler. They can easily pollute the code in places where types are not\n  expected. \u003ccode\u003etypedef\u003c/code\u003e and \u003ccode\u003eusing\u003c/code\u003e are known to the compiler to define types and can be more strictly checked. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eAs a result, macros should not be used as a replacement for\u0026nbsp;\u003ccode\u003etypedef\u003c/code\u003e or \u003ccode\u003eusing\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#define UINT unsigned int  // Noncompliant\n#define INT int  // Noncompliant\nUINT uabs( INT i );\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\ntypedef unsigned int UINT;\ntypedef int INT;\nUINT uabs( INT i );\n\u003c/pre\u003e\n\u003cp\u003eor\u003c/p\u003e\n\u003cpre\u003e\nusing UINT \u003d unsigned int;\nusing INT \u003d int;\nUINT uabs( INT i );\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/typedef\"\u003etypedef specifier\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/type_alias\"\u003eType alias, alias template\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/display/c/PRE03-C.+Prefer+typedefs+to+defines+for+encoding+non-pointer+types\"\u003ePRE03-C.\n  Prefer typedefs to defines for encoding non-pointer types\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "bad-practice",
      "cert",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5946",
    "name": "\"std::endl\" should not be used",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "EFFICIENT",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhen injecting \u003ccode\u003estd::endl\u003c/code\u003e into an output stream, two things happen:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e An end of line character \u003ccode\u003e\u0027\\n\u0027\u003c/code\u003e is added to the stream \u003c/li\u003e\n  \u003cli\u003e The stream is flushed \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn many situations, you don’t need the stream to be flushed: It takes some time, and additionally, the stream is also flushed automatically in\nseveral circumstances:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e When the stream is closed \u003c/li\u003e\n  \u003cli\u003e In the case of \u003ccode\u003estd::cout\u003c/code\u003e, each time an input is read on \u003ccode\u003estd::cin\u003c/code\u003e or an output is written on \u003ccode\u003estd::cerr\u003c/code\u003e\n  \u003c/li\u003e\n  \u003cli\u003e In the case of \u003ccode\u003estd::cerr\u003c/code\u003e, each output is immediately written, the is no need to flush \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eTherefore, if your only goal is to add an end of line, \u003ccode\u003e\u0027\\n\u0027\u003c/code\u003e is usually more efficient than \u003ccode\u003estd::endl\u003c/code\u003e. If you do want to\nflush, you can be explicit and inject \u003ccode\u003estd::flush\u003c/code\u003e into the stream, or call the \u003ccode\u003eflush\u003c/code\u003e member function on the stream.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid f() {\n  cout \u0026lt;\u0026lt; \"Hello world!\" \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \"How are you?\" \u0026lt;\u0026lt; endl; // Noncompliant, 3 useless flushes\n  string s;\n  cin \u0026gt;\u0026gt; s;\n  cout \u0026lt;\u0026lt; \"Starting long operation now...\" \u0026lt;\u0026lt; endl; // Noncompliant, flushing is useful, but not explicit enough\n  longOperation();\n  cout \u0026lt;\u0026lt; \"Long operation is done\" \u0026lt;\u0026lt; endl; // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid f() {\n  cout \u0026lt;\u0026lt; R\"(Hello world!\n\nHow are you?\n)\" \u0026lt;\u0026lt; endl;\n  // Or\n  cout \u0026lt;\u0026lt; \"Hello world!\\n\\nHow are you?\\n\";\n  string s;\n  cin \u0026gt;\u0026gt; s;\n  cout \u0026lt;\u0026lt; \"Starting long operation now...\\n\" \u0026lt;\u0026lt; flush;\n  longOperation();\n  cout \u0026lt;\u0026lt; \"Long operation is done\\n\";\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#slio50-avoid-endl\"\u003eSL.io.50: Avoid\n  \u003ccode\u003eendl\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhen injecting \u003ccode\u003estd::endl\u003c/code\u003e into an output stream, two things happen:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e An end of line character \u003ccode\u003e\u0027\\n\u0027\u003c/code\u003e is added to the stream \u003c/li\u003e\n  \u003cli\u003e The stream is flushed \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn many situations, you don’t need the stream to be flushed: It takes some time, and additionally, the stream is also flushed automatically in\nseveral circumstances:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e When the stream is closed \u003c/li\u003e\n  \u003cli\u003e In the case of \u003ccode\u003estd::cout\u003c/code\u003e, each time an input is read on \u003ccode\u003estd::cin\u003c/code\u003e or an output is written on \u003ccode\u003estd::cerr\u003c/code\u003e\n  \u003c/li\u003e\n  \u003cli\u003e In the case of \u003ccode\u003estd::cerr\u003c/code\u003e, each output is immediately written, the is no need to flush \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eTherefore, if your only goal is to add an end of line, \u003ccode\u003e\u0027\\n\u0027\u003c/code\u003e is usually more efficient than \u003ccode\u003estd::endl\u003c/code\u003e. If you do want to\nflush, you can be explicit and inject \u003ccode\u003estd::flush\u003c/code\u003e into the stream, or call the \u003ccode\u003eflush\u003c/code\u003e member function on the stream.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid f() {\n  cout \u0026lt;\u0026lt; \"Hello world!\" \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \"How are you?\" \u0026lt;\u0026lt; endl; // Noncompliant, 3 useless flushes\n  string s;\n  cin \u0026gt;\u0026gt; s;\n  cout \u0026lt;\u0026lt; \"Starting long operation now...\" \u0026lt;\u0026lt; endl; // Noncompliant, flushing is useful, but not explicit enough\n  longOperation();\n  cout \u0026lt;\u0026lt; \"Long operation is done\" \u0026lt;\u0026lt; endl; // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid f() {\n  cout \u0026lt;\u0026lt; R\"(Hello world!\n\nHow are you?\n)\" \u0026lt;\u0026lt; endl;\n  // Or\n  cout \u0026lt;\u0026lt; \"Hello world!\\n\\nHow are you?\\n\";\n  string s;\n  cin \u0026gt;\u0026gt; s;\n  cout \u0026lt;\u0026lt; \"Starting long operation now...\\n\" \u0026lt;\u0026lt; flush;\n  longOperation();\n  cout \u0026lt;\u0026lt; \"Long operation is done\\n\";\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#slio50-avoid-endl\"\u003eSL.io.50: Avoid\n  \u003ccode\u003eendl\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "bad-practice",
      "clumsy",
      "cppcoreguidelines",
      "performance"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S3529",
    "name": "Freed memory should not be used",
    "defaultSeverity": "BLOCKER",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003cp\u003eAccessing a memory block that was already freed is undefined behavior. This rule flags access via a pointer or a reference to released heap\nmemory.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eA program may allocate an additional memory block using the \u003ccode\u003emalloc\u003c/code\u003e function. When no longer needed, such memory blocks are released\nusing the \u003ccode\u003efree\u003c/code\u003e function. After it is released, reading or writing to a heap-allocated memory block leads to undefined behavior.\u003c/p\u003e\n\u003cpre\u003e\nchar *cp \u003d (char*)malloc(sizeof(char)*10); // memory is allocated\n// all bytes in cp can be used here\nfree(cp); // memory is released\ncp[9] \u003d 0; // Noncompliant: memory is used after it was released\n\u003c/pre\u003e\n\u003cp\u003eIn addition to the \u003ccode\u003emalloc\u003c/code\u003e and \u003ccode\u003efree\u003c/code\u003e pair, in C++ a heap memory may be acquired by use of the operator \u003ccode\u003enew\u003c/code\u003e,\nand later released using the operator \u003ccode\u003edelete\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\nint *intArray \u003d new int[20]; // memory is allocated\n// elements of intArray can be written or read here\ndelete[] intArray; // memory is released\nintArray[3] \u003d 10; // Noncompliant: memory is used after it was released\n\u003c/pre\u003e\n\u003cp\u003eReleasing a memory block by invoking \u003ccode\u003efree\u003c/code\u003e or operator \u003ccode\u003edelete\u003c/code\u003e informs the memory management system that the program no\nlonger uses the given block. Depending on the state and load of the program, such block can be then:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e reused, i.e., the allocation function returns the same pointer, \u003c/li\u003e\n  \u003cli\u003e released to the operating system, making it inaccessible to the program. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eAccessing released memory causes undefined behavior. This means the compiler is not bound by the language standard anymore, and your program has no\nmeaning assigned to it.\u003c/p\u003e\n\u003cp\u003ePractically this has a wide range of effects:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The program may crash due to the memory no longer being accessible, or due to unexpected value being read or written via the pointer. \u003c/li\u003e\n  \u003cli\u003e Reading from the released memory may produce a garbage value. \u003c/li\u003e\n  \u003cli\u003e When the memory was already reused to store sensitive data, such as passwords, it may lead to a vulnerability that uses this defect to extract\n  information from an instance of the program. \u003c/li\u003e\n  \u003cli\u003e Writing to released memory may change the value of the unrelated object in a remote part of the code if the memory was reused by it. As\n  different objects may reuse same the block of memory between runs, this leads to unintuitive and hard diagnose bugs. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eIn most situations, the use of an uninitialized object is a strong indication of a defect in the code, and fixing it requires a review of the\nobject allocation and deallocation strategies. Generally, the fix requires adjusting the code, so either:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Moving accesses to the memory before the deallocation \u003c/li\u003e\n  \u003cli\u003e Moving the deallocation so it happens after all the uses \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIf possible, it is desired to remove manual memory allocation, and replace it with stack-allocated objects, or in the case of C++, stack objects\nthat manage memory (using RAII idiom).\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nint *intArray \u003d (int*)malloc(sizeof(int)*10);\n// ...\nfree(intArray);\nintArray[9] \u003d 0;  // Noncompliant\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eRelease the memory after all of its uses.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nint *intArray \u003d (int*)malloc(sizeof(int)*10);\n// ...\nintArray[9] \u003d 0;  // Compliant\nfree(intArray);\n\u003c/pre\u003e\n\u003cp\u003eAlternatively, allocate the array on the stack, if the size of the array is known at compile-time:\u003c/p\u003e\n\u003cpre\u003e\nint intArray[10];\n// ...\nintArray[9] \u003d 0;  // Compliant\n\u003c/pre\u003e\n\u003cp\u003eIn C++, use \u003ccode\u003estd::vector\u003c/code\u003e with an arbitrary number of elements:\u003c/p\u003e\n\u003cpre\u003e\nstd::vector\u0026lt;int\u0026gt; intArray;\nintArray.resize(10);\n// ...\nintArray[9] \u003d 0;  // Compliant\n\u003c/pre\u003e\n\u003ch3\u003eGoing the extra mile\u003c/h3\u003e\n\u003cp\u003eIn C++, manually allocating and deallocating memory is considered a code smell.\u003c/p\u003e\n\u003cp\u003eIt is recommended to follow the \u003cem\u003eRAII\u003c/em\u003e idiom and create a class that manages the memory by allocating it when the object is constructed and\nfreeing it when it is destroyed. Furthermore, copy and move operations on such objects are designed such that this object can be passed by value\nbetween functions (either as an argument or by being returned) in place of raw pointers.\u003c/p\u003e\n\u003cp\u003eDepending on the type, passing an \u003cem\u003eRAII\u003c/em\u003e object operations may either:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Allocate a new block of memory and copy the elements (\u003ccode\u003estd::vector\u003c/code\u003e). \u003c/li\u003e\n  \u003cli\u003e Transfer ownership of the memory to constructed object (\u003ccode\u003estd::unique_ptr\u003c/code\u003e). \u003c/li\u003e\n  \u003cli\u003e Use shared ownership and free memory when the last object is destroyed (\u003ccode\u003estd::shared_ptr\u003c/code\u003e). \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis guarantees that accessing a memory managed by such an object is not released as long as such an object is not modified or destroyed (some\n\u003cem\u003eRAII\u003c/em\u003e types provide a stronger guarantee).\u003c/p\u003e\n\u003cpre\u003e\nstd::vector\u0026lt;int\u0026gt; intArray(10); // manages an array of 10 integers, on the heap\nstd::unique_ptr\u0026lt;Class\u0026gt; objPtr \u003d std::make_unique\u0026lt;Class\u0026gt;(); // manages an object on the heap\n\nintArray[5]; // OK\nobjPtr-\u0026gt;foo(); // OK\n\u003c/pre\u003e\n\u003cp\u003eHowever, any raw pointers or references to memory held by \u003cem\u003eRAII\u003c/em\u003e object may still lead to a use after free:\u003c/p\u003e\n\u003cpre\u003e\nint* p1 \u003d \u0026amp;intArray[0];    // becomes dangling when intArray is destroyed\nint* p2 \u003d intArray.data(); // same as above\nClass* p3 \u003d objPtr.get();  // becomes dangling, when objPtr releases the pointer\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/raii\"\u003eRAII\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/memory/unique_ptr\"\u003estd::unique_ptr\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/memory/shared_ptr\"\u003estd::shared_ptr\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/416\"\u003e416 - Use After Free\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/GdYxBQ\"\u003eMEM30-C - Do not access freed memory\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/onw-BQ\"\u003eMEM50-CPP - Do not access freed memory\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/OXw-BQ\"\u003eEXP54-CPP - Do not access an object outside of its lifetime\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S5025} recommends avoiding manual memory management \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eAccessing a memory block that was already freed is undefined behavior. This rule flags access via a pointer or a reference to released heap\nmemory.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eA program may allocate an additional memory block using the \u003ccode\u003emalloc\u003c/code\u003e function. When no longer needed, such memory blocks are released\nusing the \u003ccode\u003efree\u003c/code\u003e function. After it is released, reading or writing to a heap-allocated memory block leads to undefined behavior.\u003c/p\u003e\n\u003cpre\u003e\nchar *cp \u003d (char*)malloc(sizeof(char)*10); // memory is allocated\n// all bytes in cp can be used here\nfree(cp); // memory is released\ncp[9] \u003d 0; // Noncompliant: memory is used after it was released\n\u003c/pre\u003e\n\u003cp\u003eIn addition to the \u003ccode\u003emalloc\u003c/code\u003e and \u003ccode\u003efree\u003c/code\u003e pair, in C++ a heap memory may be acquired by use of the operator \u003ccode\u003enew\u003c/code\u003e,\nand later released using the operator \u003ccode\u003edelete\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\nint *intArray \u003d new int[20]; // memory is allocated\n// elements of intArray can be written or read here\ndelete[] intArray; // memory is released\nintArray[3] \u003d 10; // Noncompliant: memory is used after it was released\n\u003c/pre\u003e\n\u003cp\u003eReleasing a memory block by invoking \u003ccode\u003efree\u003c/code\u003e or operator \u003ccode\u003edelete\u003c/code\u003e informs the memory management system that the program no\nlonger uses the given block. Depending on the state and load of the program, such block can be then:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e reused, i.e., the allocation function returns the same pointer, \u003c/li\u003e\n  \u003cli\u003e released to the operating system, making it inaccessible to the program. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eAccessing released memory causes undefined behavior. This means the compiler is not bound by the language standard anymore, and your program has no\nmeaning assigned to it.\u003c/p\u003e\n\u003cp\u003ePractically this has a wide range of effects:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The program may crash due to the memory no longer being accessible, or due to unexpected value being read or written via the pointer. \u003c/li\u003e\n  \u003cli\u003e Reading from the released memory may produce a garbage value. \u003c/li\u003e\n  \u003cli\u003e When the memory was already reused to store sensitive data, such as passwords, it may lead to a vulnerability that uses this defect to extract\n  information from an instance of the program. \u003c/li\u003e\n  \u003cli\u003e Writing to released memory may change the value of the unrelated object in a remote part of the code if the memory was reused by it. As\n  different objects may reuse same the block of memory between runs, this leads to unintuitive and hard diagnose bugs. \u003c/li\u003e\n\u003c/ul\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eIn most situations, the use of an uninitialized object is a strong indication of a defect in the code, and fixing it requires a review of the\nobject allocation and deallocation strategies. Generally, the fix requires adjusting the code, so either:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Moving accesses to the memory before the deallocation \u003c/li\u003e\n  \u003cli\u003e Moving the deallocation so it happens after all the uses \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIf possible, it is desired to remove manual memory allocation, and replace it with stack-allocated objects, or in the case of C++, stack objects\nthat manage memory (using RAII idiom).\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nint *intArray \u003d (int*)malloc(sizeof(int)*10);\n// ...\nfree(intArray);\nintArray[9] \u003d 0;  // Noncompliant\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eRelease the memory after all of its uses.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nint *intArray \u003d (int*)malloc(sizeof(int)*10);\n// ...\nintArray[9] \u003d 0;  // Compliant\nfree(intArray);\n\u003c/pre\u003e\n\u003cp\u003eAlternatively, allocate the array on the stack, if the size of the array is known at compile-time:\u003c/p\u003e\n\u003cpre\u003e\nint intArray[10];\n// ...\nintArray[9] \u003d 0;  // Compliant\n\u003c/pre\u003e\n\u003cp\u003eIn C++, use \u003ccode\u003estd::vector\u003c/code\u003e with an arbitrary number of elements:\u003c/p\u003e\n\u003cpre\u003e\nstd::vector\u0026lt;int\u0026gt; intArray;\nintArray.resize(10);\n// ...\nintArray[9] \u003d 0;  // Compliant\n\u003c/pre\u003e\n\u003ch3\u003eGoing the extra mile\u003c/h3\u003e\n\u003cp\u003eIn C++, manually allocating and deallocating memory is considered a code smell.\u003c/p\u003e\n\u003cp\u003eIt is recommended to follow the \u003cem\u003eRAII\u003c/em\u003e idiom and create a class that manages the memory by allocating it when the object is constructed and\nfreeing it when it is destroyed. Furthermore, copy and move operations on such objects are designed such that this object can be passed by value\nbetween functions (either as an argument or by being returned) in place of raw pointers.\u003c/p\u003e\n\u003cp\u003eDepending on the type, passing an \u003cem\u003eRAII\u003c/em\u003e object operations may either:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Allocate a new block of memory and copy the elements (\u003ccode\u003estd::vector\u003c/code\u003e). \u003c/li\u003e\n  \u003cli\u003e Transfer ownership of the memory to constructed object (\u003ccode\u003estd::unique_ptr\u003c/code\u003e). \u003c/li\u003e\n  \u003cli\u003e Use shared ownership and free memory when the last object is destroyed (\u003ccode\u003estd::shared_ptr\u003c/code\u003e). \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis guarantees that accessing a memory managed by such an object is not released as long as such an object is not modified or destroyed (some\n\u003cem\u003eRAII\u003c/em\u003e types provide a stronger guarantee).\u003c/p\u003e\n\u003cpre\u003e\nstd::vector\u0026lt;int\u0026gt; intArray(10); // manages an array of 10 integers, on the heap\nstd::unique_ptr\u0026lt;Class\u0026gt; objPtr \u003d std::make_unique\u0026lt;Class\u0026gt;(); // manages an object on the heap\n\nintArray[5]; // OK\nobjPtr-\u0026gt;foo(); // OK\n\u003c/pre\u003e\n\u003cp\u003eHowever, any raw pointers or references to memory held by \u003cem\u003eRAII\u003c/em\u003e object may still lead to a use after free:\u003c/p\u003e\n\u003cpre\u003e\nint* p1 \u003d \u0026amp;intArray[0];    // becomes dangling when intArray is destroyed\nint* p2 \u003d intArray.data(); // same as above\nClass* p3 \u003d objPtr.get();  // becomes dangling, when objPtr releases the pointer\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/raii\"\u003eRAII\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/memory/unique_ptr\"\u003estd::unique_ptr\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/memory/shared_ptr\"\u003estd::shared_ptr\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/416\"\u003e416 - Use After Free\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/GdYxBQ\"\u003eMEM30-C - Do not access freed memory\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/onw-BQ\"\u003eMEM50-CPP - Do not access freed memory\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/OXw-BQ\"\u003eEXP54-CPP - Do not access an object outside of its lifetime\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S5025} recommends avoiding manual memory management \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cert",
      "cwe",
      "symbolic-execution"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S3520",
    "name": "Memory locations should not be released more than once",
    "defaultSeverity": "BLOCKER",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003cp\u003eDeallocating a memory location more than once leads to undefined behavior.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eUsing \u003ccode\u003edelete\u003c/code\u003e or \u003ccode\u003efree\u003c/code\u003e releases the reservation on a memory location, making it immediately available for another purpose.\nReleasing the exact memory location twice leads to undefined behavior and can often crash the program.\u003c/p\u003e\n\u003cp\u003eThe C standard defines as \u003cem\u003eundefined behavior\u003c/em\u003e a call to \u003ccode\u003efree\u003c/code\u003e with a pointer to a memory area that has already been\nreleased.\u003c/p\u003e\n\u003cp\u003eThe C++ standard defines the first \u003ccode\u003edelete\u003c/code\u003e call as the end of the lifetime for dynamically allocated memory. Access to memory past its\nlifetime end, including another \u003ccode\u003edelete\u003c/code\u003e, is undefined behavior.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact\u003c/h3\u003e\n\u003cp\u003eThe danger of a \"double-free\" comes directly from the fact that it is undefined behavior (in both C and C++). Note that there is no guarantee that\na crash will happen on a \"double-free\" when the resource is released or at all until the end of the program’s execution.\u003c/p\u003e\n\u003cp\u003eThe effects of a \"double-free\" depend entirely on the program’s memory management implementation. In the case of such an event, one of the\nfollowing can be observed:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The program’s memory-management data structures can become corrupted. This will usually cause a crash. \u003c/li\u003e\n  \u003cli\u003e Demonstrative Example 2 on \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/415\"\u003eCWE-415\u003c/a\u003e presents a set of circumstances where a crash does\n  not occur. In these circumstances, the corruption of the mentioned data structures causes two later calls to \u003ccode\u003emalloc\u003c/code\u003e to return the same\n  pointer. This can lead to a sensitive-data-exposure vulnerability or a buffer-overflow vulnerability. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eTo ensure that every release happens once, you can follow these best practices:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Release any allocated memory in the function it was acquired in. The release should be independent of any additional conditions. \u003c/li\u003e\n  \u003cli\u003e After a \u003ccode\u003edelete\u003c/code\u003e or \u003ccode\u003efree\u003c/code\u003e, set the pointer’s value to \u003ccode\u003enullptr\u003c/code\u003e or \u003ccode\u003eNULL\u003c/code\u003e. \u003ccode\u003edelete\u003c/code\u003e of\n  \u003ccode\u003enullptr\u003c/code\u003e and \u003ccode\u003efree\u003c/code\u003e of \u003ccode\u003eNULL\u003c/code\u003e are defined as having no effect. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003cp\u003eExample for C:\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid doSomething(int size) {\n  char* cp \u003d (char*) malloc(sizeof(char) * size);\n\n  // ...\n  if (condition) {\n    // ...\n    free(cp);\n  }\n\n  free(cp);  // Noncompliant: potential call to free in the above branch\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eRemove the unnecessary call to \u003ccode\u003efree\u003c/code\u003e:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid doSomething(int size) {\n  char* cp \u003d (char*) malloc(sizeof(char) * size);\n\n  // ...\n  if (condition) {\n    // ...\n  }\n\n  free(cp); // Compliant: no previous call to free in the above branch\n}\n\u003c/pre\u003e\n\u003cp\u003eSet the pointer to \u003ccode\u003eNULL\u003c/code\u003e after any call to \u003ccode\u003efree\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\nvoid doSomething(int size) {\n  char* cp \u003d (char*) malloc(sizeof(char) * size);\n\n  // ...\n  if (condition) {\n    // ...\n    free(cp);\n    cp \u003d NULL; // This will prevent freeing the same memory again\n  }\n\n  free(cp); // Compliant: if the memory was freed in the if-block above, free(NULL) is a no-op\n}\n\u003c/pre\u003e\n\u003cp\u003eExample for C++:\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid doSomething(int size) {\n  std::string* p \u003d new std::string;\n\n  // ...\n  if (condition) {\n    // ...\n    delete p;\n  }\n\n  delete p;  // Noncompliant: potential invocation of delete in the above branch\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eRemove the unnecessary invocation of \u003ccode\u003edelete\u003c/code\u003e:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\nvoid doSomething(int size) {\n  std::string* p \u003d new std::string;\n\n  // ...\n  if (condition) {\n    // ...\n  }\n\n  delete p; // Compliant: no previous call to free in the above branch\n}\n\u003c/pre\u003e\n\u003cp\u003eSet the pointer to \u003ccode\u003enullptr\u003c/code\u003e after invoking \u003ccode\u003edelete\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\nvoid doSomething(int size) {\n  std::string* p \u003d new std::string;\n\n  // ...\n  if (condition) {\n    // ...\n    delete p;\n    p \u003d nullptr; // This will prevent freeing the same memory again\n  }\n\n  delete p; // Compliant: if the memory was freed in the if-block above, operator delete of nullptr is a no-op\n}\n\u003c/pre\u003e\n\u003ch3\u003eGoing the extra mile\u003c/h3\u003e\n\u003cp\u003eIn C++, manually allocating and deallocating memory is considered a code smell.\u003c/p\u003e\n\u003cp\u003eIt is recommended to follow the \u003cem\u003eRAII\u003c/em\u003e idiom and create a class that manages the memory by allocating it when the object is constructed and\nfreeing it when it is destroyed. Furthermore, copy and move operations on such objects are designed such that this object can be passed by value\nbetween functions (either as an argument or by being returned) in place of raw pointers.\u003c/p\u003e\n\u003cp\u003eDepending on the type, passing an \u003cem\u003eRAII\u003c/em\u003e object operations may either:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Allocate a new block of memory and copy the elements (\u003ccode\u003estd::vector\u003c/code\u003e). \u003c/li\u003e\n  \u003cli\u003e Transfer ownership of the memory to constructed object (\u003ccode\u003estd::unique_ptr\u003c/code\u003e). \u003c/li\u003e\n  \u003cli\u003e Use shared ownership and free memory when the last object is destroyed (\u003ccode\u003estd::shared_ptr\u003c/code\u003e). \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eUsing \u003cem\u003eRAII\u003c/em\u003e objects instead of manual memory management can mitigate most dynamic memory management issues, including \"double-free\".\u003c/p\u003e\n\u003cpre\u003e\nvoid doSomething(int size) {\n  auto p \u003d std::make_unique\u0026lt;std::string\u0026gt;();\n\n  // ...\n  if (condition) {\n    p.reset(); // Delete happens here.\n  }\n\n  // delete not called by std::unique_ptr destructor if the branch above was taken.\n}\n\u003c/pre\u003e\n\u003ch3\u003ePitfalls\u003c/h3\u003e\n\u003cp\u003eHowever, keeping a raw pointer or a reference to memory held by \u003cem\u003eRAII\u003c/em\u003e objects may still lead to a \"double-free\". Care must be taken to\navoid the following pitfalls:\u003c/p\u003e\n\u003ch4\u003eInitialization of \u003ccode\u003estd::shared_ptr\u003c/code\u003e\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003estd::shared_ptr\u003c/code\u003e relies on an internal counter of owners inside a \"control block\". This control block is either created when the object\nis constructed with a raw pointer or inherited when constructed from another \u003ccode\u003estd::shared_ptr\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eMisunderstanding this can lead to a \"double-free\", as the following example demonstrates.\u003c/p\u003e\n\u003cp\u003eNoncompliant code example\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid doSomething(char const* data) {\n  std::shared_ptr\u0026lt;std::string\u0026gt; p1(new std::string(data));\n  std::shared_ptr\u0026lt;std::string\u0026gt; p2(p1.get()); // Noncompliant: Intended: std::shared_ptr\u0026lt;string\u0026gt; p2(p1);\n}\n\u003c/pre\u003e\n\u003cp\u003eBoth objects are created from the raw pointer, leading them to have independent control blocks. Both will attempt to release the original memory\narea.\u003c/p\u003e\n\u003cp\u003eTo avoid this, only use copy/move construction for sharing ownership or the \u003ccode\u003estd::make_shared\u003c/code\u003e for initialization.\u003c/p\u003e\n\u003cp\u003eCompliant solution\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"compliant\"\u003e\nvoid doSomething(char const* data) {\n  auto p1 \u003d std::make_shared\u0026lt;std::string\u0026gt;(data);\n  auto p2 \u003d p1; // Compliant\n}\n\u003c/pre\u003e\n\u003ch4\u003eInitialization of \u003ccode\u003estd::unique_ptr\u003c/code\u003e\u003c/h4\u003e\n\u003cp\u003eSimilar to \u003ccode\u003estd::shared_ptr\u003c/code\u003e, a \"double-free\" can occur from an erroneous initialization. This also comes from confusion raised by the\nconstructor overloads of this class.\u003c/p\u003e\n\u003cp\u003eNoncompliant code example\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"4\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid doSomething(char const* data) {\n  // Creating another unique_ptr\n  std::unique_ptr\u0026lt;std::string\u0026gt; p1(new std::string(data));\n  // ...\n  std::unique_ptr\u0026lt;std::string\u0026gt; p2(p1.get()); // Noncompliant: both p1 and p2 own the pointer now.\n\n  // Transfering ownership\n  std::unqiue_ptr\u0026lt;std::string\u0026gt; p3(new std::string(data));\n  // ...\n  std::unique_ptr\u0026lt;std::string\u0026gt; p4(p3.get()); // Noncompliant: both p3 and p4 own the pointer now.\n}\n\u003c/pre\u003e\n\u003cp\u003eAs with \u003ccode\u003estd::shared_ptr\u003c/code\u003e, using \u003ccode\u003estd::make_unique\u003c/code\u003e avoids this pitfall. It does not accept a pointer to an existing object\nbut only creates a new one.\u003c/p\u003e\n\u003cp\u003eCompliant solution\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"4\" data-diff-type\u003d\"compliant\"\u003e\nvoid doSomething(char const* data) {\n  // Creating another unique_ptr\n  auto p1 \u003d std::make_unique\u0026lt;std::string\u0026gt;(data);\n  // ...\n  auto p2 \u003d std::make_unique\u0026lt;std::string\u0026gt;(*p1); // Compliant: Creates a copy.\n\n  // Transfering ownership\n  auto p3 \u003d std::make_unique\u0026lt;std::string\u0026gt;(data);\n  auto p4 \u003d std::move(p3); // Compliant: Will invoke move constructor, which is present in std::unique_ptr.\n}\n\u003c/pre\u003e\n\u003ch4\u003eOut-of-scope access\u003c/h4\u003e\n\u003cp\u003eExtra care must be taken when passing the memory address contained in an RAII object.\u003c/p\u003e\n\u003cp\u003eBoth \u003ccode\u003estd::shared_ptr\u003c/code\u003e and \u003ccode\u003estd::unique_ptr\u003c/code\u003e provide the \u003ccode\u003eget\u003c/code\u003e method to obtain a raw pointer to the contained\nmemory. This should only be used to read the data. Passing this pointer to a function that might release it can lead to a \"double-free\" and\n\"use-after-free\".\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/memory/unique_ptr\"\u003estd::unique_ptr\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/memory/unique_ptr/make_unique\"\u003estd::make_unique\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/memory/shared_ptr\"\u003estd::shared_ptr\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/memory/shared_ptr/make_shared\"\u003estd::make_shared\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/415\"\u003e415 Double Free\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/GdYxBQ\"\u003eMEM30-C - Do not access freed memory\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/Gns-BQ\"\u003eMEM51-CPP - Properly deallocate dynamically allocated resources\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/Zns-BQ\"\u003eMEM56-CPP - Do not store an already-owned pointer value in an unrelated smart\n  pointer\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e OWASP - \u003ca href\u003d\"https://owasp.org/www-community/vulnerabilities/Doubly_freeing_memory\"\u003eDoubly freeing memory\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S5025} recommends avoiding manual memory management \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S3529} refers to \"use-after-free\", an issue with similar causes. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eDeallocating a memory location more than once leads to undefined behavior.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eUsing \u003ccode\u003edelete\u003c/code\u003e or \u003ccode\u003efree\u003c/code\u003e releases the reservation on a memory location, making it immediately available for another purpose.\nReleasing the exact memory location twice leads to undefined behavior and can often crash the program.\u003c/p\u003e\n\u003cp\u003eThe C standard defines as \u003cem\u003eundefined behavior\u003c/em\u003e a call to \u003ccode\u003efree\u003c/code\u003e with a pointer to a memory area that has already been\nreleased.\u003c/p\u003e\n\u003cp\u003eThe C++ standard defines the first \u003ccode\u003edelete\u003c/code\u003e call as the end of the lifetime for dynamically allocated memory. Access to memory past its\nlifetime end, including another \u003ccode\u003edelete\u003c/code\u003e, is undefined behavior.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact\u003c/h3\u003e\n\u003cp\u003eThe danger of a \"double-free\" comes directly from the fact that it is undefined behavior (in both C and C++). Note that there is no guarantee that\na crash will happen on a \"double-free\" when the resource is released or at all until the end of the program’s execution.\u003c/p\u003e\n\u003cp\u003eThe effects of a \"double-free\" depend entirely on the program’s memory management implementation. In the case of such an event, one of the\nfollowing can be observed:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The program’s memory-management data structures can become corrupted. This will usually cause a crash. \u003c/li\u003e\n  \u003cli\u003e Demonstrative Example 2 on \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/415\"\u003eCWE-415\u003c/a\u003e presents a set of circumstances where a crash does\n  not occur. In these circumstances, the corruption of the mentioned data structures causes two later calls to \u003ccode\u003emalloc\u003c/code\u003e to return the same\n  pointer. This can lead to a sensitive-data-exposure vulnerability or a buffer-overflow vulnerability. \u003c/li\u003e\n\u003c/ul\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eTo ensure that every release happens once, you can follow these best practices:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Release any allocated memory in the function it was acquired in. The release should be independent of any additional conditions. \u003c/li\u003e\n  \u003cli\u003e After a \u003ccode\u003edelete\u003c/code\u003e or \u003ccode\u003efree\u003c/code\u003e, set the pointer’s value to \u003ccode\u003enullptr\u003c/code\u003e or \u003ccode\u003eNULL\u003c/code\u003e. \u003ccode\u003edelete\u003c/code\u003e of\n  \u003ccode\u003enullptr\u003c/code\u003e and \u003ccode\u003efree\u003c/code\u003e of \u003ccode\u003eNULL\u003c/code\u003e are defined as having no effect. \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eExample for C:\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid doSomething(int size) {\n  char* cp \u003d (char*) malloc(sizeof(char) * size);\n\n  // ...\n  if (condition) {\n    // ...\n    free(cp);\n  }\n\n  free(cp);  // Noncompliant: potential call to free in the above branch\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eRemove the unnecessary call to \u003ccode\u003efree\u003c/code\u003e:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid doSomething(int size) {\n  char* cp \u003d (char*) malloc(sizeof(char) * size);\n\n  // ...\n  if (condition) {\n    // ...\n  }\n\n  free(cp); // Compliant: no previous call to free in the above branch\n}\n\u003c/pre\u003e\n\u003cp\u003eSet the pointer to \u003ccode\u003eNULL\u003c/code\u003e after any call to \u003ccode\u003efree\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\nvoid doSomething(int size) {\n  char* cp \u003d (char*) malloc(sizeof(char) * size);\n\n  // ...\n  if (condition) {\n    // ...\n    free(cp);\n    cp \u003d NULL; // This will prevent freeing the same memory again\n  }\n\n  free(cp); // Compliant: if the memory was freed in the if-block above, free(NULL) is a no-op\n}\n\u003c/pre\u003e\n\u003cp\u003eExample for C++:\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid doSomething(int size) {\n  std::string* p \u003d new std::string;\n\n  // ...\n  if (condition) {\n    // ...\n    delete p;\n  }\n\n  delete p;  // Noncompliant: potential invocation of delete in the above branch\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eRemove the unnecessary invocation of \u003ccode\u003edelete\u003c/code\u003e:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\nvoid doSomething(int size) {\n  std::string* p \u003d new std::string;\n\n  // ...\n  if (condition) {\n    // ...\n  }\n\n  delete p; // Compliant: no previous call to free in the above branch\n}\n\u003c/pre\u003e\n\u003cp\u003eSet the pointer to \u003ccode\u003enullptr\u003c/code\u003e after invoking \u003ccode\u003edelete\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\nvoid doSomething(int size) {\n  std::string* p \u003d new std::string;\n\n  // ...\n  if (condition) {\n    // ...\n    delete p;\n    p \u003d nullptr; // This will prevent freeing the same memory again\n  }\n\n  delete p; // Compliant: if the memory was freed in the if-block above, operator delete of nullptr is a no-op\n}\n\u003c/pre\u003e\n\u003ch3\u003eGoing the extra mile\u003c/h3\u003e\n\u003cp\u003eIn C++, manually allocating and deallocating memory is considered a code smell.\u003c/p\u003e\n\u003cp\u003eIt is recommended to follow the \u003cem\u003eRAII\u003c/em\u003e idiom and create a class that manages the memory by allocating it when the object is constructed and\nfreeing it when it is destroyed. Furthermore, copy and move operations on such objects are designed such that this object can be passed by value\nbetween functions (either as an argument or by being returned) in place of raw pointers.\u003c/p\u003e\n\u003cp\u003eDepending on the type, passing an \u003cem\u003eRAII\u003c/em\u003e object operations may either:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Allocate a new block of memory and copy the elements (\u003ccode\u003estd::vector\u003c/code\u003e). \u003c/li\u003e\n  \u003cli\u003e Transfer ownership of the memory to constructed object (\u003ccode\u003estd::unique_ptr\u003c/code\u003e). \u003c/li\u003e\n  \u003cli\u003e Use shared ownership and free memory when the last object is destroyed (\u003ccode\u003estd::shared_ptr\u003c/code\u003e). \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eUsing \u003cem\u003eRAII\u003c/em\u003e objects instead of manual memory management can mitigate most dynamic memory management issues, including \"double-free\".\u003c/p\u003e\n\u003cpre\u003e\nvoid doSomething(int size) {\n  auto p \u003d std::make_unique\u0026lt;std::string\u0026gt;();\n\n  // ...\n  if (condition) {\n    p.reset(); // Delete happens here.\n  }\n\n  // delete not called by std::unique_ptr destructor if the branch above was taken.\n}\n\u003c/pre\u003e\n\u003ch3\u003ePitfalls\u003c/h3\u003e\n\u003cp\u003eHowever, keeping a raw pointer or a reference to memory held by \u003cem\u003eRAII\u003c/em\u003e objects may still lead to a \"double-free\". Care must be taken to\navoid the following pitfalls:\u003c/p\u003e\n\u003ch4\u003eInitialization of \u003ccode\u003estd::shared_ptr\u003c/code\u003e\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003estd::shared_ptr\u003c/code\u003e relies on an internal counter of owners inside a \"control block\". This control block is either created when the object\nis constructed with a raw pointer or inherited when constructed from another \u003ccode\u003estd::shared_ptr\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eMisunderstanding this can lead to a \"double-free\", as the following example demonstrates.\u003c/p\u003e\n\u003cp\u003eNoncompliant code example\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid doSomething(char const* data) {\n  std::shared_ptr\u0026lt;std::string\u0026gt; p1(new std::string(data));\n  std::shared_ptr\u0026lt;std::string\u0026gt; p2(p1.get()); // Noncompliant: Intended: std::shared_ptr\u0026lt;string\u0026gt; p2(p1);\n}\n\u003c/pre\u003e\n\u003cp\u003eBoth objects are created from the raw pointer, leading them to have independent control blocks. Both will attempt to release the original memory\narea.\u003c/p\u003e\n\u003cp\u003eTo avoid this, only use copy/move construction for sharing ownership or the \u003ccode\u003estd::make_shared\u003c/code\u003e for initialization.\u003c/p\u003e\n\u003cp\u003eCompliant solution\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"compliant\"\u003e\nvoid doSomething(char const* data) {\n  auto p1 \u003d std::make_shared\u0026lt;std::string\u0026gt;(data);\n  auto p2 \u003d p1; // Compliant\n}\n\u003c/pre\u003e\n\u003ch4\u003eInitialization of \u003ccode\u003estd::unique_ptr\u003c/code\u003e\u003c/h4\u003e\n\u003cp\u003eSimilar to \u003ccode\u003estd::shared_ptr\u003c/code\u003e, a \"double-free\" can occur from an erroneous initialization. This also comes from confusion raised by the\nconstructor overloads of this class.\u003c/p\u003e\n\u003cp\u003eNoncompliant code example\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"4\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid doSomething(char const* data) {\n  // Creating another unique_ptr\n  std::unique_ptr\u0026lt;std::string\u0026gt; p1(new std::string(data));\n  // ...\n  std::unique_ptr\u0026lt;std::string\u0026gt; p2(p1.get()); // Noncompliant: both p1 and p2 own the pointer now.\n\n  // Transfering ownership\n  std::unqiue_ptr\u0026lt;std::string\u0026gt; p3(new std::string(data));\n  // ...\n  std::unique_ptr\u0026lt;std::string\u0026gt; p4(p3.get()); // Noncompliant: both p3 and p4 own the pointer now.\n}\n\u003c/pre\u003e\n\u003cp\u003eAs with \u003ccode\u003estd::shared_ptr\u003c/code\u003e, using \u003ccode\u003estd::make_unique\u003c/code\u003e avoids this pitfall. It does not accept a pointer to an existing object\nbut only creates a new one.\u003c/p\u003e\n\u003cp\u003eCompliant solution\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"4\" data-diff-type\u003d\"compliant\"\u003e\nvoid doSomething(char const* data) {\n  // Creating another unique_ptr\n  auto p1 \u003d std::make_unique\u0026lt;std::string\u0026gt;(data);\n  // ...\n  auto p2 \u003d std::make_unique\u0026lt;std::string\u0026gt;(*p1); // Compliant: Creates a copy.\n\n  // Transfering ownership\n  auto p3 \u003d std::make_unique\u0026lt;std::string\u0026gt;(data);\n  auto p4 \u003d std::move(p3); // Compliant: Will invoke move constructor, which is present in std::unique_ptr.\n}\n\u003c/pre\u003e\n\u003ch4\u003eOut-of-scope access\u003c/h4\u003e\n\u003cp\u003eExtra care must be taken when passing the memory address contained in an RAII object.\u003c/p\u003e\n\u003cp\u003eBoth \u003ccode\u003estd::shared_ptr\u003c/code\u003e and \u003ccode\u003estd::unique_ptr\u003c/code\u003e provide the \u003ccode\u003eget\u003c/code\u003e method to obtain a raw pointer to the contained\nmemory. This should only be used to read the data. Passing this pointer to a function that might release it can lead to a \"double-free\" and\n\"use-after-free\".\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/memory/unique_ptr\"\u003estd::unique_ptr\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/memory/unique_ptr/make_unique\"\u003estd::make_unique\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/memory/shared_ptr\"\u003estd::shared_ptr\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/memory/shared_ptr/make_shared\"\u003estd::make_shared\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/415\"\u003e415 Double Free\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/GdYxBQ\"\u003eMEM30-C - Do not access freed memory\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/Gns-BQ\"\u003eMEM51-CPP - Properly deallocate dynamically allocated resources\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/Zns-BQ\"\u003eMEM56-CPP - Do not store an already-owned pointer value in an unrelated smart\n  pointer\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e OWASP - \u003ca href\u003d\"https://owasp.org/www-community/vulnerabilities/Doubly_freeing_memory\"\u003eDoubly freeing memory\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S5025} recommends avoiding manual memory management \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S3529} refers to \"use-after-free\", an issue with similar causes. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cwe",
      "symbolic-execution"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S3522",
    "name": "The \"register\" storage class specifier should not be used",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eAccording to ISO/IEC 14882 (third edition 2011-09-01) : C++11\u003c/p\u003e\n\u003cblockquote\u003e\n  \u003cp\u003eThe register specifier shall be applied only to names of variables declared in a block or to function parameters. It specifies that the named\n  variable has automatic storage duration. A variable declared without a storage-class-specifier at block scope or declared as a function parameter\n  has automatic storage duration by default.\u003c/p\u003e\n  \u003cp\u003eA register specifier is a hint to the implementation that the variable so declared will be heavily used.[ Note: The hint can be ignored and in\n  most implementations it will be ignored if the address of the variable is taken. This use is \u003cstrong\u003edeprecated\u003c/strong\u003e - end note ]\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eIn upcoming versions of C/C++ we can expect this deprecated specifier to not be supported anymore.\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eAccording to ISO/IEC 14882 (third edition 2011-09-01) : C++11\u003c/p\u003e\n\u003cblockquote\u003e\n  \u003cp\u003eThe register specifier shall be applied only to names of variables declared in a block or to function parameters. It specifies that the named\n  variable has automatic storage duration. A variable declared without a storage-class-specifier at block scope or declared as a function parameter\n  has automatic storage duration by default.\u003c/p\u003e\n  \u003cp\u003eA register specifier is a hint to the implementation that the variable so declared will be heavily used.[ Note: The hint can be ignored and in\n  most implementations it will be ignored if the address of the variable is taken. This use is \u003cstrong\u003edeprecated\u003c/strong\u003e - end note ]\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eIn upcoming versions of C/C++ we can expect this deprecated specifier to not be supported anymore.\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "obsolete"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S3642",
    "name": "Scoped enumerations should be used",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "MODULAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThere are two kinds of enumeration:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The unscoped \u003ccode\u003eenum\u003c/code\u003e inherited from C \u003c/li\u003e\n  \u003cli\u003e The scoped enumeration \u003ccode\u003eenum class\u003c/code\u003e or \u003ccode\u003eenum struct\u003c/code\u003e added in C++ 11 \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eUnscoped enumerations have two major drawbacks that are fixed by scoped enumerations:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003eenum\u003c/code\u003e elements are visible from their enclosing scope instead of requiring the scope resolution operator (ex: \u003ccode\u003eRed\u003c/code\u003e\n  instead of \u003ccode\u003eColor::Red\u003c/code\u003e) \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003eenum\u003c/code\u003e elements convert implicitly to \u003ccode\u003eint\u003c/code\u003e, so that heterogeneous comparisons such as \u003ccode\u003eRed \u003d\u003d Big\u003c/code\u003e don’t\n  result in compile errors. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis rule raises an issue when an unscoped enumeration is used.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nenum Color { // Noncompliant: replace this \"enum\" with \"enum class\".\n  Red   \u003d 0xff0000,\n  Green \u003d 0x00ff00,\n  Blue  \u003d 0x0000ff\n};\n\nenum ProductType { // Noncompliant: replace this \"enum\" with \"enum class\".\n  Small   \u003d 1,\n  Big     \u003d 2\n};\n\nvoid printColor(int color);\nvoid printInt(int value);\n\nvoid report() {\n  printColor(Red); // correct\n  printColor(Big); // clearly buggy\n  printInt(Red);   // conversion is implicit\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nenum class Color { // declared using \"enum class\"\n  Red   \u003d 0xff0000,\n  Green \u003d 0x00ff00,\n  Blue  \u003d 0x0000ff\n};\n\nenum class ProductType { // declared using \"enum class\"\n  Small   \u003d 1,\n  Big     \u003d 2\n};\n\nvoid printColor(Color color); // requires \"Color\" instead of \"int\"\nvoid printInt(int value);\n\nvoid report() {\n  printColor(Color::Red);       // correct\n  // printColor(ProductType::Big); \u003d\u0026gt; Compilation error, no known conversion from \u0027ProductType\u0027 to \u0027Color\u0027\n  printInt(static_cast\u0026lt;int\u0026gt;(Color::Red)); // conversion never occurs implicitly and must be explicit\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eWhen the enum is a private class member, the class encapsulates its use, and the drawbacks of unscoped enums can be avoided. Therefore, the rule\ndoes not raise an issue in that case.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/enum\"\u003eEnumeration declaration\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#enum3-prefer-class-enums-over-plain-enums\"\u003eEnum.3: Prefer class\n  enums over \"plain\" enums\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThere are two kinds of enumeration:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The unscoped \u003ccode\u003eenum\u003c/code\u003e inherited from C \u003c/li\u003e\n  \u003cli\u003e The scoped enumeration \u003ccode\u003eenum class\u003c/code\u003e or \u003ccode\u003eenum struct\u003c/code\u003e added in C++ 11 \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eUnscoped enumerations have two major drawbacks that are fixed by scoped enumerations:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003eenum\u003c/code\u003e elements are visible from their enclosing scope instead of requiring the scope resolution operator (ex: \u003ccode\u003eRed\u003c/code\u003e\n  instead of \u003ccode\u003eColor::Red\u003c/code\u003e) \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003eenum\u003c/code\u003e elements convert implicitly to \u003ccode\u003eint\u003c/code\u003e, so that heterogeneous comparisons such as \u003ccode\u003eRed \u003d\u003d Big\u003c/code\u003e don’t\n  result in compile errors. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis rule raises an issue when an unscoped enumeration is used.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nenum Color { // Noncompliant: replace this \"enum\" with \"enum class\".\n  Red   \u003d 0xff0000,\n  Green \u003d 0x00ff00,\n  Blue  \u003d 0x0000ff\n};\n\nenum ProductType { // Noncompliant: replace this \"enum\" with \"enum class\".\n  Small   \u003d 1,\n  Big     \u003d 2\n};\n\nvoid printColor(int color);\nvoid printInt(int value);\n\nvoid report() {\n  printColor(Red); // correct\n  printColor(Big); // clearly buggy\n  printInt(Red);   // conversion is implicit\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nenum class Color { // declared using \"enum class\"\n  Red   \u003d 0xff0000,\n  Green \u003d 0x00ff00,\n  Blue  \u003d 0x0000ff\n};\n\nenum class ProductType { // declared using \"enum class\"\n  Small   \u003d 1,\n  Big     \u003d 2\n};\n\nvoid printColor(Color color); // requires \"Color\" instead of \"int\"\nvoid printInt(int value);\n\nvoid report() {\n  printColor(Color::Red);       // correct\n  // printColor(ProductType::Big); \u003d\u0026gt; Compilation error, no known conversion from \u0027ProductType\u0027 to \u0027Color\u0027\n  printInt(static_cast\u0026lt;int\u0026gt;(Color::Red)); // conversion never occurs implicitly and must be explicit\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eWhen the enum is a private class member, the class encapsulates its use, and the drawbacks of unscoped enums can be avoided. Therefore, the rule\ndoes not raise an issue in that case.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/enum\"\u003eEnumeration declaration\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#enum3-prefer-class-enums-over-plain-enums\"\u003eEnum.3: Prefer class\n  enums over \"plain\" enums\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cppcoreguidelines",
      "pitfall",
      "since-c++11"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1103",
    "name": "\"/*\" and \"//\" should not be used within comments",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eDefining a nested single-line comment within a multi-line comment invites errors. It may lead a developer to wrongly think that the lines located\nafter the single-line comment are not part of the comment.\u003c/p\u003e\n\u003cp\u003eIf a comment starting sequence, \u003ccode\u003e/*\u003c/code\u003e or \u003ccode\u003e//\u003c/code\u003e, occurs within a \u003ccode\u003e/*\u003c/code\u003e comment, is it quite likely to be caused by a\nmissing \u003ccode\u003e*/\u003c/code\u003e comment ending sequence.\u003c/p\u003e\n\u003cp\u003eIf a comment starting sequence occurs within a \u003ccode\u003e//\u003c/code\u003e comment, it is probably because a region of code has been commented-out using\n\u003ccode\u003e//\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n/* some comment, end comment marker accidentally omitted\n// Make sure this function is called in a thread safe context\nPerform_Critical_Safety_Function(X);\n...\n/* this comment is non-compliant */\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThe sequence // is permitted within a // comment.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/k9YxBQ\"\u003eCERT, MSC04-C.\u003c/a\u003e - Use comments consistently and in a readable fashion \u003c/li\u003e\n  \u003cli\u003e MISRA C:2004, 2.3 - The character sequence /* shall not be used within a comment. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 2-7-1 - The character sequence /* shall not be used within a C-style comment. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 3.1 - The character sequences /* and // shall not be used within a comment \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eDefining a nested single-line comment within a multi-line comment invites errors. It may lead a developer to wrongly think that the lines located\nafter the single-line comment are not part of the comment.\u003c/p\u003e\n\u003cp\u003eIf a comment starting sequence, \u003ccode\u003e/*\u003c/code\u003e or \u003ccode\u003e//\u003c/code\u003e, occurs within a \u003ccode\u003e/*\u003c/code\u003e comment, is it quite likely to be caused by a\nmissing \u003ccode\u003e*/\u003c/code\u003e comment ending sequence.\u003c/p\u003e\n\u003cp\u003eIf a comment starting sequence occurs within a \u003ccode\u003e//\u003c/code\u003e comment, it is probably because a region of code has been commented-out using\n\u003ccode\u003e//\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n/* some comment, end comment marker accidentally omitted\n// Make sure this function is called in a thread safe context\nPerform_Critical_Safety_Function(X);\n...\n/* this comment is non-compliant */\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThe sequence // is permitted within a // comment.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/k9YxBQ\"\u003eCERT, MSC04-C.\u003c/a\u003e - Use comments consistently and in a readable fashion \u003c/li\u003e\n  \u003cli\u003e MISRA C:2004, 2.3 - The character sequence /* shall not be used within a comment. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 2-7-1 - The character sequence /* shall not be used within a C-style comment. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 3.1 - The character sequences /* and // shall not be used within a comment \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "cert",
      "confusing"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5820",
    "name": "Integer literals should not be cast to bool",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eEven though C++ provides \"true\" and \"false\" as boolean literals, it allows using integer literals in places where boolean type is expected. This\ncan be done through implicit or explicit casting.\u003c/p\u003e\n\u003cp\u003eIn contexts where boolean type is expected, integral literals should be avoided. Using boolean literals instead would make your code more readable\nand less error-prone.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid f(){\n  bool isX \u003d 1; // Noncompliant\n  bool isY \u003d 0; // Noncompliant\n  bool ternaryIsX \u003d isX ? 1 : isY; // Noncompliant\n  bool cCast\u003d (bool)0; // Noncompliant\n  bool cppCast\u003d static_cast\u0026lt;bool\u0026gt;(1); // Noncompliant\n  if(1) { // Noncompliant\n     ...\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid f(){\n bool isX \u003d true;\n bool isY \u003d false;\n bool ternaryIsX \u003d isX ? true : isY;\n bool cCast\u003d false;\n bool cppCast\u003d true;\n if(true) {\n     ...\n  }\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eEven though C++ provides \"true\" and \"false\" as boolean literals, it allows using integer literals in places where boolean type is expected. This\ncan be done through implicit or explicit casting.\u003c/p\u003e\n\u003cp\u003eIn contexts where boolean type is expected, integral literals should be avoided. Using boolean literals instead would make your code more readable\nand less error-prone.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid f(){\n  bool isX \u003d 1; // Noncompliant\n  bool isY \u003d 0; // Noncompliant\n  bool ternaryIsX \u003d isX ? 1 : isY; // Noncompliant\n  bool cCast\u003d (bool)0; // Noncompliant\n  bool cppCast\u003d static_cast\u0026lt;bool\u0026gt;(1); // Noncompliant\n  if(1) { // Noncompliant\n     ...\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid f(){\n bool isX \u003d true;\n bool isY \u003d false;\n bool ternaryIsX \u003d isX ? true : isY;\n bool cCast\u003d false;\n bool cppCast\u003d true;\n if(true) {\n     ...\n  }\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "bad-practice",
      "clumsy"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1578",
    "name": "File names should comply with a naming convention",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "IDENTIFIABLE",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eShared coding conventions allow teams to collaborate effectively. For that reason, file names should conform to a defined standard. This rule\nraises an issue when the names of analyzed files don’t match the provided regular expression.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/GtYxBQ\"\u003eCERT, MSC09-C.\u003c/a\u003e - Character encoding: Use subset of ASCII for safety \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eShared coding conventions allow teams to collaborate effectively. For that reason, file names should conform to a defined standard. This rule\nraises an issue when the names of analyzed files don’t match the provided regular expression.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/GtYxBQ\"\u003eCERT, MSC09-C.\u003c/a\u003e - Character encoding: Use subset of ASCII for safety \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {
      "format": {
        "key": "format",
        "name": "format",
        "description": "POSIX regular expression used to check the file names against.",
        "defaultValue": "^[A-Za-z_-][A-Za-z0-9_-]+\\.(c|m|cpp|cc|cxx)$",
        "type": "STRING",
        "multiple": false,
        "possibleValues": []
      }
    },
    "defaultParams": {
      "format": "^[A-Za-z_-][A-Za-z0-9_-]+\\.(c|m|cpp|cc|cxx)$"
    },
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "cert",
      "convention"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1699",
    "name": "Virtual functions should not be called from constructors or destructors",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhen constructing an object of a derived class, the sub-object of the base class is constructed first, and only then the constructor of the derived\nclass is called. When there are multiple levels of inheritance, the process is the same, from the most base class to the most derived class. Along\nthis construction process, the dynamic type of the object evolves and is the type of the sub-object under construction.\u003c/p\u003e\n\u003cp\u003eThe destruction of the object follows the same process in reverse order.\u003c/p\u003e\n\u003cp\u003eAs a consequence, when calling a virtual function from a constructor or a destructor, the actual function being called is not necessarily the\nversion from the most-derived type, as some developers may believe, but the version that matches the level under construction.\u003c/p\u003e\n\u003cpre\u003e\nstruct A {\n  virtual void f();\n  virtual void g();\n  virtual void h() \u003d 0;\n};\n\nstruct B : public A {\n  B() {\n    f();\n    g();\n  }\n  void f() override;\n};\n\nstruct C : public B {\n  void f() override;\n  void g() override;\n  void h() override;\n};\n\u003c/pre\u003e\n\u003cp\u003eWhen constructing an object of type C, the following occurs:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The sub-object of type \u003ccode\u003eA\u003c/code\u003e is constructed. \u003c/li\u003e\n  \u003cli\u003e The sub-object of type \u003ccode\u003eB\u003c/code\u003e is constructed.\n    \u003cul\u003e\n      \u003cli\u003e The constructor \u003ccode\u003eB::B()\u003c/code\u003e is called, during this call, \u003ccode\u003e*this\u003c/code\u003e is considered as being of type \u003ccode\u003eB\u003c/code\u003e. \u003c/li\u003e\n      \u003cli\u003e The function \u003ccode\u003eB::f()\u003c/code\u003e is called. \u003c/li\u003e\n      \u003cli\u003e The function \u003ccode\u003eA::g()\u003c/code\u003e is called. \u003c/li\u003e\n    \u003c/ul\u003e  \u003c/li\u003e\n  \u003cli\u003e The object of type \u003ccode\u003eC\u003c/code\u003e is constructed. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis surprising behavior can be even worse: If there is no implementation for a virtual function (in the example, if the constructor attempted to\ncall \u003ccode\u003eh()\u003c/code\u003e which is still a pure virtual function) the behavior is undefined.\u003c/p\u003e\n\u003cp\u003eIf you want to perform virtual calls during object construction that will consider the actual type of the object, the best way is probably to defer\nthose calls right after the object is constructed, by using a factory function:\u003c/p\u003e\n\u003cpre\u003e\nstd::unique_ptr\u0026lt;Base\u0026gt; createObjectOfDerivedType(parameters) {\n  auto result \u003d ...;\n  result-\u0026gt;callVirtualFunction();\n  return result;\n}\n\u003c/pre\u003e\n\u003cp\u003eThis rule raises an issue when a non-final virtual function is called from a constructor or a destructor, therefore avoiding all surprising\nbehavior.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass Parent {\n  public:\n    Parent() {\n      f1();\n      f2(); // Noncompliant; confusing because Parent::f2() will always be called even if it is overridden\n    }\n    virtual ~Parent() {\n      f3(); // Noncompliant; undefined behavior\n    }\n\n  private:\n    int          f1();\n    virtual void f2();\n    virtual void f3() \u003d 0; // pure virtual\n};\n\nclass Child : public Parent {\n  public:\n    Child() { // leads to a call to Parent::f2(), not Child::f2()\n      f3(); // Noncompliant; Child::f3() might be further overridden\n    }\n  protected:\n    void f2() override;\n    void f3() override;\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nclass Parent {\n  public:\n    Parent() {\n      f1();\n      Parent::f2(); // acceptable but poor design\n    }\n    virtual ~Parent() {\n      // call to pure virtual function removed\n    }\n  protected:\n    void         f1();\n    virtual void f2();\n    virtual void f3() \u003d 0;\n};\n\nclass Child : public Parent {\n  public:\n    Child() {\n    }\n    virtual ~Child() {\n      f3(); //  // Compliant - Well defined and predictable, a final function cannot be further overridden\n    }\n  protected:\n    void f2() override;\n    void f3() final;\n};\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/6ns-BQ\"\u003eCERT, OOP50-CPP.\u003c/a\u003e - Do not invoke virtual functions from constructors or destructors\n  \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c50-use-a-factory-function-if-you-need-virtual-behavior-during-initialization\"\u003eC.50: Use a factory function if you need \"virtual behavior\" during initialization\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhen constructing an object of a derived class, the sub-object of the base class is constructed first, and only then the constructor of the derived\nclass is called. When there are multiple levels of inheritance, the process is the same, from the most base class to the most derived class. Along\nthis construction process, the dynamic type of the object evolves and is the type of the sub-object under construction.\u003c/p\u003e\n\u003cp\u003eThe destruction of the object follows the same process in reverse order.\u003c/p\u003e\n\u003cp\u003eAs a consequence, when calling a virtual function from a constructor or a destructor, the actual function being called is not necessarily the\nversion from the most-derived type, as some developers may believe, but the version that matches the level under construction.\u003c/p\u003e\n\u003cpre\u003e\nstruct A {\n  virtual void f();\n  virtual void g();\n  virtual void h() \u003d 0;\n};\n\nstruct B : public A {\n  B() {\n    f();\n    g();\n  }\n  void f() override;\n};\n\nstruct C : public B {\n  void f() override;\n  void g() override;\n  void h() override;\n};\n\u003c/pre\u003e\n\u003cp\u003eWhen constructing an object of type C, the following occurs:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The sub-object of type \u003ccode\u003eA\u003c/code\u003e is constructed. \u003c/li\u003e\n  \u003cli\u003e The sub-object of type \u003ccode\u003eB\u003c/code\u003e is constructed.\n    \u003cul\u003e\n      \u003cli\u003e The constructor \u003ccode\u003eB::B()\u003c/code\u003e is called, during this call, \u003ccode\u003e*this\u003c/code\u003e is considered as being of type \u003ccode\u003eB\u003c/code\u003e. \u003c/li\u003e\n      \u003cli\u003e The function \u003ccode\u003eB::f()\u003c/code\u003e is called. \u003c/li\u003e\n      \u003cli\u003e The function \u003ccode\u003eA::g()\u003c/code\u003e is called. \u003c/li\u003e\n    \u003c/ul\u003e  \u003c/li\u003e\n  \u003cli\u003e The object of type \u003ccode\u003eC\u003c/code\u003e is constructed. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis surprising behavior can be even worse: If there is no implementation for a virtual function (in the example, if the constructor attempted to\ncall \u003ccode\u003eh()\u003c/code\u003e which is still a pure virtual function) the behavior is undefined.\u003c/p\u003e\n\u003cp\u003eIf you want to perform virtual calls during object construction that will consider the actual type of the object, the best way is probably to defer\nthose calls right after the object is constructed, by using a factory function:\u003c/p\u003e\n\u003cpre\u003e\nstd::unique_ptr\u0026lt;Base\u0026gt; createObjectOfDerivedType(parameters) {\n  auto result \u003d ...;\n  result-\u0026gt;callVirtualFunction();\n  return result;\n}\n\u003c/pre\u003e\n\u003cp\u003eThis rule raises an issue when a non-final virtual function is called from a constructor or a destructor, therefore avoiding all surprising\nbehavior.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass Parent {\n  public:\n    Parent() {\n      f1();\n      f2(); // Noncompliant; confusing because Parent::f2() will always be called even if it is overridden\n    }\n    virtual ~Parent() {\n      f3(); // Noncompliant; undefined behavior\n    }\n\n  private:\n    int          f1();\n    virtual void f2();\n    virtual void f3() \u003d 0; // pure virtual\n};\n\nclass Child : public Parent {\n  public:\n    Child() { // leads to a call to Parent::f2(), not Child::f2()\n      f3(); // Noncompliant; Child::f3() might be further overridden\n    }\n  protected:\n    void f2() override;\n    void f3() override;\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nclass Parent {\n  public:\n    Parent() {\n      f1();\n      Parent::f2(); // acceptable but poor design\n    }\n    virtual ~Parent() {\n      // call to pure virtual function removed\n    }\n  protected:\n    void         f1();\n    virtual void f2();\n    virtual void f3() \u003d 0;\n};\n\nclass Child : public Parent {\n  public:\n    Child() {\n    }\n    virtual ~Child() {\n      f3(); //  // Compliant - Well defined and predictable, a final function cannot be further overridden\n    }\n  protected:\n    void f2() override;\n    void f3() final;\n};\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/6ns-BQ\"\u003eCERT, OOP50-CPP.\u003c/a\u003e - Do not invoke virtual functions from constructors or destructors\n  \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c50-use-a-factory-function-if-you-need-virtual-behavior-during-initialization\"\u003eC.50: Use a factory function if you need \"virtual behavior\" during initialization\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cert",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S2305",
    "name": "Standard C++ headers should be used",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003eiostream.h\u003c/code\u003e header was provided with the first C++ compiler, CFront, and became the de facto standard. During the formal\nstandardization process of C++, many shortcomings in \u003ccode\u003eiostream.h\u003c/code\u003e were fixed, but at the cost of introducing incompatibilities. Therefore,\nit was decided not to change the existing \u003ccode\u003eiostream.h\u003c/code\u003e and introduce the standard version as a new \u003ccode\u003eiostream\u003c/code\u003e header.\u003c/p\u003e\n\u003cp\u003eModern compilers tend to remove the support of the legacy \u003ccode\u003eiostream.h\u003c/code\u003e header, and migrating to the standard version is encouraged.\u003c/p\u003e\n\u003cp\u003eThis rule applies not only to \u003ccode\u003eiostream\u003c/code\u003e, but to all standard C++ headers.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;iostream.h\u0026gt; // Noncompliant\n#include \u0026lt;fstream.h\u0026gt;  // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;fstream\u0026gt;\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe \u003ccode\u003eiostream.h\u003c/code\u003e header was provided with the first C++ compiler, CFront, and became the de facto standard. During the formal\nstandardization process of C++, many shortcomings in \u003ccode\u003eiostream.h\u003c/code\u003e were fixed, but at the cost of introducing incompatibilities. Therefore,\nit was decided not to change the existing \u003ccode\u003eiostream.h\u003c/code\u003e and introduce the standard version as a new \u003ccode\u003eiostream\u003c/code\u003e header.\u003c/p\u003e\n\u003cp\u003eModern compilers tend to remove the support of the legacy \u003ccode\u003eiostream.h\u003c/code\u003e header, and migrating to the standard version is encouraged.\u003c/p\u003e\n\u003cp\u003eThis rule applies not only to \u003ccode\u003eiostream\u003c/code\u003e, but to all standard C++ headers.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;iostream.h\u0026gt; // Noncompliant\n#include \u0026lt;fstream.h\u0026gt;  // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;fstream\u0026gt;\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "obsolete"
    ],
    "deprecatedKeys": [
      "cpp:PPNonStandardInclude"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S2668",
    "name": "Increment should not be used to set boolean variables to \u0027true\u0027",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eIt is possible to use the increment operator \u003ccode\u003e++\u003c/code\u003e, to set the value of a \u003ccode\u003ebool\u003c/code\u003e(C++) or \u003ccode\u003e_Bool\u003c/code\u003e(C) variable to\n\u003ccode\u003etrue\u003c/code\u003e. But this feature has been deprecated in C++ since the 1998 version of the standard, removed in C++17, and even where allowed, is\nsimply confusing.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nbool alive;\n...\nalive++;\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nbool alive;\n...\nalive \u003d true;\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e ISO/IEC 14882:1998, 5.3.2 \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eIt is possible to use the increment operator \u003ccode\u003e++\u003c/code\u003e, to set the value of a \u003ccode\u003ebool\u003c/code\u003e(C++) or \u003ccode\u003e_Bool\u003c/code\u003e(C) variable to\n\u003ccode\u003etrue\u003c/code\u003e. But this feature has been deprecated in C++ since the 1998 version of the standard, removed in C++17, and even where allowed, is\nsimply confusing.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nbool alive;\n...\nalive++;\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nbool alive;\n...\nalive \u003d true;\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e ISO/IEC 14882:1998, 5.3.2 \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "confusing",
      "obsolete"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S3636",
    "name": "\"const\" and \"volatile\" should not be used in \"enum\" declarations",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eSince C++11, it’s possible to declare the underlying type of an \u003ccode\u003eenum\u003c/code\u003e, and like any type declaration, \u003ccode\u003eenum\u003c/code\u003e declarations\ncan contain the \u003ccode\u003econst\u003c/code\u003e or \u003ccode\u003evolatile\u003c/code\u003e specifier. But because \u003ccode\u003eenum\u003c/code\u003e values are named constants and cannot be\nre-assigned, those specifiers are ignored by the compiler and are therefore useless.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue if \u003ccode\u003econst\u003c/code\u003e or \u003ccode\u003evolatile\u003c/code\u003e is present in the declaration of the underlying type of an\n\u003ccode\u003eenum\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nenum class Color : const long int {  // Noncompliant: Remove this \"const\" specifier.\n  Red   \u003d 0xff0000,\n  Green \u003d 0x00ff00,\n  Blue  \u003d 0x0000ff\n};\n\nenum class Size : volatile char {  // Noncompliant: Remove this \"volatile\" specifier.\n  Small   \u003d \u0027s\u0027,\n  Big     \u003d \u0027b\u0027\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nenum class Color : long int {\n  Red   \u003d 0xff0000,\n  Green \u003d 0x00ff00,\n  Blue  \u003d 0x0000ff\n};\n\nenum class Size : char {\n  Small   \u003d \u0027s\u0027,\n  Big     \u003d \u0027b\u0027\n};\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eSince C++11, it’s possible to declare the underlying type of an \u003ccode\u003eenum\u003c/code\u003e, and like any type declaration, \u003ccode\u003eenum\u003c/code\u003e declarations\ncan contain the \u003ccode\u003econst\u003c/code\u003e or \u003ccode\u003evolatile\u003c/code\u003e specifier. But because \u003ccode\u003eenum\u003c/code\u003e values are named constants and cannot be\nre-assigned, those specifiers are ignored by the compiler and are therefore useless.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue if \u003ccode\u003econst\u003c/code\u003e or \u003ccode\u003evolatile\u003c/code\u003e is present in the declaration of the underlying type of an\n\u003ccode\u003eenum\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nenum class Color : const long int {  // Noncompliant: Remove this \"const\" specifier.\n  Red   \u003d 0xff0000,\n  Green \u003d 0x00ff00,\n  Blue  \u003d 0x0000ff\n};\n\nenum class Size : volatile char {  // Noncompliant: Remove this \"volatile\" specifier.\n  Small   \u003d \u0027s\u0027,\n  Big     \u003d \u0027b\u0027\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nenum class Color : long int {\n  Red   \u003d 0xff0000,\n  Green \u003d 0x00ff00,\n  Blue  \u003d 0x0000ff\n};\n\nenum class Size : char {\n  Small   \u003d \u0027s\u0027,\n  Big     \u003d \u0027b\u0027\n};\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "clumsy",
      "redundant",
      "since-c++11"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5815",
    "name": "Using \"strncat\" or \"wcsncat\" is security-sensitive",
    "defaultSeverity": "MAJOR",
    "type": "SECURITY_HOTSPOT",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "SECURITY": "MEDIUM"
    },
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eIn C, a string is just a buffer of characters, normally using the \u003ccode\u003enull\u003c/code\u003e character as a sentinel for the end of the string. This means\nthat the developer has to be aware of low-level details such as buffer sizes or having an extra character to store the final \u003ccode\u003enull\u003c/code\u003e\ncharacter. Doing that correctly and consistently is notoriously difficult and any error can lead to a security vulnerability, for instance, giving\naccess to sensitive data or allowing arbitrary code execution.\u003c/p\u003e\n\u003cp\u003eThe function \u003ccode\u003echar *strncat( char *restrict dest, const char *restrict src, size_t count );\u003c/code\u003e appends the characters of string\n\u003ccode\u003esrc\u003c/code\u003e at the end of \u003ccode\u003edest\u003c/code\u003e, but only add \u003ccode\u003ecount\u003c/code\u003e characters max. \u003ccode\u003edest\u003c/code\u003e will always be\n\u003ccode\u003enull\u003c/code\u003e-terminated. The \u003ccode\u003ewcsncat\u003c/code\u003e does the same for wide characters, and should be used with the same guidelines.\u003c/p\u003e"
      },
      {
        "key": "assess_the_problem",
        "htmlContent": "\u003ch2\u003eAsk Yourself Whether\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e There is a possibility that either the \u003ccode\u003esrc\u003c/code\u003e or the \u003ccode\u003edest\u003c/code\u003e pointer is \u003ccode\u003enull\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e The current string length of \u003ccode\u003edest\u003c/code\u003e plus the current string length of \u003ccode\u003esrc\u003c/code\u003e plus 1 (for the final \u003ccode\u003enull\u003c/code\u003e\n  character) is larger than the size of the buffer pointer-to by \u003ccode\u003esrc\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e There is a possibility that either string is not correctly \u003ccode\u003enull\u003c/code\u003e-terminated \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere is a risk if you answered yes to any of those questions.\u003c/p\u003e\n\u003ch2\u003eSensitive Code Example\u003c/h2\u003e\n\u003cpre\u003e\nint f(char *src) {\n  char dest[256];\n  strcpy(dest, \"Result: \");\n  strncat(dest, src, sizeof dest); // Sensitive: passing the buffer size instead of the remaining size\n  return doSomethingWith(dest);\n}\n\u003c/pre\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003ch2\u003eRecommended Secure Coding Practices\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C11 provides, in its annex K, the \u003ccode\u003estrncat_s\u003c/code\u003e and the \u003ccode\u003ewcsncat_s\u003c/code\u003e that were designed as safer alternatives to\n  \u003ccode\u003estrncat\u003c/code\u003e and \u003ccode\u003ewcsncat\u003c/code\u003e. It’s not recommended to use them in all circumstances because they introduce a runtime overhead and\n  require to write more code for error handling, but they perform checks that will limit the consequences of calling the function with bad arguments.\n  \u003c/li\u003e\n  \u003cli\u003e Even if your compiler does not exactly support annex K, you probably have access to similar functions \u003c/li\u003e\n  \u003cli\u003e If you are using \u003ccode\u003estrncat\u003c/code\u003e and \u003ccode\u003ewsncat\u003c/code\u003e as a safer version of \u003ccode\u003estrcat\u003c/code\u003e and \u003ccode\u003ewcscat\u003c/code\u003e, you should\n  instead consider \u003ccode\u003estrcat_s\u003c/code\u003e and \u003ccode\u003ewcscat_s\u003c/code\u003e because these functions have several shortcomings:\n    \u003cul\u003e\n      \u003cli\u003e It’s not easy to detect truncation \u003c/li\u003e\n      \u003cli\u003e The \u003ccode\u003ecount\u003c/code\u003e parameter is error-prone \u003c/li\u003e\n      \u003cli\u003e Computing the \u003ccode\u003ecount\u003c/code\u003e parameter typically requires computing the string length of \u003ccode\u003edest\u003c/code\u003e, at which point other\n      simpler alternatives exist \u003c/li\u003e\n    \u003c/ul\u003e  \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eCompliant Solution\u003c/h2\u003e\n\u003cpre\u003e\nint f(char *src) {\n  char result[] \u003d \"Result: \";\n  char dest[256];\n  strcpy(dest, result);\n  strncat(dest, src, sizeof dest - sizeof result); // Compliant but may silently truncate\n  return doSomethingWith(dest);\n}\n\u003c/pre\u003e\n\u003ch2\u003eSee\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/Top10/A06_2021-Vulnerable_and_Outdated_Components/\"\u003eOWASP Top 10 2021 Category A6\u003c/a\u003e - Vulnerable and Outdated\n  Components \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/www-project-top-ten/2017/A9_2017-Using_Components_with_Known_Vulnerabilities\"\u003eOWASP Top 10 2017 Category A9\u003c/a\u003e -\n  Using Components with Known Vulnerabilities \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/120\"\u003eMITRE, CWE-120\u003c/a\u003e - Buffer Copy without Checking Size of Input (\u0027Classic Buffer\n  Overflow\u0027) \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/HdcxBQ\"\u003eCERT, STR07-C.\u003c/a\u003e - Use the bounds-checking interfaces for string manipulation \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cert",
      "cwe"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": [],
    "vulnerabilityProbability": "HIGH"
  },
  {
    "key": "cpp:S2304",
    "name": "Namespace names should comply with a naming convention",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "IDENTIFIABLE",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eShared coding conventions allow teams to collaborate efficiently. This rule checks that all namespace names match a provided regular\nexpression.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cp\u003eWith the default regular expression \u003ccode\u003e^[a-z][a-z_0-9]*$\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\nnamespace Foo // Noncompliant\n{\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nnamespace foo\n{\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eShared coding conventions allow teams to collaborate efficiently. This rule checks that all namespace names match a provided regular\nexpression.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cp\u003eWith the default regular expression \u003ccode\u003e^[a-z][a-z_0-9]*$\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\nnamespace Foo // Noncompliant\n{\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nnamespace foo\n{\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {
      "format": {
        "key": "format",
        "name": "format",
        "description": "POSIX regular expression used to check the namespace names against",
        "defaultValue": "^[a-z][a-z_0-9]*$",
        "type": "STRING",
        "multiple": false,
        "possibleValues": []
      }
    },
    "defaultParams": {
      "format": "^[a-z][a-z_0-9]*$"
    },
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "convention"
    ],
    "deprecatedKeys": [
      "cpp:NamespaceName"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5816",
    "name": "Using \"strncpy\" or \"wcsncpy\" is security-sensitive",
    "defaultSeverity": "MAJOR",
    "type": "SECURITY_HOTSPOT",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "SECURITY": "MEDIUM"
    },
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eIn C, a string is just a buffer of characters, normally using the \u003ccode\u003enull\u003c/code\u003e character as a sentinel for the end of the string. This means\nthat the developer has to be aware of low-level details such as buffer sizes or having an extra character to store the final \u003ccode\u003enull\u003c/code\u003e\ncharacter. Doing that correctly and consistently is notoriously difficult and any error can lead to a security vulnerability, for instance, giving\naccess to sensitive data or allowing arbitrary code execution.\u003c/p\u003e\n\u003cp\u003eThe function \u003ccode\u003echar *strncpy(char * restrict dest, const char * restrict src, size_t count);\u003c/code\u003e copies the first \u003ccode\u003ecount\u003c/code\u003e\ncharacters from \u003ccode\u003esrc\u003c/code\u003e to \u003ccode\u003edest\u003c/code\u003e, stopping at the first \u003ccode\u003enull\u003c/code\u003e character, and filling extra space with 0. The\n\u003ccode\u003ewcsncpy\u003c/code\u003e does the same for wide characters and should be used with the same guidelines.\u003c/p\u003e\n\u003cp\u003eBoth of those functions are designed to work with fixed-length strings and might result in a non-\u003ccode\u003enull\u003c/code\u003e-terminated string.\u003c/p\u003e"
      },
      {
        "key": "assess_the_problem",
        "htmlContent": "\u003ch2\u003eAsk Yourself Whether\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e There is a possibility that either the \u003ccode\u003esource\u003c/code\u003e or the \u003ccode\u003edestination\u003c/code\u003e pointer is \u003ccode\u003enull\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e The security of your system can be compromised if the \u003ccode\u003edestination\u003c/code\u003e is a truncated version of the \u003ccode\u003esource\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e The \u003ccode\u003esource\u003c/code\u003e buffer can be both non-\u003ccode\u003enull\u003c/code\u003e-terminated and smaller than the \u003ccode\u003ecount\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e The \u003ccode\u003edestination\u003c/code\u003e buffer can be smaller than the \u003ccode\u003ecount\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e You expect \u003ccode\u003edest\u003c/code\u003e to be a \u003ccode\u003enull\u003c/code\u003e-terminated string \u003c/li\u003e\n  \u003cli\u003e There is an overlap between the \u003ccode\u003esource\u003c/code\u003e and the \u003ccode\u003edestination\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere is a risk if you answered yes to any of those questions.\u003c/p\u003e\n\u003ch2\u003eSensitive Code Example\u003c/h2\u003e\n\u003cpre\u003e\nint f(char *src) {\n  char dest[256];\n  strncpy(dest, src, sizeof(dest)); // Sensitive: might silently truncate\n  return doSomethingWith(dest);\n}\n\u003c/pre\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003ch2\u003eRecommended Secure Coding Practices\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C11 provides, in its annex K, the \u003ccode\u003estrncpy_s\u003c/code\u003e and the \u003ccode\u003ewcsncpy_s\u003c/code\u003e that were designed as safer alternatives to\n  \u003ccode\u003estrcpy\u003c/code\u003e and \u003ccode\u003ewcscpy\u003c/code\u003e. It’s not recommended to use them in all circumstances, because they introduce a runtime overhead and\n  require to write more code for error handling, but they perform checks that will limit the consequences of calling the function with bad arguments.\n  \u003c/li\u003e\n  \u003cli\u003e Even if your compiler does not exactly support annex K, you probably have access to similar functions \u003c/li\u003e\n  \u003cli\u003e If you are using \u003ccode\u003estrncpy\u003c/code\u003e and \u003ccode\u003ewsncpy\u003c/code\u003e as a safer version of \u003ccode\u003estrcpy\u003c/code\u003e and \u003ccode\u003ewcscpy\u003c/code\u003e, you should\n  instead consider \u003ccode\u003estrcpy_s\u003c/code\u003e and \u003ccode\u003ewcscpy_s\u003c/code\u003e, because these functions have several shortcomings:\n    \u003cul\u003e\n      \u003cli\u003e It’s not easy to detect truncation \u003c/li\u003e\n      \u003cli\u003e Too much work is done to fill the buffer with 0, leading to suboptimal performance \u003c/li\u003e\n      \u003cli\u003e Unless manually corrected, the \u003ccode\u003edest\u003c/code\u003e string might not be \u003ccode\u003enull\u003c/code\u003e-terminated \u003c/li\u003e\n    \u003c/ul\u003e  \u003c/li\u003e\n  \u003cli\u003e If you want to use \u003ccode\u003estrcpy\u003c/code\u003e and \u003ccode\u003ewcscpy\u003c/code\u003e functions and detect if the string was truncated, the pattern is the following:\n    \u003cul\u003e\n      \u003cli\u003e Set the last character of the buffer to \u003ccode\u003enull\u003c/code\u003e \u003c/li\u003e\n      \u003cli\u003e Call the function \u003c/li\u003e\n      \u003cli\u003e Check if the last character of the buffer is still \u003ccode\u003enull\u003c/code\u003e \u003c/li\u003e\n    \u003c/ul\u003e  \u003c/li\u003e\n  \u003cli\u003e If you are writing C++ code, using \u003ccode\u003estd::string\u003c/code\u003e to manipulate strings is much simpler and less error-prone \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eCompliant Solution\u003c/h2\u003e\n\u003cpre\u003e\nint f(char *src) {\n  char dest[256];\n  dest[sizeof dest - 1] \u003d 0;\n  strncpy(dest, src, sizeof(dest)); // Compliant\n  if (dest[sizeof dest - 1] !\u003d 0) {\n    // Handle error\n  }\n  return doSomethingWith(dest);\n}\n\u003c/pre\u003e\n\u003ch2\u003eSee\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/Top10/A06_2021-Vulnerable_and_Outdated_Components/\"\u003eOWASP Top 10 2021 Category A6\u003c/a\u003e - Vulnerable and Outdated\n  Components \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/www-project-top-ten/2017/A9_2017-Using_Components_with_Known_Vulnerabilities\"\u003eOWASP Top 10 2017 Category A9\u003c/a\u003e -\n  Using Components with Known Vulnerabilities \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/120\"\u003eMITRE, CWE-120\u003c/a\u003e - Buffer Copy without Checking Size of Input (\u0027Classic Buffer\n  Overflow\u0027) \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/HdcxBQ\"\u003eCERT, STR07-C.\u003c/a\u003e - Use the bounds-checking interfaces for string manipulation \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cert",
      "cwe"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": [],
    "vulnerabilityProbability": "HIGH"
  },
  {
    "key": "cpp:S5813",
    "name": "Using \"strlen\" or \"wcslen\" is security-sensitive",
    "defaultSeverity": "MAJOR",
    "type": "SECURITY_HOTSPOT",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "SECURITY": "MEDIUM"
    },
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe function \u003ccode\u003esize_t strlen(const char *s)\u003c/code\u003e measures the length of the string \u003ccode\u003es\u003c/code\u003e (excluding the final null character).\u003cbr\u003e\nThe function \u003ccode\u003esize_t wcslen(const wchar_t *s)\u003c/code\u003e does the same for wide characters, and should be used with the same guidelines.\u003c/p\u003e\n\u003cp\u003eSimilarly to many other functions in the standard C libraries, \u003ccode\u003estrlen\u003c/code\u003e and \u003ccode\u003ewcslen\u003c/code\u003e assume that their argument is not a null\npointer.\u003c/p\u003e\n\u003cp\u003eAdditionally, they expect the strings to be null-terminated. For example, the 5-letter string \"abcde\" must be stored in memory as \"abcde\\0\" (i.e.\nusing 6 characters) to be processed correctly. When a string is missing the null character at the end, these functions will iterate past the end of\nthe buffer, which is undefined behavior.\u003c/p\u003e\n\u003cp\u003eTherefore, string parameters must end with a proper null character. The absence of this particular character can lead to security vulnerabilities\nthat allow, for example, access to sensitive data or the execution of arbitrary code.\u003c/p\u003e"
      },
      {
        "key": "assess_the_problem",
        "htmlContent": "\u003ch2\u003eAsk Yourself Whether\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e There is a possibility that the pointer is null. \u003c/li\u003e\n  \u003cli\u003e There is a possibility that the string is not correctly null-terminated. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere is a risk if you answered yes to any of those questions.\u003c/p\u003e\n\u003ch2\u003eSensitive Code Example\u003c/h2\u003e\n\u003cpre\u003e\nsize_t f(char *src) {\n  char dest[256];\n  strncpy(dest, src, sizeof dest); // Truncation may happen\n  return strlen(dest); // Sensitive: \"dest\" will not be null-terminated if truncation happened\n}\n\u003c/pre\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003ch2\u003eRecommended Secure Coding Practices\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e Use safer functions. The C11 functions \u003ccode\u003estrlen_s\u003c/code\u003e and \u003ccode\u003ewcslen_s\u003c/code\u003e from annex K handle typical programming errors.\u003cbr\u003e\n  Note, however, that they have a runtime overhead and require more code for error handling and therefore are not suited to every case. \u003c/li\u003e\n  \u003cli\u003e Even if your compiler does not exactly support annex K, you probably have access to similar functions. \u003c/li\u003e\n  \u003cli\u003e If you are writing C++ code, using \u003ccode\u003estd::string\u003c/code\u003e to manipulate strings is much simpler and less error-prone. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eCompliant Solution\u003c/h2\u003e\n\u003cpre\u003e\nsize_t f(char *src) {\n  char dest[256];\n  strncpy(dest, src, sizeof dest); // Truncation may happen\n  dest[sizeof dest - 1] \u003d 0;\n  return strlen(dest); // Compliant: \"dest\" is guaranteed to be null-terminated\n}\n\u003c/pre\u003e\n\u003ch2\u003eSee\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/120\"\u003eMITRE, CWE-120\u003c/a\u003e - Buffer Copy without Checking Size of Input (\u0027Classic Buffer\n  Overflow\u0027) \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/HdcxBQ\"\u003eCERT, STR07-C.\u003c/a\u003e - Use the bounds-checking interfaces for string manipulation \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cert",
      "cwe"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": [],
    "vulnerabilityProbability": "HIGH"
  },
  {
    "key": "cpp:S3516",
    "name": "Methods returns should not be invariant",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhen a method is designed to return an invariant value, it may be poor design, but it shouldn’t adversely affect the outcome of your program.\nHowever, when it happens on all paths through the logic, it is surely a bug.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when a method contains several \u003ccode\u003ereturn\u003c/code\u003e statements that all return the same value.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint foo(int a) {\n  int b \u003d 12;\n  if (a \u003d\u003d 1) {\n    return b;\n  }\n  return b;  // Noncompliant\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhen a method is designed to return an invariant value, it may be poor design, but it shouldn’t adversely affect the outcome of your program.\nHowever, when it happens on all paths through the logic, it is surely a bug.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when a method contains several \u003ccode\u003ereturn\u003c/code\u003e statements that all return the same value.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint foo(int a) {\n  int b \u003d 12;\n  if (a \u003d\u003d 1) {\n    return b;\n  }\n  return b;  // Noncompliant\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5814",
    "name": "Using \"strcat\" or \"wcscat\" is security-sensitive",
    "defaultSeverity": "MAJOR",
    "type": "SECURITY_HOTSPOT",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "SECURITY": "MEDIUM"
    },
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eIn C, a string is just a buffer of characters, normally using the \u003ccode\u003enull\u003c/code\u003e character as a sentinel for the end of the string. This means\nthat the developer has to be aware of low-level details such as buffer sizes or having an extra character to store the final \u003ccode\u003enull\u003c/code\u003e\ncharacter. Doing that correctly and consistently is notoriously difficult and any error can lead to a security vulnerability, for instance, giving\naccess to sensitive data or allowing arbitrary code execution.\u003c/p\u003e\n\u003cp\u003eThe function \u003ccode\u003echar *strcat( char *restrict dest, const char *restrict src );\u003c/code\u003e appends the characters of string \u003ccode\u003esrc\u003c/code\u003e at the\nend of \u003ccode\u003edest\u003c/code\u003e. The \u003ccode\u003ewcscat\u003c/code\u003e does the same for wide characters and should be used with the same guidelines.\u003c/p\u003e\n\u003cp\u003eNote: the functions \u003ccode\u003estrncat\u003c/code\u003e and \u003ccode\u003ewcsncat\u003c/code\u003e might look like attractive safe replacements for \u003ccode\u003estrcat\u003c/code\u003e and\n\u003ccode\u003ewcscaty\u003c/code\u003e, but they have their own set of issues (see {rule:cpp:S5815}), and you should probably prefer another more adapted\nalternative.\u003c/p\u003e"
      },
      {
        "key": "assess_the_problem",
        "htmlContent": "\u003ch2\u003eAsk Yourself Whether\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e There is a possibility that either the \u003ccode\u003esrc\u003c/code\u003e or the \u003ccode\u003edest\u003c/code\u003e pointer is \u003ccode\u003enull\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e The current string length of \u003ccode\u003edest\u003c/code\u003e plus the current string length of \u003ccode\u003esrc\u003c/code\u003e plus 1 (for the final\u0026nbsp;\u003ccode\u003enull\u003c/code\u003e\n  character) is larger than the size of the buffer pointer-to by \u003ccode\u003esrc\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e There is a possibility that either string is not correctly \u003ccode\u003enull\u003c/code\u003e-terminated \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere is a risk if you answered yes to any of those questions.\u003c/p\u003e\n\u003ch2\u003eSensitive Code Example\u003c/h2\u003e\n\u003cpre\u003e\nint f(char *src) {\n  char dest[256];\n  strcpy(dest, \"Result: \");\n  strcat(dest, src); // Sensitive: might overflow\n  return doSomethingWith(dest);\n}\n\u003c/pre\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003ch2\u003eRecommended Secure Coding Practices\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C11 provides, in its annex K, the \u003ccode\u003estrcat_s\u003c/code\u003e and the \u003ccode\u003ewcscat_s\u003c/code\u003e that were designed as safer alternatives to\n  \u003ccode\u003estrcat\u003c/code\u003e and \u003ccode\u003ewcscat\u003c/code\u003e. It’s not recommended to use them in all circumstances, because they introduce a runtime overhead and\n  require to write more code for error handling, but they perform checks that will limit the consequences of calling the function with bad arguments.\n  \u003c/li\u003e\n  \u003cli\u003e Even if your compiler does not exactly support annex K, you probably have access to similar functions \u003c/li\u003e\n  \u003cli\u003e If you are writing C++ code, using \u003ccode\u003estd::string\u003c/code\u003e to manipulate strings is much simpler and less error-prone \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eCompliant Solution\u003c/h2\u003e\n\u003cpre\u003e\nint f(char *src) {\n  char result[] \u003d \"Result: \";\n  char *dest \u003d malloc(sizeof(result) + strlen(src)); // Not need of +1 for final 0 because sizeof will already count one 0\n  strcpy(dest, result);\n  strcat(dest, src); // Compliant: the buffer size was carefully crafted\n  int r \u003d doSomethingWith(dest);\n  free(dest);\n  return r;\n}\n\u003c/pre\u003e\n\u003ch2\u003eSee\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/Top10/A06_2021-Vulnerable_and_Outdated_Components/\"\u003eOWASP Top 10 2021 Category A6\u003c/a\u003e - Vulnerable and Outdated\n  Components \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/www-project-top-ten/2017/A9_2017-Using_Components_with_Known_Vulnerabilities\"\u003eOWASP Top 10 2017 Category A9\u003c/a\u003e -\n  Using Components with Known Vulnerabilities \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/120\"\u003eMITRE, CWE-120\u003c/a\u003e - Buffer Copy without Checking Size of Input (\u0027Classic Buffer\n  Overflow\u0027) \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/HdcxBQ\"\u003eCERT, STR07-C.\u003c/a\u003e - Use the bounds-checking interfaces for string manipulation \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cert",
      "cwe"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": [],
    "vulnerabilityProbability": "HIGH"
  },
  {
    "key": "cpp:S1219",
    "name": "\"switch\" statements should not contain non-case labels",
    "defaultSeverity": "BLOCKER",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eEven if it is legal, mixing case and non-case labels in the body of a switch statement is very confusing and can even be the result of a typing\nerror.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cp\u003eThe code is syntactically correct but the behavior is not the expected one\u003c/p\u003e\n\u003cpre\u003e\nswitch (day) {\n  case MONDAY:\n  case TUESDAY:\n  WEDNESDAY:   // instead of \"case WEDNESDAY\"\n    doSomething();\n    break;\n  ...\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nswitch (day) {\n  case MONDAY:\n  case TUESDAY:\n  case WEDNESDAY:\n    doSomething();\n    break;\n  ...\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 15.0 - The MISRA C \u003cem\u003eswitch\u003c/em\u003e syntax shall be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 6-4-3 - A switch statement shall be a well-formed switch statement. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 16.1 - All switch statements shall be well-formed \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eEven if it is legal, mixing case and non-case labels in the body of a switch statement is very confusing and can even be the result of a typing\nerror.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cp\u003eThe code is syntactically correct but the behavior is not the expected one\u003c/p\u003e\n\u003cpre\u003e\nswitch (day) {\n  case MONDAY:\n  case TUESDAY:\n  WEDNESDAY:   // instead of \"case WEDNESDAY\"\n    doSomething();\n    break;\n  ...\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nswitch (day) {\n  case MONDAY:\n  case TUESDAY:\n  case WEDNESDAY:\n    doSomething();\n    break;\n  ...\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 15.0 - The MISRA C \u003cem\u003eswitch\u003c/em\u003e syntax shall be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 6-4-3 - A switch statement shall be a well-formed switch statement. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 16.1 - All switch statements shall be well-formed \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S3519",
    "name": "Memory access should be explicitly bounded to prevent buffer overflows",
    "defaultSeverity": "BLOCKER",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003cp\u003eMemory accesses should be bounded to prevent buffer overflows.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eArray overruns and buffer overflows occur when a memory access accidentally goes beyond the boundary of the allocated array or buffer.\u003c/p\u003e\n\u003cp\u003eThese overreaching accesses cause some of the most damaging and hard to track defects. Not only do these faulty accesses constitute undefined\nbehavior, but they frequently introduce security vulnerabilities, too.\u003c/p\u003e\n\u003ch2\u003eWhat is the potential impact?\u003c/h2\u003e\n\u003cp\u003eAccessing memory that goes beyond the boundary of the allocated array or buffer results in undefined behavior.\u003c/p\u003e\n\u003cp\u003eFor programs that exercise undefined behavior, the compiler is no longer bound by the language specification. The application may crash or, even\nworse, the application may appear to execute correctly while losing data or producing incorrect results.\u003c/p\u003e\n\u003cp\u003eOut-of-bounds memory accesses cause some of the most damaging and hard-to-track defects. Unbounded memory accesses may also introduce severe\nsecurity vulnerabilities. In case a user of the program can control the contents of a buffer, for instance, a malicious attacker can use the buffer\noverflow to overwrite critical data, leak secret or private information, execute arbitrary code, or gain unauthorized access to the system.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eEnsure that memory accesses are within the bounds of the allocated array or buffer.\u003c/p\u003e\n\u003cp\u003eIf C++ is available, use the \u003ccode\u003estd::array\u003c/code\u003e or \u003ccode\u003estd::vector\u003c/code\u003e types to manage stack or heap-based arrays, respectively and use\n\u003ccode\u003estd::string\u003c/code\u003e to manage string buffers.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid access_exceeds(void) {\n  int id_sequence[3];\n  id_sequence[0] \u003d 100;\n  id_sequence[1] \u003d 200;\n  id_sequence[2] \u003d 300;\n  id_sequence[3] \u003d 400; // Noncompliant: memory access is out of bounds\n  // Accessed memory exceeds upper limit of memory block\n}\n\nvoid access_precedes(int x) {\n  int buf[100];\n  int *p \u003d buf;\n  --p;\n  p[0] \u003d 9001; // Noncompliant: memory access is out of bounds\n  // Accessed memory precedes memory block\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid access_exceeds(void) {\n  int id_sequence[3];\n  // Compliant: all memory accesses are within valid bounds between 0 and 2\n  id_sequence[0] \u003d 100;\n  id_sequence[1] \u003d 200;\n  id_sequence[2] \u003d 300;\n}\n\nvoid access_precedes(int x) {\n  int buf[100];\n  int *p \u003d buf;\n  p[0] \u003d 9001; // Compliant: memory access within valid bounds\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;string.h\u0026gt;\n\nvoid memcpy_fun(void) {\n  char src[] \u003d {1, 2, 3, 4};\n  char dst[10];\n  memcpy(dst, src, 5); // Noncompliant: memory copy function accesses out-of-bound array element\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;string.h\u0026gt;\n\nvoid memcpy_fun(void) {\n  char src[] \u003d {1, 2, 3, 4};\n  char dst[10];\n  memcpy(dst, src, sizeof(src)); // Compliant: memory copy function accesses only valid array elements\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n\nint fun(void) {\n  char buffer[64] \u003d {0};\n  if (fgets(buffer, 2048, stdin) !\u003d NULL) { // Noncompliant: target buffer may overflow\n    printf(\"buffer contents: %s\", buffer);\n    return 0;\n  }\n  return 1;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n\nint fun(void) {\n  char buffer[64] \u003d {0};\n  if (fgets(buffer, 64, stdin) !\u003d NULL) { // Compliant: reads at most 64 - 1 characters\n    printf(\"buffer contents: %s\", buffer);\n    return 0;\n  }\n  return 1;\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"4\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n#include \u0026lt;string.h\u0026gt;\n\nint foo(void) {\n  const char *const str \u003d \"AAAA\"\n                          \"BBBB\"\n                          \"CCCC\"\n                          \"DDDD\";\n  size_t str_len \u003d strlen(str);\n  char *buf1 \u003d (char *)malloc(str_len + /*null terminator*/ 1);\n  if (buf1 \u003d\u003d NULL) { return 1; }\n  memset(buf1, 0, str_len + 1);\n  strncpy(buf1, str, str_len);\n  char buf2[8] \u003d {0};\n  memcpy(buf2, buf1, str_len + 1); // Noncompliant: buf2 will overflow.\n  printf(\"buf1: %s\\n\", buf1);\n  printf(\"buf2: %s\\n\", buf2);\n  free(buf1);\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"4\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n#include \u0026lt;string.h\u0026gt;\n\nint foo(void) {\n  const char *const str \u003d \"AAAA\"\n                          \"BBBB\"\n                          \"CCCC\"\n                          \"DDDD\";\n  size_t str_len \u003d strlen(str);\n  char *buf1 \u003d (char *)malloc(str_len + /*null terminator*/ 1);\n  if (buf1 \u003d\u003d NULL) { return 1; }\n  memset(buf1, 0, str_len + 1);\n  strncpy(buf1, str, str_len + 1);\n  char buf2[8] \u003d {0};\n  // Compliant: copy only `sizeof(buf2) - 1` bytes and leave the last\n  // terminating null byte (\u0027\\0\u0027) untouched such that `buf2` can be correctly\n  // printed in the subsequent lines.\n  memcpy(buf2, buf1,  sizeof(buf2) - 1);\n  printf(\"buf1: %s\\n\", buf1);\n  printf(\"buf2: %s\\n\", buf2);\n  free(buf1);\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"5\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n\nvoid bar(void) {\n  int array[8] \u003d {1, 2, 3, 4, 5, 6, 7, 8};\n  array[8] \u003d 42; // Noncompliant: index should be between 0 and 7\n  for (size_t i \u003d 0; i \u0026lt; 8; ++i) {\n    printf(\"%d\\n\", array[i]); // Compliant: index is between 0 and 7\n  }\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"5\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n\nvoid bar(void) {\n  int array[8] \u003d {1, 2, 3, 4, 5, 6, 7, 8};\n  array[7] \u003d 42; // Compliant: index is between 0 and 7\n  for (size_t i \u003d 0; i \u0026lt; 8; ++i) {\n    printf(\"%d\\n\", array[i]); // Compliant: index is between 0 and 7\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003ePitfalls\u003c/h3\u003e\n\u003cp\u003eWhen managing and manipulating string buffers one needs to take great care that the buffers are correctly terminated with a null byte\n(\u003ccode\u003e\u0027\\0\u0027\u003c/code\u003e). Failing to correctly null terminate string buffers almost always causes buffer overruns and introduces undefined behavior.\u003c/p\u003e\n\u003cp\u003eThe following faulty program aims at creating a string copy. However, the heap-allocated memory buffer for holding the copy is too small since\n\u003ccode\u003estrlen\u003c/code\u003e calculates the length of its input string but excludes the \"invisible\" terminating null byte (\u003ccode\u003e\u0027\\0\u0027\u003c/code\u003e). The call to\n\u003ccode\u003estrncpy\u003c/code\u003e also uses the string length computed by \u003ccode\u003estrlen\u003c/code\u003e and the string copy hence lacks an implicitly copied null terminator.\nThis causes out-of-bounds reads and introduces undefined behavior in the subsequent processing steps. In this example, the call to \u003ccode\u003eprintf\u003c/code\u003e\nwill eventually trigger such erroneous behavior.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"6\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n#include \u0026lt;string.h\u0026gt;\n\nchar *make_str_copy(const char *const src) {\n  size_t src_len \u003d strlen(src);\n  char *dst \u003d (char *)malloc(src_len); // buffer too small to hold null terminator\n  if (dst \u003d\u003d NULL) {\n    perror(\"malloc failed\");\n    exit(1);\n  }\n  strncpy(dst, src, src_len); // null terminator is not (implicitly) copied either\n  return dst;\n}\n\nint main(void) {\n  const char str[] \u003d \"Hello, World!\";\n  char *str_copy \u003d make_str_copy(str);\n  // call to `printf` will trigger undefined behavior due to missing null terminator\n  printf(\"%s\\n\", str_copy); // Noncompliant: `str_copy` has not been null terminated\n  // More code that processes `str_copy` ...\n  free(str_copy);\n  return 0;\n}\n\u003c/pre\u003e\n\u003cp\u003eThe following fixed version of the program does correctly allocate a heap-based buffer of sufficient size \u003cem\u003eand\u003c/em\u003e (explicitly) terminates it\nwith a null byte (\u003ccode\u003e\u0027\\0\u0027\u003c/code\u003e):\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"6\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n#include \u0026lt;string.h\u0026gt;\n\nchar *make_str_copy(const char *const src) {\n  size_t src_len \u003d strlen(src);\n  // `src_len + 1` since `strlen` _excludes_ the terminating null byte\n  char *dst \u003d (char *)malloc(src_len + 1);\n  if (dst \u003d\u003d NULL) {\n    perror(\"malloc failed\");\n    exit(1);\n  }\n  dst[src_len] \u003d \u0027\\0\u0027; // explicitly add a null terminator\n  strncpy(dst, src, src_len);\n  return dst;\n}\n\nint main(void) {\n  const char str[] \u003d \"Hello, World!\";\n  char *str_copy \u003d make_str_copy(str);\n  printf(\"%s\\n\", str_copy); // Compliant: `str_copy` has been correctly null terminated\n  // More code that processes `str_copy` ...\n  free(str_copy);\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch3\u003eGoing the extra mile\u003c/h3\u003e\n\u003cp\u003eBuffer overflows occur when a program writes data beyond the boundaries of a buffer and can lead to memory corruption and potential security\nvulnerabilities. To mitigate this risk, developers must carefully manage array and buffer sizes. This includes using secure coding practices, and\nemploying techniques like input validation and bounds checking.\u003c/p\u003e\n\u003cp\u003eVarious modern C and C++ compilers allow one to automatically instrument a program during compilation using so-called \u003cem\u003esanitizers\u003c/em\u003e. The\naddress and undefined behavior sanitizers, for instance, aim at detecting out-of-bound memory accesses and undefined behavior, respectively. If the\ninstrumentation detects an error at runtime, the program will abort with an error message that provides valuable information for identifying and\nfixing the error.\u003c/p\u003e\n\u003cp\u003eAdditional capabilities of modern compilers that aim at hardening the binary include the \u003ccode\u003eFORTIFY_SOURCE\u003c/code\u003e compilation flag, or features\nsuch as stack canaries or address space layout randomization (ASLR). These hardening features provide some lightweight support for detecting buffer\noverflows.\u003c/p\u003e\n\u003cp\u003eYet another programming tool for memory debugging is Valgrind. Valgrind inspects a programming during its execution and is capable of detecting\nvarious memory-related issues including buffer overflows.\u003c/p\u003e\n\u003cp\u003eIn C++, manual array or string, i.e., buffer manipulations are considered a code smell.\u003c/p\u003e\n\u003cp\u003eInstead, the \u003ccode\u003estd::array\u003c/code\u003e type should be used to manage stack-based arrays, and the \u003ccode\u003estd::vector\u003c/code\u003e type should be used if a\nheap-based array is desired. Besides always carrying their respective sizes, i.e., number of elements, \u003ccode\u003estd::array\u003c/code\u003e and\n\u003ccode\u003estd::vector\u003c/code\u003e implement many useful member functions such as \u003ccode\u003ebegin()\u003c/code\u003e and \u003ccode\u003eend()\u003c/code\u003e, allowing one to safely and\nconveniently process them using algorithms from the C++\u0027s \u003ccode\u003e\u0026lt;algorithm\u0026gt;\u003c/code\u003e header, for instance. An example is shown in the\nfollowing:\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;algorithm\u0026gt;\n#include \u0026lt;array\u0026gt;\n#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;numeric\u0026gt;\n#include \u0026lt;vector\u0026gt;\n\nvoid bar() {\n  // stack-based array\n  std::array\u0026lt;int, 8\u0026gt; stack_buf;\n  std::fill(stack_buf.begin(), stack_buf.end(), 42);\n  for (auto i : stack_buf) {\n    std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0027 \u0027;\n  }\n  std::cout \u0026lt;\u0026lt; \u0027\\n\u0027;\n  std::cout \u0026lt;\u0026lt; \"sum of stack_buf\u0027s values: \"\n            \u0026lt;\u0026lt; std::accumulate(stack_buf.begin(), stack_buf.end(), 0) \u0026lt;\u0026lt; \u0027\\n\u0027;\n  // heap-based array\n  std::vector\u0026lt;int\u0026gt; heap_buf \u003d {1, 2, 3, 4};\n  heap_buf.resize(10);\n  std::iota(heap_buf.begin(), heap_buf.end(), 1);\n  std::cout \u0026lt;\u0026lt; \"sum of heap_buf\u0027s values: \"\n            \u0026lt;\u0026lt; std::accumulate(heap_buf.begin(), heap_buf.end(), 0) \u0026lt;\u0026lt; \u0027\\n\u0027;\n}\n\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003estd::string\u003c/code\u003e type should be used to manage buffers since it facilitates safe buffer manipulations. Instead of manually\nconcatenating two buffers using \u003ccode\u003estrncat\u003c/code\u003e, for instance, \u003ccode\u003estd::string\u003c/code\u003e allows this operation to be performed in a much more\nconvenient manner as shown in the following code:\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;string\u0026gt;\n\nvoid buz(std::string const \u0026amp;s) {\n  std::string t \u003d \"Hello, \" + s;\n  std::cout \u0026lt;\u0026lt; t \u0026lt;\u0026lt; \u0027\\n\u0027;\n}\n\u003c/pre\u003e\n\u003cp\u003eIn addition, the \u003ccode\u003estd::format\u003c/code\u003e function allows one to format strings according to a user-specified format and returns the result as a\nstring as shown in what follows:\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;format\u0026gt;\n#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;string\u0026gt;\n\nvoid tar(std::string const \u0026amp;s) {\n  std::string t \u003d std::format(\"Hello, World! Greetings {}\\n\", s);\n  std::cout \u0026lt;\u0026lt; t \u0026lt;\u0026lt; \u0027\\n\u0027;\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eArticles \u0026amp; blog posts\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Clang Hardening - \u003ca href\u003d\"https://blog.quarkslab.com/clang-hardening-cheat-sheet.html\"\u003eClang Hardening Cheat Sheet\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e FORTIFY_SOURCE - \u003ca href\u003d\"https://www.redhat.com/en/blog/enhance-application-security-fortifysource\"\u003eEnhance application security with\n  FORTIFY_SOURCE\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e Stack Protection - \u003ca href\u003d\"https://developers.redhat.com/articles/2022/06/02/use-compiler-flags-stack-protection-gcc-and-clang\"\u003eUse compiler\n  flags for stack protection in GCC and Clang\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e Valgrind - \u003ca href\u003d\"https://valgrind.org/docs/manual/quick-start.html\"\u003eThe Valgrind Quick Start Guide\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eConference presentations\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CppCon 2014 - \u003ca href\u003d\"https://youtu.be/V2_80g0eOMc?si\u003dU_qv9iBKI5B3a_EL\"\u003eSanitize your C++ code\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CppCon 2018 - \u003ca href\u003d\"https://youtu.be/0S0QgQd75Sw?si\u003dAW9mA09L5PEbkqXc\"\u003eSoftware Vulnerabilities in C and C++\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CppCon 2020 - \u003ca href\u003d\"https://youtu.be/xEzfnbTabyE?si\u003d9yJQkrcRKn6tuPaV\"\u003e2020: The Year of Sanitizers?\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/wtYxBQ\"\u003eARR30-C. Do not form or use out-of-bounds pointers or array subscripts\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/i3w-BQ\"\u003eSTR50-CPP. Guarantee that storage for strings has sufficient space for character\n  data and the null terminator\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/119\"\u003e119 Improper Restriction of Operations within the Bounds of a Memory Buffer\u003c/a\u003e\n  \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/121\"\u003e121 Stack-based Buffer Overflow\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/122\"\u003e122 Heap-based Buffer Overflow\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/131\"\u003e131 Incorrect Calculation of Buffer Size\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/193\"\u003e193 Off-by-one Error\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/788\"\u003e788 Access of Memory Location After End of Buffer\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S5782} ensures that POSIX functions are not called with arguments that trigger buffer overflows \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S5945} discourages the use of C-style arrays and suggests the use of \u003ccode\u003estd::array\u003c/code\u003e or \u003ccode\u003estd::vector\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eMemory accesses should be bounded to prevent buffer overflows.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eArray overruns and buffer overflows occur when a memory access accidentally goes beyond the boundary of the allocated array or buffer.\u003c/p\u003e\n\u003cp\u003eThese overreaching accesses cause some of the most damaging and hard to track defects. Not only do these faulty accesses constitute undefined\nbehavior, but they frequently introduce security vulnerabilities, too.\u003c/p\u003e\n\u003ch2\u003eWhat is the potential impact?\u003c/h2\u003e\n\u003cp\u003eAccessing memory that goes beyond the boundary of the allocated array or buffer results in undefined behavior.\u003c/p\u003e\n\u003cp\u003eFor programs that exercise undefined behavior, the compiler is no longer bound by the language specification. The application may crash or, even\nworse, the application may appear to execute correctly while losing data or producing incorrect results.\u003c/p\u003e\n\u003cp\u003eOut-of-bounds memory accesses cause some of the most damaging and hard-to-track defects. Unbounded memory accesses may also introduce severe\nsecurity vulnerabilities. In case a user of the program can control the contents of a buffer, for instance, a malicious attacker can use the buffer\noverflow to overwrite critical data, leak secret or private information, execute arbitrary code, or gain unauthorized access to the system.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eEnsure that memory accesses are within the bounds of the allocated array or buffer.\u003c/p\u003e\n\u003cp\u003eIf C++ is available, use the \u003ccode\u003estd::array\u003c/code\u003e or \u003ccode\u003estd::vector\u003c/code\u003e types to manage stack or heap-based arrays, respectively and use\n\u003ccode\u003estd::string\u003c/code\u003e to manage string buffers.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid access_exceeds(void) {\n  int id_sequence[3];\n  id_sequence[0] \u003d 100;\n  id_sequence[1] \u003d 200;\n  id_sequence[2] \u003d 300;\n  id_sequence[3] \u003d 400; // Noncompliant: memory access is out of bounds\n  // Accessed memory exceeds upper limit of memory block\n}\n\nvoid access_precedes(int x) {\n  int buf[100];\n  int *p \u003d buf;\n  --p;\n  p[0] \u003d 9001; // Noncompliant: memory access is out of bounds\n  // Accessed memory precedes memory block\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid access_exceeds(void) {\n  int id_sequence[3];\n  // Compliant: all memory accesses are within valid bounds between 0 and 2\n  id_sequence[0] \u003d 100;\n  id_sequence[1] \u003d 200;\n  id_sequence[2] \u003d 300;\n}\n\nvoid access_precedes(int x) {\n  int buf[100];\n  int *p \u003d buf;\n  p[0] \u003d 9001; // Compliant: memory access within valid bounds\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;string.h\u0026gt;\n\nvoid memcpy_fun(void) {\n  char src[] \u003d {1, 2, 3, 4};\n  char dst[10];\n  memcpy(dst, src, 5); // Noncompliant: memory copy function accesses out-of-bound array element\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;string.h\u0026gt;\n\nvoid memcpy_fun(void) {\n  char src[] \u003d {1, 2, 3, 4};\n  char dst[10];\n  memcpy(dst, src, sizeof(src)); // Compliant: memory copy function accesses only valid array elements\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n\nint fun(void) {\n  char buffer[64] \u003d {0};\n  if (fgets(buffer, 2048, stdin) !\u003d NULL) { // Noncompliant: target buffer may overflow\n    printf(\"buffer contents: %s\", buffer);\n    return 0;\n  }\n  return 1;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n\nint fun(void) {\n  char buffer[64] \u003d {0};\n  if (fgets(buffer, 64, stdin) !\u003d NULL) { // Compliant: reads at most 64 - 1 characters\n    printf(\"buffer contents: %s\", buffer);\n    return 0;\n  }\n  return 1;\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"4\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n#include \u0026lt;string.h\u0026gt;\n\nint foo(void) {\n  const char *const str \u003d \"AAAA\"\n                          \"BBBB\"\n                          \"CCCC\"\n                          \"DDDD\";\n  size_t str_len \u003d strlen(str);\n  char *buf1 \u003d (char *)malloc(str_len + /*null terminator*/ 1);\n  if (buf1 \u003d\u003d NULL) { return 1; }\n  memset(buf1, 0, str_len + 1);\n  strncpy(buf1, str, str_len);\n  char buf2[8] \u003d {0};\n  memcpy(buf2, buf1, str_len + 1); // Noncompliant: buf2 will overflow.\n  printf(\"buf1: %s\\n\", buf1);\n  printf(\"buf2: %s\\n\", buf2);\n  free(buf1);\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"4\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n#include \u0026lt;string.h\u0026gt;\n\nint foo(void) {\n  const char *const str \u003d \"AAAA\"\n                          \"BBBB\"\n                          \"CCCC\"\n                          \"DDDD\";\n  size_t str_len \u003d strlen(str);\n  char *buf1 \u003d (char *)malloc(str_len + /*null terminator*/ 1);\n  if (buf1 \u003d\u003d NULL) { return 1; }\n  memset(buf1, 0, str_len + 1);\n  strncpy(buf1, str, str_len + 1);\n  char buf2[8] \u003d {0};\n  // Compliant: copy only `sizeof(buf2) - 1` bytes and leave the last\n  // terminating null byte (\u0027\\0\u0027) untouched such that `buf2` can be correctly\n  // printed in the subsequent lines.\n  memcpy(buf2, buf1,  sizeof(buf2) - 1);\n  printf(\"buf1: %s\\n\", buf1);\n  printf(\"buf2: %s\\n\", buf2);\n  free(buf1);\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"5\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n\nvoid bar(void) {\n  int array[8] \u003d {1, 2, 3, 4, 5, 6, 7, 8};\n  array[8] \u003d 42; // Noncompliant: index should be between 0 and 7\n  for (size_t i \u003d 0; i \u0026lt; 8; ++i) {\n    printf(\"%d\\n\", array[i]); // Compliant: index is between 0 and 7\n  }\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"5\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n\nvoid bar(void) {\n  int array[8] \u003d {1, 2, 3, 4, 5, 6, 7, 8};\n  array[7] \u003d 42; // Compliant: index is between 0 and 7\n  for (size_t i \u003d 0; i \u0026lt; 8; ++i) {\n    printf(\"%d\\n\", array[i]); // Compliant: index is between 0 and 7\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003ePitfalls\u003c/h3\u003e\n\u003cp\u003eWhen managing and manipulating string buffers one needs to take great care that the buffers are correctly terminated with a null byte\n(\u003ccode\u003e\u0027\\0\u0027\u003c/code\u003e). Failing to correctly null terminate string buffers almost always causes buffer overruns and introduces undefined behavior.\u003c/p\u003e\n\u003cp\u003eThe following faulty program aims at creating a string copy. However, the heap-allocated memory buffer for holding the copy is too small since\n\u003ccode\u003estrlen\u003c/code\u003e calculates the length of its input string but excludes the \"invisible\" terminating null byte (\u003ccode\u003e\u0027\\0\u0027\u003c/code\u003e). The call to\n\u003ccode\u003estrncpy\u003c/code\u003e also uses the string length computed by \u003ccode\u003estrlen\u003c/code\u003e and the string copy hence lacks an implicitly copied null terminator.\nThis causes out-of-bounds reads and introduces undefined behavior in the subsequent processing steps. In this example, the call to \u003ccode\u003eprintf\u003c/code\u003e\nwill eventually trigger such erroneous behavior.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"6\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n#include \u0026lt;string.h\u0026gt;\n\nchar *make_str_copy(const char *const src) {\n  size_t src_len \u003d strlen(src);\n  char *dst \u003d (char *)malloc(src_len); // buffer too small to hold null terminator\n  if (dst \u003d\u003d NULL) {\n    perror(\"malloc failed\");\n    exit(1);\n  }\n  strncpy(dst, src, src_len); // null terminator is not (implicitly) copied either\n  return dst;\n}\n\nint main(void) {\n  const char str[] \u003d \"Hello, World!\";\n  char *str_copy \u003d make_str_copy(str);\n  // call to `printf` will trigger undefined behavior due to missing null terminator\n  printf(\"%s\\n\", str_copy); // Noncompliant: `str_copy` has not been null terminated\n  // More code that processes `str_copy` ...\n  free(str_copy);\n  return 0;\n}\n\u003c/pre\u003e\n\u003cp\u003eThe following fixed version of the program does correctly allocate a heap-based buffer of sufficient size \u003cem\u003eand\u003c/em\u003e (explicitly) terminates it\nwith a null byte (\u003ccode\u003e\u0027\\0\u0027\u003c/code\u003e):\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"6\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n#include \u0026lt;string.h\u0026gt;\n\nchar *make_str_copy(const char *const src) {\n  size_t src_len \u003d strlen(src);\n  // `src_len + 1` since `strlen` _excludes_ the terminating null byte\n  char *dst \u003d (char *)malloc(src_len + 1);\n  if (dst \u003d\u003d NULL) {\n    perror(\"malloc failed\");\n    exit(1);\n  }\n  dst[src_len] \u003d \u0027\\0\u0027; // explicitly add a null terminator\n  strncpy(dst, src, src_len);\n  return dst;\n}\n\nint main(void) {\n  const char str[] \u003d \"Hello, World!\";\n  char *str_copy \u003d make_str_copy(str);\n  printf(\"%s\\n\", str_copy); // Compliant: `str_copy` has been correctly null terminated\n  // More code that processes `str_copy` ...\n  free(str_copy);\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch3\u003eGoing the extra mile\u003c/h3\u003e\n\u003cp\u003eBuffer overflows occur when a program writes data beyond the boundaries of a buffer and can lead to memory corruption and potential security\nvulnerabilities. To mitigate this risk, developers must carefully manage array and buffer sizes. This includes using secure coding practices, and\nemploying techniques like input validation and bounds checking.\u003c/p\u003e\n\u003cp\u003eVarious modern C and C++ compilers allow one to automatically instrument a program during compilation using so-called \u003cem\u003esanitizers\u003c/em\u003e. The\naddress and undefined behavior sanitizers, for instance, aim at detecting out-of-bound memory accesses and undefined behavior, respectively. If the\ninstrumentation detects an error at runtime, the program will abort with an error message that provides valuable information for identifying and\nfixing the error.\u003c/p\u003e\n\u003cp\u003eAdditional capabilities of modern compilers that aim at hardening the binary include the \u003ccode\u003eFORTIFY_SOURCE\u003c/code\u003e compilation flag, or features\nsuch as stack canaries or address space layout randomization (ASLR). These hardening features provide some lightweight support for detecting buffer\noverflows.\u003c/p\u003e\n\u003cp\u003eYet another programming tool for memory debugging is Valgrind. Valgrind inspects a programming during its execution and is capable of detecting\nvarious memory-related issues including buffer overflows.\u003c/p\u003e\n\u003cp\u003eIn C++, manual array or string, i.e., buffer manipulations are considered a code smell.\u003c/p\u003e\n\u003cp\u003eInstead, the \u003ccode\u003estd::array\u003c/code\u003e type should be used to manage stack-based arrays, and the \u003ccode\u003estd::vector\u003c/code\u003e type should be used if a\nheap-based array is desired. Besides always carrying their respective sizes, i.e., number of elements, \u003ccode\u003estd::array\u003c/code\u003e and\n\u003ccode\u003estd::vector\u003c/code\u003e implement many useful member functions such as \u003ccode\u003ebegin()\u003c/code\u003e and \u003ccode\u003eend()\u003c/code\u003e, allowing one to safely and\nconveniently process them using algorithms from the C++\u0027s \u003ccode\u003e\u0026lt;algorithm\u0026gt;\u003c/code\u003e header, for instance. An example is shown in the\nfollowing:\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;algorithm\u0026gt;\n#include \u0026lt;array\u0026gt;\n#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;numeric\u0026gt;\n#include \u0026lt;vector\u0026gt;\n\nvoid bar() {\n  // stack-based array\n  std::array\u0026lt;int, 8\u0026gt; stack_buf;\n  std::fill(stack_buf.begin(), stack_buf.end(), 42);\n  for (auto i : stack_buf) {\n    std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0027 \u0027;\n  }\n  std::cout \u0026lt;\u0026lt; \u0027\\n\u0027;\n  std::cout \u0026lt;\u0026lt; \"sum of stack_buf\u0027s values: \"\n            \u0026lt;\u0026lt; std::accumulate(stack_buf.begin(), stack_buf.end(), 0) \u0026lt;\u0026lt; \u0027\\n\u0027;\n  // heap-based array\n  std::vector\u0026lt;int\u0026gt; heap_buf \u003d {1, 2, 3, 4};\n  heap_buf.resize(10);\n  std::iota(heap_buf.begin(), heap_buf.end(), 1);\n  std::cout \u0026lt;\u0026lt; \"sum of heap_buf\u0027s values: \"\n            \u0026lt;\u0026lt; std::accumulate(heap_buf.begin(), heap_buf.end(), 0) \u0026lt;\u0026lt; \u0027\\n\u0027;\n}\n\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003estd::string\u003c/code\u003e type should be used to manage buffers since it facilitates safe buffer manipulations. Instead of manually\nconcatenating two buffers using \u003ccode\u003estrncat\u003c/code\u003e, for instance, \u003ccode\u003estd::string\u003c/code\u003e allows this operation to be performed in a much more\nconvenient manner as shown in the following code:\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;string\u0026gt;\n\nvoid buz(std::string const \u0026amp;s) {\n  std::string t \u003d \"Hello, \" + s;\n  std::cout \u0026lt;\u0026lt; t \u0026lt;\u0026lt; \u0027\\n\u0027;\n}\n\u003c/pre\u003e\n\u003cp\u003eIn addition, the \u003ccode\u003estd::format\u003c/code\u003e function allows one to format strings according to a user-specified format and returns the result as a\nstring as shown in what follows:\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;format\u0026gt;\n#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;string\u0026gt;\n\nvoid tar(std::string const \u0026amp;s) {\n  std::string t \u003d std::format(\"Hello, World! Greetings {}\\n\", s);\n  std::cout \u0026lt;\u0026lt; t \u0026lt;\u0026lt; \u0027\\n\u0027;\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eArticles \u0026amp; blog posts\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Clang Hardening - \u003ca href\u003d\"https://blog.quarkslab.com/clang-hardening-cheat-sheet.html\"\u003eClang Hardening Cheat Sheet\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e FORTIFY_SOURCE - \u003ca href\u003d\"https://www.redhat.com/en/blog/enhance-application-security-fortifysource\"\u003eEnhance application security with\n  FORTIFY_SOURCE\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e Stack Protection - \u003ca href\u003d\"https://developers.redhat.com/articles/2022/06/02/use-compiler-flags-stack-protection-gcc-and-clang\"\u003eUse compiler\n  flags for stack protection in GCC and Clang\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e Valgrind - \u003ca href\u003d\"https://valgrind.org/docs/manual/quick-start.html\"\u003eThe Valgrind Quick Start Guide\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eConference presentations\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CppCon 2014 - \u003ca href\u003d\"https://youtu.be/V2_80g0eOMc?si\u003dU_qv9iBKI5B3a_EL\"\u003eSanitize your C++ code\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CppCon 2018 - \u003ca href\u003d\"https://youtu.be/0S0QgQd75Sw?si\u003dAW9mA09L5PEbkqXc\"\u003eSoftware Vulnerabilities in C and C++\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CppCon 2020 - \u003ca href\u003d\"https://youtu.be/xEzfnbTabyE?si\u003d9yJQkrcRKn6tuPaV\"\u003e2020: The Year of Sanitizers?\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/wtYxBQ\"\u003eARR30-C. Do not form or use out-of-bounds pointers or array subscripts\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/i3w-BQ\"\u003eSTR50-CPP. Guarantee that storage for strings has sufficient space for character\n  data and the null terminator\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/119\"\u003e119 Improper Restriction of Operations within the Bounds of a Memory Buffer\u003c/a\u003e\n  \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/121\"\u003e121 Stack-based Buffer Overflow\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/122\"\u003e122 Heap-based Buffer Overflow\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/131\"\u003e131 Incorrect Calculation of Buffer Size\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/193\"\u003e193 Off-by-one Error\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/788\"\u003e788 Access of Memory Location After End of Buffer\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S5782} ensures that POSIX functions are not called with arguments that trigger buffer overflows \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S5945} discourages the use of C-style arrays and suggests the use of \u003ccode\u003estd::array\u003c/code\u003e or \u003ccode\u003estd::vector\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cert",
      "cwe",
      "symbolic-execution"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S3518",
    "name": "Zero should not be a possible denominator",
    "defaultSeverity": "CRITICAL",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003cp\u003eEnsure that integer division and remainder operations do not result in divide-by-zero errors.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eIf the denominator to a division or modulo operation is zero, the behavior of the application is undefined.\u003c/p\u003e\n\u003cp\u003eOperator \u003ccode\u003e/\u003c/code\u003e is used for division and \u003ccode\u003e%\u003c/code\u003e for modulo operation. Division and modulo operations are susceptible to\ndivide-by-zero (and signed integer overflow) errors.\u003c/p\u003e\n\u003cpre\u003e\nint foo(int a, int b) {\n  if (b \u003d\u003d 0) {\n    a \u003d 1;\n  }\n  return a / b; // Noncompliant: potential divide-by-zero error\n}\n\u003c/pre\u003e\n\u003ch2\u003eWhat is the potential impact?\u003c/h2\u003e\n\u003cp\u003eInteger division or remainder operations that result in divide-by-zero errors lead to \u003cstrong\u003eundefined behavior\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eFor programs that exercise undefined behavior, the compiler is no longer bound by the language specification. The application may crash or, even\nworse, the application may appear to execute correctly while losing data or producing incorrect results.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eEmploy adequate checks that prevent divide-by-zero errors when using integer division or remainder operations.\u003c/p\u003e\n\u003cp\u003eAlternatively, replace integer division with floating-point division for which the divide-by-zero case is well defined and does not introduce\nundefined behavior.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;limits\u0026gt;\n#include \u0026lt;optional\u0026gt;\n\nstd::optional\u0026lt;int\u0026gt; safe_division(int a, int b) {\n  // While the following check correctly prevents signed integer overflows,\n  // it fails to prevent divide-by-zero errors. If `b` is equal to `0`, the\n  // application emits undefined behavior.\n  if ((a \u003d\u003d std::numeric_limits\u0026lt;int\u0026gt;::min()) \u0026amp;\u0026amp; (b \u003d\u003d -1)) {\n    return std::nullopt;\n  }\n  return a / b; // Noncompliant: causes undefined behavior if `b` is zero\n}\n\nstd::optional\u0026lt;int\u0026gt; foo(int a, int b) {\n  if (b \u003d\u003d 0) {\n    a \u003d 1;\n  }\n  return safe_division(a, b);\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;limits\u0026gt;\n#include \u0026lt;optional\u0026gt;\n\nstd::optional\u0026lt;int\u0026gt; safe_division(int a, int b) {\n  if ((b \u003d\u003d 0) || ((a \u003d\u003d std::numeric_limits\u0026lt;int\u0026gt;::min()) \u0026amp;\u0026amp; (b \u003d\u003d -1))) {\n    return std::nullopt;\n  }\n  return a / b; // Compliant: check correctly prevents divide-by-zero and signed integer overflows\n}\n\nstd::optional\u0026lt;int\u0026gt; foo(int a, int b) {\n  if (b \u003d\u003d 0) {\n    a \u003d 1;\n  }\n  return safe_division(a, b);\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;limits\u0026gt;\n#include \u0026lt;optional\u0026gt;\n\nstd::optional\u0026lt;int\u0026gt; safe_division(int a, int b) {\n  if ((a \u003d\u003d std::numeric_limits\u0026lt;int\u0026gt;::min()) \u0026amp;\u0026amp; (b \u003d\u003d -1)) {\n    return std::nullopt;\n  }\n  return a / b; // Compliant: check to prevent divide-by-zero in the caller\n}\n\nstd::optional\u0026lt;int\u0026gt; foo(int a, int b) {\n  if (b \u003d\u003d 0) {\n    return std::nullopt;\n  }\n  return safe_division(a, b);\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\ndouble foo(int a, int b) {\n  return a / static_cast\u0026lt;double\u0026gt;(b); // Compliant: replace integer division by floating-point division\n}\n\u003c/pre\u003e\n\u003ch3\u003eGoing the extra mile\u003c/h3\u003e\n\u003cp\u003eBesides divide-by-zero errors, signed integer division is susceptible to overflows, too. When the dividend is the minimum value for the signed\ninteger type and the divisor is equal to \u003ccode\u003e-1\u003c/code\u003e an overflow is provoked due to two’s complement representation. This frequently causes\nhard-to-track bugs.\u003c/p\u003e\n\u003cp\u003eThe checks shown in the following code snippet correctly protect the division operation against divide-by-zero \u003cem\u003eand\u003c/em\u003e signed integer overflow\nerrors:\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;limits\u0026gt;\n#include \u0026lt;optional\u0026gt;\n\nstd::optional\u0026lt;int\u0026gt; safe_division(int a, int b) {\n  if ((b \u003d\u003d 0) || ((a \u003d\u003d std::numeric_limits\u0026lt;int\u0026gt;::min()) \u0026amp;\u0026amp; (b \u003d\u003d -1))) {\n    return std::nullopt;\n  }\n  return a / b; // Compliant: prevents divide-by-zero _and_ signed integer overflows\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca\n  href\u003d\"https://wiki.sei.cmu.edu/confluence/display/c/INT32-C.+Ensure+that+operations+on+signed+integers+do+not+result+in+overflow\"\u003eINT32-C. Ensure\n  that operations on signed integers do not result in overflow\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/ftYxBQ\"\u003eINT33-C. Ensure that division and remainder operations do not result in\n  divide-by-zero errors\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/369\"\u003e369 - Divide by zero\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es105-dont-divide-by-integer-zero\"\u003eES.105: Don’t divide by\n  integer zero\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eEnsure that integer division and remainder operations do not result in divide-by-zero errors.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eIf the denominator to a division or modulo operation is zero, the behavior of the application is undefined.\u003c/p\u003e\n\u003cp\u003eOperator \u003ccode\u003e/\u003c/code\u003e is used for division and \u003ccode\u003e%\u003c/code\u003e for modulo operation. Division and modulo operations are susceptible to\ndivide-by-zero (and signed integer overflow) errors.\u003c/p\u003e\n\u003cpre\u003e\nint foo(int a, int b) {\n  if (b \u003d\u003d 0) {\n    a \u003d 1;\n  }\n  return a / b; // Noncompliant: potential divide-by-zero error\n}\n\u003c/pre\u003e\n\u003ch2\u003eWhat is the potential impact?\u003c/h2\u003e\n\u003cp\u003eInteger division or remainder operations that result in divide-by-zero errors lead to \u003cstrong\u003eundefined behavior\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eFor programs that exercise undefined behavior, the compiler is no longer bound by the language specification. The application may crash or, even\nworse, the application may appear to execute correctly while losing data or producing incorrect results.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eEmploy adequate checks that prevent divide-by-zero errors when using integer division or remainder operations.\u003c/p\u003e\n\u003cp\u003eAlternatively, replace integer division with floating-point division for which the divide-by-zero case is well defined and does not introduce\nundefined behavior.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;limits\u0026gt;\n#include \u0026lt;optional\u0026gt;\n\nstd::optional\u0026lt;int\u0026gt; safe_division(int a, int b) {\n  // While the following check correctly prevents signed integer overflows,\n  // it fails to prevent divide-by-zero errors. If `b` is equal to `0`, the\n  // application emits undefined behavior.\n  if ((a \u003d\u003d std::numeric_limits\u0026lt;int\u0026gt;::min()) \u0026amp;\u0026amp; (b \u003d\u003d -1)) {\n    return std::nullopt;\n  }\n  return a / b; // Noncompliant: causes undefined behavior if `b` is zero\n}\n\nstd::optional\u0026lt;int\u0026gt; foo(int a, int b) {\n  if (b \u003d\u003d 0) {\n    a \u003d 1;\n  }\n  return safe_division(a, b);\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;limits\u0026gt;\n#include \u0026lt;optional\u0026gt;\n\nstd::optional\u0026lt;int\u0026gt; safe_division(int a, int b) {\n  if ((b \u003d\u003d 0) || ((a \u003d\u003d std::numeric_limits\u0026lt;int\u0026gt;::min()) \u0026amp;\u0026amp; (b \u003d\u003d -1))) {\n    return std::nullopt;\n  }\n  return a / b; // Compliant: check correctly prevents divide-by-zero and signed integer overflows\n}\n\nstd::optional\u0026lt;int\u0026gt; foo(int a, int b) {\n  if (b \u003d\u003d 0) {\n    a \u003d 1;\n  }\n  return safe_division(a, b);\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;limits\u0026gt;\n#include \u0026lt;optional\u0026gt;\n\nstd::optional\u0026lt;int\u0026gt; safe_division(int a, int b) {\n  if ((a \u003d\u003d std::numeric_limits\u0026lt;int\u0026gt;::min()) \u0026amp;\u0026amp; (b \u003d\u003d -1)) {\n    return std::nullopt;\n  }\n  return a / b; // Compliant: check to prevent divide-by-zero in the caller\n}\n\nstd::optional\u0026lt;int\u0026gt; foo(int a, int b) {\n  if (b \u003d\u003d 0) {\n    return std::nullopt;\n  }\n  return safe_division(a, b);\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\ndouble foo(int a, int b) {\n  return a / static_cast\u0026lt;double\u0026gt;(b); // Compliant: replace integer division by floating-point division\n}\n\u003c/pre\u003e\n\u003ch3\u003eGoing the extra mile\u003c/h3\u003e\n\u003cp\u003eBesides divide-by-zero errors, signed integer division is susceptible to overflows, too. When the dividend is the minimum value for the signed\ninteger type and the divisor is equal to \u003ccode\u003e-1\u003c/code\u003e an overflow is provoked due to two’s complement representation. This frequently causes\nhard-to-track bugs.\u003c/p\u003e\n\u003cp\u003eThe checks shown in the following code snippet correctly protect the division operation against divide-by-zero \u003cem\u003eand\u003c/em\u003e signed integer overflow\nerrors:\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;limits\u0026gt;\n#include \u0026lt;optional\u0026gt;\n\nstd::optional\u0026lt;int\u0026gt; safe_division(int a, int b) {\n  if ((b \u003d\u003d 0) || ((a \u003d\u003d std::numeric_limits\u0026lt;int\u0026gt;::min()) \u0026amp;\u0026amp; (b \u003d\u003d -1))) {\n    return std::nullopt;\n  }\n  return a / b; // Compliant: prevents divide-by-zero _and_ signed integer overflows\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca\n  href\u003d\"https://wiki.sei.cmu.edu/confluence/display/c/INT32-C.+Ensure+that+operations+on+signed+integers+do+not+result+in+overflow\"\u003eINT32-C. Ensure\n  that operations on signed integers do not result in overflow\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/ftYxBQ\"\u003eINT33-C. Ensure that division and remainder operations do not result in\n  divide-by-zero errors\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/369\"\u003e369 - Divide by zero\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es105-dont-divide-by-integer-zero\"\u003eES.105: Don’t divide by\n  integer zero\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cert",
      "cwe",
      "denial-of-service",
      "symbolic-execution"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5817",
    "name": "Member functions that don\u0027t mutate their objects should be declared \"const\"",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eNo member function can be invoked on a const-qualified object unless the member function is declared \"const\".\u003c/p\u003e\n\u003cp\u003eQualifying member functions that don’t mutate their object with the \"const\" qualifier makes your interface easier to understand; you can deduce\nwithout diving into implementation if a member function is going to mutate its object.\u003c/p\u003e\n\u003cp\u003eAlso, const-qualified member functions make working with const-qualified objects possible. The compiler ensures that only member functions that are\ndeclared \"const\" can be invoked on \"const\" objects. Avoiding declaring non-mutating member functions const might break\u0026nbsp;const-correctness: it will\nnot be possible to invoke such non-mutating functions on const-qualified objects.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nclass A {\n  void f(){ // Noncompliant\n    std::cout\u0026lt;\u0026lt; \"f doesn\u0027t mutate A\";\n  }\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nclass A {\n  void f() const {\n    std::cout\u0026lt;\u0026lt; \"f doesn\u0027t mutate A\";\n  }\n};\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eVirtual member functions that don’t mutate their objects don’t necessarily need to be declared const. This might be done in order to allow them to\nbe overridden by non-const functions.\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eNo member function can be invoked on a const-qualified object unless the member function is declared \"const\".\u003c/p\u003e\n\u003cp\u003eQualifying member functions that don’t mutate their object with the \"const\" qualifier makes your interface easier to understand; you can deduce\nwithout diving into implementation if a member function is going to mutate its object.\u003c/p\u003e\n\u003cp\u003eAlso, const-qualified member functions make working with const-qualified objects possible. The compiler ensures that only member functions that are\ndeclared \"const\" can be invoked on \"const\" objects. Avoiding declaring non-mutating member functions const might break\u0026nbsp;const-correctness: it will\nnot be possible to invoke such non-mutating functions on const-qualified objects.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nclass A {\n  void f(){ // Noncompliant\n    std::cout\u0026lt;\u0026lt; \"f doesn\u0027t mutate A\";\n  }\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nclass A {\n  void f() const {\n    std::cout\u0026lt;\u0026lt; \"f doesn\u0027t mutate A\";\n  }\n};\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eVirtual member functions that don’t mutate their objects don’t necessarily need to be declared const. This might be done in order to allow them to\nbe overridden by non-const functions.\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "confusing",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1451",
    "name": "Track lack of copyright and license headers",
    "defaultSeverity": "BLOCKER",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "LAWFUL",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eEach source file should start with a header stating file ownership and the license which must be used to distribute the application.\u003c/p\u003e\n\u003cp\u003eThis rule must be fed with the header text that is expected at the beginning of every file.\u003c/p\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n/*\n * SonarQube, open source software quality management tool.\n * Copyright (C) 2008-2013 SonarSource\n * mailto:contact AT sonarsource DOT com\n *\n * SonarQube is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 3 of the License, or (at your option) any later version.\n *\n * SonarQube is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this program; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n */\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eEach source file should start with a header stating file ownership and the license which must be used to distribute the application.\u003c/p\u003e\n\u003cp\u003eThis rule must be fed with the header text that is expected at the beginning of every file.\u003c/p\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n/*\n * SonarQube, open source software quality management tool.\n * Copyright (C) 2008-2013 SonarSource\n * mailto:contact AT sonarsource DOT com\n *\n * SonarQube is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 3 of the License, or (at your option) any later version.\n *\n * SonarQube is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this program; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n */\n\u003c/pre\u003e"
      }
    ],
    "params": {
      "headerFormat": {
        "key": "headerFormat",
        "name": "headerFormat",
        "description": "Expected copyright and license header (plain text)",
        "type": "TEXT",
        "multiple": false,
        "possibleValues": []
      },
      "isRegularExpression": {
        "key": "isRegularExpression",
        "name": "isRegularExpression",
        "description": "Whether the headerFormat is a POSIX regular expression",
        "defaultValue": "false",
        "type": "BOOLEAN",
        "multiple": false,
        "possibleValues": []
      }
    },
    "defaultParams": {
      "isRegularExpression": "false"
    },
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S3630",
    "name": "\"reinterpret_cast\" should not be used",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eBecause \u003ccode\u003ereinterpret_cast\u003c/code\u003e does not perform any type safety validations, it is capable of performing dangerous conversions between\nunrelated types, often leading to undefined behavior.\u003c/p\u003e\n\u003cp\u003eIn some cases, \u003ccode\u003ereinterpret_cast\u003c/code\u003e can be simply replaced by a more focused cast, such as \u003ccode\u003estatic_cast\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eIf the goal is to access the binary representation of an object, \u003ccode\u003ereinterpret_cast\u003c/code\u003e leads to undefined behavior. Before C++20, the\ncorrect way is to use \u003ccode\u003ememcpy\u003c/code\u003e to copy the object’s bits. Since C++20, a better option is available: \u003ccode\u003estd::bit_cast\u003c/code\u003e allows to\nreinterpret a value as being of a different type of the same length preserving its binary representation (see also {rule:cpp:S6181}).\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when \u003ccode\u003ereinterpret_cast\u003c/code\u003e is used.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n  class A { public: virtual ~A(){} };\n  class B : public A { public: void doSomething(){} };\n\n  void func(A *a, float f) {\n    B* b \u003d reinterpret_cast\u0026lt;B*\u0026gt;(a) // Noncompliant, another cast is more appropriate\n    b-\u0026gt;doSomething();\n\n    static_assert(sizeof(float) \u003d\u003d sizeof(uint32_t));\n    uint32_t x \u003d reinterpret_cast\u0026lt;uint32_t\u0026amp;\u0026gt;(f); // Noncompliant and undefined behavior\n  }\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n  class A { public: virtual ~A(){} };\n  class B : public A { public: void doSomething(){} };\n\n  void func(A *a, float f) {\n    if (B* b \u003d dynamic_cast\u0026lt;B*\u0026gt;(a)) {\n      b-\u0026gt;doSomething();\n    }\n\n    static_assert(sizeof(float) \u003d\u003d sizeof(uint32_t));\n    uint32_t x \u003d std::bit_cast\u0026lt;uint32_t\u0026gt;(f);\n    // Or, before C++20\n    uint32_t y;\n    std::memcpy(\u0026amp;y, \u0026amp;f, sizeof(float));\n  }\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#prosafety-type-safety-profile\"\u003eType.1: Avoid casts\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eBecause \u003ccode\u003ereinterpret_cast\u003c/code\u003e does not perform any type safety validations, it is capable of performing dangerous conversions between\nunrelated types, often leading to undefined behavior.\u003c/p\u003e\n\u003cp\u003eIn some cases, \u003ccode\u003ereinterpret_cast\u003c/code\u003e can be simply replaced by a more focused cast, such as \u003ccode\u003estatic_cast\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eIf the goal is to access the binary representation of an object, \u003ccode\u003ereinterpret_cast\u003c/code\u003e leads to undefined behavior. Before C++20, the\ncorrect way is to use \u003ccode\u003ememcpy\u003c/code\u003e to copy the object’s bits. Since C++20, a better option is available: \u003ccode\u003estd::bit_cast\u003c/code\u003e allows to\nreinterpret a value as being of a different type of the same length preserving its binary representation (see also {rule:cpp:S6181}).\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when \u003ccode\u003ereinterpret_cast\u003c/code\u003e is used.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n  class A { public: virtual ~A(){} };\n  class B : public A { public: void doSomething(){} };\n\n  void func(A *a, float f) {\n    B* b \u003d reinterpret_cast\u0026lt;B*\u0026gt;(a) // Noncompliant, another cast is more appropriate\n    b-\u0026gt;doSomething();\n\n    static_assert(sizeof(float) \u003d\u003d sizeof(uint32_t));\n    uint32_t x \u003d reinterpret_cast\u0026lt;uint32_t\u0026amp;\u0026gt;(f); // Noncompliant and undefined behavior\n  }\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n  class A { public: virtual ~A(){} };\n  class B : public A { public: void doSomething(){} };\n\n  void func(A *a, float f) {\n    if (B* b \u003d dynamic_cast\u0026lt;B*\u0026gt;(a)) {\n      b-\u0026gt;doSomething();\n    }\n\n    static_assert(sizeof(float) \u003d\u003d sizeof(uint32_t));\n    uint32_t x \u003d std::bit_cast\u0026lt;uint32_t\u0026gt;(f);\n    // Or, before C++20\n    uint32_t y;\n    std::memcpy(\u0026amp;y, \u0026amp;f, sizeof(float));\n  }\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#prosafety-type-safety-profile\"\u003eType.1: Avoid casts\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cppcoreguidelines",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5812",
    "name": "Concise syntax should be used for concatenatable namespaces",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eNamespaces represent a cross-file named scope. They are very useful to organize code and interfaces without cluttering a unique namespace. For\ninstance, they provide a much cleaner way to avoid name collisions than using bad long names.\u003c/p\u003e\n\u003cp\u003eNamespaces can be nested to provide even more structure to type and symbol names. In that case, namespaces can be nested one inside another like\nscopes would with curly braces.\u003c/p\u003e\n\u003cp\u003eIn C++17, a new concise syntax was introduced to increase the readability of nested namespaces. It is much less verbose and involves much less\ncurly braces-delimited scopes. Whereas declaring a nested namespace of depth N requires N pairs of curly braces with the original syntax, this new\nsyntax requires only one pair of curly braces. This syntax is much more readable and less error-prone. When possible, non-inlined or inlined (since\nC++20) named namespaces should be concatenated.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nnamespace geometry { // Noncompliant\n  namespace common {\n    class point {\n    };\n  }\n}\n\nnamespace geometry { // Noncompliant since C++20\n  inline namespace triangle  {\n    class edge {\n    };\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nnamespace geometry::common {\n  class point {\n  };\n}\n\nnamespace geometry::inline triangle { // C++20\n  class edge {\n  };\n}\n\nnamespace sonarsource { // Compliant: cannot be concatenated\n  namespace core {\n    class Rule {\n    };\n  }\n  class A {\n  };\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eNamespaces represent a cross-file named scope. They are very useful to organize code and interfaces without cluttering a unique namespace. For\ninstance, they provide a much cleaner way to avoid name collisions than using bad long names.\u003c/p\u003e\n\u003cp\u003eNamespaces can be nested to provide even more structure to type and symbol names. In that case, namespaces can be nested one inside another like\nscopes would with curly braces.\u003c/p\u003e\n\u003cp\u003eIn C++17, a new concise syntax was introduced to increase the readability of nested namespaces. It is much less verbose and involves much less\ncurly braces-delimited scopes. Whereas declaring a nested namespace of depth N requires N pairs of curly braces with the original syntax, this new\nsyntax requires only one pair of curly braces. This syntax is much more readable and less error-prone. When possible, non-inlined or inlined (since\nC++20) named namespaces should be concatenated.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nnamespace geometry { // Noncompliant\n  namespace common {\n    class point {\n    };\n  }\n}\n\nnamespace geometry { // Noncompliant since C++20\n  inline namespace triangle  {\n    class edge {\n    };\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nnamespace geometry::common {\n  class point {\n  };\n}\n\nnamespace geometry::inline triangle { // C++20\n  class edge {\n  };\n}\n\nnamespace sonarsource { // Compliant: cannot be concatenated\n  namespace core {\n    class Rule {\n    };\n  }\n  class A {\n  };\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "confusing",
      "since-c++17"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S2303",
    "name": "Exception specifications should not be used",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eException specifications never really provided any advantages in C++. They have been deprecated since C++11 and removed since C++17 (specification\nwith an exception) and C++20 (empty throw specification). If your code still contains some, you should replace empty \u003ccode\u003ethrow()\u003c/code\u003e\nspecifications with \u003ccode\u003enoexcept\u003c/code\u003e and remove any other specifications.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid f() throw(); // Noncompliant\nvoid g() throw(std::exception); // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid f() noexcept;\nvoid g();\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eIf a derived class overrides a function with a dynamic exception specification, then the derived function is forced to add a compatible exception\nspecification. Such exception specifications are ignored.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#e30-dont-use-exception-specifications\"\u003eE.30: Don’t use exception\n  specifications\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eException specifications never really provided any advantages in C++. They have been deprecated since C++11 and removed since C++17 (specification\nwith an exception) and C++20 (empty throw specification). If your code still contains some, you should replace empty \u003ccode\u003ethrow()\u003c/code\u003e\nspecifications with \u003ccode\u003enoexcept\u003c/code\u003e and remove any other specifications.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid f() throw(); // Noncompliant\nvoid g() throw(std::exception); // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid f() noexcept;\nvoid g();\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eIf a derived class overrides a function with a dynamic exception specification, then the derived function is forced to add a compatible exception\nspecification. Such exception specifications are ignored.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#e30-dont-use-exception-specifications\"\u003eE.30: Don’t use exception\n  specifications\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "clumsy",
      "cppcoreguidelines",
      "error-handling"
    ],
    "deprecatedKeys": [
      "cpp:ExceptionSpecificationUsage"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S4962",
    "name": "\"nullptr\" should be used to denote the null pointer",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eBefore C++11, the only way to refer to a null pointer was by using the integer literal \u003ccode\u003e0\u003c/code\u003e, which created ambiguity about whether a\npointer or an integer was intended. Even with the \u003ccode\u003eNULL\u003c/code\u003e macro, the underlying value is still \u003ccode\u003e0\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eC++11 introduced the keyword \u003ccode\u003enullptr\u003c/code\u003e, which unambiguously refers to the null pointer. It should be used systematically.\u003c/p\u003e\n\u003cpre\u003e\nvoid f(char *c);\nvoid g(int);\nvoid usage()\n{\n    f(0); // Noncompliant\n    f(NULL); // Noncompliant\n    f(nullptr); // Compliant: unambiguous\n\n    g(0); // Compliant, a real integer\n    // g(nullptr); // This would not compile\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/nullptr\"\u003enullptr\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es47-use-nullptr-rather-than-0-or-null\"\u003eES.47: Use\n  \u003ccode\u003enullptr\u003c/code\u003e rather than \u003ccode\u003e0\u003c/code\u003e or \u003ccode\u003eNULL\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eBefore C++11, the only way to refer to a null pointer was by using the integer literal \u003ccode\u003e0\u003c/code\u003e, which created ambiguity about whether a\npointer or an integer was intended. Even with the \u003ccode\u003eNULL\u003c/code\u003e macro, the underlying value is still \u003ccode\u003e0\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eC++11 introduced the keyword \u003ccode\u003enullptr\u003c/code\u003e, which unambiguously refers to the null pointer. It should be used systematically.\u003c/p\u003e\n\u003cpre\u003e\nvoid f(char *c);\nvoid g(int);\nvoid usage()\n{\n    f(0); // Noncompliant\n    f(NULL); // Noncompliant\n    f(nullptr); // Compliant: unambiguous\n\n    g(0); // Compliant, a real integer\n    // g(nullptr); // This would not compile\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/nullptr\"\u003enullptr\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es47-use-nullptr-rather-than-0-or-null\"\u003eES.47: Use\n  \u003ccode\u003enullptr\u003c/code\u003e rather than \u003ccode\u003e0\u003c/code\u003e or \u003ccode\u003eNULL\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "bad-practice",
      "cppcoreguidelines",
      "since-c++11"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S2665",
    "name": "The \"sizeof\" and \"alignof\" operator should not be used with operands of a \"void\" type",
    "defaultSeverity": "MINOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eAlthough some compilers will allow it, the use of \u003ccode\u003esizeof\u003c/code\u003e and \u003ccode\u003ealignof\u003c/code\u003e with arguments that have a \u003ccode\u003evoid\u003c/code\u003e type is\nforbidden by both the C and C++ standards.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid fun() {\n  void* p;\n  sizeof(*p);  // Noncompliant\n  sizeof(void);  // Noncompliant\n  alignof(*p);  // Noncompliant\n  alignof(void);  // Noncompliant\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eAlthough some compilers will allow it, the use of \u003ccode\u003esizeof\u003c/code\u003e and \u003ccode\u003ealignof\u003c/code\u003e with arguments that have a \u003ccode\u003evoid\u003c/code\u003e type is\nforbidden by both the C and C++ standards.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid fun() {\n  void* p;\n  sizeof(*p);  // Noncompliant\n  sizeof(void);  // Noncompliant\n  alignof(*p);  // Noncompliant\n  alignof(void);  // Noncompliant\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "lock-in"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S4963",
    "name": "The \"Rule-of-Zero\" should be followed",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "FOCUSED",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eMost classes should not directly handle resources, but instead, use members that perform resource handling for them:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e For memory, it can be \u003ccode\u003estd::unique_ptr\u003c/code\u003e, \u003ccode\u003estd::shared_ptr\u003c/code\u003e, \u003ccode\u003estd::vector\u003c/code\u003e…​ \u003c/li\u003e\n  \u003cli\u003e For files, it can be \u003ccode\u003estd::ofstream\u003c/code\u003e, \u003ccode\u003estd::ifstream\u003c/code\u003e…​ \u003c/li\u003e\n  \u003cli\u003e …​ \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eClasses that avoid directly handling resources don’t need to define any of the special member functions required to properly handle resources:\ndestructor, copy constructor, move constructor, copy-assignment operator, move-assignment operator. That’s because the versions of those functions\nprovided by the compiler do the right thing automatically, which is especially useful because writing these functions correctly is typically tricky\nand error-prone.\u003c/p\u003e\n\u003cp\u003eOmitting all of these functions from a class is known as the Rule of Zero because no special function should be defined.\u003c/p\u003e\n\u003cp\u003eIn some cases, this rule takes a slightly different shape, while respecting the fact that no definition of those functions will be provided:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e For the base class of a polymorphic hierarchy, the destructor should be declared as \u003ccode\u003epublic\u003c/code\u003e and \u003ccode\u003evirtual\u003c/code\u003e, and defaulted\n  (\u003ccode\u003e\u003ddefault\u003c/code\u003e). The copy-constructor and copy-assignment operator should be deleted. (If you want to copy classes in a polymorphic\n  hierarchy, use the \u003ccode\u003eclone\u003c/code\u003e idiom.) The move operation will be automatically deleted by the compiler. \u003c/li\u003e\n  \u003cli\u003e For other kinds of base classes, the destructor should be \u003ccode\u003eprotected\u003c/code\u003e and non-\u003ccode\u003evirtual\u003c/code\u003e, and defaulted\n  (\u003ccode\u003e\u003ddefault\u003c/code\u003e). \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass FooPointer { // Noncompliant. The code is correct (it follows the rule of 5), but unnecessarily complex\n  Foo* pFoo;\npublic:\n  FooPointer(int initValue) {\n    pFoo \u003d new Foo(initValue);\n  }\n  ~FooPointer() {\n    delete pFoo;\n  }\n  FooPointer(FooPointer const \u0026amp;fp) \u003d delete;\n  FooPointer const \u0026amp; operator\u003d(FooPointer const \u0026amp;fp) \u003d delete;\n  FooPointer(FooPointer \u0026amp;\u0026amp;fp) noexcept {\n    pFoo \u003d fp.pFoo;\n    fp.pFoo \u003d nullptr;\n  }\n  FooPointer const \u0026amp; operator\u003d(FooPointer \u0026amp;\u0026amp;fp) {\n    FooPointer temp(std::move(fp));\n    std::swap(temp.pFoo, pFoo);\n    return *this;\n  }\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nclass FooPointer { // Compliant, std::unique_ptr is use to handle memory management\n  unique_ptr\u0026lt;Foo\u0026gt; pFoo;\npublic:\n  FooPointer(int initValue) : pFoo(std::make_unique\u0026lt;Foo\u0026gt;(initValue) {}\n};\n\u003c/pre\u003e\n\u003cp\u003eA polymorphic base class can look like this:\u003c/p\u003e\n\u003cpre\u003e\nclass Base { // Compliant, the virtual destructor is defaulted\npublic:\n  virtual ~Base() \u003d default;\n  Base(Base const \u0026amp;) \u003d delete;\n  Base \u0026amp;operator\u003d(Base const \u0026amp;) \u003d delete;\n};\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Empty destructors are treated as though they were defaulted. \u003c/li\u003e\n  \u003cli\u003e There are several cases when this rule should not be followed. For instance, if your class is manually handling a resource, logging when being\n  constructed/copied, maintaining some kind of counter, having non-transient data that should not be copied (like \u003ccode\u003ecapacity\u003c/code\u003e for\n  \u003ccode\u003estd::vector\u003c/code\u003e)…​ In that case, it should still follow the rule of 5 ({rule:cpp:S3624}). And you should consider if you can isolate this\n  specific behavior in a base class or a dedicated member data, which would allow you to still follow the rule of 0. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S3624} \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S1235} \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eMost classes should not directly handle resources, but instead, use members that perform resource handling for them:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e For memory, it can be \u003ccode\u003estd::unique_ptr\u003c/code\u003e, \u003ccode\u003estd::shared_ptr\u003c/code\u003e, \u003ccode\u003estd::vector\u003c/code\u003e…​ \u003c/li\u003e\n  \u003cli\u003e For files, it can be \u003ccode\u003estd::ofstream\u003c/code\u003e, \u003ccode\u003estd::ifstream\u003c/code\u003e…​ \u003c/li\u003e\n  \u003cli\u003e …​ \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eClasses that avoid directly handling resources don’t need to define any of the special member functions required to properly handle resources:\ndestructor, copy constructor, move constructor, copy-assignment operator, move-assignment operator. That’s because the versions of those functions\nprovided by the compiler do the right thing automatically, which is especially useful because writing these functions correctly is typically tricky\nand error-prone.\u003c/p\u003e\n\u003cp\u003eOmitting all of these functions from a class is known as the Rule of Zero because no special function should be defined.\u003c/p\u003e\n\u003cp\u003eIn some cases, this rule takes a slightly different shape, while respecting the fact that no definition of those functions will be provided:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e For the base class of a polymorphic hierarchy, the destructor should be declared as \u003ccode\u003epublic\u003c/code\u003e and \u003ccode\u003evirtual\u003c/code\u003e, and defaulted\n  (\u003ccode\u003e\u003ddefault\u003c/code\u003e). The copy-constructor and copy-assignment operator should be deleted. (If you want to copy classes in a polymorphic\n  hierarchy, use the \u003ccode\u003eclone\u003c/code\u003e idiom.) The move operation will be automatically deleted by the compiler. \u003c/li\u003e\n  \u003cli\u003e For other kinds of base classes, the destructor should be \u003ccode\u003eprotected\u003c/code\u003e and non-\u003ccode\u003evirtual\u003c/code\u003e, and defaulted\n  (\u003ccode\u003e\u003ddefault\u003c/code\u003e). \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass FooPointer { // Noncompliant. The code is correct (it follows the rule of 5), but unnecessarily complex\n  Foo* pFoo;\npublic:\n  FooPointer(int initValue) {\n    pFoo \u003d new Foo(initValue);\n  }\n  ~FooPointer() {\n    delete pFoo;\n  }\n  FooPointer(FooPointer const \u0026amp;fp) \u003d delete;\n  FooPointer const \u0026amp; operator\u003d(FooPointer const \u0026amp;fp) \u003d delete;\n  FooPointer(FooPointer \u0026amp;\u0026amp;fp) noexcept {\n    pFoo \u003d fp.pFoo;\n    fp.pFoo \u003d nullptr;\n  }\n  FooPointer const \u0026amp; operator\u003d(FooPointer \u0026amp;\u0026amp;fp) {\n    FooPointer temp(std::move(fp));\n    std::swap(temp.pFoo, pFoo);\n    return *this;\n  }\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nclass FooPointer { // Compliant, std::unique_ptr is use to handle memory management\n  unique_ptr\u0026lt;Foo\u0026gt; pFoo;\npublic:\n  FooPointer(int initValue) : pFoo(std::make_unique\u0026lt;Foo\u0026gt;(initValue) {}\n};\n\u003c/pre\u003e\n\u003cp\u003eA polymorphic base class can look like this:\u003c/p\u003e\n\u003cpre\u003e\nclass Base { // Compliant, the virtual destructor is defaulted\npublic:\n  virtual ~Base() \u003d default;\n  Base(Base const \u0026amp;) \u003d delete;\n  Base \u0026amp;operator\u003d(Base const \u0026amp;) \u003d delete;\n};\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Empty destructors are treated as though they were defaulted. \u003c/li\u003e\n  \u003cli\u003e There are several cases when this rule should not be followed. For instance, if your class is manually handling a resource, logging when being\n  constructed/copied, maintaining some kind of counter, having non-transient data that should not be copied (like \u003ccode\u003ecapacity\u003c/code\u003e for\n  \u003ccode\u003estd::vector\u003c/code\u003e)…​ In that case, it should still follow the rule of 5 ({rule:cpp:S3624}). And you should consider if you can isolate this\n  specific behavior in a base class or a dedicated member data, which would allow you to still follow the rule of 0. \u003c/li\u003e\n\u003c/ul\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S3624} \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S1235} \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cert",
      "leak"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S2612",
    "name": "Setting loose POSIX file permissions is security-sensitive",
    "defaultSeverity": "MAJOR",
    "type": "SECURITY_HOTSPOT",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "SECURITY": "MEDIUM"
    },
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eIn Unix file system permissions, the \"\u003ccode\u003eothers\u003c/code\u003e\" category refers to all users except the owner of the file system resource and the\nmembers of the group assigned to this resource.\u003c/p\u003e\n\u003cp\u003eGranting permissions to this category can lead to unintended access to files or directories that could allow attackers to obtain sensitive\ninformation, disrupt services or elevate privileges.\u003c/p\u003e"
      },
      {
        "key": "assess_the_problem",
        "htmlContent": "\u003ch2\u003eAsk Yourself Whether\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e The application is designed to be run on a multi-user environment. \u003c/li\u003e\n  \u003cli\u003e Corresponding files and directories may contain confidential information. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere is a risk if you answered yes to any of those questions.\u003c/p\u003e\n\u003ch2\u003eSensitive Code Example\u003c/h2\u003e\n\u003cp\u003eWhen creating a file or directory with permissions to \"other group\":\u003c/p\u003e\n\u003cpre\u003e\nopen(\"myfile.txt\", O_CREAT, S_IRWXU | S_IRWXG | S_IRWXO); // Sensitive: the process set 777 permissions to this newly created file\n\nmkdir(\"myfolder\", S_IRWXU | S_IRWXG | S_IRWXO); // Sensitive: the process try to set 777 permissions to this newly created directory\n\u003c/pre\u003e\n\u003cp\u003eWhen explicitly adding permissions to \"other group\" with \u003ccode\u003echmod\u003c/code\u003e, \u003ccode\u003efchmod\u003c/code\u003e or \u003ccode\u003efilesystem::permissions\u003c/code\u003e\nfunctions:\u003c/p\u003e\n\u003cpre\u003e\nchmod(\"myfile.txt\", S_IRWXU | S_IRWXG | S_IRWXO);  // Sensitive: the process set 777 permissions to this file\n\nfchmod(fd, S_IRWXU | S_IRWXG | S_IRWXO); // Sensitive: the process set 777 permissions to this file descriptor\n\u003c/pre\u003e\n\u003cp\u003eWhen defining the \u003ccode\u003eumask\u003c/code\u003e without read, write and execute permissions for \"other group\":\u003c/p\u003e\n\u003cpre\u003e\numask(S_IRWXU | S_IRWXG); // Sensitive: the further files and folders will be created with possible permissions to \"other group\"\n\u003c/pre\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003ch2\u003eRecommended Secure Coding Practices\u003c/h2\u003e\n\u003cp\u003eThe most restrictive possible permissions should be assigned to files and directories.\u003c/p\u003e\n\u003ch2\u003eCompliant Solution\u003c/h2\u003e\n\u003cp\u003eWhen creating a file or directory, do not set permissions to \"other group\":\u003c/p\u003e\n\u003cpre\u003e\nopen(\"myfile.txt\", O_CREAT, S_IRWXU | S_IRWXG); // Compliant\n\nmkdir(\"myfolder\", S_IRWXU | S_IRWXG); // Compliant\n\u003c/pre\u003e\n\u003cp\u003eWhen using \u003ccode\u003echmod\u003c/code\u003e, \u003ccode\u003efchmod\u003c/code\u003e or \u003ccode\u003efilesystem::permissions\u003c/code\u003e functions, do not add permissions to \"other group\":\u003c/p\u003e\n\u003cpre\u003e\nchmod(\"myfile.txt\", S_IRWXU | S_IRWXG);  // Compliant\n\nfchmod(fd, S_IRWXU | S_IRWXG); // Compliant\n\u003c/pre\u003e\n\u003cp\u003eWhen defining the \u003ccode\u003eumask\u003c/code\u003e, set read, write and execute permissions to other group:\u003c/p\u003e\n\u003cpre\u003e\numask(S_IRWXO); // Compliant: further created files or directories will not have permissions set for \"other group\"\n\u003c/pre\u003e\n\u003ch2\u003eSee\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/Top10/A01_2021-Broken_Access_Control/\"\u003eOWASP Top 10 2021 Category A1\u003c/a\u003e - Broken Access Control \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/Top10/A04_2021-Insecure_Design/\"\u003eOWASP Top 10 2021 Category A4\u003c/a\u003e - Insecure Design \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control\"\u003eOWASP Top 10 2017 Category A5\u003c/a\u003e - Broken Access Control\n  \u003c/li\u003e\n  \u003cli\u003e \u003ca\n  href\u003d\"https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/02-Configuration_and_Deployment_Management_Testing/09-Test_File_Permission\"\u003eOWASP File Permission\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/732\"\u003eMITRE, CWE-732\u003c/a\u003e - Incorrect Permission Assignment for Critical Resource \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/266\"\u003eMITRE, CWE-266\u003c/a\u003e - Incorrect Privilege Assignment \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/display/c/FIO06-C.+Create+files+with+appropriate+access+permissions\"\u003eCERT, FIO06-C.\u003c/a\u003e - Create\n  files with appropriate access permissions \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cert",
      "cwe"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": [],
    "vulnerabilityProbability": "MEDIUM"
  },
  {
    "key": "cpp:S1767",
    "name": "Pointers should not be cast to integral types",
    "defaultSeverity": "CRITICAL",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe size of integer required to hold a memory address is implementation-dependent. Therefore, casting a pointer (i.e. a memory address) to any\nintegral data type may result in data loss because the integral type is too small to hold the full address value.\u003c/p\u003e\n\u003cp\u003eWhen treating a memory address as integer type is absolutely required, you should be sure to use a large enough type to hold all the data.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint *p;\nint addr \u003d ( int ) \u0026amp;p;\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 11.3 - A cast should not be performed between a pointer type and an integral type. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 5-2-9 - A cast should not convert a pointer type to an integral type. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 11.4 - A conversion should not be performed between a pointer to object and an integer type \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/0dUxBQ\"\u003eCERT, INT36-C.\u003c/a\u003e - Converting a pointer to integer or integer to pointer \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe size of integer required to hold a memory address is implementation-dependent. Therefore, casting a pointer (i.e. a memory address) to any\nintegral data type may result in data loss because the integral type is too small to hold the full address value.\u003c/p\u003e\n\u003cp\u003eWhen treating a memory address as integer type is absolutely required, you should be sure to use a large enough type to hold all the data.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint *p;\nint addr \u003d ( int ) \u0026amp;p;\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 11.3 - A cast should not be performed between a pointer type and an integral type. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 5-2-9 - A cast should not convert a pointer type to an integral type. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 11.4 - A conversion should not be performed between a pointer to object and an integer type \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/0dUxBQ\"\u003eCERT, INT36-C.\u003c/a\u003e - Converting a pointer to integer or integer to pointer \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "cert"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1768",
    "name": "The sign of an unsigned variable should not be tested",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eBecause the value in a variable of an unsigned type can never be less than zero, testing to see if it is negative is a useless operation which can\nonly confuse future readers of the code.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nunsigned int i \u003d 0; // the lowest value this var can have\n...\nif (i \u0026gt;\u003d 0) { // Noncompliant\n  do_x(i);\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nunsigned int i \u003d 0;\n...\ndo_x(i);\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eBecause the value in a variable of an unsigned type can never be less than zero, testing to see if it is negative is a useless operation which can\nonly confuse future readers of the code.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nunsigned int i \u003d 0; // the lowest value this var can have\n...\nif (i \u0026gt;\u003d 0) { // Noncompliant\n  do_x(i);\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nunsigned int i \u003d 0;\n...\ndo_x(i);\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S2738",
    "name": "General \"catch\" clauses should not be used",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eA general \u003ccode\u003ecatch\u003c/code\u003e block seems like an efficient way to handle multiple possible exceptions. Unfortunately, it traps all exception types,\ncasting too broad a net, and perhaps mishandling extraordinary cases. Instead, specific exception sub-types should be caught.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\ntry {\n  file.open(\"test.txt\");\n} catch (...) {  // Noncompliant\n  // ...\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\ntry {\n  file.open(\"test.txt\");\n} catch (std::ifstream::failure e) {\n  // ...\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThere are cases though where you want to catch all exceptions, because no exceptions should be allowed to escape the function, and generic\n\u003ccode\u003ecatch\u003c/code\u003e handlers are excluded from the rule:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e In the main function \u003c/li\u003e\n  \u003cli\u003e In a class destructor \u003c/li\u003e\n  \u003cli\u003e In a \u003ccode\u003enoexcept\u003c/code\u003e function \u003c/li\u003e\n  \u003cli\u003e In an \u003ccode\u003eextern \"C\"\u003c/code\u003e function \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eAdditionally, if the \u003ccode\u003ecatch\u003c/code\u003e handler is throwing an exception (either the same as before, with \u003ccode\u003ethrow;\u003c/code\u003e or a new one that may\nmake more sense to the callers of the function), or is never exiting (because it calls a \u003ccode\u003enoreturn\u003c/code\u003e function, for instance\n\u003ccode\u003eexit\u003c/code\u003e), then the accurate type of the exception usually does not matter any longer: this case is excluded too.\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eA general \u003ccode\u003ecatch\u003c/code\u003e block seems like an efficient way to handle multiple possible exceptions. Unfortunately, it traps all exception types,\ncasting too broad a net, and perhaps mishandling extraordinary cases. Instead, specific exception sub-types should be caught.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\ntry {\n  file.open(\"test.txt\");\n} catch (...) {  // Noncompliant\n  // ...\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\ntry {\n  file.open(\"test.txt\");\n} catch (std::ifstream::failure e) {\n  // ...\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThere are cases though where you want to catch all exceptions, because no exceptions should be allowed to escape the function, and generic\n\u003ccode\u003ecatch\u003c/code\u003e handlers are excluded from the rule:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e In the main function \u003c/li\u003e\n  \u003cli\u003e In a class destructor \u003c/li\u003e\n  \u003cli\u003e In a \u003ccode\u003enoexcept\u003c/code\u003e function \u003c/li\u003e\n  \u003cli\u003e In an \u003ccode\u003eextern \"C\"\u003c/code\u003e function \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eAdditionally, if the \u003ccode\u003ecatch\u003c/code\u003e handler is throwing an exception (either the same as before, with \u003ccode\u003ethrow;\u003c/code\u003e or a new one that may\nmake more sense to the callers of the function), or is never exiting (because it calls a \u003ccode\u003enoreturn\u003c/code\u003e function, for instance\n\u003ccode\u003eexit\u003c/code\u003e), then the accurate type of the exception usually does not matter any longer: this case is excluded too.\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "error-handling"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S2737",
    "name": "\"catch\" clauses should do more than rethrow",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eA \u003ccode\u003ecatch\u003c/code\u003e clause that only rethrows the caught exception has the same effect as omitting the \u003ccode\u003ecatch\u003c/code\u003e altogether and letting\nit bubble up automatically.\u003c/p\u003e\n\u003cpre\u003e\ntry {\n  saveDocument();\n} catch (const std::exception\u0026amp; e) { // Noncompliant\n  throw;\n}\n\u003c/pre\u003e\n\u003cp\u003eSuch clauses should either be removed or populated with the appropriate logic.\u003c/p\u003e\n\u003cpre\u003e\nsaveDocument();\n\u003c/pre\u003e\n\u003cp\u003eor\u003c/p\u003e\n\u003cpre\u003e\ntry {\n  saveDocument();\n} catch (const std::exception\u0026amp; e) {\n  log \u0026lt;\u0026lt; e.what();\n  throw;\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eA \u003ccode\u003ecatch\u003c/code\u003e clause that only rethrows the caught exception has the same effect as omitting the \u003ccode\u003ecatch\u003c/code\u003e altogether and letting\nit bubble up automatically.\u003c/p\u003e\n\u003cpre\u003e\ntry {\n  saveDocument();\n} catch (const std::exception\u0026amp; e) { // Noncompliant\n  throw;\n}\n\u003c/pre\u003e\n\u003cp\u003eSuch clauses should either be removed or populated with the appropriate logic.\u003c/p\u003e\n\u003cpre\u003e\nsaveDocument();\n\u003c/pre\u003e\n\u003cp\u003eor\u003c/p\u003e\n\u003cpre\u003e\ntry {\n  saveDocument();\n} catch (const std::exception\u0026amp; e) {\n  log \u0026lt;\u0026lt; e.what();\n  throw;\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "clumsy",
      "error-handling",
      "finding",
      "unused"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S3708",
    "name": "Reference types should not be qualified with \"const\" or \"volatile\"",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe C++ specification forbids the qualification of reference types with \u003ccode\u003econst\u003c/code\u003e or \u003ccode\u003evolatile\u003c/code\u003e unless it happens via a\n\u003ccode\u003etypedef\u003c/code\u003e, in which case it’s ignored. Most compilers treat such direct qualifications as errors, but the Microsoft compiler allows\nthem.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue on both types of \u003ccode\u003econst\u003c/code\u003e qualification.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid example(char c) {\n  char \u0026amp; const direct \u003d c; // Noncompliant\n\n  typedef char \u0026amp; T;\n  const T indirect \u003d c; // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid example(char c) {\n  char \u0026amp; direct \u003d c; // or: const char \u0026amp; direct \u003d c;\n\n  typedef char \u0026amp; T;\n  T indirect \u003d c;\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://www.securecoding.cert.org/confluence/display/cplusplus/DCL52-CPP.+Never+qualify+a+reference+type+with+const+or+volatile\"\u003eCERT,\n  DCL52-CPP.\u003c/a\u003e - Never qualify a reference type with const or volatile \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe C++ specification forbids the qualification of reference types with \u003ccode\u003econst\u003c/code\u003e or \u003ccode\u003evolatile\u003c/code\u003e unless it happens via a\n\u003ccode\u003etypedef\u003c/code\u003e, in which case it’s ignored. Most compilers treat such direct qualifications as errors, but the Microsoft compiler allows\nthem.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue on both types of \u003ccode\u003econst\u003c/code\u003e qualification.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid example(char c) {\n  char \u0026amp; const direct \u003d c; // Noncompliant\n\n  typedef char \u0026amp; T;\n  const T indirect \u003d c; // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid example(char c) {\n  char \u0026amp; direct \u003d c; // or: const char \u0026amp; direct \u003d c;\n\n  typedef char \u0026amp; T;\n  T indirect \u003d c;\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://www.securecoding.cert.org/confluence/display/cplusplus/DCL52-CPP.+Never+qualify+a+reference+type+with+const+or+volatile\"\u003eCERT,\n  DCL52-CPP.\u003c/a\u003e - Never qualify a reference type with const or volatile \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cert",
      "lock-in",
      "unused"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S3949",
    "name": "Integral operations should not overflow",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eNumbers are infinite, but the types that hold them are not. Each numeric type has hard upper and lower bounds. Try to calculate or assign numbers\nbeyond those bounds, and the result will be surprising:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e For unsigned types, it will be a value that has silently wrapped around from the expected positive value to another one, following the rules of\n  modular arithmetic (if the maximum \u003ccode\u003eunsigned char\u003c/code\u003e is 255, adding 10 to an \u003ccode\u003eunsigned char\u003c/code\u003e equals to 250 will yield the value\n  4) \u003c/li\u003e\n  \u003cli\u003e For signed type, this is undefined behavior. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid test(char c) {\n  switch (c) {\n    case 2000: // Noncompliant\n      // ...\n      break;\n  }\n\n  int a \u003d 4608 * 1024 * 1024; // Noncompliant\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eNumbers are infinite, but the types that hold them are not. Each numeric type has hard upper and lower bounds. Try to calculate or assign numbers\nbeyond those bounds, and the result will be surprising:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e For unsigned types, it will be a value that has silently wrapped around from the expected positive value to another one, following the rules of\n  modular arithmetic (if the maximum \u003ccode\u003eunsigned char\u003c/code\u003e is 255, adding 10 to an \u003ccode\u003eunsigned char\u003c/code\u003e equals to 250 will yield the value\n  4) \u003c/li\u003e\n  \u003cli\u003e For signed type, this is undefined behavior. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid test(char c) {\n  switch (c) {\n    case 2000: // Noncompliant\n      // ...\n      break;\n  }\n\n  int a \u003d 4608 * 1024 * 1024; // Noncompliant\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "cert",
      "misra-c2004",
      "misra-c2012",
      "overflow"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1760",
    "name": "Keywords introduced in later specifications should not be used as identifiers",
    "defaultSeverity": "BLOCKER",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhile keywords introduced in later standards can legally be used as identifiers in code compiled to earlier standards, doing so will eventually\ncause problems. Such code will cause compile errors if (when) the compiler is upgraded, and fixing those errors could be difficult and painful.\u003c/p\u003e\n\u003cp\u003eAdditionally, such misuse of keywords has the potential to thoroughly confuse people who are unfamiliar with the code base, possibly leading them\nto introduce additional errors.\u003c/p\u003e\n\u003cp\u003eFor these reasons, the earlier this practice is stopped, the better.\u003c/p\u003e\n\u003cp\u003eThis rule flags instances of the following keywords used as identifiers:\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eC99\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003einline\u003c/code\u003e, \u003ccode\u003erestrict\u003c/code\u003e, \u003ccode\u003e_Bool\u003c/code\u003e, \u003ccode\u003e_Complex\u003c/code\u003e, \u003ccode\u003e_Noreturn\u003c/code\u003e, \u003ccode\u003e_Static_assert\u003c/code\u003e,\n\u003ccode\u003e_Thread_local\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eC11\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e_Alignas\u003c/code\u003e, \u003ccode\u003e_Alignof\u003c/code\u003e, \u003ccode\u003e_Atomic\u003c/code\u003e, \u003ccode\u003e_Generic\u003c/code\u003e, \u003ccode\u003e_Imaginary\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eC++11\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ealignas\u003c/code\u003e, \u003ccode\u003ealignof\u003c/code\u003e, \u003ccode\u003echar16_t\u003c/code\u003e, \u003ccode\u003echar32_t\u003c/code\u003e, \u003ccode\u003econstexpr\u003c/code\u003e, \u003ccode\u003edecltype\u003c/code\u003e,\n\u003ccode\u003enoexcept\u003c/code\u003e, \u003ccode\u003enullptr\u003c/code\u003e, \u003ccode\u003estatic_assert\u003c/code\u003e, \u003ccode\u003ethread_local\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eC++20\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003econcept\u003c/code\u003e, \u003ccode\u003erequires\u003c/code\u003e, \u003ccode\u003econstinit\u003c/code\u003e, \u003ccode\u003econsteval\u003c/code\u003e, \u003ccode\u003eco_await\u003c/code\u003e, \u003ccode\u003eco_return\u003c/code\u003e,\n\u003ccode\u003eco_yield\u003c/code\u003e, \u003ccode\u003echar8_t\u003c/code\u003e\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint inline \u003d 0;\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint inline_count \u003d 0;\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhile keywords introduced in later standards can legally be used as identifiers in code compiled to earlier standards, doing so will eventually\ncause problems. Such code will cause compile errors if (when) the compiler is upgraded, and fixing those errors could be difficult and painful.\u003c/p\u003e\n\u003cp\u003eAdditionally, such misuse of keywords has the potential to thoroughly confuse people who are unfamiliar with the code base, possibly leading them\nto introduce additional errors.\u003c/p\u003e\n\u003cp\u003eFor these reasons, the earlier this practice is stopped, the better.\u003c/p\u003e\n\u003cp\u003eThis rule flags instances of the following keywords used as identifiers:\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eC99\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003einline\u003c/code\u003e, \u003ccode\u003erestrict\u003c/code\u003e, \u003ccode\u003e_Bool\u003c/code\u003e, \u003ccode\u003e_Complex\u003c/code\u003e, \u003ccode\u003e_Noreturn\u003c/code\u003e, \u003ccode\u003e_Static_assert\u003c/code\u003e,\n\u003ccode\u003e_Thread_local\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eC11\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e_Alignas\u003c/code\u003e, \u003ccode\u003e_Alignof\u003c/code\u003e, \u003ccode\u003e_Atomic\u003c/code\u003e, \u003ccode\u003e_Generic\u003c/code\u003e, \u003ccode\u003e_Imaginary\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eC++11\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ealignas\u003c/code\u003e, \u003ccode\u003ealignof\u003c/code\u003e, \u003ccode\u003echar16_t\u003c/code\u003e, \u003ccode\u003echar32_t\u003c/code\u003e, \u003ccode\u003econstexpr\u003c/code\u003e, \u003ccode\u003edecltype\u003c/code\u003e,\n\u003ccode\u003enoexcept\u003c/code\u003e, \u003ccode\u003enullptr\u003c/code\u003e, \u003ccode\u003estatic_assert\u003c/code\u003e, \u003ccode\u003ethread_local\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eC++20\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003econcept\u003c/code\u003e, \u003ccode\u003erequires\u003c/code\u003e, \u003ccode\u003econstinit\u003c/code\u003e, \u003ccode\u003econsteval\u003c/code\u003e, \u003ccode\u003eco_await\u003c/code\u003e, \u003ccode\u003eco_return\u003c/code\u003e,\n\u003ccode\u003eco_yield\u003c/code\u003e, \u003ccode\u003echar8_t\u003c/code\u003e\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint inline \u003d 0;\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint inline_count \u003d 0;\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "lock-in"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1761",
    "name": "Pre-defined macros should not be defined, redefined or undefined",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe standard, predefined macros, such as \u003ccode\u003e__FILE__\u003c/code\u003e and \u003ccode\u003e__LINE__\u003c/code\u003e, are primarily intended for use by the implementation, and\nchanging them could result in undefined behavior.\u003c/p\u003e\n\u003cp\u003eThis rule checks that the following predefined macros are not defined, undefined, or redefined: \u003ccode\u003eassert\u003c/code\u003e, \u003ccode\u003eerrno\u003c/code\u003e,\n\u003ccode\u003e__FILE__\u003c/code\u003e, \u003ccode\u003e__LINE__\u003c/code\u003e, \u003ccode\u003e__TIME__\u003c/code\u003e, \u003ccode\u003e__DATE__\u003c/code\u003e, \u003ccode\u003e__TIMESTAMP__\u003c/code\u003e, \u003ccode\u003e__COUNTER__\u003c/code\u003e,\n\u003ccode\u003e__INCLUDE_LEVEL__\u003c/code\u003e, \u003ccode\u003e__BASE_FILE__\u003c/code\u003e, and \u003ccode\u003e_Pragma\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#undef __LINE__\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 20.1 - Reserved identifiers, macros and functions in the standard library shall not be defined, redefined, or undefined \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 17-0-1 - Reserved identifiers, macros and functions in the standard library shall not be defined, redefined, or undefined \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 21.1 - #define and #undef shall not be used on a reserved identifier or reserved macro name \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe standard, predefined macros, such as \u003ccode\u003e__FILE__\u003c/code\u003e and \u003ccode\u003e__LINE__\u003c/code\u003e, are primarily intended for use by the implementation, and\nchanging them could result in undefined behavior.\u003c/p\u003e\n\u003cp\u003eThis rule checks that the following predefined macros are not defined, undefined, or redefined: \u003ccode\u003eassert\u003c/code\u003e, \u003ccode\u003eerrno\u003c/code\u003e,\n\u003ccode\u003e__FILE__\u003c/code\u003e, \u003ccode\u003e__LINE__\u003c/code\u003e, \u003ccode\u003e__TIME__\u003c/code\u003e, \u003ccode\u003e__DATE__\u003c/code\u003e, \u003ccode\u003e__TIMESTAMP__\u003c/code\u003e, \u003ccode\u003e__COUNTER__\u003c/code\u003e,\n\u003ccode\u003e__INCLUDE_LEVEL__\u003c/code\u003e, \u003ccode\u003e__BASE_FILE__\u003c/code\u003e, and \u003ccode\u003e_Pragma\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#undef __LINE__\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 20.1 - Reserved identifiers, macros and functions in the standard library shall not be defined, redefined, or undefined \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 17-0-1 - Reserved identifiers, macros and functions in the standard library shall not be defined, redefined, or undefined \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 21.1 - #define and #undef shall not be used on a reserved identifier or reserved macro name \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "preprocessor",
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1762",
    "name": "\"#pragma warning (default: ...)\" should not be used",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eUsing \"#pragma warning (default: …​)\" resets the warning in question to its default settings, which may not be what the compiler was initially\ninvoked with. Typically, this usage is seen after a warning is turned off, in preparation for code that is known to cause warnings. Instead, the\nwarning’s current state should be saved, and then restored after the code in question.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#pragma warning (disable: TheWarning)\n#include problem_code.h\n#pragma warning (default: TheWarning)\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#pragma warning (push)\n#include problem_code.h\n#pragma warning (pop)\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/6NUxBQ\"\u003eCERT, MSC00-C.\u003c/a\u003e - Compile cleanly at high warning levels \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eUsing \"#pragma warning (default: …​)\" resets the warning in question to its default settings, which may not be what the compiler was initially\ninvoked with. Typically, this usage is seen after a warning is turned off, in preparation for code that is known to cause warnings. Instead, the\nwarning’s current state should be saved, and then restored after the code in question.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#pragma warning (disable: TheWarning)\n#include problem_code.h\n#pragma warning (default: TheWarning)\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#pragma warning (push)\n#include problem_code.h\n#pragma warning (pop)\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/6NUxBQ\"\u003eCERT, MSC00-C.\u003c/a\u003e - Compile cleanly at high warning levels \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cert"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1642",
    "name": "\"struct\" names should comply with a naming convention",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "IDENTIFIABLE",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eSharing some naming conventions enables teams to collaborate more efficiently. This rule checks that all \u003ccode\u003estruct\u003c/code\u003e names match a provided\nregular expression.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cp\u003eUsing the default regular expression \u003ccode\u003e^[A-Z][a-zA-Z0-9]*$\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\nstruct myStruct {\n  int one;\n  int two;\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstruct MyStruct {\n  int one;\n  int two;\n};\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eSharing some naming conventions enables teams to collaborate more efficiently. This rule checks that all \u003ccode\u003estruct\u003c/code\u003e names match a provided\nregular expression.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cp\u003eUsing the default regular expression \u003ccode\u003e^[A-Z][a-zA-Z0-9]*$\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\nstruct myStruct {\n  int one;\n  int two;\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstruct MyStruct {\n  int one;\n  int two;\n};\n\u003c/pre\u003e"
      }
    ],
    "params": {
      "format": {
        "key": "format",
        "name": "format",
        "description": "POSIX regular expression struct names should match.",
        "defaultValue": "^[A-Z][a-zA-Z0-9]*$",
        "type": "STRING",
        "multiple": false,
        "possibleValues": []
      }
    },
    "defaultParams": {
      "format": "^[A-Z][a-zA-Z0-9]*$"
    },
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "convention"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1763",
    "name": "All code should be reachable",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003cp\u003eOnce control flow has been moved out of the current code block, any subsequent statements become effectively unreachable.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eSome statements and expressions move the control flow out of the current code block. Additionally, some functions never return the control flow to\nthe caller. Any unlabeled statements that come after such a jump or function call is unreachable.\u003c/p\u003e\n\u003cp\u003eFor instance, within a code block, code following a statement containing any of these keywords is effectively dead code:\u003c/p\u003e\n\u003col\u003e\n  \u003cli\u003e \u003ccode\u003ereturn\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003ebreak\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003econtinue\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003egoto\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003eco_return\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003ethrow\u003c/code\u003e \u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eExamples of functions that never return the control flow to the caller:\u003c/p\u003e\n\u003col\u003e\n  \u003cli\u003e \u003ccode\u003eexit()\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003eabort()\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003estd::terminate()\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e Functions with the \u003ccode\u003e[[noreturn]]\u003c/code\u003e attribute. \u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eThe affected code block should be checked to verify the intended behavior, and the logic should be corrected, or the dead code removed.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nint fun(int a) {\n  int i \u003d 10;\n  return i + a;  // Noncompliant: There are following statements within the code block\n  i++;           // Dead code\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\nint divide(int a, int b) {\n  if (b \u003d\u003d 0) {\n    abort();    // Noncompliant: `abort()` never returns to the caller\n    std::cerr \u0026lt;\u0026lt; \"Divisor is 0!\" \u0026lt;\u0026lt; std::endl; // Dead code\n  }\n  return a / b;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nint fun(int a) {\n  int i \u003d 10;\n  return i + a;\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\nint divide(int a, int b) {\n  if (b \u003d\u003d 0) {\n    std::cerr \u0026lt;\u0026lt; \"Divisor is 0!\" \u0026lt;\u0026lt; std::endl;\n    abort();\n  }\n  return a / b;\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 14.1 - There shall be no unreachable code \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 0-1-1 - A project shall not contain unreachable code \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 2.1 - A project shall not contain unreachable code \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/561\"\u003eMITRE, CWE-561\u003c/a\u003e - Dead Code \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/5dUxBQ\"\u003eCERT, MSC12-C.\u003c/a\u003e - Detect and remove code that has no effect or is never executed\n  \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eOnce control flow has been moved out of the current code block, any subsequent statements become effectively unreachable.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eSome statements and expressions move the control flow out of the current code block. Additionally, some functions never return the control flow to\nthe caller. Any unlabeled statements that come after such a jump or function call is unreachable.\u003c/p\u003e\n\u003cp\u003eFor instance, within a code block, code following a statement containing any of these keywords is effectively dead code:\u003c/p\u003e\n\u003col\u003e\n  \u003cli\u003e \u003ccode\u003ereturn\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003ebreak\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003econtinue\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003egoto\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003eco_return\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003ethrow\u003c/code\u003e \u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eExamples of functions that never return the control flow to the caller:\u003c/p\u003e\n\u003col\u003e\n  \u003cli\u003e \u003ccode\u003eexit()\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003eabort()\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003estd::terminate()\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e Functions with the \u003ccode\u003e[[noreturn]]\u003c/code\u003e attribute. \u003c/li\u003e\n\u003c/ol\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eThe affected code block should be checked to verify the intended behavior, and the logic should be corrected, or the dead code removed.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nint fun(int a) {\n  int i \u003d 10;\n  return i + a;  // Noncompliant: There are following statements within the code block\n  i++;           // Dead code\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\nint divide(int a, int b) {\n  if (b \u003d\u003d 0) {\n    abort();    // Noncompliant: `abort()` never returns to the caller\n    std::cerr \u0026lt;\u0026lt; \"Divisor is 0!\" \u0026lt;\u0026lt; std::endl; // Dead code\n  }\n  return a / b;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nint fun(int a) {\n  int i \u003d 10;\n  return i + a;\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\nint divide(int a, int b) {\n  if (b \u003d\u003d 0) {\n    std::cerr \u0026lt;\u0026lt; \"Divisor is 0!\" \u0026lt;\u0026lt; std::endl;\n    abort();\n  }\n  return a / b;\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 14.1 - There shall be no unreachable code \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 0-1-1 - A project shall not contain unreachable code \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 2.1 - A project shall not contain unreachable code \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/561\"\u003eMITRE, CWE-561\u003c/a\u003e - Dead Code \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/5dUxBQ\"\u003eCERT, MSC12-C.\u003c/a\u003e - Detect and remove code that has no effect or is never executed\n  \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "cert",
      "cwe",
      "unused"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1764",
    "name": "Identical expressions should not be used on both sides of a binary operator",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eUsing the same value on both sides of a binary operator is a code defect. In the case of logical operators, it is either a copy/paste error and,\ntherefore, a bug, or it is simply duplicated code and should be simplified. In the case of most binary mathematical operators, having the same value\non both sides of an operator yields predictable results and should be simplified as well.\u003c/p\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThe following are ignored:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The expression \u003ccode\u003e1 \u0026lt;\u0026lt; 1\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e When an increment or decrement operator is used, ex: \u003ccode\u003e*p++ \u003d\u003d *p++\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e Bitwise operators \u003ccode\u003e|, \u0026amp;, ^\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e Arithmetic operators \u003ccode\u003e+, *\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e Assignment operators \u003ccode\u003e\u003d, +\u003d, *\u003d\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre\u003e\nvoid foo(int a, int b) {\n  if ( a \u003d\u003d a ) { // Noncompliant: always true\n    // ...\n  }\n\n  if ( a !\u003d a ) { // Noncompliant: always false\n    // ...\n  }\n\n  if ( (a \u003d\u003d b) \u0026amp;\u0026amp; (a \u003d\u003d b) ) { // Noncompliant: if the first condition is true, the second one is too\n    // ...\n  }\n\n  if ( (a \u003d\u003d b) || (a \u003d\u003d b) ) { // Noncompliant: if the first condition is true, the second one is too\n    // ...\n  }\n\n  if ( 5 / 5 ) { // Noncompliant: always 1\n    // ...\n  }\n\n  if ( 5 - 5 ) { // Noncompliant: always 0\n    // ...\n  }\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/5dUxBQ\"\u003eCERT, MSC12-C.\u003c/a\u003e - Detect and remove code that has no effect or is never executed\n  \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S1656} detects self-assignments \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eUsing the same value on both sides of a binary operator is a code defect. In the case of logical operators, it is either a copy/paste error and,\ntherefore, a bug, or it is simply duplicated code and should be simplified. In the case of most binary mathematical operators, having the same value\non both sides of an operator yields predictable results and should be simplified as well.\u003c/p\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThe following are ignored:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The expression \u003ccode\u003e1 \u0026lt;\u0026lt; 1\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e When an increment or decrement operator is used, ex: \u003ccode\u003e*p++ \u003d\u003d *p++\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e Bitwise operators \u003ccode\u003e|, \u0026amp;, ^\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e Arithmetic operators \u003ccode\u003e+, *\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e Assignment operators \u003ccode\u003e\u003d, +\u003d, *\u003d\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre\u003e\nvoid foo(int a, int b) {\n  if ( a \u003d\u003d a ) { // Noncompliant: always true\n    // ...\n  }\n\n  if ( a !\u003d a ) { // Noncompliant: always false\n    // ...\n  }\n\n  if ( (a \u003d\u003d b) \u0026amp;\u0026amp; (a \u003d\u003d b) ) { // Noncompliant: if the first condition is true, the second one is too\n    // ...\n  }\n\n  if ( (a \u003d\u003d b) || (a \u003d\u003d b) ) { // Noncompliant: if the first condition is true, the second one is too\n    // ...\n  }\n\n  if ( 5 / 5 ) { // Noncompliant: always 1\n    // ...\n  }\n\n  if ( 5 - 5 ) { // Noncompliant: always 0\n    // ...\n  }\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/5dUxBQ\"\u003eCERT, MSC12-C.\u003c/a\u003e - Detect and remove code that has no effect or is never executed\n  \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S1656} detects self-assignments \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cert"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S3935",
    "name": "\"case\" ranges should not be empty",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe GNU compiler gives the possibility to specify a range of consecutive values in a \u003ccode\u003ecase\u003c/code\u003e label, for example: \u003ccode\u003ecase: 1 ...\n5\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eHowever, if the values are written in decreasing order, i.e., from the larger value to the smaller one, the range will evaluate as empty. So the\n\u003ccode\u003ecase\u003c/code\u003e body will never be executed.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eThe rule raises an issue when a range specified in a \u003ccode\u003ecase\u003c/code\u003e label is in decreasing order. Swap the values to define a valid range.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nswitch (i) {\n  case 0:\n    //...\n    break;\n  case 1 ... 2:\n    //...\n    break;\n  case 5 ... 3: // Noncompliant: it evaluates as empty, so the code will never be executed\n    //...\n    break;\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nswitch (i) {\n  case 0:\n    //...\n    break;\n  case 1 ... 2:\n    //...\n    break;\n  case 3 ... 5\n    //...\n    break;\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e GCC - \u003ca href\u003d\"https://gcc.gnu.org/onlinedocs/gcc/Case-Ranges.html\"\u003eCase Ranges\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe GNU compiler gives the possibility to specify a range of consecutive values in a \u003ccode\u003ecase\u003c/code\u003e label, for example: \u003ccode\u003ecase: 1 ...\n5\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eHowever, if the values are written in decreasing order, i.e., from the larger value to the smaller one, the range will evaluate as empty. So the\n\u003ccode\u003ecase\u003c/code\u003e body will never be executed.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eThe rule raises an issue when a range specified in a \u003ccode\u003ecase\u003c/code\u003e label is in decreasing order. Swap the values to define a valid range.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nswitch (i) {\n  case 0:\n    //...\n    break;\n  case 1 ... 2:\n    //...\n    break;\n  case 5 ... 3: // Noncompliant: it evaluates as empty, so the code will never be executed\n    //...\n    break;\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nswitch (i) {\n  case 0:\n    //...\n    break;\n  case 1 ... 2:\n    //...\n    break;\n  case 3 ... 5\n    //...\n    break;\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e GCC - \u003ca href\u003d\"https://gcc.gnu.org/onlinedocs/gcc/Case-Ranges.html\"\u003eCase Ranges\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "gnu"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1878",
    "name": "\"union\" names should comply with a naming convention",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "IDENTIFIABLE",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eSharing some naming conventions enables teams to collaborate more efficiently. This rule checks that all \u003ccode\u003eunion\u003c/code\u003e names match a provided\nregular expression.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cp\u003eUsing the default regular expression \u003ccode\u003e^[A-Z][a-zA-Z0-9]*$\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\nunion my_union {\n    int one;\n    int two;\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nunion MyUnion {\n    int one;\n    int two;\n};\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eSharing some naming conventions enables teams to collaborate more efficiently. This rule checks that all \u003ccode\u003eunion\u003c/code\u003e names match a provided\nregular expression.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cp\u003eUsing the default regular expression \u003ccode\u003e^[A-Z][a-zA-Z0-9]*$\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\nunion my_union {\n    int one;\n    int two;\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nunion MyUnion {\n    int one;\n    int two;\n};\n\u003c/pre\u003e"
      }
    ],
    "params": {
      "format": {
        "key": "format",
        "name": "format",
        "description": "POSIX regular expression union names should match.",
        "defaultValue": "^[A-Z][a-zA-Z0-9]*$",
        "type": "STRING",
        "multiple": false,
        "possibleValues": []
      }
    },
    "defaultParams": {
      "format": "^[A-Z][a-zA-Z0-9]*$"
    },
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "convention"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S3936",
    "name": "\"case\" ranges should cover multiple values",
    "defaultSeverity": "BLOCKER",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe GNU compiler extension that allows \u003ccode\u003ecase\u003c/code\u003es to be specified with ranges should only be used when a range is actually needed. Use it\nwith the same number on both ends of the range, and you’ve either made a mistake because an actual range was intended, or you’ve used the syntax\ninappropriately in a way that is highly likely to confuse maintainers.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nswitch (i) {\n  case 0:\n    //...\n    break;\n  case 1 ... 2:\n    //...\n    break;\n  case 3 ... 3: // Noncompliant\n    //...\n    break;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nswitch (i) {\n  case 0:\n    //...\n    break;\n  case 1 ... 2:\n    //...\n    break;\n  case 3:\n    //...\n    break;\n}\n\u003c/pre\u003e\n\u003cp\u003eor\u003c/p\u003e\n\u003cpre\u003e\nswitch (i) {\n  case 0:\n    //...\n    break;\n  case 1 ... 2:\n    //...\n    break;\n  case 3 ... 5:\n    //...\n    break;\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe GNU compiler extension that allows \u003ccode\u003ecase\u003c/code\u003es to be specified with ranges should only be used when a range is actually needed. Use it\nwith the same number on both ends of the range, and you’ve either made a mistake because an actual range was intended, or you’ve used the syntax\ninappropriately in a way that is highly likely to confuse maintainers.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nswitch (i) {\n  case 0:\n    //...\n    break;\n  case 1 ... 2:\n    //...\n    break;\n  case 3 ... 3: // Noncompliant\n    //...\n    break;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nswitch (i) {\n  case 0:\n    //...\n    break;\n  case 1 ... 2:\n    //...\n    break;\n  case 3:\n    //...\n    break;\n}\n\u003c/pre\u003e\n\u003cp\u003eor\u003c/p\u003e\n\u003cpre\u003e\nswitch (i) {\n  case 0:\n    //...\n    break;\n  case 1 ... 2:\n    //...\n    break;\n  case 3 ... 5:\n    //...\n    break;\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "gnu",
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1990",
    "name": "\"final\" should not be used redundantly",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThere is no need to use the \u003ccode\u003efinal\u003c/code\u003e specifier inside a \u003ccode\u003efinal\u003c/code\u003e class. Everything in it is \u003ccode\u003efinal\u003c/code\u003e by default.\u003c/p\u003e\n\u003cp\u003eSimilarly, there is no need to use the \u003ccode\u003efinal\u003c/code\u003e specifier for \u003ccode\u003eunion\u003c/code\u003e, because \u003ccode\u003eunion\u003c/code\u003es can neither extend other\nclasses nor be extended.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass Base {\n  virtual void fun();\n};\n\nclass Derived final : Base {\n  void fun() final;  // Noncompliant\n};\n\nunion MyUnion final { // Noncompliant\n  // ...\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nclass Base {\n  virtual void fun();\n};\n\nclass Derived final : Base {\n  void fun() override;\n};\n\nunion MyUnion {\n  // ...\n};\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThere is no need to use the \u003ccode\u003efinal\u003c/code\u003e specifier inside a \u003ccode\u003efinal\u003c/code\u003e class. Everything in it is \u003ccode\u003efinal\u003c/code\u003e by default.\u003c/p\u003e\n\u003cp\u003eSimilarly, there is no need to use the \u003ccode\u003efinal\u003c/code\u003e specifier for \u003ccode\u003eunion\u003c/code\u003e, because \u003ccode\u003eunion\u003c/code\u003es can neither extend other\nclasses nor be extended.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass Base {\n  virtual void fun();\n};\n\nclass Derived final : Base {\n  void fun() final;  // Noncompliant\n};\n\nunion MyUnion final { // Noncompliant\n  // ...\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nclass Base {\n  virtual void fun();\n};\n\nclass Derived final : Base {\n  void fun() override;\n};\n\nunion MyUnion {\n  // ...\n};\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "convention",
      "since-c++11"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1750",
    "name": "Lambdas should not be used",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eLambdas are a concise way of creating anonymous functions - when those functions are themselves concise. However, the use of lambdas for sizable\nfunctions can make the code difficult to read. More importantly, following variable capture in lambdas can be difficult, potentially leading to\ndangling pointers. Therefore lambdas should be avoided.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint main() {\n  auto func \u003d [] () { std::cout \u0026lt;\u0026lt; \"Hello world\" \u0026lt;\u0026lt; std::endl; };\n  func();\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid func () {\n  std::cout \u0026lt;\u0026lt; \"Hello world\" \u0026lt;\u0026lt; std::endl;\n}\n\nint main() {\n  func();\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eLambdas are a concise way of creating anonymous functions - when those functions are themselves concise. However, the use of lambdas for sizable\nfunctions can make the code difficult to read. More importantly, following variable capture in lambdas can be difficult, potentially leading to\ndangling pointers. Therefore lambdas should be avoided.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint main() {\n  auto func \u003d [] () { std::cout \u0026lt;\u0026lt; \"Hello world\" \u0026lt;\u0026lt; std::endl; };\n  func();\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid func () {\n  std::cout \u0026lt;\u0026lt; \"Hello world\" \u0026lt;\u0026lt; std::endl;\n}\n\nint main() {\n  func();\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "since-c++11"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1871",
    "name": "Two branches in a conditional structure should not have exactly the same implementation",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "DISTINCT",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhen the same code is duplicated in two or more separate branches of a conditional, it can make the code harder to understand, maintain, and can\npotentially introduce bugs if one instance of the code is changed but others are not.\u003c/p\u003e\n\u003cp\u003eHaving two \u003ccode\u003ecases\u003c/code\u003e in a \u003ccode\u003eswitch\u003c/code\u003e statement or two branches in an \u003ccode\u003eif\u003c/code\u003e chain with the same implementation is at\nbest duplicate code, and at worst a coding error.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nif (a \u0026gt;\u003d 0 \u0026amp;\u0026amp; a \u0026lt; 10) {\n  doFirstThing();\n  doTheThing();\n}\nelse if (a \u0026gt;\u003d 10 \u0026amp;\u0026amp; a \u0026lt; 20) {\n  doTheOtherThing();\n}\nelse if (a \u0026gt;\u003d 20 \u0026amp;\u0026amp; a \u0026lt; 50) {\n  doFirstThing();\n  doTheThing();  // Noncompliant; duplicates first condition\n}\nelse {\n  doTheRest();\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\nswitch (i) {\n  case 1:\n    doFirstThing();\n    doSomething();\n    break;\n  case 2:\n    doSomethingDifferent();\n    break;\n  case 3:  // Noncompliant; duplicates case 1\u0027s implementation\n    doFirstThing();\n    doSomething();\n    break;\n  default:\n    doTheRest();\n}\n\u003c/pre\u003e\n\u003cp\u003eIf the same logic is truly needed for both instances, then:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e in an \u003ccode\u003eif\u003c/code\u003e chain they should be combined \u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nif ((a \u0026gt;\u003d 0 \u0026amp;\u0026amp; a \u0026lt; 10) || (a \u0026gt;\u003d 20 \u0026amp;\u0026amp; a \u0026lt; 50)) { // Compliant\n  doFirstThing();\n  doTheThing();\n}\nelse if (a \u0026gt;\u003d 10 \u0026amp;\u0026amp; a \u0026lt; 20) {\n  doTheOtherThing();\n}\nelse {\n  doTheRest();\n}\n\u003c/pre\u003e\n\u003cul\u003e\n  \u003cli\u003e for a \u003ccode\u003eswitch\u003c/code\u003e, one should fall through to the other \u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\nswitch (i) {\n  case 1:\n  case 3: // Compliant\n    doFirstThing();\n    doSomething();\n    break;\n  case 2:\n    doSomethingDifferent();\n    break;\n  default:\n    doTheRest();\n}\n\u003c/pre\u003e\n\u003cp\u003eWhen all blocks are identical, either this rule will trigger if there is no default clause or rule {rule:cpp:S3923} will raise if there is a\ndefault clause.\u003c/p\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eUnless all blocks are identical, blocks in an \u003ccode\u003eif\u003c/code\u003e chain that contain a single line of code are ignored. The same applies to blocks in a\n\u003ccode\u003eswitch\u003c/code\u003e statement that contains a single line of code with or without a following \u003ccode\u003ebreak\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\nif (a \u003d\u003d 1) {\n  doSomething();  // Compliant, usually this is done on purpose to increase the readability\n} else if (a \u003d\u003d 2) {\n  doSomethingElse();\n} else {\n  doSomething();\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S3923} - All branches in a conditional structure should not have exactly the same implementation \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhen the same code is duplicated in two or more separate branches of a conditional, it can make the code harder to understand, maintain, and can\npotentially introduce bugs if one instance of the code is changed but others are not.\u003c/p\u003e\n\u003cp\u003eHaving two \u003ccode\u003ecases\u003c/code\u003e in a \u003ccode\u003eswitch\u003c/code\u003e statement or two branches in an \u003ccode\u003eif\u003c/code\u003e chain with the same implementation is at\nbest duplicate code, and at worst a coding error.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nif (a \u0026gt;\u003d 0 \u0026amp;\u0026amp; a \u0026lt; 10) {\n  doFirstThing();\n  doTheThing();\n}\nelse if (a \u0026gt;\u003d 10 \u0026amp;\u0026amp; a \u0026lt; 20) {\n  doTheOtherThing();\n}\nelse if (a \u0026gt;\u003d 20 \u0026amp;\u0026amp; a \u0026lt; 50) {\n  doFirstThing();\n  doTheThing();  // Noncompliant; duplicates first condition\n}\nelse {\n  doTheRest();\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\nswitch (i) {\n  case 1:\n    doFirstThing();\n    doSomething();\n    break;\n  case 2:\n    doSomethingDifferent();\n    break;\n  case 3:  // Noncompliant; duplicates case 1\u0027s implementation\n    doFirstThing();\n    doSomething();\n    break;\n  default:\n    doTheRest();\n}\n\u003c/pre\u003e\n\u003cp\u003eIf the same logic is truly needed for both instances, then:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e in an \u003ccode\u003eif\u003c/code\u003e chain they should be combined \u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nif ((a \u0026gt;\u003d 0 \u0026amp;\u0026amp; a \u0026lt; 10) || (a \u0026gt;\u003d 20 \u0026amp;\u0026amp; a \u0026lt; 50)) { // Compliant\n  doFirstThing();\n  doTheThing();\n}\nelse if (a \u0026gt;\u003d 10 \u0026amp;\u0026amp; a \u0026lt; 20) {\n  doTheOtherThing();\n}\nelse {\n  doTheRest();\n}\n\u003c/pre\u003e\n\u003cul\u003e\n  \u003cli\u003e for a \u003ccode\u003eswitch\u003c/code\u003e, one should fall through to the other \u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\nswitch (i) {\n  case 1:\n  case 3: // Compliant\n    doFirstThing();\n    doSomething();\n    break;\n  case 2:\n    doSomethingDifferent();\n    break;\n  default:\n    doTheRest();\n}\n\u003c/pre\u003e\n\u003cp\u003eWhen all blocks are identical, either this rule will trigger if there is no default clause or rule {rule:cpp:S3923} will raise if there is a\ndefault clause.\u003c/p\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eUnless all blocks are identical, blocks in an \u003ccode\u003eif\u003c/code\u003e chain that contain a single line of code are ignored. The same applies to blocks in a\n\u003ccode\u003eswitch\u003c/code\u003e statement that contains a single line of code with or without a following \u003ccode\u003ebreak\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\nif (a \u003d\u003d 1) {\n  doSomething();  // Compliant, usually this is done on purpose to increase the readability\n} else if (a \u003d\u003d 2) {\n  doSomethingElse();\n} else {\n  doSomething();\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S3923} - All branches in a conditional structure should not have exactly the same implementation \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "design",
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1751",
    "name": "Loops with at most one iteration should be refactored",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eA loop with at most one iteration is equivalent to the use of an \u003ccode\u003eif\u003c/code\u003e statement to conditionally execute one piece of code. No developer\nexpects to find such a use of a loop statement. If the initial intention of the author was really to conditionally execute one piece of code, an\n\u003ccode\u003eif\u003c/code\u003e statement should be used instead.\u003c/p\u003e\n\u003cp\u003eAt worst that was not the initial intention of the author and so the body of the loop should be fixed to use the nested \u003ccode\u003ereturn\u003c/code\u003e,\n\u003ccode\u003ebreak\u003c/code\u003e or \u003ccode\u003ethrow\u003c/code\u003e statements in a more appropriate way.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nfor (int i \u003d 0; i \u0026lt; 10; i++) { // noncompliant, loop only executes once\n  printf(\"i is %d\", i);\n  break;\n}\n...\nfor (int i \u003d 0; i \u0026lt; 10; i++) { // noncompliant, loop only executes once\n  if (i \u003d\u003d x) {\n    break;\n  } else {\n    printf(\"i is %d\", i);\n    return;\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nfor (int i \u003d 0; i \u0026lt; 10; i++) {\n  printf(\"i is %d\", i);\n}\n...\nfor (int i \u003d 0; i \u0026lt; 10; i++) {\n  if (i \u003d\u003d x) {\n    break;\n  } else {\n    printf(\"i is %d\", i);\n  }\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eA loop with at most one iteration is equivalent to the use of an \u003ccode\u003eif\u003c/code\u003e statement to conditionally execute one piece of code. No developer\nexpects to find such a use of a loop statement. If the initial intention of the author was really to conditionally execute one piece of code, an\n\u003ccode\u003eif\u003c/code\u003e statement should be used instead.\u003c/p\u003e\n\u003cp\u003eAt worst that was not the initial intention of the author and so the body of the loop should be fixed to use the nested \u003ccode\u003ereturn\u003c/code\u003e,\n\u003ccode\u003ebreak\u003c/code\u003e or \u003ccode\u003ethrow\u003c/code\u003e statements in a more appropriate way.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nfor (int i \u003d 0; i \u0026lt; 10; i++) { // noncompliant, loop only executes once\n  printf(\"i is %d\", i);\n  break;\n}\n...\nfor (int i \u003d 0; i \u0026lt; 10; i++) { // noncompliant, loop only executes once\n  if (i \u003d\u003d x) {\n    break;\n  } else {\n    printf(\"i is %d\", i);\n    return;\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nfor (int i \u003d 0; i \u0026lt; 10; i++) {\n  printf(\"i is %d\", i);\n}\n...\nfor (int i \u003d 0; i \u0026lt; 10; i++) {\n  if (i \u003d\u003d x) {\n    break;\n  } else {\n    printf(\"i is %d\", i);\n  }\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1874",
    "name": "Code annotated as deprecated should not be used",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eCode is sometimes annotated as deprecated by developers maintaining libraries or APIs to indicate that the method, class, or other programming\nelement is no longer recommended for use. This is typically due to the introduction of a newer or more effective alternative. For example, when a\nbetter solution has been identified, or when the existing code presents potential errors or security risks.\u003c/p\u003e\n\u003cp\u003eDeprecation is a good practice because it helps to phase out obsolete code in a controlled manner, without breaking existing software that may\nstill depend on it. It is a way to warn other developers not to use the deprecated element in new code, and to replace it in existing code when\npossible.\u003c/p\u003e\n\u003cp\u003eDeprecated classes, interfaces, and their members should not be used, inherited or extended because they will eventually be removed. The\ndeprecation period allows you to make a smooth transition away from the aging, soon-to-be-retired technology.\u003c/p\u003e\n\u003cp\u003eCheck the documentation or the deprecation message to understand why the code was deprecated and what the recommended alternative is.\u003c/p\u003e\n\u003cpre\u003e\n// C++14 attribute\n[[deprecated(\"Use newFunction instead.\")]]\nvoid oldFunction();\n\n// GNU attribute\n__attribute__((deprecated(\"Use newFunction instead.\")))\nvoid oldFunction();\n\n// Microsoft attribute\n__declspec(deprecated(\"Use newFunction instead.\"))\nvoid oldFunction();\n\nvoid newFunction();\n\nvoid example() {\n  oldFunction(); // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/477\"\u003eMITRE, CWE-477\u003c/a\u003e - Use of Obsolete Functions \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eCode is sometimes annotated as deprecated by developers maintaining libraries or APIs to indicate that the method, class, or other programming\nelement is no longer recommended for use. This is typically due to the introduction of a newer or more effective alternative. For example, when a\nbetter solution has been identified, or when the existing code presents potential errors or security risks.\u003c/p\u003e\n\u003cp\u003eDeprecation is a good practice because it helps to phase out obsolete code in a controlled manner, without breaking existing software that may\nstill depend on it. It is a way to warn other developers not to use the deprecated element in new code, and to replace it in existing code when\npossible.\u003c/p\u003e\n\u003cp\u003eDeprecated classes, interfaces, and their members should not be used, inherited or extended because they will eventually be removed. The\ndeprecation period allows you to make a smooth transition away from the aging, soon-to-be-retired technology.\u003c/p\u003e\n\u003cp\u003eCheck the documentation or the deprecation message to understand why the code was deprecated and what the recommended alternative is.\u003c/p\u003e\n\u003cpre\u003e\n// C++14 attribute\n[[deprecated(\"Use newFunction instead.\")]]\nvoid oldFunction();\n\n// GNU attribute\n__attribute__((deprecated(\"Use newFunction instead.\")))\nvoid oldFunction();\n\n// Microsoft attribute\n__declspec(deprecated(\"Use newFunction instead.\"))\nvoid oldFunction();\n\nvoid newFunction();\n\nvoid example() {\n  oldFunction(); // Noncompliant\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/477\"\u003eMITRE, CWE-477\u003c/a\u003e - Use of Obsolete Functions \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cert",
      "cwe",
      "obsolete"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S912",
    "name": "The right-hand operands of \u0026\u0026 and || should not contain side effects",
    "defaultSeverity": "BLOCKER",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThere are some situations in C++ where certain parts of expressions may not be evaluated. If these sub-expressions contain side effects then those\nside effects may or may not occur, depending on the values of other sub expressions. The operators which can lead to this problem are\n\u003ccode\u003e\u0026amp;\u0026amp;\u003c/code\u003e and \u003ccode\u003e||\u003c/code\u003e, where the evaluation of the right-hand operand is conditional on the value of the left-hand operand. The\nconditional evaluation of the right-hand operand of one of the logical operators can easily cause problems if the developer relies on a side effect\noccurring.\u003c/p\u003e\n\u003cp\u003eOperations that cause side effects are:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e accessing a volatile object \u003c/li\u003e\n  \u003cli\u003e modifying an object \u003c/li\u003e\n  \u003cli\u003e modifying a file \u003c/li\u003e\n  \u003cli\u003e calling a function that performs any operations that cause changes in the state of the execution environment of the calling function. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis rule raises an issue when there is assignment or the use of the increment/decrement operators in right-hand operands.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nif ( ishigh \u0026amp;\u0026amp; ( x \u003d\u003d i++ ) ) // Noncompliant\n...\nif ( ishigh \u0026amp;\u0026amp; ( x \u003d\u003d  getX() ) ) // Only acceptable if getX() is known to have no side effects\n\u003c/pre\u003e\n\u003cp\u003eThe operations that cause side effects are accessing a volatile object, modifying an object, modifying a file, or calling a function\u003c/p\u003e\n\u003cp\u003ethat does any of those operations, which cause changes in the state of the execution environment of the calling function.\u003c/p\u003e\n\u003cp\u003eFor the time being, this rule only check that there is no assignment or no use of increment/decrement operators made in right hand operands.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 12.4 - The right-hand operand of a logical \u0026amp;\u0026amp; or || operator shall not contain side effects. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 5-14-1 - The right hand operand of a logical \u0026amp;\u0026amp; or || operator shall not contain side effects. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 13.5 - The right hand operand of a logical \u0026amp;\u0026amp; or || operator shall not contain persistent side effects \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/vdUxBQ\"\u003eCERT, EXP02-C.\u003c/a\u003e - Be aware of the short-circuit behavior of the logical AND and OR\n  operators \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThere are some situations in C++ where certain parts of expressions may not be evaluated. If these sub-expressions contain side effects then those\nside effects may or may not occur, depending on the values of other sub expressions. The operators which can lead to this problem are\n\u003ccode\u003e\u0026amp;\u0026amp;\u003c/code\u003e and \u003ccode\u003e||\u003c/code\u003e, where the evaluation of the right-hand operand is conditional on the value of the left-hand operand. The\nconditional evaluation of the right-hand operand of one of the logical operators can easily cause problems if the developer relies on a side effect\noccurring.\u003c/p\u003e\n\u003cp\u003eOperations that cause side effects are:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e accessing a volatile object \u003c/li\u003e\n  \u003cli\u003e modifying an object \u003c/li\u003e\n  \u003cli\u003e modifying a file \u003c/li\u003e\n  \u003cli\u003e calling a function that performs any operations that cause changes in the state of the execution environment of the calling function. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis rule raises an issue when there is assignment or the use of the increment/decrement operators in right-hand operands.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nif ( ishigh \u0026amp;\u0026amp; ( x \u003d\u003d i++ ) ) // Noncompliant\n...\nif ( ishigh \u0026amp;\u0026amp; ( x \u003d\u003d  getX() ) ) // Only acceptable if getX() is known to have no side effects\n\u003c/pre\u003e\n\u003cp\u003eThe operations that cause side effects are accessing a volatile object, modifying an object, modifying a file, or calling a function\u003c/p\u003e\n\u003cp\u003ethat does any of those operations, which cause changes in the state of the execution environment of the calling function.\u003c/p\u003e\n\u003cp\u003eFor the time being, this rule only check that there is no assignment or no use of increment/decrement operators made in right hand operands.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 12.4 - The right-hand operand of a logical \u0026amp;\u0026amp; or || operator shall not contain side effects. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 5-14-1 - The right hand operand of a logical \u0026amp;\u0026amp; or || operator shall not contain side effects. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 13.5 - The right hand operand of a logical \u0026amp;\u0026amp; or || operator shall not contain persistent side effects \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/vdUxBQ\"\u003eCERT, EXP02-C.\u003c/a\u003e - Be aware of the short-circuit behavior of the logical AND and OR\n  operators \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "cert"
    ],
    "deprecatedKeys": [
      "cpp:SideEffectInRightHandSideOfLogical"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S919",
    "name": "The comma operator, \"\u0026\u0026\", and \"||\" should not be overloaded",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eOverloaded versions of the comma and logical conjunction operators have the semantics of function calls whose sequence point and ordering semantics\nare different from those of the built-in versions. It may not be clear at the point of use that these operators are overloaded, and so developers may\nbe unaware which semantics apply.\u003c/p\u003e\n\u003cp\u003eException: Starting from \u003cem\u003eC++17\u003c/em\u003e, the order of evaluation of the comma operator is defined and identical for the builtin and the overloaded\nversions. In such circumstances, the comma operator can safely be overloaded.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include \"util.h\"\nclass A\n{\npublic:\n  UtilType getValue ( );\n  UtilType setValue ( UtilType const \u0026amp; );\n};\nvoid f1 ( A \u0026amp; a1, A \u0026amp; a2 )\n{\n  a1.getValue ( ) \u0026amp;\u0026amp; a2.setValue ( 0 );\t// Short circuiting may occur\n}\nbool operator \u0026amp;\u0026amp; ( UtilType const \u0026amp;, UtilType const \u0026amp; ); // Noncompliant\nvoid f2 ( A \u0026amp; a1, A \u0026amp; a2 )\n{\n  a1.getValue ( ) \u0026amp;\u0026amp; a2.setValue ( 0 ); // Both operands evaluated if type returned has overloaded operator\u0026amp;\u0026amp;\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++ 2008, 5-2-11 - The comma operator, \u0026amp;\u0026amp; operator and the || operator shall not be overloaded. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eOverloaded versions of the comma and logical conjunction operators have the semantics of function calls whose sequence point and ordering semantics\nare different from those of the built-in versions. It may not be clear at the point of use that these operators are overloaded, and so developers may\nbe unaware which semantics apply.\u003c/p\u003e\n\u003cp\u003eException: Starting from \u003cem\u003eC++17\u003c/em\u003e, the order of evaluation of the comma operator is defined and identical for the builtin and the overloaded\nversions. In such circumstances, the comma operator can safely be overloaded.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include \"util.h\"\nclass A\n{\npublic:\n  UtilType getValue ( );\n  UtilType setValue ( UtilType const \u0026amp; );\n};\nvoid f1 ( A \u0026amp; a1, A \u0026amp; a2 )\n{\n  a1.getValue ( ) \u0026amp;\u0026amp; a2.setValue ( 0 );\t// Short circuiting may occur\n}\nbool operator \u0026amp;\u0026amp; ( UtilType const \u0026amp;, UtilType const \u0026amp; ); // Noncompliant\nvoid f2 ( A \u0026amp; a1, A \u0026amp; a2 )\n{\n  a1.getValue ( ) \u0026amp;\u0026amp; a2.setValue ( 0 ); // Both operands evaluated if type returned has overloaded operator\u0026amp;\u0026amp;\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C++ 2008, 5-2-11 - The comma operator, \u0026amp;\u0026amp; operator and the || operator shall not be overloaded. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "misra-c++2008"
    ],
    "deprecatedKeys": [
      "cpp:CommaAndOrOverloaded"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S916",
    "name": "Switch labels should not be nested inside non-switch blocks",
    "defaultSeverity": "BLOCKER",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eA switch-label can be placed anywhere within the statements that form the body of a switch statement, potentially leading to unstructured code. To\nprevent this from happening, the scope of a case-label or default-label shall be the statement forming the body of a switch statement. All\ncase-clauses and the default-clause shall be at the same scope.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nswitch (x) {\n  case 1: // Compliant\n    if (foo) {\n      case 2: // Noncompliant\n        break;\n      default: // Noncompliant\n        break;\n    }\n    break;\n  default: // Compliant\n    break;\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C 2004, 15.1 - A switch label shall only be used when the most closely-enclosing compound statement is the body of a switch statement.\n  \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2008, 6-4-4 - A switch-label shall only be used when the most closely-enclosing compound statement is the body of a switch statement.\n  \u003c/li\u003e\n  \u003cli\u003e MISRA C 2012, 16.2 - A switch label shall only be used when the most closely-enclsoing compound statement is the body of a switch statement\n  \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eA switch-label can be placed anywhere within the statements that form the body of a switch statement, potentially leading to unstructured code. To\nprevent this from happening, the scope of a case-label or default-label shall be the statement forming the body of a switch statement. All\ncase-clauses and the default-clause shall be at the same scope.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nswitch (x) {\n  case 1: // Compliant\n    if (foo) {\n      case 2: // Noncompliant\n        break;\n      default: // Noncompliant\n        break;\n    }\n    break;\n  default: // Compliant\n    break;\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C 2004, 15.1 - A switch label shall only be used when the most closely-enclosing compound statement is the body of a switch statement.\n  \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2008, 6-4-4 - A switch-label shall only be used when the most closely-enclosing compound statement is the body of a switch statement.\n  \u003c/li\u003e\n  \u003cli\u003e MISRA C 2012, 16.2 - A switch label shall only be used when the most closely-enclsoing compound statement is the body of a switch statement\n  \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "confusing",
      "misra-c++2008",
      "misra-c2004",
      "misra-c2012"
    ],
    "deprecatedKeys": [
      "cpp:SwitchLabelPlacement"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S2755",
    "name": "XML parsers should not be vulnerable to XXE attacks",
    "defaultSeverity": "BLOCKER",
    "type": "VULNERABILITY",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "SECURITY": "HIGH"
    },
    "description": "\u003cp\u003eThis vulnerability allows the usage of external entities in XML.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eExternal Entity Processing allows for XML parsing with the involvement of external entities. However, when this functionality is enabled without\nproper precautions, it can lead to a vulnerability known as XML External Entity (XXE) attack.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003ch4\u003eExposing sensitive data\u003c/h4\u003e\n\u003cp\u003eOne significant danger of XXE vulnerabilities is the potential for sensitive data exposure. By crafting malicious XML payloads, attackers can\nreference external entities that contain sensitive information, such as system files, database credentials, or configuration files. When these\nentities are processed during XML parsing, the attacker can extract the contents and gain unauthorized access to sensitive data. This poses a severe\nthreat to the confidentiality of critical information.\u003c/p\u003e\n\u003ch4\u003eExhausting system resources\u003c/h4\u003e\n\u003cp\u003eAnother consequence of XXE vulnerabilities is the potential for denial-of-service attacks. By exploiting the ability to include external entities,\nattackers can construct XML payloads that cause resource exhaustion. This can overwhelm the system’s memory, CPU, or other critical resources, leading\nto system unresponsiveness or crashes. A successful DoS attack can disrupt the availability of services and negatively impact the user experience.\u003c/p\u003e\n\u003ch4\u003eForging requests\u003c/h4\u003e\n\u003cp\u003eXXE vulnerabilities can also enable Server-Side Request Forgery (SSRF) attacks. By leveraging the ability to include external entities, an attacker\ncan make the vulnerable application send arbitrary requests to other internal or external systems. This can result in unintended actions, such as\nretrieving data from internal resources, scanning internal networks, or attacking other systems. SSRF attacks can lead to severe consequences,\nincluding unauthorized data access, system compromise, or even further exploitation within the network infrastructure.\u003c/p\u003e\n\u003ch2\u003eHow to fix it in Xerces\u003c/h2\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003cp\u003eThe following code contains examples of XML parsers that have external entity processing enabled. As a result, the parsers are vulnerable to XXE\nattacks if an attacker can control the XML file that is processed.\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"11\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \"xercesc/parsers/XercesDOMParser.hpp\"\n\nvoid parse() {\n  XercesDOMParser *DOMparser \u003d new XercesDOMParser();\n  DOMparser-\u0026gt;setCreateEntityReferenceNodes(false); // Noncompliant\n  DOMparser-\u0026gt;setDisableDefaultEntityResolution(false); // Noncompliant\n\n  DOMparser-\u0026gt;parse(xmlFile);\n}\n\u003c/pre\u003e\n\u003cp\u003eBy default, entities resolution is enabled for \u003ccode\u003eXMLReaderFactory::createXMLReader\u003c/code\u003e.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"12\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \"xercesc/sax2/SAX2XMLReader.hpp\"\n\nvoid parse() {\n  SAX2XMLReader* reader \u003d XMLReaderFactory::createXMLReader();\n  reader-\u0026gt;setFeature(XMLUni::fgXercesDisableDefaultEntityResolution, false); // Noncompliant\n\n  reader-\u0026gt;parse(xmlFile);\n}\n\u003c/pre\u003e\n\u003cp\u003eBy default, entities resolution is enabled for \u003ccode\u003eSAXParser\u003c/code\u003e.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"13\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \"xercesc/parsers/SAXParser.hpp\"\n\nvoid parse() {\n  SAXParser* SAXparser \u003d new SAXParser();\n  SAXparser-\u0026gt;setDisableDefaultEntityResolution(false); // Noncompliant\n\n  SAXparser-\u0026gt;parse(xmlFile);\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eBy default, \u003ccode\u003eXercesDOMParser\u003c/code\u003e is safe.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"11\" data-diff-type\u003d\"compliant\"\u003e\n#include \"xercesc/parsers/XercesDOMParser.hpp\"\n\nvoid parse() {\n  XercesDOMParser *DOMparser \u003d new XercesDOMParser();\n  DOMparser-\u0026gt;setCreateEntityReferenceNodes(true);\n  DOMparser-\u0026gt;setDisableDefaultEntityResolution(true);\n\n  DOMparser-\u0026gt;parse(xmlFile);\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"12\" data-diff-type\u003d\"compliant\"\u003e\n#include \"xercesc/sax2/SAX2XMLReader.hpp\"\n\nvoid parse() {\n  SAX2XMLReader* reader \u003d XMLReaderFactory::createXMLReader();\n  reader-\u0026gt;setFeature(XMLUni::fgXercesDisableDefaultEntityResolution, true);\n\n  reader-\u0026gt;parse(xmlFile);\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"13\" data-diff-type\u003d\"compliant\"\u003e\n#include \"xercesc/parsers/SAXParser.hpp\"\n\nvoid parse() {\n  SAXParser* SAXparser \u003d new SAXParser();\n  SAXparser-\u0026gt;setDisableDefaultEntityResolution(true);\n\n  SAXparser-\u0026gt;parse(xmlFile);\n}\n\u003c/pre\u003e\n\u003ch3\u003eHow does this work?\u003c/h3\u003e\n\u003ch4\u003eDisable external entities\u003c/h4\u003e\n\u003cp\u003eThe most effective approach to prevent XXE vulnerabilities is to disable external entity processing entirely, unless it is explicitly required for\nspecific use cases. By default, XML parsers should be configured to reject the processing of external entities. This can be achieved by setting the\nappropriate properties or options in your XML parser library or framework.\u003c/p\u003e\n\u003cp\u003eIf external entity processing is necessary for certain scenarios, adopt a whitelisting approach to restrict the entities that can be resolved\nduring XML parsing. Create a list of trusted external entities and disallow all others. This approach ensures that only known and safe entities are\nprocessed.\u003cbr\u003e You should rely on features provided by your XML parser to restrict the external entities.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/Top10/A05_2021-Security_Misconfiguration/\"\u003eOWASP Top 10 2021 Category A5\u003c/a\u003e - Security Misconfiguration \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/www-project-top-ten/2017/A4_2017-XML_External_Entities_(XXE)\"\u003eOWASP Top 10 2017 Category A4\u003c/a\u003e - XML External\n  Entities (XXE) \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/611\"\u003eMITRE, CWE-611\u003c/a\u003e - Information Exposure Through XML External Entity Reference \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/827\"\u003eMITRE, CWE-827\u003c/a\u003e - Improper Control of Document Type Definition \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eThis vulnerability allows the usage of external entities in XML.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eExternal Entity Processing allows for XML parsing with the involvement of external entities. However, when this functionality is enabled without\nproper precautions, it can lead to a vulnerability known as XML External Entity (XXE) attack.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003ch4\u003eExposing sensitive data\u003c/h4\u003e\n\u003cp\u003eOne significant danger of XXE vulnerabilities is the potential for sensitive data exposure. By crafting malicious XML payloads, attackers can\nreference external entities that contain sensitive information, such as system files, database credentials, or configuration files. When these\nentities are processed during XML parsing, the attacker can extract the contents and gain unauthorized access to sensitive data. This poses a severe\nthreat to the confidentiality of critical information.\u003c/p\u003e\n\u003ch4\u003eExhausting system resources\u003c/h4\u003e\n\u003cp\u003eAnother consequence of XXE vulnerabilities is the potential for denial-of-service attacks. By exploiting the ability to include external entities,\nattackers can construct XML payloads that cause resource exhaustion. This can overwhelm the system’s memory, CPU, or other critical resources, leading\nto system unresponsiveness or crashes. A successful DoS attack can disrupt the availability of services and negatively impact the user experience.\u003c/p\u003e\n\u003ch4\u003eForging requests\u003c/h4\u003e\n\u003cp\u003eXXE vulnerabilities can also enable Server-Side Request Forgery (SSRF) attacks. By leveraging the ability to include external entities, an attacker\ncan make the vulnerable application send arbitrary requests to other internal or external systems. This can result in unintended actions, such as\nretrieving data from internal resources, scanning internal networks, or attacking other systems. SSRF attacks can lead to severe consequences,\nincluding unauthorized data access, system compromise, or even further exploitation within the network infrastructure.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eThe following code contains examples of XML parsers that have external entity processing enabled. As a result, the parsers are vulnerable to XXE\nattacks if an attacker can control the XML file that is processed.\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"11\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \"xercesc/parsers/XercesDOMParser.hpp\"\n\nvoid parse() {\n  XercesDOMParser *DOMparser \u003d new XercesDOMParser();\n  DOMparser-\u0026gt;setCreateEntityReferenceNodes(false); // Noncompliant\n  DOMparser-\u0026gt;setDisableDefaultEntityResolution(false); // Noncompliant\n\n  DOMparser-\u0026gt;parse(xmlFile);\n}\n\u003c/pre\u003e\n\u003cp\u003eBy default, entities resolution is enabled for \u003ccode\u003eXMLReaderFactory::createXMLReader\u003c/code\u003e.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"12\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \"xercesc/sax2/SAX2XMLReader.hpp\"\n\nvoid parse() {\n  SAX2XMLReader* reader \u003d XMLReaderFactory::createXMLReader();\n  reader-\u0026gt;setFeature(XMLUni::fgXercesDisableDefaultEntityResolution, false); // Noncompliant\n\n  reader-\u0026gt;parse(xmlFile);\n}\n\u003c/pre\u003e\n\u003cp\u003eBy default, entities resolution is enabled for \u003ccode\u003eSAXParser\u003c/code\u003e.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"13\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \"xercesc/parsers/SAXParser.hpp\"\n\nvoid parse() {\n  SAXParser* SAXparser \u003d new SAXParser();\n  SAXparser-\u0026gt;setDisableDefaultEntityResolution(false); // Noncompliant\n\n  SAXparser-\u0026gt;parse(xmlFile);\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eBy default, \u003ccode\u003eXercesDOMParser\u003c/code\u003e is safe.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"11\" data-diff-type\u003d\"compliant\"\u003e\n#include \"xercesc/parsers/XercesDOMParser.hpp\"\n\nvoid parse() {\n  XercesDOMParser *DOMparser \u003d new XercesDOMParser();\n  DOMparser-\u0026gt;setCreateEntityReferenceNodes(true);\n  DOMparser-\u0026gt;setDisableDefaultEntityResolution(true);\n\n  DOMparser-\u0026gt;parse(xmlFile);\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"12\" data-diff-type\u003d\"compliant\"\u003e\n#include \"xercesc/sax2/SAX2XMLReader.hpp\"\n\nvoid parse() {\n  SAX2XMLReader* reader \u003d XMLReaderFactory::createXMLReader();\n  reader-\u0026gt;setFeature(XMLUni::fgXercesDisableDefaultEntityResolution, true);\n\n  reader-\u0026gt;parse(xmlFile);\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"13\" data-diff-type\u003d\"compliant\"\u003e\n#include \"xercesc/parsers/SAXParser.hpp\"\n\nvoid parse() {\n  SAXParser* SAXparser \u003d new SAXParser();\n  SAXparser-\u0026gt;setDisableDefaultEntityResolution(true);\n\n  SAXparser-\u0026gt;parse(xmlFile);\n}\n\u003c/pre\u003e\n\u003ch3\u003eHow does this work?\u003c/h3\u003e\n\u003ch4\u003eDisable external entities\u003c/h4\u003e\n\u003cp\u003eThe most effective approach to prevent XXE vulnerabilities is to disable external entity processing entirely, unless it is explicitly required for\nspecific use cases. By default, XML parsers should be configured to reject the processing of external entities. This can be achieved by setting the\nappropriate properties or options in your XML parser library or framework.\u003c/p\u003e\n\u003cp\u003eIf external entity processing is necessary for certain scenarios, adopt a whitelisting approach to restrict the entities that can be resolved\nduring XML parsing. Create a list of trusted external entities and disallow all others. This approach ensures that only known and safe entities are\nprocessed.\u003cbr\u003e You should rely on features provided by your XML parser to restrict the external entities.\u003c/p\u003e",
        "context": {
          "key": "xerces",
          "displayName": "Xerces"
        }
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eThe following code contains examples of XML parsers that have external entity processing enabled. As a result, the parsers are vulnerable to XXE\nattacks if an attacker can control the XML file that is processed.\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \"libxml/parser.h\"\n\nvoid parse() {\n  xmlDocPtr doc \u003d xmlReadFile(xmlFile, nullptr, XML_PARSE_DTDLOAD | XML_PARSE_NOENT); // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eBy default, \u003ccode\u003exmlReadFile\u003c/code\u003e is safe since version 2.9.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \"libxml/parser.h\"\n\nvoid parse() {\n  xmlDocPtr doc \u003d xmlReadFile(xmlFile, nullptr, 0);\n}\n\u003c/pre\u003e\n\u003ch3\u003eHow does this work?\u003c/h3\u003e\n\u003ch4\u003eDisable external entities\u003c/h4\u003e\n\u003cp\u003eThe most effective approach to prevent XXE vulnerabilities is to disable external entity processing entirely, unless it is explicitly required for\nspecific use cases. By default, XML parsers should be configured to reject the processing of external entities. This can be achieved by setting the\nappropriate properties or options in your XML parser library or framework.\u003c/p\u003e\n\u003cp\u003eIf external entity processing is necessary for certain scenarios, adopt a whitelisting approach to restrict the entities that can be resolved\nduring XML parsing. Create a list of trusted external entities and disallow all others. This approach ensures that only known and safe entities are\nprocessed.\u003cbr\u003e You should rely on features provided by your XML parser to restrict the external entities.\u003c/p\u003e",
        "context": {
          "key": "libxml2",
          "displayName": "libxml2"
        }
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/Top10/A05_2021-Security_Misconfiguration/\"\u003eOWASP Top 10 2021 Category A5\u003c/a\u003e - Security Misconfiguration \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/www-project-top-ten/2017/A4_2017-XML_External_Entities_(XXE)\"\u003eOWASP Top 10 2017 Category A4\u003c/a\u003e - XML External\n  Entities (XXE) \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/611\"\u003eMITRE, CWE-611\u003c/a\u003e - Information Exposure Through XML External Entity Reference \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/827\"\u003eMITRE, CWE-827\u003c/a\u003e - Improper Control of Document Type Definition \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cwe",
      "symbolic-execution"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S2637",
    "name": "\"nonnull\" pointers should not be set to null",
    "defaultSeverity": "MINOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "LOW"
    },
    "description": "\u003cp\u003ePointers marked as \"nonnull\" may not be set to null, since they are typically not null-checked before use.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eA function’s return value and parameters may be decorated with attributes to convey additional information to the compiler and/or other\ndevelopers.\u003c/p\u003e\n\u003cp\u003eA commonly used attribute is \u003ccode\u003enonnull\u003c/code\u003e which can be used to mark a function’s return value and parameters as shown in the following:\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;stdlib.h\u0026gt;\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;string.h\u0026gt;\n\n__attribute__((returns_nonnull)) int *\nmake_array_copy(__attribute__((nonnull)) int *src, size_t len) {\n  int *dst \u003d (int *)malloc(len * sizeof(int));\n  if (dst \u003d\u003d NULL) {\n    perror(\"malloc failed\");\n    exit(1);\n  }\n  memcpy(dst, src, len);\n  return dst;\n}\n\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003enonnull\u003c/code\u003e attribute is meant for other developers and as a hint for compilers. Values marked as \u003ccode\u003enonnull\u003c/code\u003e are assumed to\nhave non-null values.\u003c/p\u003e\n\u003cp\u003eHowever, developers may accidentally break the \u003ccode\u003enonnull\u003c/code\u003e attribute as shown in the following code snippet:\u003c/p\u003e\n\u003cpre\u003e\n__attribute__((returns_nonnull))\nint* foo(__attribute__((nonnull)) int* x) {\n  x \u003d 0; // Noncompliant: `x` is marked \"nonnull\" but is set to null\n  foo(0); // Noncompliant: null is passed as an argument marked as \"nonnull\"\n  return 0; // Noncompliant: return value is marked \"nonnull\" but null is returned\n}\n\u003c/pre\u003e\n\u003cp\u003eFailing to adhere to the attribute may introduce serious program errors. In particular, the compiler does not enforce that values marked as\n\u003ccode\u003enonnull\u003c/code\u003e are indeed non-null at runtime; it is the developers\u0027 responsibility to adhere to the attribute. These values are typically\n\u003cem\u003enot\u003c/em\u003e null-checked before use. Setting a value marked as \u003ccode\u003enonnull\u003c/code\u003e to null (i.e., \u003ccode\u003eNULL\u003c/code\u003e, \u003ccode\u003e0\u003c/code\u003e or\n\u003ccode\u003enullptr\u003c/code\u003e) is hence likely to cause a null-pointer dereference. Compilers may even apply optimizations based on this attribute and might,\nfor instance, \u003cem\u003eremove\u003c/em\u003e an explicit null-check if the parameter is declared as \u003ccode\u003enonnull\u003c/code\u003e — even in code outside of the function with\nthe attribute.\u003c/p\u003e\n\u003cp\u003eNote that the \u003ccode\u003enonnull\u003c/code\u003e attribute is a GNU extension (see \u003ca\nhref\u003d\"https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html#index-nonnull-function-attribute\"\u003enonnull\u003c/a\u003e and \u003ca\nhref\u003d\"https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html#index-returns_005fnonnull-function-attribute\"\u003ereturns_nonnull\u003c/a\u003e) which many\ncompiler vendors have implemented.\u003c/p\u003e\n\u003ch2\u003eWhat is the potential impact?\u003c/h2\u003e\n\u003cp\u003eIn case a program dereferences a null pointer, it’s behavior is undefined. For programs that exercise undefined behavior the compiler no longer\nneeds to adhere to the language standard and the program has no meaning assigned to it.\u003c/p\u003e\n\u003cp\u003eIn practice, dereferencing a null pointer may lead to program crashes, or the application may appear to execute correctly while losing data or\nproducing incorrect results.\u003c/p\u003e\n\u003cp\u003eBesides affecting the application’s availability, null-pointer dereferences may lead to malicious code execution, in rare circumstances. If null is\nequivalent to the 0x0 memory address that can be accessed by privileged code, writing, and reading memory is possible, which compromises the integrity\nand confidentiality of the application.\u003c/p\u003e\n\u003cp\u003eBecause compilers may apply optimizations based on the \u003ccode\u003enonnull\u003c/code\u003e attribute, not respecting \u003ccode\u003enonnull\u003c/code\u003e can also introduce more\ncomplex bugs such as resource leaks or infinite loops as indicated in the following code snippet:\u003c/p\u003e\n\u003cpre\u003e\nstruct Node {\n  int data;\n  Node *next; // NULL for a tail node.\n};\n\nsize_t len(__attribute__((nonnull)) Node *n) {\n  size_t l \u003d 0;\n  while (n) {\n    ++l;\n    n \u003d n-\u0026gt;next;\n  }\n  return l;\n}\n\u003c/pre\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eEnsure not to pass null values when non-null arguments are expected, do not return a null value when a non-null return value is expected, and do\nnot assign null to parameters marked as non-null. This especially holds for library functions, which frequently require \u003ccode\u003enonnull\u003c/code\u003e pointer\nparameters.\u003c/p\u003e\n\u003cp\u003eOn other occasions, it might be more appropriate to remove the attribute.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n__attribute__((returns_nonnull))\nint* foo(__attribute__((nonnull)) int* x) {\n  *x \u003d 42;\n  return x;\n}\n\nvoid bar() {\n  int *p \u003d nullptr;\n  int *q \u003d foo(p); // Noncompliant: null value is passed as an argument marked \"nonnull\"\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n__attribute__((returns_nonnull))\nint* foo(__attribute__((nonnull)) int* x) {\n  *x \u003d 42;\n  return x;\n}\n\nvoid bar() {\n  int i \u003d 0;\n  int *p \u003d \u0026amp;i;\n  int *q \u003d foo(p); // Compliant: `p` points to a valid memory location\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\n__attribute__((returns_nonnull))\nint* foo() {\n  return nullptr; // Noncompliant: function may not return a null pointer\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\n__attribute__((returns_nonnull))\nint* foo() {\n  int *p \u003d new int(0);\n  return p; // Compliant: `p` points to a valid memory location\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid process(int *p);\n\nvoid foo(__attribute__((nonnull)) int *p) {\n  p \u003d nullptr; // Noncompliant: `p` is marked \"nonnull\" but is set to null\n  process(p);\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"compliant\"\u003e\nvoid process(int *p);\n\nvoid foo(__attribute__((nonnull)) int *p) {\n  process(p);\n}\n\u003c/pre\u003e\n\u003ch3\u003eGoing the extra mile\u003c/h3\u003e\n\u003cp\u003eIn C++, it is preferred to use reference parameters (\u003ccode\u003eType const\u0026amp;\u003c/code\u003e or \u003ccode\u003eType\u0026amp;\u003c/code\u003e), or pass objects by value\n(\u003ccode\u003eType\u003c/code\u003e), instead of a pointer (\u003ccode\u003eType const*\u003c/code\u003e or \u003ccode\u003eType*\u003c/code\u003e), if the argument is expected to never be null.\u003c/p\u003e\n\u003cpre\u003e\n// Precondition: graph !\u003d null\nbool isDAG(Graph const* graph);\n\u003c/pre\u003e\n\u003cp\u003eThe preferred signature would be:\u003c/p\u003e\n\u003cpre\u003e\nbool isDAG(Graph const\u0026amp; graph);\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/QdcxBQ\"\u003eEXP34-C. Do not dereference null pointers\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/display/java/EXP01-J.+Do+not+use+a+null+in+a+case+where+an+object+is+required\"\u003eEXP01-J. Do\n  not use a null in a case where an object is required\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/476\"\u003e476 NULL Pointer Dereference\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f16-for-in-parameters-pass-cheaply-copied-types-by-value-and-others-by-reference-to-const\"\u003eF.16: For \"in\" parameters, pass cheaply-copied types by value and others by reference to \u003ccode\u003econst\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f17-for-in-out-parameters-pass-by-reference-to-non-const\"\u003eF.17:\n  For \"in-out\" parameters, pass by reference to non-\u003ccode\u003econst\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S2259} detects null-pointer dereferences \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S3807} detects calls to C library functions that require valid, non-null pointers with null pointer arguments \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003ePointers marked as \"nonnull\" may not be set to null, since they are typically not null-checked before use.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eA function’s return value and parameters may be decorated with attributes to convey additional information to the compiler and/or other\ndevelopers.\u003c/p\u003e\n\u003cp\u003eA commonly used attribute is \u003ccode\u003enonnull\u003c/code\u003e which can be used to mark a function’s return value and parameters as shown in the following:\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;stdlib.h\u0026gt;\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;string.h\u0026gt;\n\n__attribute__((returns_nonnull)) int *\nmake_array_copy(__attribute__((nonnull)) int *src, size_t len) {\n  int *dst \u003d (int *)malloc(len * sizeof(int));\n  if (dst \u003d\u003d NULL) {\n    perror(\"malloc failed\");\n    exit(1);\n  }\n  memcpy(dst, src, len);\n  return dst;\n}\n\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003enonnull\u003c/code\u003e attribute is meant for other developers and as a hint for compilers. Values marked as \u003ccode\u003enonnull\u003c/code\u003e are assumed to\nhave non-null values.\u003c/p\u003e\n\u003cp\u003eHowever, developers may accidentally break the \u003ccode\u003enonnull\u003c/code\u003e attribute as shown in the following code snippet:\u003c/p\u003e\n\u003cpre\u003e\n__attribute__((returns_nonnull))\nint* foo(__attribute__((nonnull)) int* x) {\n  x \u003d 0; // Noncompliant: `x` is marked \"nonnull\" but is set to null\n  foo(0); // Noncompliant: null is passed as an argument marked as \"nonnull\"\n  return 0; // Noncompliant: return value is marked \"nonnull\" but null is returned\n}\n\u003c/pre\u003e\n\u003cp\u003eFailing to adhere to the attribute may introduce serious program errors. In particular, the compiler does not enforce that values marked as\n\u003ccode\u003enonnull\u003c/code\u003e are indeed non-null at runtime; it is the developers\u0027 responsibility to adhere to the attribute. These values are typically\n\u003cem\u003enot\u003c/em\u003e null-checked before use. Setting a value marked as \u003ccode\u003enonnull\u003c/code\u003e to null (i.e., \u003ccode\u003eNULL\u003c/code\u003e, \u003ccode\u003e0\u003c/code\u003e or\n\u003ccode\u003enullptr\u003c/code\u003e) is hence likely to cause a null-pointer dereference. Compilers may even apply optimizations based on this attribute and might,\nfor instance, \u003cem\u003eremove\u003c/em\u003e an explicit null-check if the parameter is declared as \u003ccode\u003enonnull\u003c/code\u003e — even in code outside of the function with\nthe attribute.\u003c/p\u003e\n\u003cp\u003eNote that the \u003ccode\u003enonnull\u003c/code\u003e attribute is a GNU extension (see \u003ca\nhref\u003d\"https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html#index-nonnull-function-attribute\"\u003enonnull\u003c/a\u003e and \u003ca\nhref\u003d\"https://gcc.gnu.org/onlinedocs/gcc/Common-Function-Attributes.html#index-returns_005fnonnull-function-attribute\"\u003ereturns_nonnull\u003c/a\u003e) which many\ncompiler vendors have implemented.\u003c/p\u003e\n\u003ch2\u003eWhat is the potential impact?\u003c/h2\u003e\n\u003cp\u003eIn case a program dereferences a null pointer, it’s behavior is undefined. For programs that exercise undefined behavior the compiler no longer\nneeds to adhere to the language standard and the program has no meaning assigned to it.\u003c/p\u003e\n\u003cp\u003eIn practice, dereferencing a null pointer may lead to program crashes, or the application may appear to execute correctly while losing data or\nproducing incorrect results.\u003c/p\u003e\n\u003cp\u003eBesides affecting the application’s availability, null-pointer dereferences may lead to malicious code execution, in rare circumstances. If null is\nequivalent to the 0x0 memory address that can be accessed by privileged code, writing, and reading memory is possible, which compromises the integrity\nand confidentiality of the application.\u003c/p\u003e\n\u003cp\u003eBecause compilers may apply optimizations based on the \u003ccode\u003enonnull\u003c/code\u003e attribute, not respecting \u003ccode\u003enonnull\u003c/code\u003e can also introduce more\ncomplex bugs such as resource leaks or infinite loops as indicated in the following code snippet:\u003c/p\u003e\n\u003cpre\u003e\nstruct Node {\n  int data;\n  Node *next; // NULL for a tail node.\n};\n\nsize_t len(__attribute__((nonnull)) Node *n) {\n  size_t l \u003d 0;\n  while (n) {\n    ++l;\n    n \u003d n-\u0026gt;next;\n  }\n  return l;\n}\n\u003c/pre\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eEnsure not to pass null values when non-null arguments are expected, do not return a null value when a non-null return value is expected, and do\nnot assign null to parameters marked as non-null. This especially holds for library functions, which frequently require \u003ccode\u003enonnull\u003c/code\u003e pointer\nparameters.\u003c/p\u003e\n\u003cp\u003eOn other occasions, it might be more appropriate to remove the attribute.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n__attribute__((returns_nonnull))\nint* foo(__attribute__((nonnull)) int* x) {\n  *x \u003d 42;\n  return x;\n}\n\nvoid bar() {\n  int *p \u003d nullptr;\n  int *q \u003d foo(p); // Noncompliant: null value is passed as an argument marked \"nonnull\"\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n__attribute__((returns_nonnull))\nint* foo(__attribute__((nonnull)) int* x) {\n  *x \u003d 42;\n  return x;\n}\n\nvoid bar() {\n  int i \u003d 0;\n  int *p \u003d \u0026amp;i;\n  int *q \u003d foo(p); // Compliant: `p` points to a valid memory location\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\n__attribute__((returns_nonnull))\nint* foo() {\n  return nullptr; // Noncompliant: function may not return a null pointer\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\n__attribute__((returns_nonnull))\nint* foo() {\n  int *p \u003d new int(0);\n  return p; // Compliant: `p` points to a valid memory location\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid process(int *p);\n\nvoid foo(__attribute__((nonnull)) int *p) {\n  p \u003d nullptr; // Noncompliant: `p` is marked \"nonnull\" but is set to null\n  process(p);\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"compliant\"\u003e\nvoid process(int *p);\n\nvoid foo(__attribute__((nonnull)) int *p) {\n  process(p);\n}\n\u003c/pre\u003e\n\u003ch3\u003eGoing the extra mile\u003c/h3\u003e\n\u003cp\u003eIn C++, it is preferred to use reference parameters (\u003ccode\u003eType const\u0026amp;\u003c/code\u003e or \u003ccode\u003eType\u0026amp;\u003c/code\u003e), or pass objects by value\n(\u003ccode\u003eType\u003c/code\u003e), instead of a pointer (\u003ccode\u003eType const*\u003c/code\u003e or \u003ccode\u003eType*\u003c/code\u003e), if the argument is expected to never be null.\u003c/p\u003e\n\u003cpre\u003e\n// Precondition: graph !\u003d null\nbool isDAG(Graph const* graph);\n\u003c/pre\u003e\n\u003cp\u003eThe preferred signature would be:\u003c/p\u003e\n\u003cpre\u003e\nbool isDAG(Graph const\u0026amp; graph);\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/QdcxBQ\"\u003eEXP34-C. Do not dereference null pointers\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/display/java/EXP01-J.+Do+not+use+a+null+in+a+case+where+an+object+is+required\"\u003eEXP01-J. Do\n  not use a null in a case where an object is required\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/476\"\u003e476 NULL Pointer Dereference\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f16-for-in-parameters-pass-cheaply-copied-types-by-value-and-others-by-reference-to-const\"\u003eF.16: For \"in\" parameters, pass cheaply-copied types by value and others by reference to \u003ccode\u003econst\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f17-for-in-out-parameters-pass-by-reference-to-non-const\"\u003eF.17:\n  For \"in-out\" parameters, pass by reference to non-\u003ccode\u003econst\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S2259} detects null-pointer dereferences \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S3807} detects calls to C library functions that require valid, non-null pointers with null pointer arguments \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cert",
      "cwe",
      "symbolic-execution"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S3726",
    "name": "\"extern\" shouldn\u0027t be used on member definitions",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eData members and member functions cannot be defined as external, although entire objects can. When a member is declared as \u003ccode\u003eextern\u003c/code\u003e, the\ncompiler simply ignores the keyword, making it both extraneous and confusing.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass C {\n  void fun();\n};\n\nextern void C::fun() { // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nclass C {\n  void fun();\n};\n\nvoid C::fun() {\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/storage_duration\"\u003eStorage class specifiers\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eData members and member functions cannot be defined as external, although entire objects can. When a member is declared as \u003ccode\u003eextern\u003c/code\u003e, the\ncompiler simply ignores the keyword, making it both extraneous and confusing.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass C {\n  void fun();\n};\n\nextern void C::fun() { // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nclass C {\n  void fun();\n};\n\nvoid C::fun() {\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/storage_duration\"\u003eStorage class specifiers\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "unused"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1669",
    "name": "Context-sensitive keywords should not be used as identifiers",
    "defaultSeverity": "BLOCKER",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe C++ standards define some identifiers as having special meaning in specific contexts. These are:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003efinal\u003c/code\u003e and \u003ccode\u003eoverride\u003c/code\u003e since C++11 \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003emodule\u003c/code\u003e and \u003ccode\u003eimport\u003c/code\u003e since C++20 \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWhile it is technically possible to use them as normal identifiers, it’s clearer for the reader of the code to consider them as if they were\nkeywords and only use them with their special meaning.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid module(int final); // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid precept(int finalValue); // Compliant\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/final\"\u003efinal specifier\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/override\"\u003eoverride specifier\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/keyword/module\"\u003eC++ keyword: module\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/keyword/import\"\u003eC++ keyword: import\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe C++ standards define some identifiers as having special meaning in specific contexts. These are:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003efinal\u003c/code\u003e and \u003ccode\u003eoverride\u003c/code\u003e since C++11 \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003emodule\u003c/code\u003e and \u003ccode\u003eimport\u003c/code\u003e since C++20 \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWhile it is technically possible to use them as normal identifiers, it’s clearer for the reader of the code to consider them as if they were\nkeywords and only use them with their special meaning.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid module(int final); // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid precept(int finalValue); // Compliant\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/final\"\u003efinal specifier\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/override\"\u003eoverride specifier\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/keyword/module\"\u003eC++ keyword: module\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/keyword/import\"\u003eC++ keyword: import\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S2757",
    "name": "Non-existent operators like \"\u003d+\" should not be used",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eUsing operator pairs (e.g., \u003ccode\u003e\u003d+\u003c/code\u003e) that look like reversed single operators (e.g., \u003ccode\u003e+\u003d\u003c/code\u003e) is confusing. They compile and run\nbut do not produce the same result as their mirrored counterpart.\u003c/p\u003e\n\u003cpre\u003e\nint target \u003d -5;\nint num \u003d 3;\n\ntarget \u003d- num;  // Noncompliant: target \u003d -3. Is that the intended behavior?\ntarget \u003d+ num; // Noncompliant: target \u003d 3\n\u003c/pre\u003e\n\u003cp\u003eThis rule raises an issue when \u003ccode\u003e\u003d+\u003c/code\u003e, \u003ccode\u003e\u003d-\u003c/code\u003e, \u003ccode\u003e\u003d!\u003c/code\u003e, \u003ccode\u003e\u003d\u0026amp;\u003c/code\u003e, \u003ccode\u003e\u003d*\u003c/code\u003e, \u003ccode\u003e+\u003d+\u003c/code\u003e, and\n\u003ccode\u003e-\u003d-\u003c/code\u003e are used without any space between the operators and when there is at least one whitespace after.\u003c/p\u003e\n\u003cp\u003eReplace the operators with a single one if that is the intention\u003c/p\u003e\n\u003cpre\u003e\nint target \u003d -5;\nint num \u003d 3;\n\ntarget -\u003d num;  // target \u003d -8\n\u003c/pre\u003e\n\u003cp\u003eOr fix the spacing to avoid confusion\u003c/p\u003e\n\u003cpre\u003e\nint target \u003d -5;\nint num \u003d 3;\n\ntarget \u003d -num;  // target \u003d -3\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eUsing operator pairs (e.g., \u003ccode\u003e\u003d+\u003c/code\u003e) that look like reversed single operators (e.g., \u003ccode\u003e+\u003d\u003c/code\u003e) is confusing. They compile and run\nbut do not produce the same result as their mirrored counterpart.\u003c/p\u003e\n\u003cpre\u003e\nint target \u003d -5;\nint num \u003d 3;\n\ntarget \u003d- num;  // Noncompliant: target \u003d -3. Is that the intended behavior?\ntarget \u003d+ num; // Noncompliant: target \u003d 3\n\u003c/pre\u003e\n\u003cp\u003eThis rule raises an issue when \u003ccode\u003e\u003d+\u003c/code\u003e, \u003ccode\u003e\u003d-\u003c/code\u003e, \u003ccode\u003e\u003d!\u003c/code\u003e, \u003ccode\u003e\u003d\u0026amp;\u003c/code\u003e, \u003ccode\u003e\u003d*\u003c/code\u003e, \u003ccode\u003e+\u003d+\u003c/code\u003e, and\n\u003ccode\u003e-\u003d-\u003c/code\u003e are used without any space between the operators and when there is at least one whitespace after.\u003c/p\u003e\n\u003cp\u003eReplace the operators with a single one if that is the intention\u003c/p\u003e\n\u003cpre\u003e\nint target \u003d -5;\nint num \u003d 3;\n\ntarget -\u003d num;  // target \u003d -8\n\u003c/pre\u003e\n\u003cp\u003eOr fix the spacing to avoid confusion\u003c/p\u003e\n\u003cpre\u003e\nint target \u003d -5;\nint num \u003d 3;\n\ntarget \u003d -num;  // target \u003d -3\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S3728",
    "name": "String literals should not be concatenated implicitly",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "FORMATTED",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhile in C, and derived languages, it is legal to concatenate two literals by putting them next to each other, this is only justified in a few\ncases. For instance if one is a macro or if the layout makes it clearer.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nconst char * v1 \u003d \"a\"\"b\";      // Noncompliant; same as \"ab\"\nconst char * v2 \u003d \"a\\n\" \"b\\n\"; // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nconst char * v1 \u003d \"ab\"\nconst char * v2 \u003d \"a\\n\"\n                  \"b\\n\";\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cpre\u003e\nconst char * v3 \u003d \"a\" /* comment */ \"b\";\n\n#define _s \"b\"\nconst char * v4 \u003d \"a\" _s; // concatenation with macro ignored\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhile in C, and derived languages, it is legal to concatenate two literals by putting them next to each other, this is only justified in a few\ncases. For instance if one is a macro or if the layout makes it clearer.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nconst char * v1 \u003d \"a\"\"b\";      // Noncompliant; same as \"ab\"\nconst char * v2 \u003d \"a\\n\" \"b\\n\"; // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nconst char * v1 \u003d \"ab\"\nconst char * v2 \u003d \"a\\n\"\n                  \"b\\n\";\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cpre\u003e\nconst char * v3 \u003d \"a\" /* comment */ \"b\";\n\n#define _s \"b\"\nconst char * v4 \u003d \"a\" _s; // concatenation with macro ignored\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "confusing"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S3609",
    "name": "\"static\" should not be used in unnamed namespaces",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eSince C++11, declaring a variable, class, or function in an unnamed \u003ccode\u003enamespace\u003c/code\u003e gives it internal linkage. Similarly, marking a\ndeclaration \u003ccode\u003estatic\u003c/code\u003e also gives it internal linkage. Because both mechanisms have the same effect (although \u003ccode\u003estatic\u003c/code\u003e has a\nnarrower application) using them together is clearly redundant.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nnamespace {\n  static int i \u003d 3;  // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nnamespace {\n  int i \u003d 3;\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e ISO/IEC 14882:2011 §3.5 paragraph 4 \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eSince C++11, declaring a variable, class, or function in an unnamed \u003ccode\u003enamespace\u003c/code\u003e gives it internal linkage. Similarly, marking a\ndeclaration \u003ccode\u003estatic\u003c/code\u003e also gives it internal linkage. Because both mechanisms have the same effect (although \u003ccode\u003estatic\u003c/code\u003e has a\nnarrower application) using them together is clearly redundant.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nnamespace {\n  static int i \u003d 3;  // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nnamespace {\n  int i \u003d 3;\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e ISO/IEC 14882:2011 §3.5 paragraph 4 \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "clumsy",
      "redundant",
      "since-c++11"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S3608",
    "name": "Default capture should not be used",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eLambdas can use variables from their enclosing scope (called \"capture\") either by reference or by value. Since lambdas may run asynchronously,\nreference capture should be used with caution because, by the time the lambda runs, the referenced variable may be out of scope, resulting in an\naccess violation at run time.\u003c/p\u003e\n\u003cp\u003eYou can specify default capture by reference (\u003ccode\u003e[\u0026amp;]\u003c/code\u003e), or by value (\u003ccode\u003e[\u003d]\u003c/code\u003e). Default reference capture can cause scope\nissues, but so can default value capture. Both forms of default capture implicitly also capture \u003ccode\u003e*this\u003c/code\u003e, which would automatically be used\nif, for example, you referenced a method from the enclosing scope.\u003c/p\u003e\n\u003cp\u003eIf the lambda is used immediately (for instance, passed as an argument to \u003ccode\u003estd::sort\u003c/code\u003e), there is no risk of dangling reference. For\nthose lambdas, it is safe to pass everything through a default capture by reference. See also {rule:cpp:S5495}.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when default capture is used unless the lambda is immediately executed.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid fun() {\n  Foo foo;\n  ...\n  executor-\u0026gt;Schedule([\u0026amp;] {  // Noncompliant\n    maybeMember(foo);  // implicit use of *this reference if maybeMember is a member function. foo and maybeMember may both be gone by the time this is invoked\n  });\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid fun() {\n  Foo foo;\n  ...\n  executor-\u0026gt;Schedule([\u0026amp;foo] { // it is clear that foo is captured by reference and compilation is going to fail if maybeMember is a member function\n    maybeMember(foo);\n  });\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S5495} Capture by reference in lambdas used locally \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eLambdas can use variables from their enclosing scope (called \"capture\") either by reference or by value. Since lambdas may run asynchronously,\nreference capture should be used with caution because, by the time the lambda runs, the referenced variable may be out of scope, resulting in an\naccess violation at run time.\u003c/p\u003e\n\u003cp\u003eYou can specify default capture by reference (\u003ccode\u003e[\u0026amp;]\u003c/code\u003e), or by value (\u003ccode\u003e[\u003d]\u003c/code\u003e). Default reference capture can cause scope\nissues, but so can default value capture. Both forms of default capture implicitly also capture \u003ccode\u003e*this\u003c/code\u003e, which would automatically be used\nif, for example, you referenced a method from the enclosing scope.\u003c/p\u003e\n\u003cp\u003eIf the lambda is used immediately (for instance, passed as an argument to \u003ccode\u003estd::sort\u003c/code\u003e), there is no risk of dangling reference. For\nthose lambdas, it is safe to pass everything through a default capture by reference. See also {rule:cpp:S5495}.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when default capture is used unless the lambda is immediately executed.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid fun() {\n  Foo foo;\n  ...\n  executor-\u0026gt;Schedule([\u0026amp;] {  // Noncompliant\n    maybeMember(foo);  // implicit use of *this reference if maybeMember is a member function. foo and maybeMember may both be gone by the time this is invoked\n  });\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid fun() {\n  Foo foo;\n  ...\n  executor-\u0026gt;Schedule([\u0026amp;foo] { // it is clear that foo is captured by reference and compilation is going to fail if maybeMember is a member function\n    maybeMember(foo);\n  });\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S5495} Capture by reference in lambdas used locally \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "since-c++11",
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S3729",
    "name": "Array indices should be placed between brackets",
    "defaultSeverity": "BLOCKER",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhile C syntax considers array subscripts (\u003ccode\u003e[]\u003c/code\u003e) as symmetrical, meaning that \u003ccode\u003ea[i]\u003c/code\u003e and \u003ccode\u003ei[a]\u003c/code\u003e are equivalent,\nthe convention is to put the index in the brackets rather than the array name. Inverting the index and array name serves no purpose, and is very\nconfusing.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n10[P1] \u003d 0; // Noncompliant\ndostuff(i[arr]); // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nP1[10] \u003d 0;\ndostuff(arr[i]);\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhile C syntax considers array subscripts (\u003ccode\u003e[]\u003c/code\u003e) as symmetrical, meaning that \u003ccode\u003ea[i]\u003c/code\u003e and \u003ccode\u003ei[a]\u003c/code\u003e are equivalent,\nthe convention is to put the index in the brackets rather than the array name. Inverting the index and array name serves no purpose, and is very\nconfusing.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n10[P1] \u003d 0; // Noncompliant\ndostuff(i[arr]); // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nP1[10] \u003d 0;\ndostuff(arr[i]);\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1541",
    "name": "Cyclomatic Complexity of functions should not be too high",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "FOCUSED",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe Cyclomatic Complexity of functions should not exceed a defined threshold. Complex code may perform poorly and can be difficult to test\nthoroughly.\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe Cyclomatic Complexity of functions should not exceed a defined threshold. Complex code may perform poorly and can be difficult to test\nthoroughly.\u003c/p\u003e"
      }
    ],
    "params": {
      "maximumFunctionComplexityThreshold": {
        "key": "maximumFunctionComplexityThreshold",
        "name": "maximumFunctionComplexityThreshold",
        "description": "The maximum authorized complexity.",
        "defaultValue": "20",
        "type": "INTEGER",
        "multiple": false,
        "possibleValues": []
      }
    },
    "defaultParams": {
      "maximumFunctionComplexityThreshold": "20"
    },
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "brain-overload"
    ],
    "deprecatedKeys": [
      "cpp:FunctionComplexity"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1301",
    "name": "\"if\" statements should be preferred over \"switch\" when simpler",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eswitch\u003c/code\u003e statements are useful when there are many different cases depending on the value of the same expression. For just one or two\ncases, however, the code will be more readable with \u003ccode\u003eif\u003c/code\u003e statements.\u003c/p\u003e\n\u003cp\u003eIn particular, \u003ccode\u003eif\u003c/code\u003e statements are more suitable when the condition of the \u003ccode\u003eswitch\u003c/code\u003e is boolean.\u003c/p\u003e\n\u003cp\u003eThis rule detects statements that could be simplified with a simple \u003ccode\u003eif / else\u003c/code\u003e. That is when there is at most one \u003ccode\u003ecase\u003c/code\u003e,\nnot counting those that fall through to a \u003ccode\u003edefault\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThe following code:\u003c/p\u003e\n\u003cpre\u003e\nswitch (variable) {\n  case 0:\n    doSomething();\n    break;\n  case 1:\n  case 2:\n  default:\n    doSomethingElse();\n    break;\n}\n\u003c/pre\u003e\n\u003cp\u003eWould be more readable that way:\u003c/p\u003e\n\u003cpre\u003e\nif (variable \u003d\u003d 0) {\n  doSomething();\n} else {\n  doSomethingElse();\n}\n\u003c/pre\u003e\n\u003cp\u003eWhile the following snippets don’t trigger the rule because using \u003ccode\u003eif\u003c/code\u003e would not improve their readability:\u003c/p\u003e\n\u003cpre\u003e\nswitch (variable) {\n  case 0:\n  case 1: // Would need a less readable check in an `if`\n    doSomething();\n    break;\n}\n\nswitch (variable) {\n  case 0:\n    doSomething();\n    break;\n  case 1: // Would require introducing `else if`\n    doSomethingElse();\n    break;\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2012, 16.6 - Every switch statement shall have at least two switch-clauses \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003ccode\u003eswitch\u003c/code\u003e statements are useful when there are many different cases depending on the value of the same expression. For just one or two\ncases, however, the code will be more readable with \u003ccode\u003eif\u003c/code\u003e statements.\u003c/p\u003e\n\u003cp\u003eIn particular, \u003ccode\u003eif\u003c/code\u003e statements are more suitable when the condition of the \u003ccode\u003eswitch\u003c/code\u003e is boolean.\u003c/p\u003e\n\u003cp\u003eThis rule detects statements that could be simplified with a simple \u003ccode\u003eif / else\u003c/code\u003e. That is when there is at most one \u003ccode\u003ecase\u003c/code\u003e,\nnot counting those that fall through to a \u003ccode\u003edefault\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThe following code:\u003c/p\u003e\n\u003cpre\u003e\nswitch (variable) {\n  case 0:\n    doSomething();\n    break;\n  case 1:\n  case 2:\n  default:\n    doSomethingElse();\n    break;\n}\n\u003c/pre\u003e\n\u003cp\u003eWould be more readable that way:\u003c/p\u003e\n\u003cpre\u003e\nif (variable \u003d\u003d 0) {\n  doSomething();\n} else {\n  doSomethingElse();\n}\n\u003c/pre\u003e\n\u003cp\u003eWhile the following snippets don’t trigger the rule because using \u003ccode\u003eif\u003c/code\u003e would not improve their readability:\u003c/p\u003e\n\u003cpre\u003e\nswitch (variable) {\n  case 0:\n  case 1: // Would need a less readable check in an `if`\n    doSomething();\n    break;\n}\n\nswitch (variable) {\n  case 0:\n    doSomething();\n    break;\n  case 1: // Would require introducing `else if`\n    doSomethingElse();\n    break;\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2012, 16.6 - Every switch statement shall have at least two switch-clauses \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "bad-practice",
      "based-on-misra"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1543",
    "name": "Macro names should comply with a naming convention",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "IDENTIFIABLE",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eSharing some naming conventions is a key point to make it possible for a team to efficiently collaborate. This rule allows to check that all macro\nnames match a provided regular expression.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#define foo // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#define FOO\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eSharing some naming conventions is a key point to make it possible for a team to efficiently collaborate. This rule allows to check that all macro\nnames match a provided regular expression.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#define foo // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#define FOO\n\u003c/pre\u003e"
      }
    ],
    "params": {
      "format": {
        "key": "format",
        "name": "format",
        "description": "POSIX regular expression used to check the macro names against.",
        "defaultValue": "^[A-Z][A-Z0-9_]*$",
        "type": "STRING",
        "multiple": false,
        "possibleValues": []
      }
    },
    "defaultParams": {
      "format": "^[A-Z][A-Z0-9_]*$"
    },
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "convention",
      "preprocessor"
    ],
    "deprecatedKeys": [
      "cpp:PPMacroName"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S2754",
    "name": "Declarations should not be empty",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eEmpty declarations are cruft; they (may) compile, but they violate the language standards, don’t contribute anything of value, and clutter up the\nprogram. Like cobwebs, they should be swept away.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint;  // Noncompliant\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e ISO/IEC 9899:2011, 6.7p2 \u003c/li\u003e\n  \u003cli\u003e ISO/IEC 14882:2011, 7p3. \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/5dUxBQ\"\u003eCERT, MSC12-C.\u003c/a\u003e - Detect and remove code that has no effect or is never executed\n  \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eEmpty declarations are cruft; they (may) compile, but they violate the language standards, don’t contribute anything of value, and clutter up the\nprogram. Like cobwebs, they should be swept away.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint;  // Noncompliant\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e ISO/IEC 9899:2011, 6.7p2 \u003c/li\u003e\n  \u003cli\u003e ISO/IEC 14882:2011, 7p3. \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/5dUxBQ\"\u003eCERT, MSC12-C.\u003c/a\u003e - Detect and remove code that has no effect or is never executed\n  \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cert",
      "unused"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S2753",
    "name": "Values of different \"enum\" types should not be compared",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eJust as comparing apples and oranges is seen as a classic folly, comparing values from different enumerations against each other or converting them\ninto one another is nonsensical. True, at root \u003ccode\u003eenum\u003c/code\u003es are simply named numbers, and it’s certainly valid to compare numbers. But an added\nlayer of meaning is created by an \u003ccode\u003eenum\u003c/code\u003e, one that goes beyond simple numerical values.\u003c/p\u003e\n\u003cp\u003eIgnoring that extra layer of meaning is at best a trap for maintainers, who are likely to be hopelessly confused by the code. At worst, it is a\nbug, which will lead to unexpected results.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nenum apple {BRAEBURN, FUJI, GRANNY_SMITH, RED_DELICIOUS};\nenum orange {BLOOD, NAVEL, BITTER, BERGAMOT, MANDARIN};\n\nvoid makeCider(apple v);\n\nbool fun(apple v1, orange v2) {\n  makeCider((apple)v2); // Noncompliant\n  return v1 !\u003d v2;  // Noncompliant\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eJust as comparing apples and oranges is seen as a classic folly, comparing values from different enumerations against each other or converting them\ninto one another is nonsensical. True, at root \u003ccode\u003eenum\u003c/code\u003es are simply named numbers, and it’s certainly valid to compare numbers. But an added\nlayer of meaning is created by an \u003ccode\u003eenum\u003c/code\u003e, one that goes beyond simple numerical values.\u003c/p\u003e\n\u003cp\u003eIgnoring that extra layer of meaning is at best a trap for maintainers, who are likely to be hopelessly confused by the code. At worst, it is a\nbug, which will lead to unexpected results.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nenum apple {BRAEBURN, FUJI, GRANNY_SMITH, RED_DELICIOUS};\nenum orange {BLOOD, NAVEL, BITTER, BERGAMOT, MANDARIN};\n\nvoid makeCider(apple v);\n\nbool fun(apple v1, orange v2) {\n  makeCider((apple)v2); // Noncompliant\n  return v1 !\u003d v2;  // Noncompliant\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S909",
    "name": "\"continue\" should not be used",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003econtinue\u003c/code\u003e is an unstructured control flow statement. It makes code less testable, less readable and less maintainable. Structured\ncontrol flow statements such as \u003ccode\u003eif\u003c/code\u003e should be used instead.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint i;\nfor (i \u003d 0; i \u0026lt; 10; i++) {\n  if (i \u003d\u003d 5) {\n    continue;  /* Noncompliant */\n  }\n  printf(\"i \u003d %d\\n\", i);\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint i;\nfor (i \u003d 0; i \u0026lt; 10; i++) {\n  if (i !\u003d 5) {\n    printf(\"i \u003d %d\\n\", i);\n  }\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 14.5 - The continue statement shall not be used. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003ccode\u003econtinue\u003c/code\u003e is an unstructured control flow statement. It makes code less testable, less readable and less maintainable. Structured\ncontrol flow statements such as \u003ccode\u003eif\u003c/code\u003e should be used instead.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint i;\nfor (i \u003d 0; i \u0026lt; 10; i++) {\n  if (i \u003d\u003d 5) {\n    continue;  /* Noncompliant */\n  }\n  printf(\"i \u003d %d\\n\", i);\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint i;\nfor (i \u003d 0; i \u0026lt; 10; i++) {\n  if (i !\u003d 5) {\n    printf(\"i \u003d %d\\n\", i);\n  }\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 14.5 - The continue statement shall not be used. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "bad-practice",
      "based-on-misra"
    ],
    "deprecatedKeys": [
      "cpp:ContinueUsage"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S907",
    "name": "\"goto\" statement should not be used",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003egoto\u003c/code\u003e is an unstructured control flow statement. It makes code less readable and maintainable. Structured control flow statements such\nas \u003ccode\u003eif\u003c/code\u003e, \u003ccode\u003efor\u003c/code\u003e, \u003ccode\u003ewhile\u003c/code\u003e, \u003ccode\u003econtinue\u003c/code\u003e or \u003ccode\u003ebreak\u003c/code\u003e should be used instead.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint i \u003d 0;\nloop:\n  printf(\"i \u003d %d\\n\", i);\n  i++;\n  if (i \u0026lt; 10){\n    goto loop; // Noncompliant\n  }\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nfor (int i \u003d 0; i \u0026lt; 10; i++) {\n  printf(\"i \u003d %d\\n\", i);\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 14.4 - The goto statement shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 15.1 - The goto statement should not be used \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es76-avoid-goto\"\u003eES.76: Avoid\n  \u003ccode\u003egoto\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003ccode\u003egoto\u003c/code\u003e is an unstructured control flow statement. It makes code less readable and maintainable. Structured control flow statements such\nas \u003ccode\u003eif\u003c/code\u003e, \u003ccode\u003efor\u003c/code\u003e, \u003ccode\u003ewhile\u003c/code\u003e, \u003ccode\u003econtinue\u003c/code\u003e or \u003ccode\u003ebreak\u003c/code\u003e should be used instead.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint i \u003d 0;\nloop:\n  printf(\"i \u003d %d\\n\", i);\n  i++;\n  if (i \u0026lt; 10){\n    goto loop; // Noncompliant\n  }\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nfor (int i \u003d 0; i \u0026lt; 10; i++) {\n  printf(\"i \u003d %d\\n\", i);\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 14.4 - The goto statement shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 15.1 - The goto statement should not be used \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es76-avoid-goto\"\u003eES.76: Avoid\n  \u003ccode\u003egoto\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "brain-overload"
    ],
    "deprecatedKeys": [
      "cpp:GotoUsage"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S905",
    "name": "Non-empty statements should change control flow or have at least one side-effect",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003cp\u003eStatements with no side effects and no change of control flow do not contribute to the functionality of the code and can indicate a programming\nerror.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhen writing code, it is important to ensure that each statement serves a purpose and contributes to the overall functionality of the program. When\nthey have no side effects or do not change the control flow, they can either indicate a programming error or be redundant:\u003c/p\u003e\n\u003col\u003e\n  \u003cli\u003e The code does not behave as intended: The statements are expected to have an effect but they do not. This can be caused by mistyping,\n  copy-and-paste errors, etc. \u003c/li\u003e\n  \u003cli\u003e The statements are residual after a refactoring. \u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThe rule does not raise an issue on statements containing only a semicolon (\u003ccode\u003e;\u003c/code\u003e).\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eIdentify statements that do not contribute to the functionality of the code and verify if they are intended to be part of the logic. If they are,\nthere is a bug to be fixed. If they are not, then they are redundant and should be removed.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nint add(int a, int b) {\n  int result \u003d 0;\n  a + b; // Noncompliant: no side effect, hides a bug, the developer likely accidentally duplicated the line\n  return result;\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\nint mul(int a, int b) {\n  int result \u003d 1;\n  result \u003d\u003d a; // Noncompliant: no side effect, hides a bug, the developer intended to assign\n  result *\u003d b;\n  return result;\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"noncompliant\"\u003e\nint sub(int a, int b) {\n  int result \u003d a - b;\n  a - b; // Noncompliant: no side effect, there is no underlying bug, but the statement is useless\n  return result;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nint add(int a, int b) {\n  int result \u003d a + b;\n  return result;\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\nint mul(int a, int b) {\n  int result \u003d 1;\n  result \u003d a;\n  result *\u003d b;\n  return result;\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"compliant\"\u003e\nint sub(int a, int b) {\n  int result \u003d a - b;\n  return result;\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/482\"\u003e482 Comparing instead of Assigning\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/5dUxBQ\"\u003eMSC12-C. Detect and remove code that has no effect or is never executed\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 14.2 - All non-null statements shall either have at least one side-effect however executed or cause control flow to change. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S1116} - Empty statements should be removed \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S1854} - Unused assignments should be removed \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eStatements with no side effects and no change of control flow do not contribute to the functionality of the code and can indicate a programming\nerror.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhen writing code, it is important to ensure that each statement serves a purpose and contributes to the overall functionality of the program. When\nthey have no side effects or do not change the control flow, they can either indicate a programming error or be redundant:\u003c/p\u003e\n\u003col\u003e\n  \u003cli\u003e The code does not behave as intended: The statements are expected to have an effect but they do not. This can be caused by mistyping,\n  copy-and-paste errors, etc. \u003c/li\u003e\n  \u003cli\u003e The statements are residual after a refactoring. \u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThe rule does not raise an issue on statements containing only a semicolon (\u003ccode\u003e;\u003c/code\u003e).\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eIdentify statements that do not contribute to the functionality of the code and verify if they are intended to be part of the logic. If they are,\nthere is a bug to be fixed. If they are not, then they are redundant and should be removed.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nint add(int a, int b) {\n  int result \u003d 0;\n  a + b; // Noncompliant: no side effect, hides a bug, the developer likely accidentally duplicated the line\n  return result;\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\nint mul(int a, int b) {\n  int result \u003d 1;\n  result \u003d\u003d a; // Noncompliant: no side effect, hides a bug, the developer intended to assign\n  result *\u003d b;\n  return result;\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"noncompliant\"\u003e\nint sub(int a, int b) {\n  int result \u003d a - b;\n  a - b; // Noncompliant: no side effect, there is no underlying bug, but the statement is useless\n  return result;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nint add(int a, int b) {\n  int result \u003d a + b;\n  return result;\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\nint mul(int a, int b) {\n  int result \u003d 1;\n  result \u003d a;\n  result *\u003d b;\n  return result;\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"compliant\"\u003e\nint sub(int a, int b) {\n  int result \u003d a - b;\n  return result;\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/482\"\u003e482 Comparing instead of Assigning\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/5dUxBQ\"\u003eMSC12-C. Detect and remove code that has no effect or is never executed\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 14.2 - All non-null statements shall either have at least one side-effect however executed or cause control flow to change. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S1116} - Empty statements should be removed \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S1854} - Unused assignments should be removed \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "cwe",
      "unused"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1656",
    "name": "Variables should not be self-assigned",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThere is no reason to re-assign a variable to itself. Either this statement is redundant and should be removed, or the re-assignment is a mistake\nand some other value or variable was intended for the assignment instead.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid setValue(int value) {\n  value \u003d value;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid setValue(int value) {\n  this-\u0026gt;value \u003d value;\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/5dUxBQ\"\u003eCERT, MSC12-C.\u003c/a\u003e - Detect and remove code that has no effect or is never executed\n  \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThere is no reason to re-assign a variable to itself. Either this statement is redundant and should be removed, or the re-assignment is a mistake\nand some other value or variable was intended for the assignment instead.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid setValue(int value) {\n  value \u003d value;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid setValue(int value) {\n  this-\u0026gt;value \u003d value;\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/5dUxBQ\"\u003eCERT, MSC12-C.\u003c/a\u003e - Detect and remove code that has no effect or is never executed\n  \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cert"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S3715",
    "name": "GNU extensions should not be used",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eProprietary compiler extensions can be handy, but they commit you to always using that compiler. This rule raises an issue when GNU extensions are\nused, such as:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Ternary operator with omitted second operand \u003c/li\u003e\n  \u003cli\u003e Case ranges in switch statements \u003c/li\u003e\n  \u003cli\u003e Expression statements, i.e. code blocks producing value \u003c/li\u003e\n  \u003cli\u003e Index range in array initializers \u003c/li\u003e\n  \u003cli\u003e A array initializer without \u003ccode\u003e\u003d\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e A structure member initializer with a colon \u003c/li\u003e\n  \u003cli\u003e Decimal floating points numbers \u003ccode\u003e_Decimal32\u003c/code\u003e, \u003ccode\u003e_Decimal64\u003c/code\u003e, and \u003ccode\u003e_Decimal128\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e Structures and union without named data members \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstruct S {\n  int f;\n};\n\nstruct S s[] \u003d {\n  [0] { // Noncompliant\n    f : 0 // Noncompliant\n  }\n  [1 ... 3] \u003d { // CHECK :8 :11 S3715:use of GNU array range extension\n    .f \u003d 2\n  }\n};\n\nint fun(int p) {\n  switch (p) {\n    case 0 ... 1: // Noncompliant\n      do_the_thing();\n      break;\n    case 2:\n      //...\n  }\n\n  p \u003d ({ // Noncompliant\n    int a \u003d 10, b \u003d 20;\n    (a * b) + 10;\n  });\n\n  return p ?: 0; // Noncompliant\n}\n\n_Decimal32 d32; // Noncompliant\n\nstruct Empty {}; // Noncompliant in C\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstruct S {\n  int f;\n};\n\nstruct S s[] \u003d {\n  [0] \u003d {\n    .f \u003d 0\n  },\n  [1] \u003d {\n    .f \u003d 2\n  }\n  [2] \u003d {\n    .f \u003d 2\n  },\n  [3] \u003d {\n    .f \u003d 2\n  }\n\n};\n\nint fun(int p) {\n  switch (p) {\n    case 0:\n    case 1:\n      do_the_thing();\n      break;\n    case 2:\n      //...\n  }\n\n  int a \u003d 10, b \u003d 20;\n  p \u003d (a * b) + 10;\n\n  return p ? p: 0;\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eProprietary compiler extensions can be handy, but they commit you to always using that compiler. This rule raises an issue when GNU extensions are\nused, such as:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Ternary operator with omitted second operand \u003c/li\u003e\n  \u003cli\u003e Case ranges in switch statements \u003c/li\u003e\n  \u003cli\u003e Expression statements, i.e. code blocks producing value \u003c/li\u003e\n  \u003cli\u003e Index range in array initializers \u003c/li\u003e\n  \u003cli\u003e A array initializer without \u003ccode\u003e\u003d\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e A structure member initializer with a colon \u003c/li\u003e\n  \u003cli\u003e Decimal floating points numbers \u003ccode\u003e_Decimal32\u003c/code\u003e, \u003ccode\u003e_Decimal64\u003c/code\u003e, and \u003ccode\u003e_Decimal128\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e Structures and union without named data members \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstruct S {\n  int f;\n};\n\nstruct S s[] \u003d {\n  [0] { // Noncompliant\n    f : 0 // Noncompliant\n  }\n  [1 ... 3] \u003d { // CHECK :8 :11 S3715:use of GNU array range extension\n    .f \u003d 2\n  }\n};\n\nint fun(int p) {\n  switch (p) {\n    case 0 ... 1: // Noncompliant\n      do_the_thing();\n      break;\n    case 2:\n      //...\n  }\n\n  p \u003d ({ // Noncompliant\n    int a \u003d 10, b \u003d 20;\n    (a * b) + 10;\n  });\n\n  return p ?: 0; // Noncompliant\n}\n\n_Decimal32 d32; // Noncompliant\n\nstruct Empty {}; // Noncompliant in C\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstruct S {\n  int f;\n};\n\nstruct S s[] \u003d {\n  [0] \u003d {\n    .f \u003d 0\n  },\n  [1] \u003d {\n    .f \u003d 2\n  }\n  [2] \u003d {\n    .f \u003d 2\n  },\n  [3] \u003d {\n    .f \u003d 2\n  }\n\n};\n\nint fun(int p) {\n  switch (p) {\n    case 0:\n    case 1:\n      do_the_thing();\n      break;\n    case 2:\n      //...\n  }\n\n  int a \u003d 10, b \u003d 20;\n  p \u003d (a * b) + 10;\n\n  return p ? p: 0;\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "gnu",
      "lock-in",
      "obsolete"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1659",
    "name": "Multiple variables should not be declared on the same line",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "FORMATTED",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eDeclaring multiple variables or members on the same line hinders readability. Moreover, as soon as they contain references, pointers, or\nassignments, they become confusing for maintainers.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when a declaration declares multiple variables or members.\u003c/p\u003e\n\u003cpre\u003e\nint i1, j1; // Noncompliant\nint i2, *j2; // Noncompliant\nint *i3,\n    \u0026amp;j3 \u003d i2; // Noncompliant\n\u003c/pre\u003e\n\u003cp\u003eGiving each declaration its own line makes the code more maintainable.\u003c/p\u003e\n\u003cpre\u003e\nint i1;\nint j1;\nint i2;\nint *j2;\nint *i3;\nint \u0026amp;j3 \u003d i2;\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/EtcxBQ\"\u003eCERT, DCL04-C.\u003c/a\u003e - Do not declare more than one variable per declaration \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 8-0-1 - An init-declarator-list or a member-declarator-list shall consist of a single init-declarator or member-declarator\n  respectively \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es10-declare-one-name-only-per-declaration\"\u003eES.10: Declare one\n  name (only) per declaration\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eDeclaring multiple variables or members on the same line hinders readability. Moreover, as soon as they contain references, pointers, or\nassignments, they become confusing for maintainers.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when a declaration declares multiple variables or members.\u003c/p\u003e\n\u003cpre\u003e\nint i1, j1; // Noncompliant\nint i2, *j2; // Noncompliant\nint *i3,\n    \u0026amp;j3 \u003d i2; // Noncompliant\n\u003c/pre\u003e\n\u003cp\u003eGiving each declaration its own line makes the code more maintainable.\u003c/p\u003e\n\u003cpre\u003e\nint i1;\nint j1;\nint i2;\nint *j2;\nint *i3;\nint \u0026amp;j3 \u003d i2;\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/EtcxBQ\"\u003eCERT, DCL04-C.\u003c/a\u003e - Do not declare more than one variable per declaration \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 8-0-1 - An init-declarator-list or a member-declarator-list shall consist of a single init-declarator or member-declarator\n  respectively \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es10-declare-one-name-only-per-declaration\"\u003eES.10: Declare one\n  name (only) per declaration\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "cert",
      "convention"
    ],
    "deprecatedKeys": [
      "cpp:SingleDeclarationPerStatement"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S3719",
    "name": "Virtual functions should not have default arguments",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eIt’s best to avoid giving default argument initializers to virtual functions. While doing so is legal, the code is unlikely to be correctly\nmaintained over time and will lead to incorrect polymorphic code and unnecessary complexity in a class hierarchy.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass Base {\npublic:\n  virtual void fun(int p \u003d 42) { // Noncompliant\n    // ...\n  }\n};\n\nclass Derived : public Base {\npublic:\n  void fun(int p \u003d 13) override { // Noncompliant\n    // ...\n  }\n};\n\nclass Derived2 : public Base {\npublic:\n  void fun(int p) override {\n    // ...\n  }\n};\n\nint main() {\n  Derived *d \u003d new Derived;\n  Base *b \u003d d;\n  b-\u0026gt;fun(); // uses default argument 42\n  d-\u0026gt;fun(); // uses default argument 13; was that expected?\n\n  Base *b2 \u003d new Base;\n  Derived2 *d2 \u003d new Derived2;\n  b2-\u0026gt;fun(); // uses default argument 42\n  d2-\u0026gt;fun(); // compile time error; was that expected?\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nclass Base {\npublic:\n  void fun(int p \u003d 42) { // non-virtual forwarding function\n    fun_impl(p);\n  }\nprotected:\n  virtual void fun_impl(int p) {\n    // ...\n  }\n};\n\nclass Derived : public Base {\nprotected:\n  void fun_impl(int p) override {\n    // ...\n  }\n};\n\nclass Derived2 : public Base {\nprotected:\n  void fun_impl(int p) override {\n    // ...\n  }\n};\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S1712} \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eIt’s best to avoid giving default argument initializers to virtual functions. While doing so is legal, the code is unlikely to be correctly\nmaintained over time and will lead to incorrect polymorphic code and unnecessary complexity in a class hierarchy.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass Base {\npublic:\n  virtual void fun(int p \u003d 42) { // Noncompliant\n    // ...\n  }\n};\n\nclass Derived : public Base {\npublic:\n  void fun(int p \u003d 13) override { // Noncompliant\n    // ...\n  }\n};\n\nclass Derived2 : public Base {\npublic:\n  void fun(int p) override {\n    // ...\n  }\n};\n\nint main() {\n  Derived *d \u003d new Derived;\n  Base *b \u003d d;\n  b-\u0026gt;fun(); // uses default argument 42\n  d-\u0026gt;fun(); // uses default argument 13; was that expected?\n\n  Base *b2 \u003d new Base;\n  Derived2 *d2 \u003d new Derived2;\n  b2-\u0026gt;fun(); // uses default argument 42\n  d2-\u0026gt;fun(); // compile time error; was that expected?\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nclass Base {\npublic:\n  void fun(int p \u003d 42) { // non-virtual forwarding function\n    fun_impl(p);\n  }\nprotected:\n  virtual void fun_impl(int p) {\n    // ...\n  }\n};\n\nclass Derived : public Base {\nprotected:\n  void fun_impl(int p) override {\n    // ...\n  }\n};\n\nclass Derived2 : public Base {\nprotected:\n  void fun_impl(int p) override {\n    // ...\n  }\n};\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S1712} \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "api-design",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1771",
    "name": "A \"struct\" should not have member functions",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhile it is possible to define a \u003ccode\u003estruct\u003c/code\u003e with member functions in C++, the general expectation is that \u003ccode\u003estruct\u003c/code\u003es only\naggregate data, while classes are used for fully encapsulated abstractions, containing data and methods. Thus, including a member function in a\n\u003ccode\u003estruct\u003c/code\u003e is likely to lead to confusion at best and should be avoided.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstruct S\n{\n  S(int x, int y) : x(x), y(y) {}\n  int x;\n  int y;\n  public:\n    int fun(); // Noncompliant\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstruct S\n{\n  S(int x, int y) : x(x), y(y) {}\n  int x;\n  int y;\n};\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Constructors are ignored for this rule, because they are the only way that a \u003ccode\u003estruct\u003c/code\u003e designer can enforce that all fields of a\n  \u003ccode\u003estruct\u003c/code\u003e are correctly initialized. \u003c/li\u003e\n  \u003cli\u003e Overload of the function operator \u0027()\u0027. It is a common practice to use struct as a functor. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhile it is possible to define a \u003ccode\u003estruct\u003c/code\u003e with member functions in C++, the general expectation is that \u003ccode\u003estruct\u003c/code\u003es only\naggregate data, while classes are used for fully encapsulated abstractions, containing data and methods. Thus, including a member function in a\n\u003ccode\u003estruct\u003c/code\u003e is likely to lead to confusion at best and should be avoided.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstruct S\n{\n  S(int x, int y) : x(x), y(y) {}\n  int x;\n  int y;\n  public:\n    int fun(); // Noncompliant\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstruct S\n{\n  S(int x, int y) : x(x), y(y) {}\n  int x;\n  int y;\n};\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Constructors are ignored for this rule, because they are the only way that a \u003ccode\u003estruct\u003c/code\u003e designer can enforce that all fields of a\n  \u003ccode\u003estruct\u003c/code\u003e are correctly initialized. \u003c/li\u003e\n  \u003cli\u003e Overload of the function operator \u0027()\u0027. It is a common practice to use struct as a functor. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1772",
    "name": "Constants should come first in equality tests",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe result of the comparison is the same, regardless of whether the constant is on the left or right-hand side. But following this convention will\nhelp pinpoint the occasional error where \u003ccode\u003e\u003d\u003c/code\u003e (assignment) is substituted for \u003ccode\u003e\u003d\u003d\u003c/code\u003e (comparison).\u003c/p\u003e\n\u003cp\u003eIf the constant is on the right-hand side of the expression in such cases, the code will still compile and run - just not as expected. If the\nconstant is on the left-hand side, the error will be caught at the first attempt to compile.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nif ( var \u003d\u003d constant )\nif ( pointer \u003d\u003d NULL )\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nif ( constant \u003d\u003d var )\nif ( NULL \u003d\u003d pointer )\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe result of the comparison is the same, regardless of whether the constant is on the left or right-hand side. But following this convention will\nhelp pinpoint the occasional error where \u003ccode\u003e\u003d\u003c/code\u003e (assignment) is substituted for \u003ccode\u003e\u003d\u003d\u003c/code\u003e (comparison).\u003c/p\u003e\n\u003cp\u003eIf the constant is on the right-hand side of the expression in such cases, the code will still compile and run - just not as expected. If the\nconstant is on the left-hand side, the error will be caught at the first attempt to compile.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nif ( var \u003d\u003d constant )\nif ( pointer \u003d\u003d NULL )\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nif ( constant \u003d\u003d var )\nif ( NULL \u003d\u003d pointer )\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "convention"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1773",
    "name": "\"public\", \"protected\" and \"private\" sections of a class should be declared in that order",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eCoding conventions allow teams to work efficiently together. This rule checks that the \u003ccode\u003epublic\u003c/code\u003e section of a class is declared first,\nfollowed by the \u003ccode\u003eprotected\u003c/code\u003e section, and ending with the \u003ccode\u003eprivate\u003c/code\u003e section.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass Point\n{\n  private:\n    String _color;\n    ...\n\n  protected:\n    ...\n\n  public:\n    String getColor();\n    String setColor();\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nclass Point\n{\n  public:\n    String getColor();\n    String setColor();\n\n  protected:\n    ...\n\n  private:\n    String _color;\n    ...\n};\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eCoding conventions allow teams to work efficiently together. This rule checks that the \u003ccode\u003epublic\u003c/code\u003e section of a class is declared first,\nfollowed by the \u003ccode\u003eprotected\u003c/code\u003e section, and ending with the \u003ccode\u003eprivate\u003c/code\u003e section.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass Point\n{\n  private:\n    String _color;\n    ...\n\n  protected:\n    ...\n\n  public:\n    String getColor();\n    String setColor();\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nclass Point\n{\n  public:\n    String getColor();\n    String setColor();\n\n  protected:\n    ...\n\n  private:\n    String _color;\n    ...\n};\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "convention"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1774",
    "name": "The ternary operator should not be used",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eTernary expressions, while concise, can often lead to code that is difficult to read and understand, especially when they are nested or complex.\nPrioritizing readability fosters maintainability and reduces the likelihood of bugs. Therefore, they should be removed in favor of more explicit\ncontrol structures, such as \u003ccode\u003eif\u003c/code\u003e/\u003ccode\u003eelse\u003c/code\u003e statements, to improve the clarity and readability of the code.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre\u003e\nprintf(\"%s\", (i \u0026gt; 10 ? \"yes\" : \"no\"));  // Noncompliant\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre\u003e\nif (i \u0026gt; 10) {\n  printf(\"yes\");\n} else {\n  printf(\"no\");\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eFor C++11 mode only, the issue is not raised for ternary operators used inside \u003ccode\u003econstexpr\u003c/code\u003e functions. In C++11 such functions are\nlimited to just a return statement, so the use of a ternary operator is required in them. This restriction is lifted in later standards, and thus\nissues are raised.\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eTernary expressions, while concise, can often lead to code that is difficult to read and understand, especially when they are nested or complex.\nPrioritizing readability fosters maintainability and reduces the likelihood of bugs. Therefore, they should be removed in favor of more explicit\ncontrol structures, such as \u003ccode\u003eif\u003c/code\u003e/\u003ccode\u003eelse\u003c/code\u003e statements, to improve the clarity and readability of the code.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre\u003e\nprintf(\"%s\", (i \u0026gt; 10 ? \"yes\" : \"no\"));  // Noncompliant\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre\u003e\nif (i \u0026gt; 10) {\n  printf(\"yes\");\n} else {\n  printf(\"no\");\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eFor C++11 mode only, the issue is not raised for ternary operators used inside \u003ccode\u003econstexpr\u003c/code\u003e functions. In C++11 such functions are\nlimited to just a return statement, so the use of a ternary operator is required in them. This restriction is lifted in later standards, and thus\nissues are raised.\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "brain-overload"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S812",
    "name": "The first operand of a conditional operator should have type bool",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThis rule is a strict implementation of a MISRA (Motor Industry Software Reliability Association) rule. MISRA defines best practices for developing\nsafety-critical software. You can learn more about this rule in the MISRA documents referenced below.\u003c/p\u003e\n\u003cp\u003eIf you are not concerned with MISRA compliance or with safety-critical software, you might consider using rule {rule:cpp:S867} instead ; it targets\nthe same kind of issue for general-purpose software.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++ 2008, 5-0-14 - The first operand of a conditional-operator shall have type bool. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThis rule is a strict implementation of a MISRA (Motor Industry Software Reliability Association) rule. MISRA defines best practices for developing\nsafety-critical software. You can learn more about this rule in the MISRA documents referenced below.\u003c/p\u003e\n\u003cp\u003eIf you are not concerned with MISRA compliance or with safety-critical software, you might consider using rule {rule:cpp:S867} instead ; it targets\nthe same kind of issue for general-purpose software.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C++ 2008, 5-0-14 - The first operand of a conditional-operator shall have type bool. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "misra-c++2008"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S813",
    "name": "typedefs that indicate size and signedness should be used in place of the basic types",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe basic numeric types \u003ccode\u003echar\u003c/code\u003e, \u003ccode\u003eint\u003c/code\u003e, \u003ccode\u003eshort\u003c/code\u003e, \u003ccode\u003elong\u003c/code\u003e, \u003ccode\u003efloat\u003c/code\u003e, \u003ccode\u003edouble\u003c/code\u003e, and\n\u003ccode\u003elong double\u003c/code\u003e should not be used. Instead, specific-length typedefs should be. This rule helps to clarify the size of the storage, but does\nnot guarantee portability because of the asymmetric behavior of integral promotion.\u003c/p\u003e\n\u003cp\u003eNote that it is still important to understand the integer size of the implementation, and developers should be aware of the actual implementation\nof the typedefs under these definitions.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint function(unsigned short a) // Noncompliant\n{\n  // ...\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;stdint.h\u0026gt;\nint32_t function(uint16_t a) // Compliant\n{\n  // ...\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 6.3 - typedefs that indicate size and signedness should be used in place of the basic types \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 3-9-2 - typedefs that indicate size and signedness should be used in place of the basic numerical types \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe basic numeric types \u003ccode\u003echar\u003c/code\u003e, \u003ccode\u003eint\u003c/code\u003e, \u003ccode\u003eshort\u003c/code\u003e, \u003ccode\u003elong\u003c/code\u003e, \u003ccode\u003efloat\u003c/code\u003e, \u003ccode\u003edouble\u003c/code\u003e, and\n\u003ccode\u003elong double\u003c/code\u003e should not be used. Instead, specific-length typedefs should be. This rule helps to clarify the size of the storage, but does\nnot guarantee portability because of the asymmetric behavior of integral promotion.\u003c/p\u003e\n\u003cp\u003eNote that it is still important to understand the integer size of the implementation, and developers should be aware of the actual implementation\nof the typedefs under these definitions.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint function(unsigned short a) // Noncompliant\n{\n  // ...\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;stdint.h\u0026gt;\nint32_t function(uint16_t a) // Compliant\n{\n  // ...\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 6.3 - typedefs that indicate size and signedness should be used in place of the basic types \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 3-9-2 - typedefs that indicate size and signedness should be used in place of the basic numerical types \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "based-on-misra"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S810",
    "name": "Appropriate char types should be used for character and integer values",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThere are three distinct \u003ccode\u003echar\u003c/code\u003e types, (plain) \u003ccode\u003echar\u003c/code\u003e, \u003ccode\u003esigned char\u003c/code\u003e and \u003ccode\u003eunsigned char\u003c/code\u003e. \u003ccode\u003esigned\nchar\u003c/code\u003e and \u003ccode\u003eunsigned char\u003c/code\u003e should only be used for numeric data, and plain \u003ccode\u003echar\u003c/code\u003e should only be used for character data.\nSince it is implementation-defined, the signedness of the plain \u003ccode\u003echar\u003c/code\u003e type should not be assumed.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nsigned char a \u003d \u0027a\u0027; // Noncompliant, explicitly signed\nunsigned char b \u003d \u0027\\r\u0027; // Noncompliant, explicitly unsigned\nchar c \u003d 10; // Noncompliant\n\nunsigned char d \u003d c; // Noncompliant, d is explicitly signed while c is not\nchar e \u003d a; // Noncompliant, a is explicitly signed while e is not\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nchar a \u003d \u0027a\u0027;\nchar b \u003d \u0027\\r\u0027;\nunsigned char c \u003d 10;\nsigned char c \u003d 10;\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Since the integer value 0 is used as a sentinel for the end of a string, converting this value to char is ignored. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 6.1 - The plain char type shall be used only for the storage and use of character values \u003c/li\u003e\n  \u003cli\u003e MISRA C:2004, 6.2 - signed and unsigned char type shall be used only for the storage and use of number values \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 5-0-11 - The plain char type shall only be used for the storage and use of character values \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 5-0-12 - signed char and unsigned char type shall only be used for the storage and use of numeric values \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/AtcxBQ\"\u003eCERT, INT07-C.\u003c/a\u003e - Use only explicitly signed or unsigned char type for numeric values\n  \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/F9YxBQ\"\u003eCERT, STR00-C.\u003c/a\u003e - Represent characters using an appropriate type \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/3tYxBQ\"\u003eCERT, STR04-C.\u003c/a\u003e - Use plain char for characters in the basic character set \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThere are three distinct \u003ccode\u003echar\u003c/code\u003e types, (plain) \u003ccode\u003echar\u003c/code\u003e, \u003ccode\u003esigned char\u003c/code\u003e and \u003ccode\u003eunsigned char\u003c/code\u003e. \u003ccode\u003esigned\nchar\u003c/code\u003e and \u003ccode\u003eunsigned char\u003c/code\u003e should only be used for numeric data, and plain \u003ccode\u003echar\u003c/code\u003e should only be used for character data.\nSince it is implementation-defined, the signedness of the plain \u003ccode\u003echar\u003c/code\u003e type should not be assumed.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nsigned char a \u003d \u0027a\u0027; // Noncompliant, explicitly signed\nunsigned char b \u003d \u0027\\r\u0027; // Noncompliant, explicitly unsigned\nchar c \u003d 10; // Noncompliant\n\nunsigned char d \u003d c; // Noncompliant, d is explicitly signed while c is not\nchar e \u003d a; // Noncompliant, a is explicitly signed while e is not\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nchar a \u003d \u0027a\u0027;\nchar b \u003d \u0027\\r\u0027;\nunsigned char c \u003d 10;\nsigned char c \u003d 10;\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Since the integer value 0 is used as a sentinel for the end of a string, converting this value to char is ignored. \u003c/li\u003e\n\u003c/ul\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 6.1 - The plain char type shall be used only for the storage and use of character values \u003c/li\u003e\n  \u003cli\u003e MISRA C:2004, 6.2 - signed and unsigned char type shall be used only for the storage and use of number values \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 5-0-11 - The plain char type shall only be used for the storage and use of character values \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 5-0-12 - signed char and unsigned char type shall only be used for the storage and use of numeric values \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/AtcxBQ\"\u003eCERT, INT07-C.\u003c/a\u003e - Use only explicitly signed or unsigned char type for numeric values\n  \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/F9YxBQ\"\u003eCERT, STR00-C.\u003c/a\u003e - Represent characters using an appropriate type \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/3tYxBQ\"\u003eCERT, STR04-C.\u003c/a\u003e - Use plain char for characters in the basic character set \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "cert",
      "confusing"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S811",
    "name": "The condition of an if-statement and the condition of an iteration-statement shall have type bool",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThis rule is a strict implementation of a MISRA (Motor Industry Software Reliability Association) rule. MISRA defines best practices for developing\nsafety-critical software. You can learn more about this rule in the MISRA documents referenced below.\u003c/p\u003e\n\u003cp\u003eIf you are not concerned with MISRA compliance or with safety-critical software, you might consider using rule {rule:cpp:S867} instead ; it targets\nthe same kind of issue for general-purpose software.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++ 2008, 5-0-13 \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThis rule is a strict implementation of a MISRA (Motor Industry Software Reliability Association) rule. MISRA defines best practices for developing\nsafety-critical software. You can learn more about this rule in the MISRA documents referenced below.\u003c/p\u003e\n\u003cp\u003eIf you are not concerned with MISRA compliance or with safety-critical software, you might consider using rule {rule:cpp:S867} instead ; it targets\nthe same kind of issue for general-purpose software.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C++ 2008, 5-0-13 \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "misra-c++2008"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S4790",
    "name": "Using weak hashing algorithms is security-sensitive",
    "defaultSeverity": "CRITICAL",
    "type": "SECURITY_HOTSPOT",
    "cleanCodeAttribute": "TRUSTWORTHY",
    "defaultImpacts": {
      "SECURITY": "HIGH"
    },
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eCryptographic hash algorithms such as \u003ccode\u003eMD2\u003c/code\u003e, \u003ccode\u003eMD4\u003c/code\u003e, \u003ccode\u003eMD5\u003c/code\u003e, \u003ccode\u003eMD6\u003c/code\u003e, \u003ccode\u003eHAVAL-128\u003c/code\u003e,\n\u003ccode\u003eHMAC-MD5\u003c/code\u003e, \u003ccode\u003eDSA\u003c/code\u003e (which uses \u003ccode\u003eSHA-1\u003c/code\u003e), \u003ccode\u003eRIPEMD\u003c/code\u003e, \u003ccode\u003eRIPEMD-128\u003c/code\u003e, \u003ccode\u003eRIPEMD-160\u003c/code\u003e,\n\u003ccode\u003eHMACRIPEMD160\u003c/code\u003e and \u003ccode\u003eSHA-1\u003c/code\u003e are no longer considered secure, because it is possible to have \u003ccode\u003ecollisions\u003c/code\u003e (little\ncomputational effort is enough to find two or more different inputs that produce the same hash).\u003c/p\u003e"
      },
      {
        "key": "assess_the_problem",
        "htmlContent": "\u003ch2\u003eAsk Yourself Whether\u003c/h2\u003e\n\u003cp\u003eThe hashed value is used in a security context like:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e User-password storage. \u003c/li\u003e\n  \u003cli\u003e Security token generation (used to confirm e-mail when registering on a website, reset password, etc …​). \u003c/li\u003e\n  \u003cli\u003e To compute some message integrity. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere is a risk if you answered yes to any of those questions.\u003c/p\u003e\n\u003ch2\u003eSensitive Code Example\u003c/h2\u003e\n\u003cpre\u003e\n#include \u0026lt;botan/hash.h\u0026gt;\n// ...\n\nBotan::secure_vector\u0026lt;uint8_t\u0026gt; f(std::string input){\n    std::unique_ptr\u0026lt;Botan::HashFunction\u0026gt; hash(Botan::HashFunction::create(\"MD5\")); // Sensitive\n    return hash-\u0026gt;process(input);\n}\n\u003c/pre\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003ch2\u003eRecommended Secure Coding Practices\u003c/h2\u003e\n\u003cp\u003eSafer alternatives, such as \u003ccode\u003eSHA-256\u003c/code\u003e, \u003ccode\u003eSHA-512\u003c/code\u003e, \u003ccode\u003eSHA-3\u003c/code\u003e are recommended, and for password hashing, it’s even\nbetter to use algorithms that do not compute too \"quickly\", like \u003ccode\u003ebcrypt\u003c/code\u003e, \u003ccode\u003escrypt\u003c/code\u003e, \u003ccode\u003eargon2\u003c/code\u003e or \u003ccode\u003epbkdf2\u003c/code\u003e\nbecause it slows down \u003ccode\u003ebrute force attacks\u003c/code\u003e.\u003c/p\u003e\n\u003ch2\u003eCompliant Solution\u003c/h2\u003e\n\u003cpre\u003e\n#include \u0026lt;botan/hash.h\u0026gt;\n// ...\n\nBotan::secure_vector\u0026lt;uint8_t\u0026gt; f(std::string input){\n    std::unique_ptr\u0026lt;Botan::HashFunction\u0026gt; hash(Botan::HashFunction::create(\"SHA-512\")); // Compliant\n    return hash-\u0026gt;process(input);\n}\n\u003c/pre\u003e\n\u003ch2\u003eSee\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/Top10/A02_2021-Cryptographic_Failures/\"\u003eOWASP Top 10 2021 Category A2\u003c/a\u003e - Cryptographic Failures \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://www.owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\"\u003eOWASP Top 10 2017 Category A3\u003c/a\u003e - Sensitive Data\n  Exposure \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration\"\u003eOWASP Top 10 2017 Category A6\u003c/a\u003e - Security\n  Misconfiguration \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://mobile-security.gitbook.io/masvs/security-requirements/0x08-v3-cryptography_verification_requirements\"\u003eMobile AppSec\n  Verification Standard\u003c/a\u003e - Cryptography Requirements \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/www-project-mobile-top-10/2016-risks/m5-insufficient-cryptography\"\u003eOWASP Mobile Top 10 2016 Category M5\u003c/a\u003e -\n  Insufficient Cryptography \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/1240\"\u003eMITRE, CWE-1240\u003c/a\u003e - Use of a Risky Cryptographic Primitive \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cwe"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": [],
    "vulnerabilityProbability": "LOW"
  },
  {
    "key": "cpp:S818",
    "name": "Literal suffix \"L\" for long integers shall be upper case",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "IDENTIFIABLE",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eUsing upper case literal suffixes removes the potential ambiguity between \"1\" (digit 1) and \"l\" (letter el) for declaring literals.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nconst int        a \u003d 0u;      // Noncompliant\nconst int        b \u003d 0l;      // Noncompliant\nconst int        c \u003d 0Ul;     // Noncompliant\nconst int        d \u003d 0x12bu;  // Noncompliant\nconst float      m \u003d 1.2f;    // Noncompliant\nconst float      n \u003d 1.2l;    // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nconst int        a \u003d 0U;\nconst int        b \u003d 0L;\nconst int        c \u003d 0UL;\nconst int        d \u003d 0x12bU;\nconst float      m \u003d 1.2F;\nconst float      n \u003d 1.2L;\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 2-13-4 - Literal suffixes shall be upper case \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 7.3 - The lowercase character \"l\" shall not be used in a literal suffix \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/cdYxBQ\"\u003eCERT DCL16-C.\u003c/a\u003e - Use \"L,\" not \"l,\" to indicate a long value \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eUsing upper case literal suffixes removes the potential ambiguity between \"1\" (digit 1) and \"l\" (letter el) for declaring literals.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nconst int        a \u003d 0u;      // Noncompliant\nconst int        b \u003d 0l;      // Noncompliant\nconst int        c \u003d 0Ul;     // Noncompliant\nconst int        d \u003d 0x12bu;  // Noncompliant\nconst float      m \u003d 1.2f;    // Noncompliant\nconst float      n \u003d 1.2l;    // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nconst int        a \u003d 0U;\nconst int        b \u003d 0L;\nconst int        c \u003d 0UL;\nconst int        d \u003d 0x12bU;\nconst float      m \u003d 1.2F;\nconst float      n \u003d 1.2L;\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 2-13-4 - Literal suffixes shall be upper case \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 7.3 - The lowercase character \"l\" shall not be used in a literal suffix \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/cdYxBQ\"\u003eCERT DCL16-C.\u003c/a\u003e - Use \"L,\" not \"l,\" to indicate a long value \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "cert",
      "convention",
      "pitfall"
    ],
    "deprecatedKeys": [
      "cpp:LiteralSuffix"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S817",
    "name": "String literals with different prefixes should not be concatenated",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eConcatenation of wide and narrow string literals has not always been supported in C or C++, and even when supported, the meaning may be unclear to\nthe reader. Concatenation of string literals with different encodings is only conditionally supported, and may be removed in a future version of the\nlanguage.\u003c/p\u003e\n\u003cp\u003eTherefore, only string literals with the same prefix should be concatenated together.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nwchar_t n_array[] \u003d \"Hello\" L\"World\";     // Noncompliant\nwchar_t w_array[] \u003d L\"Hello\" \"World\";     // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nchar_t n_array[] \u003d \"Hello\" \"World\";     // Compliant\nwchar_t w_array[] \u003d L\"Hello\" L\"World\";\t// Compliant\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 2-13-5 - Narrow and wide string literals shall not be concatenated. \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/WdYxBQ\"\u003eCERT STR10-C.\u003c/a\u003e - Do not concatenate different type of string literals \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eConcatenation of wide and narrow string literals has not always been supported in C or C++, and even when supported, the meaning may be unclear to\nthe reader. Concatenation of string literals with different encodings is only conditionally supported, and may be removed in a future version of the\nlanguage.\u003c/p\u003e\n\u003cp\u003eTherefore, only string literals with the same prefix should be concatenated together.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nwchar_t n_array[] \u003d \"Hello\" L\"World\";     // Noncompliant\nwchar_t w_array[] \u003d L\"Hello\" \"World\";     // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nchar_t n_array[] \u003d \"Hello\" \"World\";     // Compliant\nwchar_t w_array[] \u003d L\"Hello\" L\"World\";\t// Compliant\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 2-13-5 - Narrow and wide string literals shall not be concatenated. \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/WdYxBQ\"\u003eCERT STR10-C.\u003c/a\u003e - Do not concatenate different type of string literals \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "cert"
    ],
    "deprecatedKeys": [
      "cpp:NarrowAndWideStringConcat"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S814",
    "name": "Bit fields should be declared with appropriate types",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eSome types are not very well suited for use in a bit-field, because their behavior is implementation-defined. When defining a bit-field, you should\nstick to the following safe and portable types:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e In C: \u003ccode\u003esigned short\u003c/code\u003e, \u003ccode\u003eunsigned short\u003c/code\u003e, \u003ccode\u003esigned char\u003c/code\u003e, \u003ccode\u003eunsigned char\u003c/code\u003e, \u003ccode\u003esigned int\u003c/code\u003e,\n  \u003ccode\u003eunsigned int\u003c/code\u003e or \u003ccode\u003e_Bool\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e In C++ before C++14: all enumerated types, as well as\u0026nbsp;\u003ccode\u003esigned short\u003c/code\u003e, \u003ccode\u003eunsigned short\u003c/code\u003e, \u003ccode\u003esigned char\u003c/code\u003e,\n  \u003ccode\u003eunsigned char\u003c/code\u003e, \u003ccode\u003esigned int\u003c/code\u003e, \u003ccode\u003eunsigned int\u003c/code\u003e, \u003ccode\u003esigned long\u003c/code\u003e, \u003ccode\u003eunsigned long\u003c/code\u003e, \u003ccode\u003esigned\n  long long\u003c/code\u003e, \u003ccode\u003eunsigned long long\u003c/code\u003e\u003ccode\u003e\u0026nbsp;or bool\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e In C++ starting at C++14: all enumerated and integral types \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n// Assuming we are in C\nint b:3; // Noncompliant - may have the range of values 0..7 or -4..3\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nunsigned int b:3;\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 6.4 - Bit fields shall only be defined to be of type \u003cem\u003eunsigned int\u003c/em\u003e or \u003cem\u003esigned int\u003c/em\u003e. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 9-6-2 - Bit-fields shall be either \u003cem\u003ebool\u003c/em\u003e type or an explicitly \u003cem\u003eunsigned\u003c/em\u003e or \u003cem\u003esigned\u003c/em\u003e integral type.\n  \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 6.1 - Bit-fields shall only be declared with an appropriate type \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/VNYxBQ\"\u003eCERT, INT12-C.\u003c/a\u003e - Do not make assumptions about the type of a plain int bit-field\n  when used in an expression \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eSome types are not very well suited for use in a bit-field, because their behavior is implementation-defined. When defining a bit-field, you should\nstick to the following safe and portable types:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e In C: \u003ccode\u003esigned short\u003c/code\u003e, \u003ccode\u003eunsigned short\u003c/code\u003e, \u003ccode\u003esigned char\u003c/code\u003e, \u003ccode\u003eunsigned char\u003c/code\u003e, \u003ccode\u003esigned int\u003c/code\u003e,\n  \u003ccode\u003eunsigned int\u003c/code\u003e or \u003ccode\u003e_Bool\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e In C++ before C++14: all enumerated types, as well as\u0026nbsp;\u003ccode\u003esigned short\u003c/code\u003e, \u003ccode\u003eunsigned short\u003c/code\u003e, \u003ccode\u003esigned char\u003c/code\u003e,\n  \u003ccode\u003eunsigned char\u003c/code\u003e, \u003ccode\u003esigned int\u003c/code\u003e, \u003ccode\u003eunsigned int\u003c/code\u003e, \u003ccode\u003esigned long\u003c/code\u003e, \u003ccode\u003eunsigned long\u003c/code\u003e, \u003ccode\u003esigned\n  long long\u003c/code\u003e, \u003ccode\u003eunsigned long long\u003c/code\u003e\u003ccode\u003e\u0026nbsp;or bool\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e In C++ starting at C++14: all enumerated and integral types \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n// Assuming we are in C\nint b:3; // Noncompliant - may have the range of values 0..7 or -4..3\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nunsigned int b:3;\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 6.4 - Bit fields shall only be defined to be of type \u003cem\u003eunsigned int\u003c/em\u003e or \u003cem\u003esigned int\u003c/em\u003e. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 9-6-2 - Bit-fields shall be either \u003cem\u003ebool\u003c/em\u003e type or an explicitly \u003cem\u003eunsigned\u003c/em\u003e or \u003cem\u003esigned\u003c/em\u003e integral type.\n  \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 6.1 - Bit-fields shall only be declared with an appropriate type \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/VNYxBQ\"\u003eCERT, INT12-C.\u003c/a\u003e - Do not make assumptions about the type of a plain int bit-field\n  when used in an expression \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "cert",
      "lock-in"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S935",
    "name": "Function exit paths should have appropriate return values",
    "defaultSeverity": "CRITICAL",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhen a function does not return an appropriate value, it causes the program to have an undefined behavior. For example, if a function is supposed\nto return a value indicating whether a file was successfully opened but does not return any value, the program may continue to execute as if the file\nwas opened successfully, even though it was not. This can lead to data corruption or other issues that are difficult to diagnose.\u003c/p\u003e\n\u003cp\u003eFunctions with a void return type are not expected to return any value. If they do, it may indicate a programming error.\u003c/p\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThe rule does not raise an issue:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e when the \u003ccode\u003ereturn\u003c/code\u003e statement of a \u003ccode\u003evoid\u003c/code\u003e function is a \u003ccode\u003evoid\u003c/code\u003e expression. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\nvoid foo() {\n  // ...\n}\n\nvoid bar() {\n  return foo(); // Compliant by exception\n}\n\u003c/pre\u003e\n\u003cul\u003e\n  \u003cli\u003e for coroutines, introduced in C++20. Coroutines always declare coroutine objects as return types, but the compiler implicitly creates the\n  returned object. The coroutine body never contains a \u003ccode\u003ereturn\u003c/code\u003e statement, as it is disallowed: if a coroutine returns a value, it will use\n  \u003ccode\u003eco_return\u003c/code\u003e. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nint my_func(int a) {\n  if (a \u0026gt; 100) {\n    return; // Noncompliant\n  }\n\n  // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nint my_func(int a) {\n  if (a \u0026gt; 100) {\n    return a;\n  }\n\n  if (a \u0026gt; 80) {\n    throw new Exception();\n  }\n\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 16.8 - All exit paths from a function with non-void return type shall have an explicit return statement with an expression \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 8-4-3 - All exit paths from a function with non-void return type shall have an explicit return statement with an expression\n  \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 17.4 - All exit paths from a function with non-void return type shall have an explicit return statement with an expression \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/394\"\u003eMITRE, CWE-394\u003c/a\u003e - Unexpected Status Code or Return Value \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/m9YxBQ\"\u003eCERT, MSC37-C.\u003c/a\u003e - Ensure that control never reaches the end of a non-void function\n  \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/EXs-BQ\"\u003eCERT, MSC52-CPP.\u003c/a\u003e - Value-returning functions must return a value from all exit paths\n  \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/Cns-BQ\"\u003eCERT, MSC53-CPP.\u003c/a\u003e - Do not return from a function declared [[noreturn]] \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S6369} - Coroutine should have co_return on each execution path or provide return_void \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhen a function does not return an appropriate value, it causes the program to have an undefined behavior. For example, if a function is supposed\nto return a value indicating whether a file was successfully opened but does not return any value, the program may continue to execute as if the file\nwas opened successfully, even though it was not. This can lead to data corruption or other issues that are difficult to diagnose.\u003c/p\u003e\n\u003cp\u003eFunctions with a void return type are not expected to return any value. If they do, it may indicate a programming error.\u003c/p\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThe rule does not raise an issue:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e when the \u003ccode\u003ereturn\u003c/code\u003e statement of a \u003ccode\u003evoid\u003c/code\u003e function is a \u003ccode\u003evoid\u003c/code\u003e expression. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\nvoid foo() {\n  // ...\n}\n\nvoid bar() {\n  return foo(); // Compliant by exception\n}\n\u003c/pre\u003e\n\u003cul\u003e\n  \u003cli\u003e for coroutines, introduced in C++20. Coroutines always declare coroutine objects as return types, but the compiler implicitly creates the\n  returned object. The coroutine body never contains a \u003ccode\u003ereturn\u003c/code\u003e statement, as it is disallowed: if a coroutine returns a value, it will use\n  \u003ccode\u003eco_return\u003c/code\u003e. \u003c/li\u003e\n\u003c/ul\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nint my_func(int a) {\n  if (a \u0026gt; 100) {\n    return; // Noncompliant\n  }\n\n  // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nint my_func(int a) {\n  if (a \u0026gt; 100) {\n    return a;\n  }\n\n  if (a \u0026gt; 80) {\n    throw new Exception();\n  }\n\n  return 0;\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 16.8 - All exit paths from a function with non-void return type shall have an explicit return statement with an expression \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 8-4-3 - All exit paths from a function with non-void return type shall have an explicit return statement with an expression\n  \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 17.4 - All exit paths from a function with non-void return type shall have an explicit return statement with an expression \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/394\"\u003eMITRE, CWE-394\u003c/a\u003e - Unexpected Status Code or Return Value \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/m9YxBQ\"\u003eCERT, MSC37-C.\u003c/a\u003e - Ensure that control never reaches the end of a non-void function\n  \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/EXs-BQ\"\u003eCERT, MSC52-CPP.\u003c/a\u003e - Value-returning functions must return a value from all exit paths\n  \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/Cns-BQ\"\u003eCERT, MSC53-CPP.\u003c/a\u003e - Do not return from a function declared [[noreturn]] \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S6369} - Coroutine should have co_return on each execution path or provide return_void \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "cert",
      "cwe"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S936",
    "name": "Function names should be used either as a call with a parameter list or with the \"\u0026\" operator",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eUsing a \"bald\" function name is likely a bug. Rather than testing the return value of a function with a \u003ccode\u003evoid\u003c/code\u003e parameter list, it\nimplicitly retrieves the address of that function in memory. If that’s truly what’s intended, then it should be made explicit with the use of the\n\u003ccode\u003e\u0026amp;\u003c/code\u003e (address-of) operator. If it’s not, then a parameter list (even an empty one) should be added after the function name.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nint func(void) {\n  // ...\n}\n\nvoid f2(int a, int b) {\n  // ...\n  if (func) {  // Noncompliant: tests that the memory address of func() is non-null\n    //...\n  }\n  // ...\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nint func(void) {\n  // ...\n}\n\nvoid f2(int a, int b) {\n  // ...\n  if (func()) {  // Compliant: tests that the return value of func() \u0026gt; 0\n    //...\n  }\n  // ...\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eCallback functions are a common occurrence and are usually not passed with a preceding \u003ccode\u003e\u0026amp;\u003c/code\u003e. However, there is little ambiguity, so\nthis rule ignores function identifiers when used as a parameter of a function call.\u003c/p\u003e\n\u003cpre\u003e\nvoid foo() {\n  // ...\n}\n\nregisterEvent(AnEvent, foo); // Compliant by exception\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 16.9 - A function identifier shall only be used with either a preceding \u0026amp;, or with a parenthesized parameter list, which may\n  be empty. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 8-4-4 - A function identifier shall only be used to call the function or it shall be preceded by \u0026amp;. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eUsing a \"bald\" function name is likely a bug. Rather than testing the return value of a function with a \u003ccode\u003evoid\u003c/code\u003e parameter list, it\nimplicitly retrieves the address of that function in memory. If that’s truly what’s intended, then it should be made explicit with the use of the\n\u003ccode\u003e\u0026amp;\u003c/code\u003e (address-of) operator. If it’s not, then a parameter list (even an empty one) should be added after the function name.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nint func(void) {\n  // ...\n}\n\nvoid f2(int a, int b) {\n  // ...\n  if (func) {  // Noncompliant: tests that the memory address of func() is non-null\n    //...\n  }\n  // ...\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nint func(void) {\n  // ...\n}\n\nvoid f2(int a, int b) {\n  // ...\n  if (func()) {  // Compliant: tests that the return value of func() \u0026gt; 0\n    //...\n  }\n  // ...\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eCallback functions are a common occurrence and are usually not passed with a preceding \u003ccode\u003e\u0026amp;\u003c/code\u003e. However, there is little ambiguity, so\nthis rule ignores function identifiers when used as a parameter of a function call.\u003c/p\u003e\n\u003cpre\u003e\nvoid foo() {\n  // ...\n}\n\nregisterEvent(AnEvent, foo); // Compliant by exception\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 16.9 - A function identifier shall only be used with either a preceding \u0026amp;, or with a parenthesized parameter list, which may\n  be empty. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 8-4-4 - A function identifier shall only be used to call the function or it shall be preceded by \u0026amp;. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S3229",
    "name": "Members should be initialized in the order they are declared",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eClass members are initialized in the order in which they are declared in the class, not the order in which they appear in the class initializer\nlist. To avoid errors caused by order-dependent initialization, the order of members in the initialization list should match the order in which\nmembers are declared in a class.\u003c/p\u003e\n\u003cp\u003eThe initialization order, as described \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/constructor#Initialization_order\"\u003ehere\u003c/a\u003e, is:\u003c/p\u003e\n\u003col\u003e\n  \u003cli\u003e If the constructor is for the most-derived class, virtual bases are initialized in the order in which they appear in depth-first left-to-right\n  traversal of the base class declarations (left-to-right refers to the appearance in base-specifier lists) \u003c/li\u003e\n  \u003cli\u003e Then, direct bases are initialized in left-to-right order as they appear in this class’s base-specifier list \u003c/li\u003e\n  \u003cli\u003e Then, non-static data members are initialized in order of declaration in the class definition. \u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;iostream\u0026gt;\n\nstruct A {\n  A(int num) {\n    std::cout \u0026lt;\u0026lt; \"A(num \u003d \" \u0026lt;\u0026lt; num \u0026lt;\u0026lt; \")\" \u0026lt;\u0026lt; std::endl;\n  }\n};\n\nstruct B {\n  int b;\n};\n\nclass C : public A, B {\npublic:\n  int x;\n  int y;\n\n  C(int i) : B{i}, A{b}, y(i), x(y + 1) { }  // Noncompliant\n};\n\nint main() {\n  C c(1); // Undefined behavior, might print \"A(num \u003d 0)\"\n  std::cout \u0026lt;\u0026lt; c.x \u0026lt;\u0026lt; \" \" \u0026lt;\u0026lt; c.y \u0026lt;\u0026lt; std::endl;  // might print \"1 1\"\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;iostream\u0026gt;\n\nstruct A {\n  A(int num) {\n    std::cout \u0026lt;\u0026lt; \"A(num \u003d \" \u0026lt;\u0026lt; num \u0026lt;\u0026lt; \")\" \u0026lt;\u0026lt; std::endl;\n  }\n};\n\nstruct B {\n  int b;\n};\n\nclass C : public A, B {\npublic:\n  int x;\n  int y;\n\n  C(int i) : A{i}, B{i}, x(i + 1), y(i) { }\n};\n\nint main() {\n  C c(1); // prints \"A(num \u003d 1)\"\n  std::cout \u0026lt;\u0026lt; c.x \u0026lt;\u0026lt; \" \" \u0026lt;\u0026lt; c.y \u0026lt;\u0026lt; std::endl;  // prints \"2 1\"\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/dXw-BQ\"\u003eCERT, OOP53-CPP.\u003c/a\u003e - Write constructor member initializers in the canonical order\n  \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c47-define-and-initialize-member-variables-in-the-order-of-member-declaration\"\u003eC.47: Define and initialize member variables in the order of member declaration\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eClass members are initialized in the order in which they are declared in the class, not the order in which they appear in the class initializer\nlist. To avoid errors caused by order-dependent initialization, the order of members in the initialization list should match the order in which\nmembers are declared in a class.\u003c/p\u003e\n\u003cp\u003eThe initialization order, as described \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/constructor#Initialization_order\"\u003ehere\u003c/a\u003e, is:\u003c/p\u003e\n\u003col\u003e\n  \u003cli\u003e If the constructor is for the most-derived class, virtual bases are initialized in the order in which they appear in depth-first left-to-right\n  traversal of the base class declarations (left-to-right refers to the appearance in base-specifier lists) \u003c/li\u003e\n  \u003cli\u003e Then, direct bases are initialized in left-to-right order as they appear in this class’s base-specifier list \u003c/li\u003e\n  \u003cli\u003e Then, non-static data members are initialized in order of declaration in the class definition. \u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;iostream\u0026gt;\n\nstruct A {\n  A(int num) {\n    std::cout \u0026lt;\u0026lt; \"A(num \u003d \" \u0026lt;\u0026lt; num \u0026lt;\u0026lt; \")\" \u0026lt;\u0026lt; std::endl;\n  }\n};\n\nstruct B {\n  int b;\n};\n\nclass C : public A, B {\npublic:\n  int x;\n  int y;\n\n  C(int i) : B{i}, A{b}, y(i), x(y + 1) { }  // Noncompliant\n};\n\nint main() {\n  C c(1); // Undefined behavior, might print \"A(num \u003d 0)\"\n  std::cout \u0026lt;\u0026lt; c.x \u0026lt;\u0026lt; \" \" \u0026lt;\u0026lt; c.y \u0026lt;\u0026lt; std::endl;  // might print \"1 1\"\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;iostream\u0026gt;\n\nstruct A {\n  A(int num) {\n    std::cout \u0026lt;\u0026lt; \"A(num \u003d \" \u0026lt;\u0026lt; num \u0026lt;\u0026lt; \")\" \u0026lt;\u0026lt; std::endl;\n  }\n};\n\nstruct B {\n  int b;\n};\n\nclass C : public A, B {\npublic:\n  int x;\n  int y;\n\n  C(int i) : A{i}, B{i}, x(i + 1), y(i) { }\n};\n\nint main() {\n  C c(1); // prints \"A(num \u003d 1)\"\n  std::cout \u0026lt;\u0026lt; c.x \u0026lt;\u0026lt; \" \" \u0026lt;\u0026lt; c.y \u0026lt;\u0026lt; std::endl;  // prints \"2 1\"\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/dXw-BQ\"\u003eCERT, OOP53-CPP.\u003c/a\u003e - Write constructor member initializers in the canonical order\n  \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c47-define-and-initialize-member-variables-in-the-order-of-member-declaration\"\u003eC.47: Define and initialize member variables in the order of member declaration\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cert",
      "cppcoreguidelines",
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5408",
    "name": "\"constexpr\" functions should not be declared \"inline\"",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eDeclaring a function or a static member variable \u003ccode\u003econstexpr\u003c/code\u003e makes it implicitly inline.\u003c/p\u003e\n\u003cp\u003eIn that situation, explicitly using the \u003ccode\u003einline\u003c/code\u003e keyword would be redundant, and might lead to confusion if it’s used in some cases but\nnot others. It’s better to simply omit it.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\ninline constexpr int addOne(int n) { return n+1; } // Noncompliant\nstruct A {\ninline constexpr static int secretNumber \u003d 0; // Noncompliant\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nconstexpr int addOne(int n) { return n+1; }\nstruct A {\nconstexpr static int secretNumber \u003d 0;\n};\n\u003c/pre\u003e\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eDeclaring a function or a static member variable \u003ccode\u003econstexpr\u003c/code\u003e makes it implicitly inline.\u003c/p\u003e\n\u003cp\u003eIn that situation, explicitly using the \u003ccode\u003einline\u003c/code\u003e keyword would be redundant, and might lead to confusion if it’s used in some cases but\nnot others. It’s better to simply omit it.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\ninline constexpr int addOne(int n) { return n+1; } // Noncompliant\nstruct A {\ninline constexpr static int secretNumber \u003d 0; // Noncompliant\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nconstexpr int addOne(int n) { return n+1; }\nstruct A {\nconstexpr static int secretNumber \u003d 0;\n};\n\u003c/pre\u003e\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "redundant",
      "since-c++11"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5409",
    "name": "Functions that throw exceptions should not be used as hash functions",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eYou can provide your own hash function when using a standard library container based on a hash table (for instance,\n\u003ccode\u003estd::unordered_map\u003c/code\u003e). One of the requirements of the hash function is that it should not throw exceptions.\u003c/p\u003e\n\u003cp\u003eIf you don’t follow this requirement and your hash function throws, you may end up with corrupted data in your container.\u003c/p\u003e\n\u003cp\u003eSince this function is not supposed to throw, you should also declare it \u003ccode\u003enoexcept\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nstruct MyHash {\n  size_t operator() (Customer c) const { // Noncompliant, copying may throw\n    if (c.name().empty()) {\n      throw std::runtime_error(\"You should know the customer name at this point\"); // Noncompliant\n    }\n    return std::hash\u0026lt;std::string\u0026gt;()(c.name());\n  }\n};\nstd::unordered_set\u0026lt;Customer, MyHash\u0026gt; mySet;\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nstruct MyHash {\n  size_t operator() (Customer const \u0026amp;c) const noexcept {\n    return std::hash\u0026lt;std::string\u0026gt;()(c.name());\n  }\n};\nstd::unordered_set\u0026lt;Customer, MyHash\u0026gt; mySet;\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c89-make-a-hash-noexcept\"\u003eC.89:\n  Make a \u003ccode\u003ehash\u003c/code\u003e \u003ccode\u003enoexcept\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eYou can provide your own hash function when using a standard library container based on a hash table (for instance,\n\u003ccode\u003estd::unordered_map\u003c/code\u003e). One of the requirements of the hash function is that it should not throw exceptions.\u003c/p\u003e\n\u003cp\u003eIf you don’t follow this requirement and your hash function throws, you may end up with corrupted data in your container.\u003c/p\u003e\n\u003cp\u003eSince this function is not supposed to throw, you should also declare it \u003ccode\u003enoexcept\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nstruct MyHash {\n  size_t operator() (Customer c) const { // Noncompliant, copying may throw\n    if (c.name().empty()) {\n      throw std::runtime_error(\"You should know the customer name at this point\"); // Noncompliant\n    }\n    return std::hash\u0026lt;std::string\u0026gt;()(c.name());\n  }\n};\nstd::unordered_set\u0026lt;Customer, MyHash\u0026gt; mySet;\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nstruct MyHash {\n  size_t operator() (Customer const \u0026amp;c) const noexcept {\n    return std::hash\u0026lt;std::string\u0026gt;()(c.name());\n  }\n};\nstd::unordered_set\u0026lt;Customer, MyHash\u0026gt; mySet;\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c89-make-a-hash-noexcept\"\u003eC.89:\n  Make a \u003ccode\u003ehash\u003c/code\u003e \u003ccode\u003enoexcept\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cppcoreguidelines",
      "since-c++11",
      "unpredictable"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:M23_196",
    "name": "An exception of class type shall be caught by const reference or reference",
    "defaultSeverity": "BLOCKER",
    "type": "BUG",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 18.3.2\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eSlicing occurs if the exception object is of a derived class and it is caught by value as the base class, which means that information unique to\nthe derived class’s members is lost. Slicing does not occur when the exception is caught by reference.\u003c/p\u003e\n\u003cp\u003eException objects may be shared between threads, such as when an exception is thrown from \u003ccode\u003estd::shared_future\u003c/code\u003e. In this case, catching\nby const reference reduces the chance of data races.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\ntry\n{\n  mayThrow();\n}\ncatch ( std::runtime_error e )       // Non-compliant - slicing occurs\n{\n}\ncatch ( std::exception const \u0026amp; e )   // Compliant - exception object is complete\n{\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003e{rule:cpp:S1044} targets the same defect as this rule but for a non-mission-critical context.\u003c/p\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/SXs-BQ\"\u003ehttps://wiki.sei.cmu.edu/confluence/x/SXs-BQ\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca\n  href\u003d\"https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#e15-catch-exceptions-from-a-hierarchy-by-reference\"\u003ehttps://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#e15-catch-exceptions-from-a-hierarchy-by-reference\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 18.3.2\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eSlicing occurs if the exception object is of a derived class and it is caught by value as the base class, which means that information unique to\nthe derived class’s members is lost. Slicing does not occur when the exception is caught by reference.\u003c/p\u003e\n\u003cp\u003eException objects may be shared between threads, such as when an exception is thrown from \u003ccode\u003estd::shared_future\u003c/code\u003e. In this case, catching\nby const reference reduces the chance of data races.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\ntry\n{\n  mayThrow();\n}\ncatch ( std::runtime_error e )       // Non-compliant - slicing occurs\n{\n}\ncatch ( std::exception const \u0026amp; e )   // Compliant - exception object is complete\n{\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003e{rule:cpp:S1044} targets the same defect as this rule but for a non-mission-critical context.\u003c/p\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/SXs-BQ\"\u003ehttps://wiki.sei.cmu.edu/confluence/x/SXs-BQ\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca\n  href\u003d\"https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#e15-catch-exceptions-from-a-hierarchy-by-reference\"\u003ehttps://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#e15-catch-exceptions-from-a-hierarchy-by-reference\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "misra-c++2023",
      "misra-required"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:M23_191",
    "name": "An \"empty throw\" shall only occur within the \"compound-statement\" of a \"catch handler\"",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 18.1.2\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eAn \u003cem\u003eempty throw\u003c/em\u003e is a \u003cem\u003ethrow-expression\u003c/em\u003e with no operand.\u003c/p\u003e\n\u003cp\u003eFor the purposes of this rule, the body of a lambda declared within the \u003cem\u003ecompound-statement\u003c/em\u003e of a \u003cem\u003ecatch handler\u003c/em\u003e is not considered\nto be part of the \u003cem\u003ecatch handler\u003c/em\u003e.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eAn \u003cem\u003eempty throw\u003c/em\u003e re-throws the temporary object that represents an exception. Its use is intended to enable the handling of an exception to\nbe split across two or more handlers.\u003c/p\u003e\n\u003cp\u003eSyntactically, there is nothing to prevent an \u003cem\u003eempty throw\u003c/em\u003e from being used outside a \u003cem\u003ecatch handler\u003c/em\u003e. However, this would result in\n\u003cem\u003eimplementation-defined\u003c/em\u003e program termination when there is no exception object to re-throw.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nvoid f1( void )\n{\n  try\n  {\n    throw std::range_error( \"range error\" );\n  }\n\n  catch ( std::exception const \u0026amp; )\n  {\n    log( \"Caught in f1\" );\n\n    throw;                   // Compliant - re-throws an exception object\n  }\n}\n\nvoid f2( void )\n{\n  throw;                     // Non-compliant - not syntactically within a catch\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003e{rule:cpp:S1039} targets the same defect as this rule but for a non-mission-critical context.\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 18.1.2\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eAn \u003cem\u003eempty throw\u003c/em\u003e is a \u003cem\u003ethrow-expression\u003c/em\u003e with no operand.\u003c/p\u003e\n\u003cp\u003eFor the purposes of this rule, the body of a lambda declared within the \u003cem\u003ecompound-statement\u003c/em\u003e of a \u003cem\u003ecatch handler\u003c/em\u003e is not considered\nto be part of the \u003cem\u003ecatch handler\u003c/em\u003e.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eAn \u003cem\u003eempty throw\u003c/em\u003e re-throws the temporary object that represents an exception. Its use is intended to enable the handling of an exception to\nbe split across two or more handlers.\u003c/p\u003e\n\u003cp\u003eSyntactically, there is nothing to prevent an \u003cem\u003eempty throw\u003c/em\u003e from being used outside a \u003cem\u003ecatch handler\u003c/em\u003e. However, this would result in\n\u003cem\u003eimplementation-defined\u003c/em\u003e program termination when there is no exception object to re-throw.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nvoid f1( void )\n{\n  try\n  {\n    throw std::range_error( \"range error\" );\n  }\n\n  catch ( std::exception const \u0026amp; )\n  {\n    log( \"Caught in f1\" );\n\n    throw;                   // Compliant - re-throws an exception object\n  }\n}\n\nvoid f2( void )\n{\n  throw;                     // Non-compliant - not syntactically within a catch\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003e{rule:cpp:S1039} targets the same defect as this rule but for a non-mission-critical context.\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "misra-c++2023",
      "misra-required",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:M23_194",
    "name": "Handlers for a \"function-try-block\" of a constructor or destructor shall not refer to non-static members from their class or its bases",
    "defaultSeverity": "BLOCKER",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 18.3.3\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eReferring to a non-static member of a class or a base class in the handler (i.e. the \u003cem\u003ecatch\u003c/em\u003e part) of a \u003cem\u003efunction-try-block\u003c/em\u003e of a\nclass constructor or destructor results in \u003cem\u003eundefined behaviour\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eFor example, if a memory allocation exception is thrown during creation of the object, the object will not exist when the handler attempts to\naccess its members. Additionally, in the destructor, the object may have been successfully destroyed before the exception is handled and it will not\nbe available to the handler.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nclass C\n{\npublic:\n  int32_t x;\n\n  C()\n  try : x { mayThrow() }\n  {\n  }\n\n  catch ( ... )\n  {\n    if ( 0 \u003d\u003d x )   // Non-compliant - x may not exist at this point\n    {\n    }\n  }\n\n  ~C()\n  try\n  {\n    // Action that may raise an exception\n  }\n\n  catch ( ... )\n  {\n    if ( 0 \u003d\u003d x )   // Non-compliant - x may not exist at this point\n    {\n    }\n  }\n};\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003e{rule:cpp:S1042} targets the same defect as this rule but for a non-mission-critical context.\u003c/p\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cp\u003e\u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/_3s-BQ\"\u003ehttps://wiki.sei.cmu.edu/confluence/x/_3s-BQ\u003c/a\u003e\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 18.3.3\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eReferring to a non-static member of a class or a base class in the handler (i.e. the \u003cem\u003ecatch\u003c/em\u003e part) of a \u003cem\u003efunction-try-block\u003c/em\u003e of a\nclass constructor or destructor results in \u003cem\u003eundefined behaviour\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eFor example, if a memory allocation exception is thrown during creation of the object, the object will not exist when the handler attempts to\naccess its members. Additionally, in the destructor, the object may have been successfully destroyed before the exception is handled and it will not\nbe available to the handler.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nclass C\n{\npublic:\n  int32_t x;\n\n  C()\n  try : x { mayThrow() }\n  {\n  }\n\n  catch ( ... )\n  {\n    if ( 0 \u003d\u003d x )   // Non-compliant - x may not exist at this point\n    {\n    }\n  }\n\n  ~C()\n  try\n  {\n    // Action that may raise an exception\n  }\n\n  catch ( ... )\n  {\n    if ( 0 \u003d\u003d x )   // Non-compliant - x may not exist at this point\n    {\n    }\n  }\n};\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003e{rule:cpp:S1042} targets the same defect as this rule but for a non-mission-critical context.\u003c/p\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cp\u003e\u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/_3s-BQ\"\u003ehttps://wiki.sei.cmu.edu/confluence/x/_3s-BQ\u003c/a\u003e\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "misra-c++2023",
      "misra-required"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1042",
    "name": "Handlers of a function-try-block implementation of a class constructor or destructor shall not reference non-static members from this class or its bases",
    "defaultSeverity": "CRITICAL",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhen a constructor/destructor has a function-try-block, the code inside of the catch clause will be executed after the object has been destroyed\n(if the object was partially constructed when the exception was thrown, this part will be destroyed before going in the catch block). Therefore, the\nmembers of the object are not available, and it is undefined behavior to access them.\u003c/p\u003e\n\u003cp\u003eSince the lifetime of a static member is greater than that of the object itself, so a static member can be accessed from the catch code.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass A {\npublic:\n  int i;\n  A ( ) try {\n    // Action that might raise an exception\n  } catch ( ... ) {\n    if ( i \u003d\u003d 0 ) { // Noncompliant, i has been destroyed\n      // ...\n    }\n  }\n  ~A ( ) try {\n    // Action that might raise an exception\n  } catch ( ... ) {\n    if ( i \u003d\u003d 0 ) { // Noncompliant\n      // ...\n    }\n  }\n};\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 15-3-3 \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/_3s-BQ\"\u003eCERT, ERR53-CPP.\u003c/a\u003e - Do not reference base classes or class data members in a\n  constructor or destructor function-try-block handler \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhen a constructor/destructor has a function-try-block, the code inside of the catch clause will be executed after the object has been destroyed\n(if the object was partially constructed when the exception was thrown, this part will be destroyed before going in the catch block). Therefore, the\nmembers of the object are not available, and it is undefined behavior to access them.\u003c/p\u003e\n\u003cp\u003eSince the lifetime of a static member is greater than that of the object itself, so a static member can be accessed from the catch code.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass A {\npublic:\n  int i;\n  A ( ) try {\n    // Action that might raise an exception\n  } catch ( ... ) {\n    if ( i \u003d\u003d 0 ) { // Noncompliant, i has been destroyed\n      // ...\n    }\n  }\n  ~A ( ) try {\n    // Action that might raise an exception\n  } catch ( ... ) {\n    if ( i \u003d\u003d 0 ) { // Noncompliant\n      // ...\n    }\n  }\n};\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 15-3-3 \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/_3s-BQ\"\u003eCERT, ERR53-CPP.\u003c/a\u003e - Do not reference base classes or class data members in a\n  constructor or destructor function-try-block handler \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cert",
      "misra-c++2008"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S3584",
    "name": "Dynamically allocated memory should be released",
    "defaultSeverity": "BLOCKER",
    "type": "BUG",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003cp\u003eMemory allocated dynamically with \u003ccode\u003ecalloc\u003c/code\u003e, \u003ccode\u003emalloc\u003c/code\u003e, \u003ccode\u003erealloc\u003c/code\u003e, or \u003ccode\u003enew\u003c/code\u003e should be released when it is\nnot needed anymore. Failure to do so will result in a memory leak that could severely hinder application performance or abort it or the entire host\nmachine.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eMemory is a limited resource shared between all the applications running on the same host machine.\u003c/p\u003e\n\u003cp\u003eC and C++ do not automatically reclaim unused memory. The developer has to release the memory claimed for their application that is no longer\nneeded. Unlike the stack that automatically allocates local variables on a function call and deallocates them on a function return, the heap offers no\nautomatic memory management. The developer has to make sure to deallocate the memory they allocate dynamically on the heap.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when memory is allocated dynamically and not freed within the same function.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eNeglecting to free the memory leads to a memory leak.\u003c/p\u003e\n\u003cp\u003eThe application that leaks memory will consume more and more of it over time, eventually claiming all the memory available on the host machine.\nWhen this happens and the system runs out of memory, it typically does one of the following:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The operating system (if any) terminates the application. \u003c/li\u003e\n  \u003cli\u003e The operating system (if any) terminates some other application, and the problem reoccurs when the reclaimed memory gets used up by the leaking\n  application. \u003c/li\u003e\n  \u003cli\u003e The operating system (if any) starts offloading some of the memory pages to disk and slows down some memory accesses by orders of magnitude.\n  \u003c/li\u003e\n  \u003cli\u003e The entire system crashes as a whole and reboots automatically or hangs waiting for a manual reboot. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eMoreover, memory leaks can help an attacker to take over the system. An attacker could use a memory leak to fill the memory with malicious code.\nThis facilitates remote code execution through another chained vulnerability.\u003c/p\u003e\n\u003cp\u003eEven if the attacker cannot take over the system she can intentionally trigger the condition leading to a memory leak to make use of the issue\nabove and cause denial-of-service (DoS) of the system.\u003c/p\u003e\n\u003cp\u003eA memory leak can have a significant impact on the energy footprint of an application.\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e If an application demands more memory than necessary, the user will have to install more memory banks than necessary. Each memory bank consumes\n  additional power. \u003c/li\u003e\n  \u003cli\u003e As the application continues to reserve more and more memory, it places an increased load on the memory management subsystem. This increased\n  load can lead to a larger computation demand, which in turn translates to higher power consumption by the CPU. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eFinally, memory leaks degrade the user experience. The user often experiences a system slowdown caused by the uncontrolled memory use of an\napplication. Delayed response time, system freezes, and crashes degrade the user experience and discourage the further use of the application.\u003c/p\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eIf a function \u003ccode\u003ereturn\u003c/code\u003es a pointer to the caller or stores it in an external structure, this pointer is said to \u003cem\u003eescape\u003c/em\u003e (it is\nnow accessible outside of function, and no longer local to it). This includes storing the pointer in a static or global variable, passing it to a\nfunction that can potentially do that, or returning the pointer directly or as part of an aggregate object.\u003c/p\u003e\n\u003cp\u003eThe memory pointed to by an escaping pointer might be used somewhere else in the program. For that reason, the analyzer cannot proclaim a leak for\nan escaping pointer by only looking at a function scope.\u003c/p\u003e\n\u003cp\u003eWhile in some cases the leak might be detectable in the scope of a caller, in others, the analyzer would need to simulate the entire program to\nverify that the memory is not used anywhere, which is not feasible.\u003c/p\u003e\n\u003cp\u003eFor this technical reason, this rule often ignores escaping pointers.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eAsk yourself whether you need to allocate memory on the heap. If your object is small enough, in many cases allocating it as a local variable on\nthe stack is a better choice as it simplifies memory management.\u003c/p\u003e\n\u003cp\u003eIf you do need to allocate it on the heap, the direct fix for a memory leak is to make sure you always deallocate memory.\u003c/p\u003e\n\u003cp\u003eIn C++ you should use RAII (resource acquisition is initialization) idiom. See \u003ca href\u003d\"#_going_the_extra_mile\"\u003eGoing the extra mile\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eAlternatively, you have to manually make sure that every exit of the scope of the pointer to the allocated memory is prepended by the deallocation\nof that pointer.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nbool fire(Point pos, Direction dir, State const\u0026amp; s) {\n  Bullet *bullet \u003d new Bullet{pos, dir};\n  if (auto affected \u003d bullet-\u0026gt;hitAnyone(s)) {\n    affected-\u0026gt;takeHit();\n    return true; // Noncompliant, the memory pointed to by bullet is not deleted\n  }\n  delete bullet;\n  return false;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eUse a local object\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nbool fire(Point pos, Direction dir, State const\u0026amp; s) {\n  Bullet bullet{pos, dir};\n  if (auto affected \u003d bullet.hitAnyone(s)) {\n    affected-\u0026gt;takeHit();\n    return true; // Compliant: bullet is destroyed and deallocated automatically\n  }\n  return false; // Compliant: bullet is destroyed and deallocated automatically\n}\n\u003c/pre\u003e\n\u003cp\u003eIf you cannot use RAII or a local object, manually make sure memory is freed on every exit of the scope of the pointer.\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\nint fun() {\n  char* name \u003d (char *) malloc (size);\n  if (!name) {\n    return 1;\n  }\n  if (condition()) {\n    return 2; // Noncompliant: memory pointed to by \"name\" has not been released\n  }\n  // ...\n  return 0; // Noncompliant: memory pointed to by \"name\" has not been released\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\nint fun() {\n  char* name \u003d (char *) malloc (size);\n  if (!name) {\n    return 1; // Memory wasn\u0027t allocated, no need to free it\n  }\n  if (condition()) {\n    free(name);\n    return 2; // Compliant: memory is freed\n  }\n  // ...\n  free(name);\n  return 0; // Compliant: memory is freed\n}\n\u003c/pre\u003e\n\u003ch3\u003ePitfalls\u003c/h3\u003e\n\u003cp\u003eNote that the execution can exit the scope in different ways:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003ereturn\u003c/code\u003e from the function \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003ebreak\u003c/code\u003e from a \u003ccode\u003eswitch\u003c/code\u003e statement or a loop \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003egoto\u003c/code\u003e out of a code block (compound statement) \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003ethrow\u003c/code\u003e a C++ exception \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003eco_return\u003c/code\u003e from an C++ coroutine \u003c/li\u003e\n  \u003cli\u003e End of the scope (\u003ccode\u003e}\u003c/code\u003e) \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn the following example, even though the function frees memory before the explicit \u003ccode\u003ereturn\u003c/code\u003e, the memory remains allocated when the\nexecution leaves the \u003ccode\u003ewhile\u003c/code\u003e body via many other ways.\u003c/p\u003e\n\u003cpre\u003e\nvoid fire(Point pos, Direction dir, State const\u0026amp; s) {\n  while (condition()) {\n    Bullet *bullet \u003d new Bullet{pos, dir};\n    if (bullet-\u0026gt;misfired()) break; // Noncompliant: memory is not freed\n    if (!condition()) {\n      delete bullet;\n      return;\n    }\n    // Noncompliant: memory is not freed\n    if (s.tooManyBullets()) throw Exception(\"Too many bullets\");\n    if (bullet-\u0026gt;timeIsUp(s)) goto end; // Noncompliant: memory is not freed\n  } // Noncompliant: at the end of iteration bullet leaks\n\nend: // Memory allocated in the loop is not freed\n  std::cout \u0026lt;\u0026lt;\"Bullet is lost\\n\";\n}\n\u003c/pre\u003e\n\u003cp\u003eThis is why it is very difficult to avoid leaks when managing memory manually.\u003c/p\u003e\n\u003ch3\u003eGoing the extra mile\u003c/h3\u003e\n\u003cp\u003eIn C++, manually allocating and deallocating memory is considered a code smell.\u003c/p\u003e\n\u003cp\u003eIt is recommended to follow the \u003cem\u003eRAII\u003c/em\u003e idiom and create a class that manages the memory by allocating it when the object is constructed and\nfreeing it when it is destroyed. Furthermore, copy and move operations on such objects are designed such that this object can be passed by value\nbetween functions (either as an argument or by being returned) in place of raw pointers.\u003c/p\u003e\n\u003cp\u003eDepending on the type, passing an \u003cem\u003eRAII\u003c/em\u003e object operations may either:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Allocate a new block of memory and copy the elements (\u003ccode\u003estd::vector\u003c/code\u003e). \u003c/li\u003e\n  \u003cli\u003e Transfer ownership of the memory to constructed object (\u003ccode\u003estd::unique_ptr\u003c/code\u003e). \u003c/li\u003e\n  \u003cli\u003e Use shared ownership and free memory when the last object is destroyed (\u003ccode\u003estd::shared_ptr\u003c/code\u003e). \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe RAII object will take care of the deallocation of the memory when it is no longer used.\u003c/p\u003e\n\u003cp\u003eTo correct the noncompliant example, use \u003ccode\u003estd::unique_ptr\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\nbool fire(Point pos, Direction dir, State const\u0026amp; s) {\n  auto bullet \u003d std::make_unique\u0026lt;Bullet\u0026gt;(pos, dir);\n  if (auto affected \u003d bullet-\u0026gt;hitAnything(s)) {\n    affected-\u0026gt;takeHit();\n    return true; // Compliant: unique_ptr\u0026lt;Bullet\u0026gt; automatically frees memory\n  }\n  return false; // Compliant: unique_ptr\u0026lt;Bullet\u0026gt; automatically frees memory\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Wikipedia - \u003ca href\u003d\"https://en.wikipedia.org/wiki/Memory_leak\"\u003eMemory leak\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/raii\"\u003eRAII\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/401\"\u003e401 Improper Release of Memory Before Removing Last Reference (\u0027Memory Leak\u0027)\u003c/a\u003e\n  \u003c/li\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/FtYxBQ\"\u003eMEM00-C. Allocate and free memory in the same module, at the same level of\n  abstraction\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/GNYxBQ\"\u003eMEM31-C. Free dynamically allocated memory when no longer needed\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S5025} discourages manual memory management, which helps to avoid memory leaks. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eMemory allocated dynamically with \u003ccode\u003ecalloc\u003c/code\u003e, \u003ccode\u003emalloc\u003c/code\u003e, \u003ccode\u003erealloc\u003c/code\u003e, or \u003ccode\u003enew\u003c/code\u003e should be released when it is\nnot needed anymore. Failure to do so will result in a memory leak that could severely hinder application performance or abort it or the entire host\nmachine.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eMemory is a limited resource shared between all the applications running on the same host machine.\u003c/p\u003e\n\u003cp\u003eC and C++ do not automatically reclaim unused memory. The developer has to release the memory claimed for their application that is no longer\nneeded. Unlike the stack that automatically allocates local variables on a function call and deallocates them on a function return, the heap offers no\nautomatic memory management. The developer has to make sure to deallocate the memory they allocate dynamically on the heap.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when memory is allocated dynamically and not freed within the same function.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eNeglecting to free the memory leads to a memory leak.\u003c/p\u003e\n\u003cp\u003eThe application that leaks memory will consume more and more of it over time, eventually claiming all the memory available on the host machine.\nWhen this happens and the system runs out of memory, it typically does one of the following:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The operating system (if any) terminates the application. \u003c/li\u003e\n  \u003cli\u003e The operating system (if any) terminates some other application, and the problem reoccurs when the reclaimed memory gets used up by the leaking\n  application. \u003c/li\u003e\n  \u003cli\u003e The operating system (if any) starts offloading some of the memory pages to disk and slows down some memory accesses by orders of magnitude.\n  \u003c/li\u003e\n  \u003cli\u003e The entire system crashes as a whole and reboots automatically or hangs waiting for a manual reboot. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eMoreover, memory leaks can help an attacker to take over the system. An attacker could use a memory leak to fill the memory with malicious code.\nThis facilitates remote code execution through another chained vulnerability.\u003c/p\u003e\n\u003cp\u003eEven if the attacker cannot take over the system she can intentionally trigger the condition leading to a memory leak to make use of the issue\nabove and cause denial-of-service (DoS) of the system.\u003c/p\u003e\n\u003cp\u003eA memory leak can have a significant impact on the energy footprint of an application.\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e If an application demands more memory than necessary, the user will have to install more memory banks than necessary. Each memory bank consumes\n  additional power. \u003c/li\u003e\n  \u003cli\u003e As the application continues to reserve more and more memory, it places an increased load on the memory management subsystem. This increased\n  load can lead to a larger computation demand, which in turn translates to higher power consumption by the CPU. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eFinally, memory leaks degrade the user experience. The user often experiences a system slowdown caused by the uncontrolled memory use of an\napplication. Delayed response time, system freezes, and crashes degrade the user experience and discourage the further use of the application.\u003c/p\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eIf a function \u003ccode\u003ereturn\u003c/code\u003es a pointer to the caller or stores it in an external structure, this pointer is said to \u003cem\u003eescape\u003c/em\u003e (it is\nnow accessible outside of function, and no longer local to it). This includes storing the pointer in a static or global variable, passing it to a\nfunction that can potentially do that, or returning the pointer directly or as part of an aggregate object.\u003c/p\u003e\n\u003cp\u003eThe memory pointed to by an escaping pointer might be used somewhere else in the program. For that reason, the analyzer cannot proclaim a leak for\nan escaping pointer by only looking at a function scope.\u003c/p\u003e\n\u003cp\u003eWhile in some cases the leak might be detectable in the scope of a caller, in others, the analyzer would need to simulate the entire program to\nverify that the memory is not used anywhere, which is not feasible.\u003c/p\u003e\n\u003cp\u003eFor this technical reason, this rule often ignores escaping pointers.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eAsk yourself whether you need to allocate memory on the heap. If your object is small enough, in many cases allocating it as a local variable on\nthe stack is a better choice as it simplifies memory management.\u003c/p\u003e\n\u003cp\u003eIf you do need to allocate it on the heap, the direct fix for a memory leak is to make sure you always deallocate memory.\u003c/p\u003e\n\u003cp\u003eIn C++ you should use RAII (resource acquisition is initialization) idiom. See \u003ca href\u003d\"#_going_the_extra_mile\"\u003eGoing the extra mile\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eAlternatively, you have to manually make sure that every exit of the scope of the pointer to the allocated memory is prepended by the deallocation\nof that pointer.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nbool fire(Point pos, Direction dir, State const\u0026amp; s) {\n  Bullet *bullet \u003d new Bullet{pos, dir};\n  if (auto affected \u003d bullet-\u0026gt;hitAnyone(s)) {\n    affected-\u0026gt;takeHit();\n    return true; // Noncompliant, the memory pointed to by bullet is not deleted\n  }\n  delete bullet;\n  return false;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eUse a local object\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nbool fire(Point pos, Direction dir, State const\u0026amp; s) {\n  Bullet bullet{pos, dir};\n  if (auto affected \u003d bullet.hitAnyone(s)) {\n    affected-\u0026gt;takeHit();\n    return true; // Compliant: bullet is destroyed and deallocated automatically\n  }\n  return false; // Compliant: bullet is destroyed and deallocated automatically\n}\n\u003c/pre\u003e\n\u003cp\u003eIf you cannot use RAII or a local object, manually make sure memory is freed on every exit of the scope of the pointer.\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\nint fun() {\n  char* name \u003d (char *) malloc (size);\n  if (!name) {\n    return 1;\n  }\n  if (condition()) {\n    return 2; // Noncompliant: memory pointed to by \"name\" has not been released\n  }\n  // ...\n  return 0; // Noncompliant: memory pointed to by \"name\" has not been released\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\nint fun() {\n  char* name \u003d (char *) malloc (size);\n  if (!name) {\n    return 1; // Memory wasn\u0027t allocated, no need to free it\n  }\n  if (condition()) {\n    free(name);\n    return 2; // Compliant: memory is freed\n  }\n  // ...\n  free(name);\n  return 0; // Compliant: memory is freed\n}\n\u003c/pre\u003e\n\u003ch3\u003ePitfalls\u003c/h3\u003e\n\u003cp\u003eNote that the execution can exit the scope in different ways:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003ereturn\u003c/code\u003e from the function \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003ebreak\u003c/code\u003e from a \u003ccode\u003eswitch\u003c/code\u003e statement or a loop \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003egoto\u003c/code\u003e out of a code block (compound statement) \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003ethrow\u003c/code\u003e a C++ exception \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003eco_return\u003c/code\u003e from an C++ coroutine \u003c/li\u003e\n  \u003cli\u003e End of the scope (\u003ccode\u003e}\u003c/code\u003e) \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn the following example, even though the function frees memory before the explicit \u003ccode\u003ereturn\u003c/code\u003e, the memory remains allocated when the\nexecution leaves the \u003ccode\u003ewhile\u003c/code\u003e body via many other ways.\u003c/p\u003e\n\u003cpre\u003e\nvoid fire(Point pos, Direction dir, State const\u0026amp; s) {\n  while (condition()) {\n    Bullet *bullet \u003d new Bullet{pos, dir};\n    if (bullet-\u0026gt;misfired()) break; // Noncompliant: memory is not freed\n    if (!condition()) {\n      delete bullet;\n      return;\n    }\n    // Noncompliant: memory is not freed\n    if (s.tooManyBullets()) throw Exception(\"Too many bullets\");\n    if (bullet-\u0026gt;timeIsUp(s)) goto end; // Noncompliant: memory is not freed\n  } // Noncompliant: at the end of iteration bullet leaks\n\nend: // Memory allocated in the loop is not freed\n  std::cout \u0026lt;\u0026lt;\"Bullet is lost\\n\";\n}\n\u003c/pre\u003e\n\u003cp\u003eThis is why it is very difficult to avoid leaks when managing memory manually.\u003c/p\u003e\n\u003ch3\u003eGoing the extra mile\u003c/h3\u003e\n\u003cp\u003eIn C++, manually allocating and deallocating memory is considered a code smell.\u003c/p\u003e\n\u003cp\u003eIt is recommended to follow the \u003cem\u003eRAII\u003c/em\u003e idiom and create a class that manages the memory by allocating it when the object is constructed and\nfreeing it when it is destroyed. Furthermore, copy and move operations on such objects are designed such that this object can be passed by value\nbetween functions (either as an argument or by being returned) in place of raw pointers.\u003c/p\u003e\n\u003cp\u003eDepending on the type, passing an \u003cem\u003eRAII\u003c/em\u003e object operations may either:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Allocate a new block of memory and copy the elements (\u003ccode\u003estd::vector\u003c/code\u003e). \u003c/li\u003e\n  \u003cli\u003e Transfer ownership of the memory to constructed object (\u003ccode\u003estd::unique_ptr\u003c/code\u003e). \u003c/li\u003e\n  \u003cli\u003e Use shared ownership and free memory when the last object is destroyed (\u003ccode\u003estd::shared_ptr\u003c/code\u003e). \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe RAII object will take care of the deallocation of the memory when it is no longer used.\u003c/p\u003e\n\u003cp\u003eTo correct the noncompliant example, use \u003ccode\u003estd::unique_ptr\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\nbool fire(Point pos, Direction dir, State const\u0026amp; s) {\n  auto bullet \u003d std::make_unique\u0026lt;Bullet\u0026gt;(pos, dir);\n  if (auto affected \u003d bullet-\u0026gt;hitAnything(s)) {\n    affected-\u0026gt;takeHit();\n    return true; // Compliant: unique_ptr\u0026lt;Bullet\u0026gt; automatically frees memory\n  }\n  return false; // Compliant: unique_ptr\u0026lt;Bullet\u0026gt; automatically frees memory\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Wikipedia - \u003ca href\u003d\"https://en.wikipedia.org/wiki/Memory_leak\"\u003eMemory leak\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/raii\"\u003eRAII\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/401\"\u003e401 Improper Release of Memory Before Removing Last Reference (\u0027Memory Leak\u0027)\u003c/a\u003e\n  \u003c/li\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/FtYxBQ\"\u003eMEM00-C. Allocate and free memory in the same module, at the same level of\n  abstraction\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/GNYxBQ\"\u003eMEM31-C. Free dynamically allocated memory when no longer needed\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S5025} discourages manual memory management, which helps to avoid memory leaks. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cert",
      "cwe",
      "denial-of-service",
      "leak",
      "symbolic-execution"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1044",
    "name": "Exception classes should be caught by reference",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eCatching an exception class by value rather than by reference can cause several problems:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Memory is allocated unnecessarily: catching by value creates a copy of the exception object, which is destroyed at the exit of the catch block.\n  \u003c/li\u003e\n  \u003cli\u003e Slicing occurs: the copy will be an instance of the exception base class rather than the potentially more specific exception class initially\n  caught. So it may lead to a loss of precision as any additional data or functionality offered by the subclass will not be accessible. \u003c/li\u003e\n  \u003cli\u003e Copying the exception class may throw an exception, leading to unexpected behavior. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eThis rule raises an issue when an exception is caught by value instead of by reference.\u003c/p\u003e\n\u003cp\u003eIt is also best to avoid catching an exception by pointer (implying throwing by pointer) because it means the catch clause must manage the memory\nheld by the pointer. The rule {rule:cpp:S1035} detects this situation.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\ntry {\n  // ...\n} catch (ExceptionClass ex) { // Noncompliant\n  //...\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\ntry {\n  // ...\n} catch (ExceptionClass \u0026amp;ex) {\n  //...\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/SXs-BQ\"\u003eERR61-CPP. Catch exceptions by lvalue reference\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#e15-throw-by-value-catch-exceptions-from-a-hierarchy-by-reference\"\u003eE.15: Throw by value, catch exceptions from a hierarchy by reference\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 15-3-5 - A class type exception shall always be caught by reference \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S1035} - An exception object should not have a pointer type \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eCatching an exception class by value rather than by reference can cause several problems:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Memory is allocated unnecessarily: catching by value creates a copy of the exception object, which is destroyed at the exit of the catch block.\n  \u003c/li\u003e\n  \u003cli\u003e Slicing occurs: the copy will be an instance of the exception base class rather than the potentially more specific exception class initially\n  caught. So it may lead to a loss of precision as any additional data or functionality offered by the subclass will not be accessible. \u003c/li\u003e\n  \u003cli\u003e Copying the exception class may throw an exception, leading to unexpected behavior. \u003c/li\u003e\n\u003c/ul\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eThis rule raises an issue when an exception is caught by value instead of by reference.\u003c/p\u003e\n\u003cp\u003eIt is also best to avoid catching an exception by pointer (implying throwing by pointer) because it means the catch clause must manage the memory\nheld by the pointer. The rule {rule:cpp:S1035} detects this situation.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\ntry {\n  // ...\n} catch (ExceptionClass ex) { // Noncompliant\n  //...\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\ntry {\n  // ...\n} catch (ExceptionClass \u0026amp;ex) {\n  //...\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/SXs-BQ\"\u003eERR61-CPP. Catch exceptions by lvalue reference\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#e15-throw-by-value-catch-exceptions-from-a-hierarchy-by-reference\"\u003eE.15: Throw by value, catch exceptions from a hierarchy by reference\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 15-3-5 - A class type exception shall always be caught by reference \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S1035} - An exception object should not have a pointer type \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cert",
      "cppcoreguidelines",
      "misra-c++2008"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1045",
    "name": "Handlers in a single try-catch or function-try-block for a derived class and some or all of its bases should be ordered most-derived-first",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eExceptions handlers (\u003ccode\u003ecatch ()\u003c/code\u003e) are evaluated in the order they are written. Once a match is found, the evaluation stops. If there is a\nhandler for a base class followed by a handler for class derived from that base class, the second handler will never trigger: The handler for the base\nclass will match the derived class, and will be the only executed handler. The derived class handler is dead code.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass BaseException { };\nclass DerivedException: public BaseException { };\n\ntry\n{\n  // ...\n}\ncatch ( BaseException \u0026amp;b ) // Will catch DerivedException as well\n{\n  // ...\n}\ncatch ( DerivedException \u0026amp;d ) // Noncompliant, the previous handled effectively hides this one\n{\n  // Any code here will be unreachable,\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nclass BaseException { };\nclass DerivedException: public BaseException { };\n\ntry\n{\n  // ...\n}\ncatch ( DerivedException \u0026amp;d ) // Compliant\n{\n  // ...\n}\ncatch ( BaseException  \u0026amp;b ) // Compliant, will be triggered for BaseException that are not DerivedException\n{\n  // ...\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 15-3-6 \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/Nnw-BQ\"\u003eCERT, ERR54-CPP.\u003c/a\u003e - Catch handlers should order their parameter types from most\n  derived to least derived \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eExceptions handlers (\u003ccode\u003ecatch ()\u003c/code\u003e) are evaluated in the order they are written. Once a match is found, the evaluation stops. If there is a\nhandler for a base class followed by a handler for class derived from that base class, the second handler will never trigger: The handler for the base\nclass will match the derived class, and will be the only executed handler. The derived class handler is dead code.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass BaseException { };\nclass DerivedException: public BaseException { };\n\ntry\n{\n  // ...\n}\ncatch ( BaseException \u0026amp;b ) // Will catch DerivedException as well\n{\n  // ...\n}\ncatch ( DerivedException \u0026amp;d ) // Noncompliant, the previous handled effectively hides this one\n{\n  // Any code here will be unreachable,\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nclass BaseException { };\nclass DerivedException: public BaseException { };\n\ntry\n{\n  // ...\n}\ncatch ( DerivedException \u0026amp;d ) // Compliant\n{\n  // ...\n}\ncatch ( BaseException  \u0026amp;b ) // Compliant, will be triggered for BaseException that are not DerivedException\n{\n  // ...\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 15-3-6 \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/Nnw-BQ\"\u003eCERT, ERR54-CPP.\u003c/a\u003e - Catch handlers should order their parameter types from most\n  derived to least derived \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cert",
      "misra-c++2008"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S3222",
    "name": "Label names should comply with a naming convention",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "IDENTIFIABLE",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eShared coding conventions allow teams to collaborate effectively. This rule checks that labels match a provided regular expression.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cp\u003eWith default provided regular expression \u003ccode\u003e^[A-Z][A-Z0-9_]*$\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\nexit:  // Noncompliant\n  doCleanup();\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nEXIT:  // Compliant\n  doCleanup();\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eShared coding conventions allow teams to collaborate effectively. This rule checks that labels match a provided regular expression.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cp\u003eWith default provided regular expression \u003ccode\u003e^[A-Z][A-Z0-9_]*$\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\nexit:  // Noncompliant\n  doCleanup();\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nEXIT:  // Compliant\n  doCleanup();\n\u003c/pre\u003e"
      }
    ],
    "params": {
      "format": {
        "key": "format",
        "name": "format",
        "description": "POSIX regular expression used to check the label names against.",
        "defaultValue": "^[A-Z][A-Z0-9_]*$",
        "type": "STRING",
        "multiple": false,
        "possibleValues": []
      }
    },
    "defaultParams": {
      "format": "^[A-Z][A-Z0-9_]*$"
    },
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "convention"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1046",
    "name": "Condition-specific \"catch\" handlers should not be used after the ellipsis (catch-all) handler",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe catch-all handler, written \u003ccode\u003ecatch(...)\u003c/code\u003e in C++, or \u003ccode\u003e@catch(...)\u003c/code\u003e in Objective-C, catches every type of exception. If\nthere is another catch statement for a specific exception after the catch-all handler, it will not be executed because the catch-all handler will\nalready have handled the exception.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003cp\u003eThe following C++ example is similar in Objective-C: the \u003ccode\u003etry\u003c/code\u003e and \u003ccode\u003ecatch\u003c/code\u003e equivalents are \u003ccode\u003e@try\u003c/code\u003e and\n\u003ccode\u003e@catch\u003c/code\u003e.\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre\u003e\nvoid f() {\n  try {\n    // ...\n  } catch (...) {\n    // Handle all exception types\n  } catch (std::exception const \u0026amp;e) { // Noncompliant: it will never be called\n  }\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre\u003e\nvoid f() {\n  try {\n    // ...\n  } catch (std::exception const \u0026amp;e) {\n    // Handle standard exceptions\n  } catch (...) { // Compliant: handle all other exception types\n  }\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/try_catch\"\u003etry-block\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e Apple Developer Documentation - \u003ca\n  href\u003d\"https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Exceptions/Tasks/HandlingExceptions.html\"\u003eObjective-C: Handling\n  Exceptions\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 15-3-7 - Where multiple handlers are provided in a single try-catch statement or function-try-block, any ellipsis (catch-all)\n  handler shall occur last. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe catch-all handler, written \u003ccode\u003ecatch(...)\u003c/code\u003e in C++, or \u003ccode\u003e@catch(...)\u003c/code\u003e in Objective-C, catches every type of exception. If\nthere is another catch statement for a specific exception after the catch-all handler, it will not be executed because the catch-all handler will\nalready have handled the exception.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eThe following C++ example is similar in Objective-C: the \u003ccode\u003etry\u003c/code\u003e and \u003ccode\u003ecatch\u003c/code\u003e equivalents are \u003ccode\u003e@try\u003c/code\u003e and\n\u003ccode\u003e@catch\u003c/code\u003e.\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre\u003e\nvoid f() {\n  try {\n    // ...\n  } catch (...) {\n    // Handle all exception types\n  } catch (std::exception const \u0026amp;e) { // Noncompliant: it will never be called\n  }\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre\u003e\nvoid f() {\n  try {\n    // ...\n  } catch (std::exception const \u0026amp;e) {\n    // Handle standard exceptions\n  } catch (...) { // Compliant: handle all other exception types\n  }\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/try_catch\"\u003etry-block\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e Apple Developer Documentation - \u003ca\n  href\u003d\"https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Exceptions/Tasks/HandlingExceptions.html\"\u003eObjective-C: Handling\n  Exceptions\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 15-3-7 - Where multiple handlers are provided in a single try-catch statement or function-try-block, any ellipsis (catch-all)\n  handler shall occur last. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "misra-c++2008",
      "unused"
    ],
    "deprecatedKeys": [
      "cpp:EllipsisHandlerNotLast"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S3588",
    "name": "Closed resources should not be accessed",
    "defaultSeverity": "BLOCKER",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003cp\u003eUsing the value of a pointer to a \u003ccode\u003eFILE\u003c/code\u003e object after the associated file is closed is undefined behavior.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eOnce a file has been closed, its corresponding \u003ccode\u003eFILE*\u003c/code\u003e typed variable becomes invalid and the stream may no longer be accessed through\nthis variable. In particular, a pointer to a \u003ccode\u003eFILE\u003c/code\u003e object may not be passed to \u003ccode\u003efclose\u003c/code\u003e more than once.\u003c/p\u003e\n\u003cp\u003eUsing the value of a pointer to a \u003ccode\u003eFILE\u003c/code\u003e object after the associated file is closed results in undefined behavior.\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n\nint process_file(int print) {\n  FILE *f \u003d fopen(\"example.txt\", \"r\");\n  if (!f) {\n    perror(\"fopen() failed\");\n    return 1;\n  }\n\n  if (print) {\n    char buffer[256];\n    while (fgets(buffer, 256, f)) {\n      printf(\"%s\", buffer);\n    }\n    fclose(f);\n  }\n\n  // Further processing ...\n\n  fclose(f); // Noncompliant: file associated with `f` might already be closed.\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch2\u003eWhat is the potential impact?\u003c/h2\u003e\n\u003cp\u003eIf a pointer to a \u003ccode\u003eFILE\u003c/code\u003e object is used after the associated file is closed, the behavior of the application is undefined.\u003c/p\u003e\n\u003cp\u003eWhen a program comprises undefined behavior, the compiler no longer needs to adhere to the language standard, and the program has no meaning\nassigned to it. The application might just crash, but in the worst case, the application may appear to execute correctly, while losing data or\nproducing incorrect results.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eDo not use the value of a pointer to a \u003ccode\u003eFILE\u003c/code\u003e object after the associated file has been closed.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n\nint process_file(int print) {\n  FILE *f \u003d fopen(\"example.txt\", \"r\");\n  if (!f) {\n    perror(\"fopen() failed\");\n    return 1;\n  }\n\n  if (print) {\n    char buffer[256];\n    while (fgets(buffer, 256, f)) {\n      printf(\"%s\", buffer);\n    }\n    fclose(f);\n  }\n\n  fclose(f); // Noncompliant: file associated with `f` might already be closed.\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n\nint process_file(int print) {\n  FILE *f \u003d fopen(\"example.txt\", \"r\");\n  if (!f) {\n    perror(\"fopen() failed\");\n    return 1;\n  }\n\n  if (print) {\n    char buffer[256];\n    while (fgets(buffer, 256, f)) {\n      printf(\"%s\", buffer);\n    }\n  }\n\n  if (fclose(f) \u003d\u003d EOF) { // Compliant: file associated with `f` is closed only once.\n    return 1;\n  }\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch3\u003eGoing the extra mile\u003c/h3\u003e\n\u003cp\u003eUsing C++\u0027s \u003cem\u003eRAII\u003c/em\u003e idiom can mitigate these \"double-close\" issues.\u003c/p\u003e\n\u003cp\u003eFollowing this idiom, one would create a class that manages the underlying file by opening it when the object is constructed and closing it when\nthe object is destroyed, effectively using a constructor-destructor pair as a \"do-undo\"-mechanism.\u003c/p\u003e\n\u003cp\u003eAn exemplary class that manages a pointer to a file is shown in what follows.\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;cstdio\u0026gt;\n#include \u0026lt;fstream\u0026gt;\n#include \u0026lt;string\u0026gt;\n#include \u0026lt;utility\u0026gt;\n\n// Although `std::fstream` should be preferred, if available, a file stream\n// managed by this `File` class cannot suffer from \"double-close\" issues.\nclass File {\n  FILE *f;\n\npublic:\n  // Opens file stream on construction.\n  File(std::string const \u0026amp;path, std::string const \u0026amp;modes)\n      : f(fopen(path.c_str(), modes.c_str())) {\n    if (!f) {\n      throw std::ios_base::failure(\"fopen() failed\");\n    }\n  }\n  // Will close the file stream upon destruction.\n  ~File() {\n    // Here we are fine with `std::terminate` being called here in case `close`\n    // throws and exception.\n    close();\n  }\n  // Allow only one owner of a file, disallow copy operations.\n  File(const File \u0026amp;other) \u003d delete;\n  File \u0026amp;operator\u003d(const File \u0026amp;other) \u003d delete;\n  // Moving a file to a different scope shall be allowed.\n  File(File \u0026amp;\u0026amp;other) : f(std::exchange(other.f, nullptr)) {}\n  File \u0026amp;operator\u003d(File \u0026amp;\u0026amp;other) {\n    if (this !\u003d \u0026amp;other) {\n      // In case of non-self-assignment, close the currently managed file and\n      // \"steal\" the other\u0027s file.\n      close();\n      f \u003d std::exchange(other.f, nullptr);\n    }\n    return *this;\n  }\n  // Allow file to be closed explicitly.\n  void close() {\n    if (f !\u003d nullptr \u0026amp;\u0026amp; fclose(std::exchange(f, nullptr)) \u003d\u003d EOF) {\n      throw std::ios_base::failure(\"fclose() failed\");\n    }\n  }\n  // Allow access to underlying file via `f`.\n  FILE *handle() { return f; }\n  // Release `f`, i.e., stop managing it.\n  FILE *release() { return std::exchange(f, nullptr); }\n};\n\nvoid file_user() {\n  File fh{\"example.txt\", \"r\"};\n  FILE *f \u003d fh.handle();\n  // Use `f` for the desired file operation(s).\n  //\n  // The file stream managed by `fh` will be automatically closed when `fh` goes\n  // out of scope at the end of this function.\n}\n\u003c/pre\u003e\n\u003cp\u003eWith the design shown above, it is still possible to \"double-close\" a file by passing the raw \u003ccode\u003eFILE\u003c/code\u003e pointer obtained by a call to\n\u003ccode\u003eFile::handle\u003c/code\u003e to \u003ccode\u003efclose\u003c/code\u003e (e.g. \u003ccode\u003efclose(f.handle())\u003c/code\u003e). However, this design reduces the risk of such occurrence by\neliminating the need for manually closing files. If even the reduced possibility of \"double-close\" is still a concern, the function member\n\u003ccode\u003eFile::handle\u003c/code\u003e should be removed and any required file operations should be wrapped by the \u003ccode\u003eFile\u003c/code\u003e class.\u003c/p\u003e\n\u003cp\u003eIf falling back to low-level file operations is not necessary, one should prefer \u003ccode\u003estd::fstream\u003c/code\u003e.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/QdUxBQ\"\u003eFIO46-C. Do not access a closed file\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S3520} addresses \"double-free\" memory issues \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eUsing the value of a pointer to a \u003ccode\u003eFILE\u003c/code\u003e object after the associated file is closed is undefined behavior.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eOnce a file has been closed, its corresponding \u003ccode\u003eFILE*\u003c/code\u003e typed variable becomes invalid and the stream may no longer be accessed through\nthis variable. In particular, a pointer to a \u003ccode\u003eFILE\u003c/code\u003e object may not be passed to \u003ccode\u003efclose\u003c/code\u003e more than once.\u003c/p\u003e\n\u003cp\u003eUsing the value of a pointer to a \u003ccode\u003eFILE\u003c/code\u003e object after the associated file is closed results in undefined behavior.\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n\nint process_file(int print) {\n  FILE *f \u003d fopen(\"example.txt\", \"r\");\n  if (!f) {\n    perror(\"fopen() failed\");\n    return 1;\n  }\n\n  if (print) {\n    char buffer[256];\n    while (fgets(buffer, 256, f)) {\n      printf(\"%s\", buffer);\n    }\n    fclose(f);\n  }\n\n  // Further processing ...\n\n  fclose(f); // Noncompliant: file associated with `f` might already be closed.\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch2\u003eWhat is the potential impact?\u003c/h2\u003e\n\u003cp\u003eIf a pointer to a \u003ccode\u003eFILE\u003c/code\u003e object is used after the associated file is closed, the behavior of the application is undefined.\u003c/p\u003e\n\u003cp\u003eWhen a program comprises undefined behavior, the compiler no longer needs to adhere to the language standard, and the program has no meaning\nassigned to it. The application might just crash, but in the worst case, the application may appear to execute correctly, while losing data or\nproducing incorrect results.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eDo not use the value of a pointer to a \u003ccode\u003eFILE\u003c/code\u003e object after the associated file has been closed.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n\nint process_file(int print) {\n  FILE *f \u003d fopen(\"example.txt\", \"r\");\n  if (!f) {\n    perror(\"fopen() failed\");\n    return 1;\n  }\n\n  if (print) {\n    char buffer[256];\n    while (fgets(buffer, 256, f)) {\n      printf(\"%s\", buffer);\n    }\n    fclose(f);\n  }\n\n  fclose(f); // Noncompliant: file associated with `f` might already be closed.\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n\nint process_file(int print) {\n  FILE *f \u003d fopen(\"example.txt\", \"r\");\n  if (!f) {\n    perror(\"fopen() failed\");\n    return 1;\n  }\n\n  if (print) {\n    char buffer[256];\n    while (fgets(buffer, 256, f)) {\n      printf(\"%s\", buffer);\n    }\n  }\n\n  if (fclose(f) \u003d\u003d EOF) { // Compliant: file associated with `f` is closed only once.\n    return 1;\n  }\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch3\u003eGoing the extra mile\u003c/h3\u003e\n\u003cp\u003eUsing C++\u0027s \u003cem\u003eRAII\u003c/em\u003e idiom can mitigate these \"double-close\" issues.\u003c/p\u003e\n\u003cp\u003eFollowing this idiom, one would create a class that manages the underlying file by opening it when the object is constructed and closing it when\nthe object is destroyed, effectively using a constructor-destructor pair as a \"do-undo\"-mechanism.\u003c/p\u003e\n\u003cp\u003eAn exemplary class that manages a pointer to a file is shown in what follows.\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;cstdio\u0026gt;\n#include \u0026lt;fstream\u0026gt;\n#include \u0026lt;string\u0026gt;\n#include \u0026lt;utility\u0026gt;\n\n// Although `std::fstream` should be preferred, if available, a file stream\n// managed by this `File` class cannot suffer from \"double-close\" issues.\nclass File {\n  FILE *f;\n\npublic:\n  // Opens file stream on construction.\n  File(std::string const \u0026amp;path, std::string const \u0026amp;modes)\n      : f(fopen(path.c_str(), modes.c_str())) {\n    if (!f) {\n      throw std::ios_base::failure(\"fopen() failed\");\n    }\n  }\n  // Will close the file stream upon destruction.\n  ~File() {\n    // Here we are fine with `std::terminate` being called here in case `close`\n    // throws and exception.\n    close();\n  }\n  // Allow only one owner of a file, disallow copy operations.\n  File(const File \u0026amp;other) \u003d delete;\n  File \u0026amp;operator\u003d(const File \u0026amp;other) \u003d delete;\n  // Moving a file to a different scope shall be allowed.\n  File(File \u0026amp;\u0026amp;other) : f(std::exchange(other.f, nullptr)) {}\n  File \u0026amp;operator\u003d(File \u0026amp;\u0026amp;other) {\n    if (this !\u003d \u0026amp;other) {\n      // In case of non-self-assignment, close the currently managed file and\n      // \"steal\" the other\u0027s file.\n      close();\n      f \u003d std::exchange(other.f, nullptr);\n    }\n    return *this;\n  }\n  // Allow file to be closed explicitly.\n  void close() {\n    if (f !\u003d nullptr \u0026amp;\u0026amp; fclose(std::exchange(f, nullptr)) \u003d\u003d EOF) {\n      throw std::ios_base::failure(\"fclose() failed\");\n    }\n  }\n  // Allow access to underlying file via `f`.\n  FILE *handle() { return f; }\n  // Release `f`, i.e., stop managing it.\n  FILE *release() { return std::exchange(f, nullptr); }\n};\n\nvoid file_user() {\n  File fh{\"example.txt\", \"r\"};\n  FILE *f \u003d fh.handle();\n  // Use `f` for the desired file operation(s).\n  //\n  // The file stream managed by `fh` will be automatically closed when `fh` goes\n  // out of scope at the end of this function.\n}\n\u003c/pre\u003e\n\u003cp\u003eWith the design shown above, it is still possible to \"double-close\" a file by passing the raw \u003ccode\u003eFILE\u003c/code\u003e pointer obtained by a call to\n\u003ccode\u003eFile::handle\u003c/code\u003e to \u003ccode\u003efclose\u003c/code\u003e (e.g. \u003ccode\u003efclose(f.handle())\u003c/code\u003e). However, this design reduces the risk of such occurrence by\neliminating the need for manually closing files. If even the reduced possibility of \"double-close\" is still a concern, the function member\n\u003ccode\u003eFile::handle\u003c/code\u003e should be removed and any required file operations should be wrapped by the \u003ccode\u003eFile\u003c/code\u003e class.\u003c/p\u003e\n\u003cp\u003eIf falling back to low-level file operations is not necessary, one should prefer \u003ccode\u003estd::fstream\u003c/code\u003e.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/QdUxBQ\"\u003eFIO46-C. Do not access a closed file\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S3520} addresses \"double-free\" memory issues \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cert",
      "symbolic-execution"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5404",
    "name": "A call to \"wait()\" on a \"std::condition_variable\" should have a condition",
    "defaultSeverity": "BLOCKER",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eA \u003ccode\u003econdition variable\u003c/code\u003e\u0026nbsp;is a synchronization primitive that can be used to block a thread, or multiple threads at the same time,\nuntil another thread both modifies a shared variable (the\u0026nbsp;\u003cem\u003econdition\u003c/em\u003e), and notifies the \u003ccode\u003econdition variable\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eWaiting for a \u003ccode\u003econdition variable\u003c/code\u003e\u0026nbsp;without a \u003cem\u003econdition\u003c/em\u003e can lead to spurious wake-ups or to wait forever.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;thread\u0026gt;\n#include \u0026lt;condition_variable\u0026gt;\n\nstd::mutex mutex;\nstd::condition_variable condVar;\n\nvoid consumer() {\n  std::cout \u0026lt;\u0026lt; \"Waiting for work\" \u0026lt;\u0026lt; std::endl;\n  std::unique_lock\u0026lt;std::mutex\u0026gt; lck(mutex);\n  condVar.wait(lck); // noncompliant: can wait forever as the order between t1 and t2 is not guaranteed\n  std::cout \u0026lt;\u0026lt; \"Doing some work\" \u0026lt;\u0026lt; std::endl;\n}\n\nvoid producer() {\n  std::cout \u0026lt;\u0026lt; \"Work submited\" \u0026lt;\u0026lt; std::endl;\n  condVar.notify_one(); // this can be executed before or after the wait in consumer, no guarantee\n}\n\nint main() {\n  std::thread t1(consumer);\n  std::thread t2(producer);\n\n  t1.join();\n  t2.join();\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;thread\u0026gt;\n#include \u0026lt;condition_variable\u0026gt;\n\nstd::mutex mutex;\nstd::condition_variable condVar;\n\nbool pendingWork{false};\n\nvoid consumer() {\n  std::cout \u0026lt;\u0026lt; \"Waiting for work\" \u0026lt;\u0026lt; std::endl;\n  std::unique_lock\u0026lt;std::mutex\u0026gt; lck(mutex);\n  condVar.wait(lck, []{ return pendingWork; }); // compliant: if this is called after producer in t2, the call will not block thanks to the condition\n  std::cout \u0026lt;\u0026lt; \"Doing some work\" \u0026lt;\u0026lt; std::endl;\n}\n\nvoid producer() {\n  {\n    std::lock_guard\u0026lt;std::mutex\u0026gt; lck(mutex);\n    pendingWork \u003d true;\n  }\n  std::cout \u0026lt;\u0026lt; \"Work submitted\" \u0026lt;\u0026lt; std::endl;\n  condVar.notify_one();\n}\n\nint main(){\n  std::thread t1(consumer);\n  std::thread t2(producer);\n\n  t1.join();\n  t2.join();\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://www.modernescpp.com/index.php/c-core-guidelines-be-aware-of-the-traps-of-condition-variables\"\u003eThe traps of condition\n  variables\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#cp42-dont-wait-without-a-condition\"\u003eCP.42: Don’t\n  \u003ccode\u003ewait\u003c/code\u003e without a condition\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eA \u003ccode\u003econdition variable\u003c/code\u003e\u0026nbsp;is a synchronization primitive that can be used to block a thread, or multiple threads at the same time,\nuntil another thread both modifies a shared variable (the\u0026nbsp;\u003cem\u003econdition\u003c/em\u003e), and notifies the \u003ccode\u003econdition variable\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eWaiting for a \u003ccode\u003econdition variable\u003c/code\u003e\u0026nbsp;without a \u003cem\u003econdition\u003c/em\u003e can lead to spurious wake-ups or to wait forever.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;thread\u0026gt;\n#include \u0026lt;condition_variable\u0026gt;\n\nstd::mutex mutex;\nstd::condition_variable condVar;\n\nvoid consumer() {\n  std::cout \u0026lt;\u0026lt; \"Waiting for work\" \u0026lt;\u0026lt; std::endl;\n  std::unique_lock\u0026lt;std::mutex\u0026gt; lck(mutex);\n  condVar.wait(lck); // noncompliant: can wait forever as the order between t1 and t2 is not guaranteed\n  std::cout \u0026lt;\u0026lt; \"Doing some work\" \u0026lt;\u0026lt; std::endl;\n}\n\nvoid producer() {\n  std::cout \u0026lt;\u0026lt; \"Work submited\" \u0026lt;\u0026lt; std::endl;\n  condVar.notify_one(); // this can be executed before or after the wait in consumer, no guarantee\n}\n\nint main() {\n  std::thread t1(consumer);\n  std::thread t2(producer);\n\n  t1.join();\n  t2.join();\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;iostream\u0026gt;\n#include \u0026lt;thread\u0026gt;\n#include \u0026lt;condition_variable\u0026gt;\n\nstd::mutex mutex;\nstd::condition_variable condVar;\n\nbool pendingWork{false};\n\nvoid consumer() {\n  std::cout \u0026lt;\u0026lt; \"Waiting for work\" \u0026lt;\u0026lt; std::endl;\n  std::unique_lock\u0026lt;std::mutex\u0026gt; lck(mutex);\n  condVar.wait(lck, []{ return pendingWork; }); // compliant: if this is called after producer in t2, the call will not block thanks to the condition\n  std::cout \u0026lt;\u0026lt; \"Doing some work\" \u0026lt;\u0026lt; std::endl;\n}\n\nvoid producer() {\n  {\n    std::lock_guard\u0026lt;std::mutex\u0026gt; lck(mutex);\n    pendingWork \u003d true;\n  }\n  std::cout \u0026lt;\u0026lt; \"Work submitted\" \u0026lt;\u0026lt; std::endl;\n  condVar.notify_one();\n}\n\nint main(){\n  std::thread t1(consumer);\n  std::thread t2(producer);\n\n  t1.join();\n  t2.join();\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://www.modernescpp.com/index.php/c-core-guidelines-be-aware-of-the-traps-of-condition-variables\"\u003eThe traps of condition\n  variables\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#cp42-dont-wait-without-a-condition\"\u003eCP.42: Don’t\n  \u003ccode\u003ewait\u003c/code\u003e without a condition\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cppcoreguidelines",
      "pitfall",
      "since-c++11",
      "unpredictable"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1048",
    "name": "Destructors should not throw exceptions",
    "defaultSeverity": "CRITICAL",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThrowing an exception from a destructor may result in a call to \u003ccode\u003estd::terminate\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eBy default, compilers implicitly declare destructors as \u003ccode\u003enoexcept\u003c/code\u003e, so \u003ccode\u003estd::terminate\u003c/code\u003e is called when they exit with an\nexception. Destructors may still propagate an exception if they are explicitly declared as \u003ccode\u003enoexcept(false)\u003c/code\u003e. However, even a destructor\ndeclared as \u003ccode\u003enoexcept(false)\u003c/code\u003e calls \u003ccode\u003estd::terminate\u003c/code\u003e when it throws during stack unwinding.\u003c/p\u003e\n\u003cp\u003eThe following example illustrates the severity of the underlying problem:\u003c/p\u003e\n\u003cp\u003eThe destructor of a container needs to call the destructors for all managed objects. Suppose a call to an object’s destructor throws an exception.\nIn that case, there are only two \u003cem\u003econceptual\u003c/em\u003e ways to proceed:\u003c/p\u003e\n\u003col\u003e\n  \u003cli\u003e Abort the destruction. This results in a partially destroyed object and possibly many more objects whose destructors are never called. \u003c/li\u003e\n  \u003cli\u003e Ignore the exception and proceed with destroying the remaining objects. However, this potentially results in more partially destroyed objects\n  if further destructors throw an exception. \u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eBecause both options are undesired, destructors should never \u003ccode\u003ethrow\u003c/code\u003e exceptions.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eIn most cases, throwing exceptions in destructors makes the program unreliable:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e If \u003ccode\u003estd::terminate\u003c/code\u003e is called, the program terminates in an implementation-defined, abrupt, and unclean manner. \u003c/li\u003e\n  \u003cli\u003e The program’s behavior is undefined if a standard library component (a container, an algorithm, …​) manages a user-defined object that throws\n  an exception from its destructor. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eThis rule raises an issue when an exception is thrown from within a destructor or from a function transitively called by a destructor.\u003c/p\u003e\n\u003cp\u003eSuch an exception should be caught and handled before the destructor exits.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cp\u003eIn the following example, an exception is thrown inside the \u003ccode\u003eBuilder\u003c/code\u003e destructor when calling \u003ccode\u003estd::optional::value\u003c/code\u003e on an\nempty optional. It follows that the program abruptly terminates when \u003ccode\u003eb\u003c/code\u003e gets destroyed during stack unwinding in\n\u003ccode\u003eapplication()\u003c/code\u003e if the user name lookup fails.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid logBuilderDestruction(int userId);\n\nclass Builder {\n  std::optional\u0026lt;int\u0026gt; _id;\n\n public:\n  void setId(int userId) { _id \u003d userId; }\n\n  ~Builder() {\n    auto userId \u003d _id.value(); // Noncompliant: may throw std::bad_optional_access\n    logBuilderDestruction(userId);\n  }\n};\n\nstd::unordered_map\u0026lt;std::string, int\u0026gt;\u0026amp; getDatabase();\n\nint lookupUserId(std::string const\u0026amp; name) {\n  return getDatabase().at(name); // May throw std::out_of_range.\n}\n\nvoid application(std::string const\u0026amp; name) {\n  Builder b;\n  b.setId(lookupUserId(name));\n  // lookupUserId throws an exception when the name is unknown.\n  // This causes the stack to unwind: local variables alive at\n  // this point, such a \"b\", are destroyed. This happens before\n  // the invocation of \"b.setId()\" so \"b._id\" is still empty\n  // when its destructor is executed.\n\n  // ...\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eThe solution below uses \u003ccode\u003estd::optional::value_or\u003c/code\u003e to ensure no exceptions are thrown from the destructor.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid logBuilderDestruction(int userId);\n\nclass Builder {\n  std::optional\u0026lt;int\u0026gt; _id;\n\n public:\n  void setId(int userId) { _id \u003d userId; }\n\n  ~Builder() {\n    auto userId \u003d _id.value_or(-1); // Compliant: never throws.\n    logBuilderDestruction(userId);\n  }\n};\n\nstd::unordered_map\u0026lt;std::string, int\u0026gt;\u0026amp; getDatabase();\n\nint lookupUserId(std::string const\u0026amp; name) {\n  return getDatabase().at(name); // May throw std::out_of_range.\n}\n\nvoid application(std::string const\u0026amp; name) {\n  Builder b;\n  b.setId(lookupUserId(name));\n  // lookupUserId throws an exception when the name is unknown.\n  // This causes the stack to unwind: local variables alive at\n  // this point, such a \"b\", are destroyed. This happens before\n  // the invocation of \"b.setId()\" so \"b._id\" is still empty\n  // when its destructor is executed.\n\n  // ...\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cp\u003eHow to deal with exceptions in destructors highly depends on the application. Below, we present another way to solve the issue with an RAII-based\nclass representing a temporary directory.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\n// Delete the given directory; throws OSException on failure.\nvoid deleteDirectory(Path path) noexcept(false) {\n  // ...\n}\n\nclass TemporaryDirectory {\n  Path tmp;\n\npublic:\n  TemporaryDirectory(); // Create a new temporary directory.\n\n  TemporaryDirectory(TemporaryDirectory const\u0026amp;) \u003d delete;\n  TemporaryDirectory(TemporaryDirectory\u0026amp;\u0026amp;) \u003d delete;\n  TemporaryDirectory\u0026amp; operator\u003d(TemporaryDirectory const\u0026amp;) \u003d delete;\n  TemporaryDirectory\u0026amp; operator\u003d(TemporaryDirectory\u0026amp;\u0026amp;) \u003d delete;\n\n  ~TemporaryDirectory() {\n    deleteDirectory(tmp); // Noncompliant: may throw.\n  }\n};\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eDepending on the use case for those temporary directories, applying some remedial actions to avoid leaking secrets may be essential. Yet, it may be\nreasonable to simply log and silence the exception, for example, in the context of unit tests.\u003c/p\u003e\n\u003cp\u003eIt is possible to redesign the class:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Add a \u003ccode\u003eremove\u003c/code\u003e member function for scenarios that must carefully and reliably handle any \u003ccode\u003eOSException\u003c/code\u003e. In sensitive\n  contexts, the application should not solely rely on the destructor. \u003c/li\u003e\n  \u003cli\u003e Call this \u003ccode\u003eremove\u003c/code\u003e function from the destructor and catch any exception. This preserves the original class intent: an attempt to\n  delete the directory is made. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\n// Delete the given directory; throws OSException on failure.\nvoid deleteDirectory(Path path) noexcept(false) {\n  // ...\n}\n\nclass TemporaryDirectory {\n  Path tmp;\n\npublic:\n  TemporaryDirectory(); // Create a new temporary directory.\n\n  TemporaryDirectory(TemporaryDirectory const\u0026amp;) \u003d delete;\n  TemporaryDirectory(TemporaryDirectory\u0026amp;\u0026amp;) \u003d delete;\n  TemporaryDirectory\u0026amp; operator\u003d(TemporaryDirectory const\u0026amp;) \u003d delete;\n  TemporaryDirectory\u0026amp; operator\u003d(TemporaryDirectory\u0026amp;\u0026amp;) \u003d delete;\n\n  void remove() { deleteDirectory(tmp); }\n\n  ~TemporaryDirectory() {\n    try {\n      remove();\n    } catch (OSException const\u0026amp; e) {\n      logFailureToRemoveDirectory(e);\n    }\n  }\n};\n\u003c/pre\u003e\n\u003ch3\u003ePitfalls\u003c/h3\u003e\n\u003cp\u003eUsing a \u003cem\u003efunction-try-block\u003c/em\u003e in a destructor does not prevent the destructor from exiting with an exception.\u003c/p\u003e\n\u003cp\u003eFor example, the following destructor does not prevent the exception from escaping.\u003c/p\u003e\n\u003cpre\u003e\n~TemporaryDirectory() try {\n  remove();\n} catch (OSException const\u0026amp; e) {\n  logFailureToRemoveDirectory(e);\n}\n// `e` is automatically rethrow as if `throw;` was used.\n\u003c/pre\u003e\n\u003cp\u003eInstead, a \u003cem\u003etry-block\u003c/em\u003e should be used within the destructor’s body.\u003c/p\u003e\n\u003ch3\u003eGoing the extra mile\u003c/h3\u003e\n\u003cp\u003eIt is possible to detect whether a destructor is executed during stack unwinding and act accordingly; for example, to implement a transaction\nrollback action.\u003c/p\u003e\n\u003cp\u003eThe C++17 \u003ca href\u003d\"https://en.cppreference.com/w/cpp/error/uncaught_exception\"\u003e\u003ccode\u003estd::uncaught_exceptions\u003c/code\u003e\u003c/a\u003e function can be used for\nthis purpose, as explained in \u003ca href\u003d\"https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4152.pdf\"\u003eN4152\u003c/a\u003e. This function ends with an\n\u003ccode\u003es\u003c/code\u003e and should not be confused with \u003ccode\u003estd::uncaught_exception\u003c/code\u003e, which got removed in C++20 for the reasons exposed in the\npaper.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/function-try-block\"\u003efunction-try-block\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c36-a-destructor-must-not-fail\"\u003eC.36: A destructor must not\n  fail\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c37-make-destructors-noexcept\"\u003eC.37: Make destructors\n  \u003ccode\u003enoexcept\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 15-5-1 - A class destructor shall not exit with an exception. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S3654} - Destructors should be \"noexcept\" \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThrowing an exception from a destructor may result in a call to \u003ccode\u003estd::terminate\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eBy default, compilers implicitly declare destructors as \u003ccode\u003enoexcept\u003c/code\u003e, so \u003ccode\u003estd::terminate\u003c/code\u003e is called when they exit with an\nexception. Destructors may still propagate an exception if they are explicitly declared as \u003ccode\u003enoexcept(false)\u003c/code\u003e. However, even a destructor\ndeclared as \u003ccode\u003enoexcept(false)\u003c/code\u003e calls \u003ccode\u003estd::terminate\u003c/code\u003e when it throws during stack unwinding.\u003c/p\u003e\n\u003cp\u003eThe following example illustrates the severity of the underlying problem:\u003c/p\u003e\n\u003cp\u003eThe destructor of a container needs to call the destructors for all managed objects. Suppose a call to an object’s destructor throws an exception.\nIn that case, there are only two \u003cem\u003econceptual\u003c/em\u003e ways to proceed:\u003c/p\u003e\n\u003col\u003e\n  \u003cli\u003e Abort the destruction. This results in a partially destroyed object and possibly many more objects whose destructors are never called. \u003c/li\u003e\n  \u003cli\u003e Ignore the exception and proceed with destroying the remaining objects. However, this potentially results in more partially destroyed objects\n  if further destructors throw an exception. \u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eBecause both options are undesired, destructors should never \u003ccode\u003ethrow\u003c/code\u003e exceptions.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eIn most cases, throwing exceptions in destructors makes the program unreliable:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e If \u003ccode\u003estd::terminate\u003c/code\u003e is called, the program terminates in an implementation-defined, abrupt, and unclean manner. \u003c/li\u003e\n  \u003cli\u003e The program’s behavior is undefined if a standard library component (a container, an algorithm, …​) manages a user-defined object that throws\n  an exception from its destructor. \u003c/li\u003e\n\u003c/ul\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eThis rule raises an issue when an exception is thrown from within a destructor or from a function transitively called by a destructor.\u003c/p\u003e\n\u003cp\u003eSuch an exception should be caught and handled before the destructor exits.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cp\u003eIn the following example, an exception is thrown inside the \u003ccode\u003eBuilder\u003c/code\u003e destructor when calling \u003ccode\u003estd::optional::value\u003c/code\u003e on an\nempty optional. It follows that the program abruptly terminates when \u003ccode\u003eb\u003c/code\u003e gets destroyed during stack unwinding in\n\u003ccode\u003eapplication()\u003c/code\u003e if the user name lookup fails.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid logBuilderDestruction(int userId);\n\nclass Builder {\n  std::optional\u0026lt;int\u0026gt; _id;\n\n public:\n  void setId(int userId) { _id \u003d userId; }\n\n  ~Builder() {\n    auto userId \u003d _id.value(); // Noncompliant: may throw std::bad_optional_access\n    logBuilderDestruction(userId);\n  }\n};\n\nstd::unordered_map\u0026lt;std::string, int\u0026gt;\u0026amp; getDatabase();\n\nint lookupUserId(std::string const\u0026amp; name) {\n  return getDatabase().at(name); // May throw std::out_of_range.\n}\n\nvoid application(std::string const\u0026amp; name) {\n  Builder b;\n  b.setId(lookupUserId(name));\n  // lookupUserId throws an exception when the name is unknown.\n  // This causes the stack to unwind: local variables alive at\n  // this point, such a \"b\", are destroyed. This happens before\n  // the invocation of \"b.setId()\" so \"b._id\" is still empty\n  // when its destructor is executed.\n\n  // ...\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eThe solution below uses \u003ccode\u003estd::optional::value_or\u003c/code\u003e to ensure no exceptions are thrown from the destructor.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid logBuilderDestruction(int userId);\n\nclass Builder {\n  std::optional\u0026lt;int\u0026gt; _id;\n\n public:\n  void setId(int userId) { _id \u003d userId; }\n\n  ~Builder() {\n    auto userId \u003d _id.value_or(-1); // Compliant: never throws.\n    logBuilderDestruction(userId);\n  }\n};\n\nstd::unordered_map\u0026lt;std::string, int\u0026gt;\u0026amp; getDatabase();\n\nint lookupUserId(std::string const\u0026amp; name) {\n  return getDatabase().at(name); // May throw std::out_of_range.\n}\n\nvoid application(std::string const\u0026amp; name) {\n  Builder b;\n  b.setId(lookupUserId(name));\n  // lookupUserId throws an exception when the name is unknown.\n  // This causes the stack to unwind: local variables alive at\n  // this point, such a \"b\", are destroyed. This happens before\n  // the invocation of \"b.setId()\" so \"b._id\" is still empty\n  // when its destructor is executed.\n\n  // ...\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cp\u003eHow to deal with exceptions in destructors highly depends on the application. Below, we present another way to solve the issue with an RAII-based\nclass representing a temporary directory.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\n// Delete the given directory; throws OSException on failure.\nvoid deleteDirectory(Path path) noexcept(false) {\n  // ...\n}\n\nclass TemporaryDirectory {\n  Path tmp;\n\npublic:\n  TemporaryDirectory(); // Create a new temporary directory.\n\n  TemporaryDirectory(TemporaryDirectory const\u0026amp;) \u003d delete;\n  TemporaryDirectory(TemporaryDirectory\u0026amp;\u0026amp;) \u003d delete;\n  TemporaryDirectory\u0026amp; operator\u003d(TemporaryDirectory const\u0026amp;) \u003d delete;\n  TemporaryDirectory\u0026amp; operator\u003d(TemporaryDirectory\u0026amp;\u0026amp;) \u003d delete;\n\n  ~TemporaryDirectory() {\n    deleteDirectory(tmp); // Noncompliant: may throw.\n  }\n};\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eDepending on the use case for those temporary directories, applying some remedial actions to avoid leaking secrets may be essential. Yet, it may be\nreasonable to simply log and silence the exception, for example, in the context of unit tests.\u003c/p\u003e\n\u003cp\u003eIt is possible to redesign the class:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Add a \u003ccode\u003eremove\u003c/code\u003e member function for scenarios that must carefully and reliably handle any \u003ccode\u003eOSException\u003c/code\u003e. In sensitive\n  contexts, the application should not solely rely on the destructor. \u003c/li\u003e\n  \u003cli\u003e Call this \u003ccode\u003eremove\u003c/code\u003e function from the destructor and catch any exception. This preserves the original class intent: an attempt to\n  delete the directory is made. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\n// Delete the given directory; throws OSException on failure.\nvoid deleteDirectory(Path path) noexcept(false) {\n  // ...\n}\n\nclass TemporaryDirectory {\n  Path tmp;\n\npublic:\n  TemporaryDirectory(); // Create a new temporary directory.\n\n  TemporaryDirectory(TemporaryDirectory const\u0026amp;) \u003d delete;\n  TemporaryDirectory(TemporaryDirectory\u0026amp;\u0026amp;) \u003d delete;\n  TemporaryDirectory\u0026amp; operator\u003d(TemporaryDirectory const\u0026amp;) \u003d delete;\n  TemporaryDirectory\u0026amp; operator\u003d(TemporaryDirectory\u0026amp;\u0026amp;) \u003d delete;\n\n  void remove() { deleteDirectory(tmp); }\n\n  ~TemporaryDirectory() {\n    try {\n      remove();\n    } catch (OSException const\u0026amp; e) {\n      logFailureToRemoveDirectory(e);\n    }\n  }\n};\n\u003c/pre\u003e\n\u003ch3\u003ePitfalls\u003c/h3\u003e\n\u003cp\u003eUsing a \u003cem\u003efunction-try-block\u003c/em\u003e in a destructor does not prevent the destructor from exiting with an exception.\u003c/p\u003e\n\u003cp\u003eFor example, the following destructor does not prevent the exception from escaping.\u003c/p\u003e\n\u003cpre\u003e\n~TemporaryDirectory() try {\n  remove();\n} catch (OSException const\u0026amp; e) {\n  logFailureToRemoveDirectory(e);\n}\n// `e` is automatically rethrow as if `throw;` was used.\n\u003c/pre\u003e\n\u003cp\u003eInstead, a \u003cem\u003etry-block\u003c/em\u003e should be used within the destructor’s body.\u003c/p\u003e\n\u003ch3\u003eGoing the extra mile\u003c/h3\u003e\n\u003cp\u003eIt is possible to detect whether a destructor is executed during stack unwinding and act accordingly; for example, to implement a transaction\nrollback action.\u003c/p\u003e\n\u003cp\u003eThe C++17 \u003ca href\u003d\"https://en.cppreference.com/w/cpp/error/uncaught_exception\"\u003e\u003ccode\u003estd::uncaught_exceptions\u003c/code\u003e\u003c/a\u003e function can be used for\nthis purpose, as explained in \u003ca href\u003d\"https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4152.pdf\"\u003eN4152\u003c/a\u003e. This function ends with an\n\u003ccode\u003es\u003c/code\u003e and should not be confused with \u003ccode\u003estd::uncaught_exception\u003c/code\u003e, which got removed in C++20 for the reasons exposed in the\npaper.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/function-try-block\"\u003efunction-try-block\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c36-a-destructor-must-not-fail\"\u003eC.36: A destructor must not\n  fail\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c37-make-destructors-noexcept\"\u003eC.37: Make destructors\n  \u003ccode\u003enoexcept\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 15-5-1 - A class destructor shall not exit with an exception. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S3654} - Destructors should be \"noexcept\" \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "misra-c++2008"
    ],
    "deprecatedKeys": [
      "cpp:ExceptionInDestructor"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S2259",
    "name": "Null pointers should not be dereferenced",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003cp\u003eDereferencing a null pointer results in undefined behavior.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eA pointer to null, also known as a null pointer, is created by initializing a pointer object to \u003ccode\u003e0\u003c/code\u003e, \u003ccode\u003eNULL\u003c/code\u003e, or in the case\nof C++ \u003ccode\u003enullptr\u003c/code\u003e. A null pointer does neither point to an object nor to valid memory, and as a consequence dereferencing or accessing the\nmemory pointed by such a pointer is undefined behavior.\u003c/p\u003e\n\u003cpre\u003e\nint deref() {\n  int* ptr \u003d 0;\n  return *ptr; // Noncompliant: deference of a null pointer\n}\n\u003c/pre\u003e\n\u003cp\u003eIn addition to using the \u003ccode\u003e*\u003c/code\u003e operator, accessing a member of a structure (using \u003ccode\u003e→\u003c/code\u003e) or an element of an array (using\n\u003ccode\u003e[]\u003c/code\u003e) also leads to dereference of the pointer, and causes undefined behavior if performed on a pointer to null.\u003c/p\u003e\n\u003cpre\u003e\nint subscript() {\n  int* ptr \u003d 0;\n  return ptr[2]; // Noncompliant: subscript operator used on null pointer\n}\n\u003c/pre\u003e\n\u003cpre\u003e\nstruct Aggregate {\n  int x;\n  int y;\n};\n\nint memberAccess() {\n  struct Aggregate* ptr \u003d 0;\n  return ptr-\u0026gt;x; // Noncompliant: member access on a null pointer\n}\n\u003c/pre\u003e\n\u003cp\u003eFinally, invoking a function pointer that holds a null value, dereferences the pointer, and too results in undefined behavior.\u003c/p\u003e\n\u003cpre\u003e\nvoid call() {\n  void (*func)(int) \u003d NULL; // func is a pointer to a function\n  func(10); // Noncompliant: the invocation of a null function pointer\n}\n\u003c/pre\u003e\n\u003ch2\u003eWhat is the potential impact?\u003c/h2\u003e\n\u003cp\u003eThe behavior of a program that dereferences a null pointer is undefined. In that case, the compiler no longer needs to adhere to the language\nstandard and the program has no meaning assigned to it.\u003c/p\u003e\n\u003cp\u003eIn practice, dereferencing a null pointer may lead to program crashes, or the application may appear to execute correctly while losing data or\nproducing incorrect results.\u003c/p\u003e\n\u003cp\u003eBesides affecting the application’s availability, null pointer dereferences may lead to code execution, in rare circumstances. If null is\nequivalent to the \u003ccode\u003e0x0\u003c/code\u003e memory address that can be accessed by privileged code, writing, and reading memory is possible, which compromises\nthe integrity and confidentiality of the application.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eEnsure that any pointer that is dereferenced by the program \u003cem\u003eis not\u003c/em\u003e null.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nchar *p1 \u003d ... ;\nif (p1 \u003d\u003d NULL \u0026amp;\u0026amp; *p1 \u003d\u003d \u0027\\t\u0027) { // Noncompliant: p1 will be dereferenced IFF it is null\n  // ...\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nchar *p1 \u003d ... ;\nif (p1 !\u003d NULL \u0026amp;\u0026amp; *p1 \u003d\u003d \u0027\\t\u0027) { // Compliant: *p1 cannot be evaluated if p1 is NULL\n  // ...\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\nchar *p2 \u003d ... ;\nif (p2 !\u003d NULL) {\n    // ...\n}\np2[2] \u003d \u0027\\t\u0027; // Noncompliant: potential null-dereference\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\nchar *p2 \u003d ... ;\nif (p2 !\u003d NULL) {\n    // ...\n  p2[2] \u003d \u0027\\t\u0027; // Compliant: p2 is known to be non-null\n}\n\u003c/pre\u003e\n\u003ch3\u003eGoing the extra mile\u003c/h3\u003e\n\u003cp\u003eIn C++, it is preferred to use reference parameters (\u003ccode\u003eType const\u0026amp;\u003c/code\u003e or \u003ccode\u003eType\u0026amp;\u003c/code\u003e), or pass objects by value\n(\u003ccode\u003eType\u003c/code\u003e), instead of a pointer (\u003ccode\u003eType const*\u003c/code\u003e or \u003ccode\u003eType*\u003c/code\u003e), if the argument is expected to never be null.\u003c/p\u003e\n\u003cpre\u003e\n// Precondition: graph !\u003d null\nbool isDAG(Graph const* graph);\n\u003c/pre\u003e\n\u003cp\u003eThe preferred signature would be:\u003c/p\u003e\n\u003cpre\u003e\nbool isDAG(Graph const\u0026amp; graph);\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/QdcxBQ\"\u003eEXP34-C.Do not dereference null pointers\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/476\"\u003e476 NULL Pointer Dereference\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f16-for-in-parameters-pass-cheaply-copied-types-by-value-and-others-by-reference-to-const\"\u003eF.16: For \"in\" parameters, pass cheaply-copied types by value and others by reference to \u003ccode\u003econst\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f17-for-in-out-parameters-pass-by-reference-to-non-const\"\u003eF.17:\n  For \"in-out\" parameters, pass by reference to non-\u003ccode\u003econst\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S3807} detects calls to C library functions that require valid, non-null pointers with null pointer arguments \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S2637} detects uses of null pointers as arguments for parameters that are annotated with \u003ccode\u003enonnull\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eDereferencing a null pointer results in undefined behavior.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eA pointer to null, also known as a null pointer, is created by initializing a pointer object to \u003ccode\u003e0\u003c/code\u003e, \u003ccode\u003eNULL\u003c/code\u003e, or in the case\nof C++ \u003ccode\u003enullptr\u003c/code\u003e. A null pointer does neither point to an object nor to valid memory, and as a consequence dereferencing or accessing the\nmemory pointed by such a pointer is undefined behavior.\u003c/p\u003e\n\u003cpre\u003e\nint deref() {\n  int* ptr \u003d 0;\n  return *ptr; // Noncompliant: deference of a null pointer\n}\n\u003c/pre\u003e\n\u003cp\u003eIn addition to using the \u003ccode\u003e*\u003c/code\u003e operator, accessing a member of a structure (using \u003ccode\u003e→\u003c/code\u003e) or an element of an array (using\n\u003ccode\u003e[]\u003c/code\u003e) also leads to dereference of the pointer, and causes undefined behavior if performed on a pointer to null.\u003c/p\u003e\n\u003cpre\u003e\nint subscript() {\n  int* ptr \u003d 0;\n  return ptr[2]; // Noncompliant: subscript operator used on null pointer\n}\n\u003c/pre\u003e\n\u003cpre\u003e\nstruct Aggregate {\n  int x;\n  int y;\n};\n\nint memberAccess() {\n  struct Aggregate* ptr \u003d 0;\n  return ptr-\u0026gt;x; // Noncompliant: member access on a null pointer\n}\n\u003c/pre\u003e\n\u003cp\u003eFinally, invoking a function pointer that holds a null value, dereferences the pointer, and too results in undefined behavior.\u003c/p\u003e\n\u003cpre\u003e\nvoid call() {\n  void (*func)(int) \u003d NULL; // func is a pointer to a function\n  func(10); // Noncompliant: the invocation of a null function pointer\n}\n\u003c/pre\u003e\n\u003ch2\u003eWhat is the potential impact?\u003c/h2\u003e\n\u003cp\u003eThe behavior of a program that dereferences a null pointer is undefined. In that case, the compiler no longer needs to adhere to the language\nstandard and the program has no meaning assigned to it.\u003c/p\u003e\n\u003cp\u003eIn practice, dereferencing a null pointer may lead to program crashes, or the application may appear to execute correctly while losing data or\nproducing incorrect results.\u003c/p\u003e\n\u003cp\u003eBesides affecting the application’s availability, null pointer dereferences may lead to code execution, in rare circumstances. If null is\nequivalent to the \u003ccode\u003e0x0\u003c/code\u003e memory address that can be accessed by privileged code, writing, and reading memory is possible, which compromises\nthe integrity and confidentiality of the application.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eEnsure that any pointer that is dereferenced by the program \u003cem\u003eis not\u003c/em\u003e null.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nchar *p1 \u003d ... ;\nif (p1 \u003d\u003d NULL \u0026amp;\u0026amp; *p1 \u003d\u003d \u0027\\t\u0027) { // Noncompliant: p1 will be dereferenced IFF it is null\n  // ...\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nchar *p1 \u003d ... ;\nif (p1 !\u003d NULL \u0026amp;\u0026amp; *p1 \u003d\u003d \u0027\\t\u0027) { // Compliant: *p1 cannot be evaluated if p1 is NULL\n  // ...\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\nchar *p2 \u003d ... ;\nif (p2 !\u003d NULL) {\n    // ...\n}\np2[2] \u003d \u0027\\t\u0027; // Noncompliant: potential null-dereference\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\nchar *p2 \u003d ... ;\nif (p2 !\u003d NULL) {\n    // ...\n  p2[2] \u003d \u0027\\t\u0027; // Compliant: p2 is known to be non-null\n}\n\u003c/pre\u003e\n\u003ch3\u003eGoing the extra mile\u003c/h3\u003e\n\u003cp\u003eIn C++, it is preferred to use reference parameters (\u003ccode\u003eType const\u0026amp;\u003c/code\u003e or \u003ccode\u003eType\u0026amp;\u003c/code\u003e), or pass objects by value\n(\u003ccode\u003eType\u003c/code\u003e), instead of a pointer (\u003ccode\u003eType const*\u003c/code\u003e or \u003ccode\u003eType*\u003c/code\u003e), if the argument is expected to never be null.\u003c/p\u003e\n\u003cpre\u003e\n// Precondition: graph !\u003d null\nbool isDAG(Graph const* graph);\n\u003c/pre\u003e\n\u003cp\u003eThe preferred signature would be:\u003c/p\u003e\n\u003cpre\u003e\nbool isDAG(Graph const\u0026amp; graph);\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/QdcxBQ\"\u003eEXP34-C.Do not dereference null pointers\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/476\"\u003e476 NULL Pointer Dereference\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f16-for-in-parameters-pass-cheaply-copied-types-by-value-and-others-by-reference-to-const\"\u003eF.16: For \"in\" parameters, pass cheaply-copied types by value and others by reference to \u003ccode\u003econst\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f17-for-in-out-parameters-pass-by-reference-to-non-const\"\u003eF.17:\n  For \"in-out\" parameters, pass by reference to non-\u003ccode\u003econst\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S3807} detects calls to C library functions that require valid, non-null pointers with null pointer arguments \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S2637} detects uses of null pointers as arguments for parameters that are annotated with \u003ccode\u003enonnull\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cert",
      "cwe",
      "symbolic-execution"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S3469",
    "name": "Inheritance should be \"public\"",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhile it is possible for inheritance to be non-\u003ccode\u003epublic\u003c/code\u003e, it is rarely justified and complicates the use of the derived class. For\ninstance, inherited member visibility is diminished and implicit and \u003ccode\u003estatic_cast\u003c/code\u003e casts from the derived class to the base class will not\nwork.\u003c/p\u003e\n\u003cp\u003eIt is sometimes used to limit the base class functionality available in the derived class. When that is the desire, composition should be used\ninstead.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass B : private A {  // Noncompliant\n  // ...\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nclass B : public A {\n  // ...\n}\n\u003c/pre\u003e\n\u003cp\u003eor\u003c/p\u003e\n\u003cpre\u003e\nclass B {\n  private:\n  A a;\n  // ...\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhile it is possible for inheritance to be non-\u003ccode\u003epublic\u003c/code\u003e, it is rarely justified and complicates the use of the derived class. For\ninstance, inherited member visibility is diminished and implicit and \u003ccode\u003estatic_cast\u003c/code\u003e casts from the derived class to the base class will not\nwork.\u003c/p\u003e\n\u003cp\u003eIt is sometimes used to limit the base class functionality available in the derived class. When that is the desire, composition should be used\ninstead.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass B : private A {  // Noncompliant\n  // ...\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nclass B : public A {\n  // ...\n}\n\u003c/pre\u003e\n\u003cp\u003eor\u003c/p\u003e\n\u003cpre\u003e\nclass B {\n  private:\n  A a;\n  // ...\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "api-design"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5523",
    "name": "Local variables should be initialized immediately",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eObjects should be initialized as soon as they are declared. It will be implicitly the case if they have a default constructor, as this latter will\nbe called, but otherwise the initialization must be explicit. Even when an object has a default constructor, it may be interesting to use another more\nrelevant constructor to directly give the the object its right value.\u003c/p\u003e\n\u003cp\u003eSuch direct initialization increases the readability of the code:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e seeing the initial value of a variable is usually a good indicator of its purpose, \u003c/li\u003e\n  \u003cli\u003e waiting until we know a good initial value before declaring a variable can lead to a reduced variable scope, \u003c/li\u003e\n  \u003cli\u003e it makes reasoning on the source code simpler: we remove the burden of having to know if a variable is initialized at a specific point in the\n  code, \u003c/li\u003e\n  \u003cli\u003e it is a first step that can lead to the possibility of declaring the variable \u003ccode\u003econst\u003c/code\u003e, which further simplifies reasoning, \u003c/li\u003e\n  \u003cli\u003e it is also a first step toward declaring it \u003ccode\u003eauto\u003c/code\u003e, which could increase readability by shifting the focus away from the exact type.\n  \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003ePlease note that the intent of the rule is not to initialize any variable with some semi-random value, but with the value that is meaningful for\nthis variable.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when a local variable of a built-in or pointer type is declared without an initial value.\u003c/p\u003e\n\u003cp\u003eThe related rule {rule:cpp:S836} detects situations when a variable is actually read before being initialized, while this rule promotes the good\npractice of systematically initializing the variable.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\ndouble init1();\ndouble init2();\ndouble init3();\ndouble init4();\n\nvoid f(bool b) {\n  int i; // Noncompliant\n  string s; // Compliant: default constructor will be called, but we could probably find a better value\n\n  double d1; // Noncompliant\n  double d2; // Noncompliant\n  if (b) {\n    d1 \u003d init1();\n    d2 \u003d init2();\n  } else {\n    d1 \u003d init3();\n    d2 \u003d init4();\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\ndouble init1();\ndouble init2();\ndouble init3();\ndouble init4();\n\nstd::pair\u0026lt;double, double\u0026gt; init(bool b) {\n    return b ? std::make_pair(init1(), init2()) : std::make_pair(init3(), init4());\n}\n\nvoid f(bool b) {\n  int i \u003d 0;\n  string s;\n\n  auto [d1, d2] \u003d init(b);\n}\n\n// Or:\nvoid f(bool b) {\n  auto [d1, d2] \u003d [b](){\n    if (b) {\n      return std::make_pair(init1(), init2());\n    } else {\n      return std::make_pair(init3(), init4());\n    }\n  }();\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eBuffers can be left uninitialized as long as they are written into immediately after their declarations.\u003c/p\u003e\n\u003cpre\u003e\n  int buf[10]; // allowed but it should be initialized right after the declaration\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es20-always-initialize-an-object\"\u003eES.20: Always initialize an\n  object\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eObjects should be initialized as soon as they are declared. It will be implicitly the case if they have a default constructor, as this latter will\nbe called, but otherwise the initialization must be explicit. Even when an object has a default constructor, it may be interesting to use another more\nrelevant constructor to directly give the the object its right value.\u003c/p\u003e\n\u003cp\u003eSuch direct initialization increases the readability of the code:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e seeing the initial value of a variable is usually a good indicator of its purpose, \u003c/li\u003e\n  \u003cli\u003e waiting until we know a good initial value before declaring a variable can lead to a reduced variable scope, \u003c/li\u003e\n  \u003cli\u003e it makes reasoning on the source code simpler: we remove the burden of having to know if a variable is initialized at a specific point in the\n  code, \u003c/li\u003e\n  \u003cli\u003e it is a first step that can lead to the possibility of declaring the variable \u003ccode\u003econst\u003c/code\u003e, which further simplifies reasoning, \u003c/li\u003e\n  \u003cli\u003e it is also a first step toward declaring it \u003ccode\u003eauto\u003c/code\u003e, which could increase readability by shifting the focus away from the exact type.\n  \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003ePlease note that the intent of the rule is not to initialize any variable with some semi-random value, but with the value that is meaningful for\nthis variable.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when a local variable of a built-in or pointer type is declared without an initial value.\u003c/p\u003e\n\u003cp\u003eThe related rule {rule:cpp:S836} detects situations when a variable is actually read before being initialized, while this rule promotes the good\npractice of systematically initializing the variable.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\ndouble init1();\ndouble init2();\ndouble init3();\ndouble init4();\n\nvoid f(bool b) {\n  int i; // Noncompliant\n  string s; // Compliant: default constructor will be called, but we could probably find a better value\n\n  double d1; // Noncompliant\n  double d2; // Noncompliant\n  if (b) {\n    d1 \u003d init1();\n    d2 \u003d init2();\n  } else {\n    d1 \u003d init3();\n    d2 \u003d init4();\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\ndouble init1();\ndouble init2();\ndouble init3();\ndouble init4();\n\nstd::pair\u0026lt;double, double\u0026gt; init(bool b) {\n    return b ? std::make_pair(init1(), init2()) : std::make_pair(init3(), init4());\n}\n\nvoid f(bool b) {\n  int i \u003d 0;\n  string s;\n\n  auto [d1, d2] \u003d init(b);\n}\n\n// Or:\nvoid f(bool b) {\n  auto [d1, d2] \u003d [b](){\n    if (b) {\n      return std::make_pair(init1(), init2());\n    } else {\n      return std::make_pair(init3(), init4());\n    }\n  }();\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eBuffers can be left uninitialized as long as they are written into immediately after their declarations.\u003c/p\u003e\n\u003cpre\u003e\n  int buf[10]; // allowed but it should be initialized right after the declaration\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es20-always-initialize-an-object\"\u003eES.20: Always initialize an\n  object\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "cppcoreguidelines",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S3468",
    "name": "Function declarations that look like variable declarations should not be used",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eLike a clever insect posing as a leaf, there are constructs in C++ which look like variable declarations, but which are actually interpreted by the\ncompiler as function or function pointer declarations. Beyond the problem of confusing maintainers, it’s highly likely in such cases that what the\ncoder intended is not what the compiler will do.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid doWork(Status status) {\n  Lock lock();  // Noncompliant; declares function named \"lock\"\n  ...\n  Form form(ProgressBar(status)); // Noncompliant; declares function named \"form\" with \"status\" parameter\n  ...\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid doWork(Status status) {\n  Lock lock;  // remove the parentheses to declare a variable\n  ...\n  Form form((ProgressBar(status))); // add a pair of parentheses to declare a variable\n  ...\n}\n\u003c/pre\u003e\n\u003cp\u003eSince C++11 you can also use direct initialization to declare a variable:\u003c/p\u003e\n\u003cpre\u003e\nvoid doWork(Status status) {\n  Lock lock{};\n  ...\n  Form form{ProgressBar{status}};\n  ...\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/DHw-BQ\"\u003eCERT, DCL53-CPP.\u003c/a\u003e - Do not write syntactically ambiguous declarations \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eLike a clever insect posing as a leaf, there are constructs in C++ which look like variable declarations, but which are actually interpreted by the\ncompiler as function or function pointer declarations. Beyond the problem of confusing maintainers, it’s highly likely in such cases that what the\ncoder intended is not what the compiler will do.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid doWork(Status status) {\n  Lock lock();  // Noncompliant; declares function named \"lock\"\n  ...\n  Form form(ProgressBar(status)); // Noncompliant; declares function named \"form\" with \"status\" parameter\n  ...\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid doWork(Status status) {\n  Lock lock;  // remove the parentheses to declare a variable\n  ...\n  Form form((ProgressBar(status))); // add a pair of parentheses to declare a variable\n  ...\n}\n\u003c/pre\u003e\n\u003cp\u003eSince C++11 you can also use direct initialization to declare a variable:\u003c/p\u003e\n\u003cpre\u003e\nvoid doWork(Status status) {\n  Lock lock{};\n  ...\n  Form form{ProgressBar{status}};\n  ...\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/DHw-BQ\"\u003eCERT, DCL53-CPP.\u003c/a\u003e - Do not write syntactically ambiguous declarations \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cert"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5524",
    "name": "Multiple mutexes should not be acquired with individual locks",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cem\u003eMutexes\u003c/em\u003e are synchronization primitives that allow you to manage concurrency. It is a common situation to have to lock more than one\n\u003cem\u003emutex\u003c/em\u003e simultaneously to get access to several resources at the same time.\u003c/p\u003e\n\u003cp\u003eIf this is not done properly, it can lead to deadlocks or crashes. If one thread acquires A and then tries to acquire B, while another thread\nacquires B and then tries to acquire A, both threads will wait for each other forever.\u003c/p\u003e\n\u003cp\u003eIn such a case, a commonly accepted good practice is to define an order on the \u003cem\u003emutexes\u003c/em\u003e then lock them in that order, and then unlock them\nin the reverse order. However, such an order is not always clearly defined or easy to ensure across a whole program.\u003c/p\u003e\n\u003cp\u003eC++ provides facilities to lock multiple \u003cem\u003emutexes\u003c/em\u003e in one go, with a dedicated deadlock prevention algorithm. They should be used instead.\nBefore C++17, you should use \u003ccode\u003estd::lock\u003c/code\u003e, and since C++17 you can use a variadic constructor of \u003ccode\u003estd::scoped_lock\u003c/code\u003e. See the\nexamples for more details.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid g();\n\nstd::mutex m1;\nstd::mutex m2;\n\nvoid f() {\n  // The example would be the same with std::lock_guard if C++17 std::scoped_lock is not available\n  std::scoped_lock\u0026lt;std::mutex\u0026gt; lck1(m1); // Compliant: first mutex acquired\n  std::scoped_lock\u0026lt;std::mutex\u0026gt; lck2(m2); // Noncompliant: acquiring several mutexes\n  g();\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid g();\n\nstd::mutex m1;\nstd::mutex m2;\n\nvoid f() { // Compliant: C++11 solution\n  std::lock(m1, m2);\n  std::lock_guard\u0026lt;std::mutex\u0026gt; lck1(m1, std::adopt_lock);\n  std::lock_guard\u0026lt;std::mutex\u0026gt; lck2(m2, std::adopt_lock);\n  g();\n}\n\nvoid f() { // Compliant: C++17 solution\n  std::scoped_lock\u0026lt;std::mutex, std::mutex\u0026gt; lck1(m1, m2);\n  g();\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#cp21-use-stdlock-or-stdscoped_lock-to-acquire-multiple-mutexes\"\u003eCP.21: Use \u003ccode\u003estd::lock()\u003c/code\u003e or \u003ccode\u003estd::scoped_lock\u003c/code\u003e to acquire multiple \u003ccode\u003emutex\u003c/code\u003ees\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/thread/scoped_lock\"\u003ecppreference.com - std::scoped_lock\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cem\u003eMutexes\u003c/em\u003e are synchronization primitives that allow you to manage concurrency. It is a common situation to have to lock more than one\n\u003cem\u003emutex\u003c/em\u003e simultaneously to get access to several resources at the same time.\u003c/p\u003e\n\u003cp\u003eIf this is not done properly, it can lead to deadlocks or crashes. If one thread acquires A and then tries to acquire B, while another thread\nacquires B and then tries to acquire A, both threads will wait for each other forever.\u003c/p\u003e\n\u003cp\u003eIn such a case, a commonly accepted good practice is to define an order on the \u003cem\u003emutexes\u003c/em\u003e then lock them in that order, and then unlock them\nin the reverse order. However, such an order is not always clearly defined or easy to ensure across a whole program.\u003c/p\u003e\n\u003cp\u003eC++ provides facilities to lock multiple \u003cem\u003emutexes\u003c/em\u003e in one go, with a dedicated deadlock prevention algorithm. They should be used instead.\nBefore C++17, you should use \u003ccode\u003estd::lock\u003c/code\u003e, and since C++17 you can use a variadic constructor of \u003ccode\u003estd::scoped_lock\u003c/code\u003e. See the\nexamples for more details.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid g();\n\nstd::mutex m1;\nstd::mutex m2;\n\nvoid f() {\n  // The example would be the same with std::lock_guard if C++17 std::scoped_lock is not available\n  std::scoped_lock\u0026lt;std::mutex\u0026gt; lck1(m1); // Compliant: first mutex acquired\n  std::scoped_lock\u0026lt;std::mutex\u0026gt; lck2(m2); // Noncompliant: acquiring several mutexes\n  g();\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid g();\n\nstd::mutex m1;\nstd::mutex m2;\n\nvoid f() { // Compliant: C++11 solution\n  std::lock(m1, m2);\n  std::lock_guard\u0026lt;std::mutex\u0026gt; lck1(m1, std::adopt_lock);\n  std::lock_guard\u0026lt;std::mutex\u0026gt; lck2(m2, std::adopt_lock);\n  g();\n}\n\nvoid f() { // Compliant: C++17 solution\n  std::scoped_lock\u0026lt;std::mutex, std::mutex\u0026gt; lck1(m1, m2);\n  g();\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#cp21-use-stdlock-or-stdscoped_lock-to-acquire-multiple-mutexes\"\u003eCP.21: Use \u003ccode\u003estd::lock()\u003c/code\u003e or \u003ccode\u003estd::scoped_lock\u003c/code\u003e to acquire multiple \u003ccode\u003emutex\u003c/code\u003ees\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/thread/scoped_lock\"\u003ecppreference.com - std::scoped_lock\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "bad-practice",
      "cppcoreguidelines",
      "pitfall",
      "since-c++11"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S922",
    "name": "Evaluation of the operand to the sizeof operator shall not contain side effects",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThis rule is a strict implementation of a MISRA (Motor Industry Software Reliability Association) rule. MISRA defines best practices for developing\nsafety-critical software. You can learn more about this rule in the MISRA documents referenced below.\u003c/p\u003e\n\u003cp\u003eIf you are not concerned with MISRA compliance or with safety-critical software, you might consider using rule {rule:cpp:S3135} instead ; it\ntargets the same kind of issue for general-purpose software.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C 2004, 12.3 - The sizeof operator shall not be used on expressions that contain side effects. \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2008, 5-3-4 - Evaluation of the operand to the sizeof operator shall not contain side effects. \u003c/li\u003e\n  \u003cli\u003e MISRA C 2012, 13.6 - The operand of the sizeof operator shall not contain any expression which has potential side effects \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThis rule is a strict implementation of a MISRA (Motor Industry Software Reliability Association) rule. MISRA defines best practices for developing\nsafety-critical software. You can learn more about this rule in the MISRA documents referenced below.\u003c/p\u003e\n\u003cp\u003eIf you are not concerned with MISRA compliance or with safety-critical software, you might consider using rule {rule:cpp:S3135} instead ; it\ntargets the same kind of issue for general-purpose software.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C 2004, 12.3 - The sizeof operator shall not be used on expressions that contain side effects. \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2008, 5-3-4 - Evaluation of the operand to the sizeof operator shall not contain side effects. \u003c/li\u003e\n  \u003cli\u003e MISRA C 2012, 13.6 - The operand of the sizeof operator shall not contain any expression which has potential side effects \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "misra-c++2008"
    ],
    "deprecatedKeys": [
      "cpp:SideEffectInSizeOf"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S802",
    "name": "\"typedef\" names should be unique identifiers",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eReusing a \u003ccode\u003etypedef\u003c/code\u003e name either as another \u003ccode\u003etypedef\u003c/code\u003e name or for any other purpose may lead to developer confusion.\u003c/p\u003e\n\u003cp\u003eThe same \u003ccode\u003etypedef\u003c/code\u003e shall not be duplicated anywhere in the project, even if the declarations are identical.\u003c/p\u003e\n\u003cp\u003eNote that where the type definition is made in a header file, and that header file is included in multiple source files, this rule is not\nviolated.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n{\n  typedef unsigned char uint8_t;\n}\n\n{\n  typedef unsigned char uint8_t; // Noncompliant, redefinition\n}\n\n{\n  unsigned char uint8_t; // Noncompliant, reuse of uint8_t for another purpose\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\ntypedef unsigned char uint8_t;\n{\n}\n\n{\n}\n\n{\n  unsigned char myChar;\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 5.3 - A typedef name shall be a unique identifier. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 2-10-3 - A typedef name (including qualification, if any) shall be a unique identifier. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eReusing a \u003ccode\u003etypedef\u003c/code\u003e name either as another \u003ccode\u003etypedef\u003c/code\u003e name or for any other purpose may lead to developer confusion.\u003c/p\u003e\n\u003cp\u003eThe same \u003ccode\u003etypedef\u003c/code\u003e shall not be duplicated anywhere in the project, even if the declarations are identical.\u003c/p\u003e\n\u003cp\u003eNote that where the type definition is made in a header file, and that header file is included in multiple source files, this rule is not\nviolated.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n{\n  typedef unsigned char uint8_t;\n}\n\n{\n  typedef unsigned char uint8_t; // Noncompliant, redefinition\n}\n\n{\n  unsigned char uint8_t; // Noncompliant, reuse of uint8_t for another purpose\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\ntypedef unsigned char uint8_t;\n{\n}\n\n{\n}\n\n{\n  unsigned char myChar;\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 5.3 - A typedef name shall be a unique identifier. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 2-10-3 - A typedef name (including qualification, if any) shall be a unique identifier. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S923",
    "name": "Functions should not be defined with a variable number of arguments",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003ePassing arguments via an ellipsis bypasses the type checking performed by the compiler. Additionally, passing an argument with non-POD class type\nleads to undefined behavior. Note that the rule specifies \"defined\" (and not \"declared\") so as to permit the use of existing library functions.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid MyPrintf ( char_t * pFormat, ... )\t// Noncompliant\n{\n  // ...\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 16.1 - Functions shall not be defined with a variable number of arguments. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 8-4-1 - Functions shall not be defined using the ellipsis notation. \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/5ns-BQ\"\u003eCERT, DCL50-CPP.\u003c/a\u003e - Do not define a C-style variadic function \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#-es34-dont-define-a-c-style-variadic-function\"\u003eES.34: Don’t\n  define a (C-style) variadic function\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f55-dont-use-va_arg-arguments\"\u003eF.55: Don’t use\n  \u003ccode\u003eva_arg\u003c/code\u003e arguments\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003ePassing arguments via an ellipsis bypasses the type checking performed by the compiler. Additionally, passing an argument with non-POD class type\nleads to undefined behavior. Note that the rule specifies \"defined\" (and not \"declared\") so as to permit the use of existing library functions.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid MyPrintf ( char_t * pFormat, ... )\t// Noncompliant\n{\n  // ...\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 16.1 - Functions shall not be defined with a variable number of arguments. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 8-4-1 - Functions shall not be defined using the ellipsis notation. \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/5ns-BQ\"\u003eCERT, DCL50-CPP.\u003c/a\u003e - Do not define a C-style variadic function \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#-es34-dont-define-a-c-style-variadic-function\"\u003eES.34: Don’t\n  define a (C-style) variadic function\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f55-dont-use-va_arg-arguments\"\u003eF.55: Don’t use\n  \u003ccode\u003eva_arg\u003c/code\u003e arguments\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cert",
      "misra-c++2008",
      "misra-c2004",
      "pitfall"
    ],
    "deprecatedKeys": [
      "cpp:FunctionEllipsis"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S920",
    "name": "Switch statement conditions should not have essentially boolean type",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhen there is only a single condition to test, you have the option of using either a \u003ccode\u003eswitch\u003c/code\u003e statement or an \u003ccode\u003eif\u003c/code\u003e-\u003ccode\u003eelse\nif\u003c/code\u003e-\u003ccode\u003eelse\u003c/code\u003e statement. For a larger set of potential values, a \u003ccode\u003eswitch\u003c/code\u003e can be easier to read, but when the condition being\ntested is essentially boolean, then an \u003ccode\u003eif\u003c/code\u003e/\u003ccode\u003eelse\u003c/code\u003e statement should be used instead.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n_Bool b \u003d p \u0026gt; 0;\nswitch (b) { // Noncompliant\n...\n}\nswitch (x \u003d\u003d 0) { // Noncompliant\n...\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n_Bool b \u003d p \u0026gt; 0;\nif (b) {\n...\n} else {\n...\n}\nif (x \u003d\u003d 0) {\n...\n} else {\n...\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 15.4 - A switch expression shall not represent a value that is effectively Boolean \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2008, 6-4-7 - The condition of a switch statement shall not have bool type \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 16.7 - A switch-expression shall not have essentially Boolean type \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhen there is only a single condition to test, you have the option of using either a \u003ccode\u003eswitch\u003c/code\u003e statement or an \u003ccode\u003eif\u003c/code\u003e-\u003ccode\u003eelse\nif\u003c/code\u003e-\u003ccode\u003eelse\u003c/code\u003e statement. For a larger set of potential values, a \u003ccode\u003eswitch\u003c/code\u003e can be easier to read, but when the condition being\ntested is essentially boolean, then an \u003ccode\u003eif\u003c/code\u003e/\u003ccode\u003eelse\u003c/code\u003e statement should be used instead.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n_Bool b \u003d p \u0026gt; 0;\nswitch (b) { // Noncompliant\n...\n}\nswitch (x \u003d\u003d 0) { // Noncompliant\n...\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n_Bool b \u003d p \u0026gt; 0;\nif (b) {\n...\n} else {\n...\n}\nif (x \u003d\u003d 0) {\n...\n} else {\n...\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 15.4 - A switch expression shall not represent a value that is effectively Boolean \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2008, 6-4-7 - The condition of a switch statement shall not have bool type \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 16.7 - A switch-expression shall not have essentially Boolean type \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "misra-c++2008",
      "misra-c2004",
      "misra-c2012"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1270",
    "name": "Functions without parameters should not use \"(void)\"",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eExplicitly specifying a \u003ccode\u003evoid\u003c/code\u003e parameter list is required in C, but optional in C++. Using \u003ccode\u003evoid\u003c/code\u003e for a parameter-less\nfunction decreases its readability. The at-a-glance impression is that the function \u003cem\u003edoes\u003c/em\u003e take a parameter, and it takes a second look to\nascertain that it does not. Therefore the more compact notation is preferred.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint fun(void);\n\nint fun(void) {\n  ...\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint fun();\n\nint fun() {\n  ...\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#nl25-dont-use-void-as-an-argument-type\"\u003eNL.25: Don’t use\n  \u003ccode\u003evoid\u003c/code\u003e as an argument type\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eExplicitly specifying a \u003ccode\u003evoid\u003c/code\u003e parameter list is required in C, but optional in C++. Using \u003ccode\u003evoid\u003c/code\u003e for a parameter-less\nfunction decreases its readability. The at-a-glance impression is that the function \u003cem\u003edoes\u003c/em\u003e take a parameter, and it takes a second look to\nascertain that it does not. Therefore the more compact notation is preferred.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint fun(void);\n\nint fun(void) {\n  ...\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint fun();\n\nint fun() {\n  ...\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#nl25-dont-use-void-as-an-argument-type\"\u003eNL.25: Don’t use\n  \u003ccode\u003evoid\u003c/code\u003e as an argument type\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "convention",
      "cppcoreguidelines"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1271",
    "name": "\"::\" operator should be used to access global variables and functions",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhile it is possible to access a global variable or function without using the \u003ccode\u003e::\u003c/code\u003e operator, it can be considered to be misleading\nbecause it might imply to the readers of your code that this is a local or class variable/function and not a global one. Being explicit also allows\nmore freedom in naming local variables without the chance of clashing with global names.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint a \u003d 10;\nint main()\n{\n  ...\n  int b \u003d a;    // Noncompliant\n  ...\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint a \u003d 10;\nint main()\n{\n  ...\n  int b \u003d ::a;    // Compliant\n  ...\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhile it is possible to access a global variable or function without using the \u003ccode\u003e::\u003c/code\u003e operator, it can be considered to be misleading\nbecause it might imply to the readers of your code that this is a local or class variable/function and not a global one. Being explicit also allows\nmore freedom in naming local variables without the chance of clashing with global names.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint a \u003d 10;\nint main()\n{\n  ...\n  int b \u003d a;    // Noncompliant\n  ...\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint a \u003d 10;\nint main()\n{\n  ...\n  int b \u003d ::a;    // Compliant\n  ...\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S3692",
    "name": "Comparison operators should not be virtual",
    "defaultSeverity": "BLOCKER",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eMaking a comparison operator \u003ccode\u003evirtual\u003c/code\u003e implies that you want to compare objects of different types by overriding\n\u003ccode\u003eoperator\u003d\u003d\u003c/code\u003e, for instance, in a subclass to compare instances of the base class with instances of the subclass. But polymorphic comparison\noperators are very difficult to get right, and are actually questionable in concept. After all, can two objects with only a few common members really\nbe equal?\u003c/p\u003e\n\u003cp\u003eThis rule raises issues on \u003ccode\u003evirtual\u003c/code\u003e comparison operators.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstruct Foo {\n  virtual bool operator\u003d\u003d(const Foo \u0026amp;other) const; // Noncompliant\n  virtual bool operator!\u003d(const Foo \u0026amp;other) const; // Noncompliant\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstruct Foo {\n  bool operator\u003d\u003d(const Foo \u0026amp;other) const;\n  bool operator!\u003d(const Foo \u0026amp;other) const;\n};\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c87-beware-of—​on-base-classes\"\u003eC.87: Beware of \u003ccode\u003e\u003d\u003d\u003c/code\u003e\n  on base classes\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eMaking a comparison operator \u003ccode\u003evirtual\u003c/code\u003e implies that you want to compare objects of different types by overriding\n\u003ccode\u003eoperator\u003d\u003d\u003c/code\u003e, for instance, in a subclass to compare instances of the base class with instances of the subclass. But polymorphic comparison\noperators are very difficult to get right, and are actually questionable in concept. After all, can two objects with only a few common members really\nbe equal?\u003c/p\u003e\n\u003cp\u003eThis rule raises issues on \u003ccode\u003evirtual\u003c/code\u003e comparison operators.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstruct Foo {\n  virtual bool operator\u003d\u003d(const Foo \u0026amp;other) const; // Noncompliant\n  virtual bool operator!\u003d(const Foo \u0026amp;other) const; // Noncompliant\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstruct Foo {\n  bool operator\u003d\u003d(const Foo \u0026amp;other) const;\n  bool operator!\u003d(const Foo \u0026amp;other) const;\n};\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c87-beware-of—​on-base-classes\"\u003eC.87: Beware of \u003ccode\u003e\u003d\u003d\u003c/code\u003e\n  on base classes\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cppcoreguidelines",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1151",
    "name": "\"switch case\" clauses should not have too many lines of code",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "FOCUSED",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003eswitch\u003c/code\u003e statement should be used only to clearly define some new branches in the control flow. As soon as a \u003ccode\u003ecase\u003c/code\u003e\nclause contains too many statements this highly decreases the readability of the overall control flow statement. In such case, the content of\n\u003ccode\u003ecase\u003c/code\u003e clause should be extracted in a dedicated function.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cp\u003eWith the default threshold of 5:\u003c/p\u003e\n\u003cpre\u003e\nswitch (myVariable) {\n  case 0: // 6 lines till next case\n    methodCall1(\"\");\n    methodCall2(\"\");\n    methodCall3(\"\");\n    methodCall4(\"\");\n    methodCall5(\"\");\n    break;\n  case 1:\n  // ...\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nswitch (myVariable) {\n  case 0: // Compliant: 2 lines\n    doSomething();\n    break;\n  case 1: // Compliant: 5 lines till next case. Curly braces after a case are not counted if they contain the entire case body\n   {\n     methodCall1(\"\");\n     methodCall2(\"\");\n     methodCall3(\"\");\n     methodCall4(\"\");\n     break;\n   }\n   case 2:\n  // ...\n}\n// ...\nvoid doSomething(){\n    methodCall1(\"\");\n    methodCall2(\"\");\n    methodCall3(\"\");\n    methodCall4(\"\");\n    methodCall5(\"\");\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe \u003ccode\u003eswitch\u003c/code\u003e statement should be used only to clearly define some new branches in the control flow. As soon as a \u003ccode\u003ecase\u003c/code\u003e\nclause contains too many statements this highly decreases the readability of the overall control flow statement. In such case, the content of\n\u003ccode\u003ecase\u003c/code\u003e clause should be extracted in a dedicated function.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cp\u003eWith the default threshold of 5:\u003c/p\u003e\n\u003cpre\u003e\nswitch (myVariable) {\n  case 0: // 6 lines till next case\n    methodCall1(\"\");\n    methodCall2(\"\");\n    methodCall3(\"\");\n    methodCall4(\"\");\n    methodCall5(\"\");\n    break;\n  case 1:\n  // ...\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nswitch (myVariable) {\n  case 0: // Compliant: 2 lines\n    doSomething();\n    break;\n  case 1: // Compliant: 5 lines till next case. Curly braces after a case are not counted if they contain the entire case body\n   {\n     methodCall1(\"\");\n     methodCall2(\"\");\n     methodCall3(\"\");\n     methodCall4(\"\");\n     break;\n   }\n   case 2:\n  // ...\n}\n// ...\nvoid doSomething(){\n    methodCall1(\"\");\n    methodCall2(\"\");\n    methodCall3(\"\");\n    methodCall4(\"\");\n    methodCall5(\"\");\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {
      "max": {
        "key": "max",
        "name": "max",
        "description": "Maximum Number of Lines",
        "defaultValue": "5",
        "type": "INTEGER",
        "multiple": false,
        "possibleValues": []
      }
    },
    "defaultParams": {
      "max": "5"
    },
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "brain-overload"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S3691",
    "name": "Partial specialization syntax should not be used for function templates",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eClass templates can be explicitly or partially specialized. But according to the C++ standard, function templates cannot be partially specialized.\nUnder certain conditions, the Microsoft® compiler will silently ignore the confusing application of partial specialization syntax to a function, but\nother compilers will raise an error for it and fail compilation.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\ntemplate\u0026lt;typename T\u0026gt;\nvoid fun(T p);\n\ntemplate\u0026lt;typename T\u0026gt;\nvoid fun\u0026lt;T\u0026gt;(T p) { // Noncompliant\n  // ...\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\ntemplate\u0026lt;typename T\u0026gt;\nvoid fun(T p);\n\ntemplate\u0026lt;typename T\u0026gt;\nvoid fun(T p) {\n  // ...\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eClass templates can be explicitly or partially specialized. But according to the C++ standard, function templates cannot be partially specialized.\nUnder certain conditions, the Microsoft® compiler will silently ignore the confusing application of partial specialization syntax to a function, but\nother compilers will raise an error for it and fail compilation.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\ntemplate\u0026lt;typename T\u0026gt;\nvoid fun(T p);\n\ntemplate\u0026lt;typename T\u0026gt;\nvoid fun\u0026lt;T\u0026gt;(T p) { // Noncompliant\n  // ...\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\ntemplate\u0026lt;typename T\u0026gt;\nvoid fun(T p);\n\ntemplate\u0026lt;typename T\u0026gt;\nvoid fun(T p) {\n  // ...\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "lock-in"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S926",
    "name": "Parameters in a function prototype should be named",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "IDENTIFIABLE",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eNaming the parameters in a function prototype helps identify how they’ll be used by the function, thereby acting as a thin layer of documentation\nfor the function.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid divide (int, int);\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid divide (int numerator, int denominator);\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 16.3 - Identifiers shall be given for all of the parameters in a function prototype declaration \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 8.2 - Function types shall be in prototype form with named parameters \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eNaming the parameters in a function prototype helps identify how they’ll be used by the function, thereby acting as a thin layer of documentation\nfor the function.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid divide (int, int);\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid divide (int numerator, int denominator);\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 16.3 - Identifiers shall be given for all of the parameters in a function prototype declaration \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 8.2 - Function types shall be in prototype form with named parameters \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "based-on-misra"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S924",
    "name": "Loops should not have more than one \"break\" or \"goto\" statement",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eRestricting the number of exits from a loop is done in the interests of good structured programming. One \u003ccode\u003ebreak\u003c/code\u003e or \u003ccode\u003egoto\u003c/code\u003e\nstatement is acceptable in a loop since this allows, for example, for dual-outcome loops or optimal coding.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cp\u003eWith the default threshold of 1:\u003c/p\u003e\n\u003cpre\u003e\nfor (int i \u003d 0; i \u0026lt; 10; i++) {\n  if (...) {\n    break;      //  Compliant\n  }\n  else if (...) {\n    break;      //  Non-compliant - second jump from loop\n  }\n  else {\n    ...\n  }\n}\nwhile (...) {\n  if (...) {\n    break;      // Compliant\n  }\n  if (...) {\n    break;      // Non-compliant - second jump from loop\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nfor (int i \u003d 0; i \u0026lt; 10; i++) {\n  if (...) {\n    break;      //  Compliant\n  }\n}\nwhile (...) {\n  if (...) {\n    break;    // Compliant\n  }\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 14.6 - For any iteration statement there shall be at most one break statement used for loop termination. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 6-6-4 - For any iteration statement there shall be no more than one break or goto statement used for loop termination. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 15.4 - There should be no more than one break or goto statement used to terminate any iteration statement \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eRestricting the number of exits from a loop is done in the interests of good structured programming. One \u003ccode\u003ebreak\u003c/code\u003e or \u003ccode\u003egoto\u003c/code\u003e\nstatement is acceptable in a loop since this allows, for example, for dual-outcome loops or optimal coding.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cp\u003eWith the default threshold of 1:\u003c/p\u003e\n\u003cpre\u003e\nfor (int i \u003d 0; i \u0026lt; 10; i++) {\n  if (...) {\n    break;      //  Compliant\n  }\n  else if (...) {\n    break;      //  Non-compliant - second jump from loop\n  }\n  else {\n    ...\n  }\n}\nwhile (...) {\n  if (...) {\n    break;      // Compliant\n  }\n  if (...) {\n    break;      // Non-compliant - second jump from loop\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nfor (int i \u003d 0; i \u0026lt; 10; i++) {\n  if (...) {\n    break;      //  Compliant\n  }\n}\nwhile (...) {\n  if (...) {\n    break;    // Compliant\n  }\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 14.6 - For any iteration statement there shall be at most one break statement used for loop termination. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 6-6-4 - For any iteration statement there shall be no more than one break or goto statement used for loop termination. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 15.4 - There should be no more than one break or goto statement used to terminate any iteration statement \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {
      "maxNumberOfTerminationStatements": {
        "key": "maxNumberOfTerminationStatements",
        "name": "maxNumberOfTerminationStatements",
        "description": "Maximum authorized number of break/goto statements",
        "defaultValue": "1",
        "type": "INTEGER",
        "multiple": false,
        "possibleValues": []
      }
    },
    "defaultParams": {
      "maxNumberOfTerminationStatements": "1"
    },
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "confusing"
    ],
    "deprecatedKeys": [
      "cpp:SingleGotoOrBreakPerIteration"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S925",
    "name": "Recursion should not be used",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eRecursion is a powerful tool, but it can be tricky to get right. Getting it wrong can lead to stack overflow errors and cause system problems. Even\nwhen you do get it right, recursive code can be difficult to understand, perhaps leading to maintenance problems in the future. Therefore recursion\nshould be avoided in general and used only with due deliberation and caution when it is strictly necessary.\u003c/p\u003e\n\u003cp\u003eThis rule checks for direct recursion (when a function calls itself).\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint pow(int num, int exponent) {\n  if (exponent \u0026gt; 1) {\n    num \u003d num * pow(num, exponent-1);  // Noncompliant; direct recursion\n  }\n  return num;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint pow(int num, int exponent) {\n  int val \u003d num;\n  while (exponent \u0026gt; 0) {\n    val *\u003d num;\n    --exponent;\n  }\n  return val;\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 16.2 - Functions shall not call themselves, either directly or indirectly. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 7-5-4 - Functions should not call themselves, either directly or indirectly. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 17.2 - Functions shall not call themselves, either directly or indirectly \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eRecursion is a powerful tool, but it can be tricky to get right. Getting it wrong can lead to stack overflow errors and cause system problems. Even\nwhen you do get it right, recursive code can be difficult to understand, perhaps leading to maintenance problems in the future. Therefore recursion\nshould be avoided in general and used only with due deliberation and caution when it is strictly necessary.\u003c/p\u003e\n\u003cp\u003eThis rule checks for direct recursion (when a function calls itself).\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint pow(int num, int exponent) {\n  if (exponent \u0026gt; 1) {\n    num \u003d num * pow(num, exponent-1);  // Noncompliant; direct recursion\n  }\n  return num;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint pow(int num, int exponent) {\n  int val \u003d num;\n  while (exponent \u0026gt; 0) {\n    val *\u003d num;\n    --exponent;\n  }\n  return val;\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 16.2 - Functions shall not call themselves, either directly or indirectly. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 7-5-4 - Functions should not call themselves, either directly or indirectly. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 17.2 - Functions shall not call themselves, either directly or indirectly \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "bad-practice",
      "based-on-misra",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1039",
    "name": "Empty throws (\"throw;\") should only be used in the compound statements of catch handlers",
    "defaultSeverity": "CRITICAL",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eCatch blocks define how to deal with exceptions. It is possible to partially handle an exception before passing it on to a higher level for\ncomplete handling with the empty throw statement \u003ccode\u003ethrow;\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eHowever, when an empty throw is called outside of a catch clause, and there is no exception object to re-throw, the program will call\n\u003ccode\u003estd::terminate\u003c/code\u003e. This will cause the program to end, which is unlikely to be the expected behavior.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eThe rule raises an issue when an empty throw expression is used outside of a catch clause.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre\u003e\nvoid f(int i) {\n  if (i \u0026lt;\u003d 0) {\n    throw;   // Noncompliant: it will call std::terminate() if f1 is called while no exception is active\n  }\n}\n\nvoid g(int i) {\n  try {\n    f(i);\n    throw; // Noncompliant\n  } catch (...) {\n    doSomething();\n  }\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre\u003e\nvoid f(int i) {\n  try {\n    if (i \u0026lt;\u003d 0) {\n      throw std::out_of_range(\"Invalid negative index.\");\n    }\n  } catch (const std::out_of_range\u0026amp; e) { // The catch block handles partially the exception\n    std::cout \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; \u0027\\n\u0027;\n    if (i \u0026lt; 0) {\n      throw; // And passes control to the next exception handler\n    }\n  }\n}\n\nvoid g(int i) noexcept {\n  try {\n    f(i);\n  } catch (...) {\n    // The catch block handles the re-throw from f\n    doSomething();\n  }\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/throw\"\u003e\u003ccode\u003ethrow\u003c/code\u003e expression\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/error/terminate\"\u003e\u003ccode\u003estd::terminate\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 15-1-3 - An empty throw (\u003ccode\u003ethrow;\u003c/code\u003e) shall only be used in the compound-statement of a catch handler. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eCatch blocks define how to deal with exceptions. It is possible to partially handle an exception before passing it on to a higher level for\ncomplete handling with the empty throw statement \u003ccode\u003ethrow;\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eHowever, when an empty throw is called outside of a catch clause, and there is no exception object to re-throw, the program will call\n\u003ccode\u003estd::terminate\u003c/code\u003e. This will cause the program to end, which is unlikely to be the expected behavior.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eThe rule raises an issue when an empty throw expression is used outside of a catch clause.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre\u003e\nvoid f(int i) {\n  if (i \u0026lt;\u003d 0) {\n    throw;   // Noncompliant: it will call std::terminate() if f1 is called while no exception is active\n  }\n}\n\nvoid g(int i) {\n  try {\n    f(i);\n    throw; // Noncompliant\n  } catch (...) {\n    doSomething();\n  }\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre\u003e\nvoid f(int i) {\n  try {\n    if (i \u0026lt;\u003d 0) {\n      throw std::out_of_range(\"Invalid negative index.\");\n    }\n  } catch (const std::out_of_range\u0026amp; e) { // The catch block handles partially the exception\n    std::cout \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; \u0027\\n\u0027;\n    if (i \u0026lt; 0) {\n      throw; // And passes control to the next exception handler\n    }\n  }\n}\n\nvoid g(int i) noexcept {\n  try {\n    f(i);\n  } catch (...) {\n    // The catch block handles the re-throw from f\n    doSomething();\n  }\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/throw\"\u003e\u003ccode\u003ethrow\u003c/code\u003e expression\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/error/terminate\"\u003e\u003ccode\u003estd::terminate\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 15-1-3 - An empty throw (\u003ccode\u003ethrow;\u003c/code\u003e) shall only be used in the compound-statement of a catch handler. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "based-on-misra"
    ],
    "deprecatedKeys": [
      "cpp:EmptyThrowOutsideHandler"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5639",
    "name": "Track comments matching a regular expression",
    "defaultSeverity": "INFO",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThis rule will be triggered when a comment matches one of the given regular expressions.\u003c/p\u003e\n\u003cp\u003eFor example, the following configuration raises issues for two different situations, each line contains a message followed by a POSIX regular\nexpression separated by a pipe \u003ccode\u003e|\u003c/code\u003e character.\u003c/p\u003e\n\u003cpre\u003e\nThis comment should be reviewed.|.*REVIEW.*\nDo not hardcode passwords.|.*(123456|password).*\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThis rule will be triggered when a comment matches one of the given regular expressions.\u003c/p\u003e\n\u003cp\u003eFor example, the following configuration raises issues for two different situations, each line contains a message followed by a POSIX regular\nexpression separated by a pipe \u003ccode\u003e|\u003c/code\u003e character.\u003c/p\u003e\n\u003cpre\u003e\nThis comment should be reviewed.|.*REVIEW.*\nDo not hardcode passwords.|.*(123456|password).*\n\u003c/pre\u003e"
      }
    ],
    "params": {
      "regularExpressionsToDetect": {
        "key": "regularExpressionsToDetect",
        "name": "regularExpressionsToDetect",
        "description": "Line separated list of strings with the format (see description for an example): message|POSIX regular expression",
        "type": "TEXT",
        "multiple": false,
        "possibleValues": []
      }
    },
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:M23_087",
    "name": "A virtual base class shall only be cast to a derived class by means of \"dynamic_cast\"",
    "defaultSeverity": "BLOCKER",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 8.2.1\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eThis rule applies to both pointer and reference casts.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eThe behaviour when casting from a virtual base class to a derived class is only well defined when \u003ccode\u003edynamic_cast\u003c/code\u003e is used, whilst the use\nof the other casts can result in \u003cem\u003eundefined behaviour\u003c/em\u003e. Since C++17, a \u003ccode\u003estatic_cast\u003c/code\u003e from a virtual base class is now\n\u003cem\u003eill-formed\u003c/em\u003e, but some compilers may not yet issue a diagnostic. This rule ensures that all cases are detected.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nclass B  { };\nclass D: public virtual B { };\n\nD d;\nB * pB  \u003d \u0026amp;d;\nD * pD1 \u003d reinterpret_cast\u0026lt; D * \u0026gt;( pB  );   // Non-compliant\nD * pD2 \u003d dynamic_cast\u0026lt; D * \u0026gt;( pB  );       // Compliant - pD2 may be null\nD \u0026amp; D3  \u003d dynamic_cast\u0026lt; D \u0026amp; \u0026gt;( *pB );       // Compliant - may throw an exception\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003e{rule:cpp:S5302} targets the same defect as this rule but for a non-mission-critical context.\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 8.2.1\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eThis rule applies to both pointer and reference casts.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eThe behaviour when casting from a virtual base class to a derived class is only well defined when \u003ccode\u003edynamic_cast\u003c/code\u003e is used, whilst the use\nof the other casts can result in \u003cem\u003eundefined behaviour\u003c/em\u003e. Since C++17, a \u003ccode\u003estatic_cast\u003c/code\u003e from a virtual base class is now\n\u003cem\u003eill-formed\u003c/em\u003e, but some compilers may not yet issue a diagnostic. This rule ensures that all cases are detected.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nclass B  { };\nclass D: public virtual B { };\n\nD d;\nB * pB  \u003d \u0026amp;d;\nD * pD1 \u003d reinterpret_cast\u0026lt; D * \u0026gt;( pB  );   // Non-compliant\nD * pD2 \u003d dynamic_cast\u0026lt; D * \u0026gt;( pB  );       // Compliant - pD2 may be null\nD \u0026amp; D3  \u003d dynamic_cast\u0026lt; D \u0026amp; \u0026gt;( *pB );       // Compliant - may throw an exception\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003e{rule:cpp:S5302} targets the same defect as this rule but for a non-mission-critical context.\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "misra-c++2023",
      "misra-required"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:M23_083",
    "name": "The \"declaration\" of an object should contain no more than two levels of pointer indirection",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 11.3.2\u003c/p\u003e\n\u003cp\u003eCategory: Advisory\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eAny \u003cem\u003etypedef-name\u003c/em\u003e appearing in a \u003cem\u003edeclaration\u003c/em\u003e [1] is treated as if it were replaced by the type that it denotes.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e the pointer decay that occurs when declaring a function parameter of array type introduces a level of pointer\nindirection.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eUse of more than two levels of indirection can seriously impair the ability to understand the behaviour of the code, and therefore should be\navoided.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\ntypedef int8_t * INTPTR1;\nusing INTPTR2 \u003d int8_t *;\n\n\nstruct s\n{\n  int8_t *   s1;                                // Compliant\n  int8_t **  s2;                                // Compliant\n  int8_t *** s3;                                // Non-compliant\n};\n\nstruct s *   ps1;                               // Compliant\nstruct s **  ps2;                               // Compliant\nstruct s *** ps3;                               // Non-compliant\n\nint8_t **  (   *pfunc1 )();                     // Compliant\nint8_t **  (  **pfunc2 )();                     // Compliant\nint8_t **  ( ***pfunc3 )();                     // Non-compliant\nint8_t *** (  **pfunc4 )();                     // Non-compliant\n\nvoid function( int8_t  *   par1,                // Compliant\n               int8_t  **  par2,                // Compliant\n               int8_t  *** par3,                // Non-compliant\n               INTPTR1 *   par4,                // Compliant\n               INTPTR1 *   const * const par5,  // Non-compliant\n               int8_t  *   par6[],              // Compliant\n               int8_t  **  par7[],              // Non-compliant\n               int8_t  ** \u0026amp;par8)                // Compliant\n\n{\n   int8_t  *   ptr1;                            // Compliant\n   int8_t  **  ptr2;                            // Compliant\n   int8_t  *** ptr3;                            // Non-compliant\n   INTPTR2 *   ptr4;                            // Compliant\n   INTPTR2 *   const * const ptr5;              // Non-compliant\n   int8_t  *   ptr6[ 10 ];                      // Compliant\n   int8_t  **  ptr7[ 10 ];                      // Compliant\n}\n\u003c/pre\u003e\n\u003cp\u003eExplanation of types:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003epar1\u003c/code\u003e and \u003ccode\u003eptr1\u003c/code\u003e are of type pointer to \u003ccode\u003eint8_t\u003c/code\u003e. \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003epar2\u003c/code\u003e and \u003ccode\u003eptr2\u003c/code\u003e are of type pointer to pointer to \u003ccode\u003eint8_t\u003c/code\u003e. \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003epar3\u003c/code\u003e and \u003ccode\u003eptr3\u003c/code\u003e are of type pointer to a pointer to a pointer to \u003ccode\u003eint8_t\u003c/code\u003e. This is three levels and is\n  non-compliant. \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003epar4\u003c/code\u003e and \u003ccode\u003eptr4\u003c/code\u003e are expanded to a type of pointer to a pointer to \u003ccode\u003eint8_t\u003c/code\u003e. \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003epar5\u003c/code\u003e and \u003ccode\u003eptr5\u003c/code\u003e are expanded to a type of const pointer to a const pointer to a pointer to \u003ccode\u003eint8_t\u003c/code\u003e. This is\n  three levels and is non-compliant. \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003epar6\u003c/code\u003e is of type pointer to pointer to \u003ccode\u003eint8_t\u003c/code\u003e because arrays are converted to a pointer to the initial element of the\n  array. \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003eptr6\u003c/code\u003e is of type array of pointers to \u003ccode\u003eint8_t\u003c/code\u003e. \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003epar7\u003c/code\u003e is of type pointer to pointer to pointer to \u003ccode\u003eint8_t\u003c/code\u003e because arrays are converted to a pointer to the initial\n  element of the array. This is three levels and is non-compliant. \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003eptr7\u003c/code\u003e is of type array of pointer to pointer to \u003ccode\u003eint8_t\u003c/code\u003e. This is compliant. \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003epar8\u003c/code\u003e is of type reference to pointer to pointer to \u003ccode\u003eint8_t\u003c/code\u003e. This is compliant. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eGlossary\u003c/h3\u003e\n\u003ch4\u003e[1] Declaration\u003c/h4\u003e\n\u003cp\u003eA \u003cem\u003edeclaration\u003c/em\u003e introduces the name of an \u003cem\u003eentity\u003c/em\u003e into a \u003cem\u003etranslation unit\u003c/em\u003e (see [basic.def]/1).\u003c/p\u003e\n\u003cp\u003eAn \u003cem\u003eentity\u003c/em\u003e may be \u003cem\u003edeclared\u003c/em\u003e several times. The first \u003cem\u003edeclaration\u003c/em\u003e of an \u003cem\u003eentity\u003c/em\u003e in a \u003cem\u003etranslation unit\u003c/em\u003e is\ncalled an \u003cem\u003eintroduction\u003c/em\u003e [2]. All subsequent \u003cem\u003edeclarations\u003c/em\u003e are called \u003cem\u003eredeclarations\u003c/em\u003e [3].\u003c/p\u003e\n\u003cp\u003eA \u003cem\u003edefinition\u003c/em\u003e [4] is a \u003cem\u003edeclaration\u003c/em\u003e, as described in [basic.def]/2.\u003c/p\u003e\n\u003ch4\u003e[2] Introduction\u003c/h4\u003e\n\u003cp\u003eSee \u003cem\u003edeclaration\u003c/em\u003e [1].\u003c/p\u003e\n\u003ch4\u003e[3] Redeclaration\u003c/h4\u003e\n\u003cp\u003eSee \u003cem\u003edeclaration\u003c/em\u003e [1].\u003c/p\u003e\n\u003ch4\u003e[4] Definition\u003c/h4\u003e\n\u003cp\u003eSee \u003cem\u003edeclaration\u003c/em\u003e [1].\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003e{rule:cpp:S943} targets the same defect as this rule but for a non-mission-critical context.\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 11.3.2\u003c/p\u003e\n\u003cp\u003eCategory: Advisory\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eAny \u003cem\u003etypedef-name\u003c/em\u003e appearing in a \u003cem\u003edeclaration\u003c/em\u003e [1] is treated as if it were replaced by the type that it denotes.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e the pointer decay that occurs when declaring a function parameter of array type introduces a level of pointer\nindirection.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eUse of more than two levels of indirection can seriously impair the ability to understand the behaviour of the code, and therefore should be\navoided.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\ntypedef int8_t * INTPTR1;\nusing INTPTR2 \u003d int8_t *;\n\n\nstruct s\n{\n  int8_t *   s1;                                // Compliant\n  int8_t **  s2;                                // Compliant\n  int8_t *** s3;                                // Non-compliant\n};\n\nstruct s *   ps1;                               // Compliant\nstruct s **  ps2;                               // Compliant\nstruct s *** ps3;                               // Non-compliant\n\nint8_t **  (   *pfunc1 )();                     // Compliant\nint8_t **  (  **pfunc2 )();                     // Compliant\nint8_t **  ( ***pfunc3 )();                     // Non-compliant\nint8_t *** (  **pfunc4 )();                     // Non-compliant\n\nvoid function( int8_t  *   par1,                // Compliant\n               int8_t  **  par2,                // Compliant\n               int8_t  *** par3,                // Non-compliant\n               INTPTR1 *   par4,                // Compliant\n               INTPTR1 *   const * const par5,  // Non-compliant\n               int8_t  *   par6[],              // Compliant\n               int8_t  **  par7[],              // Non-compliant\n               int8_t  ** \u0026amp;par8)                // Compliant\n\n{\n   int8_t  *   ptr1;                            // Compliant\n   int8_t  **  ptr2;                            // Compliant\n   int8_t  *** ptr3;                            // Non-compliant\n   INTPTR2 *   ptr4;                            // Compliant\n   INTPTR2 *   const * const ptr5;              // Non-compliant\n   int8_t  *   ptr6[ 10 ];                      // Compliant\n   int8_t  **  ptr7[ 10 ];                      // Compliant\n}\n\u003c/pre\u003e\n\u003cp\u003eExplanation of types:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003epar1\u003c/code\u003e and \u003ccode\u003eptr1\u003c/code\u003e are of type pointer to \u003ccode\u003eint8_t\u003c/code\u003e. \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003epar2\u003c/code\u003e and \u003ccode\u003eptr2\u003c/code\u003e are of type pointer to pointer to \u003ccode\u003eint8_t\u003c/code\u003e. \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003epar3\u003c/code\u003e and \u003ccode\u003eptr3\u003c/code\u003e are of type pointer to a pointer to a pointer to \u003ccode\u003eint8_t\u003c/code\u003e. This is three levels and is\n  non-compliant. \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003epar4\u003c/code\u003e and \u003ccode\u003eptr4\u003c/code\u003e are expanded to a type of pointer to a pointer to \u003ccode\u003eint8_t\u003c/code\u003e. \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003epar5\u003c/code\u003e and \u003ccode\u003eptr5\u003c/code\u003e are expanded to a type of const pointer to a const pointer to a pointer to \u003ccode\u003eint8_t\u003c/code\u003e. This is\n  three levels and is non-compliant. \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003epar6\u003c/code\u003e is of type pointer to pointer to \u003ccode\u003eint8_t\u003c/code\u003e because arrays are converted to a pointer to the initial element of the\n  array. \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003eptr6\u003c/code\u003e is of type array of pointers to \u003ccode\u003eint8_t\u003c/code\u003e. \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003epar7\u003c/code\u003e is of type pointer to pointer to pointer to \u003ccode\u003eint8_t\u003c/code\u003e because arrays are converted to a pointer to the initial\n  element of the array. This is three levels and is non-compliant. \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003eptr7\u003c/code\u003e is of type array of pointer to pointer to \u003ccode\u003eint8_t\u003c/code\u003e. This is compliant. \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003epar8\u003c/code\u003e is of type reference to pointer to pointer to \u003ccode\u003eint8_t\u003c/code\u003e. This is compliant. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eGlossary\u003c/h3\u003e\n\u003ch4\u003e[1] Declaration\u003c/h4\u003e\n\u003cp\u003eA \u003cem\u003edeclaration\u003c/em\u003e introduces the name of an \u003cem\u003eentity\u003c/em\u003e into a \u003cem\u003etranslation unit\u003c/em\u003e (see [basic.def]/1).\u003c/p\u003e\n\u003cp\u003eAn \u003cem\u003eentity\u003c/em\u003e may be \u003cem\u003edeclared\u003c/em\u003e several times. The first \u003cem\u003edeclaration\u003c/em\u003e of an \u003cem\u003eentity\u003c/em\u003e in a \u003cem\u003etranslation unit\u003c/em\u003e is\ncalled an \u003cem\u003eintroduction\u003c/em\u003e [2]. All subsequent \u003cem\u003edeclarations\u003c/em\u003e are called \u003cem\u003eredeclarations\u003c/em\u003e [3].\u003c/p\u003e\n\u003cp\u003eA \u003cem\u003edefinition\u003c/em\u003e [4] is a \u003cem\u003edeclaration\u003c/em\u003e, as described in [basic.def]/2.\u003c/p\u003e\n\u003ch4\u003e[2] Introduction\u003c/h4\u003e\n\u003cp\u003eSee \u003cem\u003edeclaration\u003c/em\u003e [1].\u003c/p\u003e\n\u003ch4\u003e[3] Redeclaration\u003c/h4\u003e\n\u003cp\u003eSee \u003cem\u003edeclaration\u003c/em\u003e [1].\u003c/p\u003e\n\u003ch4\u003e[4] Definition\u003c/h4\u003e\n\u003cp\u003eSee \u003cem\u003edeclaration\u003c/em\u003e [1].\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003e{rule:cpp:S943} targets the same defect as this rule but for a non-mission-critical context.\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "misra-advisory",
      "misra-c++2023",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1032",
    "name": "Function templates should not be specialized",
    "defaultSeverity": "BLOCKER",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eExplicit specializations of function templates are not considered in overload resolution, only the main template. As a consequence, the function\nthat will be selected might very well be different from what seems natural to the developer, leading to hard to understand bugs. Moreover, function\ntemplates don’t allow partial specialization.\u003c/p\u003e\n\u003cp\u003eInstead of specializing a function template, you may choose to overload it with another template or non template function, since a more specialized\noverload will be preferred to a generic overload.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\ntemplate \u0026lt;typename T\u0026gt; void f ( T );\ntemplate \u0026lt;\u0026gt; void f\u0026lt;char*\u0026gt; ( char * ); // explicit specialization, noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\ntemplate \u0026lt;typename T\u0026gt; void f ( T );\nvoid f( char * ); // overload, compliant\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThis rule ignores cases where none of the main function template arguments depend on a template parameter: Even if the code could still be written\nwithout function template specialization (by deferring the real work to a class template, and offering specializations of this class template as\ncustomization point to the user), there is no risk of confusion for overload resolution in these cases.\u003c/p\u003e\n\u003cpre\u003e\n// For real code, use std::numeric_limits instead...\ntemplate \u0026lt;class T\u0026gt; T max();\ntemplate \u0026lt;\u0026gt; float max\u0026lt;float\u0026gt;() { return FLT_MAX; }  // Ignored\n\ntemplate\u0026lt;class T\u0026gt;\nbool isMax(T t){\n    return t \u003d\u003d max\u0026lt;T\u0026gt;();\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 14-8-1 \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#t144-dont-specialize-function-templates\"\u003eT.144: Don’t specialize\n  function templates\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eExplicit specializations of function templates are not considered in overload resolution, only the main template. As a consequence, the function\nthat will be selected might very well be different from what seems natural to the developer, leading to hard to understand bugs. Moreover, function\ntemplates don’t allow partial specialization.\u003c/p\u003e\n\u003cp\u003eInstead of specializing a function template, you may choose to overload it with another template or non template function, since a more specialized\noverload will be preferred to a generic overload.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\ntemplate \u0026lt;typename T\u0026gt; void f ( T );\ntemplate \u0026lt;\u0026gt; void f\u0026lt;char*\u0026gt; ( char * ); // explicit specialization, noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\ntemplate \u0026lt;typename T\u0026gt; void f ( T );\nvoid f( char * ); // overload, compliant\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThis rule ignores cases where none of the main function template arguments depend on a template parameter: Even if the code could still be written\nwithout function template specialization (by deferring the real work to a class template, and offering specializations of this class template as\ncustomization point to the user), there is no risk of confusion for overload resolution in these cases.\u003c/p\u003e\n\u003cpre\u003e\n// For real code, use std::numeric_limits instead...\ntemplate \u0026lt;class T\u0026gt; T max();\ntemplate \u0026lt;\u0026gt; float max\u0026lt;float\u0026gt;() { return FLT_MAX; }  // Ignored\n\ntemplate\u0026lt;class T\u0026gt;\nbool isMax(T t){\n    return t \u003d\u003d max\u0026lt;T\u0026gt;();\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 14-8-1 \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#t144-dont-specialize-function-templates\"\u003eT.144: Don’t specialize\n  function templates\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "cppcoreguidelines"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5995",
    "name": "\"bind\" should not be used",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eUsing \u003ccode\u003estd::bind\u003c/code\u003e or \u003ccode\u003eboost::bind\u003c/code\u003e allows to create a wrapper to a function where some arguments are bound to fixed values,\nor the order of arguments is changed. However, this way of wrapping a function comes with some issues:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The code is not really clear, the usage of placeholders makes it difficult to follow, \u003c/li\u003e\n  \u003cli\u003e The complexity of the implementation of \u003ccode\u003estd::bind\u003c/code\u003e often results in sub-optimal code, \u003c/li\u003e\n  \u003cli\u003e The possibilities offered by \u003ccode\u003ebind\u003c/code\u003e are limited, for instance, it’s not possible to bind a function with variable arguments, \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003ebind\u003c/code\u003e allows to silently discard some arguments, which is often not what was expected, \u003c/li\u003e\n  \u003cli\u003e Fixed arguments are evaluated when \u003ccode\u003ebind\u003c/code\u003e is called, not when the bound function is called, which might be surprising in some cases,\n  \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003ebind\u003c/code\u003e requires to take the address of a function, which can be difficult (if the function is overloaded) or not recommended (for\n  standard library functions, see {rule:cpp:S5180}). \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eTo create such a wrapper, it is usually better to:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e either write a simple lambda that just calls the wrapped function with the full power of the language concerning how the arguments are going to\n  be tinkered with. \u003c/li\u003e\n  \u003cli\u003e or, if the function \u003ccode\u003ebind\u003c/code\u003e is only applied to the first arguments, call \u003ccode\u003estd::bind_front\u003c/code\u003e that has been introduced in\n  C++20 and that is safer to use and a simpler replacement than lambdas. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nconstexpr int multiply(int a, int b) {return a*b;}\nauto flipMultiplication \u003d std::bind(multiply, std::placeholders::_2, std::placeholders::_1); // Noncompliant\nint i \u003d flipMultiplication (6, 7);\n\nstruct Logger {\n    string subsystem;\n    template \u0026lt;class T\u0026gt;\n    void operator()(T const \u0026amp;what) {  cout \u0026lt;\u0026lt; subsystem \u0026lt;\u0026lt; \": \" \u0026lt;\u0026lt; what \u0026lt;\u0026lt; \"\\n\"; }\n};\n\nvoid f(){\n    Logger net {\"network\"};\n    // Noncompliant in C++14, compliant by exception in C++11 because it would require a polymorphic lambda\n    auto networkLog \u003d bind(net, _1);\n    networkLog(4);\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nconstexpr int multiply(int a, int b) {return a*b;}\nauto flipMultiplication \u003d [](int a, int b) {return multiply(b, a);}; // Compliant\nint i2 \u003d flipMultiplication (6, 7);\n\nvoid f(){\n    Logger net {\"network\"};\n    auto networkLog \u003d [\u0026amp;](auto what) {net(what);}; // Compliant\n    networkLog(4);\n}{code}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eBefore C++14 lambda was limited and could not capture by move or be polymorphic. Therefore, if the call to \u003ccode\u003ebind\u003c/code\u003e makes use of those\nfeatures, it will not be reported in C++11.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://abseil.io/tips/108\"\u003eAbseil - Avoid std::bind\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e Effective modern C++ item 34: Prefer lambdas to \u003ccode\u003estd::bind\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eUsing \u003ccode\u003estd::bind\u003c/code\u003e or \u003ccode\u003eboost::bind\u003c/code\u003e allows to create a wrapper to a function where some arguments are bound to fixed values,\nor the order of arguments is changed. However, this way of wrapping a function comes with some issues:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The code is not really clear, the usage of placeholders makes it difficult to follow, \u003c/li\u003e\n  \u003cli\u003e The complexity of the implementation of \u003ccode\u003estd::bind\u003c/code\u003e often results in sub-optimal code, \u003c/li\u003e\n  \u003cli\u003e The possibilities offered by \u003ccode\u003ebind\u003c/code\u003e are limited, for instance, it’s not possible to bind a function with variable arguments, \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003ebind\u003c/code\u003e allows to silently discard some arguments, which is often not what was expected, \u003c/li\u003e\n  \u003cli\u003e Fixed arguments are evaluated when \u003ccode\u003ebind\u003c/code\u003e is called, not when the bound function is called, which might be surprising in some cases,\n  \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003ebind\u003c/code\u003e requires to take the address of a function, which can be difficult (if the function is overloaded) or not recommended (for\n  standard library functions, see {rule:cpp:S5180}). \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eTo create such a wrapper, it is usually better to:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e either write a simple lambda that just calls the wrapped function with the full power of the language concerning how the arguments are going to\n  be tinkered with. \u003c/li\u003e\n  \u003cli\u003e or, if the function \u003ccode\u003ebind\u003c/code\u003e is only applied to the first arguments, call \u003ccode\u003estd::bind_front\u003c/code\u003e that has been introduced in\n  C++20 and that is safer to use and a simpler replacement than lambdas. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nconstexpr int multiply(int a, int b) {return a*b;}\nauto flipMultiplication \u003d std::bind(multiply, std::placeholders::_2, std::placeholders::_1); // Noncompliant\nint i \u003d flipMultiplication (6, 7);\n\nstruct Logger {\n    string subsystem;\n    template \u0026lt;class T\u0026gt;\n    void operator()(T const \u0026amp;what) {  cout \u0026lt;\u0026lt; subsystem \u0026lt;\u0026lt; \": \" \u0026lt;\u0026lt; what \u0026lt;\u0026lt; \"\\n\"; }\n};\n\nvoid f(){\n    Logger net {\"network\"};\n    // Noncompliant in C++14, compliant by exception in C++11 because it would require a polymorphic lambda\n    auto networkLog \u003d bind(net, _1);\n    networkLog(4);\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nconstexpr int multiply(int a, int b) {return a*b;}\nauto flipMultiplication \u003d [](int a, int b) {return multiply(b, a);}; // Compliant\nint i2 \u003d flipMultiplication (6, 7);\n\nvoid f(){\n    Logger net {\"network\"};\n    auto networkLog \u003d [\u0026amp;](auto what) {net(what);}; // Compliant\n    networkLog(4);\n}{code}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eBefore C++14 lambda was limited and could not capture by move or be polymorphic. Therefore, if the call to \u003ccode\u003ebind\u003c/code\u003e makes use of those\nfeatures, it will not be reported in C++11.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://abseil.io/tips/108\"\u003eAbseil - Avoid std::bind\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e Effective modern C++ item 34: Prefer lambdas to \u003ccode\u003estd::bind\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "clumsy",
      "since-c++11"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S2123",
    "name": "Values should not be uselessly incremented",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eA value that is incremented or decremented and then not stored is at best wasted code and at worst a bug.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint pickNumber() {\n  int i \u003d 0;\n  int j \u003d 0;\n\n  i \u003d i++; // Noncompliant; i is still zero\n\n  return j++; // Noncompliant; 0 returned\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint pickNumber() {\n  int i \u003d 0;\n  int j \u003d 0;\n\n  i++;\n  return ++j;\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eA value that is incremented or decremented and then not stored is at best wasted code and at worst a bug.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint pickNumber() {\n  int i \u003d 0;\n  int j \u003d 0;\n\n  i \u003d i++; // Noncompliant; i is still zero\n\n  return j++; // Noncompliant; 0 returned\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint pickNumber() {\n  int i \u003d 0;\n  int j \u003d 0;\n\n  i++;\n  return ++j;\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "unused"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S2486",
    "name": "Exceptions should not be ignored",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhen exceptions occur, it is usually a bad idea to simply ignore them. Instead, it is better to handle them properly, or at least to log them.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid save() {\n  try {\n    saveDocument();\n  } catch (const std::exception\u0026amp; ex) {\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid save() {\n  try {\n    saveDocument();\n  } catch (const std::exception\u0026amp; ex) {\n    log \u0026lt;\u0026lt; \"Exception while saving the document: \" \u0026lt;\u0026lt; ex.what();\n  }\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/Top10/A09_2021-Security_Logging_and_Monitoring_Failures/\"\u003eOWASP Top 10 2021 Category A9\u003c/a\u003e - Security Logging and\n  Monitoring Failures \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/www-project-top-ten/2017/A10_2017-Insufficient_Logging%2526Monitoring\"\u003eOWASP Top 10 2017 Category A10\u003c/a\u003e -\n  Insufficient Logging \u0026amp; Monitoring \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/390\"\u003eMITRE, CWE-390\u003c/a\u003e - Detection of Error Condition Without Action \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhen exceptions occur, it is usually a bad idea to simply ignore them. Instead, it is better to handle them properly, or at least to log them.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid save() {\n  try {\n    saveDocument();\n  } catch (const std::exception\u0026amp; ex) {\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid save() {\n  try {\n    saveDocument();\n  } catch (const std::exception\u0026amp; ex) {\n    log \u0026lt;\u0026lt; \"Exception while saving the document: \" \u0026lt;\u0026lt; ex.what();\n  }\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/Top10/A09_2021-Security_Logging_and_Monitoring_Failures/\"\u003eOWASP Top 10 2021 Category A9\u003c/a\u003e - Security Logging and\n  Monitoring Failures \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/www-project-top-ten/2017/A10_2017-Insufficient_Logging%2526Monitoring\"\u003eOWASP Top 10 2017 Category A10\u003c/a\u003e -\n  Insufficient Logging \u0026amp; Monitoring \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/390\"\u003eMITRE, CWE-390\u003c/a\u003e - Detection of Error Condition Without Action \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cwe",
      "error-handling",
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S3696",
    "name": "Non-exception types should not be thrown",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eJust because you \u003cem\u003ecan\u003c/em\u003e stick your hand in a blender, that doesn’t mean you \u003cem\u003eshould\u003c/em\u003e. Similarly, you \u003cem\u003ecan\u003c/em\u003e \u003ccode\u003ethrow\u003c/code\u003e\nanything, but that doesn’t mean you \u003cem\u003eshould\u003c/em\u003e \u003ccode\u003ethrow\u003c/code\u003e something that’s not derived at some level from\n\u003ccode\u003estd::exception\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eIf you can’t find an existing exception type that suitably conveys what you need to convey, then you should extend \u003ccode\u003estd::exception\u003c/code\u003e to\ncreate one.\u003c/p\u003e\n\u003cp\u003eSpecifically, part of the point of throwing exceptions is to communicate about the conditions of the error, but primitives have far less ability to\ncommunicate meaningfully than \u003ccode\u003eexception\u003c/code\u003es. And, the creation of some other object type could itself \u003ccode\u003ethrow\u003c/code\u003e an exception,\nresulting in program termination.\u003c/p\u003e\n\u003cp\u003eFurther, \u003ccode\u003ecatch\u003c/code\u003eing non-exception types is painful and fraught with the potential for (further) error.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nthrow 42;                               // Noncompliant\nthrow \"Invalid negative index.\";        // Noncompliant\nthrow std::string(\"Permission denied\"); // Noncompliant\nthrow nullptr;                          // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nthrow std::domain_error(\"User ID not found.\");\nthrow std::out_of_range(\"Invalid negative index.\");\nthrow std::system_error(EACCES, std::system_category());\nthrow std::invalid_argument(\"Unexpected null \u0027user_id\u0027 argument.\");\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 15-1-2 - NULL shall not be thrown explicitly. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eJust because you \u003cem\u003ecan\u003c/em\u003e stick your hand in a blender, that doesn’t mean you \u003cem\u003eshould\u003c/em\u003e. Similarly, you \u003cem\u003ecan\u003c/em\u003e \u003ccode\u003ethrow\u003c/code\u003e\nanything, but that doesn’t mean you \u003cem\u003eshould\u003c/em\u003e \u003ccode\u003ethrow\u003c/code\u003e something that’s not derived at some level from\n\u003ccode\u003estd::exception\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eIf you can’t find an existing exception type that suitably conveys what you need to convey, then you should extend \u003ccode\u003estd::exception\u003c/code\u003e to\ncreate one.\u003c/p\u003e\n\u003cp\u003eSpecifically, part of the point of throwing exceptions is to communicate about the conditions of the error, but primitives have far less ability to\ncommunicate meaningfully than \u003ccode\u003eexception\u003c/code\u003es. And, the creation of some other object type could itself \u003ccode\u003ethrow\u003c/code\u003e an exception,\nresulting in program termination.\u003c/p\u003e\n\u003cp\u003eFurther, \u003ccode\u003ecatch\u003c/code\u003eing non-exception types is painful and fraught with the potential for (further) error.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nthrow 42;                               // Noncompliant\nthrow \"Invalid negative index.\";        // Noncompliant\nthrow std::string(\"Permission denied\"); // Noncompliant\nthrow nullptr;                          // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nthrow std::domain_error(\"User ID not found.\");\nthrow std::out_of_range(\"Invalid negative index.\");\nthrow std::system_error(EACCES, std::system_category());\nthrow std::invalid_argument(\"Unexpected null \u0027user_id\u0027 argument.\");\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 15-1-2 - NULL shall not be thrown explicitly. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "api-design",
      "based-on-misra",
      "error-handling"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1155",
    "name": "\"empty()\" or \"is_empty()\" should be used to test for emptiness",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhen you call \u003ccode\u003eempty()\u003c/code\u003e or \u003ccode\u003eis_empty()\u003c/code\u003e, it clearly communicates the code’s intention, which is to check if the collection is\nempty. Using \u003ccode\u003esize() \u003d\u003d 0\u003c/code\u003e for this purpose is less direct and makes the code slightly more complex.\u003c/p\u003e\n\u003cp\u003eMoreover, depending on the implementation, the \u003ccode\u003esize()\u003c/code\u003e, \u003ccode\u003elength()\u003c/code\u003e, or \u003ccode\u003ecount()\u003c/code\u003e methods can have a time\ncomplexity of \u003ccode\u003eO(n)\u003c/code\u003e where \u003ccode\u003en\u003c/code\u003e is the number of elements in the collection. On the other hand, \u003ccode\u003eempty()\u003c/code\u003e and\n\u003ccode\u003eis_empty()\u003c/code\u003e simply check if there is at least one element in the collection, which is a constant time operation, \u003ccode\u003eO(1)\u003c/code\u003e.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid fun(const std::vector\u0026lt;int\u0026gt; \u0026amp;myVector) {\n  if (myVector.size() \u003d\u003d 0) { // Noncompliant\n    // do something\n  }\n}\n\u003c/pre\u003e\n\u003cp\u003ePrefer using \u003ccode\u003eempty()\u003c/code\u003e or \u003ccode\u003eis_empty()\u003c/code\u003e to test for emptiness over \u003ccode\u003esize()\u003c/code\u003e, \u003ccode\u003elength()\u003c/code\u003e, or\n\u003ccode\u003ecount()\u003c/code\u003e.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid fun(const std::vector\u0026lt;int\u0026gt; \u0026amp;myVector) {\n  if (myVector.empty()) {\n    // do something\n  }\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#t143-dont-write-unintentionally-non-generic-code\"\u003eT.143: Don’t\n  write unintentionally non-generic code\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhen you call \u003ccode\u003eempty()\u003c/code\u003e or \u003ccode\u003eis_empty()\u003c/code\u003e, it clearly communicates the code’s intention, which is to check if the collection is\nempty. Using \u003ccode\u003esize() \u003d\u003d 0\u003c/code\u003e for this purpose is less direct and makes the code slightly more complex.\u003c/p\u003e\n\u003cp\u003eMoreover, depending on the implementation, the \u003ccode\u003esize()\u003c/code\u003e, \u003ccode\u003elength()\u003c/code\u003e, or \u003ccode\u003ecount()\u003c/code\u003e methods can have a time\ncomplexity of \u003ccode\u003eO(n)\u003c/code\u003e where \u003ccode\u003en\u003c/code\u003e is the number of elements in the collection. On the other hand, \u003ccode\u003eempty()\u003c/code\u003e and\n\u003ccode\u003eis_empty()\u003c/code\u003e simply check if there is at least one element in the collection, which is a constant time operation, \u003ccode\u003eO(1)\u003c/code\u003e.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid fun(const std::vector\u0026lt;int\u0026gt; \u0026amp;myVector) {\n  if (myVector.size() \u003d\u003d 0) { // Noncompliant\n    // do something\n  }\n}\n\u003c/pre\u003e\n\u003cp\u003ePrefer using \u003ccode\u003eempty()\u003c/code\u003e or \u003ccode\u003eis_empty()\u003c/code\u003e to test for emptiness over \u003ccode\u003esize()\u003c/code\u003e, \u003ccode\u003elength()\u003c/code\u003e, or\n\u003ccode\u003ecount()\u003c/code\u003e.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid fun(const std::vector\u0026lt;int\u0026gt; \u0026amp;myVector) {\n  if (myVector.empty()) {\n    // do something\n  }\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#t143-dont-write-unintentionally-non-generic-code\"\u003eT.143: Don’t\n  write unintentionally non-generic code\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "clumsy",
      "cppcoreguidelines"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S3574",
    "name": "Redundant lambda return types should be omitted",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eIt is a best practice to make lambda return types implicit whenever possible. First and foremost, doing so avoids implicit conversions, which could\nresult in data or precision loss. Second, omitting the return type often helps future-proof the code.\u003c/p\u003e\n\u003cp\u003eThe issue is raised when explicit return types are used.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n// Noncompliant: the explicit return types are redundant.\n[](int i) -\u0026gt; int { return i + 42; }\n[]() -\u0026gt; auto { return foo(); }\n[](int x) -\u0026gt; std::vector\u0026lt;int\u0026gt; { return std::vector\u0026lt;int\u0026gt;{ x }; }\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n// Compliant: no explicit return type.\n[](int i) { return i + 42; }\n[]() { return foo(); }\n[](int x) { return std::vector\u0026lt;int\u0026gt;{ x }; }\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThere are a few exceptions to this rule.\u003c/p\u003e\n\u003cp\u003eFirst, no issue is raised when the compiler is not deducing the same type by itself. This can happen when a conversion is requested.\u003c/p\u003e\n\u003cpre\u003e\n// Compliant: the compiler would deduce a different return type.\n[](int x) -\u0026gt; double { return x; }\n[](float x) -\u0026gt; int { return x; } // Precision loss, see S5276.\n\u003c/pre\u003e\n\u003cp\u003eThe compiler also deduces a different type when there are no \u003ccode\u003ereturn\u003c/code\u003e statements and the explicit return type is not\n\u003ccode\u003evoid\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\n// Compliant: removing these explicit return types would result in a different signature.\n[](int x) -\u0026gt; int { throw std::runtime_error(\"No more eggs\"); }\n[](int x) -\u0026gt; int { std::terminate(); }\n\u003c/pre\u003e\n\u003cp\u003eAnother similar situation is when references are involved: instead, the compiler deduces a value without an explicit return type. This can have an\nimpact on both correctness and performance.\u003c/p\u003e\n\u003cpre\u003e\n// Compliant: removing the explicit return type would return a copy.\n[](std::vector\u0026lt;int\u0026gt;\u0026amp; data) -\u0026gt; auto\u0026amp; {\n    std::sort(data.begin(), data.end());\n    return data;\n}\n\u003c/pre\u003e\n\u003cp\u003eAdditionally, no issues are raised when the deduction of the return type is not available. This is the case with C++20 coroutines in their lambda\nform.\u003c/p\u003e\n\u003cpre\u003e\n// Compliant: coroutine lambdas cannot rely on type deduction.\n[]() -\u0026gt; Task { co_await std::suspend_always{}; }\n\u003c/pre\u003e\n\u003cp\u003eIn some other cases, removing the explicit return type would result in ill-formed programs. This is the case when using initializer lists or\naggregate initializations.\u003c/p\u003e\n\u003cpre\u003e\n// Compliant: type deduction wouldn\u0027t work.\n[](int x) -\u0026gt; std::vector\u0026lt;int\u0026gt; { return { x }; }\n[]() -\u0026gt; std::array\u0026lt;int, 4\u0026gt; { return { 1, 2, 3, 4 }; }\n\u003c/pre\u003e\n\u003cp\u003eRemoving the explicit return type when a lambda has multiple \u003ccode\u003ereturn\u003c/code\u003e statements of different types would also result in ill-formed\nprograms. Here are two examples where the explicit return type introduces useful implicit conversions.\u003c/p\u003e\n\u003cpre\u003e\n// Compliant: omitting the return type would result in a compilation error.\n[](Base* ptr) -\u0026gt; Derived* {\n    if (auto* derived \u003d dynamic_cast\u0026lt;Derived*\u0026gt;(ptr)) {\n        actOnDerived(derived);\n        return derived;\n    }\n\n    // \"nullptr_t\" mismatches the previous return type \"Derived*\".\n    return nullptr;\n}\n\n// Compliant: omitting the return type would result in a compilation error.\n[](std::string_view request) -\u0026gt; std::variant\u0026lt;Error, Data\u0026gt; {\n    if (!isRequestValid(request)) {\n        return Error{ \"invalid request\" };\n    }\n\n    auto reader \u003d readRequest(request);\n    // \"Data\" mismatches the previous return type \"Error\".\n    return Data{ reader.data(), reader.size() };\n}\n\u003c/pre\u003e\n\u003cp\u003eFinally, this rule does not trigger on explicit template-dependent or constrained return types since they can have a use of their own, help\nreadability or improve maintainability.\u003c/p\u003e\n\u003cpre\u003e\n// Compliant: enforce \"process()\" returns a reference.\n[](auto x) -\u0026gt; auto\u0026amp; { return process(x); }\n\n// Compliant: ensure the lambda returns a reference when \"f()\" does.\n[f](auto arg) -\u0026gt; decltype(f(arg)) { return f(arg); }\n\n// Compliant: the return type restricts possible input types.\n[](auto x) -\u0026gt; std::enable_if_t\u0026lt;std::is_integral_v\u0026lt;decltype(x)\u0026gt;\u0026gt; { process(x); }\n\ntemplate \u0026lt;typename T\u0026gt;\nT getGlobalProperty(std::string_view name, T defaultValue) { /* ... */ }\n\n// Compliant: the return type is constrained (C++20) and can help maintainability.\nauto getProperty \u003d [](std::string_view name) -\u0026gt; std::totally_ordered auto {\n    return getGlobalProperty(name, 0);\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S5276}: Implicit casts should not lower precision \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eIt is a best practice to make lambda return types implicit whenever possible. First and foremost, doing so avoids implicit conversions, which could\nresult in data or precision loss. Second, omitting the return type often helps future-proof the code.\u003c/p\u003e\n\u003cp\u003eThe issue is raised when explicit return types are used.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n// Noncompliant: the explicit return types are redundant.\n[](int i) -\u0026gt; int { return i + 42; }\n[]() -\u0026gt; auto { return foo(); }\n[](int x) -\u0026gt; std::vector\u0026lt;int\u0026gt; { return std::vector\u0026lt;int\u0026gt;{ x }; }\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n// Compliant: no explicit return type.\n[](int i) { return i + 42; }\n[]() { return foo(); }\n[](int x) { return std::vector\u0026lt;int\u0026gt;{ x }; }\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThere are a few exceptions to this rule.\u003c/p\u003e\n\u003cp\u003eFirst, no issue is raised when the compiler is not deducing the same type by itself. This can happen when a conversion is requested.\u003c/p\u003e\n\u003cpre\u003e\n// Compliant: the compiler would deduce a different return type.\n[](int x) -\u0026gt; double { return x; }\n[](float x) -\u0026gt; int { return x; } // Precision loss, see S5276.\n\u003c/pre\u003e\n\u003cp\u003eThe compiler also deduces a different type when there are no \u003ccode\u003ereturn\u003c/code\u003e statements and the explicit return type is not\n\u003ccode\u003evoid\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\n// Compliant: removing these explicit return types would result in a different signature.\n[](int x) -\u0026gt; int { throw std::runtime_error(\"No more eggs\"); }\n[](int x) -\u0026gt; int { std::terminate(); }\n\u003c/pre\u003e\n\u003cp\u003eAnother similar situation is when references are involved: instead, the compiler deduces a value without an explicit return type. This can have an\nimpact on both correctness and performance.\u003c/p\u003e\n\u003cpre\u003e\n// Compliant: removing the explicit return type would return a copy.\n[](std::vector\u0026lt;int\u0026gt;\u0026amp; data) -\u0026gt; auto\u0026amp; {\n    std::sort(data.begin(), data.end());\n    return data;\n}\n\u003c/pre\u003e\n\u003cp\u003eAdditionally, no issues are raised when the deduction of the return type is not available. This is the case with C++20 coroutines in their lambda\nform.\u003c/p\u003e\n\u003cpre\u003e\n// Compliant: coroutine lambdas cannot rely on type deduction.\n[]() -\u0026gt; Task { co_await std::suspend_always{}; }\n\u003c/pre\u003e\n\u003cp\u003eIn some other cases, removing the explicit return type would result in ill-formed programs. This is the case when using initializer lists or\naggregate initializations.\u003c/p\u003e\n\u003cpre\u003e\n// Compliant: type deduction wouldn\u0027t work.\n[](int x) -\u0026gt; std::vector\u0026lt;int\u0026gt; { return { x }; }\n[]() -\u0026gt; std::array\u0026lt;int, 4\u0026gt; { return { 1, 2, 3, 4 }; }\n\u003c/pre\u003e\n\u003cp\u003eRemoving the explicit return type when a lambda has multiple \u003ccode\u003ereturn\u003c/code\u003e statements of different types would also result in ill-formed\nprograms. Here are two examples where the explicit return type introduces useful implicit conversions.\u003c/p\u003e\n\u003cpre\u003e\n// Compliant: omitting the return type would result in a compilation error.\n[](Base* ptr) -\u0026gt; Derived* {\n    if (auto* derived \u003d dynamic_cast\u0026lt;Derived*\u0026gt;(ptr)) {\n        actOnDerived(derived);\n        return derived;\n    }\n\n    // \"nullptr_t\" mismatches the previous return type \"Derived*\".\n    return nullptr;\n}\n\n// Compliant: omitting the return type would result in a compilation error.\n[](std::string_view request) -\u0026gt; std::variant\u0026lt;Error, Data\u0026gt; {\n    if (!isRequestValid(request)) {\n        return Error{ \"invalid request\" };\n    }\n\n    auto reader \u003d readRequest(request);\n    // \"Data\" mismatches the previous return type \"Error\".\n    return Data{ reader.data(), reader.size() };\n}\n\u003c/pre\u003e\n\u003cp\u003eFinally, this rule does not trigger on explicit template-dependent or constrained return types since they can have a use of their own, help\nreadability or improve maintainability.\u003c/p\u003e\n\u003cpre\u003e\n// Compliant: enforce \"process()\" returns a reference.\n[](auto x) -\u0026gt; auto\u0026amp; { return process(x); }\n\n// Compliant: ensure the lambda returns a reference when \"f()\" does.\n[f](auto arg) -\u0026gt; decltype(f(arg)) { return f(arg); }\n\n// Compliant: the return type restricts possible input types.\n[](auto x) -\u0026gt; std::enable_if_t\u0026lt;std::is_integral_v\u0026lt;decltype(x)\u0026gt;\u0026gt; { process(x); }\n\ntemplate \u0026lt;typename T\u0026gt;\nT getGlobalProperty(std::string_view name, T defaultValue) { /* ... */ }\n\n// Compliant: the return type is constrained (C++20) and can help maintainability.\nauto getProperty \u003d [](std::string_view name) -\u0026gt; std::totally_ordered auto {\n    return getGlobalProperty(name, 0);\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S5276}: Implicit casts should not lower precision \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "bad-practice",
      "since-c++11"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1035",
    "name": "An exception object should not have pointer type",
    "defaultSeverity": "CRITICAL",
    "type": "BUG",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhen an exception is a pointer, it is difficult for the code that catches the exception to determine whether or not it needs to delete the\npointed-to object. It is even more complicated than a traditional manual memory management scenario because the \u003ccode\u003ethrow\u003c/code\u003e and the\ncorresponding \u003ccode\u003ecatch\u003c/code\u003e can be far apart.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eThrowing by value is more straightforward and less error-prone than using a pointer as an exception object.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nstd::out_of_range globalException(\"Index too high\");\n\nvoid fn(int i) {\n  // In this situation, the developer writing the \"catch\" has no way of knowing if the object pointed to by\n  // the exception should be deleted or not\n  if (i \u0026gt; 10) {\n    throw (\u0026amp;globalException); // Noncompliant: the catch is supposed not to delete the pointer\n  } else {\n    throw (new std::out_of_range{\"Invalid index\"}); // Noncompliant: the catch is supposed to delete the pointer\n  }\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nstd::out_of_range globalException(\"Index too high\");\n\nvoid fn(int i) {\n  if (i \u0026gt; 10) {\n    throw (globalException); // Compliant: it throws a copy of the global variable\n  } else {\n    throw (std::out_of_range{\"Invalid index\"}); // Compliant: it throws a new object\n  }\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++ 2008, 15-0-2 - An exception object should not have pointer type. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S1044} - Exception classes should be caught by reference \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhen an exception is a pointer, it is difficult for the code that catches the exception to determine whether or not it needs to delete the\npointed-to object. It is even more complicated than a traditional manual memory management scenario because the \u003ccode\u003ethrow\u003c/code\u003e and the\ncorresponding \u003ccode\u003ecatch\u003c/code\u003e can be far apart.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eThrowing by value is more straightforward and less error-prone than using a pointer as an exception object.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nstd::out_of_range globalException(\"Index too high\");\n\nvoid fn(int i) {\n  // In this situation, the developer writing the \"catch\" has no way of knowing if the object pointed to by\n  // the exception should be deleted or not\n  if (i \u0026gt; 10) {\n    throw (\u0026amp;globalException); // Noncompliant: the catch is supposed not to delete the pointer\n  } else {\n    throw (new std::out_of_range{\"Invalid index\"}); // Noncompliant: the catch is supposed to delete the pointer\n  }\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nstd::out_of_range globalException(\"Index too high\");\n\nvoid fn(int i) {\n  if (i \u0026gt; 10) {\n    throw (globalException); // Compliant: it throws a copy of the global variable\n  } else {\n    throw (std::out_of_range{\"Invalid index\"}); // Compliant: it throws a new object\n  }\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++ 2008, 15-0-2 - An exception object should not have pointer type. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S1044} - Exception classes should be caught by reference \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "misra-c++2008"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S3698",
    "name": "Non-exception types should not be caught",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThrowing as an exception an object that is not derived from \u003ccode\u003estd::exception\u003c/code\u003e is a bad practice. It is usually unreliable, meaningless,\nand a source of type clashes.\u003c/p\u003e\n\u003cp\u003eFor the same reason, catching a non-exception type is a sign that your application has a bad exception-handling design. You should use standard\nexception types or create your own exception types that inherit at some level from \u003ccode\u003estd::exception\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\ntry {\n  /* code that can throw: 42 */\n} catch (int ex) { // Noncompliant\n  if (ex \u003d\u003d 42) {\n    /*...*/\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\ntry {\n  /* code that can throw: std::domain_error(\"User ID not found.\") */\n} catch (const std::domain_error\u0026amp; ex) {\n  /*...*/\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#e14-use-purpose-designed-user-defined-types-as-exceptions-not-built-in-types\"\u003eE.14: Use purpose-designed user-defined types as exceptions (not built-in types)\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThrowing as an exception an object that is not derived from \u003ccode\u003estd::exception\u003c/code\u003e is a bad practice. It is usually unreliable, meaningless,\nand a source of type clashes.\u003c/p\u003e\n\u003cp\u003eFor the same reason, catching a non-exception type is a sign that your application has a bad exception-handling design. You should use standard\nexception types or create your own exception types that inherit at some level from \u003ccode\u003estd::exception\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\ntry {\n  /* code that can throw: 42 */\n} catch (int ex) { // Noncompliant\n  if (ex \u003d\u003d 42) {\n    /*...*/\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\ntry {\n  /* code that can throw: std::domain_error(\"User ID not found.\") */\n} catch (const std::domain_error\u0026amp; ex) {\n  /*...*/\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#e14-use-purpose-designed-user-defined-types-as-exceptions-not-built-in-types\"\u003eE.14: Use purpose-designed user-defined types as exceptions (not built-in types)\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "cppcoreguidelines",
      "error-handling"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1036",
    "name": "Control should not be transferred into a complex logic block using a \"goto\" or a \"switch\" statement",
    "defaultSeverity": "BLOCKER",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eHaving a \u003ccode\u003eswitch\u003c/code\u003e and its cases wholly encompassed by a control structure such as a \u003ccode\u003etry\u003c/code\u003e, \u003ccode\u003e@try\u003c/code\u003e,\n\u003ccode\u003ecatch\u003c/code\u003e, \u003ccode\u003e@catch\u003c/code\u003e, or a loop is perfectly acceptable. (\u003ccode\u003etry\u003c/code\u003e and \u003ccode\u003ecatch\u003c/code\u003e are used hereafter to refer to\nboth variants.) It is also acceptable to have a \u003ccode\u003egoto\u003c/code\u003e and its target label wholly encompassed in a control structure.\u003c/p\u003e\n\u003cp\u003eWhat is not acceptable is using a \u003ccode\u003egoto\u003c/code\u003e or \u003ccode\u003ecase\u003c/code\u003e to suddenly jump into the body of a \u003ccode\u003etry\u003c/code\u003e, \u003ccode\u003ecatch\u003c/code\u003e,\nObjective-C \u003ccode\u003e@finally\u003c/code\u003e, or loop structure. Tangling labels or \u003ccode\u003eswitch\u003c/code\u003e blocks with other control structures results in code that\nis difficult, if not impossible to understand. More importantly, when it compiles (some of these constructs won’t compile under ISO-conformant\ncompilers), it can lead to unexpected results. Therefore this usage should be strictly avoided.\u003c/p\u003e\n\u003cp\u003eThis C++ code sample, which is also applicable to Objective-C if \u003ccode\u003etry\u003c/code\u003e and \u003ccode\u003ecatch\u003c/code\u003e are converted to \u003ccode\u003e@try\u003c/code\u003e and\n\u003ccode\u003e@catch\u003c/code\u003e, demonstrates jumping into a \u003ccode\u003eswitch\u003c/code\u003e and into a \u003ccode\u003etry\u003c/code\u003e and \u003ccode\u003ecatch\u003c/code\u003e :\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid f ( int32_t i )\n{\n  if ( 10 \u003d\u003d i )\n  {\n    goto Label_10; // Noncompliant; goto transfers control into try block\n  }\n\n  if ( 11 \u003d\u003d i )\n  {\n    goto Label_11; // Noncompliant; goto transfers control into catch block\n  }\n\n  switch ( i )\n  {\n    case 1:\n      try\n      {\n        Label_10:\n        case 2:  // Noncompliant; switch transfers control into try block\n          // Action\n          break;\n      }\n      catch ( ... )\n      {\n        Label_11:\n        case 3: // Noncompliant; switch transfers control into catch block\n          // Action\n          break;\n      }\n      break;\n    default:\n    {\n      // Default Action\n      break;\n    }\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid f ( int32_t i )\n{\n  switch ( i )\n  {\n    case 1:\n    case 2:\n      // Action\n      break;\n    case 3:\n      // Action\n      break;\n    case 10:\n\n    default:\n    {\n      // Default Action\n      break;\n    }\n  }\n\n  try\n  {\n    if ( 2 \u003d\u003d i || 10 \u003d\u003d i)\n    {\n      // Action\n    }\n  }\n  catch ( ... )\n  {\n    if (3 \u003d\u003d i || 11 \u003d\u003d i)\n    {\n      // Action\n    }\n  }\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 15-0-3 - Control shall not be transferred into a try or catch block using goto or switch statement \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/zdYxBQ\"\u003eCERT, MSC20-C.\u003c/a\u003e - Do not use a switch statement to transfer control into a complex\n  block \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eHaving a \u003ccode\u003eswitch\u003c/code\u003e and its cases wholly encompassed by a control structure such as a \u003ccode\u003etry\u003c/code\u003e, \u003ccode\u003e@try\u003c/code\u003e,\n\u003ccode\u003ecatch\u003c/code\u003e, \u003ccode\u003e@catch\u003c/code\u003e, or a loop is perfectly acceptable. (\u003ccode\u003etry\u003c/code\u003e and \u003ccode\u003ecatch\u003c/code\u003e are used hereafter to refer to\nboth variants.) It is also acceptable to have a \u003ccode\u003egoto\u003c/code\u003e and its target label wholly encompassed in a control structure.\u003c/p\u003e\n\u003cp\u003eWhat is not acceptable is using a \u003ccode\u003egoto\u003c/code\u003e or \u003ccode\u003ecase\u003c/code\u003e to suddenly jump into the body of a \u003ccode\u003etry\u003c/code\u003e, \u003ccode\u003ecatch\u003c/code\u003e,\nObjective-C \u003ccode\u003e@finally\u003c/code\u003e, or loop structure. Tangling labels or \u003ccode\u003eswitch\u003c/code\u003e blocks with other control structures results in code that\nis difficult, if not impossible to understand. More importantly, when it compiles (some of these constructs won’t compile under ISO-conformant\ncompilers), it can lead to unexpected results. Therefore this usage should be strictly avoided.\u003c/p\u003e\n\u003cp\u003eThis C++ code sample, which is also applicable to Objective-C if \u003ccode\u003etry\u003c/code\u003e and \u003ccode\u003ecatch\u003c/code\u003e are converted to \u003ccode\u003e@try\u003c/code\u003e and\n\u003ccode\u003e@catch\u003c/code\u003e, demonstrates jumping into a \u003ccode\u003eswitch\u003c/code\u003e and into a \u003ccode\u003etry\u003c/code\u003e and \u003ccode\u003ecatch\u003c/code\u003e :\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid f ( int32_t i )\n{\n  if ( 10 \u003d\u003d i )\n  {\n    goto Label_10; // Noncompliant; goto transfers control into try block\n  }\n\n  if ( 11 \u003d\u003d i )\n  {\n    goto Label_11; // Noncompliant; goto transfers control into catch block\n  }\n\n  switch ( i )\n  {\n    case 1:\n      try\n      {\n        Label_10:\n        case 2:  // Noncompliant; switch transfers control into try block\n          // Action\n          break;\n      }\n      catch ( ... )\n      {\n        Label_11:\n        case 3: // Noncompliant; switch transfers control into catch block\n          // Action\n          break;\n      }\n      break;\n    default:\n    {\n      // Default Action\n      break;\n    }\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid f ( int32_t i )\n{\n  switch ( i )\n  {\n    case 1:\n    case 2:\n      // Action\n      break;\n    case 3:\n      // Action\n      break;\n    case 10:\n\n    default:\n    {\n      // Default Action\n      break;\n    }\n  }\n\n  try\n  {\n    if ( 2 \u003d\u003d i || 10 \u003d\u003d i)\n    {\n      // Action\n    }\n  }\n  catch ( ... )\n  {\n    if (3 \u003d\u003d i || 11 \u003d\u003d i)\n    {\n      // Action\n    }\n  }\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 15-0-3 - Control shall not be transferred into a try or catch block using goto or switch statement \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/zdYxBQ\"\u003eCERT, MSC20-C.\u003c/a\u003e - Do not use a switch statement to transfer control into a complex\n  block \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cert",
      "lock-in",
      "misra-c++2008",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S2245",
    "name": "Using pseudorandom number generators (PRNGs) is security-sensitive",
    "defaultSeverity": "CRITICAL",
    "type": "SECURITY_HOTSPOT",
    "cleanCodeAttribute": "TRUSTWORTHY",
    "defaultImpacts": {
      "SECURITY": "HIGH"
    },
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eUsing pseudorandom number generators (PRNGs) is security-sensitive. For example, it has led in the past to the following vulnerabilities:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"http://cve.mitre.org/cgi-bin/cvename.cgi?name\u003dCVE-2013-6386\"\u003eCVE-2013-6386\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"http://cve.mitre.org/cgi-bin/cvename.cgi?name\u003dCVE-2006-3419\"\u003eCVE-2006-3419\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"http://cve.mitre.org/cgi-bin/cvename.cgi?name\u003dCVE-2008-4102\"\u003eCVE-2008-4102\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWhen software generates predictable values in a context requiring unpredictability, it may be possible for an attacker to guess the next value that\nwill be generated, and use this guess to impersonate another user or access sensitive information.\u003c/p\u003e\n\u003cp\u003eAs the functions rely on a pseudorandom number generator, they should not be used for security-critical applications or for protecting sensitive\ndata.\u003c/p\u003e"
      },
      {
        "key": "assess_the_problem",
        "htmlContent": "\u003ch2\u003eAsk Yourself Whether\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e the code using the generated value requires it to be unpredictable. It is the case for all encryption mechanisms or when a secret value, such\n  as a password, is hashed. \u003c/li\u003e\n  \u003cli\u003e the function you use generates a value which can be predicted (pseudo-random). \u003c/li\u003e\n  \u003cli\u003e the generated value is used multiple times. \u003c/li\u003e\n  \u003cli\u003e an attacker can access the generated value. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere is a risk if you answered yes to any of those questions.\u003c/p\u003e\n\u003ch2\u003eSensitive Code Example\u003c/h2\u003e\n\u003cpre\u003e\n#include \u0026lt;random\u0026gt;\n// ...\n\nvoid f() {\n  int random_int \u003d std::rand(); // Sensitive\n}\n\u003c/pre\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003ch2\u003eRecommended Secure Coding Practices\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e Use functions which rely on a strong random number generator such as \u003ccode\u003erandombytes_uniform()\u003c/code\u003e or \u003ccode\u003erandombytes_buf()\u003c/code\u003e from\n  \u003ccode\u003elibsodium\u003c/code\u003e, or \u003ccode\u003erandomize()\u003c/code\u003e from Botan. \u003c/li\u003e\n  \u003cli\u003e Use the generated random values only once. \u003c/li\u003e\n  \u003cli\u003e You should not expose the generated random value. If you have to store it, make sure that the database or file is secure. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eCompliant Solution\u003c/h2\u003e\n\u003cpre\u003e\n#include \u0026lt;sodium.h\u0026gt;\n#include \u0026lt;botan/system_rng.h\u0026gt;\n// ...\n\nvoid f() {\n  char random_chars[10];\n  randombytes_buf(random_chars, 10); // Compliant\n  uint32_t random_int \u003d randombytes_uniform(10); // Compliant\n\n  uint8_t random_chars[10];\n  Botan::System_RNG system;\n  system.randomize(random_chars, 10); // Compliant\n}\n\u003c/pre\u003e\n\u003ch2\u003eSee\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/Top10/A02_2021-Cryptographic_Failures/\"\u003eOWASP Top 10 2021 Category A2\u003c/a\u003e - Cryptographic Failures \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://www.owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\"\u003eOWASP Top 10 2017 Category A3\u003c/a\u003e - Sensitive Data\n  Exposure \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://mobile-security.gitbook.io/masvs/security-requirements/0x08-v3-cryptography_verification_requirements\"\u003eMobile AppSec\n  Verification Standard\u003c/a\u003e - Cryptography Requirements \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/www-project-mobile-top-10/2016-risks/m5-insufficient-cryptography\"\u003eOWASP Mobile Top 10 2016 Category M5\u003c/a\u003e -\n  Insufficient Cryptography \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/338\"\u003eMITRE, CWE-338\u003c/a\u003e - Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)\n  \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/330\"\u003eMITRE, CWE-330\u003c/a\u003e - Use of Insufficiently Random Values \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/326\"\u003eMITRE, CWE-326\u003c/a\u003e - Inadequate Encryption Strength \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/1241\"\u003eMITRE, CWE-1241\u003c/a\u003e - Use of Predictable Algorithm in Random Number Generator \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/UNcxBQ\"\u003eCERT, MSC30-C.\u003c/a\u003e - Do not use the rand() function for generating pseudorandom numbers\n  \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/2ns-BQ\"\u003eCERT, MSC50-CPP.\u003c/a\u003e - Do not use std::rand() for generating pseudorandom numbers \u003c/li\u003e\n  \u003cli\u003e Derived from FindSecBugs rule \u003ca href\u003d\"https://h3xstream.github.io/find-sec-bugs/bugs.htm#PREDICTABLE_RANDOM\"\u003ePredictable Pseudo Random Number\n  Generator\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cert",
      "cwe"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": [],
    "vulnerabilityProbability": "MEDIUM"
  },
  {
    "key": "cpp:S3576",
    "name": "\"final\" classes should not have \"virtual\" functions",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eSince \u003ccode\u003efinal\u003c/code\u003e classes can’t be extended, indicating that functions in such a class are overrideable by adding the \u003ccode\u003evirtual\u003c/code\u003e\nspecifier is possibly misguided, and definitely confusing.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass Base {\n  virtual void f1();\n};\n\nclass C final : Base {\n  virtual void f1();  // Noncompliant\n  virtual void f2();  // Noncompliant\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nclass Base {\n  virtual void f1();\n};\n\nclass C final : Base {\n  void f1() override;\n  void f2();\n};\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S3471} - \"override\" or \"final\" should be used instead of \"virtual\" \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eSince \u003ccode\u003efinal\u003c/code\u003e classes can’t be extended, indicating that functions in such a class are overrideable by adding the \u003ccode\u003evirtual\u003c/code\u003e\nspecifier is possibly misguided, and definitely confusing.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass Base {\n  virtual void f1();\n};\n\nclass C final : Base {\n  virtual void f1();  // Noncompliant\n  virtual void f2();  // Noncompliant\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nclass Base {\n  virtual void f1();\n};\n\nclass C final : Base {\n  void f1() override;\n  void f2();\n};\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S3471} - \"override\" or \"final\" should be used instead of \"virtual\" \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "confusing",
      "since-c++11"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S4426",
    "name": "Cryptographic keys should be robust",
    "defaultSeverity": "CRITICAL",
    "type": "VULNERABILITY",
    "cleanCodeAttribute": "TRUSTWORTHY",
    "defaultImpacts": {
      "SECURITY": "HIGH"
    },
    "description": "\u003cp\u003eThis vulnerability exposes encrypted data to attacks whose goal is to recover the plaintext.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eEncryption algorithms are essential for protecting sensitive information and ensuring secure communications in a variety of domains. They are used\nfor several important reasons:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Confidentiality, privacy, and intellectual property protection \u003c/li\u003e\n  \u003cli\u003e Security during transmission or on storage devices \u003c/li\u003e\n  \u003cli\u003e Data integrity, general trust, and authentication \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWhen selecting encryption algorithms, tools, or combinations, you should also consider two things:\u003c/p\u003e\n\u003col\u003e\n  \u003cli\u003e No encryption is unbreakable. \u003c/li\u003e\n  \u003cli\u003e The strength of an encryption algorithm is usually measured by the effort required to crack it within a reasonable time frame. \u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eIn today’s cryptography, the length of the \u003cstrong\u003ekey\u003c/strong\u003e directly affects the security level of cryptographic algorithms.\u003c/p\u003e\n\u003cp\u003eNote that depending on the algorithm, the term \u003cstrong\u003ekey\u003c/strong\u003e refers to a different mathematical property. For example:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e For RSA, the key is the product of two large prime numbers, also called the \u003cstrong\u003emodulus\u003c/strong\u003e. \u003c/li\u003e\n  \u003cli\u003e For AES and Elliptic Curve Cryptography (ECC), the key is only a sequence of randomly generated bytes.\n    \u003cul\u003e\n      \u003cli\u003e In some cases, AES keys are derived from a master key or a passphrase using a Key Derivation Function (KDF) like PBKDF2 (Password-Based Key\n      Derivation Function 2) \u003c/li\u003e\n    \u003c/ul\u003e  \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIf an application uses a key that is considered short and \u003cstrong\u003einsecure\u003c/strong\u003e, the encrypted data is exposed to attacks aimed at getting at\nthe plaintext.\u003c/p\u003e\n\u003cp\u003eIn general, it is best practice to expect a breach: that a user or organization with malicious intent will perform cryptographic attacks on this\ndata after obtaining it by other means.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eAfter retrieving encrypted data and performing cryptographic attacks on it on a given timeframe, attackers can recover the plaintext that\nencryption was supposed to protect.\u003c/p\u003e\n\u003cp\u003eDepending on the recovered data, the impact may vary.\u003c/p\u003e\n\u003cp\u003eBelow are some real-world scenarios that illustrate the potential impact of an attacker exploiting the vulnerability.\u003c/p\u003e\n\u003ch4\u003eAdditional attack surface\u003c/h4\u003e\n\u003cp\u003eBy modifying the plaintext of the encrypted message, an attacker may be able to trigger additional vulnerabilities in the code. An attacker can\nfurther exploit a system to obtain more information.\u003cbr\u003e Encrypted values are often considered trustworthy because it would not be possible for a\nthird party to modify them under normal circumstances.\u003c/p\u003e\n\u003ch4\u003eBreach of confidentiality and privacy\u003c/h4\u003e\n\u003cp\u003eWhen encrypted data contains personal or sensitive information, its retrieval by an attacker can lead to privacy violations, identity theft,\nfinancial loss, reputational damage, or unauthorized access to confidential systems.\u003c/p\u003e\n\u003cp\u003eIn this scenario, the company, its employees, users, and partners could be seriously affected.\u003c/p\u003e\n\u003cp\u003eThe impact is twofold, as data breaches and exposure of encrypted data can undermine trust in the organization, as customers, clients and\nstakeholders may lose confidence in the organization’s ability to protect their sensitive data.\u003c/p\u003e\n\u003ch4\u003eLegal and compliance issues\u003c/h4\u003e\n\u003cp\u003eIn many industries and locations, there are legal and compliance requirements to protect sensitive data. If encrypted data is compromised and the\nplaintext can be recovered, companies face legal consequences, penalties, or violations of privacy laws.\u003c/p\u003e\n\u003ch2\u003eHow to fix it in Botan\u003c/h2\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003cp\u003eThe following code examples either explicitly or implicitly generate keys. Note that there are differences in the size of the keys depending on the\nalgorithm.\u003c/p\u003e\n\u003cp\u003eDue to the mathematical properties of the algorithms, the security requirements for the key size vary depending on the algorithm.\u003cbr\u003e For example,\na 256-bit ECC key provides about the same level of security as a 3072-bit RSA key and a 128-bit symmetric key.\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cp\u003eHere is an example of a private key generation with RSA:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;botan/pubkey.h\u0026gt;\n#include \u0026lt;botan/rng.h\u0026gt;\n#include \u0026lt;botan/rsa.h\u0026gt;\n\nvoid encrypt() {\n    std::unique_ptr\u0026lt;Botan::RandomNumberGenerator\u0026gt;   rng(new Botan::System_RNG);\n    Botan::RSA_PrivateKey                           rsaKey(*rng, 1024); // Noncompliant\n}\n\u003c/pre\u003e\n\u003cp\u003eHere is an example with the generation of a key as part of a Discrete Logarithmic (DL) group, a Digital Signature Algorithm (DSA) parameter:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;botan/dl_group.h\u0026gt;\n\nvoid encrypt() {\n    Botan::DL_Group(\"dsa/botan/1024\"); // Noncompliant\n}\n\u003c/pre\u003e\n\u003cp\u003eHere is an example of an Elliptic Curve (EC) initialization. It implicitly generates a private key whose size is indicated in the algorithm\nname:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;botan/ec_group.h\u0026gt;\n\nvoid encrypt() {\n    Botan::EC_Group(\"secp160k1\"); // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;botan/pubkey.h\u0026gt;\n#include \u0026lt;botan/rng.h\u0026gt;\n#include \u0026lt;botan/rsa.h\u0026gt;\n\nvoid encrypt() {\n    std::unique_ptr\u0026lt;Botan::RandomNumberGenerator\u0026gt;   rng(new Botan::System_RNG);\n    Botan::RSA_PrivateKey                           rsaKey(*rng, 2048);\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;botan/dl_group.h\u0026gt;\n\nvoid encrypt() {\n    Botan::DL_Group(\"dsa/botan/2048\");\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;botan/ec_group.h\u0026gt;\n\nvoid encrypt() {\n    Botan::EC_Group(\"secp224k1\");\n}\n\u003c/pre\u003e\n\u003ch3\u003eHow does this work?\u003c/h3\u003e\n\u003cp\u003eAs a rule of thumb, use the cryptographic algorithms and mechanisms that are considered strong by the cryptographic community.\u003c/p\u003e\n\u003cp\u003eThe appropriate choices are the following.\u003c/p\u003e\n\u003ch4\u003eRSA (Rivest-Shamir-Adleman) and DSA (Digital Signature Algorithm)\u003c/h4\u003e\n\u003cp\u003eThe security of these algorithms depends on the difficulty of attacks attempting to solve their underlying mathematical problem.\u003c/p\u003e\n\u003cp\u003eIn general, a minimum key size of \u003cstrong\u003e2048\u003c/strong\u003e bits is recommended for both.\u003c/p\u003e\n\u003ch4\u003eAES (Advanced Encryption Standard)\u003c/h4\u003e\n\u003cp\u003eAES supports three key sizes: 128 bits, 192 bits and 256 bits. The security of the AES algorithm is based on the computational complexity of trying\nall possible keys.\u003cbr\u003e A larger key size increases the number of possible keys and makes exhaustive search attacks computationally infeasible.\nTherefore, a 256-bit key provides a higher level of security than a 128-bit or 192-bit key.\u003c/p\u003e\n\u003cp\u003eCurrently, a minimum key size of \u003cstrong\u003e128 bits\u003c/strong\u003e is recommended for AES.\u003c/p\u003e\n\u003ch4\u003eElliptic Curve Cryptography (ECC)\u003c/h4\u003e\n\u003cp\u003eElliptic curve cryptography is also used in various algorithms, such as ECDSA, ECDH, or ECMQV. The length of keys generated with elliptic curve\nalgorithms are mentioned directly in their names. For example, \u003ccode\u003esecp256k1\u003c/code\u003e generates a 256-bits long private key.\u003c/p\u003e\n\u003cp\u003eCurrently, a minimum key size of \u003cstrong\u003e224 bits\u003c/strong\u003e is recommended for EC algorithms.\u003c/p\u003e\n\u003ch3\u003eGoing the extra mile\u003c/h3\u003e\n\u003ch4\u003ePre-Quantum Cryptography\u003c/h4\u003e\n\u003cp\u003eEncrypted data and communications recorded today could be decrypted in the future by an attack from a quantum computer.\u003cbr\u003e It is important to keep\nin mind that NIST-approved digital signature schemes, key agreement, and key transport may need to be replaced with secure quantum-resistant (or\n\"post-quantum\") counterpart.\u003c/p\u003e\n\u003cp\u003eThus, if data is to remain secure beyond 2030, proactive measures should be taken now to ensure its safety.\u003c/p\u003e\n\u003cp\u003e\u003ca href\u003d\"https://www.enisa.europa.eu/publications/post-quantum-cryptography-current-state-and-quantum-mitigation\"\u003eLearn more here\u003c/a\u003e.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eArticles \u0026amp; blog posts\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://learn.microsoft.com/en-us/dotnet/standard/security/vulnerabilities-cbc-mode\"\u003eMicrosoft, Timing vulnerabilities with CBC-mode\n  symmetric decryption using padding\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Padding_oracle_attack\"\u003eWikipedia, Padding Oracle Attack\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Chosen-ciphertext_attack\"\u003eWikipedia, Chosen-Ciphertext Attack\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Chosen-plaintext_attack\"\u003eWikipedia, Chosen-Plaintext Attack\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Semantic_security\"\u003eWikipedia, Semantically Secure Cryptosystems\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Optimal_asymmetric_encryption_padding\"\u003eWikipedia, OAEP\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Galois/Counter_Mode\"\u003eWikipedia, Galois/Counter Mode\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/Top10/A02_2021-Cryptographic_Failures/\"\u003eOWASP Top 10 2021 Category A2\u003c/a\u003e - Cryptographic Failures \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://www.owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\"\u003eOWASP Top 10 2017 Category A3\u003c/a\u003e - Sensitive Data\n  Exposure \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration\"\u003eOWASP Top 10 2017 Category A6\u003c/a\u003e - Security\n  Misconfiguration \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://mobile-security.gitbook.io/masvs/security-requirements/0x08-v3-cryptography_verification_requirements\"\u003eMobile AppSec\n  Verification Standard\u003c/a\u003e - Cryptography Requirements \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/www-project-mobile-top-10/2016-risks/m5-insufficient-cryptography\"\u003eOWASP Mobile Top 10 2016 Category M5\u003c/a\u003e -\n  Insufficient Cryptography \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf\"\u003eNIST 800-131A\u003c/a\u003e - Recommendation for Transitioning the\n  Use of Cryptographic Algorithms and Key Lengths* \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/326\"\u003eMITRE, CWE-326\u003c/a\u003e - Inadequate Encryption\n  Strength \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/327\"\u003eMITRE, CWE-327\u003c/a\u003e - Use of a Broken or Risky Cryptographic Algorithm \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/hDdGBQ\"\u003eCERT, MSC61-J.\u003c/a\u003e - Do not use insecure or weak cryptographic algorithms \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eThis vulnerability exposes encrypted data to attacks whose goal is to recover the plaintext.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eEncryption algorithms are essential for protecting sensitive information and ensuring secure communications in a variety of domains. They are used\nfor several important reasons:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Confidentiality, privacy, and intellectual property protection \u003c/li\u003e\n  \u003cli\u003e Security during transmission or on storage devices \u003c/li\u003e\n  \u003cli\u003e Data integrity, general trust, and authentication \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWhen selecting encryption algorithms, tools, or combinations, you should also consider two things:\u003c/p\u003e\n\u003col\u003e\n  \u003cli\u003e No encryption is unbreakable. \u003c/li\u003e\n  \u003cli\u003e The strength of an encryption algorithm is usually measured by the effort required to crack it within a reasonable time frame. \u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eIn today’s cryptography, the length of the \u003cstrong\u003ekey\u003c/strong\u003e directly affects the security level of cryptographic algorithms.\u003c/p\u003e\n\u003cp\u003eNote that depending on the algorithm, the term \u003cstrong\u003ekey\u003c/strong\u003e refers to a different mathematical property. For example:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e For RSA, the key is the product of two large prime numbers, also called the \u003cstrong\u003emodulus\u003c/strong\u003e. \u003c/li\u003e\n  \u003cli\u003e For AES and Elliptic Curve Cryptography (ECC), the key is only a sequence of randomly generated bytes.\n    \u003cul\u003e\n      \u003cli\u003e In some cases, AES keys are derived from a master key or a passphrase using a Key Derivation Function (KDF) like PBKDF2 (Password-Based Key\n      Derivation Function 2) \u003c/li\u003e\n    \u003c/ul\u003e  \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIf an application uses a key that is considered short and \u003cstrong\u003einsecure\u003c/strong\u003e, the encrypted data is exposed to attacks aimed at getting at\nthe plaintext.\u003c/p\u003e\n\u003cp\u003eIn general, it is best practice to expect a breach: that a user or organization with malicious intent will perform cryptographic attacks on this\ndata after obtaining it by other means.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eAfter retrieving encrypted data and performing cryptographic attacks on it on a given timeframe, attackers can recover the plaintext that\nencryption was supposed to protect.\u003c/p\u003e\n\u003cp\u003eDepending on the recovered data, the impact may vary.\u003c/p\u003e\n\u003cp\u003eBelow are some real-world scenarios that illustrate the potential impact of an attacker exploiting the vulnerability.\u003c/p\u003e\n\u003ch4\u003eAdditional attack surface\u003c/h4\u003e\n\u003cp\u003eBy modifying the plaintext of the encrypted message, an attacker may be able to trigger additional vulnerabilities in the code. An attacker can\nfurther exploit a system to obtain more information.\u003cbr\u003e Encrypted values are often considered trustworthy because it would not be possible for a\nthird party to modify them under normal circumstances.\u003c/p\u003e\n\u003ch4\u003eBreach of confidentiality and privacy\u003c/h4\u003e\n\u003cp\u003eWhen encrypted data contains personal or sensitive information, its retrieval by an attacker can lead to privacy violations, identity theft,\nfinancial loss, reputational damage, or unauthorized access to confidential systems.\u003c/p\u003e\n\u003cp\u003eIn this scenario, the company, its employees, users, and partners could be seriously affected.\u003c/p\u003e\n\u003cp\u003eThe impact is twofold, as data breaches and exposure of encrypted data can undermine trust in the organization, as customers, clients and\nstakeholders may lose confidence in the organization’s ability to protect their sensitive data.\u003c/p\u003e\n\u003ch4\u003eLegal and compliance issues\u003c/h4\u003e\n\u003cp\u003eIn many industries and locations, there are legal and compliance requirements to protect sensitive data. If encrypted data is compromised and the\nplaintext can be recovered, companies face legal consequences, penalties, or violations of privacy laws.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eThe following code examples either explicitly or implicitly generate keys. Note that there are differences in the size of the keys depending on the\nalgorithm.\u003c/p\u003e\n\u003cp\u003eDue to the mathematical properties of the algorithms, the security requirements for the key size vary depending on the algorithm.\u003cbr\u003e For example,\na 256-bit ECC key provides about the same level of security as a 3072-bit RSA key and a 128-bit symmetric key.\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cp\u003eHere is an example of a private key generation with RSA:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;botan/pubkey.h\u0026gt;\n#include \u0026lt;botan/rng.h\u0026gt;\n#include \u0026lt;botan/rsa.h\u0026gt;\n\nvoid encrypt() {\n    std::unique_ptr\u0026lt;Botan::RandomNumberGenerator\u0026gt;   rng(new Botan::System_RNG);\n    Botan::RSA_PrivateKey                           rsaKey(*rng, 1024); // Noncompliant\n}\n\u003c/pre\u003e\n\u003cp\u003eHere is an example with the generation of a key as part of a Discrete Logarithmic (DL) group, a Digital Signature Algorithm (DSA) parameter:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;botan/dl_group.h\u0026gt;\n\nvoid encrypt() {\n    Botan::DL_Group(\"dsa/botan/1024\"); // Noncompliant\n}\n\u003c/pre\u003e\n\u003cp\u003eHere is an example of an Elliptic Curve (EC) initialization. It implicitly generates a private key whose size is indicated in the algorithm\nname:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;botan/ec_group.h\u0026gt;\n\nvoid encrypt() {\n    Botan::EC_Group(\"secp160k1\"); // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;botan/pubkey.h\u0026gt;\n#include \u0026lt;botan/rng.h\u0026gt;\n#include \u0026lt;botan/rsa.h\u0026gt;\n\nvoid encrypt() {\n    std::unique_ptr\u0026lt;Botan::RandomNumberGenerator\u0026gt;   rng(new Botan::System_RNG);\n    Botan::RSA_PrivateKey                           rsaKey(*rng, 2048);\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;botan/dl_group.h\u0026gt;\n\nvoid encrypt() {\n    Botan::DL_Group(\"dsa/botan/2048\");\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;botan/ec_group.h\u0026gt;\n\nvoid encrypt() {\n    Botan::EC_Group(\"secp224k1\");\n}\n\u003c/pre\u003e\n\u003ch3\u003eHow does this work?\u003c/h3\u003e\n\u003cp\u003eAs a rule of thumb, use the cryptographic algorithms and mechanisms that are considered strong by the cryptographic community.\u003c/p\u003e\n\u003cp\u003eThe appropriate choices are the following.\u003c/p\u003e\n\u003ch4\u003eRSA (Rivest-Shamir-Adleman) and DSA (Digital Signature Algorithm)\u003c/h4\u003e\n\u003cp\u003eThe security of these algorithms depends on the difficulty of attacks attempting to solve their underlying mathematical problem.\u003c/p\u003e\n\u003cp\u003eIn general, a minimum key size of \u003cstrong\u003e2048\u003c/strong\u003e bits is recommended for both.\u003c/p\u003e\n\u003ch4\u003eAES (Advanced Encryption Standard)\u003c/h4\u003e\n\u003cp\u003eAES supports three key sizes: 128 bits, 192 bits and 256 bits. The security of the AES algorithm is based on the computational complexity of trying\nall possible keys.\u003cbr\u003e A larger key size increases the number of possible keys and makes exhaustive search attacks computationally infeasible.\nTherefore, a 256-bit key provides a higher level of security than a 128-bit or 192-bit key.\u003c/p\u003e\n\u003cp\u003eCurrently, a minimum key size of \u003cstrong\u003e128 bits\u003c/strong\u003e is recommended for AES.\u003c/p\u003e\n\u003ch4\u003eElliptic Curve Cryptography (ECC)\u003c/h4\u003e\n\u003cp\u003eElliptic curve cryptography is also used in various algorithms, such as ECDSA, ECDH, or ECMQV. The length of keys generated with elliptic curve\nalgorithms are mentioned directly in their names. For example, \u003ccode\u003esecp256k1\u003c/code\u003e generates a 256-bits long private key.\u003c/p\u003e\n\u003cp\u003eCurrently, a minimum key size of \u003cstrong\u003e224 bits\u003c/strong\u003e is recommended for EC algorithms.\u003c/p\u003e\n\u003ch3\u003eGoing the extra mile\u003c/h3\u003e\n\u003ch4\u003ePre-Quantum Cryptography\u003c/h4\u003e\n\u003cp\u003eEncrypted data and communications recorded today could be decrypted in the future by an attack from a quantum computer.\u003cbr\u003e It is important to keep\nin mind that NIST-approved digital signature schemes, key agreement, and key transport may need to be replaced with secure quantum-resistant (or\n\"post-quantum\") counterpart.\u003c/p\u003e\n\u003cp\u003eThus, if data is to remain secure beyond 2030, proactive measures should be taken now to ensure its safety.\u003c/p\u003e\n\u003cp\u003e\u003ca href\u003d\"https://www.enisa.europa.eu/publications/post-quantum-cryptography-current-state-and-quantum-mitigation\"\u003eLearn more here\u003c/a\u003e.\u003c/p\u003e",
        "context": {
          "key": "botan",
          "displayName": "Botan"
        }
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cp\u003eHere is an example of a private key generation with RSA:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"21\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;cryptopp/rsa.h\u0026gt;\n#include \u0026lt;cryptopp/rng.h\u0026gt;\n\nvoid encrypt() {\n    CryptoPP::AutoSeededRandomPool  rng;\n    CryptoPP::InvertibleRSAFunction rsa_trapdoor;\n\n    rsa_trapdoor.GenerateRandomWithKeySize(rng, 1024); // Noncompliant\n}\n\u003c/pre\u003e\n\u003cp\u003eHere is an example of a key generation with the Digital Signature Algorithm (DSA):\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"22\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;cryptopp/dsa.h\u0026gt;\n#include \u0026lt;cryptopp/rng.h\u0026gt;\n\ncryptopp::autoseededrandompool rng;\ncryptopp::dsa::privatekey      dsa_private_key;\n\ndsa_private_key.GenerateRandomWithKeySize(rng, 1024); // Noncompliant\n\u003c/pre\u003e\n\u003cp\u003eHere is an example of a key generation with Diffie-Hellman:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"23\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;cryptopp/dh.h\u0026gt;\n#include \u0026lt;cryptopp/rng.h\u0026gt;\n\ncryptopp::autoseededrandompool rng;\nCryptoPP::DH                   dh;\n\ndh.AccessGroupParameters().GenerateRandomWithKeySize(rng, 1024); // Noncompliant\n\u003c/pre\u003e\n\u003cp\u003eHere is an example of an Elliptic Curve (EC) initialization. It implicitly generates a private key whose size is indicated in the algorithm\nname:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"24\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;cryptopp/osrng.h\u0026gt;\n\nvoid ecnrypt() {\n    CryptoPP::ASN1::secp112r1(); // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"21\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;cryptopp/rsa.h\u0026gt;\n#include \u0026lt;cryptopp/rng.h\u0026gt;\n\nvoid encrypt() {\n    CryptoPP::AutoSeededRandomPool  rng;\n    CryptoPP::InvertibleRSAFunction rsa_trapdoor;\n\n    rsa_trapdoor.GenerateRandomWithKeySize(rng, 2048);\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"22\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;cryptopp/dsa.h\u0026gt;\n#include \u0026lt;cryptopp/rng.h\u0026gt;\n\ncryptopp::autoseededrandompool rng;\ncryptopp::dsa::privatekey      dsa_private_key;\n\ndsa_private_key.GenerateRandomWithKeySize(rng, 2048);\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"23\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;cryptopp/dh.h\u0026gt;\n#include \u0026lt;cryptopp/rng.h\u0026gt;\n\ncryptopp::autoseededrandompool rng;\nCryptoPP::DH                   dh;\n\ndh.AccessGroupParameters().GenerateRandomWithKeySize(rng, 2048);\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"24\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;cryptopp/osrng.h\u0026gt;\n\nvoid ecnrypt() {\n    CryptoPP::ASN1::secp256r1();\n}\n\u003c/pre\u003e\n\u003ch3\u003eHow does this work?\u003c/h3\u003e\n\u003cp\u003eAs a rule of thumb, use the cryptographic algorithms and mechanisms that are considered strong by the cryptographic community.\u003c/p\u003e\n\u003cp\u003eThe appropriate choices are the following.\u003c/p\u003e\n\u003ch4\u003eRSA (Rivest-Shamir-Adleman) and DSA (Digital Signature Algorithm)\u003c/h4\u003e\n\u003cp\u003eThe security of these algorithms depends on the difficulty of attacks attempting to solve their underlying mathematical problem.\u003c/p\u003e\n\u003cp\u003eIn general, a minimum key size of \u003cstrong\u003e2048\u003c/strong\u003e bits is recommended for both.\u003c/p\u003e\n\u003ch4\u003eAES (Advanced Encryption Standard)\u003c/h4\u003e\n\u003cp\u003eAES supports three key sizes: 128 bits, 192 bits and 256 bits. The security of the AES algorithm is based on the computational complexity of trying\nall possible keys.\u003cbr\u003e A larger key size increases the number of possible keys and makes exhaustive search attacks computationally infeasible.\nTherefore, a 256-bit key provides a higher level of security than a 128-bit or 192-bit key.\u003c/p\u003e\n\u003cp\u003eCurrently, a minimum key size of \u003cstrong\u003e128 bits\u003c/strong\u003e is recommended for AES.\u003c/p\u003e\n\u003ch4\u003eElliptic Curve Cryptography (ECC)\u003c/h4\u003e\n\u003cp\u003eElliptic curve cryptography is also used in various algorithms, such as ECDSA, ECDH, or ECMQV. The length of keys generated with elliptic curve\nalgorithms are mentioned directly in their names. For example, \u003ccode\u003esecp256k1\u003c/code\u003e generates a 256-bits long private key.\u003c/p\u003e\n\u003cp\u003eCurrently, a minimum key size of \u003cstrong\u003e224 bits\u003c/strong\u003e is recommended for EC algorithms.\u003c/p\u003e\n\u003ch3\u003eGoing the extra mile\u003c/h3\u003e\n\u003ch4\u003ePre-Quantum Cryptography\u003c/h4\u003e\n\u003cp\u003eEncrypted data and communications recorded today could be decrypted in the future by an attack from a quantum computer.\u003cbr\u003e It is important to keep\nin mind that NIST-approved digital signature schemes, key agreement, and key transport may need to be replaced with secure quantum-resistant (or\n\"post-quantum\") counterpart.\u003c/p\u003e\n\u003cp\u003eThus, if data is to remain secure beyond 2030, proactive measures should be taken now to ensure its safety.\u003c/p\u003e\n\u003cp\u003e\u003ca href\u003d\"https://www.enisa.europa.eu/publications/post-quantum-cryptography-current-state-and-quantum-mitigation\"\u003eLearn more here\u003c/a\u003e.\u003c/p\u003e",
        "context": {
          "key": "cryptopp",
          "displayName": "CryptoPP"
        }
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eThe following code examples either explicitly or implicitly generate keys. Note that there are differences in the size of the keys depending on the\nalgorithm.\u003c/p\u003e\n\u003cp\u003eDue to the mathematical properties of the algorithms, the security requirements for the key size vary depending on the algorithm.\u003cbr\u003e For example,\na 256-bit ECC key provides about the same level of security as a 3072-bit RSA key and a 128-bit symmetric key.\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cp\u003eHere is an example of a private key generation with RSA:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"31\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;openssl/rsa.h\u0026gt;\n\nvoid encrypt() {\n    RSA* rsa_key_pair \u003d RSA_new();\n    BIGNUM* exponent  \u003d BSA_new();\n\n    BN_set_word(exponent, RSA_F4);\n    RSA_generate_key_ex(rsa_key_pair, 1024, exponent, NULL); // Noncompliant\n}\n\u003c/pre\u003e\n\u003cp\u003eHere is an example of a key generation with the Digital Signature Algorithm (DSA):\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"32\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;openssl/dsa.h\u0026gt;\n\nvoid encrypt() {\n    DSA* dsa_params \u003d DSA_new();\n    DSA_generate_parameters_ex(dsa_params, 1024, NULL, 0, NULL, NULL, NULL); // Noncompliant\n}\n\u003c/pre\u003e\n\u003cp\u003eHere is an example of a key generation with Diffie-Hellman:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"33\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;openssl/dh.h\u0026gt;\n\nvoid encrypt() {\n    DH* dh_params \u003d DH_new();\n    DH_generate_parameters_ex(dh_params, 1024, DH_GENERATOR_2, NULL); // Noncompliant\n}\n\u003c/pre\u003e\n\u003cp\u003eHere is an example of an Elliptic Curve (EC) initialization. It implicitly generates a private key whose size is indicated in the algorithm\nname:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"34\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;botan/ec_group.h\u0026gt;\n\nvoid encrypt() {\n    EC_KEY* ec_key \u003d EC_KEY_new_by_curve_name(NID_secp112r1); // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"31\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;openssl/rsa.h\u0026gt;\n\nvoid encrypt() {\n    RSA* rsa_key_pair \u003d RSA_new();\n    BIGNUM* exponent  \u003d BSA_new();\n\n    BN_set_word(exponent, RSA_F4);\n    RSA_generate_key_ex(rsa_key_pair, 2048, exponent, NULL);\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"32\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;openssl/dsa.h\u0026gt;\n\nvoid encrypt() {\n    DSA* dsa_params \u003d DSA_new();\n    DSA_generate_parameters_ex(dsa_params, 2048, NULL, 0, NULL, NULL, NULL);\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"33\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;openssl/dh.h\u0026gt;\n\nvoid encrypt() {\n    DH* dh_params \u003d DH_new();\n    DH_generate_parameters_ex(dh_params, 2048, DH_GENERATOR_2, NULL);\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"34\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;botan/ec_group.h\u0026gt;\n\nvoid encrypt() {\n    EC_KEY* ec_key \u003d EC_KEY_new_by_curve_name(NID_secp224r1);\n}\n\u003c/pre\u003e\n\u003ch3\u003eHow does this work?\u003c/h3\u003e\n\u003cp\u003eAs a rule of thumb, use the cryptographic algorithms and mechanisms that are considered strong by the cryptographic community.\u003c/p\u003e\n\u003cp\u003eThe appropriate choices are the following.\u003c/p\u003e\n\u003ch4\u003eRSA (Rivest-Shamir-Adleman) and DSA (Digital Signature Algorithm)\u003c/h4\u003e\n\u003cp\u003eThe security of these algorithms depends on the difficulty of attacks attempting to solve their underlying mathematical problem.\u003c/p\u003e\n\u003cp\u003eIn general, a minimum key size of \u003cstrong\u003e2048\u003c/strong\u003e bits is recommended for both.\u003c/p\u003e\n\u003ch4\u003eAES (Advanced Encryption Standard)\u003c/h4\u003e\n\u003cp\u003eAES supports three key sizes: 128 bits, 192 bits and 256 bits. The security of the AES algorithm is based on the computational complexity of trying\nall possible keys.\u003cbr\u003e A larger key size increases the number of possible keys and makes exhaustive search attacks computationally infeasible.\nTherefore, a 256-bit key provides a higher level of security than a 128-bit or 192-bit key.\u003c/p\u003e\n\u003cp\u003eCurrently, a minimum key size of \u003cstrong\u003e128 bits\u003c/strong\u003e is recommended for AES.\u003c/p\u003e\n\u003ch4\u003eElliptic Curve Cryptography (ECC)\u003c/h4\u003e\n\u003cp\u003eElliptic curve cryptography is also used in various algorithms, such as ECDSA, ECDH, or ECMQV. The length of keys generated with elliptic curve\nalgorithms are mentioned directly in their names. For example, \u003ccode\u003esecp256k1\u003c/code\u003e generates a 256-bits long private key.\u003c/p\u003e\n\u003cp\u003eCurrently, a minimum key size of \u003cstrong\u003e224 bits\u003c/strong\u003e is recommended for EC algorithms.\u003c/p\u003e\n\u003ch3\u003eGoing the extra mile\u003c/h3\u003e\n\u003ch4\u003ePre-Quantum Cryptography\u003c/h4\u003e\n\u003cp\u003eEncrypted data and communications recorded today could be decrypted in the future by an attack from a quantum computer.\u003cbr\u003e It is important to keep\nin mind that NIST-approved digital signature schemes, key agreement, and key transport may need to be replaced with secure quantum-resistant (or\n\"post-quantum\") counterpart.\u003c/p\u003e\n\u003cp\u003eThus, if data is to remain secure beyond 2030, proactive measures should be taken now to ensure its safety.\u003c/p\u003e\n\u003cp\u003e\u003ca href\u003d\"https://www.enisa.europa.eu/publications/post-quantum-cryptography-current-state-and-quantum-mitigation\"\u003eLearn more here\u003c/a\u003e.\u003c/p\u003e",
        "context": {
          "key": "openssl",
          "displayName": "OpenSSL"
        }
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eArticles \u0026amp; blog posts\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://learn.microsoft.com/en-us/dotnet/standard/security/vulnerabilities-cbc-mode\"\u003eMicrosoft, Timing vulnerabilities with CBC-mode\n  symmetric decryption using padding\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Padding_oracle_attack\"\u003eWikipedia, Padding Oracle Attack\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Chosen-ciphertext_attack\"\u003eWikipedia, Chosen-Ciphertext Attack\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Chosen-plaintext_attack\"\u003eWikipedia, Chosen-Plaintext Attack\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Semantic_security\"\u003eWikipedia, Semantically Secure Cryptosystems\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Optimal_asymmetric_encryption_padding\"\u003eWikipedia, OAEP\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Galois/Counter_Mode\"\u003eWikipedia, Galois/Counter Mode\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/Top10/A02_2021-Cryptographic_Failures/\"\u003eOWASP Top 10 2021 Category A2\u003c/a\u003e - Cryptographic Failures \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://www.owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\"\u003eOWASP Top 10 2017 Category A3\u003c/a\u003e - Sensitive Data\n  Exposure \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration\"\u003eOWASP Top 10 2017 Category A6\u003c/a\u003e - Security\n  Misconfiguration \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://mobile-security.gitbook.io/masvs/security-requirements/0x08-v3-cryptography_verification_requirements\"\u003eMobile AppSec\n  Verification Standard\u003c/a\u003e - Cryptography Requirements \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/www-project-mobile-top-10/2016-risks/m5-insufficient-cryptography\"\u003eOWASP Mobile Top 10 2016 Category M5\u003c/a\u003e -\n  Insufficient Cryptography \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf\"\u003eNIST 800-131A\u003c/a\u003e - Recommendation for Transitioning the\n  Use of Cryptographic Algorithms and Key Lengths* \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/326\"\u003eMITRE, CWE-326\u003c/a\u003e - Inadequate Encryption\n  Strength \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/327\"\u003eMITRE, CWE-327\u003c/a\u003e - Use of a Broken or Risky Cryptographic Algorithm \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/hDdGBQ\"\u003eCERT, MSC61-J.\u003c/a\u003e - Do not use insecure or weak cryptographic algorithms \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cwe",
      "privacy"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5999",
    "name": "\"std::scoped_lock\" should be created with constructor arguments",
    "defaultSeverity": "BLOCKER",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhen constructing an \u003ccode\u003estd::scoped_lock\u003c/code\u003e, the constructor arguments are used to list the mutexes that the \u003ccode\u003escoped_lock\u003c/code\u003e will\nlock on the creation and unlock on destruction. It is possible to construct a \u003ccode\u003escoped_lock\u003c/code\u003e without any parameter, but in that case, it\ndoes absolutely nothing and is just dead code, which was probably not the intent of the user.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid f1(std::mutex \u0026amp;m) {\n  std::scoped_lock lock; // Noncompliant\n  // Do some work\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid f1(std::mutex \u0026amp;m) {\n  std::scoped_lock lock {m}; // Compliant\n  // Do some work\n}\n\ntemplate\u0026lt;class... D\u0026gt;\nvoid processAll(D \u0026amp;...data) {\n  scoped_lock lock {data.getMutex()...}; // Compliant, even if the list might be empty in some cases\n  // Do some work\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/thread/scoped_lock\"\u003estd::scoped_lock\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhen constructing an \u003ccode\u003estd::scoped_lock\u003c/code\u003e, the constructor arguments are used to list the mutexes that the \u003ccode\u003escoped_lock\u003c/code\u003e will\nlock on the creation and unlock on destruction. It is possible to construct a \u003ccode\u003escoped_lock\u003c/code\u003e without any parameter, but in that case, it\ndoes absolutely nothing and is just dead code, which was probably not the intent of the user.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid f1(std::mutex \u0026amp;m) {\n  std::scoped_lock lock; // Noncompliant\n  // Do some work\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid f1(std::mutex \u0026amp;m) {\n  std::scoped_lock lock {m}; // Compliant\n  // Do some work\n}\n\ntemplate\u0026lt;class... D\u0026gt;\nvoid processAll(D \u0026amp;...data) {\n  scoped_lock lock {data.getMutex()...}; // Compliant, even if the list might be empty in some cases\n  // Do some work\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/thread/scoped_lock\"\u003estd::scoped_lock\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "since-c++17"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S3458",
    "name": "Empty \"case\" clauses that fall through to the \"default\" should be omitted",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eEmpty \u003ccode\u003ecase\u003c/code\u003e clauses that fall through to the default are useless. Whether or not such a \u003ccode\u003ecase\u003c/code\u003e is present, the\n\u003ccode\u003edefault\u003c/code\u003e clause will be invoked. Such \u003ccode\u003ecase\u003c/code\u003es simply clutter the code, and should be removed.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nswitch(ch)\n{\n  case \u0027a\u0027 :\n    handleA();\n    break;\n  case \u0027b\u0027 :\n    handleB();\n    break;\n  case \u0027c\u0027 :  // Noncompliant\n  default:\n    handleTheRest();\n    break;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nswitch(ch)\n{\n  case \u0027a\u0027 :\n    handleA();\n    break;\n  case \u0027b\u0027 :\n    handleB();\n    break;\n  default:\n    handleTheRest();\n    break;\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eEmpty \u003ccode\u003ecase\u003c/code\u003e clauses that fall through to the default are useless. Whether or not such a \u003ccode\u003ecase\u003c/code\u003e is present, the\n\u003ccode\u003edefault\u003c/code\u003e clause will be invoked. Such \u003ccode\u003ecase\u003c/code\u003es simply clutter the code, and should be removed.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nswitch(ch)\n{\n  case \u0027a\u0027 :\n    handleA();\n    break;\n  case \u0027b\u0027 :\n    handleB();\n    break;\n  case \u0027c\u0027 :  // Noncompliant\n  default:\n    handleTheRest();\n    break;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nswitch(ch)\n{\n  case \u0027a\u0027 :\n    handleA();\n    break;\n  case \u0027b\u0027 :\n    handleB();\n    break;\n  default:\n    handleTheRest();\n    break;\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "clumsy",
      "finding"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S4423",
    "name": "Weak SSL/TLS protocols should not be used",
    "defaultSeverity": "CRITICAL",
    "type": "VULNERABILITY",
    "cleanCodeAttribute": "TRUSTWORTHY",
    "defaultImpacts": {
      "SECURITY": "HIGH"
    },
    "description": "\u003cp\u003eThis vulnerability exposes encrypted data to a number of attacks whose goal is to recover the plaintext.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eEncryption algorithms are essential for protecting sensitive information and ensuring secure communications in a variety of domains. They are used\nfor several important reasons:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Confidentiality, privacy, and intellectual property protection \u003c/li\u003e\n  \u003cli\u003e Security during transmission or on storage devices \u003c/li\u003e\n  \u003cli\u003e Data integrity, general trust, and authentication \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWhen selecting encryption algorithms, tools, or combinations, you should also consider two things:\u003c/p\u003e\n\u003col\u003e\n  \u003cli\u003e No encryption is unbreakable. \u003c/li\u003e\n  \u003cli\u003e The strength of an encryption algorithm is usually measured by the effort required to crack it within a reasonable time frame. \u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eFor these reasons, as soon as cryptography is included in a project, it is important to choose encryption algorithms that are considered strong and\nsecure by the cryptography community.\u003c/p\u003e\n\u003cp\u003eTo provide communication security over a network, SSL and TLS are generally used. However, it is important to note that the following protocols are\nall considered weak by the cryptographic community, and are officially deprecated:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e SSL versions 1.0, 2.0 and 3.0 \u003c/li\u003e\n  \u003cli\u003e TLS versions 1.0 and 1.1 \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWhen these unsecured protocols are used, it is best practice to expect a breach: that a user or organization with malicious intent will perform\nmathematical attacks on this data after obtaining it by other means.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eAfter retrieving encrypted data and performing cryptographic attacks on it on a given timeframe, attackers can recover the plaintext that\nencryption was supposed to protect.\u003c/p\u003e\n\u003cp\u003eDepending on the recovered data, the impact may vary.\u003c/p\u003e\n\u003cp\u003eBelow are some real-world scenarios that illustrate the potential impact of an attacker exploiting the vulnerability.\u003c/p\u003e\n\u003ch4\u003eAdditional attack surface\u003c/h4\u003e\n\u003cp\u003eBy modifying the plaintext of the encrypted message, an attacker may be able to trigger additional vulnerabilities in the code. An attacker can\nfurther exploit a system to obtain more information.\u003cbr\u003e Encrypted values are often considered trustworthy because it would not be possible for a\nthird party to modify them under normal circumstances.\u003c/p\u003e\n\u003ch4\u003eBreach of confidentiality and privacy\u003c/h4\u003e\n\u003cp\u003eWhen encrypted data contains personal or sensitive information, its retrieval by an attacker can lead to privacy violations, identity theft,\nfinancial loss, reputational damage, or unauthorized access to confidential systems.\u003c/p\u003e\n\u003cp\u003eIn this scenario, the company, its employees, users, and partners could be seriously affected.\u003c/p\u003e\n\u003cp\u003eThe impact is twofold, as data breaches and exposure of encrypted data can undermine trust in the organization, as customers, clients and\nstakeholders may lose confidence in the organization’s ability to protect their sensitive data.\u003c/p\u003e\n\u003ch4\u003eLegal and compliance issues\u003c/h4\u003e\n\u003cp\u003eIn many industries and locations, there are legal and compliance requirements to protect sensitive data. If encrypted data is compromised and the\nplaintext can be recovered, companies face legal consequences, penalties, or violations of privacy laws.\u003c/p\u003e\n\u003ch2\u003eHow to fix it in cURL\u003c/h2\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003cp\u003eThe following code samples attempt to create an HTTP request.\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cp\u003eThis sample uses Curl’s default TLS algorithms, which are weak cryptographical algorithms: TLSv1.0 and LTSv1.1.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"11\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;curl/curl.h\u0026gt;\n\nvoid encrypt() {\n    CURL *curl;\n    curl_global_init(CURL_GLOBAL_DEFAULT);\n\n    curl \u003d curl_easy_init();                                      // Noncompliant\n    curl_easy_setopt(curl, CURLOPT_URL, \"https://example.com/\");\n\n    curl_easy_perform(curl);\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"11\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;curl/curl.h\u0026gt;\n\nvoid encrypt() {\n    CURL *curl;\n    curl_global_init(CURL_GLOBAL_DEFAULT);\n\n    curl \u003d curl_easy_init();\n    curl_easy_setopt(curl, CURLOPT_URL, \"https://example.com/\");\n    curl_easy_setopt(curl, CURLOPT_SSLVERSION, CURL_SSLVERSION_TLSv1_2);\n\n    curl_easy_perform(curl);\n}\n\u003c/pre\u003e\n\u003ch3\u003eHow does this work?\u003c/h3\u003e\n\u003cp\u003eAs a rule of thumb, by default you should use the cryptographic algorithms and mechanisms that are considered strong by the cryptographic\ncommunity.\u003c/p\u003e\n\u003cp\u003eThe best choices at the moment are the following.\u003c/p\u003e\n\u003ch4\u003eUse TLS v1.2 or TLS v1.3\u003c/h4\u003e\n\u003cp\u003eEven though TLS V1.3 is available, using TLS v1.2 is still considered good and secure practice by the cryptography community.\u003cbr\u003e\u003c/p\u003e\n\u003cp\u003eThe use of TLS v1.2 ensures compatibility with a wide range of platforms and enables seamless communication between different systems that do not\nyet have TLS v1.3 support.\u003c/p\u003e\n\u003cp\u003eThe only drawback depends on whether the framework used is outdated: its TLS v1.2 settings may enable older and insecure cipher suites that are\ndeprecated as insecure.\u003c/p\u003e\n\u003cp\u003eOn the other hand, TLS v1.3 removes support for older and weaker cryptographic algorithms, eliminates known vulnerabilities from previous TLS\nversions, and improves performance.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eArticles \u0026amp; blog posts\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Padding_oracle_attack\"\u003eWikipedia, Padding Oracle Attack\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Chosen-ciphertext_attack\"\u003eWikipedia, Chosen-Ciphertext Attack\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Chosen-plaintext_attack\"\u003eWikipedia, Chosen-Plaintext Attack\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Semantic_security\"\u003eWikipedia, Semantically Secure Cryptosystems\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Optimal_asymmetric_encryption_padding\"\u003eWikipedia, OAEP\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Galois/Counter_Mode\"\u003eWikipedia, Galois/Counter Mode\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/Top10/A02_2021-Cryptographic_Failures/\"\u003eOWASP Top 10 2021 Category A2\u003c/a\u003e - Cryptographic Failures \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration\"\u003eOWASP Top 10 2017 Category A6\u003c/a\u003e - Security\n  Misconfiguration \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/327\"\u003eMITRE, CWE-327\u003c/a\u003e - Use of a Broken or Risky Cryptographic Algorithm \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eThis vulnerability exposes encrypted data to a number of attacks whose goal is to recover the plaintext.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eEncryption algorithms are essential for protecting sensitive information and ensuring secure communications in a variety of domains. They are used\nfor several important reasons:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Confidentiality, privacy, and intellectual property protection \u003c/li\u003e\n  \u003cli\u003e Security during transmission or on storage devices \u003c/li\u003e\n  \u003cli\u003e Data integrity, general trust, and authentication \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWhen selecting encryption algorithms, tools, or combinations, you should also consider two things:\u003c/p\u003e\n\u003col\u003e\n  \u003cli\u003e No encryption is unbreakable. \u003c/li\u003e\n  \u003cli\u003e The strength of an encryption algorithm is usually measured by the effort required to crack it within a reasonable time frame. \u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eFor these reasons, as soon as cryptography is included in a project, it is important to choose encryption algorithms that are considered strong and\nsecure by the cryptography community.\u003c/p\u003e\n\u003cp\u003eTo provide communication security over a network, SSL and TLS are generally used. However, it is important to note that the following protocols are\nall considered weak by the cryptographic community, and are officially deprecated:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e SSL versions 1.0, 2.0 and 3.0 \u003c/li\u003e\n  \u003cli\u003e TLS versions 1.0 and 1.1 \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWhen these unsecured protocols are used, it is best practice to expect a breach: that a user or organization with malicious intent will perform\nmathematical attacks on this data after obtaining it by other means.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eAfter retrieving encrypted data and performing cryptographic attacks on it on a given timeframe, attackers can recover the plaintext that\nencryption was supposed to protect.\u003c/p\u003e\n\u003cp\u003eDepending on the recovered data, the impact may vary.\u003c/p\u003e\n\u003cp\u003eBelow are some real-world scenarios that illustrate the potential impact of an attacker exploiting the vulnerability.\u003c/p\u003e\n\u003ch4\u003eAdditional attack surface\u003c/h4\u003e\n\u003cp\u003eBy modifying the plaintext of the encrypted message, an attacker may be able to trigger additional vulnerabilities in the code. An attacker can\nfurther exploit a system to obtain more information.\u003cbr\u003e Encrypted values are often considered trustworthy because it would not be possible for a\nthird party to modify them under normal circumstances.\u003c/p\u003e\n\u003ch4\u003eBreach of confidentiality and privacy\u003c/h4\u003e\n\u003cp\u003eWhen encrypted data contains personal or sensitive information, its retrieval by an attacker can lead to privacy violations, identity theft,\nfinancial loss, reputational damage, or unauthorized access to confidential systems.\u003c/p\u003e\n\u003cp\u003eIn this scenario, the company, its employees, users, and partners could be seriously affected.\u003c/p\u003e\n\u003cp\u003eThe impact is twofold, as data breaches and exposure of encrypted data can undermine trust in the organization, as customers, clients and\nstakeholders may lose confidence in the organization’s ability to protect their sensitive data.\u003c/p\u003e\n\u003ch4\u003eLegal and compliance issues\u003c/h4\u003e\n\u003cp\u003eIn many industries and locations, there are legal and compliance requirements to protect sensitive data. If encrypted data is compromised and the\nplaintext can be recovered, companies face legal consequences, penalties, or violations of privacy laws.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eThe following code samples attempt to create an HTTP request.\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cp\u003eThis sample uses Curl’s default TLS algorithms, which are weak cryptographical algorithms: TLSv1.0 and LTSv1.1.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"11\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;curl/curl.h\u0026gt;\n\nvoid encrypt() {\n    CURL *curl;\n    curl_global_init(CURL_GLOBAL_DEFAULT);\n\n    curl \u003d curl_easy_init();                                      // Noncompliant\n    curl_easy_setopt(curl, CURLOPT_URL, \"https://example.com/\");\n\n    curl_easy_perform(curl);\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"11\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;curl/curl.h\u0026gt;\n\nvoid encrypt() {\n    CURL *curl;\n    curl_global_init(CURL_GLOBAL_DEFAULT);\n\n    curl \u003d curl_easy_init();\n    curl_easy_setopt(curl, CURLOPT_URL, \"https://example.com/\");\n    curl_easy_setopt(curl, CURLOPT_SSLVERSION, CURL_SSLVERSION_TLSv1_2);\n\n    curl_easy_perform(curl);\n}\n\u003c/pre\u003e\n\u003ch3\u003eHow does this work?\u003c/h3\u003e\n\u003cp\u003eAs a rule of thumb, by default you should use the cryptographic algorithms and mechanisms that are considered strong by the cryptographic\ncommunity.\u003c/p\u003e\n\u003cp\u003eThe best choices at the moment are the following.\u003c/p\u003e\n\u003ch4\u003eUse TLS v1.2 or TLS v1.3\u003c/h4\u003e\n\u003cp\u003eEven though TLS V1.3 is available, using TLS v1.2 is still considered good and secure practice by the cryptography community.\u003cbr\u003e\u003c/p\u003e\n\u003cp\u003eThe use of TLS v1.2 ensures compatibility with a wide range of platforms and enables seamless communication between different systems that do not\nyet have TLS v1.3 support.\u003c/p\u003e\n\u003cp\u003eThe only drawback depends on whether the framework used is outdated: its TLS v1.2 settings may enable older and insecure cipher suites that are\ndeprecated as insecure.\u003c/p\u003e\n\u003cp\u003eOn the other hand, TLS v1.3 removes support for older and weaker cryptographic algorithms, eliminates known vulnerabilities from previous TLS\nversions, and improves performance.\u003c/p\u003e",
        "context": {
          "key": "curl",
          "displayName": "cURL"
        }
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eThe following code samples attempt to create an OpenSSL TLS Client.\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cp\u003eThis sample uses OpenSSL’s default TLS algorithms, which are weak cryptographical algorithms (TLSv1.0 and LTSv1.1).\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"21\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;openssl/ssl.h\u0026gt;\n\nvoid encrypt() {\n    const SSL_METHOD *method \u003d TLS_method();        // Noncompliant\n    SSL_CTX *ctx             \u003d SSL_CTX_new(method);\n\n    SSL *ssl \u003d SSL_new(ctx);\n    SSL_connect(ssl);\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"21\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;openssl/ssl.h\u0026gt;\n\nvoid encrypt() {\n    const SSL_METHOD *method \u003d TLS_method();\n    SSL_CTX *ctx             \u003d SSL_CTX_new(method);\n\n    SSL_CTX_set_min_proto_version(ctx, TLS1_2_VERSION);\n\n    SSL *ssl \u003d SSL_new(ctx);\n    SSL_connect(ssl);\n}\n\u003c/pre\u003e\n\u003ch3\u003eHow does this work?\u003c/h3\u003e\n\u003cp\u003eAs a rule of thumb, by default you should use the cryptographic algorithms and mechanisms that are considered strong by the cryptographic\ncommunity.\u003c/p\u003e\n\u003cp\u003eThe best choices at the moment are the following.\u003c/p\u003e\n\u003ch4\u003eUse TLS v1.2 or TLS v1.3\u003c/h4\u003e\n\u003cp\u003eEven though TLS V1.3 is available, using TLS v1.2 is still considered good and secure practice by the cryptography community.\u003cbr\u003e\u003c/p\u003e\n\u003cp\u003eThe use of TLS v1.2 ensures compatibility with a wide range of platforms and enables seamless communication between different systems that do not\nyet have TLS v1.3 support.\u003c/p\u003e\n\u003cp\u003eThe only drawback depends on whether the framework used is outdated: its TLS v1.2 settings may enable older and insecure cipher suites that are\ndeprecated as insecure.\u003c/p\u003e\n\u003cp\u003eOn the other hand, TLS v1.3 removes support for older and weaker cryptographic algorithms, eliminates known vulnerabilities from previous TLS\nversions, and improves performance.\u003c/p\u003e",
        "context": {
          "key": "openssl",
          "displayName": "OpenSSL"
        }
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eThe following code samples attempt to create a Botan TLS Client.\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cp\u003eThis sample uses Botan’s default TLS algorithms, which are weak cryptographical algorithms (TLSv1.0 and DLTv1.0).\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;botan/tls_client.h\u0026gt;\n#include \u0026lt;botan/tls_callbacks.h\u0026gt;\n#include \u0026lt;botan/tls_session_manager.h\u0026gt;\n#include \u0026lt;botan/tls_policy.h\u0026gt;\n#include \u0026lt;botan/auto_rng.h\u0026gt;\n#include \u0026lt;botan/certstor.h\u0026gt;\n#include \u0026lt;botan/certstor_system.h\u0026gt;\n\nclass Custom_Callbacks   : public Botan::TLS::Callbacks { };\nclass Custom_Credentials : public Botan::Credentials_Manager { };\n\nvoid encrypt() {\n    Custom_Callbacks      callbacks;\n    Botan::AutoSeeded_RNG rng;\n    Custom_Credentials    creds;\n    Botan::TLS::Policy    policy; // Noncompliant\n\n    Botan::TLS::Session_Manager_In_Memory session_mgr(rng);\n    Botan::TLS::Client client(callbacks, session_mgr, creds, policy, rng,\n                              Botan::TLS::Server_Information(\"example.com\", 443),\n                              Botan::TLS::Protocol_Version::TLS_V12);\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eThis sample uses the \"Strict\" Botan TLS Policy, whose minimal versions are strong cryptographical algorithms (TLSv1.2 and TLSv1.2).\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;botan/tls_client.h\u0026gt;\n#include \u0026lt;botan/tls_callbacks.h\u0026gt;\n#include \u0026lt;botan/tls_session_manager.h\u0026gt;\n#include \u0026lt;botan/tls_policy.h\u0026gt;\n#include \u0026lt;botan/auto_rng.h\u0026gt;\n#include \u0026lt;botan/certstor.h\u0026gt;\n#include \u0026lt;botan/certstor_system.h\u0026gt;\n\nclass Custom_Callbacks   : public Botan::TLS::Callbacks { };\nclass Custom_Credentials : public Botan::Credentials_Manager { };\n\nvoid encrypt() {\n    Custom_Callbacks          callbacks;\n    Botan::AutoSeeded_RNG     rng;\n    Custom_Credentials        creds;\n    Botan::TLS::Strict_Policy policy;\n\n    Botan::TLS::Session_Manager_In_Memory session_mgr(rng);\n    Botan::TLS::Client client(callbacks, session_mgr, creds, policy, rng,\n                              Botan::TLS::Server_Information(\"example.com\", 443),\n                              Botan::TLS::Protocol_Version::TLS_V12);\n}\n\u003c/pre\u003e\n\u003ch3\u003eHow does this work?\u003c/h3\u003e\n\u003cp\u003eAs a rule of thumb, by default you should use the cryptographic algorithms and mechanisms that are considered strong by the cryptographic\ncommunity.\u003c/p\u003e\n\u003cp\u003eThe best choices at the moment are the following.\u003c/p\u003e\n\u003ch4\u003eUse TLS v1.2 or TLS v1.3\u003c/h4\u003e\n\u003cp\u003eEven though TLS V1.3 is available, using TLS v1.2 is still considered good and secure practice by the cryptography community.\u003cbr\u003e\u003c/p\u003e\n\u003cp\u003eThe use of TLS v1.2 ensures compatibility with a wide range of platforms and enables seamless communication between different systems that do not\nyet have TLS v1.3 support.\u003c/p\u003e\n\u003cp\u003eThe only drawback depends on whether the framework used is outdated: its TLS v1.2 settings may enable older and insecure cipher suites that are\ndeprecated as insecure.\u003c/p\u003e\n\u003cp\u003eOn the other hand, TLS v1.3 removes support for older and weaker cryptographic algorithms, eliminates known vulnerabilities from previous TLS\nversions, and improves performance.\u003c/p\u003e",
        "context": {
          "key": "botan",
          "displayName": "Botan"
        }
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eArticles \u0026amp; blog posts\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Padding_oracle_attack\"\u003eWikipedia, Padding Oracle Attack\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Chosen-ciphertext_attack\"\u003eWikipedia, Chosen-Ciphertext Attack\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Chosen-plaintext_attack\"\u003eWikipedia, Chosen-Plaintext Attack\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Semantic_security\"\u003eWikipedia, Semantically Secure Cryptosystems\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Optimal_asymmetric_encryption_padding\"\u003eWikipedia, OAEP\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Galois/Counter_Mode\"\u003eWikipedia, Galois/Counter Mode\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/Top10/A02_2021-Cryptographic_Failures/\"\u003eOWASP Top 10 2021 Category A2\u003c/a\u003e - Cryptographic Failures \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration\"\u003eOWASP Top 10 2017 Category A6\u003c/a\u003e - Security\n  Misconfiguration \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/327\"\u003eMITRE, CWE-327\u003c/a\u003e - Use of a Broken or Risky Cryptographic Algorithm \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cwe",
      "privacy",
      "symbolic-execution"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S3457",
    "name": "Format strings should be used correctly",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eprintf\u003c/code\u003e format strings contain placeholders, represented by special characters such as \u003ccode\u003e%s\u003c/code\u003e. These placeholders are\ninterpreted at runtime rather than validated by the compiler. Using incorrect placeholders or with inappropriate arguments can result in the wrong\nstring being created or undefined behavior.\u003c/p\u003e\n\u003cp\u003eStarting with C++20, \u003ccode\u003estd::format\u003c/code\u003e should be preferred: it is more readable and validated at compile-time, making it more secure. Rule\n{rule:cpp:S6494} covers that. Furthermore, C++23 provides \u003ccode\u003estd::print\u003c/code\u003e, which is similar to \u003ccode\u003estd::format\u003c/code\u003e but directly prints\nits output instead of generating a \u003ccode\u003estd::string\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003e{rule:cpp:S2275} covers errors leading to undefined behavior.\u003cbr\u003e This rule is about errors that produce an unexpected string.\u003c/p\u003e\n\u003cp\u003eThese problems are detected when the format string is a string literal:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Every argument should be used: \u003cpre\u003e\nprintf(\"Numbers: %d\", 1, 2); // Noncompliant: the second argument \"2\" is unused\n\u003c/pre\u003e  You should either remove the extra arguments or add the relevant placeholders.  \u003c/li\u003e\n  \u003cli\u003e The formatting flags \u003ccode\u003e0\u003c/code\u003e and \u003ccode\u003e-\u003c/code\u003e are mutually exclusive: \u003cpre\u003e\nprintf(\"Number: %0-10f\", 1.2); // Noncompliant: flag \"0\" is ignored because of \"-\"\n\u003c/pre\u003e  When \u003ccode\u003e0\u003c/code\u003e is used, the number is right-aligned with leading \u003ccode\u003e0\u003c/code\u003es. The flag \u003ccode\u003e-\u003c/code\u003e aligns the number to the left. Consequently, zero \u003ccode\u003e0\u003c/code\u003e would be used when using both flags, thus making the \u003ccode\u003e0\u003c/code\u003e flag useless.   You should choose which flags make sense in your use case and remove the other.  \u003c/li\u003e\n  \u003cli\u003e The formatting flags \u003ccode\u003e␣\u003c/code\u003e (space) and \u003ccode\u003e+\u003c/code\u003e are mutually exclusive: \u003cpre\u003e\nprintf(\"Number: % +f\", 1.2); // Noncompliant: flag \" \" is ignored because of \"+\"\n\u003c/pre\u003e  Both the space and the \u003ccode\u003e+\u003c/code\u003e flags change when the sign character is printed. They are, therefore, incompatible with one another.   You should decide which one is appropriate in your case and remove the other.  \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/io/c/fprintf\"\u003e\u003ccode\u003eprintf\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/utility/format/format\"\u003e\u003ccode\u003estd::format\u003c/code\u003e from C++20\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/io/print\"\u003e\u003ccode\u003estd::print\u003c/code\u003e from C++23\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/J9YxBQ\"\u003eCERT, FIO47-C.\u003c/a\u003e - Use valid format strings \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S6494} - C++ formatting functions should be used instead of C printf-like functions \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S2275} - Printf-style format strings should not lead to unexpected behavior at runtime \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003ccode\u003eprintf\u003c/code\u003e format strings contain placeholders, represented by special characters such as \u003ccode\u003e%s\u003c/code\u003e. These placeholders are\ninterpreted at runtime rather than validated by the compiler. Using incorrect placeholders or with inappropriate arguments can result in the wrong\nstring being created or undefined behavior.\u003c/p\u003e\n\u003cp\u003eStarting with C++20, \u003ccode\u003estd::format\u003c/code\u003e should be preferred: it is more readable and validated at compile-time, making it more secure. Rule\n{rule:cpp:S6494} covers that. Furthermore, C++23 provides \u003ccode\u003estd::print\u003c/code\u003e, which is similar to \u003ccode\u003estd::format\u003c/code\u003e but directly prints\nits output instead of generating a \u003ccode\u003estd::string\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003e{rule:cpp:S2275} covers errors leading to undefined behavior.\u003cbr\u003e This rule is about errors that produce an unexpected string.\u003c/p\u003e\n\u003cp\u003eThese problems are detected when the format string is a string literal:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Every argument should be used: \u003cpre\u003e\nprintf(\"Numbers: %d\", 1, 2); // Noncompliant: the second argument \"2\" is unused\n\u003c/pre\u003e  You should either remove the extra arguments or add the relevant placeholders.  \u003c/li\u003e\n  \u003cli\u003e The formatting flags \u003ccode\u003e0\u003c/code\u003e and \u003ccode\u003e-\u003c/code\u003e are mutually exclusive: \u003cpre\u003e\nprintf(\"Number: %0-10f\", 1.2); // Noncompliant: flag \"0\" is ignored because of \"-\"\n\u003c/pre\u003e  When \u003ccode\u003e0\u003c/code\u003e is used, the number is right-aligned with leading \u003ccode\u003e0\u003c/code\u003es. The flag \u003ccode\u003e-\u003c/code\u003e aligns the number to the left. Consequently, zero \u003ccode\u003e0\u003c/code\u003e would be used when using both flags, thus making the \u003ccode\u003e0\u003c/code\u003e flag useless.   You should choose which flags make sense in your use case and remove the other.  \u003c/li\u003e\n  \u003cli\u003e The formatting flags \u003ccode\u003e␣\u003c/code\u003e (space) and \u003ccode\u003e+\u003c/code\u003e are mutually exclusive: \u003cpre\u003e\nprintf(\"Number: % +f\", 1.2); // Noncompliant: flag \" \" is ignored because of \"+\"\n\u003c/pre\u003e  Both the space and the \u003ccode\u003e+\u003c/code\u003e flags change when the sign character is printed. They are, therefore, incompatible with one another.   You should decide which one is appropriate in your case and remove the other.  \u003c/li\u003e\n\u003c/ul\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/io/c/fprintf\"\u003e\u003ccode\u003eprintf\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/utility/format/format\"\u003e\u003ccode\u003estd::format\u003c/code\u003e from C++20\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/io/print\"\u003e\u003ccode\u003estd::print\u003c/code\u003e from C++23\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/J9YxBQ\"\u003eCERT, FIO47-C.\u003c/a\u003e - Use valid format strings \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S6494} - C++ formatting functions should be used instead of C printf-like functions \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S2275} - Printf-style format strings should not lead to unexpected behavior at runtime \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cert",
      "confusing"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5997",
    "name": "\"std::scoped_lock\" should be used instead of \"std::lock_guard\"",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003estd::scoped_lock\u003c/code\u003e basically provides the same feature as \u003ccode\u003estd::lock_guard\u003c/code\u003e, but is more generic: It can lock several mutexes\nat the same time, with a deadlock prevention mechanism (see {rule:cpp:S5524}). The equivalent code to perform simultaneous locking with\n\u003ccode\u003estd::lock_guard\u003c/code\u003e is significantly more complex. Therefore, it is simpler to use \u003ccode\u003estd::scoped_lock\u003c/code\u003e all the time, even when\nlocking only one mutex (there will be no performance impact).\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid f1(std::mutex \u0026amp;m1) {\n  std::lock_guard lock{m1}; // Noncompliant\n  // Do some work\n}\n\nvoid f2(std::mutex \u0026amp;m1, std::mutex \u0026amp;m2)\n    std::lock(m1, m2);\n    std::lock_guard\u0026lt;std::mutex\u0026gt; lock1{m1, std::adopt_lock}; // Noncompliant\n    std::lock_guard\u0026lt;std::mutex\u0026gt; lock2{m2, std::adopt_lock}; // Noncompliant\n    // Do some work\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid f1(std::mutex \u0026amp;m1) {\n  std::scoped_lock lock{m1}; // Compliant\n  // Do some work\n}\n\nvoid f2(std::mutex \u0026amp;m1, std::mutex \u0026amp;m2)\n    std::scoped_lock lock{m1, m2}; // Compliant, and more simple\n    // Do some work\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/thread/scoped_lock\"\u003estd::scoped_lock\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003ccode\u003estd::scoped_lock\u003c/code\u003e basically provides the same feature as \u003ccode\u003estd::lock_guard\u003c/code\u003e, but is more generic: It can lock several mutexes\nat the same time, with a deadlock prevention mechanism (see {rule:cpp:S5524}). The equivalent code to perform simultaneous locking with\n\u003ccode\u003estd::lock_guard\u003c/code\u003e is significantly more complex. Therefore, it is simpler to use \u003ccode\u003estd::scoped_lock\u003c/code\u003e all the time, even when\nlocking only one mutex (there will be no performance impact).\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid f1(std::mutex \u0026amp;m1) {\n  std::lock_guard lock{m1}; // Noncompliant\n  // Do some work\n}\n\nvoid f2(std::mutex \u0026amp;m1, std::mutex \u0026amp;m2)\n    std::lock(m1, m2);\n    std::lock_guard\u0026lt;std::mutex\u0026gt; lock1{m1, std::adopt_lock}; // Noncompliant\n    std::lock_guard\u0026lt;std::mutex\u0026gt; lock2{m2, std::adopt_lock}; // Noncompliant\n    // Do some work\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid f1(std::mutex \u0026amp;m1) {\n  std::scoped_lock lock{m1}; // Compliant\n  // Do some work\n}\n\nvoid f2(std::mutex \u0026amp;m1, std::mutex \u0026amp;m2)\n    std::scoped_lock lock{m1, m2}; // Compliant, and more simple\n    // Do some work\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/thread/scoped_lock\"\u003estd::scoped_lock\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "brain-overload",
      "clumsy",
      "since-c++17"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S834",
    "name": "Array declarations should include an explicit size specification",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eIt is possible to declare an array without explicitly specifying its size, but using an explicit size declaration is clearer, and is therefore\npreferred.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint arr1 [ ];  // Noncompliant; nothing specified\nint arr2 [ ] \u003d { [0] \u003d 1, [12] \u003d 36, [4] \u003d 93 }; // Noncompliant; highest index determines size. May be difficult to spot\nint pirate [ ] \u003d { 2, 4, 8, 42, 501, 90210, 7, 1776 }; // Noncompliant; size is implicit, not explicit\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint arr1 [10];\nint arr2 [13] \u003d { [0] \u003d 1, [12] \u003d 36, [4] \u003d 93 };\nint pirate [10] \u003d { 2, 4, 8, 42, 501, 90210, 7, 1776 }; // Implicitly-assigned size was 8. Desired size was 10.\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 8.12 - When an array is declared with external linkage, its size shall be stated explicitly or defined implicitly by\n  initialisation \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 3-1-3 - When an array is declared, its size shall either be stated explicitly or defined implicitly by initialization \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 8.11 - When an array with external linkage is declared, its size should be explicitely specified \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 9.5 - Where designated initializers are used to initialize an array object the size of the array shall be specified explicitly\n  \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/6dUxBQ\"\u003eCERT, ARR02-C.\u003c/a\u003e - Explicitly specify array bounds, even if implicitly defined by an\n  initializer \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eIt is possible to declare an array without explicitly specifying its size, but using an explicit size declaration is clearer, and is therefore\npreferred.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint arr1 [ ];  // Noncompliant; nothing specified\nint arr2 [ ] \u003d { [0] \u003d 1, [12] \u003d 36, [4] \u003d 93 }; // Noncompliant; highest index determines size. May be difficult to spot\nint pirate [ ] \u003d { 2, 4, 8, 42, 501, 90210, 7, 1776 }; // Noncompliant; size is implicit, not explicit\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint arr1 [10];\nint arr2 [13] \u003d { [0] \u003d 1, [12] \u003d 36, [4] \u003d 93 };\nint pirate [10] \u003d { 2, 4, 8, 42, 501, 90210, 7, 1776 }; // Implicitly-assigned size was 8. Desired size was 10.\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 8.12 - When an array is declared with external linkage, its size shall be stated explicitly or defined implicitly by\n  initialisation \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 3-1-3 - When an array is declared, its size shall either be stated explicitly or defined implicitly by initialization \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 8.11 - When an array with external linkage is declared, its size should be explicitely specified \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 9.5 - Where designated initializers are used to initialize an array object the size of the array shall be specified explicitly\n  \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/6dUxBQ\"\u003eCERT, ARR02-C.\u003c/a\u003e - Explicitly specify array bounds, even if implicitly defined by an\n  initializer \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "cert"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S955",
    "name": "Non-standard characters should not occur in header file names in \"#include\" directives",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003e#include\u003c/code\u003e directive allows you to include header files in your code by enclosing the file names in either double quotes\n(\u003ccode\u003e\"\u003c/code\u003e) or angle brackets (\u003ccode\u003e\u0026lt;\u003c/code\u003e and \u003ccode\u003e\u0026gt;\u003c/code\u003e). However, using:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003e\u0027\u003c/code\u003e, \u003ccode\u003e\\\u003c/code\u003e or \u003ccode\u003e/*\u003c/code\u003e characters between the double quotes (for example: \u003ccode\u003e#include \"dir\\foo.h\"\u003c/code\u003e) \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003e\u0027\u003c/code\u003e, \u003ccode\u003e\\\u003c/code\u003e, \u003ccode\u003e\"\u003c/code\u003e or \u003ccode\u003e/*\u003c/code\u003e characters between the angle brackets (for example: \u003ccode\u003e#include\n  \u0026lt;\"foo\"\u0026gt;\u003c/code\u003e) \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003ein the header names may or may not be supported, and the behavior will depend on the specific implementation.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 19.2 - Non-standard characters should not occur in header file names in #include directives. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 16-2-4 - The \u0027, \", /* or // characters shall not occur in a header file name. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 16-2-5 - The \\ character should not occur in a header file name. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 20.2 - The \u0027, \" or \\ characters and the /* or // character sequences shall not occur in a header file name \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe \u003ccode\u003e#include\u003c/code\u003e directive allows you to include header files in your code by enclosing the file names in either double quotes\n(\u003ccode\u003e\"\u003c/code\u003e) or angle brackets (\u003ccode\u003e\u0026lt;\u003c/code\u003e and \u003ccode\u003e\u0026gt;\u003c/code\u003e). However, using:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003e\u0027\u003c/code\u003e, \u003ccode\u003e\\\u003c/code\u003e or \u003ccode\u003e/*\u003c/code\u003e characters between the double quotes (for example: \u003ccode\u003e#include \"dir\\foo.h\"\u003c/code\u003e) \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003e\u0027\u003c/code\u003e, \u003ccode\u003e\\\u003c/code\u003e, \u003ccode\u003e\"\u003c/code\u003e or \u003ccode\u003e/*\u003c/code\u003e characters between the angle brackets (for example: \u003ccode\u003e#include\n  \u0026lt;\"foo\"\u0026gt;\u003c/code\u003e) \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003ein the header names may or may not be supported, and the behavior will depend on the specific implementation.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 19.2 - Non-standard characters should not occur in header file names in #include directives. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 16-2-4 - The \u0027, \", /* or // characters shall not occur in a header file name. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 16-2-5 - The \\ character should not occur in a header file name. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 20.2 - The \u0027, \" or \\ characters and the /* or // character sequences shall not occur in a header file name \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "based-on-misra"
    ],
    "deprecatedKeys": [
      "cpp:PPIncludeNonStandardCharacters"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S835",
    "name": "Braces should be used to indicate and match the structure in the non-zero initialization of arrays and structures",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "FORMATTED",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eISO/IEC 14882:2003 [1] requires initializer lists for arrays, structures and union types to be enclosed in a single pair of braces (though the\nbehaviour if this is not done is undefined). The rule given here goes further in requiring the use of additional braces to indicate nested\nstructures.\u003c/p\u003e\n\u003cp\u003eThis forces the developer to explicitly consider and demonstrate the order in which elements of complex data types are initialized (e.g.\nmulti-dimensional arrays).\u003c/p\u003e\n\u003cp\u003eThe zero initialization of arrays or structures shall only be applied at the top level.\u003c/p\u003e\n\u003cp\u003eThe non-zero initialization of arrays or structures requires an explicit initializer for each element.\u003c/p\u003e\n\u003cp\u003eA similar principle applies to structures, and nested combinations of structures, arrays and other types.\u003c/p\u003e\n\u003cp\u003eNote also that all the elements of arrays or structures can be initialized (to zero or NULL) by giving an explicit initializer for the first\nelement only. If this method of initialization is chosen then the first element should be initialized to zero (or NULL), and nested braces need not be\nused.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint a1[3][2] \u003d { 1, 2, 3, 4, 5, 6 }; // Noncompliant\nint a2[5] \u003d { 1, 2, 3 }; // Noncompliant, partial initialization\nint a3[2][2] \u003d { { }, { 1, 2 } }; // Noncompliant, zero initialization at sub-level\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint a1[3][2] \u003d { { 1, 2 }, { 3, 4 }, { 5, 6 } }; // Compliant\nint a2[5] \u003d { 1, 2, 3, 0, 0 }; // Compliant, Non-zero initialization\nint a2[5] \u003d { 0 }; // Compliant, zero initialization\nint a3[2][2] \u003d { }; // Compliant, zero initialization\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 9.2 - Braces shall be used to indicate and match the structure in the non-zero initialization of arrays and structures. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 8-5-2 - Braces shall be used to indicate and match the structure in the nonzero initialization of arrays and structures. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 9.2 - The initializer of an aggregate or union shall be enclosed in braces. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 9.3 - Arrays shall not be partially initialized. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eISO/IEC 14882:2003 [1] requires initializer lists for arrays, structures and union types to be enclosed in a single pair of braces (though the\nbehaviour if this is not done is undefined). The rule given here goes further in requiring the use of additional braces to indicate nested\nstructures.\u003c/p\u003e\n\u003cp\u003eThis forces the developer to explicitly consider and demonstrate the order in which elements of complex data types are initialized (e.g.\nmulti-dimensional arrays).\u003c/p\u003e\n\u003cp\u003eThe zero initialization of arrays or structures shall only be applied at the top level.\u003c/p\u003e\n\u003cp\u003eThe non-zero initialization of arrays or structures requires an explicit initializer for each element.\u003c/p\u003e\n\u003cp\u003eA similar principle applies to structures, and nested combinations of structures, arrays and other types.\u003c/p\u003e\n\u003cp\u003eNote also that all the elements of arrays or structures can be initialized (to zero or NULL) by giving an explicit initializer for the first\nelement only. If this method of initialization is chosen then the first element should be initialized to zero (or NULL), and nested braces need not be\nused.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint a1[3][2] \u003d { 1, 2, 3, 4, 5, 6 }; // Noncompliant\nint a2[5] \u003d { 1, 2, 3 }; // Noncompliant, partial initialization\nint a3[2][2] \u003d { { }, { 1, 2 } }; // Noncompliant, zero initialization at sub-level\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint a1[3][2] \u003d { { 1, 2 }, { 3, 4 }, { 5, 6 } }; // Compliant\nint a2[5] \u003d { 1, 2, 3, 0, 0 }; // Compliant, Non-zero initialization\nint a2[5] \u003d { 0 }; // Compliant, zero initialization\nint a3[2][2] \u003d { }; // Compliant, zero initialization\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 9.2 - Braces shall be used to indicate and match the structure in the non-zero initialization of arrays and structures. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 8-5-2 - Braces shall be used to indicate and match the structure in the nonzero initialization of arrays and structures. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 9.2 - The initializer of an aggregate or union shall be enclosed in braces. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 9.3 - Arrays shall not be partially initialized. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "based-on-misra"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S956",
    "name": "\"#include\" directives should be followed by either \u003cfilename\u003e or \"filename\" sequences",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003e#include\u003c/code\u003e directive is a preprocessor directive that tells the compiler to insert the contents of a file in the source code.\u003c/p\u003e\n\u003cp\u003eHowever, the standard only allows the \u003ccode\u003e#include\u003c/code\u003e directive to be followed by angle brackets (\u003ccode\u003e\u0026lt;filename.h\u0026gt;\u003c/code\u003e) or double\nquotes (\u003ccode\u003e\"filename.h\"\u003c/code\u003e).\u003c/p\u003e\n\u003cp\u003eIf the \u003ccode\u003e#include\u003c/code\u003e directive contains macro names, the result of their expansion must also follow this rule:\u003c/p\u003e\n\u003cpre\u003e\n#define HEADER \"filename.h\"\n#include HEADER // Compliant\n\u003c/pre\u003e\n\u003cp\u003eThe behavior is undefined if neither angle brackets nor double quotes follow the \u003ccode\u003e#include\u003c/code\u003e directive.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 19.3 - The #include directive shall be followed by either a \u0026lt;filename\u0026gt; or \"filename\" sequence. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 16-2-6 - The #include directive shall be followed by either a \u0026lt;filename\u0026gt; or \"filename\" sequence. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 20.3 - The #include directive shall be followed by either a \u0026lt;filename\u0026gt; or \"filename\" sequence \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe \u003ccode\u003e#include\u003c/code\u003e directive is a preprocessor directive that tells the compiler to insert the contents of a file in the source code.\u003c/p\u003e\n\u003cp\u003eHowever, the standard only allows the \u003ccode\u003e#include\u003c/code\u003e directive to be followed by angle brackets (\u003ccode\u003e\u0026lt;filename.h\u0026gt;\u003c/code\u003e) or double\nquotes (\u003ccode\u003e\"filename.h\"\u003c/code\u003e).\u003c/p\u003e\n\u003cp\u003eIf the \u003ccode\u003e#include\u003c/code\u003e directive contains macro names, the result of their expansion must also follow this rule:\u003c/p\u003e\n\u003cpre\u003e\n#define HEADER \"filename.h\"\n#include HEADER // Compliant\n\u003c/pre\u003e\n\u003cp\u003eThe behavior is undefined if neither angle brackets nor double quotes follow the \u003ccode\u003e#include\u003c/code\u003e directive.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 19.3 - The #include directive shall be followed by either a \u0026lt;filename\u0026gt; or \"filename\" sequence. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 16-2-6 - The #include directive shall be followed by either a \u0026lt;filename\u0026gt; or \"filename\" sequence. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 20.3 - The #include directive shall be followed by either a \u0026lt;filename\u0026gt; or \"filename\" sequence \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "based-on-misra"
    ],
    "deprecatedKeys": [
      "cpp:PPBadIncludeForm"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S953",
    "name": "Unions should not be used",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe use of unions to access an object in different ways may result in the data being misinterpreted. Therefore, this rule prohibits the use of\nunions for any purpose.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nunion U1 { // Noncompliant\n    float j;\n    int i;\n};\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 18.4 - Unions shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 9-5-1 - Unions shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 19.2 - The union keyword should not be used \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe use of unions to access an object in different ways may result in the data being misinterpreted. Therefore, this rule prohibits the use of\nunions for any purpose.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nunion U1 { // Noncompliant\n    float j;\n    int i;\n};\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 18.4 - Unions shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 9-5-1 - Unions shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 19.2 - The union keyword should not be used \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "based-on-misra"
    ],
    "deprecatedKeys": [
      "cpp:Union"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S833",
    "name": "If a function has internal linkage then all re-declarations shall include the static storage class specifer",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThis rule is a strict implementation of a MISRA (Motor Industry Software Reliability Association) rule. MISRA defines best practices for developing\nsafety-critical software. You can learn more about this rule in the MISRA documents referenced below.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++ 2008, 3-3-2 \u003c/li\u003e\n  \u003cli\u003e MISRA C 2004, 8.11 \u003c/li\u003e\n  \u003cli\u003e MISRA C 2012, 8.8 \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThis rule is a strict implementation of a MISRA (Motor Industry Software Reliability Association) rule. MISRA defines best practices for developing\nsafety-critical software. You can learn more about this rule in the MISRA documents referenced below.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C++ 2008, 3-3-2 \u003c/li\u003e\n  \u003cli\u003e MISRA C 2004, 8.11 \u003c/li\u003e\n  \u003cli\u003e MISRA C 2012, 8.8 \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "misra-c++2008",
      "misra-c2004",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S954",
    "name": "#include directives in a file should only be preceded by other preprocessor directives or comments",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eTo aid code readability, all the \u003ccode\u003e#include\u003c/code\u003e directives in a particular code file should be grouped together near the top of the file.\nThe only items which may precede an \u003ccode\u003e#include\u003c/code\u003e in a file are other preprocessor directives or comments.\u003c/p\u003e\n\u003cp\u003eAdditionally, an \u003ccode\u003e#include\u003c/code\u003e may appear within an \u003ccode\u003eextern \"C\"\u003c/code\u003e block, this can be used for instance to include a C file from a\nC++ file.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;h1.h\u0026gt; /* Compliant */\nint32_t i;\n#include \u0026lt;f2.h\u0026gt; /* Noncompliant */\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;h1.h\u0026gt;\n#include \u0026lt;f2.h\u0026gt;\nextern \"C\" {\n#include \u0026lt;f3.h\u0026gt;\n}\n\nint32_t i;\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 19.1 - #include statements in a file should only be preceded by other preprocessor directives or comments. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 16-0-1 - #include directives in a file shall only be preceded by other preprocessor directives or comments. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 20.1 - #include directives should only be preceded by preprocessor directives or comments \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eTo aid code readability, all the \u003ccode\u003e#include\u003c/code\u003e directives in a particular code file should be grouped together near the top of the file.\nThe only items which may precede an \u003ccode\u003e#include\u003c/code\u003e in a file are other preprocessor directives or comments.\u003c/p\u003e\n\u003cp\u003eAdditionally, an \u003ccode\u003e#include\u003c/code\u003e may appear within an \u003ccode\u003eextern \"C\"\u003c/code\u003e block, this can be used for instance to include a C file from a\nC++ file.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;h1.h\u0026gt; /* Compliant */\nint32_t i;\n#include \u0026lt;f2.h\u0026gt; /* Noncompliant */\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;h1.h\u0026gt;\n#include \u0026lt;f2.h\u0026gt;\nextern \"C\" {\n#include \u0026lt;f3.h\u0026gt;\n}\n\nint32_t i;\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 19.1 - #include statements in a file should only be preceded by other preprocessor directives or comments. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 16-0-1 - #include directives in a file shall only be preceded by other preprocessor directives or comments. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 20.1 - #include directives should only be preceded by preprocessor directives or comments \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "confusing",
      "misra-c++2008",
      "misra-c2004",
      "misra-c2012"
    ],
    "deprecatedKeys": [
      "cpp:PPIncludeNotAtTop"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1181",
    "name": "Generic exceptions should not be caught",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eSome exception classes are designed to be used only as base classes to more specific exceptions, for instance, \u003ccode\u003estd::exception\u003c/code\u003e (the\nbase class of all standard C++ exceptions), \u003ccode\u003estd::logic_error\u003c/code\u003e or \u003ccode\u003estd::runtime_error\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eCatching such generic exception types is usually a bad idea because it implies that the \"catch\" block is clever enough to handle any type of\nexception.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\ntry {\n  /* code that may throw std::system_error */\n} catch (const std::exception \u0026amp;ex) { // Noncompliant\n  /*...*/\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\ntry {\n  /* code that may throw std::system_error */\n} catch (const std::system_error \u0026amp;ex) {\n  /*...*/\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThere are cases, though, where you want to catch all exceptions because no exceptions should be allowed to escape the function, and generic\n\u003ccode\u003ecatch\u003c/code\u003e handlers are excluded from the rule:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e In the main function \u003c/li\u003e\n  \u003cli\u003e In a class destructor \u003c/li\u003e\n  \u003cli\u003e In a \u003ccode\u003enoexcept\u003c/code\u003e function \u003c/li\u003e\n  \u003cli\u003e In an \u003ccode\u003eextern \"C\"\u003c/code\u003e function \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eAdditionally, if the \u003ccode\u003ecatch\u003c/code\u003e handler is throwing an exception (either the same as before, with \u003ccode\u003ethrow;\u003c/code\u003e or a new one that may\nmake more sense to the callers of the function) or is never exiting (because it calls a \u003ccode\u003enoreturn\u003c/code\u003e function, for instance\n\u003ccode\u003eexit\u003c/code\u003e), then the accurate type of the exception usually does not matter any longer: this case is excluded too.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/396\"\u003eMITRE, CWE-396\u003c/a\u003e - Declaration of Catch for Generic Exception \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#e14-use-purpose-designed-user-defined-types-as-exceptions-not-built-in-types\"\u003eE.14: Use purpose-designed user-defined types as exceptions (not built-in types)\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eSome exception classes are designed to be used only as base classes to more specific exceptions, for instance, \u003ccode\u003estd::exception\u003c/code\u003e (the\nbase class of all standard C++ exceptions), \u003ccode\u003estd::logic_error\u003c/code\u003e or \u003ccode\u003estd::runtime_error\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eCatching such generic exception types is usually a bad idea because it implies that the \"catch\" block is clever enough to handle any type of\nexception.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\ntry {\n  /* code that may throw std::system_error */\n} catch (const std::exception \u0026amp;ex) { // Noncompliant\n  /*...*/\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\ntry {\n  /* code that may throw std::system_error */\n} catch (const std::system_error \u0026amp;ex) {\n  /*...*/\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThere are cases, though, where you want to catch all exceptions because no exceptions should be allowed to escape the function, and generic\n\u003ccode\u003ecatch\u003c/code\u003e handlers are excluded from the rule:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e In the main function \u003c/li\u003e\n  \u003cli\u003e In a class destructor \u003c/li\u003e\n  \u003cli\u003e In a \u003ccode\u003enoexcept\u003c/code\u003e function \u003c/li\u003e\n  \u003cli\u003e In an \u003ccode\u003eextern \"C\"\u003c/code\u003e function \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eAdditionally, if the \u003ccode\u003ecatch\u003c/code\u003e handler is throwing an exception (either the same as before, with \u003ccode\u003ethrow;\u003c/code\u003e or a new one that may\nmake more sense to the callers of the function) or is never exiting (because it calls a \u003ccode\u003enoreturn\u003c/code\u003e function, for instance\n\u003ccode\u003eexit\u003c/code\u003e), then the accurate type of the exception usually does not matter any longer: this case is excluded too.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/396\"\u003eMITRE, CWE-396\u003c/a\u003e - Declaration of Catch for Generic Exception \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#e14-use-purpose-designed-user-defined-types-as-exceptions-not-built-in-types\"\u003eE.14: Use purpose-designed user-defined types as exceptions (not built-in types)\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "bad-practice",
      "cert",
      "cppcoreguidelines",
      "cwe",
      "error-handling"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5782",
    "name": "POSIX functions should not be called with arguments that trigger buffer overflows",
    "defaultSeverity": "BLOCKER",
    "type": "VULNERABILITY",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM",
      "SECURITY": "HIGH"
    },
    "description": "\u003cp\u003eSome POSIX functions take one argument that is a buffer and another one that represents the size of the buffer. It is up to the developer to make\nsure the two arguments do match and that the size argument does not exceed the buffer’s size.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhen the size argument exceeds the actual size of the buffer, the memory management functions will either read or write data past the buffer memory\nboundary into adjacent memory. Because the memory might be uninitialized or contain other pieces of data, the behavior of the affected function can\nnot be predicted and will likely trigger bugs.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eBuffer boundaries violations can lead to serious security issues.\u003c/p\u003e\n\u003ch4\u003eInformation disclosure\u003c/h4\u003e\n\u003cp\u003eIn some scenarios, insecure functions can lead to information disclosure. For instance, if an attacker can cause a buffer overread, they might be\nable to disclose data in memory that they’re not supposed to have access to. This could potentially allow them to access sensitive information, such\nas passwords or encryption keys. An example of a buffer overread is provided with the Heartbleed vulnerability. \u003d\u003d\u003d\u003d Code execution\u003c/p\u003e\n\u003cp\u003eIn some cases, an attacker can craft input in a way that allows them to gain unauthorized access to your system. For example, they might be able to\noverwrite a function’s return address in memory, causing your program to execute code of the attacker’s choosing. This could potentially give the\nattacker full control over your system.\u003c/p\u003e\n\u003ch4\u003eDenial of service\u003c/h4\u003e\n\u003cp\u003eIf an attacker can trigger a buffer overflow by providing oversized input, it can cause the program to crash. If the attacker repeats this process,\nit can continually disrupt the service, denying access to other users. This can be particularly damaging for services that require high availability,\nsuch as online platforms or databases.\u003c/p\u003e\n\u003cp\u003eIn some cases, the input might cause the program to enter an infinite loop or consume excessive memory, slowing down the system or even causing it\nto become unresponsive. This type of attack is known as a resource exhaustion DoS attack.\u003c/p\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eFunctions related to sockets using the type \u003ccode\u003esocklen_t\u003c/code\u003e are not checked. This is because these functions are using a C-style polymorphic\npattern using \u003ccode\u003eunion\u003c/code\u003e. It relies on a mismatch between allocated memory and sizes of structures and it creates false positives.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003cp\u003eIn the following code example, \u003ccode\u003ememchr\u003c/code\u003e is used to find the first occurrence of the \u003ccode\u003e@\u003c/code\u003e character in a buffer,\n\u003ccode\u003earray\u003c/code\u003e. The second argument does not match the size of this buffer, so it may find an occurrence of the character after the end of the\nbuffer and read data it is not supposed to. If the returned \u003ccode\u003epos\u003c/code\u003e pointer is later used to write characters, this could unexpectedly\noverwrite data.\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nchar array[10];\ninitialize(array);\nchar *pos \u003d memchr(array, \u0027@\u0027, 42); // Noncompliant\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nchar array[10];\ninitialize(array);\nchar *pos \u003d memchr(array, \u0027@\u0027, sizeof(array));\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eArticles \u0026amp; blog posts\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Heartbleed - \u003ca href\u003d\"https://heartbleed.com/\"\u003eThe Heartbleed Bug\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e OWASP - \u003ca href\u003d\"https://owasp.org/Top10/A06_2021-Vulnerable_and_Outdated_Components/\"\u003eTop 10 2021 - A06 - Vulnerable and Outdated\n  Components\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e OWASP - \u003ca href\u003d\"https://owasp.org/www-project-top-ten/2017/A9_2017-Using_Components_with_Known_Vulnerabilities\"\u003eOWASP Top 10 2017 Category A9\n  - Using Components with Known Vulnerabilities\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/119\"\u003eCWE-119 - Improper Restriction of Operations within the Bounds of a Memory\n  Buffer\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/131\"\u003eCWE-131 - Incorrect Calculation of Buffer Size\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/788\"\u003eCWE-788 - Access of Memory Location After End of Buffer\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/wtYxBQ\"\u003eARR30-C. - Do not form or use out-of-bounds pointers or array subscripts\u003c/a\u003e\n  \u003c/li\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/i3w-BQ\"\u003eSTR50-CPP. - Guarantee that storage for strings has sufficient space for\n  character data and the null terminator\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eSome POSIX functions take one argument that is a buffer and another one that represents the size of the buffer. It is up to the developer to make\nsure the two arguments do match and that the size argument does not exceed the buffer’s size.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhen the size argument exceeds the actual size of the buffer, the memory management functions will either read or write data past the buffer memory\nboundary into adjacent memory. Because the memory might be uninitialized or contain other pieces of data, the behavior of the affected function can\nnot be predicted and will likely trigger bugs.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eBuffer boundaries violations can lead to serious security issues.\u003c/p\u003e\n\u003ch4\u003eInformation disclosure\u003c/h4\u003e\n\u003cp\u003eIn some scenarios, insecure functions can lead to information disclosure. For instance, if an attacker can cause a buffer overread, they might be\nable to disclose data in memory that they’re not supposed to have access to. This could potentially allow them to access sensitive information, such\nas passwords or encryption keys. An example of a buffer overread is provided with the Heartbleed vulnerability. \u003d\u003d\u003d\u003d Code execution\u003c/p\u003e\n\u003cp\u003eIn some cases, an attacker can craft input in a way that allows them to gain unauthorized access to your system. For example, they might be able to\noverwrite a function’s return address in memory, causing your program to execute code of the attacker’s choosing. This could potentially give the\nattacker full control over your system.\u003c/p\u003e\n\u003ch4\u003eDenial of service\u003c/h4\u003e\n\u003cp\u003eIf an attacker can trigger a buffer overflow by providing oversized input, it can cause the program to crash. If the attacker repeats this process,\nit can continually disrupt the service, denying access to other users. This can be particularly damaging for services that require high availability,\nsuch as online platforms or databases.\u003c/p\u003e\n\u003cp\u003eIn some cases, the input might cause the program to enter an infinite loop or consume excessive memory, slowing down the system or even causing it\nto become unresponsive. This type of attack is known as a resource exhaustion DoS attack.\u003c/p\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eFunctions related to sockets using the type \u003ccode\u003esocklen_t\u003c/code\u003e are not checked. This is because these functions are using a C-style polymorphic\npattern using \u003ccode\u003eunion\u003c/code\u003e. It relies on a mismatch between allocated memory and sizes of structures and it creates false positives.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eIn the following code example, \u003ccode\u003ememchr\u003c/code\u003e is used to find the first occurrence of the \u003ccode\u003e@\u003c/code\u003e character in a buffer,\n\u003ccode\u003earray\u003c/code\u003e. The second argument does not match the size of this buffer, so it may find an occurrence of the character after the end of the\nbuffer and read data it is not supposed to. If the returned \u003ccode\u003epos\u003c/code\u003e pointer is later used to write characters, this could unexpectedly\noverwrite data.\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nchar array[10];\ninitialize(array);\nchar *pos \u003d memchr(array, \u0027@\u0027, 42); // Noncompliant\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nchar array[10];\ninitialize(array);\nchar *pos \u003d memchr(array, \u0027@\u0027, sizeof(array));\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eArticles \u0026amp; blog posts\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Heartbleed - \u003ca href\u003d\"https://heartbleed.com/\"\u003eThe Heartbleed Bug\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e OWASP - \u003ca href\u003d\"https://owasp.org/Top10/A06_2021-Vulnerable_and_Outdated_Components/\"\u003eTop 10 2021 - A06 - Vulnerable and Outdated\n  Components\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e OWASP - \u003ca href\u003d\"https://owasp.org/www-project-top-ten/2017/A9_2017-Using_Components_with_Known_Vulnerabilities\"\u003eOWASP Top 10 2017 Category A9\n  - Using Components with Known Vulnerabilities\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/119\"\u003eCWE-119 - Improper Restriction of Operations within the Bounds of a Memory\n  Buffer\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/131\"\u003eCWE-131 - Incorrect Calculation of Buffer Size\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/788\"\u003eCWE-788 - Access of Memory Location After End of Buffer\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/wtYxBQ\"\u003eARR30-C. - Do not form or use out-of-bounds pointers or array subscripts\u003c/a\u003e\n  \u003c/li\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/i3w-BQ\"\u003eSTR50-CPP. - Guarantee that storage for strings has sufficient space for\n  character data and the null terminator\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cert",
      "cwe",
      "symbolic-execution"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S831",
    "name": "Objects or functions with external linkage shall be declared in a header file",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThis rule is a strict implementation of a MISRA (Motor Industry Software Reliability Association) rule. MISRA defines best practices for developing\nsafety-critical software. You can learn more about this rule in the MISRA documents referenced below.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++ 2008, 3-3-1 \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThis rule is a strict implementation of a MISRA (Motor Industry Software Reliability Association) rule. MISRA defines best practices for developing\nsafety-critical software. You can learn more about this rule in the MISRA documents referenced below.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C++ 2008, 3-3-1 \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "misra-c++2008"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S959",
    "name": "\"#undef\" should be used with caution",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eCode that contains many macros becomes hard to understand. This is even worse when the set of defined macros is not stable, and you have to know at\neach point what macros are defined. Therefore, \u003ccode\u003e#undef\u003c/code\u003e can decrease the readability of macros.\u003c/p\u003e\n\u003cp\u003eHowever, well-disciplined use of \u003ccode\u003e#undef\u003c/code\u003e can also improve readability, for instance when defining a macro with a limited scope: The\nmacro is \u003ccode\u003e#defined\u003c/code\u003e, used a couple of times to reduce code duplication, then immediately \u003ccode\u003e#undefed\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when a \u003ccode\u003e#undef\u003c/code\u003e undefines a macro that was defined in another file. It will also raise an issue for an\n\u003ccode\u003e#undef\u003c/code\u003e directive that tries to undefine a non-existing macro.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#ifndef MY_HDR\n#define MY_HDR\n#endif\n...\n#undef MY_HDR    /* Noncompliant */\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#define LEVEL(i) int const i \u003d #i\nLEVEL(Debug);\nLEVEL(Warning);\nLEVEL(Error);\n#undef LEVEL\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 19.6 - #undef shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 16-0-3 - #undef shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 20.5 - #undef should not be used \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eCode that contains many macros becomes hard to understand. This is even worse when the set of defined macros is not stable, and you have to know at\neach point what macros are defined. Therefore, \u003ccode\u003e#undef\u003c/code\u003e can decrease the readability of macros.\u003c/p\u003e\n\u003cp\u003eHowever, well-disciplined use of \u003ccode\u003e#undef\u003c/code\u003e can also improve readability, for instance when defining a macro with a limited scope: The\nmacro is \u003ccode\u003e#defined\u003c/code\u003e, used a couple of times to reduce code duplication, then immediately \u003ccode\u003e#undefed\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when a \u003ccode\u003e#undef\u003c/code\u003e undefines a macro that was defined in another file. It will also raise an issue for an\n\u003ccode\u003e#undef\u003c/code\u003e directive that tries to undefine a non-existing macro.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#ifndef MY_HDR\n#define MY_HDR\n#endif\n...\n#undef MY_HDR    /* Noncompliant */\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#define LEVEL(i) int const i \u003d #i\nLEVEL(Debug);\nLEVEL(Warning);\nLEVEL(Error);\n#undef LEVEL\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 19.6 - #undef shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 16-0-3 - #undef shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 20.5 - #undef should not be used \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "brain-overload"
    ],
    "deprecatedKeys": [
      "cpp:PPUndefUsage"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:M23_089",
    "name": "C-style casts and \"functional notation\" casts shall not be used",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 8.2.2\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eThis rule does not apply to \u003cem\u003efunctional notation\u003c/em\u003e casts that use curly braces or that result in a constructor call.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eC-style casts and \u003cem\u003efunctional notation\u003c/em\u003e casts raise several concerns:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e They permit almost any type to be converted to almost any other type without checks; \u003c/li\u003e\n  \u003cli\u003e They give no indication why the conversion is taking place; \u003c/li\u003e\n  \u003cli\u003e Their syntax is more difficult to recognize. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThese concerns can be addressed with the use of \u003ccode\u003econst_cast\u003c/code\u003e, \u003ccode\u003edynamic_cast\u003c/code\u003e, \u003ccode\u003ereinterpret_cast\u003c/code\u003e and\n\u003ccode\u003estatic_cast\u003c/code\u003e, which:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Enforce constraints on the types involved; \u003c/li\u003e\n  \u003cli\u003e Give a better indication of the cast’s intent; \u003c/li\u003e\n  \u003cli\u003e Are easy to identify. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eException\u003c/h3\u003e\n\u003cp\u003eA C-style cast to \u003ccode\u003evoid\u003c/code\u003e is permitted, as this allows the intentional discarding of a value to be made explicit — for instance, the\nreturn value of a non-void function call (see {rule:cpp:M23_007}: MISRA C++ 2023 Rule\u0026nbsp;0.1.2).\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nint32_t g();\n\nvoid f1()\n{\n  ( void ) g();  // Compliant by exception\n}\n\u003c/pre\u003e\n\u003cp\u003eIn the following example (which violates {rule:cpp:M23_090}: MISRA C++ 2023 Rule\u0026nbsp;8.2.3), the C-style casts from \u003ccode\u003ea1\u003c/code\u003e to the\nnon-const pointer \u003ccode\u003ea2\u003c/code\u003e is more permissive than necessary. If the type of \u003ccode\u003ea1\u003c/code\u003e is not \u003ccode\u003eA\u003c/code\u003e, then the C-style cast to\n\u003ccode\u003ea2\u003c/code\u003e will compile, resulting in \u003cem\u003eundefined behaviour\u003c/em\u003e. The equivalent \u003ccode\u003econst_cast\u003c/code\u003e to \u003ccode\u003ea3\u003c/code\u003e will not compile if\nthe type of \u003ccode\u003ea1\u003c/code\u003e is changed.\u003c/p\u003e\n\u003cpre\u003e\nstruct A\n{\n  A( char c);\n};\n\nstruct B {};\n\nvoid f1a( A x )\n{\n  auto const \u0026amp; a1 \u003d x;\n  A          * a2 \u003d ( A * )\u0026amp;a1;                // Non-compliant\n  A          * a3 \u003d const_cast\u0026lt; A * \u0026gt;( \u0026amp;a1 );\n}\n\nvoid f1b( B x )\n{\n  auto const \u0026amp; a1 \u003d x;\n  A          * a2 \u003d ( A * )\u0026amp;a1;                // Non-compliant\n  A          * a3 \u003d const_cast\u0026lt; A * \u0026gt;( \u0026amp;a1 );  // Ill-formed\n}\n\nvoid f2( int32_t x )\n{\n  auto i \u003d A( \u0027c\u0027 );        // Rule does not apply - constructor is called\n  auto j \u003d int8_t { 42 };   // Rule does not apply - use of curly braces\n  auto k \u003d int8_t ( x );    // Non-compliant - does not construct an object\n}                           // of class type\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S871} targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:M23_007}: MISRA C++ 2023 Rule\u0026nbsp;0.1.2 - The value returned by a function shall be \u003cem\u003eused\u003c/em\u003e \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:M23_090}: MISRA C++ 2023 Rule\u0026nbsp;8.2.3 - A cast shall not remove any \u003ccode\u003econst\u003c/code\u003e or \u003ccode\u003evolatile\u003c/code\u003e qualification from\n  the type accessed via a pointer or by reference \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 8.2.2\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eThis rule does not apply to \u003cem\u003efunctional notation\u003c/em\u003e casts that use curly braces or that result in a constructor call.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eC-style casts and \u003cem\u003efunctional notation\u003c/em\u003e casts raise several concerns:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e They permit almost any type to be converted to almost any other type without checks; \u003c/li\u003e\n  \u003cli\u003e They give no indication why the conversion is taking place; \u003c/li\u003e\n  \u003cli\u003e Their syntax is more difficult to recognize. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThese concerns can be addressed with the use of \u003ccode\u003econst_cast\u003c/code\u003e, \u003ccode\u003edynamic_cast\u003c/code\u003e, \u003ccode\u003ereinterpret_cast\u003c/code\u003e and\n\u003ccode\u003estatic_cast\u003c/code\u003e, which:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Enforce constraints on the types involved; \u003c/li\u003e\n  \u003cli\u003e Give a better indication of the cast’s intent; \u003c/li\u003e\n  \u003cli\u003e Are easy to identify. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eException\u003c/h3\u003e\n\u003cp\u003eA C-style cast to \u003ccode\u003evoid\u003c/code\u003e is permitted, as this allows the intentional discarding of a value to be made explicit — for instance, the\nreturn value of a non-void function call (see {rule:cpp:M23_007}: MISRA C++ 2023 Rule\u0026nbsp;0.1.2).\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nint32_t g();\n\nvoid f1()\n{\n  ( void ) g();  // Compliant by exception\n}\n\u003c/pre\u003e\n\u003cp\u003eIn the following example (which violates {rule:cpp:M23_090}: MISRA C++ 2023 Rule\u0026nbsp;8.2.3), the C-style casts from \u003ccode\u003ea1\u003c/code\u003e to the\nnon-const pointer \u003ccode\u003ea2\u003c/code\u003e is more permissive than necessary. If the type of \u003ccode\u003ea1\u003c/code\u003e is not \u003ccode\u003eA\u003c/code\u003e, then the C-style cast to\n\u003ccode\u003ea2\u003c/code\u003e will compile, resulting in \u003cem\u003eundefined behaviour\u003c/em\u003e. The equivalent \u003ccode\u003econst_cast\u003c/code\u003e to \u003ccode\u003ea3\u003c/code\u003e will not compile if\nthe type of \u003ccode\u003ea1\u003c/code\u003e is changed.\u003c/p\u003e\n\u003cpre\u003e\nstruct A\n{\n  A( char c);\n};\n\nstruct B {};\n\nvoid f1a( A x )\n{\n  auto const \u0026amp; a1 \u003d x;\n  A          * a2 \u003d ( A * )\u0026amp;a1;                // Non-compliant\n  A          * a3 \u003d const_cast\u0026lt; A * \u0026gt;( \u0026amp;a1 );\n}\n\nvoid f1b( B x )\n{\n  auto const \u0026amp; a1 \u003d x;\n  A          * a2 \u003d ( A * )\u0026amp;a1;                // Non-compliant\n  A          * a3 \u003d const_cast\u0026lt; A * \u0026gt;( \u0026amp;a1 );  // Ill-formed\n}\n\nvoid f2( int32_t x )\n{\n  auto i \u003d A( \u0027c\u0027 );        // Rule does not apply - constructor is called\n  auto j \u003d int8_t { 42 };   // Rule does not apply - use of curly braces\n  auto k \u003d int8_t ( x );    // Non-compliant - does not construct an object\n}                           // of class type\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S871} targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:M23_007}: MISRA C++ 2023 Rule\u0026nbsp;0.1.2 - The value returned by a function shall be \u003cem\u003eused\u003c/em\u003e \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:M23_090}: MISRA C++ 2023 Rule\u0026nbsp;8.2.3 - A cast shall not remove any \u003ccode\u003econst\u003c/code\u003e or \u003ccode\u003evolatile\u003c/code\u003e qualification from\n  the type accessed via a pointer or by reference \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "misra-c++2023",
      "misra-required",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S836",
    "name": "Variables should be initialized before use",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003cp\u003eVariables should be initialized before their use to avoid unexpected behavior due to garbage values.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eA local variable of any built-in type (such as \u003ccode\u003eint\u003c/code\u003e, \u003ccode\u003efloat\u003c/code\u003e, and pointers), declared without an initial value is not\ninitialized to any particular value. Consequently, if no value is assigned to such a variable first, the code that uses it has no defined\nbehavior.\u003c/p\u003e\n\u003cpre\u003e\nint addition() {\n  int x;  // x is not initialized\n  return x + 10; // Noncompliant: x has grabage value\n}\n\nint dereference() {\n  int* p; // p is not initialized\n  return *p; // Noncompliant: p has garbage value\n}\n\u003c/pre\u003e\n\u003cp\u003eSimilarly, structures that simply aggregate variables of built-in types, such as arrays or \u003ccode\u003estruct\u003c/code\u003e/\u003ccode\u003eclass\u003c/code\u003e types without a\nconstructor, will not initialize their members when declared without an initializer:\u003c/p\u003e\n\u003cpre\u003e\nstruct Aggregate {\n  int i;\n  float f;\n};\n\nvoid aggregates() {\n  int* intArray[5]; // each element of array is not initializer\n  Aggregate aggr; // members aggr.i, agrr.f are not initialized\n  Aggregate aggrArray[2]; // members of each element are not initialized\n}\n\u003c/pre\u003e\n\u003cp\u003eFinally, allocating objects of builtin or such aggregates types on the heap, also does not initialize their values:\u003c/p\u003e\n\u003cpre\u003e\nvoid usingMalloc() {\n  int* intArr \u003d (int*)malloc(sizeof(int) * 10); // each of 10 allocated integers is not initialized\n}\n\u003c/pre\u003e\n\u003cp\u003eThis also applies when \u003ccode\u003enew\u003c/code\u003e is used in C++:\u003c/p\u003e\n\u003cpre\u003e\nvoid usingNew() {\n  Aggregate* aggrPtr \u003d new Aggregate; // members of allocated Aggregate are not initialized\n  Aggregate* aggrArr \u003d new Aggregate[5]; // members of each of 5 Aggregate objects are not initialized\n}\n\u003c/pre\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eUsing garbage values will cause the program to behave nondeterministically at runtime. The program may produce a different output or crash\ndepending on the run.\u003c/p\u003e\n\u003cp\u003eIn some situations, loading a variable may expose a sensitive data, such as a password that was previously stored in the same location, leading to\na vulnerability that uses such a defect as a gadget for extracting information from the instance of the program.\u003c/p\u003e\n\u003cp\u003eFinally, in C++, outside of a few exceptions related to the uses of \u003ccode\u003eunsigned char\u003c/code\u003e or \u003ccode\u003estd::byte\u003c/code\u003e, loading data from an\nuninitialized variable causes undefined behavior. This means that the compiler is not bound by the language standard anymore, and the program has no\nmeaning assigned to it. As a consequence, the impact of such a defect is not limited to the use of garbage values.\u003c/p\u003e\n\u003ch3\u003eWhy is there an issue for a class with a default constructor?\u003c/h3\u003e\n\u003cp\u003eIn C++, a class can define a default constructor invoked when an object of the given type is created. Such a constructor is called even if a\nvariable is declared without any initializer. However, if the constructor code omits the initialization of a member that itself does not have the\ndefault constructor, the member will remain uninitialized (See also {rule:cpp:S2107}). And reading from it will produce a garbage value:\u003c/p\u003e\n\u003cpre\u003e\nstruct Partial {\n  // x is not initialized\n  Partial() : y(10.0) {}\n\n  int x;\n  float y;\n};\n\nint initialized() {\n  Partial p; // constructor is called\n  // or even Partial p{};\n  return p.x; // Non-compliant: reading an uninitialized variable\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThis rule does not flag the variables with static storage duration, meaning: global, static, and thread-local variables.\u003c/p\u003e\n\u003cp\u003eAll the variables with static storage duration are zero-initialized before the initializer is evaluated. As a consequence, any variable or member\nof such an object has a defined value even if no initializer is specified.\u003c/p\u003e\n\u003cpre\u003e\nint globInt;\nint globTab[10];\nAggregate globAggr;\nPartial globPart; // x member is zero-initialized\n\nint uses() {\n  static int staticInt;\n  return globInt     // Compliant: all zero-initialized\n       + globTab[2]\n       + globAggr.f\n       + globPart.x\n       + staticInt;\n}\n\u003c/pre\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eCommonly, the use of an uninitialized object is an indication of a defect in the code, where either variable initialization was skipped on some\ncode paths, or the object is used by mistake. Generally, you can address such problems by:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Initializing variables on the declaration with a valid value \u003c/li\u003e\n  \u003cli\u003e Assigning to the variable on the code path(s) that was missing initialization \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWhenever possible, it is preferable to initialize a variable with its final value on the declaration, as this eliminates the possibility of this\ndefect occurring.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nint function(int flag, int b) {\n  int a;\n  if (flag) {\n    a \u003d b;\n  }\n  return a; // Noncompliant: \"a\" has not been initialized in all paths\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eInitializing variable on all code paths:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nint function(int flag, int b) {\n  int a;\n  if (flag) {\n    a \u003d b;\n  } else {\n    a \u003d 10;\n  }\n  return a; // Compliant\n}\n\u003c/pre\u003e\n\u003cp\u003eSkipping path that leads to the read of an uninitialized value:\u003c/p\u003e\n\u003cpre\u003e\nint function(int flag, int b) {\n  int a;\n  if (flag) {\n    a \u003d b;\n  } else {\n    return 10;\n  }\n  return a; // Compliant\n}\n\u003c/pre\u003e\n\u003cp\u003eProviding a valid initial value:\u003c/p\u003e\n\u003cpre\u003e\nint function(int flag, int b) {\n  int a \u003d 10;\n  if (flag) {\n    a \u003d b;\n  }\n  return a; // Compliant\n}\n\u003c/pre\u003e\n\u003cp\u003eInitializing value in the definition:\u003c/p\u003e\n\u003cpre\u003e\nint function(int flag, int b) {\n  int const a \u003d flag ? b : 10;\n  return a; // Compliant\n}\n\u003c/pre\u003e\n\u003ch3\u003ePitfalls\u003c/h3\u003e\n\u003cp\u003eInitializing the variable to zero at the declaration is not always the right solution to fix the issue, as it may lead to logic errors if such a\nvalue is not handled correctly. For example, setting an \u003ccode\u003eage\u003c/code\u003e field of an \u003ccode\u003eEmployee\u003c/code\u003e structure may break assumptions of\nretirement handling code. Or more commonly, setting a pointer to \u003ccode\u003eNULL\u003c/code\u003e will turn dereference of an uninitialized value into a null-pointer\ndereference.\u003c/p\u003e\n\u003ch3\u003eGoing the extra mile\u003c/h3\u003e\n\u003cp\u003eWith the addition of lambdas in C++11, it is possible to initialize variables on declaration without creating a separate function to compute the\nvalue:\u003c/p\u003e\n\u003cpre\u003e\nint x \u003d [\u0026amp;] { // capture all context by reference\n  if (someCondition())\n    return computeVar1();\n  /* perform more computations */\n  return other;\n}(); // invoke the lambda immediately (right after creation)\n\u003c/pre\u003e\n\u003cp\u003eSuch pattern is referred to as an \u003cem\u003eImmediately invoked function expression\u003c/em\u003e (IIFE) or \u003cem\u003eImediately invoked lambda\u003c/em\u003e. Furthermore, with\nthe addition of structured binding in C++17, it is possible to declare multiple variables whose values are coupled:\u003c/p\u003e\n\u003cpre\u003e\nauto [px, py, pz] \u003d [\u0026amp;] {\n  if (x_dir) {\n    return std::make_tuple(1, 0, 0);\n  } else if (y_dir) {\n    return std::make_tuple(0, 1, 0);\n  } else {\n    assert(z_dir);\n    return std::make_tuple(0, 0, 1);\n  }\n}();\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/storage_duration\"\u003eStorage class specifiers\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/457\"\u003e457 Use of Uninitialized Variable\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e MISRA C:2004, 9.1 - All automatic variables shall have been assigned a value before being used. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 8-5-1 - All variables shall have a defined value before they are used. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S2107} detects fields being left uninitialized after the invocation of a constructor \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eVariables should be initialized before their use to avoid unexpected behavior due to garbage values.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eA local variable of any built-in type (such as \u003ccode\u003eint\u003c/code\u003e, \u003ccode\u003efloat\u003c/code\u003e, and pointers), declared without an initial value is not\ninitialized to any particular value. Consequently, if no value is assigned to such a variable first, the code that uses it has no defined\nbehavior.\u003c/p\u003e\n\u003cpre\u003e\nint addition() {\n  int x;  // x is not initialized\n  return x + 10; // Noncompliant: x has grabage value\n}\n\nint dereference() {\n  int* p; // p is not initialized\n  return *p; // Noncompliant: p has garbage value\n}\n\u003c/pre\u003e\n\u003cp\u003eSimilarly, structures that simply aggregate variables of built-in types, such as arrays or \u003ccode\u003estruct\u003c/code\u003e/\u003ccode\u003eclass\u003c/code\u003e types without a\nconstructor, will not initialize their members when declared without an initializer:\u003c/p\u003e\n\u003cpre\u003e\nstruct Aggregate {\n  int i;\n  float f;\n};\n\nvoid aggregates() {\n  int* intArray[5]; // each element of array is not initializer\n  Aggregate aggr; // members aggr.i, agrr.f are not initialized\n  Aggregate aggrArray[2]; // members of each element are not initialized\n}\n\u003c/pre\u003e\n\u003cp\u003eFinally, allocating objects of builtin or such aggregates types on the heap, also does not initialize their values:\u003c/p\u003e\n\u003cpre\u003e\nvoid usingMalloc() {\n  int* intArr \u003d (int*)malloc(sizeof(int) * 10); // each of 10 allocated integers is not initialized\n}\n\u003c/pre\u003e\n\u003cp\u003eThis also applies when \u003ccode\u003enew\u003c/code\u003e is used in C++:\u003c/p\u003e\n\u003cpre\u003e\nvoid usingNew() {\n  Aggregate* aggrPtr \u003d new Aggregate; // members of allocated Aggregate are not initialized\n  Aggregate* aggrArr \u003d new Aggregate[5]; // members of each of 5 Aggregate objects are not initialized\n}\n\u003c/pre\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eUsing garbage values will cause the program to behave nondeterministically at runtime. The program may produce a different output or crash\ndepending on the run.\u003c/p\u003e\n\u003cp\u003eIn some situations, loading a variable may expose a sensitive data, such as a password that was previously stored in the same location, leading to\na vulnerability that uses such a defect as a gadget for extracting information from the instance of the program.\u003c/p\u003e\n\u003cp\u003eFinally, in C++, outside of a few exceptions related to the uses of \u003ccode\u003eunsigned char\u003c/code\u003e or \u003ccode\u003estd::byte\u003c/code\u003e, loading data from an\nuninitialized variable causes undefined behavior. This means that the compiler is not bound by the language standard anymore, and the program has no\nmeaning assigned to it. As a consequence, the impact of such a defect is not limited to the use of garbage values.\u003c/p\u003e\n\u003ch3\u003eWhy is there an issue for a class with a default constructor?\u003c/h3\u003e\n\u003cp\u003eIn C++, a class can define a default constructor invoked when an object of the given type is created. Such a constructor is called even if a\nvariable is declared without any initializer. However, if the constructor code omits the initialization of a member that itself does not have the\ndefault constructor, the member will remain uninitialized (See also {rule:cpp:S2107}). And reading from it will produce a garbage value:\u003c/p\u003e\n\u003cpre\u003e\nstruct Partial {\n  // x is not initialized\n  Partial() : y(10.0) {}\n\n  int x;\n  float y;\n};\n\nint initialized() {\n  Partial p; // constructor is called\n  // or even Partial p{};\n  return p.x; // Non-compliant: reading an uninitialized variable\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThis rule does not flag the variables with static storage duration, meaning: global, static, and thread-local variables.\u003c/p\u003e\n\u003cp\u003eAll the variables with static storage duration are zero-initialized before the initializer is evaluated. As a consequence, any variable or member\nof such an object has a defined value even if no initializer is specified.\u003c/p\u003e\n\u003cpre\u003e\nint globInt;\nint globTab[10];\nAggregate globAggr;\nPartial globPart; // x member is zero-initialized\n\nint uses() {\n  static int staticInt;\n  return globInt     // Compliant: all zero-initialized\n       + globTab[2]\n       + globAggr.f\n       + globPart.x\n       + staticInt;\n}\n\u003c/pre\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eCommonly, the use of an uninitialized object is an indication of a defect in the code, where either variable initialization was skipped on some\ncode paths, or the object is used by mistake. Generally, you can address such problems by:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Initializing variables on the declaration with a valid value \u003c/li\u003e\n  \u003cli\u003e Assigning to the variable on the code path(s) that was missing initialization \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWhenever possible, it is preferable to initialize a variable with its final value on the declaration, as this eliminates the possibility of this\ndefect occurring.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nint function(int flag, int b) {\n  int a;\n  if (flag) {\n    a \u003d b;\n  }\n  return a; // Noncompliant: \"a\" has not been initialized in all paths\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eInitializing variable on all code paths:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nint function(int flag, int b) {\n  int a;\n  if (flag) {\n    a \u003d b;\n  } else {\n    a \u003d 10;\n  }\n  return a; // Compliant\n}\n\u003c/pre\u003e\n\u003cp\u003eSkipping path that leads to the read of an uninitialized value:\u003c/p\u003e\n\u003cpre\u003e\nint function(int flag, int b) {\n  int a;\n  if (flag) {\n    a \u003d b;\n  } else {\n    return 10;\n  }\n  return a; // Compliant\n}\n\u003c/pre\u003e\n\u003cp\u003eProviding a valid initial value:\u003c/p\u003e\n\u003cpre\u003e\nint function(int flag, int b) {\n  int a \u003d 10;\n  if (flag) {\n    a \u003d b;\n  }\n  return a; // Compliant\n}\n\u003c/pre\u003e\n\u003cp\u003eInitializing value in the definition:\u003c/p\u003e\n\u003cpre\u003e\nint function(int flag, int b) {\n  int const a \u003d flag ? b : 10;\n  return a; // Compliant\n}\n\u003c/pre\u003e\n\u003ch3\u003ePitfalls\u003c/h3\u003e\n\u003cp\u003eInitializing the variable to zero at the declaration is not always the right solution to fix the issue, as it may lead to logic errors if such a\nvalue is not handled correctly. For example, setting an \u003ccode\u003eage\u003c/code\u003e field of an \u003ccode\u003eEmployee\u003c/code\u003e structure may break assumptions of\nretirement handling code. Or more commonly, setting a pointer to \u003ccode\u003eNULL\u003c/code\u003e will turn dereference of an uninitialized value into a null-pointer\ndereference.\u003c/p\u003e\n\u003ch3\u003eGoing the extra mile\u003c/h3\u003e\n\u003cp\u003eWith the addition of lambdas in C++11, it is possible to initialize variables on declaration without creating a separate function to compute the\nvalue:\u003c/p\u003e\n\u003cpre\u003e\nint x \u003d [\u0026amp;] { // capture all context by reference\n  if (someCondition())\n    return computeVar1();\n  /* perform more computations */\n  return other;\n}(); // invoke the lambda immediately (right after creation)\n\u003c/pre\u003e\n\u003cp\u003eSuch pattern is referred to as an \u003cem\u003eImmediately invoked function expression\u003c/em\u003e (IIFE) or \u003cem\u003eImediately invoked lambda\u003c/em\u003e. Furthermore, with\nthe addition of structured binding in C++17, it is possible to declare multiple variables whose values are coupled:\u003c/p\u003e\n\u003cpre\u003e\nauto [px, py, pz] \u003d [\u0026amp;] {\n  if (x_dir) {\n    return std::make_tuple(1, 0, 0);\n  } else if (y_dir) {\n    return std::make_tuple(0, 1, 0);\n  } else {\n    assert(z_dir);\n    return std::make_tuple(0, 0, 1);\n  }\n}();\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/storage_duration\"\u003eStorage class specifiers\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/457\"\u003e457 Use of Uninitialized Variable\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e MISRA C:2004, 9.1 - All automatic variables shall have been assigned a value before being used. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 8-5-1 - All variables shall have a defined value before they are used. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S2107} detects fields being left uninitialized after the invocation of a constructor \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "cwe",
      "symbolic-execution"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S958",
    "name": "Macros should not be #define\u0027d or #undef\u0027d within a block",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhile it is legal to place \u003ccode\u003e#define\u003c/code\u003e and \u003ccode\u003e#undef\u003c/code\u003e directives anywhere in a source file, placing them outside of the global\nnamespace is misleading since their scope is not actually restricted. This may be inconsistent with developer expectations.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nnamespace NS\n{\n  #ifndef MY_HDR\n  #define MY_HDR    /* Noncompliant */\n  #undef FOO        /* Noncompliant */\n  #endif\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#ifndef MY_HDR\n#define MY_HDR\n#undef FOO\n#endif\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 19.5 - Macros shall not be #define’d or #undef’d within a block. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 16-0-2 - Macros shall only be #define’d or #undef’d in the global namespace. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhile it is legal to place \u003ccode\u003e#define\u003c/code\u003e and \u003ccode\u003e#undef\u003c/code\u003e directives anywhere in a source file, placing them outside of the global\nnamespace is misleading since their scope is not actually restricted. This may be inconsistent with developer expectations.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nnamespace NS\n{\n  #ifndef MY_HDR\n  #define MY_HDR    /* Noncompliant */\n  #undef FOO        /* Noncompliant */\n  #endif\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#ifndef MY_HDR\n#define MY_HDR\n#undef FOO\n#endif\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 19.5 - Macros shall not be #define’d or #undef’d within a block. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 16-0-2 - Macros shall only be #define’d or #undef’d in the global namespace. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "pitfall"
    ],
    "deprecatedKeys": [
      "cpp:PPDefineOrUndefFromBlock"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5309",
    "name": "Every switch statement shall have at least one case-clause",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThis rule is a strict implementation of a MISRA (Motor Industry Software Reliability Association) rule. MISRA defines best practices for developing\nsafety-critical software. You can learn more about this rule in the MISRA documents referenced below.\u003c/p\u003e\n\u003cp\u003eIf you are not concerned with MISRA compliance or with safety-critical software, you might consider using rule {rule:cpp:S1301} instead ; it\ntargets the same kind of issue for general-purpose software.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C 2004, 15.5 - Every switch statement shall have at least one case clause. \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2008, 6-4-8 - Every switch statement shall have at least one case-clause. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThis rule is a strict implementation of a MISRA (Motor Industry Software Reliability Association) rule. MISRA defines best practices for developing\nsafety-critical software. You can learn more about this rule in the MISRA documents referenced below.\u003c/p\u003e\n\u003cp\u003eIf you are not concerned with MISRA compliance or with safety-critical software, you might consider using rule {rule:cpp:S1301} instead ; it\ntargets the same kind of issue for general-purpose software.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C 2004, 15.5 - Every switch statement shall have at least one case clause. \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2008, 6-4-8 - Every switch statement shall have at least one case-clause. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "misra-c++2008"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5307",
    "name": "All \"if ... else if\" constructs shall be terminated with an \"else \"clause",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThis rule is a strict implementation of a MISRA (Motor Industry Software Reliability Association) rule. MISRA defines best practices for developing\nsafety-critical software. You can learn more about this rule in the MISRA documents referenced below.\u003c/p\u003e\n\u003cp\u003eIf you are not concerned with MISRA compliance or with safety-critical software, you might consider using rule ElseIfWithoutElse instead ; it\ntargets the same kind of issue for general-purpose software.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++2008, 6-4-2 \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThis rule is a strict implementation of a MISRA (Motor Industry Software Reliability Association) rule. MISRA defines best practices for developing\nsafety-critical software. You can learn more about this rule in the MISRA documents referenced below.\u003c/p\u003e\n\u003cp\u003eIf you are not concerned with MISRA compliance or with safety-critical software, you might consider using rule ElseIfWithoutElse instead ; it\ntargets the same kind of issue for general-purpose software.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C++2008, 6-4-2 \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "misra-c++2008"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5308",
    "name": "Return value of \"setuid\" family of functions should always be checked",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003cp\u003eUnchecked return value of a function from the \u003ccode\u003esetuid\u003c/code\u003e-family might cause unexpected behavior and poses a security risk.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eFunctions from the \u003ccode\u003esetuid\u003c/code\u003e-family including \u003ccode\u003esetuid\u003c/code\u003e and \u003ccode\u003esetgid\u003c/code\u003e are used to change the identity of the caller\nprocess. They are used to change privileges for the subsequent actions to be executed. If a call to these functions returns an error that is not\nchecked and handled appropriately, the subsequent parts of the program will execute with unexpected privileges. This, in turn, leads to unexpected\nprogram behavior and poses a \u003cem\u003eserious\u003c/em\u003e security risk.\u003c/p\u003e\n\u003ch2\u003eWhat is the potential impact?\u003c/h2\u003e\n\u003cp\u003eFunctions for managing a program’s privileges are fairly complex and one needs to take great care to use them correctly.\u003c/p\u003e\n\u003cp\u003eFailing to correctly handle potential errors indicated by those functions\u0027 respective return values can lead to unexpected behavior. If the program\nfails to acquire more privileges to execute a privileged operation, for instance, the OS will disallow the operation and the program is likely\nterminated by the OS. However, if the program silently fails to drop its privileges, it will continue to run the subsequent operations with more\nprivileges than expected, which poses a \u003cem\u003eserious\u003c/em\u003e security risk.\u003c/p\u003e\n\u003ch2\u003eExample program that changes between privileged and unprivileged mode\u003c/h2\u003e\n\u003cp\u003eA brief example on how \u003ccode\u003esetuid\u003c/code\u003e can be used and how to correctly check its return value is given in what follows.\u003c/p\u003e\n\u003cp\u003eConsider the following example:\u003c/p\u003e\n\u003cp\u003eAssume that the program shown below has been compiled to its binary named \u003ccode\u003emy-program\u003c/code\u003e. One can change its owner to root, for\ninstance.\u003c/p\u003e\n\u003cpre\u003e\n$ sudo chown root:root my-program\n\u003c/pre\u003e\n\u003cp\u003eAfter setting the program’s setuid bit using\u003c/p\u003e\n\u003cpre\u003e\n$ sudo chmod u+s my-program\n\u003c/pre\u003e\n\u003cp\u003ethe program’s permissions may look like\u003c/p\u003e\n\u003cpre\u003e\n-rwsrwxr-x 1 root root 16416 Aug 21 15:45 my-program\n\u003c/pre\u003e\n\u003cp\u003eThe \u0027s\u0027 indicates that the executable has the setuid bit set. Notice that the program’s owner (here root) may be different from its caller.\nFunctions from the \u003ccode\u003esetuid\u003c/code\u003e-family can be used to manipulate privileges and acquire (or drop) the program owner’s privileges.\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n#include \u0026lt;sys/types.h\u0026gt;\n#include \u0026lt;unistd.h\u0026gt;\n\nstatic uid_t real_uid;\nstatic uid_t effective_uid;\n\nvoid do_setuid(void) {\n  printf(\"Try to acquire privileges\\n\");\n  int status;\n  status \u003d seteuid(effective_uid);\n  if (status \u0026lt; 0) { // Compliant: return code is checked and potential errors are handled.\n    fprintf(stderr, \"Couldn\u0027t set uid.\\n\");\n    exit(status);\n  }\n  printf(\"Set uid to %lu\\n\", (unsigned long int)effective_uid);\n}\n\nvoid undo_setuid(void) {\n  printf(\"Try to drop privileges\\n\");\n  int status;\n  status \u003d seteuid(real_uid);\n  if (status \u0026lt; 0) { // Compliant: return code is checked and potential errors are handled.\n    fprintf(stderr, \"Couldn\u0027t set uid.\\n\");\n    exit(status);\n  }\n  printf(\"Set uid to %lu\\n\", (unsigned long int)real_uid);\n}\n\nint main(void) {\n  real_uid \u003d getuid();       // Real ID of the program\u0027s caller.\n  effective_uid \u003d geteuid(); // Effective ID of the program\u0027s owner (here root).\n  // Immediately drop privileges and set effective user ID back to real user ID\n  // such that operations are performed using the real user ID for determining\n  // permissions.\n  undo_setuid();\n  // Switch back to file user ID (the owner\u0027s privileges) only if the effective\n  // ID (the privileges) is required to determine permission for privileged\n  // operations.\n  do_setuid();\n  //\n  // PERFORM PRIVILEGED OPERATION (using root privileges in this example).\n  //\n  // Drop privileges as soon as they are no longer needed.\n  undo_setuid();\n\n  // There are a multitude of operations that can be extremely dangerous if\n  // executed as root. Assume that this program would not correctly handle\n  // potential errors. In that case, the following system call poses a security\n  // risk, if dropping privileges fails. The following command recursively removes\n  // all files and directories inside the /tmp directory. If executed with root\n  // permissions, it can potentially delete important files and directories, causing\n  // system instability or data loss.\n  system(\"rm -rf /tmp/*\"); // Caution: poses a security risk if accidentally executed as root.\n}\n\u003c/pre\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eAlways check the return values of the \u003ccode\u003esetuid\u003c/code\u003e-family functions and handle any potential error appropriately.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n#include \u0026lt;sys/types.h\u0026gt;\n#include \u0026lt;unistd.h\u0026gt;\n\nstatic uid_t real_uid;\nstatic uid_t effective_uid;\n\nvoid undo_setuid(void) {\n  printf(\"Try to drop privileges\\n\");\n  // Potential failures of `seteuid` are neither checked nor handled appropriately.\n  // This function may hence silently fail to drop privileges and continues execution\n  // in a privileged mode. This poses a serious security risk!\n  seteuid(real_uid); // Noncompliant: return value is not checked.\n  printf(\"Set uid to %lu\\n\", (unsigned long int)real_uid);\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n#include \u0026lt;sys/types.h\u0026gt;\n#include \u0026lt;unistd.h\u0026gt;\n\nstatic uid_t real_uid;\nstatic uid_t effective_uid;\n\nvoid undo_setuid(void) {\n  printf(\"Try to drop privileges\\n\");\n  int status;\n  status \u003d seteuid(real_uid);\n  if (status \u0026lt; 0) { // Compliant: return code is checked and potential errors are handled.\n    fprintf(stderr, \"Couldn\u0027t set uid.\\n\");\n    exit(status);\n  }\n  printf(\"Set uid to %lu\\n\", (unsigned long int)real_uid);\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eArticles \u0026amp; blog posts\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://www.usenix.org/legacy/events/sec02/full_papers/chen/chen.pdf\"\u003eSetuid demystified\u003c/a\u003e Chen, Hao, David Wagner, and Drew Dean.\n  11th USENIX Security Symposium (USENIX Security 02). 2002. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca\n  href\u003d\"https://wiki.sei.cmu.edu/confluence/display/c/POS36-C.+Observe+correct+revocation+order+while+relinquishing+privileges\"\u003ePOS36-C. Ensure that\n  privilege relinquishment is successful\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/display/c/POS37-C.+Ensure+that+privilege+relinquishment+is+successful\"\u003ePOS37-C. Observe\n  correct revocation order while relinquishing privileges\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/252.html\"\u003e252 Unchecked Return Value\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/272.html\"\u003e272 Least Privilege Violation\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eUnchecked return value of a function from the \u003ccode\u003esetuid\u003c/code\u003e-family might cause unexpected behavior and poses a security risk.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eFunctions from the \u003ccode\u003esetuid\u003c/code\u003e-family including \u003ccode\u003esetuid\u003c/code\u003e and \u003ccode\u003esetgid\u003c/code\u003e are used to change the identity of the caller\nprocess. They are used to change privileges for the subsequent actions to be executed. If a call to these functions returns an error that is not\nchecked and handled appropriately, the subsequent parts of the program will execute with unexpected privileges. This, in turn, leads to unexpected\nprogram behavior and poses a \u003cem\u003eserious\u003c/em\u003e security risk.\u003c/p\u003e\n\u003ch2\u003eWhat is the potential impact?\u003c/h2\u003e\n\u003cp\u003eFunctions for managing a program’s privileges are fairly complex and one needs to take great care to use them correctly.\u003c/p\u003e\n\u003cp\u003eFailing to correctly handle potential errors indicated by those functions\u0027 respective return values can lead to unexpected behavior. If the program\nfails to acquire more privileges to execute a privileged operation, for instance, the OS will disallow the operation and the program is likely\nterminated by the OS. However, if the program silently fails to drop its privileges, it will continue to run the subsequent operations with more\nprivileges than expected, which poses a \u003cem\u003eserious\u003c/em\u003e security risk.\u003c/p\u003e\n\u003ch2\u003eExample program that changes between privileged and unprivileged mode\u003c/h2\u003e\n\u003cp\u003eA brief example on how \u003ccode\u003esetuid\u003c/code\u003e can be used and how to correctly check its return value is given in what follows.\u003c/p\u003e\n\u003cp\u003eConsider the following example:\u003c/p\u003e\n\u003cp\u003eAssume that the program shown below has been compiled to its binary named \u003ccode\u003emy-program\u003c/code\u003e. One can change its owner to root, for\ninstance.\u003c/p\u003e\n\u003cpre\u003e\n$ sudo chown root:root my-program\n\u003c/pre\u003e\n\u003cp\u003eAfter setting the program’s setuid bit using\u003c/p\u003e\n\u003cpre\u003e\n$ sudo chmod u+s my-program\n\u003c/pre\u003e\n\u003cp\u003ethe program’s permissions may look like\u003c/p\u003e\n\u003cpre\u003e\n-rwsrwxr-x 1 root root 16416 Aug 21 15:45 my-program\n\u003c/pre\u003e\n\u003cp\u003eThe \u0027s\u0027 indicates that the executable has the setuid bit set. Notice that the program’s owner (here root) may be different from its caller.\nFunctions from the \u003ccode\u003esetuid\u003c/code\u003e-family can be used to manipulate privileges and acquire (or drop) the program owner’s privileges.\u003c/p\u003e\n\u003cpre\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n#include \u0026lt;sys/types.h\u0026gt;\n#include \u0026lt;unistd.h\u0026gt;\n\nstatic uid_t real_uid;\nstatic uid_t effective_uid;\n\nvoid do_setuid(void) {\n  printf(\"Try to acquire privileges\\n\");\n  int status;\n  status \u003d seteuid(effective_uid);\n  if (status \u0026lt; 0) { // Compliant: return code is checked and potential errors are handled.\n    fprintf(stderr, \"Couldn\u0027t set uid.\\n\");\n    exit(status);\n  }\n  printf(\"Set uid to %lu\\n\", (unsigned long int)effective_uid);\n}\n\nvoid undo_setuid(void) {\n  printf(\"Try to drop privileges\\n\");\n  int status;\n  status \u003d seteuid(real_uid);\n  if (status \u0026lt; 0) { // Compliant: return code is checked and potential errors are handled.\n    fprintf(stderr, \"Couldn\u0027t set uid.\\n\");\n    exit(status);\n  }\n  printf(\"Set uid to %lu\\n\", (unsigned long int)real_uid);\n}\n\nint main(void) {\n  real_uid \u003d getuid();       // Real ID of the program\u0027s caller.\n  effective_uid \u003d geteuid(); // Effective ID of the program\u0027s owner (here root).\n  // Immediately drop privileges and set effective user ID back to real user ID\n  // such that operations are performed using the real user ID for determining\n  // permissions.\n  undo_setuid();\n  // Switch back to file user ID (the owner\u0027s privileges) only if the effective\n  // ID (the privileges) is required to determine permission for privileged\n  // operations.\n  do_setuid();\n  //\n  // PERFORM PRIVILEGED OPERATION (using root privileges in this example).\n  //\n  // Drop privileges as soon as they are no longer needed.\n  undo_setuid();\n\n  // There are a multitude of operations that can be extremely dangerous if\n  // executed as root. Assume that this program would not correctly handle\n  // potential errors. In that case, the following system call poses a security\n  // risk, if dropping privileges fails. The following command recursively removes\n  // all files and directories inside the /tmp directory. If executed with root\n  // permissions, it can potentially delete important files and directories, causing\n  // system instability or data loss.\n  system(\"rm -rf /tmp/*\"); // Caution: poses a security risk if accidentally executed as root.\n}\n\u003c/pre\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eAlways check the return values of the \u003ccode\u003esetuid\u003c/code\u003e-family functions and handle any potential error appropriately.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n#include \u0026lt;sys/types.h\u0026gt;\n#include \u0026lt;unistd.h\u0026gt;\n\nstatic uid_t real_uid;\nstatic uid_t effective_uid;\n\nvoid undo_setuid(void) {\n  printf(\"Try to drop privileges\\n\");\n  // Potential failures of `seteuid` are neither checked nor handled appropriately.\n  // This function may hence silently fail to drop privileges and continues execution\n  // in a privileged mode. This poses a serious security risk!\n  seteuid(real_uid); // Noncompliant: return value is not checked.\n  printf(\"Set uid to %lu\\n\", (unsigned long int)real_uid);\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n#include \u0026lt;sys/types.h\u0026gt;\n#include \u0026lt;unistd.h\u0026gt;\n\nstatic uid_t real_uid;\nstatic uid_t effective_uid;\n\nvoid undo_setuid(void) {\n  printf(\"Try to drop privileges\\n\");\n  int status;\n  status \u003d seteuid(real_uid);\n  if (status \u0026lt; 0) { // Compliant: return code is checked and potential errors are handled.\n    fprintf(stderr, \"Couldn\u0027t set uid.\\n\");\n    exit(status);\n  }\n  printf(\"Set uid to %lu\\n\", (unsigned long int)real_uid);\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eArticles \u0026amp; blog posts\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://www.usenix.org/legacy/events/sec02/full_papers/chen/chen.pdf\"\u003eSetuid demystified\u003c/a\u003e Chen, Hao, David Wagner, and Drew Dean.\n  11th USENIX Security Symposium (USENIX Security 02). 2002. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca\n  href\u003d\"https://wiki.sei.cmu.edu/confluence/display/c/POS36-C.+Observe+correct+revocation+order+while+relinquishing+privileges\"\u003ePOS36-C. Ensure that\n  privilege relinquishment is successful\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/display/c/POS37-C.+Ensure+that+privilege+relinquishment+is+successful\"\u003ePOS37-C. Observe\n  correct revocation order while relinquishing privileges\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/252.html\"\u003e252 Unchecked Return Value\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/272.html\"\u003e272 Least Privilege Violation\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "symbolic-execution"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:M23_094",
    "name": "A cast should not convert a pointer type to an integral type",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 8.2.7\u003c/p\u003e\n\u003cp\u003eCategory: Advisory\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eCasting between a pointer and an integer type makes it harder for tools and developers to understand and reason about code behaviour. For example,\npointer tracking within tools may become unreliable when pointers are cast to integers.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e casting between pointers and integers may be unavoidable when addressing memory mapped registers or other hardware specific\nfeatures. When the advice given in this rule is not followed, the use of \u003ccode\u003estd::uintptr_t\u003c/code\u003e or \u003ccode\u003estd::intptr_t\u003c/code\u003e is required by\nMISRA C++ 2023 Rule\u0026nbsp;8.2.8 (An \u003cem\u003eobject pointer type\u003c/em\u003e shall not be cast to an integral type other than \u003ccode\u003estd::uintptr_t\u003c/code\u003e or\n\u003ccode\u003estd::intptr_t\u003c/code\u003e) as these types are guaranteed to be able to represent all possible pointer values.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cp\u003eThe following examples violate MISRA C++ 2023 Rule\u0026nbsp;8.2.8 (An \u003cem\u003eobject pointer type\u003c/em\u003e shall not be cast to an integral type other than\n\u003ccode\u003estd::uintptr_t\u003c/code\u003e or \u003ccode\u003estd::intptr_t\u003c/code\u003e):\u003c/p\u003e\n\u003cpre\u003e\nstruct S;\n\nvoid f( S * s )\n{\n  std::intptr_t p \u003d reinterpret_cast\u0026lt; std::intptr_t \u0026gt;( s );   // Non-compliant\n  std::uint8_t  q \u003d reinterpret_cast\u0026lt; std::uint8_t  \u0026gt;( s );   // Non-compliant\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S5358} targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2023 Rule\u0026nbsp;8.2.5 - \u003ccode\u003ereinterpret_cast\u003c/code\u003e shall not be used \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2023 Rule\u0026nbsp;8.2.8 - An \u003cem\u003eobject pointer type\u003c/em\u003e shall not be cast to an integral type other than \u003ccode\u003estd::uintptr_t\u003c/code\u003e\n  or \u003ccode\u003estd::intptr_t\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 8.2.7\u003c/p\u003e\n\u003cp\u003eCategory: Advisory\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eCasting between a pointer and an integer type makes it harder for tools and developers to understand and reason about code behaviour. For example,\npointer tracking within tools may become unreliable when pointers are cast to integers.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e casting between pointers and integers may be unavoidable when addressing memory mapped registers or other hardware specific\nfeatures. When the advice given in this rule is not followed, the use of \u003ccode\u003estd::uintptr_t\u003c/code\u003e or \u003ccode\u003estd::intptr_t\u003c/code\u003e is required by\nMISRA C++ 2023 Rule\u0026nbsp;8.2.8 (An \u003cem\u003eobject pointer type\u003c/em\u003e shall not be cast to an integral type other than \u003ccode\u003estd::uintptr_t\u003c/code\u003e or\n\u003ccode\u003estd::intptr_t\u003c/code\u003e) as these types are guaranteed to be able to represent all possible pointer values.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cp\u003eThe following examples violate MISRA C++ 2023 Rule\u0026nbsp;8.2.8 (An \u003cem\u003eobject pointer type\u003c/em\u003e shall not be cast to an integral type other than\n\u003ccode\u003estd::uintptr_t\u003c/code\u003e or \u003ccode\u003estd::intptr_t\u003c/code\u003e):\u003c/p\u003e\n\u003cpre\u003e\nstruct S;\n\nvoid f( S * s )\n{\n  std::intptr_t p \u003d reinterpret_cast\u0026lt; std::intptr_t \u0026gt;( s );   // Non-compliant\n  std::uint8_t  q \u003d reinterpret_cast\u0026lt; std::uint8_t  \u0026gt;( s );   // Non-compliant\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S5358} targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2023 Rule\u0026nbsp;8.2.5 - \u003ccode\u003ereinterpret_cast\u003c/code\u003e shall not be used \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2023 Rule\u0026nbsp;8.2.8 - An \u003cem\u003eobject pointer type\u003c/em\u003e shall not be cast to an integral type other than \u003ccode\u003estd::uintptr_t\u003c/code\u003e\n  or \u003ccode\u003estd::intptr_t\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "misra-advisory",
      "misra-c++2023"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1185",
    "name": "Overriding member functions should do more than simply call the same member in the base class",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eOverriding a function just to call the overridden function from the base class without performing any other actions can be useless and\nmisleading.\u003c/p\u003e\n\u003cp\u003eThere are cases when it is justified because redeclaring the function allows some side effects:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Changing the visibility of the function in the derived class \u003c/li\u003e\n  \u003cli\u003e Preventing the base class function from being hidden by an overload added in the derived class (a using-declaration could have the same effect)\n  \u003c/li\u003e\n  \u003cli\u003e To resolve ambiguities in cases of multiple inheritance \u003c/li\u003e\n  \u003cli\u003e To make an inherited function final \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis rule raises an issue when an override not in one of the abovementioned situations only calls the overridden function, directly forwarding its\narguments.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nclass Base {\npublic:\n  virtual void f();\n};\n\nclass Derived : public Base {\npublic:\n  virtual void f() {\n    Base::f(); // Noncompliant\n  }\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nclass Base {\npublic:\n  virtual void f();\n};\n\nclass Derived : public Base {\n};\n\u003c/pre\u003e\n\u003cp\u003eor\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nclass Base {\npublic:\n  void f();\n};\n\nclass Derived : public Base {\nprivate: // Compliant: change of visibility\n  virtual void f() {\n    Base::f();\n  }\n};\n\u003c/pre\u003e\n\u003cp\u003eor\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nclass Base {\npublic:\n  void f();\n};\n\nclass Derived : public Base {\npublic:\n  void f(int i);\n  void f() { // Compliant: prevents hiding by f(int)\n    Base::f();\n  }\n};\n\u003c/pre\u003e\n\u003cp\u003eor\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nclass Base {\npublic:\n  virtual void f();\n};\n\nclass Derived : public Base {\npublic:\n  void f() final { // Compliant: cannot be overridden by derived classes\n    Base::f();\n  }\n};\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eOverriding a function just to call the overridden function from the base class without performing any other actions can be useless and\nmisleading.\u003c/p\u003e\n\u003cp\u003eThere are cases when it is justified because redeclaring the function allows some side effects:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Changing the visibility of the function in the derived class \u003c/li\u003e\n  \u003cli\u003e Preventing the base class function from being hidden by an overload added in the derived class (a using-declaration could have the same effect)\n  \u003c/li\u003e\n  \u003cli\u003e To resolve ambiguities in cases of multiple inheritance \u003c/li\u003e\n  \u003cli\u003e To make an inherited function final \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis rule raises an issue when an override not in one of the abovementioned situations only calls the overridden function, directly forwarding its\narguments.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nclass Base {\npublic:\n  virtual void f();\n};\n\nclass Derived : public Base {\npublic:\n  virtual void f() {\n    Base::f(); // Noncompliant\n  }\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nclass Base {\npublic:\n  virtual void f();\n};\n\nclass Derived : public Base {\n};\n\u003c/pre\u003e\n\u003cp\u003eor\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nclass Base {\npublic:\n  void f();\n};\n\nclass Derived : public Base {\nprivate: // Compliant: change of visibility\n  virtual void f() {\n    Base::f();\n  }\n};\n\u003c/pre\u003e\n\u003cp\u003eor\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nclass Base {\npublic:\n  void f();\n};\n\nclass Derived : public Base {\npublic:\n  void f(int i);\n  void f() { // Compliant: prevents hiding by f(int)\n    Base::f();\n  }\n};\n\u003c/pre\u003e\n\u003cp\u003eor\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nclass Base {\npublic:\n  virtual void f();\n};\n\nclass Derived : public Base {\npublic:\n  void f() final { // Compliant: cannot be overridden by derived classes\n    Base::f();\n  }\n};\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "clumsy",
      "redundant"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S2275",
    "name": "Printf-style format strings should not lead to unexpected behavior at runtime",
    "defaultSeverity": "BLOCKER",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eBecause \u003ccode\u003eprintf\u003c/code\u003e format strings are interpreted at runtime, rather than validated by the compiler, they can contain errors that lead to\nunexpected behavior or runtime errors. This rule statically validates the good behavior of \u003ccode\u003eprintf\u003c/code\u003e formats.\u003c/p\u003e\n\u003cp\u003eThe related rule {rule:cpp:S3457} is about errors that produce an unexpected string, while this rule is about errors that will create undefined\nbehavior.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nprintf(\"%d\", 1.2); // Noncompliant, an \"int\" is expected rather than a \"double\"\nprintf(\"%d %d\", 1); // Noncompliant, the second argument is missing\nprintf(\"%0$d \", 1); // Noncompliant, arguments are numbered starting from 1\nprintf(\"%1$d %d\", 1, 2); // Noncompliant, positional and non-positional arguments can not be mixed\nprintf(\"%*d\", 1.1, 2); // Noncompliant, field width should be an integer\nprintf(\"ab\\0cd\"); // Noncompliant, format string contains null char\n\nint x;\nprintf(\"%+p\", (void*)\u0026amp;x); // Noncompliant, flag \"+\" has undefined behavior with conversion specifier \"p\"\nprintf(\"%vd\", x); //Noncompliant, conversion specifier \"v\" is not valid\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nprintf(\"%f\", 1.2); // Compliant, format is consistent with the corresponding argument\nprintf(\"%d\", 1); // Compliant, number of specifiers is consistent with number of arguments\nprintf(\"%1$d \", 1); // Compliant, number of positional argument is consistent\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThis rule will only work if the format string is provided as a string literal.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://www.securecoding.cert.org/confluence/x/wQA1\"\u003eCERT, FIO47-C.\u003c/a\u003e - Use valid format strings \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eBecause \u003ccode\u003eprintf\u003c/code\u003e format strings are interpreted at runtime, rather than validated by the compiler, they can contain errors that lead to\nunexpected behavior or runtime errors. This rule statically validates the good behavior of \u003ccode\u003eprintf\u003c/code\u003e formats.\u003c/p\u003e\n\u003cp\u003eThe related rule {rule:cpp:S3457} is about errors that produce an unexpected string, while this rule is about errors that will create undefined\nbehavior.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nprintf(\"%d\", 1.2); // Noncompliant, an \"int\" is expected rather than a \"double\"\nprintf(\"%d %d\", 1); // Noncompliant, the second argument is missing\nprintf(\"%0$d \", 1); // Noncompliant, arguments are numbered starting from 1\nprintf(\"%1$d %d\", 1, 2); // Noncompliant, positional and non-positional arguments can not be mixed\nprintf(\"%*d\", 1.1, 2); // Noncompliant, field width should be an integer\nprintf(\"ab\\0cd\"); // Noncompliant, format string contains null char\n\nint x;\nprintf(\"%+p\", (void*)\u0026amp;x); // Noncompliant, flag \"+\" has undefined behavior with conversion specifier \"p\"\nprintf(\"%vd\", x); //Noncompliant, conversion specifier \"v\" is not valid\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nprintf(\"%f\", 1.2); // Compliant, format is consistent with the corresponding argument\nprintf(\"%d\", 1); // Compliant, number of specifiers is consistent with number of arguments\nprintf(\"%1$d \", 1); // Compliant, number of positional argument is consistent\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThis rule will only work if the format string is provided as a string literal.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://www.securecoding.cert.org/confluence/x/wQA1\"\u003eCERT, FIO47-C.\u003c/a\u003e - Use valid format strings \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cert"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5422",
    "name": "Functions should not have more than one argument of type \"bool\"",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "FOCUSED",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003ebool\u003c/code\u003e is often used to implement an \u003ccode\u003eenum\u003c/code\u003e with two values. But when used carelessly, this leads to error-prone code. While\nit may seem reasonable when defining a boolean function parameter, the meaning might not be so clear at the function call point.\u003c/p\u003e\n\u003cp\u003eIf the function only has a single boolean argument, the potential ambiguity is mitigated: the function name can indicate its purpose, and what\n\u003ccode\u003etrue\u003c/code\u003e and \u003ccode\u003efalse\u003c/code\u003e mean. But when a function has more than one boolean argument, it becomes increasingly difficult to come up\nwith descriptive names. Moreover, it becomes very easy for callers to inadvertently swap the argument order. In such cases, it is much clearer to use\nan explicit \u003ccode\u003eenum\u003c/code\u003e or, if the boolean has a logical relation to another argument, to package them together in a \u003ccode\u003estruct\u003c/code\u003e, where\nthe data member name can give meaning to the boolean. Another option is to split dealing with the multiple boolean arguments into multiple functions\nbecause sometimes multiple boolean parameters indicate a function that’s trying to do too much.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass Image;\n\nImage* loadImage(const char *path, bool bw, bool lowRes, bool createEmptyIfNotExist); // Noncompliant\nbool saveImage(const Image *image, const char *path, bool color, bool highRes);  // Noncompliant\n\nvoid f(const char* path) {\n  Image *image \u003d loadImage(path, false, true, false);\n  // do some processing on image\n  saveImage(image, path, true, false);\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nclass Image;\nenum class ColorMode {RGB, BlackAndWhite};\nenum class Resolution {Full, Low};\nenum class NotExistFallback {CreateEmpty, ReturnNullPtr};\n\nImage* loadImage(const char *path, ColorMode mode, Resolution res, NotExistFallback fallback);\nbool saveImage(const Image *image, const char *path, ColorMode mode, Resolution res);\n\nvoid f(const char* path) {\n  Image *image \u003d loadImage(path, ColorMode::RGB, Resolution::Low, NotExistFallback::ReturnNullPtr);\n  // do some processing on image\n  saveImage(image, path, ColorMode::RGB, Resolution::Low);\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003ccode\u003ebool\u003c/code\u003e is often used to implement an \u003ccode\u003eenum\u003c/code\u003e with two values. But when used carelessly, this leads to error-prone code. While\nit may seem reasonable when defining a boolean function parameter, the meaning might not be so clear at the function call point.\u003c/p\u003e\n\u003cp\u003eIf the function only has a single boolean argument, the potential ambiguity is mitigated: the function name can indicate its purpose, and what\n\u003ccode\u003etrue\u003c/code\u003e and \u003ccode\u003efalse\u003c/code\u003e mean. But when a function has more than one boolean argument, it becomes increasingly difficult to come up\nwith descriptive names. Moreover, it becomes very easy for callers to inadvertently swap the argument order. In such cases, it is much clearer to use\nan explicit \u003ccode\u003eenum\u003c/code\u003e or, if the boolean has a logical relation to another argument, to package them together in a \u003ccode\u003estruct\u003c/code\u003e, where\nthe data member name can give meaning to the boolean. Another option is to split dealing with the multiple boolean arguments into multiple functions\nbecause sometimes multiple boolean parameters indicate a function that’s trying to do too much.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass Image;\n\nImage* loadImage(const char *path, bool bw, bool lowRes, bool createEmptyIfNotExist); // Noncompliant\nbool saveImage(const Image *image, const char *path, bool color, bool highRes);  // Noncompliant\n\nvoid f(const char* path) {\n  Image *image \u003d loadImage(path, false, true, false);\n  // do some processing on image\n  saveImage(image, path, true, false);\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nclass Image;\nenum class ColorMode {RGB, BlackAndWhite};\nenum class Resolution {Full, Low};\nenum class NotExistFallback {CreateEmpty, ReturnNullPtr};\n\nImage* loadImage(const char *path, ColorMode mode, Resolution res, NotExistFallback fallback);\nbool saveImage(const Image *image, const char *path, ColorMode mode, Resolution res);\n\nvoid f(const char* path) {\n  Image *image \u003d loadImage(path, ColorMode::RGB, Resolution::Low, NotExistFallback::ReturnNullPtr);\n  // do some processing on image\n  saveImage(image, path, ColorMode::RGB, Resolution::Low);\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "bad-practice",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1065",
    "name": "Unused labels should be removed",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eIf a label is declared but not used in the program, it can be considered as dead code and should therefore be removed.\u003c/p\u003e\n\u003cp\u003eThis will improve maintainability as developers will not wonder what this label is used for.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid fun() {\n  label: doSomething();\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid fun() {\n  doSomething();\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2012, 2.6 - A function should not contain unused label declarations \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/5dUxBQ\"\u003eCERT, MSC12-C.\u003c/a\u003e - Detect and remove code that has no effect or is never executed\n  \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eIf a label is declared but not used in the program, it can be considered as dead code and should therefore be removed.\u003c/p\u003e\n\u003cp\u003eThis will improve maintainability as developers will not wonder what this label is used for.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid fun() {\n  label: doSomething();\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid fun() {\n  doSomething();\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2012, 2.6 - A function should not contain unused label declarations \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/5dUxBQ\"\u003eCERT, MSC12-C.\u003c/a\u003e - Detect and remove code that has no effect or is never executed\n  \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "cert",
      "unused"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1186",
    "name": "Methods should not be empty",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eAn empty function is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty functions bring no\nfunctionality and are misleading to others as they might think the function implementation fulfills a specific and identified requirement.\u003c/p\u003e\n\u003cp\u003eThere are several reasons for a function not to have a body:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. \u003c/li\u003e\n  \u003cli\u003e It is not yet, or never will be, supported. In this case an exception should be thrown. \u003c/li\u003e\n  \u003cli\u003e The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThis rule doesn’t raise an issue for empty class constructors or destructors.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid shouldNotBeEmpty() {  // Noncompliant - method is empty\n}\n\nvoid notImplemented() {  // Noncompliant - method is empty\n}\n\nvoid emptyOnPurpose() {  // Noncompliant - method is empty\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid shouldNotBeEmpty() {\n  doSomething();\n}\n\nvoid notImplemented() {\n  throw std::logic_exception(\"notImplemented() cannot be performed because...\");\n}\n\nvoid emptyOnPurpose() {\n  // comment explaining why the method is empty\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eAn empty function is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty functions bring no\nfunctionality and are misleading to others as they might think the function implementation fulfills a specific and identified requirement.\u003c/p\u003e\n\u003cp\u003eThere are several reasons for a function not to have a body:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production. \u003c/li\u003e\n  \u003cli\u003e It is not yet, or never will be, supported. In this case an exception should be thrown. \u003c/li\u003e\n  \u003cli\u003e The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThis rule doesn’t raise an issue for empty class constructors or destructors.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid shouldNotBeEmpty() {  // Noncompliant - method is empty\n}\n\nvoid notImplemented() {  // Noncompliant - method is empty\n}\n\nvoid emptyOnPurpose() {  // Noncompliant - method is empty\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid shouldNotBeEmpty() {\n  doSomething();\n}\n\nvoid notImplemented() {\n  throw std::logic_exception(\"notImplemented() cannot be performed because...\");\n}\n\nvoid emptyOnPurpose() {\n  // comment explaining why the method is empty\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S4334",
    "name": "\"auto\" should not be used to deduce raw pointers",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eUsing \u003ccode\u003eauto\u003c/code\u003e when the type that would be deduced is a pointer type can cause confusion. It is much better to specify the pointer part\noutside of \u003ccode\u003eauto\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nauto item \u003d new Item(); // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nauto* item \u003d new Item();\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eUsing \u003ccode\u003eauto\u003c/code\u003e when the type that would be deduced is a pointer type can cause confusion. It is much better to specify the pointer part\noutside of \u003ccode\u003eauto\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nauto item \u003d new Item(); // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nauto* item \u003d new Item();\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "confusing",
      "since-c++11"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5302",
    "name": "A pointer to a virtual base class shall only be cast to a pointer to a derived class by means of dynamic_cast",
    "defaultSeverity": "BLOCKER",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eCasting from a virtual base to a derived class, using any means other than \u003ccode\u003edynamic_cast\u003c/code\u003e has undefined behavior. The behavior for\n\u003ccode\u003edynamic_cast\u003c/code\u003e is defined.\u003c/p\u003e\n\u003cp\u003eNote: As of C++17, the program is considered ill-formed, and an error is reported.\u003c/p\u003e\n\u003cp\u003eMost compilers emit an error for previous versions of C++ as well.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nclass B { ... };\nclass D: public virtual B { ... };\nD d;\nB *pB \u003d \u0026amp;d;\n\nD *pD1 \u003d ( D * ) pB; // Noncompliant - undefined behavior\nD *pD2 \u003d static_cast\u0026lt;D*\u0026gt;(pB); // Noncompliant - undefined behavior\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nclass B { ... };\nclass D: public virtual B { ... };\nD d;\nB *pB \u003d \u0026amp;d;\n\nD *pD1 \u003d dynamic_cast\u0026lt;D*\u0026gt;(pB); // Compliant, but pD2 may be NULL\nD \u0026amp; D2 \u003d dynamic_cast\u0026lt;D\u0026amp;\u0026gt;(*pB); // Compliant, but may throw an exception\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 5-2-2 - A pointer to a virtual base class shall only be cast to a pointer to a derived class by means of dynamic_cast. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eCasting from a virtual base to a derived class, using any means other than \u003ccode\u003edynamic_cast\u003c/code\u003e has undefined behavior. The behavior for\n\u003ccode\u003edynamic_cast\u003c/code\u003e is defined.\u003c/p\u003e\n\u003cp\u003eNote: As of C++17, the program is considered ill-formed, and an error is reported.\u003c/p\u003e\n\u003cp\u003eMost compilers emit an error for previous versions of C++ as well.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nclass B { ... };\nclass D: public virtual B { ... };\nD d;\nB *pB \u003d \u0026amp;d;\n\nD *pD1 \u003d ( D * ) pB; // Noncompliant - undefined behavior\nD *pD2 \u003d static_cast\u0026lt;D*\u0026gt;(pB); // Noncompliant - undefined behavior\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nclass B { ... };\nclass D: public virtual B { ... };\nD d;\nB *pB \u003d \u0026amp;d;\n\nD *pD1 \u003d dynamic_cast\u0026lt;D*\u0026gt;(pB); // Compliant, but pD2 may be NULL\nD \u0026amp; D2 \u003d dynamic_cast\u0026lt;D\u0026amp;\u0026gt;(*pB); // Compliant, but may throw an exception\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 5-2-2 - A pointer to a virtual base class shall only be cast to a pointer to a derived class by means of dynamic_cast. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "misra-c++2008"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1066",
    "name": "Mergeable \"if\" statements should be combined",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eNested code - blocks of code inside blocks of code - is eventually necessary, but increases complexity. This is why keeping the code as flat as\npossible, by avoiding unnecessary nesting, is considered a good practice.\u003c/p\u003e\n\u003cp\u003eMerging \u003ccode\u003eif\u003c/code\u003e statements when possible will decrease the nesting of the code and improve its readability.\u003c/p\u003e\n\u003cp\u003eCode like\u003c/p\u003e\n\u003cpre\u003e\nif (condition1) {\n  if (condition2) {             // Noncompliant\n    /* ... */\n  }\n}\n\u003c/pre\u003e\n\u003cp\u003ewill be more readable as\u003c/p\u003e\n\u003cpre\u003e\nif (condition1 \u0026amp;\u0026amp; condition2) { // Compliant\n  /* ... */\n}\n\u003c/pre\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eIf merging the conditions seems to result in a more complex code, extracting the condition or part of it in a named function or variable is a\nbetter approach to fix readability.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre\u003e\nif (fs::exists(path)) {\n  if (fs::is_regular_file(path) || fs::is_directory(path)) { // Noncompliant\n    /* ... */\n  }\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre\u003e\nbool isFileOrDirectory(fs::path const\u0026amp; path) {\n  return fs::is_regular_file(path) || fs::is_directory(path);\n}\n\n/* ... */\n\nif (fs::exists(path) \u0026amp;\u0026amp; isFileOrDirectory(path)) { // Compliant\n  /* ... */\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eNested code - blocks of code inside blocks of code - is eventually necessary, but increases complexity. This is why keeping the code as flat as\npossible, by avoiding unnecessary nesting, is considered a good practice.\u003c/p\u003e\n\u003cp\u003eMerging \u003ccode\u003eif\u003c/code\u003e statements when possible will decrease the nesting of the code and improve its readability.\u003c/p\u003e\n\u003cp\u003eCode like\u003c/p\u003e\n\u003cpre\u003e\nif (condition1) {\n  if (condition2) {             // Noncompliant\n    /* ... */\n  }\n}\n\u003c/pre\u003e\n\u003cp\u003ewill be more readable as\u003c/p\u003e\n\u003cpre\u003e\nif (condition1 \u0026amp;\u0026amp; condition2) { // Compliant\n  /* ... */\n}\n\u003c/pre\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eIf merging the conditions seems to result in a more complex code, extracting the condition or part of it in a named function or variable is a\nbetter approach to fix readability.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre\u003e\nif (fs::exists(path)) {\n  if (fs::is_regular_file(path) || fs::is_directory(path)) { // Noncompliant\n    /* ... */\n  }\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre\u003e\nbool isFileOrDirectory(fs::path const\u0026amp; path) {\n  return fs::is_regular_file(path) || fs::is_directory(path);\n}\n\n/* ... */\n\nif (fs::exists(path) \u0026amp;\u0026amp; isFileOrDirectory(path)) { // Compliant\n  /* ... */\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "clumsy"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S2156",
    "name": "\"final\" classes should not have \"protected\" members",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe difference between \u003ccode\u003eprivate\u003c/code\u003e and \u003ccode\u003eprotected\u003c/code\u003e visibility is that child classes can see and use \u003ccode\u003eprotected\u003c/code\u003e\nmembers but cannot see \u003ccode\u003eprivate\u003c/code\u003e ones. Since a \u003ccode\u003efinal\u003c/code\u003e class will have no children, marking the members of a \u003ccode\u003efinal\u003c/code\u003e\nclass \u003ccode\u003eprotected\u003c/code\u003e is confusingly pointless.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nclass C final {\nprotected:  // Noncompliant\n  void fun();\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nclass C final {\nprivate:\n  void fun();\n};\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eWhen overriding a base class function, keeping the same visibility as for the base class is standard practice. This rule ignores\n\u003ccode\u003eprotected\u003c/code\u003e functions in a \u003ccode\u003efinal\u003c/code\u003e class that override base class \u003ccode\u003eprotected\u003c/code\u003e functions.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/final\"\u003efinal specifier\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe difference between \u003ccode\u003eprivate\u003c/code\u003e and \u003ccode\u003eprotected\u003c/code\u003e visibility is that child classes can see and use \u003ccode\u003eprotected\u003c/code\u003e\nmembers but cannot see \u003ccode\u003eprivate\u003c/code\u003e ones. Since a \u003ccode\u003efinal\u003c/code\u003e class will have no children, marking the members of a \u003ccode\u003efinal\u003c/code\u003e\nclass \u003ccode\u003eprotected\u003c/code\u003e is confusingly pointless.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nclass C final {\nprotected:  // Noncompliant\n  void fun();\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nclass C final {\nprivate:\n  void fun();\n};\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eWhen overriding a base class function, keeping the same visibility as for the base class is standard practice. This rule ignores\n\u003ccode\u003eprotected\u003c/code\u003e functions in a \u003ccode\u003efinal\u003c/code\u003e class that override base class \u003ccode\u003eprotected\u003c/code\u003e functions.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/final\"\u003efinal specifier\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "confusing",
      "since-c++11"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:M23_090",
    "name": "A cast shall not remove any \"const\" or \"volatile\" qualification from the type accessed via a pointer or by reference",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "MODULAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 8.2.3\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eUsing a cast to remove the qualification associated with the addressed type is a violation of the principle of type qualification.\u003c/p\u003e\n\u003cp\u003eSome of the problems that might arise include:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Removal of \u003ccode\u003econst\u003c/code\u003e qualification might circumvent the read-only status of an object, which may lead to \u003cem\u003eundefined behaviour\u003c/em\u003e;\n  \u003c/li\u003e\n  \u003cli\u003e Removal of \u003ccode\u003econst\u003c/code\u003e qualification might result in a hardware exception when the object is accessed; \u003c/li\u003e\n  \u003cli\u003e Removal of \u003ccode\u003evolatile\u003c/code\u003e qualification might result in accesses to an object being removed during optimization. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\n         uint16_t           x;\n         uint16_t * const   cpi \u003d \u0026amp;x;       // const pointer\n         uint16_t * const * pcpi;           // pointer to const pointer\n         uint16_t *       * ppi;\n   const uint16_t         * pci;            // pointer to const\nvolatile uint16_t         * pvi;            // pointer to volatile\n         uint16_t         * pi;\n\npi \u003d cpi;                                   // Rule does not apply - no cast\n\npi  \u003d const_cast\u0026lt; uint16_t *  \u0026gt;( pci  );    // Non-compliant\npi  \u003d const_cast\u0026lt; uint16_t *  \u0026gt;( pvi  );    // Non-compliant\nppi \u003d const_cast\u0026lt; uint16_t ** \u0026gt;( pcpi );    // Non-compliant\n\u003c/pre\u003e\n\u003cp\u003eThe following examples also violate {rule:cpp:M23_089}: MISRA C++ 2023 Rule\u0026nbsp;8.2.2.\u003c/p\u003e\n\u003cpre\u003e\npi  \u003d ( uint16_t *  )pci;                   // Non-compliant\npi  \u003d ( uint16_t *  )pvi;                   // Non-compliant\nppi \u003d ( uint16_t ** )pcpi;                  // Non-compliant\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S859} targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:M23_089}: MISRA C++ 2023 Rule\u0026nbsp;8.2.2 - C-style casts and \u003cem\u003efunctional notation\u003c/em\u003e casts shall not be used \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/HNcxBQ\"\u003eCERT, EXP32-C.\u003c/a\u003e - Do not access a volatile object through a nonvolatile reference\n  \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/P9YxBQ\"\u003eCERT, EXP05-C.\u003c/a\u003e - Do not cast away a const qualification \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/AHw-BQ\"\u003eCERT, EXP55-CPP.\u003c/a\u003e - Do not access a cv-qualified object through a cv-unqualified type\n  \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/036324/CppCoreGuidelines.md#es50-dont-cast-away-const\"\u003eC++ Core Guidelines -\n  ES.50\u003c/a\u003e - Don’t cast away const. \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/036324/CppCoreGuidelines.md#prosafety-type-safety-profile\"\u003eC++ Core Guidelines -\n  Type.3\u003c/a\u003e - Don’t use const_cast to cast away const \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 8.2.3\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eUsing a cast to remove the qualification associated with the addressed type is a violation of the principle of type qualification.\u003c/p\u003e\n\u003cp\u003eSome of the problems that might arise include:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Removal of \u003ccode\u003econst\u003c/code\u003e qualification might circumvent the read-only status of an object, which may lead to \u003cem\u003eundefined behaviour\u003c/em\u003e;\n  \u003c/li\u003e\n  \u003cli\u003e Removal of \u003ccode\u003econst\u003c/code\u003e qualification might result in a hardware exception when the object is accessed; \u003c/li\u003e\n  \u003cli\u003e Removal of \u003ccode\u003evolatile\u003c/code\u003e qualification might result in accesses to an object being removed during optimization. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\n         uint16_t           x;\n         uint16_t * const   cpi \u003d \u0026amp;x;       // const pointer\n         uint16_t * const * pcpi;           // pointer to const pointer\n         uint16_t *       * ppi;\n   const uint16_t         * pci;            // pointer to const\nvolatile uint16_t         * pvi;            // pointer to volatile\n         uint16_t         * pi;\n\npi \u003d cpi;                                   // Rule does not apply - no cast\n\npi  \u003d const_cast\u0026lt; uint16_t *  \u0026gt;( pci  );    // Non-compliant\npi  \u003d const_cast\u0026lt; uint16_t *  \u0026gt;( pvi  );    // Non-compliant\nppi \u003d const_cast\u0026lt; uint16_t ** \u0026gt;( pcpi );    // Non-compliant\n\u003c/pre\u003e\n\u003cp\u003eThe following examples also violate {rule:cpp:M23_089}: MISRA C++ 2023 Rule\u0026nbsp;8.2.2.\u003c/p\u003e\n\u003cpre\u003e\npi  \u003d ( uint16_t *  )pci;                   // Non-compliant\npi  \u003d ( uint16_t *  )pvi;                   // Non-compliant\nppi \u003d ( uint16_t ** )pcpi;                  // Non-compliant\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S859} targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:M23_089}: MISRA C++ 2023 Rule\u0026nbsp;8.2.2 - C-style casts and \u003cem\u003efunctional notation\u003c/em\u003e casts shall not be used \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/HNcxBQ\"\u003eCERT, EXP32-C.\u003c/a\u003e - Do not access a volatile object through a nonvolatile reference\n  \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/P9YxBQ\"\u003eCERT, EXP05-C.\u003c/a\u003e - Do not cast away a const qualification \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/AHw-BQ\"\u003eCERT, EXP55-CPP.\u003c/a\u003e - Do not access a cv-qualified object through a cv-unqualified type\n  \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/036324/CppCoreGuidelines.md#es50-dont-cast-away-const\"\u003eC++ Core Guidelines -\n  ES.50\u003c/a\u003e - Don’t cast away const. \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/036324/CppCoreGuidelines.md#prosafety-type-safety-profile\"\u003eC++ Core Guidelines -\n  Type.3\u003c/a\u003e - Don’t use const_cast to cast away const \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "misra-c++2023",
      "misra-required",
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1067",
    "name": "Expressions should not be too complex",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "FOCUSED",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe complexity of an expression is defined by the number of \u003ccode\u003e\u0026amp;\u0026amp;\u003c/code\u003e, \u003ccode\u003e||\u003c/code\u003e and \u003ccode\u003econdition ? ifTrue : ifFalse\u003c/code\u003e\noperators it contains.\u003c/p\u003e\n\u003cp\u003eA single expression’s complexity should not become too high to keep the code readable.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cp\u003eWith the default threshold value 3.\u003c/p\u003e\n\u003cpre\u003e\nif (((condition1 \u0026amp;\u0026amp; condition2) || (condition3 \u0026amp;\u0026amp; condition4)) \u0026amp;\u0026amp; condition5) { ... }\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nif ((myFirstCondition() || mySecondCondition()) \u0026amp;\u0026amp; myLastCondition()) { ... }\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe complexity of an expression is defined by the number of \u003ccode\u003e\u0026amp;\u0026amp;\u003c/code\u003e, \u003ccode\u003e||\u003c/code\u003e and \u003ccode\u003econdition ? ifTrue : ifFalse\u003c/code\u003e\noperators it contains.\u003c/p\u003e\n\u003cp\u003eA single expression’s complexity should not become too high to keep the code readable.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cp\u003eWith the default threshold value 3.\u003c/p\u003e\n\u003cpre\u003e\nif (((condition1 \u0026amp;\u0026amp; condition2) || (condition3 \u0026amp;\u0026amp; condition4)) \u0026amp;\u0026amp; condition5) { ... }\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nif ((myFirstCondition() || mySecondCondition()) \u0026amp;\u0026amp; myLastCondition()) { ... }\n\u003c/pre\u003e"
      }
    ],
    "params": {
      "max": {
        "key": "max",
        "name": "max",
        "description": "Maximum number of allowed conditional operators in an expression",
        "defaultValue": "3",
        "type": "INTEGER",
        "multiple": false,
        "possibleValues": []
      }
    },
    "defaultParams": {
      "max": "3"
    },
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "brain-overload"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1188",
    "name": "Lambdas should not have too many lines",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "FOCUSED",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eLambdas (introduced in C++11) are a very convenient and compact way to inject a behavior without having to create a dedicated function. But those\nlambdas should be used only if the behavior to be injected can be defined in a few lines of code, otherwise the source code can quickly become\nunreadable.\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eLambdas (introduced in C++11) are a very convenient and compact way to inject a behavior without having to create a dedicated function. But those\nlambdas should be used only if the behavior to be injected can be defined in a few lines of code, otherwise the source code can quickly become\nunreadable.\u003c/p\u003e"
      }
    ],
    "params": {
      "max": {
        "key": "max",
        "name": "max",
        "description": "Maximum allowed lines in a lambda",
        "defaultValue": "20",
        "type": "INTEGER",
        "multiple": false,
        "possibleValues": []
      }
    },
    "defaultParams": {
      "max": "20"
    },
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "since-c++11"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5421",
    "name": "Non-const global variables should not be used",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "MODULAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eA global variable can be modified from anywhere in the program. At first, this might look convenient, but it makes programs harder to understand.\nWhen you see a function call, you cannot know if the function will affect the value of the variable or not. You have lost the ability to reason\nlocally about your code and must always have the whole program in mind.\u003c/p\u003e\n\u003cp\u003eAdditionally, global variables are often subject to race conditions in multi-threaded environments.\u003c/p\u003e\n\u003cp\u003eSome global variables defined in external libraries (such as \u003ccode\u003estd::cout\u003c/code\u003e, \u003ccode\u003estd::cin\u003c/code\u003e, \u003ccode\u003estd::cerr\u003c/code\u003e) are acceptable\nto use, but you should have a good reason to create your own. If you use a global variable, ensure they can be safely accessed concurrently.\u003c/p\u003e\n\u003cp\u003eThis rule detects all declarations of global variables (in the global namespace or any namespace) that are not constant.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\ndouble oneFoot \u003d 0.3048; // Noncompliant\ndouble userValue; // Noncompliant\nvoid readValue();\nvoid writeResult();\n\nint main() {\n  readValue();\n  writeResult();\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nconstexpr double footToMeter \u003d 0.3048;\n\ndouble readValue();\nvoid writeResult(double);\n\nint main() {\n  auto userValue \u003d readValue();\n  writeResult(userValue * footToMeter);\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#i2-avoid-non-const-global-variables\"\u003eI.2: Avoid\n  non-\u003ccode\u003econst\u003c/code\u003e global variables\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eA global variable can be modified from anywhere in the program. At first, this might look convenient, but it makes programs harder to understand.\nWhen you see a function call, you cannot know if the function will affect the value of the variable or not. You have lost the ability to reason\nlocally about your code and must always have the whole program in mind.\u003c/p\u003e\n\u003cp\u003eAdditionally, global variables are often subject to race conditions in multi-threaded environments.\u003c/p\u003e\n\u003cp\u003eSome global variables defined in external libraries (such as \u003ccode\u003estd::cout\u003c/code\u003e, \u003ccode\u003estd::cin\u003c/code\u003e, \u003ccode\u003estd::cerr\u003c/code\u003e) are acceptable\nto use, but you should have a good reason to create your own. If you use a global variable, ensure they can be safely accessed concurrently.\u003c/p\u003e\n\u003cp\u003eThis rule detects all declarations of global variables (in the global namespace or any namespace) that are not constant.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\ndouble oneFoot \u003d 0.3048; // Noncompliant\ndouble userValue; // Noncompliant\nvoid readValue();\nvoid writeResult();\n\nint main() {\n  readValue();\n  writeResult();\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nconstexpr double footToMeter \u003d 0.3048;\n\ndouble readValue();\nvoid writeResult(double);\n\nint main() {\n  auto userValue \u003d readValue();\n  writeResult(userValue * footToMeter);\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#i2-avoid-non-const-global-variables\"\u003eI.2: Avoid\n  non-\u003ccode\u003econst\u003c/code\u003e global variables\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "bad-practice",
      "cppcoreguidelines",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5542",
    "name": "Encryption algorithms should be used with secure mode and padding scheme",
    "defaultSeverity": "CRITICAL",
    "type": "VULNERABILITY",
    "cleanCodeAttribute": "TRUSTWORTHY",
    "defaultImpacts": {
      "SECURITY": "HIGH"
    },
    "description": "\u003cp\u003eThis vulnerability exposes encrypted data to a number of attacks whose goal is to recover the plaintext.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eEncryption algorithms are essential for protecting sensitive information and ensuring secure communications in a variety of domains. They are used\nfor several important reasons:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Confidentiality, privacy, and intellectual property protection \u003c/li\u003e\n  \u003cli\u003e Security during transmission or on storage devices \u003c/li\u003e\n  \u003cli\u003e Data integrity, general trust, and authentication \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWhen selecting encryption algorithms, tools, or combinations, you should also consider two things:\u003c/p\u003e\n\u003col\u003e\n  \u003cli\u003e No encryption is unbreakable. \u003c/li\u003e\n  \u003cli\u003e The strength of an encryption algorithm is usually measured by the effort required to crack it within a reasonable time frame. \u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eFor these reasons, as soon as cryptography is included in a project, it is important to choose encryption algorithms that are considered strong and\nsecure by the cryptography community.\u003c/p\u003e\n\u003cp\u003eFor AES, the weakest modes are CBC (Cipher Block Chaining) and ECB (Electronic Codebook) because they are either vulnerable to padding oracles or\ndo not provide authentication mechanisms.\u003c/p\u003e\n\u003cp\u003eFor RSA, the weakest algorithms are either using it without padding or using the PKCS1v1.5 padding scheme.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eThe cleartext of an encrypted message might be recoverable. Additionally, it might be possible to modify the cleartext of an encrypted message.\u003c/p\u003e\n\u003cp\u003eBelow are some real-world scenarios that illustrate possible impacts of an attacker exploiting the vulnerability.\u003c/p\u003e\n\u003ch4\u003eTheft of sensitive data\u003c/h4\u003e\n\u003cp\u003eThe encrypted message might contain data that is considered sensitive and should not be known to third parties.\u003c/p\u003e\n\u003cp\u003eBy using a weak algorithm the likelihood that an attacker might be able to recover the cleartext drastically increases.\u003c/p\u003e\n\u003ch4\u003eAdditional attack surface\u003c/h4\u003e\n\u003cp\u003eBy modifying the cleartext of the encrypted message it might be possible for an attacker to trigger other vulnerabilities in the code. Encrypted\nvalues are often considered trusted, since under normal circumstances it would not be possible for a third party to modify them.\u003c/p\u003e\n\u003ch2\u003eHow to fix it in Botan\u003c/h2\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cp\u003eExample with a symmetric cipher, AES:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;botan/cipher_mode.h\u0026gt;\n\nvoid encrypt() {\n  Botan::Cipher_Mode::create(\"AES-256/ECB\", Botan::ENCRYPTION); // Noncompliant\n}\n\u003c/pre\u003e\n\u003cp\u003eExample with an asymmetric cipher, RSA:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;botan/rng.h\u0026gt;\n#include \u0026lt;botan/auto_rng.h\u0026gt;\n#include \u0026lt;botan/rsa.h\u0026gt;\n#include \u0026lt;botan/pubkey.h\u0026gt;\n\nvoid encrypt() {\n  std::unique_ptr\u0026lt;Botan::RandomNumberGenerator\u0026gt;   rng(new Botan::AutoSeeded_RNG);\n  Botan::RSA_PrivateKey                           rsaKey(*rng.get(), 2048);\n\n  Botan::PK_Encryptor_EME(rsaKey, *rng.get(), \"PKCS1v15\"); // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eFor the AES symmetric cipher, use the GCM mode:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;botan/cipher_mode.h\u0026gt;\n\nvoid encrypt() {\n  Botan::Cipher_Mode::create(\"AES-256/GCM\", Botan::ENCRYPTION);\n}\n\u003c/pre\u003e\n\u003cp\u003eFor the RSA asymmetric cipher, use the Optimal Asymmetric Encryption Padding (OAEP):\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;botan/rng.h\u0026gt;\n#include \u0026lt;botan/auto_rng.h\u0026gt;\n#include \u0026lt;botan/rsa.h\u0026gt;\n#include \u0026lt;botan/pubkey.h\u0026gt;\n\nvoid encrypt() {\n  std::unique_ptr\u0026lt;Botan::RandomNumberGenerator\u0026gt;   rng(new Botan::AutoSeeded_RNG);\n  Botan::RSA_PrivateKey                           rsaKey(*rng.get(), 2048);\n\n  Botan::PK_Encryptor_EME(rsaKey, *rng.get(), \"OAEP\");\n}\n\u003c/pre\u003e\n\u003ch3\u003eHow does this work?\u003c/h3\u003e\n\u003cp\u003eAs a rule of thumb, use the cryptographic algorithms and mechanisms that are considered strong by the cryptographic community.\u003c/p\u003e\n\u003cp\u003eAppropriate choices are currently the following.\u003c/p\u003e\n\u003ch4\u003eFor AES: Use Galois/Counter mode (GCM)\u003c/h4\u003e\n\u003cp\u003eGCM mode combines encryption with authentication and integrity checks using a cryptographic hash function and provides both confidentiality and\nauthenticity of data.\u003c/p\u003e\n\u003cp\u003eOther similar modes are:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e CCM: \u003ccode\u003eCounter with CBC-MAC\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e CWC: \u003ccode\u003eCipher Block Chaining with Message Authentication Code\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e EAX: \u003ccode\u003eEncrypt-and-Authenticate\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e IAPM: \u003ccode\u003eInteger Authenticated Parallelizable Mode\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e OCB: \u003ccode\u003eOffset Codebook Mode\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIt is also possible to use AES-CBC with HMAC for integrity checks. However, it\u003c/p\u003e\n\u003cp\u003eis considered more straightforward to use AES-GCM directly instead.\u003c/p\u003e\n\u003ch4\u003eFor RSA: use the OAEP scheme\u003c/h4\u003e\n\u003cp\u003eThe Optimal Asymmetric Encryption Padding scheme (OAEP) adds randomness and a secure hash function that strengthens the regular inner workings of\nRSA.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eArticles \u0026amp; blog posts\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://learn.microsoft.com/en-us/dotnet/standard/security/vulnerabilities-cbc-mode\"\u003eMicrosoft, Timing vulnerabilities with CBC-mode\n  symmetric decryption using padding\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Padding_oracle_attack\"\u003eWikipedia, Padding Oracle Attack\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Chosen-ciphertext_attack\"\u003eWikipedia, Chosen-Ciphertext Attack\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Chosen-plaintext_attack\"\u003eWikipedia, Chosen-Plaintext Attack\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Semantic_security\"\u003eWikipedia, Semantically Secure Cryptosystems\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Optimal_asymmetric_encryption_padding\"\u003eWikipedia, OAEP\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Galois/Counter_Mode\"\u003eWikipedia, Galois/Counter Mode\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/Top10/A02_2021-Cryptographic_Failures/\"\u003eOWASP Top 10 2021 Category A2\u003c/a\u003e - Cryptographic Failures \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration\"\u003eOWASP Top 10 2017 Category A6\u003c/a\u003e - Security\n  Misconfiguration \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/327\"\u003eMITRE, CWE-327\u003c/a\u003e - Use of a Broken or Risky Cryptographic Algorithm \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eThis vulnerability exposes encrypted data to a number of attacks whose goal is to recover the plaintext.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eEncryption algorithms are essential for protecting sensitive information and ensuring secure communications in a variety of domains. They are used\nfor several important reasons:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Confidentiality, privacy, and intellectual property protection \u003c/li\u003e\n  \u003cli\u003e Security during transmission or on storage devices \u003c/li\u003e\n  \u003cli\u003e Data integrity, general trust, and authentication \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWhen selecting encryption algorithms, tools, or combinations, you should also consider two things:\u003c/p\u003e\n\u003col\u003e\n  \u003cli\u003e No encryption is unbreakable. \u003c/li\u003e\n  \u003cli\u003e The strength of an encryption algorithm is usually measured by the effort required to crack it within a reasonable time frame. \u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eFor these reasons, as soon as cryptography is included in a project, it is important to choose encryption algorithms that are considered strong and\nsecure by the cryptography community.\u003c/p\u003e\n\u003cp\u003eFor AES, the weakest modes are CBC (Cipher Block Chaining) and ECB (Electronic Codebook) because they are either vulnerable to padding oracles or\ndo not provide authentication mechanisms.\u003c/p\u003e\n\u003cp\u003eFor RSA, the weakest algorithms are either using it without padding or using the PKCS1v1.5 padding scheme.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eThe cleartext of an encrypted message might be recoverable. Additionally, it might be possible to modify the cleartext of an encrypted message.\u003c/p\u003e\n\u003cp\u003eBelow are some real-world scenarios that illustrate possible impacts of an attacker exploiting the vulnerability.\u003c/p\u003e\n\u003ch4\u003eTheft of sensitive data\u003c/h4\u003e\n\u003cp\u003eThe encrypted message might contain data that is considered sensitive and should not be known to third parties.\u003c/p\u003e\n\u003cp\u003eBy using a weak algorithm the likelihood that an attacker might be able to recover the cleartext drastically increases.\u003c/p\u003e\n\u003ch4\u003eAdditional attack surface\u003c/h4\u003e\n\u003cp\u003eBy modifying the cleartext of the encrypted message it might be possible for an attacker to trigger other vulnerabilities in the code. Encrypted\nvalues are often considered trusted, since under normal circumstances it would not be possible for a third party to modify them.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cp\u003eExample with a symmetric cipher, AES:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;botan/cipher_mode.h\u0026gt;\n\nvoid encrypt() {\n  Botan::Cipher_Mode::create(\"AES-256/ECB\", Botan::ENCRYPTION); // Noncompliant\n}\n\u003c/pre\u003e\n\u003cp\u003eExample with an asymmetric cipher, RSA:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;botan/rng.h\u0026gt;\n#include \u0026lt;botan/auto_rng.h\u0026gt;\n#include \u0026lt;botan/rsa.h\u0026gt;\n#include \u0026lt;botan/pubkey.h\u0026gt;\n\nvoid encrypt() {\n  std::unique_ptr\u0026lt;Botan::RandomNumberGenerator\u0026gt;   rng(new Botan::AutoSeeded_RNG);\n  Botan::RSA_PrivateKey                           rsaKey(*rng.get(), 2048);\n\n  Botan::PK_Encryptor_EME(rsaKey, *rng.get(), \"PKCS1v15\"); // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eFor the AES symmetric cipher, use the GCM mode:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;botan/cipher_mode.h\u0026gt;\n\nvoid encrypt() {\n  Botan::Cipher_Mode::create(\"AES-256/GCM\", Botan::ENCRYPTION);\n}\n\u003c/pre\u003e\n\u003cp\u003eFor the RSA asymmetric cipher, use the Optimal Asymmetric Encryption Padding (OAEP):\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;botan/rng.h\u0026gt;\n#include \u0026lt;botan/auto_rng.h\u0026gt;\n#include \u0026lt;botan/rsa.h\u0026gt;\n#include \u0026lt;botan/pubkey.h\u0026gt;\n\nvoid encrypt() {\n  std::unique_ptr\u0026lt;Botan::RandomNumberGenerator\u0026gt;   rng(new Botan::AutoSeeded_RNG);\n  Botan::RSA_PrivateKey                           rsaKey(*rng.get(), 2048);\n\n  Botan::PK_Encryptor_EME(rsaKey, *rng.get(), \"OAEP\");\n}\n\u003c/pre\u003e\n\u003ch3\u003eHow does this work?\u003c/h3\u003e\n\u003cp\u003eAs a rule of thumb, use the cryptographic algorithms and mechanisms that are considered strong by the cryptographic community.\u003c/p\u003e\n\u003cp\u003eAppropriate choices are currently the following.\u003c/p\u003e\n\u003ch4\u003eFor AES: Use Galois/Counter mode (GCM)\u003c/h4\u003e\n\u003cp\u003eGCM mode combines encryption with authentication and integrity checks using a cryptographic hash function and provides both confidentiality and\nauthenticity of data.\u003c/p\u003e\n\u003cp\u003eOther similar modes are:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e CCM: \u003ccode\u003eCounter with CBC-MAC\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e CWC: \u003ccode\u003eCipher Block Chaining with Message Authentication Code\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e EAX: \u003ccode\u003eEncrypt-and-Authenticate\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e IAPM: \u003ccode\u003eInteger Authenticated Parallelizable Mode\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e OCB: \u003ccode\u003eOffset Codebook Mode\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIt is also possible to use AES-CBC with HMAC for integrity checks. However, it\u003c/p\u003e\n\u003cp\u003eis considered more straightforward to use AES-GCM directly instead.\u003c/p\u003e\n\u003ch4\u003eFor RSA: use the OAEP scheme\u003c/h4\u003e\n\u003cp\u003eThe Optimal Asymmetric Encryption Padding scheme (OAEP) adds randomness and a secure hash function that strengthens the regular inner workings of\nRSA.\u003c/p\u003e",
        "context": {
          "key": "botan",
          "displayName": "Botan"
        }
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cp\u003eExample with a symmetric cipher, AES:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"21\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;cryptopp/aes.h\u0026gt;\n#include \u0026lt;cryptopp/modes.h\u0026gt;\n\nvoic encrypt() {\n  CryptoPP::CBC_Mode\u0026lt;CryptoPP::AES\u0026gt;::Encryption(); // Noncompliant\n}\n\u003c/pre\u003e\n\u003cp\u003eExample with an asymmetric cipher, RSA:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"22\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;cryptopp/rsa.h\u0026gt;\n\nvoid encrypt() {\n  CryptoPP::RSAES\u0026lt;CryptoPP::PKCS1v15\u0026gt;::Encryptor(); // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eFor the AES symmetric cipher, use the GCM mode:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"21\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;cryptopp/aes.h\u0026gt;\n#include \u0026lt;cryptopp/modes.h\u0026gt;\n\nvoid encrypt() {\n  CryptoPP::GCM\u0026lt;CryptoPP::AES\u0026gt;::Encryption();\n}\n\u003c/pre\u003e\n\u003cp\u003eFor the RSA asymmetric cipher, use the Optimal Asymmetric Encryption Padding (OAEP):\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"22\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;cryptopp/rsa.h\u0026gt;\n\nvoid encrypt() {\n  CryptoPP::RSAES\u0026lt;CryptoPP::OAEP\u0026lt;CryptoPP::SHA1\u0026gt;\u0026gt;::Encryptor();\n}\n\u003c/pre\u003e\n\u003ch3\u003eHow does this work?\u003c/h3\u003e\n\u003cp\u003eAs a rule of thumb, use the cryptographic algorithms and mechanisms that are considered strong by the cryptographic community.\u003c/p\u003e\n\u003cp\u003eAppropriate choices are currently the following.\u003c/p\u003e\n\u003ch4\u003eFor AES: Use Galois/Counter mode (GCM)\u003c/h4\u003e\n\u003cp\u003eGCM mode combines encryption with authentication and integrity checks using a cryptographic hash function and provides both confidentiality and\nauthenticity of data.\u003c/p\u003e\n\u003cp\u003eOther similar modes are:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e CCM: \u003ccode\u003eCounter with CBC-MAC\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e CWC: \u003ccode\u003eCipher Block Chaining with Message Authentication Code\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e EAX: \u003ccode\u003eEncrypt-and-Authenticate\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e IAPM: \u003ccode\u003eInteger Authenticated Parallelizable Mode\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e OCB: \u003ccode\u003eOffset Codebook Mode\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIt is also possible to use AES-CBC with HMAC for integrity checks. However, it\u003c/p\u003e\n\u003cp\u003eis considered more straightforward to use AES-GCM directly instead.\u003c/p\u003e\n\u003ch4\u003eFor RSA: use the OAEP scheme\u003c/h4\u003e\n\u003cp\u003eThe Optimal Asymmetric Encryption Padding scheme (OAEP) adds randomness and a secure hash function that strengthens the regular inner workings of\nRSA.\u003c/p\u003e",
        "context": {
          "key": "cryptopp",
          "displayName": "CryptoPP"
        }
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cp\u003eExample with a symmetric cipher, AES:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"31\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;openssl/evp.h\u0026gt;\n\nvoid encrypt() {\n  EVP_aes_128_cbc(); // Noncompliant\n}\n\u003c/pre\u003e\n\u003cp\u003eExample with an asymmetric cipher, RSA:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"32\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;openssl/rsa.h\u0026gt;\n\nvoid encrypt() {\n  RSA_public_decrypt(flen, from, to, key, RSA_SSLV23_PADDING); // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eFor the AES symmetric cipher, use the GCM mode:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"31\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;openssl/evp.h\u0026gt;\n\nvoid encrypt() {\n  EVP_aes_128_gcm();\n}\n\u003c/pre\u003e\n\u003cp\u003eFor the RSA asymmetric cipher, use the Optimal Asymmetric Encryption Padding (OAEP):\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"32\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;openssl/rsa.h\u0026gt;\n\nvoid encrypt() {\n  RSA_public_decrypt(flen, from, to, key, RSA_PKCS1_OAEP_PADDING);\n}\n\u003c/pre\u003e\n\u003ch3\u003eHow does this work?\u003c/h3\u003e\n\u003cp\u003eAs a rule of thumb, use the cryptographic algorithms and mechanisms that are considered strong by the cryptographic community.\u003c/p\u003e\n\u003cp\u003eAppropriate choices are currently the following.\u003c/p\u003e\n\u003ch4\u003eFor AES: Use Galois/Counter mode (GCM)\u003c/h4\u003e\n\u003cp\u003eGCM mode combines encryption with authentication and integrity checks using a cryptographic hash function and provides both confidentiality and\nauthenticity of data.\u003c/p\u003e\n\u003cp\u003eOther similar modes are:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e CCM: \u003ccode\u003eCounter with CBC-MAC\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e CWC: \u003ccode\u003eCipher Block Chaining with Message Authentication Code\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e EAX: \u003ccode\u003eEncrypt-and-Authenticate\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e IAPM: \u003ccode\u003eInteger Authenticated Parallelizable Mode\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e OCB: \u003ccode\u003eOffset Codebook Mode\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIt is also possible to use AES-CBC with HMAC for integrity checks. However, it\u003c/p\u003e\n\u003cp\u003eis considered more straightforward to use AES-GCM directly instead.\u003c/p\u003e\n\u003ch4\u003eFor RSA: use the OAEP scheme\u003c/h4\u003e\n\u003cp\u003eThe Optimal Asymmetric Encryption Padding scheme (OAEP) adds randomness and a secure hash function that strengthens the regular inner workings of\nRSA.\u003c/p\u003e",
        "context": {
          "key": "openssl",
          "displayName": "OpenSSL"
        }
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eArticles \u0026amp; blog posts\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://learn.microsoft.com/en-us/dotnet/standard/security/vulnerabilities-cbc-mode\"\u003eMicrosoft, Timing vulnerabilities with CBC-mode\n  symmetric decryption using padding\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Padding_oracle_attack\"\u003eWikipedia, Padding Oracle Attack\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Chosen-ciphertext_attack\"\u003eWikipedia, Chosen-Ciphertext Attack\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Chosen-plaintext_attack\"\u003eWikipedia, Chosen-Plaintext Attack\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Semantic_security\"\u003eWikipedia, Semantically Secure Cryptosystems\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Optimal_asymmetric_encryption_padding\"\u003eWikipedia, OAEP\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://en.wikipedia.org/wiki/Galois/Counter_Mode\"\u003eWikipedia, Galois/Counter Mode\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/Top10/A02_2021-Cryptographic_Failures/\"\u003eOWASP Top 10 2021 Category A2\u003c/a\u003e - Cryptographic Failures \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration\"\u003eOWASP Top 10 2017 Category A6\u003c/a\u003e - Security\n  Misconfiguration \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/327\"\u003eMITRE, CWE-327\u003c/a\u003e - Use of a Broken or Risky Cryptographic Algorithm \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cert",
      "cwe",
      "privacy"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1068",
    "name": "Unused \"private\" fields should be removed",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eIf a \u003ccode\u003eprivate\u003c/code\u003e field is declared but not used locally, its limited visibility makes it dead code.\u003c/p\u003e\n\u003cp\u003eThis is either a sign that some logic is missing or that the code should be cleaned.\u003c/p\u003e\n\u003cp\u003eCleaning out dead code decreases the size of the maintained codebase, making it easier to understand and preventing bugs from being introduced.\u003c/p\u003e\n\u003cpre\u003e\nclass MyClass {\npublic:\n  int compute(int a) {\n    return a * 42;\n  }\n\n  int publicField \u003d 0; // Compliant: might be used somewhere else\nprivate:\n  int foo \u003d 42;  // Noncompliant: foo is unused and should be removed\n};\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eIf a \u003ccode\u003eprivate\u003c/code\u003e field is declared but not used locally, its limited visibility makes it dead code.\u003c/p\u003e\n\u003cp\u003eThis is either a sign that some logic is missing or that the code should be cleaned.\u003c/p\u003e\n\u003cp\u003eCleaning out dead code decreases the size of the maintained codebase, making it easier to understand and preventing bugs from being introduced.\u003c/p\u003e\n\u003cpre\u003e\nclass MyClass {\npublic:\n  int compute(int a) {\n    return a * 42;\n  }\n\n  int publicField \u003d 0; // Compliant: might be used somewhere else\nprivate:\n  int foo \u003d 42;  // Noncompliant: foo is unused and should be removed\n};\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "unused"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5305",
    "name": "The statement forming the body of a \"switch\", \"while\", \"do {...} while\" or \"for\" statement shall be a compound statement",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThis rule is a strict implementation of a MISRA (Motor Industry Software Reliability Association) rule. MISRA defines best practices for developing\nsafety-critical software. You can learn more about this rule in the MISRA documents referenced below.\u003c/p\u003e\n\u003cp\u003eIf you are not concerned with MISRA compliance or with safety-critical software, you might consider using rule {rule:cpp:S121} instead ; it targets\nthe same kind of issue for general-purpose software.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++2008, 6-3-1 The statement forming the body of a switch, while, do … while or for statement shall be a compound statement. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThis rule is a strict implementation of a MISRA (Motor Industry Software Reliability Association) rule. MISRA defines best practices for developing\nsafety-critical software. You can learn more about this rule in the MISRA documents referenced below.\u003c/p\u003e\n\u003cp\u003eIf you are not concerned with MISRA compliance or with safety-critical software, you might consider using rule {rule:cpp:S121} instead ; it targets\nthe same kind of issue for general-purpose software.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C++2008, 6-3-1 The statement forming the body of a switch, while, do … while or for statement shall be a compound statement. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "misra-c++2008"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5547",
    "name": "Cipher algorithms should be robust",
    "defaultSeverity": "CRITICAL",
    "type": "VULNERABILITY",
    "cleanCodeAttribute": "TRUSTWORTHY",
    "defaultImpacts": {
      "SECURITY": "HIGH"
    },
    "description": "\u003cp\u003eThis vulnerability makes it possible that the cleartext of the encrypted message might be recoverable without prior knowledge of the key.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eEncryption algorithms are essential for protecting sensitive information and ensuring secure communication in various domains. They are used for\nseveral important reasons:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Confidentiality, privacy, and intellectual property protection \u003c/li\u003e\n  \u003cli\u003e Security during transmission or on storage devices \u003c/li\u003e\n  \u003cli\u003e Data integrity, general trust, and authentication \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWhen selecting encryption algorithms, tools, or combinations, you should also consider two things:\u003c/p\u003e\n\u003col\u003e\n  \u003cli\u003e No encryption is unbreakable. \u003c/li\u003e\n  \u003cli\u003e The strength of an encryption algorithm is usually measured by the effort required to crack it within a reasonable time frame. \u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eFor these reasons, as soon as cryptography is included in a project, it is important to choose encryption algorithms that are considered strong and\nsecure by the cryptography community.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eThe cleartext of an encrypted message might be recoverable. Additionally, it might be possible to modify the cleartext of an encrypted message.\u003c/p\u003e\n\u003cp\u003eBelow are some real-world scenarios that illustrate some impacts of an attacker exploiting the vulnerability.\u003c/p\u003e\n\u003ch4\u003eTheft of sensitive data\u003c/h4\u003e\n\u003cp\u003eThe encrypted message might contain data that is considered sensitive and should not be known to third parties.\u003c/p\u003e\n\u003cp\u003eBy using a weak algorithm the likelihood that an attacker might be able to recover the cleartext drastically increases.\u003c/p\u003e\n\u003ch4\u003eAdditional attack surface\u003c/h4\u003e\n\u003cp\u003eBy modifying the cleartext of the encrypted message it might be possible for an attacker to trigger other vulnerabilities in the code. Encrypted\nvalues are often considered trusted, since under normal circumstances it would not be possible for a third party to modify them.\u003c/p\u003e\n\u003ch2\u003eHow to fix it in Botan\u003c/h2\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003cp\u003eThe following code contains examples of algorithms that are not considered highly resistant to cryptanalysis and thus should be avoided.\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;botan/cipher_mode.h\u0026gt;\n\nvoid encrypt() {\n  Botan::Cipher_Mode::create(\"DES/CBC/PKCS7\", Botan::ENCRYPTION); // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;botan/cipher_mode.h\u0026gt;\n\nvoid encrypt() {\n  Botan::Cipher_Mode::create(\"AES-256/GCM\", Botan::ENCRYPTION);\n}\n\u003c/pre\u003e\n\u003ch3\u003eHow does this work?\u003c/h3\u003e\n\u003ch4\u003eUse a secure algorithm\u003c/h4\u003e\n\u003cp\u003eIt is highly recommended to use an algorithm that is currently considered secure by the cryptographic community. A common choice for such an\nalgorithm is the Advanced Encryption Standard (AES).\u003c/p\u003e\n\u003cp\u003eFor block ciphers, it is not recommended to use algorithms with a block size that is smaller than 128 bits.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://botan.randombit.net/handbook/\"\u003eBotan\u003c/a\u003e - Handbook \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://www.feistyduck.com/books/openssl-cookbook/\"\u003eOpenSSL\u003c/a\u003e - Cookbook \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/Top10/A02_2021-Cryptographic_Failures/\"\u003eOWASP Top 10 2021 Category A2\u003c/a\u003e - Cryptographic Failures \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://www.owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\"\u003eOWASP Top 10 2017 Category A3\u003c/a\u003e - Sensitive Data\n  Exposure \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/327\"\u003eMITRE, CWE-327\u003c/a\u003e - Use of a Broken or Risky Cryptographic Algorithm \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eThis vulnerability makes it possible that the cleartext of the encrypted message might be recoverable without prior knowledge of the key.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eEncryption algorithms are essential for protecting sensitive information and ensuring secure communication in various domains. They are used for\nseveral important reasons:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Confidentiality, privacy, and intellectual property protection \u003c/li\u003e\n  \u003cli\u003e Security during transmission or on storage devices \u003c/li\u003e\n  \u003cli\u003e Data integrity, general trust, and authentication \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWhen selecting encryption algorithms, tools, or combinations, you should also consider two things:\u003c/p\u003e\n\u003col\u003e\n  \u003cli\u003e No encryption is unbreakable. \u003c/li\u003e\n  \u003cli\u003e The strength of an encryption algorithm is usually measured by the effort required to crack it within a reasonable time frame. \u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eFor these reasons, as soon as cryptography is included in a project, it is important to choose encryption algorithms that are considered strong and\nsecure by the cryptography community.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eThe cleartext of an encrypted message might be recoverable. Additionally, it might be possible to modify the cleartext of an encrypted message.\u003c/p\u003e\n\u003cp\u003eBelow are some real-world scenarios that illustrate some impacts of an attacker exploiting the vulnerability.\u003c/p\u003e\n\u003ch4\u003eTheft of sensitive data\u003c/h4\u003e\n\u003cp\u003eThe encrypted message might contain data that is considered sensitive and should not be known to third parties.\u003c/p\u003e\n\u003cp\u003eBy using a weak algorithm the likelihood that an attacker might be able to recover the cleartext drastically increases.\u003c/p\u003e\n\u003ch4\u003eAdditional attack surface\u003c/h4\u003e\n\u003cp\u003eBy modifying the cleartext of the encrypted message it might be possible for an attacker to trigger other vulnerabilities in the code. Encrypted\nvalues are often considered trusted, since under normal circumstances it would not be possible for a third party to modify them.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eThe following code contains examples of algorithms that are not considered highly resistant to cryptanalysis and thus should be avoided.\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;botan/cipher_mode.h\u0026gt;\n\nvoid encrypt() {\n  Botan::Cipher_Mode::create(\"DES/CBC/PKCS7\", Botan::ENCRYPTION); // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;botan/cipher_mode.h\u0026gt;\n\nvoid encrypt() {\n  Botan::Cipher_Mode::create(\"AES-256/GCM\", Botan::ENCRYPTION);\n}\n\u003c/pre\u003e\n\u003ch3\u003eHow does this work?\u003c/h3\u003e\n\u003ch4\u003eUse a secure algorithm\u003c/h4\u003e\n\u003cp\u003eIt is highly recommended to use an algorithm that is currently considered secure by the cryptographic community. A common choice for such an\nalgorithm is the Advanced Encryption Standard (AES).\u003c/p\u003e\n\u003cp\u003eFor block ciphers, it is not recommended to use algorithms with a block size that is smaller than 128 bits.\u003c/p\u003e",
        "context": {
          "key": "botan",
          "displayName": "Botan"
        }
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eThe following code contains examples of algorithms that are not considered highly resistant to cryptanalysis and thus should be avoided.\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"21\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;cryptopp/des.h\u0026gt;\n\nvoid encrypt() {\n  CryptoPP::DES::Encryption(key, sizeof(key)); // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"21\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;cryptopp/aes.h\u0026gt;\n\nvoid encrypt() {\n  CryptoPP::AES::Encryption(key, sizeof(key));\n}\n\u003c/pre\u003e\n\u003ch3\u003eHow does this work?\u003c/h3\u003e\n\u003ch4\u003eUse a secure algorithm\u003c/h4\u003e\n\u003cp\u003eIt is highly recommended to use an algorithm that is currently considered secure by the cryptographic community. A common choice for such an\nalgorithm is the Advanced Encryption Standard (AES).\u003c/p\u003e\n\u003cp\u003eFor block ciphers, it is not recommended to use algorithms with a block size that is smaller than 128 bits.\u003c/p\u003e",
        "context": {
          "key": "cryptopp",
          "displayName": "CryptoPP"
        }
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eThe following code contains examples of algorithms that are not considered highly resistant to cryptanalysis and thus should be avoided.\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"31\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;openssl/evp.h\u0026gt;\n\nvoid encrypt() {\n  EVP_des_cbc(); // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"31\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;openssl/evp.h\u0026gt;\n\nvoid encrypt() {\n  EVP_aes_128_gcm();\n}\n\u003c/pre\u003e\n\u003ch3\u003eHow does this work?\u003c/h3\u003e\n\u003ch4\u003eUse a secure algorithm\u003c/h4\u003e\n\u003cp\u003eIt is highly recommended to use an algorithm that is currently considered secure by the cryptographic community. A common choice for such an\nalgorithm is the Advanced Encryption Standard (AES).\u003c/p\u003e\n\u003cp\u003eFor block ciphers, it is not recommended to use algorithms with a block size that is smaller than 128 bits.\u003c/p\u003e",
        "context": {
          "key": "openssl",
          "displayName": "OpenSSL"
        }
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://botan.randombit.net/handbook/\"\u003eBotan\u003c/a\u003e - Handbook \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://www.feistyduck.com/books/openssl-cookbook/\"\u003eOpenSSL\u003c/a\u003e - Cookbook \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/Top10/A02_2021-Cryptographic_Failures/\"\u003eOWASP Top 10 2021 Category A2\u003c/a\u003e - Cryptographic Failures \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://www.owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure\"\u003eOWASP Top 10 2017 Category A3\u003c/a\u003e - Sensitive Data\n  Exposure \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/327\"\u003eMITRE, CWE-327\u003c/a\u003e - Use of a Broken or Risky Cryptographic Algorithm \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cert",
      "cwe",
      "privacy"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6636",
    "name": "Coroutines should have well-defined exception behavior",
    "defaultSeverity": "CRITICAL",
    "type": "BUG",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhen a regular function throws an exception, stack unwinding occurs. This applies to exceptions thrown within the function body or from an inner\nfunction call.\u003c/p\u003e\n\u003cp\u003eC++20 introduced coroutines, a stackless method to invoke functions that can be suspended and resumed. As coroutines have no stack, exceptions\nbehave differently across a coroutine boundary.\u003c/p\u003e\n\u003cp\u003eThe \u003cem\u003ePromise object\u003c/em\u003e of any coroutine is required to have an \u003ccode\u003eunhandled_exception\u003c/code\u003e function. If an exception escapes the\ncoroutine function body, the \u003ccode\u003eunhandled_exception\u003c/code\u003e function is called, and the coroutine reaches the final-suspend point. Resuming the\ncoroutine after this point is undefined behavior.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003eunhandled_exception\u003c/code\u003e method is used to define such behavior. The exception can be obtained with \u003ccode\u003estd::current_exception\u003c/code\u003e\nand can be logged, rethrown, or stored:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e If rethrown, the exception will be received in any thread that resumes the coroutine. \u003c/li\u003e\n  \u003cli\u003e If stored, it can be propagated through the \u003cem\u003ePromise object\u003c/em\u003e to the awaiter. \u003c/li\u003e\n  \u003cli\u003e If no exceptions were expected from the coroutine, the program can be terminated. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eChoosing an approach depends on the coroutine use-case. Also, keep in mind the following:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Rethrowing in \u003ccode\u003eunhandled_exception\u003c/code\u003e will cause the coroutine to reach the final-suspend point without calling\n  \u003ccode\u003efinal_suspend\u003c/code\u003e first. \u003c/li\u003e\n  \u003cli\u003e A \u003ccode\u003enoexcept\u003c/code\u003e specified coroutine will only terminate the program if an exception is thrown from the \u003cem\u003ePromise type\u003c/em\u003e\u0027s\n  construction. This happens because the coroutine internal mechanisms wrap the coroutine body in a \u003ccode\u003etry-catch\u003c/code\u003e block. To enforce\n  \u003ccode\u003enoexcept\u003c/code\u003e on a coroutine, the program should be terminated in the promise_type \u003ccode\u003eunhandled_exception\u003c/code\u003e function. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nstruct Task {\n  struct promise_type {\n    /* ... */\n    void unhandled_exception() {}\n  };\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nstruct Task {\n  struct promise_type {\n    void unhandled_exception() {\n      /* ... */\n      except \u003d std::current_exception(); // store exception\n    }\n\n    std::exception_ptr except; // awaiter can check and obtain it via promise()\n  };\n};\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhen a regular function throws an exception, stack unwinding occurs. This applies to exceptions thrown within the function body or from an inner\nfunction call.\u003c/p\u003e\n\u003cp\u003eC++20 introduced coroutines, a stackless method to invoke functions that can be suspended and resumed. As coroutines have no stack, exceptions\nbehave differently across a coroutine boundary.\u003c/p\u003e\n\u003cp\u003eThe \u003cem\u003ePromise object\u003c/em\u003e of any coroutine is required to have an \u003ccode\u003eunhandled_exception\u003c/code\u003e function. If an exception escapes the\ncoroutine function body, the \u003ccode\u003eunhandled_exception\u003c/code\u003e function is called, and the coroutine reaches the final-suspend point. Resuming the\ncoroutine after this point is undefined behavior.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003eunhandled_exception\u003c/code\u003e method is used to define such behavior. The exception can be obtained with \u003ccode\u003estd::current_exception\u003c/code\u003e\nand can be logged, rethrown, or stored:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e If rethrown, the exception will be received in any thread that resumes the coroutine. \u003c/li\u003e\n  \u003cli\u003e If stored, it can be propagated through the \u003cem\u003ePromise object\u003c/em\u003e to the awaiter. \u003c/li\u003e\n  \u003cli\u003e If no exceptions were expected from the coroutine, the program can be terminated. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eChoosing an approach depends on the coroutine use-case. Also, keep in mind the following:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Rethrowing in \u003ccode\u003eunhandled_exception\u003c/code\u003e will cause the coroutine to reach the final-suspend point without calling\n  \u003ccode\u003efinal_suspend\u003c/code\u003e first. \u003c/li\u003e\n  \u003cli\u003e A \u003ccode\u003enoexcept\u003c/code\u003e specified coroutine will only terminate the program if an exception is thrown from the \u003cem\u003ePromise type\u003c/em\u003e\u0027s\n  construction. This happens because the coroutine internal mechanisms wrap the coroutine body in a \u003ccode\u003etry-catch\u003c/code\u003e block. To enforce\n  \u003ccode\u003enoexcept\u003c/code\u003e on a coroutine, the program should be terminated in the promise_type \u003ccode\u003eunhandled_exception\u003c/code\u003e function. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nstruct Task {\n  struct promise_type {\n    /* ... */\n    void unhandled_exception() {}\n  };\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nstruct Task {\n  struct promise_type {\n    void unhandled_exception() {\n      /* ... */\n      except \u003d std::current_exception(); // store exception\n    }\n\n    std::exception_ptr except; // awaiter can check and obtain it via promise()\n  };\n};\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "pitfall",
      "since-c++20"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5306",
    "name": "An `if ( condition )` construct shall be followed by a compound statement. The else keyword shall be followed by either a compound statement, or another if statement",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThis rule is a strict implementation of a MISRA (Motor Industry Software Reliability Association) rule. MISRA defines best practices for developing\nsafety-critical software. You can learn more about this rule in the MISRA documents referenced below.\u003c/p\u003e\n\u003cp\u003eIf you are not concerned with MISRA compliance or with safety-critical software, you might consider using rule {rule:cpp:S121} instead ; it targets\nthe same kind of issue for general-purpose software.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++2008, 6-4-1 An if ( condition ) construct shall be followed by a compound statement. The else keyword shall be followed by either a\n  compound statement, or another if statement. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThis rule is a strict implementation of a MISRA (Motor Industry Software Reliability Association) rule. MISRA defines best practices for developing\nsafety-critical software. You can learn more about this rule in the MISRA documents referenced below.\u003c/p\u003e\n\u003cp\u003eIf you are not concerned with MISRA compliance or with safety-critical software, you might consider using rule {rule:cpp:S121} instead ; it targets\nthe same kind of issue for general-purpose software.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C++2008, 6-4-1 An if ( condition ) construct shall be followed by a compound statement. The else keyword shall be followed by either a\n  compound statement, or another if statement. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "misra-c++2008"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5303",
    "name": "C-style casts (other than void casts) and functional notation casts (other than explicit constructor calls) shall not be used",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThis rule is a strict implementation of a MISRA (Motor Industry Software Reliability Association) rule. MISRA defines best practices for developing\nsafety-critical software. You can learn more about this rule in the MISRA documents referenced below.\u003c/p\u003e\n\u003cp\u003eIf you are not concerned with MISRA compliance or with safety-critical software, you might consider using rule {rule:cpp:S871} instead ; it targets\nthe same kind of issue for general-purpose software.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++2008, 5-2-4 \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThis rule is a strict implementation of a MISRA (Motor Industry Software Reliability Association) rule. MISRA defines best practices for developing\nsafety-critical software. You can learn more about this rule in the MISRA documents referenced below.\u003c/p\u003e\n\u003cp\u003eIf you are not concerned with MISRA compliance or with safety-critical software, you might consider using rule {rule:cpp:S871} instead ; it targets\nthe same kind of issue for general-purpose software.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C++2008, 5-2-4 \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "misra-c++2008"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5425",
    "name": "\"Forwarding references\" parameters should be used only to forward parameters",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cem\u003eForwarding references\u003c/em\u003e are a special kind of references that both ignore and preserve the \u003cem\u003evalue category\u003c/em\u003e of a function argument,\nmaking it possible to forward it by means of \u003ccode\u003estd::forward\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eAny code using such a reference for any other purpose than forwarding is actually ignoring rvalue-ness and const-ness of the associated\nparameter.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;utility\u0026gt;\n#include \u0026lt;string\u0026gt;\n#include \u0026lt;iostream\u0026gt;\n\ntemplate\u0026lt;typename TP\u0026gt; void f( TP\u0026amp;\u0026amp; arg ) {\n    std::string s(arg);\n}\n\nint main() {\n    std::string s(\"test\");\n    f(std::move(s));\n    std::cout\u0026lt;\u0026lt;\"f:\"\u0026lt;\u0026lt;s\u0026lt;\u0026lt;std::endl; // output is \"f:test\"\n\n    return 0;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;utility\u0026gt;\n#include \u0026lt;string\u0026gt;\n#include \u0026lt;iostream\u0026gt;\n\ntemplate\u0026lt;typename TP\u0026gt; void f( TP\u0026amp;\u0026amp; arg ) {\n    std::string s(std::forward\u0026lt;TP\u0026gt;(arg));\n}\n\nint main() {\n    std::string s(\"test\");\n    f(std::move(s));\n    std::cout\u0026lt;\u0026lt;\"f:\"\u0026lt;\u0026lt;s\u0026lt;\u0026lt;std::endl; // output is \"f:\"\n\n    return 0;\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f19-for-forward-parameters-pass-by-tp-and-only-stdforward-the-parameter\"\u003eF.19: For \"forward\" parameters, pass by \u003ccode\u003eTP\u0026amp;\u0026amp;\u003c/code\u003e and only \u003ccode\u003estd::forward\u003c/code\u003e the parameter\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cem\u003eForwarding references\u003c/em\u003e are a special kind of references that both ignore and preserve the \u003cem\u003evalue category\u003c/em\u003e of a function argument,\nmaking it possible to forward it by means of \u003ccode\u003estd::forward\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eAny code using such a reference for any other purpose than forwarding is actually ignoring rvalue-ness and const-ness of the associated\nparameter.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;utility\u0026gt;\n#include \u0026lt;string\u0026gt;\n#include \u0026lt;iostream\u0026gt;\n\ntemplate\u0026lt;typename TP\u0026gt; void f( TP\u0026amp;\u0026amp; arg ) {\n    std::string s(arg);\n}\n\nint main() {\n    std::string s(\"test\");\n    f(std::move(s));\n    std::cout\u0026lt;\u0026lt;\"f:\"\u0026lt;\u0026lt;s\u0026lt;\u0026lt;std::endl; // output is \"f:test\"\n\n    return 0;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;utility\u0026gt;\n#include \u0026lt;string\u0026gt;\n#include \u0026lt;iostream\u0026gt;\n\ntemplate\u0026lt;typename TP\u0026gt; void f( TP\u0026amp;\u0026amp; arg ) {\n    std::string s(std::forward\u0026lt;TP\u0026gt;(arg));\n}\n\nint main() {\n    std::string s(\"test\");\n    f(std::move(s));\n    std::cout\u0026lt;\u0026lt;\"f:\"\u0026lt;\u0026lt;s\u0026lt;\u0026lt;std::endl; // output is \"f:\"\n\n    return 0;\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f19-for-forward-parameters-pass-by-tp-and-only-stdforward-the-parameter\"\u003eF.19: For \"forward\" parameters, pass by \u003ccode\u003eTP\u0026amp;\u0026amp;\u003c/code\u003e and only \u003ccode\u003estd::forward\u003c/code\u003e the parameter\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cppcoreguidelines",
      "since-c++11",
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S824",
    "name": "Functions should not be declared at block scope",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eA function declared at block scope will refer to a member of the enclosing namespace, and so the declaration should be explicitly placed at the\nnamespace level.\u003c/p\u003e\n\u003cp\u003eAdditionally, where a declaration statement could either declare a function or an object, the compiler will choose to declare the function. To\navoid potential developer confusion over the meaning of a declaration, functions should not be declared at block scope.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass A {\n};\n\nvoid fun() {\n  void nestedFun();  // Noncompliant; declares a function in block scope\n\n  A a();      // Noncompliant; declares a function at block scope, not an object\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 8.6 - Functions shall be declared at file scope \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 3-1-2 - Functions shall not be declared at block scope \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eA function declared at block scope will refer to a member of the enclosing namespace, and so the declaration should be explicitly placed at the\nnamespace level.\u003c/p\u003e\n\u003cp\u003eAdditionally, where a declaration statement could either declare a function or an object, the compiler will choose to declare the function. To\navoid potential developer confusion over the meaning of a declaration, functions should not be declared at block scope.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass A {\n};\n\nvoid fun() {\n  void nestedFun();  // Noncompliant; declares a function in block scope\n\n  A a();      // Noncompliant; declares a function at block scope, not an object\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 8.6 - Functions shall be declared at file scope \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 3-1-2 - Functions shall not be declared at block scope \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "misra-c++2008",
      "misra-c2004"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S945",
    "name": "Array type function arguments should not decay to pointers",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhen a variable with array type decays to a pointer, its bounds are lost.\u003c/p\u003e\n\u003cp\u003eIf a design requires arrays of different lengths, then a class should be used to encapsulate the array objects and so ensure that the size is\nmaintained. Note that in C++20, the class \u003ccode\u003estd::span\u003c/code\u003e is designed for this purpose, and you can find implementation of \u003ccode\u003espan\u003c/code\u003e\nthat works with earlier versions of the standard.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid f1( int p[ 10 ] ); // Non-compliant, function called with arguments of array type\nvoid f2( int *p ); // Non-compliant, function is called with arguments of array type\nvoid functionWorkingOnSingleInt(int * p); // Non-compliant, function is called with arguments of array type\n\nvoid b ()\n{\n  int a[ 10 ];\n  f1( a ); // The size is lost\n  f2( a ); // The size is lost\n  functionWorkingOnSingleInt( a ); // Not clear that the function acts on only one element\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid f3( int ( \u0026amp;p )[ 10 ] ); // Compliant\nvoid f4(span\u0026lt;int\u0026gt; s); // Compliant\nvoid functionWorkingOnSingleInt(int * p); // Compliant\n\nvoid b ()\n{\n int a[ 10 ];\n  f3( a ); // size preserved.\n  f4( a ); // size captured by the span class\n  functionWorkingOnSingleInt( \u0026amp;a[0] ); // explicit about what happens\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 5-2-12 - An identifier with array type passed as a function argument shall not decay to a pointer. \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#i13-do-not-pass-an-array-as-a-single-pointer\"\u003eI.13: Do not pass\n  an array as a single pointer\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhen a variable with array type decays to a pointer, its bounds are lost.\u003c/p\u003e\n\u003cp\u003eIf a design requires arrays of different lengths, then a class should be used to encapsulate the array objects and so ensure that the size is\nmaintained. Note that in C++20, the class \u003ccode\u003estd::span\u003c/code\u003e is designed for this purpose, and you can find implementation of \u003ccode\u003espan\u003c/code\u003e\nthat works with earlier versions of the standard.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid f1( int p[ 10 ] ); // Non-compliant, function called with arguments of array type\nvoid f2( int *p ); // Non-compliant, function is called with arguments of array type\nvoid functionWorkingOnSingleInt(int * p); // Non-compliant, function is called with arguments of array type\n\nvoid b ()\n{\n  int a[ 10 ];\n  f1( a ); // The size is lost\n  f2( a ); // The size is lost\n  functionWorkingOnSingleInt( a ); // Not clear that the function acts on only one element\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid f3( int ( \u0026amp;p )[ 10 ] ); // Compliant\nvoid f4(span\u0026lt;int\u0026gt; s); // Compliant\nvoid functionWorkingOnSingleInt(int * p); // Compliant\n\nvoid b ()\n{\n int a[ 10 ];\n  f3( a ); // size preserved.\n  f4( a ); // size captured by the span class\n  functionWorkingOnSingleInt( \u0026amp;a[0] ); // explicit about what happens\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 5-2-12 - An identifier with array type passed as a function argument shall not decay to a pointer. \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#i13-do-not-pass-an-array-as-a-single-pointer\"\u003eI.13: Do not pass\n  an array as a single pointer\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "cppcoreguidelines",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S943",
    "name": "Object declarations should contain no more than 2 levels of pointer indirection",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhile they are extraordinarily useful, pointers are not the most intuitive concept in the world. Pointers to pointers are even harder to understand\nand use correctly. And with each additional level of indirection, pointer variables become more difficult to use correctly. Therefore pointer\ndeclarators should be limited to no more than two levels of nesting.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\ntypedef int * INTPTR;\nstruct s {\n int ** s1;\n int *** s2; // Noncompliant\n};\n\nstruct s ** ps1;\nstruct s *** ps2; // Noncompliant\n\nint ** ( *pfunc1)();\nint ** ( **pfunc2)();\nint ** (***pfunc3)(); // Noncompliant\nint *** ( **pfunc4)(); // Noncompliant\n\nvoid function( int ** par1,\n               int *** par2, // Noncompliant\n               INTPTR * par3,\n               int * par4[],\n               int ** par5[]) // Noncompliant\n{\n  int ** ptr1;\n  int *** ptr2; // Noncompliant\n  INTPTR * ptr3;\n  int * ptr4[ 10 ];\n  int ** ptr5[ 10 ]; //Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\ntypedef int * INTPTR;\nstruct s {\n int ** s1;\n int ** s2;\n};\n\nstruct s ** ps1;\nstruct s ** ps2;\n\nint ** (*pfunc1)();\nint ** (**pfunc2)();\nint ** (**pfunc3)();\nint ** (**pfunc4)();\n\nvoid function( int ** par1,\n               int ** par2,\n               INTPTR * par3,\n               int * par4[],\n               int * par5[])\n{\n  int ** ptr1;\n  int ** ptr2;\n  INTPTR * ptr3;\n  int * ptr4[ 10 ];\n  int * ptr5[ 10 ];\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 17.5 - The declaration of objects should contain no more than 2 levels of pointer indirection \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 5-0-19 - The declaration of objects shall contain no more than two levels of pointer indirection \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 18.5 - Declarations should contain no more than two levels of pointer nesting \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhile they are extraordinarily useful, pointers are not the most intuitive concept in the world. Pointers to pointers are even harder to understand\nand use correctly. And with each additional level of indirection, pointer variables become more difficult to use correctly. Therefore pointer\ndeclarators should be limited to no more than two levels of nesting.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\ntypedef int * INTPTR;\nstruct s {\n int ** s1;\n int *** s2; // Noncompliant\n};\n\nstruct s ** ps1;\nstruct s *** ps2; // Noncompliant\n\nint ** ( *pfunc1)();\nint ** ( **pfunc2)();\nint ** (***pfunc3)(); // Noncompliant\nint *** ( **pfunc4)(); // Noncompliant\n\nvoid function( int ** par1,\n               int *** par2, // Noncompliant\n               INTPTR * par3,\n               int * par4[],\n               int ** par5[]) // Noncompliant\n{\n  int ** ptr1;\n  int *** ptr2; // Noncompliant\n  INTPTR * ptr3;\n  int * ptr4[ 10 ];\n  int ** ptr5[ 10 ]; //Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\ntypedef int * INTPTR;\nstruct s {\n int ** s1;\n int ** s2;\n};\n\nstruct s ** ps1;\nstruct s ** ps2;\n\nint ** (*pfunc1)();\nint ** (**pfunc2)();\nint ** (**pfunc3)();\nint ** (**pfunc4)();\n\nvoid function( int ** par1,\n               int ** par2,\n               INTPTR * par3,\n               int * par4[],\n               int * par5[])\n{\n  int ** ptr1;\n  int ** ptr2;\n  INTPTR * ptr3;\n  int * ptr4[ 10 ];\n  int * ptr5[ 10 ];\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 17.5 - The declaration of objects should contain no more than 2 levels of pointer indirection \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 5-0-19 - The declaration of objects shall contain no more than two levels of pointer indirection \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 18.5 - Declarations should contain no more than two levels of pointer nesting \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "brain-overload",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1291",
    "name": "Track uses of \"NOSONAR\" comments",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eAny issue to quality rule can be deactivated with the \u003ccode\u003eNOSONAR\u003c/code\u003e marker. This marker is pretty useful to exclude false-positive results\nbut it can also be used abusively to hide real quality flaws.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when \u003ccode\u003eNOSONAR\u003c/code\u003e is used.\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eAny issue to quality rule can be deactivated with the \u003ccode\u003eNOSONAR\u003c/code\u003e marker. This marker is pretty useful to exclude false-positive results\nbut it can also be used abusively to hide real quality flaws.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when \u003ccode\u003eNOSONAR\u003c/code\u003e is used.\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "bad-practice"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S2260",
    "name": "Track parsing failures",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhen the analysis succeeds, it doesn’t mean that the analyzer was able to understand all the analyzed code. If the analyzer fails to parse some\nparts of your code, it will ignore them during the analysis. This rule will help you track these parsing failures.\u003c/p\u003e\n\u003cp\u003eThere are many reasons why parsing failures can happen, here are the common ones:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Compiler extensions: Your compiler might allow you to write code that isn’t standard-conforming. \u003c/li\u003e\n  \u003cli\u003e Bad analysis environment. This usually means that the environment during the build is different than the one during the analysis. For example,\n  files or symbolic links that were available during the build are not available during the analysis. \u003c/li\u003e\n  \u003cli\u003e Use of new language features that are not yet supported by our analyzer. \u003c/li\u003e\n  \u003cli\u003e Limitation in our analyzer. We are always working on improving this. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eHow do they impact analysis? We cannot judge without looking at specific examples, as they contain a broad range of types of errors. On our side,\nwe will make sure that you get notified through the analysis logs when they have an impact on the quality of the analysis.\u003c/p\u003e\n\u003cp\u003eThere are three recommended ways to deal with parsing failures:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Fix them when it is possible. It should be obvious from the message if you can do it. For example, by replacing the use of a compiler extension\n  with the standard-conforming equivalent. \u003c/li\u003e\n  \u003cli\u003e If you cannot fix them and the analysis logs state that they have a bad impact on the analysis results, Report them. \u003c/li\u003e\n  \u003cli\u003e If you cannot fix them and the analysis logs don’t state anything explicit about their impact, ignore them by resolving them as \"won’t fix\".\n  \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n// This example uses Microsoft extension /Zc:referenceBinding that allows binding r-value to l-value. Even though your compiler might allow it, our analyzer will flag it\n\nstruct S {\n...\n};\n\nvoid f(S\u0026amp;) {\n...\n}\n\nint main() {\n  f(S{}); // Noncompliant: no matching function for call to \u0027f\u0027\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n// Here we are showing how to fix the issue by replacing the code relying on a compiler extension by standard-conforming equivalent\n\nstruct S {\n...\n};\n\nvoid f(S\u0026amp;\u0026amp;) { // Using C++11 r-value reference fixes the issue\n...\n}\n\nint main() {\n  f(S{}); // Compliant\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhen the analysis succeeds, it doesn’t mean that the analyzer was able to understand all the analyzed code. If the analyzer fails to parse some\nparts of your code, it will ignore them during the analysis. This rule will help you track these parsing failures.\u003c/p\u003e\n\u003cp\u003eThere are many reasons why parsing failures can happen, here are the common ones:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Compiler extensions: Your compiler might allow you to write code that isn’t standard-conforming. \u003c/li\u003e\n  \u003cli\u003e Bad analysis environment. This usually means that the environment during the build is different than the one during the analysis. For example,\n  files or symbolic links that were available during the build are not available during the analysis. \u003c/li\u003e\n  \u003cli\u003e Use of new language features that are not yet supported by our analyzer. \u003c/li\u003e\n  \u003cli\u003e Limitation in our analyzer. We are always working on improving this. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eHow do they impact analysis? We cannot judge without looking at specific examples, as they contain a broad range of types of errors. On our side,\nwe will make sure that you get notified through the analysis logs when they have an impact on the quality of the analysis.\u003c/p\u003e\n\u003cp\u003eThere are three recommended ways to deal with parsing failures:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Fix them when it is possible. It should be obvious from the message if you can do it. For example, by replacing the use of a compiler extension\n  with the standard-conforming equivalent. \u003c/li\u003e\n  \u003cli\u003e If you cannot fix them and the analysis logs state that they have a bad impact on the analysis results, Report them. \u003c/li\u003e\n  \u003cli\u003e If you cannot fix them and the analysis logs don’t state anything explicit about their impact, ignore them by resolving them as \"won’t fix\".\n  \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n// This example uses Microsoft extension /Zc:referenceBinding that allows binding r-value to l-value. Even though your compiler might allow it, our analyzer will flag it\n\nstruct S {\n...\n};\n\nvoid f(S\u0026amp;) {\n...\n}\n\nint main() {\n  f(S{}); // Noncompliant: no matching function for call to \u0027f\u0027\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n// Here we are showing how to fix the issue by replacing the code relying on a compiler extension by standard-conforming equivalent\n\nstruct S {\n...\n};\n\nvoid f(S\u0026amp;\u0026amp;) { // Using C++11 r-value reference fixes the issue\n...\n}\n\nint main() {\n  f(S{}); // Compliant\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "suspicious"
    ],
    "deprecatedKeys": [
      "cpp:ParsingError"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S3470",
    "name": "Standard namespaces should not be modified",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eIt may seem tidy to add your new declarations to the \u003ccode\u003estd\u003c/code\u003e or \u003ccode\u003eposix\u003c/code\u003e namespaces, but doing so results in undefined behavior.\nThe C++14 Standard, [namespace.std] (ISO/IEC 14882-2014 §17.6.4.2.1), paragraphs 1 and 2 states:\u003c/p\u003e\n\u003cblockquote\u003e\n  \u003col\u003e\n    \u003cli\u003e The behavior of a C++ program is undefined if it adds declarations or definitions to namespace std or to a namespace within namespace std\n    unless otherwise specified. A program may add a template specialization for any standard library template to namespace std only if the declaration\n    depends on a user-defined type and the specialization meets the standard library requirements for the original template and is not explicitly\n    prohibited. \u003c/li\u003e\n    \u003cli\u003e The behavior of a C++ program is undefined if it declares:\n      \u003cul\u003e\n        \u003cli\u003e an explicit specialization of any member function of a standard library class template, or \u003c/li\u003e\n        \u003cli\u003e an explicit specialization of any member function template of a standard library class or class template, or \u003c/li\u003e\n        \u003cli\u003e an explicit or partial specialization of any member class template of a standard library class or class template. \u003c/li\u003e\n      \u003c/ul\u003e  \u003c/li\u003e\n  \u003c/ol\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eIn addition to restricting extensions to the \u003ccode\u003estd\u003c/code\u003e namespace, the C++14 Standard goes on in §17.6.4.2.2 to say:\u003c/p\u003e\n\u003cblockquote\u003e\n  \u003col\u003e\n    \u003cli\u003e The behavior of a C++ program is undefined if it adds declarations or definitions to namespace posix or to a namespace within namespace posix\n    unless otherwise specified. The namespace posix is reserved for use by ISO/IEC 9945 and other POSIX standards. \u003c/li\u003e\n  \u003c/ol\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eYou may think that it’s legitimate to reopen \u003ccode\u003estd\u003c/code\u003e to define a version of extension points (\u003ccode\u003estd::swap\u003c/code\u003e,\n\u003ccode\u003estd::hash\u003c/code\u003e…​) that work with your types, but it’s not necessary: If you call these extension points according to the correct pattern (see\nfor instance S5963 for \u003ccode\u003eswap\u003c/code\u003e), user-defined version will be found too.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue for any modification of the standard \u003ccode\u003estd\u003c/code\u003e and \u003ccode\u003eposix\u003c/code\u003e namespaces.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nnamespace MyNamespace {\n  class MyType {/*...*/};\n}\nnamespace std { // Noncompliant\n  int x;\n  void swap(MyNamespace::MyType \u0026amp;m1, MyNamespace::MyType \u0026amp;m2);\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nnamespace expanded_std {\n  int x;\n}\nnamespace MyNamespace {\n  class MyType {/*...*/};\n  void swap(MyType \u0026amp;m1, MyType \u0026amp;m2); // See also S5963 to see how to properly call it\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eA namespace fragment that only contains template specializations or explicit instantiations is ignored by this rule.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/Xnw-BQ\"\u003eCERT, DCL58-CPP.\u003c/a\u003e - Do not modify the standard namespaces \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eIt may seem tidy to add your new declarations to the \u003ccode\u003estd\u003c/code\u003e or \u003ccode\u003eposix\u003c/code\u003e namespaces, but doing so results in undefined behavior.\nThe C++14 Standard, [namespace.std] (ISO/IEC 14882-2014 §17.6.4.2.1), paragraphs 1 and 2 states:\u003c/p\u003e\n\u003cblockquote\u003e\n  \u003col\u003e\n    \u003cli\u003e The behavior of a C++ program is undefined if it adds declarations or definitions to namespace std or to a namespace within namespace std\n    unless otherwise specified. A program may add a template specialization for any standard library template to namespace std only if the declaration\n    depends on a user-defined type and the specialization meets the standard library requirements for the original template and is not explicitly\n    prohibited. \u003c/li\u003e\n    \u003cli\u003e The behavior of a C++ program is undefined if it declares:\n      \u003cul\u003e\n        \u003cli\u003e an explicit specialization of any member function of a standard library class template, or \u003c/li\u003e\n        \u003cli\u003e an explicit specialization of any member function template of a standard library class or class template, or \u003c/li\u003e\n        \u003cli\u003e an explicit or partial specialization of any member class template of a standard library class or class template. \u003c/li\u003e\n      \u003c/ul\u003e  \u003c/li\u003e\n  \u003c/ol\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eIn addition to restricting extensions to the \u003ccode\u003estd\u003c/code\u003e namespace, the C++14 Standard goes on in §17.6.4.2.2 to say:\u003c/p\u003e\n\u003cblockquote\u003e\n  \u003col\u003e\n    \u003cli\u003e The behavior of a C++ program is undefined if it adds declarations or definitions to namespace posix or to a namespace within namespace posix\n    unless otherwise specified. The namespace posix is reserved for use by ISO/IEC 9945 and other POSIX standards. \u003c/li\u003e\n  \u003c/ol\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eYou may think that it’s legitimate to reopen \u003ccode\u003estd\u003c/code\u003e to define a version of extension points (\u003ccode\u003estd::swap\u003c/code\u003e,\n\u003ccode\u003estd::hash\u003c/code\u003e…​) that work with your types, but it’s not necessary: If you call these extension points according to the correct pattern (see\nfor instance S5963 for \u003ccode\u003eswap\u003c/code\u003e), user-defined version will be found too.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue for any modification of the standard \u003ccode\u003estd\u003c/code\u003e and \u003ccode\u003eposix\u003c/code\u003e namespaces.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nnamespace MyNamespace {\n  class MyType {/*...*/};\n}\nnamespace std { // Noncompliant\n  int x;\n  void swap(MyNamespace::MyType \u0026amp;m1, MyNamespace::MyType \u0026amp;m2);\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nnamespace expanded_std {\n  int x;\n}\nnamespace MyNamespace {\n  class MyType {/*...*/};\n  void swap(MyType \u0026amp;m1, MyType \u0026amp;m2); // See also S5963 to see how to properly call it\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eA namespace fragment that only contains template specializations or explicit instantiations is ignored by this rule.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/Xnw-BQ\"\u003eCERT, DCL58-CPP.\u003c/a\u003e - Do not modify the standard namespaces \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cert"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S3590",
    "name": "Stack allocated memory and non-owned memory should not be freed",
    "defaultSeverity": "BLOCKER",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003cp\u003eExplicitly releasing non-heap memory leads to undefined behavior.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003efree\u003c/code\u003e function and \u003ccode\u003edelete\u003c/code\u003e operator are used exclusively to release dynamically allocated memory. Attempting to release\nany other type of memory is \u003cem\u003eundefined behavior\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eThe following non-heap memory types may not be released:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Stack allocated memory - local variables or memory allocated with the \u003ccode\u003ealloca\u003c/code\u003e, \u003ccode\u003e_alloca\u003c/code\u003e, \u003ccode\u003e_malloca\u003c/code\u003e and\n  \u003ccode\u003e__builtin_alloca\u003c/code\u003e functions. \u003c/li\u003e\n  \u003cli\u003e Executable program code - function pointers. \u003c/li\u003e\n  \u003cli\u003e Program data - global and static variables. \u003c/li\u003e\n  \u003cli\u003e Read-only program data - constants and strings. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eWhat is the potential impact\u003c/h3\u003e\n\u003cp\u003eTrying to release non-heap memory using \u003ccode\u003efree\u003c/code\u003e or \u003ccode\u003edelete\u003c/code\u003e results in undefined behavior.\u003c/p\u003e\n\u003cp\u003eWhen a program comprises undefined behavior, the compiler no longer needs to adhere to the language standard, and the program has no meaning\nassigned to it.\u003c/p\u003e\n\u003cp\u003eThe application will usually just crash, but in the worst case, the application may appear to execute correctly, while losing data or producing\nincorrect results.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eRemove any calls to \u003ccode\u003efree\u003c/code\u003e or \u003ccode\u003edelete\u003c/code\u003e that aim at releasing non-heap memory.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003cp\u003eStack allocated memory:\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid fun(int size) {\n  int number \u003d 0;\n  char* name \u003d (char*)alloca(size);\n  // ...\n  delete \u0026amp;number; // Noncompliant: memory is stack-allocated.\n  free(name); // Noncompliant: memory is stack-allocated.\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid fun(int size) {\n  int number \u003d 0;\n  char* name \u003d (char*)alloca(size);\n  // ...\n  // Compliant: stack memory is automatically released at the end of the function.\n}\n\u003c/pre\u003e\n\u003cp\u003eExecutable program code:\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\nint getValue() {\n  return 10;\n}\n\nint main() {\n  // ...\n  free((void*) \u0026amp;getValue); // Noncompliant: memory is part of executable code.\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\nint getValue() {\n  return 10;\n}\n\nint main() {\n  // ...\n  // Compliant: program code will be released at the end of the program\u0027s execution.\n  return 0;\n}\n\u003c/pre\u003e\n\u003cp\u003eProgram data:\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"noncompliant\"\u003e\nstruct S {\n  static inline int data \u003d 64;\n};\n\nint main() {\n  static int x \u003d 8;\n  // ...\n  free(\u0026amp;x); // Noncompliant: memory part of the program\u0027s data.\n  free(\u0026amp;S::data); // Noncompliant: memory part of the program\u0027s data.\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"compliant\"\u003e\nstruct S {\n  static inline int data \u003d 64;\n};\n\nint main() {\n  static int x \u003d 8;\n  // ...\n  // Compliant: globals and static variables are released at the end of the program\u0027s execution.\n  return 0;\n}\n\u003c/pre\u003e\n\u003cp\u003eRead-only program data:\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"4\" data-diff-type\u003d\"noncompliant\"\u003e\nint const limit \u003d 128;\n\nint main() {\n  char* name \u003d \"string\";\n  // ...\n  free((void*)\u0026amp;limit); // Noncompliant: memory part of program\u0027s read-only data.\n  free(name); // Noncompliant: memory part of read-only program data.\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"4\" data-diff-type\u003d\"compliant\"\u003e\nint const limit \u003d 128;\n\nint main() {\n  char const* name \u003d \"string\";\n  // ...\n  // Compliant: read-only program data is freed at the end of the program\u0027s execution.\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch3\u003eGoing the extra mile\u003c/h3\u003e\n\u003cp\u003eThe accidental release of non-heap memory usually occurs in practice if the same pointer variable is used to once reference heap and once non-heap\nmemory. This may lead to confusion and should be avoided.\u003c/p\u003e\n\u003cp\u003eThese best practices help to avoid accidentally releasing non-heap memory:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e If accessing different memory types, use different pointer variables. \u003c/li\u003e\n  \u003cli\u003e When passing non-heap memory addresses to functions, ensure that the functions do not attempt to release the memory. \u003c/li\u003e\n  \u003cli\u003e If manually managing dynamic memory, release it in the same scope where it was acquired. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe following example shows a situation in which the same pointer variable is used to hold a stack or heap address. This leads to a situation in\nwhich heap memory is accidentally released.\u003c/p\u003e\n\u003cp\u003eNoncompliant code example\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"5\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid fun(int length) {\n  static char smallString[32];\n  char* usedString;\n\n  if (length \u0026lt; 31) {\n    usedString \u003d smallString; // Pointer to stack memory assigned here\n  } else {\n    usedString \u003d (char*)malloc(length + 1);\n  }\n  // ...\n  free(usedString); // Noncompliant: if length \u0026lt; 31, the freed memory will be located on the stack.\n}\n\u003c/pre\u003e\n\u003cp\u003eCompliant solution\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"5\" data-diff-type\u003d\"compliant\"\u003e\nvoid fun(int length) {\n  static char smallString[32];\n  char* stackOrHeapString;\n  char* heapString \u003d nullptr;\n\n  if (length \u0026lt; 31) {\n    stackOrHeapString \u003d smallString;\n  } else {\n    heapString \u003d (char*)malloc(length + 1);\n    stackOrHeapString \u003d heapString;\n  }\n  // ...\n  free(heapString); // Compliant: only the heap string will be freed if allocated.\n}\n\u003c/pre\u003e\n\u003cp\u003eThe following example shows a situation in which dynamically allocated memory is acquired and released in different functions. On top of this\nchain, a stack allocated buffer is introduced, leading to a call to \u003ccode\u003efree\u003c/code\u003e of stack memory.\u003c/p\u003e\n\u003cp\u003eNoncompliant code example\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"6\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid use(char* string) {\n  // ...\n  free(string); // Noncompliant: pointer\u0027s origin is unknown. If non-heap, the program will crash.\n}\n\nvoid fun(int length) {\n  static char smallString[32];\n  char* usedString;\n\n  if (length \u0026lt; 31) {\n    usedString \u003d smallString; // Pointer to stack memory assigned here\n  } else {\n    usedString \u003d (char*)malloc(length + 1);\n  }\n  use(usedString); // If length \u0026lt; 31, the unsafe memory will free memory located on the stack.\n}\n\u003c/pre\u003e\n\u003cp\u003eCompliant solution\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"6\" data-diff-type\u003d\"compliant\"\u003e\nvoid use(char* string) {\n  // ...\n  // Compliant: memory no longer freed in the called function\n}\n\nvoid fun(int length) {\n  static char smallString[32];\n  if (length \u0026lt; 31) {\n    use(smallString);\n  } else {\n    heapString \u003d (char*)malloc(length + 1);\n    use(heapString);\n    free(heapString); // Compliant: memory released in the scope it was acquired in.\n  }\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eExplicitly releasing non-heap memory leads to undefined behavior.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe \u003ccode\u003efree\u003c/code\u003e function and \u003ccode\u003edelete\u003c/code\u003e operator are used exclusively to release dynamically allocated memory. Attempting to release\nany other type of memory is \u003cem\u003eundefined behavior\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eThe following non-heap memory types may not be released:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Stack allocated memory - local variables or memory allocated with the \u003ccode\u003ealloca\u003c/code\u003e, \u003ccode\u003e_alloca\u003c/code\u003e, \u003ccode\u003e_malloca\u003c/code\u003e and\n  \u003ccode\u003e__builtin_alloca\u003c/code\u003e functions. \u003c/li\u003e\n  \u003cli\u003e Executable program code - function pointers. \u003c/li\u003e\n  \u003cli\u003e Program data - global and static variables. \u003c/li\u003e\n  \u003cli\u003e Read-only program data - constants and strings. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eWhat is the potential impact\u003c/h3\u003e\n\u003cp\u003eTrying to release non-heap memory using \u003ccode\u003efree\u003c/code\u003e or \u003ccode\u003edelete\u003c/code\u003e results in undefined behavior.\u003c/p\u003e\n\u003cp\u003eWhen a program comprises undefined behavior, the compiler no longer needs to adhere to the language standard, and the program has no meaning\nassigned to it.\u003c/p\u003e\n\u003cp\u003eThe application will usually just crash, but in the worst case, the application may appear to execute correctly, while losing data or producing\nincorrect results.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eRemove any calls to \u003ccode\u003efree\u003c/code\u003e or \u003ccode\u003edelete\u003c/code\u003e that aim at releasing non-heap memory.\u003c/p\u003e\n\n\u003cp\u003eStack allocated memory:\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid fun(int size) {\n  int number \u003d 0;\n  char* name \u003d (char*)alloca(size);\n  // ...\n  delete \u0026amp;number; // Noncompliant: memory is stack-allocated.\n  free(name); // Noncompliant: memory is stack-allocated.\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid fun(int size) {\n  int number \u003d 0;\n  char* name \u003d (char*)alloca(size);\n  // ...\n  // Compliant: stack memory is automatically released at the end of the function.\n}\n\u003c/pre\u003e\n\u003cp\u003eExecutable program code:\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\nint getValue() {\n  return 10;\n}\n\nint main() {\n  // ...\n  free((void*) \u0026amp;getValue); // Noncompliant: memory is part of executable code.\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\nint getValue() {\n  return 10;\n}\n\nint main() {\n  // ...\n  // Compliant: program code will be released at the end of the program\u0027s execution.\n  return 0;\n}\n\u003c/pre\u003e\n\u003cp\u003eProgram data:\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"noncompliant\"\u003e\nstruct S {\n  static inline int data \u003d 64;\n};\n\nint main() {\n  static int x \u003d 8;\n  // ...\n  free(\u0026amp;x); // Noncompliant: memory part of the program\u0027s data.\n  free(\u0026amp;S::data); // Noncompliant: memory part of the program\u0027s data.\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"compliant\"\u003e\nstruct S {\n  static inline int data \u003d 64;\n};\n\nint main() {\n  static int x \u003d 8;\n  // ...\n  // Compliant: globals and static variables are released at the end of the program\u0027s execution.\n  return 0;\n}\n\u003c/pre\u003e\n\u003cp\u003eRead-only program data:\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"4\" data-diff-type\u003d\"noncompliant\"\u003e\nint const limit \u003d 128;\n\nint main() {\n  char* name \u003d \"string\";\n  // ...\n  free((void*)\u0026amp;limit); // Noncompliant: memory part of program\u0027s read-only data.\n  free(name); // Noncompliant: memory part of read-only program data.\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"4\" data-diff-type\u003d\"compliant\"\u003e\nint const limit \u003d 128;\n\nint main() {\n  char const* name \u003d \"string\";\n  // ...\n  // Compliant: read-only program data is freed at the end of the program\u0027s execution.\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch3\u003eGoing the extra mile\u003c/h3\u003e\n\u003cp\u003eThe accidental release of non-heap memory usually occurs in practice if the same pointer variable is used to once reference heap and once non-heap\nmemory. This may lead to confusion and should be avoided.\u003c/p\u003e\n\u003cp\u003eThese best practices help to avoid accidentally releasing non-heap memory:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e If accessing different memory types, use different pointer variables. \u003c/li\u003e\n  \u003cli\u003e When passing non-heap memory addresses to functions, ensure that the functions do not attempt to release the memory. \u003c/li\u003e\n  \u003cli\u003e If manually managing dynamic memory, release it in the same scope where it was acquired. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe following example shows a situation in which the same pointer variable is used to hold a stack or heap address. This leads to a situation in\nwhich heap memory is accidentally released.\u003c/p\u003e\n\u003cp\u003eNoncompliant code example\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"5\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid fun(int length) {\n  static char smallString[32];\n  char* usedString;\n\n  if (length \u0026lt; 31) {\n    usedString \u003d smallString; // Pointer to stack memory assigned here\n  } else {\n    usedString \u003d (char*)malloc(length + 1);\n  }\n  // ...\n  free(usedString); // Noncompliant: if length \u0026lt; 31, the freed memory will be located on the stack.\n}\n\u003c/pre\u003e\n\u003cp\u003eCompliant solution\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"5\" data-diff-type\u003d\"compliant\"\u003e\nvoid fun(int length) {\n  static char smallString[32];\n  char* stackOrHeapString;\n  char* heapString \u003d nullptr;\n\n  if (length \u0026lt; 31) {\n    stackOrHeapString \u003d smallString;\n  } else {\n    heapString \u003d (char*)malloc(length + 1);\n    stackOrHeapString \u003d heapString;\n  }\n  // ...\n  free(heapString); // Compliant: only the heap string will be freed if allocated.\n}\n\u003c/pre\u003e\n\u003cp\u003eThe following example shows a situation in which dynamically allocated memory is acquired and released in different functions. On top of this\nchain, a stack allocated buffer is introduced, leading to a call to \u003ccode\u003efree\u003c/code\u003e of stack memory.\u003c/p\u003e\n\u003cp\u003eNoncompliant code example\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"6\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid use(char* string) {\n  // ...\n  free(string); // Noncompliant: pointer\u0027s origin is unknown. If non-heap, the program will crash.\n}\n\nvoid fun(int length) {\n  static char smallString[32];\n  char* usedString;\n\n  if (length \u0026lt; 31) {\n    usedString \u003d smallString; // Pointer to stack memory assigned here\n  } else {\n    usedString \u003d (char*)malloc(length + 1);\n  }\n  use(usedString); // If length \u0026lt; 31, the unsafe memory will free memory located on the stack.\n}\n\u003c/pre\u003e\n\u003cp\u003eCompliant solution\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"6\" data-diff-type\u003d\"compliant\"\u003e\nvoid use(char* string) {\n  // ...\n  // Compliant: memory no longer freed in the called function\n}\n\nvoid fun(int length) {\n  static char smallString[32];\n  if (length \u0026lt; 31) {\n    use(smallString);\n  } else {\n    heapString \u003d (char*)malloc(length + 1);\n    use(heapString);\n    free(heapString); // Compliant: memory released in the scope it was acquired in.\n  }\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "symbolic-execution",
      "unpredictable"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1051",
    "name": "C libraries should not be used",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe use of C headers and therefore C functions in a C++ program, is sometimes necessary, but should be avoided in favor of C++ headers and\nfunctions.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;string.h\u0026gt;\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;cstring\u0026gt;\n#include \u0026lt;string\u0026gt;\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 18-0-1 - The C library shall not be used. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe use of C headers and therefore C functions in a C++ program, is sometimes necessary, but should be avoided in favor of C++ headers and\nfunctions.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;string.h\u0026gt;\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;cstring\u0026gt;\n#include \u0026lt;string\u0026gt;\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 18-0-1 - The C library shall not be used. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "misra-c++2008"
    ],
    "deprecatedKeys": [
      "cpp:PPIncludeCHeader"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1172",
    "name": "Unused function parameters should be removed",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eA typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function’s\nbody. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to\nsuch parameters, the function’s behavior will be the same, but the programmer’s intention won’t be clearly expressed anymore. Therefore, removing\nfunction parameters that are not being utilized is considered best practice.\u003c/p\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThere are some cases when you want to have an unused parameter (usually because the function has to conform to a fixed prototype, or because it is\nvirtual, or it will be called from a template). In this case, and if the parameter is never used, an accepted practice is to leave it unnamed. If it\nis only sometimes used (for instance, depending on conditional compilation), you may, since C++17, use the \u003ccode\u003e[[maybe_unused]]\u003c/code\u003e attribute to\nbe explicit about it.\u003c/p\u003e\n\u003cpre\u003e\nvoid f([[maybe_unused]] int i) {\n  assert(i \u0026lt; 42); // In optimized mode, this assert will be removed, and \"i\" will be unused\n}\n\u003c/pre\u003e\n\u003cp\u003eIn case of Objective-C, it is acceptable to have unused parameters if the method is supposed to be overridden.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eHaving unused function parameters in your code can lead to confusion and misunderstanding of a developer’s intention. They reduce code readability\nand introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid doSomething(int a, int b) { // Noncompliant, \"b\" is unused\n  compute(a);\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid doSomething(int a) {\n  compute(a);\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 2.7 - There should be no unused parameters in functions \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/5dUxBQ\"\u003eCERT, MSC12-C.\u003c/a\u003e - Detect and remove code that has no effect or is never executed\n  \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f9-unused-parameters-should-be-unnamed\"\u003eF.9: Unused parameters\n  should be unnamed\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eA typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function’s\nbody. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to\nsuch parameters, the function’s behavior will be the same, but the programmer’s intention won’t be clearly expressed anymore. Therefore, removing\nfunction parameters that are not being utilized is considered best practice.\u003c/p\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThere are some cases when you want to have an unused parameter (usually because the function has to conform to a fixed prototype, or because it is\nvirtual, or it will be called from a template). In this case, and if the parameter is never used, an accepted practice is to leave it unnamed. If it\nis only sometimes used (for instance, depending on conditional compilation), you may, since C++17, use the \u003ccode\u003e[[maybe_unused]]\u003c/code\u003e attribute to\nbe explicit about it.\u003c/p\u003e\n\u003cpre\u003e\nvoid f([[maybe_unused]] int i) {\n  assert(i \u0026lt; 42); // In optimized mode, this assert will be removed, and \"i\" will be unused\n}\n\u003c/pre\u003e\n\u003cp\u003eIn case of Objective-C, it is acceptable to have unused parameters if the method is supposed to be overridden.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eHaving unused function parameters in your code can lead to confusion and misunderstanding of a developer’s intention. They reduce code readability\nand introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid doSomething(int a, int b) { // Noncompliant, \"b\" is unused\n  compute(a);\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid doSomething(int a) {\n  compute(a);\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 0-1-11 - There shall be no unused parameters (named or unnamed) in nonvirtual functions. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 2.7 - There should be no unused parameters in functions \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/5dUxBQ\"\u003eCERT, MSC12-C.\u003c/a\u003e - Detect and remove code that has no effect or is never executed\n  \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f9-unused-parameters-should-be-unnamed\"\u003eF.9: Unused parameters\n  should be unnamed\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "cert",
      "unused"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S3230",
    "name": "Member data should be initialized in-class or in a constructor initialization list",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThere are three ways to initialize a non-static data member in a class:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e With an in-class initializer (since C++11) \u003c/li\u003e\n  \u003cli\u003e In the initialization list of a constructor \u003c/li\u003e\n  \u003cli\u003e In the constructor body \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eYou should use those methods in that order of preference. When applicable, in-class initializers are best, because they apply automatically to all\nconstructors of the class (except for default copy/move constructors and constructors where an explicit initialization for this member is provided).\nBut they can only be used for initialization with constant values.\u003c/p\u003e\n\u003cp\u003eIf your member value depends on a parameter, you can initialize it in the constructor’s initialization list. If the initialization is complex, you\ncan define a function to compute the value, and use this function in the initializer list.\u003c/p\u003e\n\u003cp\u003eInitialization in the constructor body has several issues. First, it’s not an initialization, but an assignment. Which means it will not work with\nall data types (const-qualified members, members of reference type, member of a type without default constructor…​). And even if it works, the member\nwill first be initialized, then assigned to, which means useless operations will take place. To prevent \"use-before-set\" errors, it’s better to\nimmediately initialize the member with its real value.\u003c/p\u003e\n\u003cp\u003eIt’s hard to find a good example where setting the value of a member in the constructor would be appropriate. One case might be when you assign to\nseveral data members in one operation. As a consequence constructor bodies are empty in many situations.\u003c/p\u003e\n\u003cp\u003eThis rules raises an issue in two conditions:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e When you assign a value to a member variable in the body of a constructor. \u003c/li\u003e\n  \u003cli\u003e When you default-initialize in an initializer list a member variable, that would be value-initialized by default \u003c/li\u003e\n  \u003cli\u003e For C++11 or later, when you initialize a member variable in the initializer list of a constructor, but could have done so directly in the\n  class:\n    \u003cul\u003e\n      \u003cli\u003e The variable has either no in-class initializer, or an in-class initializer with the same value as in the constructor \u003c/li\u003e\n      \u003cli\u003e The initial value does not depend on a constructor parameter \u003c/li\u003e\n    \u003c/ul\u003e  \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass S {\n  int i1;\n  int i2;\n  int i3;\npublic:\n  S( int halfValue, int i2 \u003d 0) : i2(i2), i3(42) { // Noncompliant for i1 and i3, compliant for i2\n    this-\u0026gt;i1 \u003d 2*halfValue;\n  }\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nclass S {\n  int i1;\n  int i2;\n  int i3 \u003d 42; // In-class initializer\npublic:\n  S( int halfValue, int i2 \u003d 0 ) : i1(2*halfValue), i2(i2) {} // Compliant\n};\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c48-prefer-in-class-initializers-to-member-initializers-in-constructors-for-constant-initializers\"\u003eC.48: Prefer in-class initializers to member initializers in constructors for constant initializers\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c49-prefer-initialization-to-assignment-in-constructors\"\u003eC.49:\n  Prefer initialization to assignment in constructors\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThere are three ways to initialize a non-static data member in a class:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e With an in-class initializer (since C++11) \u003c/li\u003e\n  \u003cli\u003e In the initialization list of a constructor \u003c/li\u003e\n  \u003cli\u003e In the constructor body \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eYou should use those methods in that order of preference. When applicable, in-class initializers are best, because they apply automatically to all\nconstructors of the class (except for default copy/move constructors and constructors where an explicit initialization for this member is provided).\nBut they can only be used for initialization with constant values.\u003c/p\u003e\n\u003cp\u003eIf your member value depends on a parameter, you can initialize it in the constructor’s initialization list. If the initialization is complex, you\ncan define a function to compute the value, and use this function in the initializer list.\u003c/p\u003e\n\u003cp\u003eInitialization in the constructor body has several issues. First, it’s not an initialization, but an assignment. Which means it will not work with\nall data types (const-qualified members, members of reference type, member of a type without default constructor…​). And even if it works, the member\nwill first be initialized, then assigned to, which means useless operations will take place. To prevent \"use-before-set\" errors, it’s better to\nimmediately initialize the member with its real value.\u003c/p\u003e\n\u003cp\u003eIt’s hard to find a good example where setting the value of a member in the constructor would be appropriate. One case might be when you assign to\nseveral data members in one operation. As a consequence constructor bodies are empty in many situations.\u003c/p\u003e\n\u003cp\u003eThis rules raises an issue in two conditions:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e When you assign a value to a member variable in the body of a constructor. \u003c/li\u003e\n  \u003cli\u003e When you default-initialize in an initializer list a member variable, that would be value-initialized by default \u003c/li\u003e\n  \u003cli\u003e For C++11 or later, when you initialize a member variable in the initializer list of a constructor, but could have done so directly in the\n  class:\n    \u003cul\u003e\n      \u003cli\u003e The variable has either no in-class initializer, or an in-class initializer with the same value as in the constructor \u003c/li\u003e\n      \u003cli\u003e The initial value does not depend on a constructor parameter \u003c/li\u003e\n    \u003c/ul\u003e  \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass S {\n  int i1;\n  int i2;\n  int i3;\npublic:\n  S( int halfValue, int i2 \u003d 0) : i2(i2), i3(42) { // Noncompliant for i1 and i3, compliant for i2\n    this-\u0026gt;i1 \u003d 2*halfValue;\n  }\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nclass S {\n  int i1;\n  int i2;\n  int i3 \u003d 42; // In-class initializer\npublic:\n  S( int halfValue, int i2 \u003d 0 ) : i1(2*halfValue), i2(i2) {} // Compliant\n};\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c48-prefer-in-class-initializers-to-member-initializers-in-constructors-for-constant-initializers\"\u003eC.48: Prefer in-class initializers to member initializers in constructors for constant initializers\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c49-prefer-initialization-to-assignment-in-constructors\"\u003eC.49:\n  Prefer initialization to assignment in constructors\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cppcoreguidelines",
      "performance"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1052",
    "name": "\"\u003cctime\u003e\" should not be used",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eVarious aspects of \u003ccode\u003ectime\u003c/code\u003e are implementation-defined or unspecified, such as the formats of times.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;ctime\u0026gt;  /* Noncompliant */\n\nvoid f()\n{\n  clock();\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 18-0-4 - The time handling functions of library \u0026lt;ctime\u0026gt; shall not be used. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eVarious aspects of \u003ccode\u003ectime\u003c/code\u003e are implementation-defined or unspecified, such as the formats of times.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;ctime\u0026gt;  /* Noncompliant */\n\nvoid f()\n{\n  clock();\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 18-0-4 - The time handling functions of library \u0026lt;ctime\u0026gt; shall not be used. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "lock-in"
    ],
    "deprecatedKeys": [
      "cpp:PPIncludeCtime"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S3471",
    "name": "\"override\" or \"final\" should be used instead of \"virtual\"",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eIn a base class, \u003ccode\u003evirtual\u003c/code\u003e indicates that a function can be overridden. In a derived class, it indicates an override. But given the\nspecifier’s dual meaning, it would be clearer and more sound to use derived class-specific specifiers instead: \u003ccode\u003eoverride\u003c/code\u003e or\n\u003ccode\u003efinal\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\nclass Counter {\nprotected:\n  int c \u003d 0;\npublic:\n  virtual void count() {\n    c++;\n  }\n};\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nclass FastCounter: public Counter {\npublic:\n  virtual void count() {  // Noncompliant: ambiguous\n    c +\u003d 2;\n  }\n};\n\u003c/pre\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003eoverride\u003c/code\u003e indicates that a function is intended to override a base-class function. The compiler will issue a warning if this is not\n  the case. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nclass FastCounter: public Counter {\npublic:\n  void count() override {\n    c +\u003d 2;\n  }\n};\n\u003c/pre\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003efinal\u003c/code\u003e indicates a function \u003ccode\u003eoverride\u003c/code\u003e that cannot itself be overridden. The compiler will issue a warning if the\n  signature does not match the signature of a base-class \u003ccode\u003evirtual\u003c/code\u003e function. \u003ccode\u003eoverride\u003c/code\u003e is redundant when \u003ccode\u003efinal\u003c/code\u003e is\n  specified. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nclass FastCounter: public Counter {\npublic:\n  void count() final {\n    c +\u003d 2;\n  }\n};\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c128-virtual-functions-should-specify-exactly-one-of-virtual-override-or-final\"\u003eC.128: Virtual functions should specify exactly one of \u003ccode\u003evirtual\u003c/code\u003e, \u003ccode\u003eoverride\u003c/code\u003e, or \u003ccode\u003efinal\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S1016} - Virtual functions should be declared with the \"virtual\" keyword \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eIn a base class, \u003ccode\u003evirtual\u003c/code\u003e indicates that a function can be overridden. In a derived class, it indicates an override. But given the\nspecifier’s dual meaning, it would be clearer and more sound to use derived class-specific specifiers instead: \u003ccode\u003eoverride\u003c/code\u003e or\n\u003ccode\u003efinal\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\nclass Counter {\nprotected:\n  int c \u003d 0;\npublic:\n  virtual void count() {\n    c++;\n  }\n};\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nclass FastCounter: public Counter {\npublic:\n  virtual void count() {  // Noncompliant: ambiguous\n    c +\u003d 2;\n  }\n};\n\u003c/pre\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003eoverride\u003c/code\u003e indicates that a function is intended to override a base-class function. The compiler will issue a warning if this is not\n  the case. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nclass FastCounter: public Counter {\npublic:\n  void count() override {\n    c +\u003d 2;\n  }\n};\n\u003c/pre\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003efinal\u003c/code\u003e indicates a function \u003ccode\u003eoverride\u003c/code\u003e that cannot itself be overridden. The compiler will issue a warning if the\n  signature does not match the signature of a base-class \u003ccode\u003evirtual\u003c/code\u003e function. \u003ccode\u003eoverride\u003c/code\u003e is redundant when \u003ccode\u003efinal\u003c/code\u003e is\n  specified. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nclass FastCounter: public Counter {\npublic:\n  void count() final {\n    c +\u003d 2;\n  }\n};\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c128-virtual-functions-should-specify-exactly-one-of-virtual-override-or-final\"\u003eC.128: Virtual functions should specify exactly one of \u003ccode\u003evirtual\u003c/code\u003e, \u003ccode\u003eoverride\u003c/code\u003e, or \u003ccode\u003efinal\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S1016} - Virtual functions should be declared with the \"virtual\" keyword \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "api-design",
      "cppcoreguidelines",
      "since-c++11"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S946",
    "name": "The address of an automatic object should not be assigned to another object that may persist after the first object has ceased to exist",
    "defaultSeverity": "BLOCKER",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003cp\u003eThe address of an automatic object should not be persisted beyond the object’s lifetime.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eAn automatic object is an object whose lifetime is automatically managed. The storage for an automatic object, e.g. a local variable, is allocated\nat the beginning of the enclosing code block and is deallocated at the end. This is commonly referred to as \"allocated on the stack\".\u003c/p\u003e\n\u003cp\u003eIf the address of an automatic object is assigned to another automatic object of larger scope, a static or extern object, or if it is returned from\na function (using \u003ccode\u003ereturn\u003c/code\u003e or an output parameter), then there will be a point where the address will point to an object that ceased to\nexist. In that case, the address becomes invalid, and attempts to dereference the invalid address — trying to access the object that ceased to\nexist — result in undefined behavior.\u003c/p\u003e\n\u003cpre\u003e\nint *global \u003d nullptr;\n\nint* bar(int **out) {\n  int local \u003d 42;\n  int *ptr;\n  global \u003d \u0026amp;local; // Noncompliant: assigning the address of an object allocated on the stack to a global variable\n  {\n    int i \u003d 9001;\n    ptr \u003d \u0026amp;i; // Noncompliant: assigning the address of a stack-allocated object to an object that outlives it\n  }\n  *out \u003d \u0026amp;local; // Noncompliant: returning the address of an object allocated on the stack (via output parameter)\n  return \u0026amp;local; // Noncompliant: returning the address of an object allocated on the stack\n}\n\u003c/pre\u003e\n\u003ch2\u003eWhat is the potential impact?\u003c/h2\u003e\n\u003cp\u003ePersisting addresses of objects with automatic storage past their lifetime is dangerous as it creates invalid addresses. Attempts to access objects\nthat no longer exist through such invalid addresses result in undefined behavior.\u003c/p\u003e\n\u003cp\u003eFor programs that exercise undefined behavior, the compiler is no longer bound by the language specification. The application may crash or, even\nworse, the application may appear to execute correctly while losing data or producing incorrect results.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eThere are multiple approaches to avoid persisting addresses of objects with automatic storage after their lifetime ended:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Make a full copy of the object instead of using its address. \u003c/li\u003e\n  \u003cli\u003e Allocate the object on the heap (free-store) and deallocate it once done. \u003c/li\u003e\n  \u003cli\u003e Create the automatic object in a larger scope where it outlives all accesses through its address. \u003c/li\u003e\n  \u003cli\u003e Reduce the scope of objects that store the address of the original automatic object. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nint* bar(void) {\n  int local_auto \u003d 42;\n  return \u0026amp;local_auto; // Noncompliant: returns the address of a stack-allocated object\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nint foo() {\n  int local_auto \u003d 42;\n  return local_auto; // Compliant: returns a value rather than an address\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nint* foo() {\n  int *local_auto \u003d new int(42);\n  return local_auto; // Compliant: returns the address of a heap-allocated object\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\nconst char *str_ptr \u003d nullptr;\n\nvoid bar() {\n  const char str[] \u003d \"This will change\";\n  str_ptr \u003d str; // Noncompliant: address of `str` becomes invalid when `str` goes out of scope\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\nvoid bar() {\n  const char str[] \u003d \"This will change\";\n  const char *str_ptr \u003d str; // Compliant: `str_ptr` has the same storage duration as `str`\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;string\u0026gt;\n\nstd::string bar() {\n  std::string str \u003d \"This will change\";\n  return str; // Compliant: `str` will be moved to the caller (using C++ move semantics)\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;array\u0026gt;\n#include \u0026lt;cstddef\u0026gt;\n\nint *buz() {\n  int buf[256];\n  for (size_t i \u003d 0; i \u0026lt; std::size(buf); ++i) {\n    buf[i] \u003d i;\n  }\n  return buf; // Noncompliant: returns address of stack-allocated object\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;array\u0026gt;\n#include \u0026lt;cstddef\u0026gt;\n#include \u0026lt;numeric\u0026gt;\n\nvoid buz(int *buf, size_t length) {\n  std::iota(\u0026amp;buf[0], \u0026amp;buf[length], 0);\n}\n\nvoid caller() {\n  int buf[256];\n  buz(buf, std::size(buf));\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;array\u0026gt;\n\nstd::array\u0026lt;int, 3\u0026gt; buz() {\n  std::array\u0026lt;int, 3\u0026gt; buf \u003d {1, 2, 3};\n  return buf; // Compliant: `buf` will by copied to the caller; return-value optimization (RVO) might be invoked\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;numeric\u0026gt;\n#include \u0026lt;vector\u0026gt;\n\nstd::vector\u0026lt;int\u0026gt; buz() {\n  std::vector\u0026lt;int\u0026gt; buf;\n  std::iota(buf.begin(), buf.end(), 0);\n  return buf; // Compliant: `buf` will be moved to the caller (using C++ move semantics)\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"4\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;algorithm\u0026gt;\n#include \u0026lt;array\u0026gt;\n\nvoid fun(char **out) {\n  char buffer[64];\n  std::fill(std::begin(buffer), std::end(buffer), 42);\n  *out \u003d buffer; // Noncompliant: `buffer`\u0027s address becomes invalid once it goes out of scope\n}\n\nvoid caller() {\n  char *p;\n  fun(\u0026amp;p);\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"4\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;algorithm\u0026gt;\n#include \u0026lt;array\u0026gt;\n\nchar buffer[64];\n\nvoid fun(char **out) {\n  std::fill(std::begin(buffer), std::end(buffer), 42);\n  *out \u003d buffer; // Compliant: `buffer`\u0027s lifetime is the program\u0027s lifetime\n}\n\nvoid caller() {\n  char *p;\n  fun(\u0026amp;p);\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"4\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;vector\u0026gt;\n\nstd::vector\u0026lt;int\u0026gt; fun() {\n  std::vector\u0026lt;int\u0026gt; buf(/* count */ 64, /* initial value */ 42);\n  return buf;\n}\n\nvoid caller() {\n  auto buf \u003d fun();\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eConference presentations\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CppCon 2018 - \u003ca href\u003d\"https://www.youtube.com/watch?v\u003duQyT-5iWUow\u0026amp;ab_channel\u003dCppCon\"\u003eSurprises in Object Lifetime\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/UtcxBQ\"\u003eDCL30-C. Declare objects with appropriate storage durations\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/OXw-BQ\"\u003eEXP54-CPP. Do not access an object outside of its lifetime\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/6NUxBQ\"\u003eMSC00-C. Compile cleanly at high warning levels\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e MISRA C:2004, 17.6 - The address of an object with automatic storage shall not be assigned to another object that may persist after the first\n  object has ceased to exist \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 7-5-2 - The address of an object with automatic storage shall not be assigned to another object that may persist after the\n  first object has ceased to exist \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 18.6 - The address of an object with automatic storage shall not be copied to another object that persists after the first object\n  has ceased to exist \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e S837 detects attempts to return addresses of automatic variables \u003c/li\u003e\n  \u003cli\u003e S839 ensures that functions do not return references or pointers to parameters that are passed by reference \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eThe address of an automatic object should not be persisted beyond the object’s lifetime.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eAn automatic object is an object whose lifetime is automatically managed. The storage for an automatic object, e.g. a local variable, is allocated\nat the beginning of the enclosing code block and is deallocated at the end. This is commonly referred to as \"allocated on the stack\".\u003c/p\u003e\n\u003cp\u003eIf the address of an automatic object is assigned to another automatic object of larger scope, a static or extern object, or if it is returned from\na function (using \u003ccode\u003ereturn\u003c/code\u003e or an output parameter), then there will be a point where the address will point to an object that ceased to\nexist. In that case, the address becomes invalid, and attempts to dereference the invalid address — trying to access the object that ceased to\nexist — result in undefined behavior.\u003c/p\u003e\n\u003cpre\u003e\nint *global \u003d nullptr;\n\nint* bar(int **out) {\n  int local \u003d 42;\n  int *ptr;\n  global \u003d \u0026amp;local; // Noncompliant: assigning the address of an object allocated on the stack to a global variable\n  {\n    int i \u003d 9001;\n    ptr \u003d \u0026amp;i; // Noncompliant: assigning the address of a stack-allocated object to an object that outlives it\n  }\n  *out \u003d \u0026amp;local; // Noncompliant: returning the address of an object allocated on the stack (via output parameter)\n  return \u0026amp;local; // Noncompliant: returning the address of an object allocated on the stack\n}\n\u003c/pre\u003e\n\u003ch2\u003eWhat is the potential impact?\u003c/h2\u003e\n\u003cp\u003ePersisting addresses of objects with automatic storage past their lifetime is dangerous as it creates invalid addresses. Attempts to access objects\nthat no longer exist through such invalid addresses result in undefined behavior.\u003c/p\u003e\n\u003cp\u003eFor programs that exercise undefined behavior, the compiler is no longer bound by the language specification. The application may crash or, even\nworse, the application may appear to execute correctly while losing data or producing incorrect results.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eThere are multiple approaches to avoid persisting addresses of objects with automatic storage after their lifetime ended:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Make a full copy of the object instead of using its address. \u003c/li\u003e\n  \u003cli\u003e Allocate the object on the heap (free-store) and deallocate it once done. \u003c/li\u003e\n  \u003cli\u003e Create the automatic object in a larger scope where it outlives all accesses through its address. \u003c/li\u003e\n  \u003cli\u003e Reduce the scope of objects that store the address of the original automatic object. \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nint* bar(void) {\n  int local_auto \u003d 42;\n  return \u0026amp;local_auto; // Noncompliant: returns the address of a stack-allocated object\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nint foo() {\n  int local_auto \u003d 42;\n  return local_auto; // Compliant: returns a value rather than an address\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nint* foo() {\n  int *local_auto \u003d new int(42);\n  return local_auto; // Compliant: returns the address of a heap-allocated object\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\nconst char *str_ptr \u003d nullptr;\n\nvoid bar() {\n  const char str[] \u003d \"This will change\";\n  str_ptr \u003d str; // Noncompliant: address of `str` becomes invalid when `str` goes out of scope\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\nvoid bar() {\n  const char str[] \u003d \"This will change\";\n  const char *str_ptr \u003d str; // Compliant: `str_ptr` has the same storage duration as `str`\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;string\u0026gt;\n\nstd::string bar() {\n  std::string str \u003d \"This will change\";\n  return str; // Compliant: `str` will be moved to the caller (using C++ move semantics)\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;array\u0026gt;\n#include \u0026lt;cstddef\u0026gt;\n\nint *buz() {\n  int buf[256];\n  for (size_t i \u003d 0; i \u0026lt; std::size(buf); ++i) {\n    buf[i] \u003d i;\n  }\n  return buf; // Noncompliant: returns address of stack-allocated object\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;array\u0026gt;\n#include \u0026lt;cstddef\u0026gt;\n#include \u0026lt;numeric\u0026gt;\n\nvoid buz(int *buf, size_t length) {\n  std::iota(\u0026amp;buf[0], \u0026amp;buf[length], 0);\n}\n\nvoid caller() {\n  int buf[256];\n  buz(buf, std::size(buf));\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;array\u0026gt;\n\nstd::array\u0026lt;int, 3\u0026gt; buz() {\n  std::array\u0026lt;int, 3\u0026gt; buf \u003d {1, 2, 3};\n  return buf; // Compliant: `buf` will by copied to the caller; return-value optimization (RVO) might be invoked\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;numeric\u0026gt;\n#include \u0026lt;vector\u0026gt;\n\nstd::vector\u0026lt;int\u0026gt; buz() {\n  std::vector\u0026lt;int\u0026gt; buf;\n  std::iota(buf.begin(), buf.end(), 0);\n  return buf; // Compliant: `buf` will be moved to the caller (using C++ move semantics)\n}\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"4\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;algorithm\u0026gt;\n#include \u0026lt;array\u0026gt;\n\nvoid fun(char **out) {\n  char buffer[64];\n  std::fill(std::begin(buffer), std::end(buffer), 42);\n  *out \u003d buffer; // Noncompliant: `buffer`\u0027s address becomes invalid once it goes out of scope\n}\n\nvoid caller() {\n  char *p;\n  fun(\u0026amp;p);\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"4\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;algorithm\u0026gt;\n#include \u0026lt;array\u0026gt;\n\nchar buffer[64];\n\nvoid fun(char **out) {\n  std::fill(std::begin(buffer), std::end(buffer), 42);\n  *out \u003d buffer; // Compliant: `buffer`\u0027s lifetime is the program\u0027s lifetime\n}\n\nvoid caller() {\n  char *p;\n  fun(\u0026amp;p);\n}\n\u003c/pre\u003e\n\u003cpre data-diff-id\u003d\"4\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;vector\u0026gt;\n\nstd::vector\u0026lt;int\u0026gt; fun() {\n  std::vector\u0026lt;int\u0026gt; buf(/* count */ 64, /* initial value */ 42);\n  return buf;\n}\n\nvoid caller() {\n  auto buf \u003d fun();\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eConference presentations\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CppCon 2018 - \u003ca href\u003d\"https://www.youtube.com/watch?v\u003duQyT-5iWUow\u0026amp;ab_channel\u003dCppCon\"\u003eSurprises in Object Lifetime\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/UtcxBQ\"\u003eDCL30-C. Declare objects with appropriate storage durations\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/OXw-BQ\"\u003eEXP54-CPP. Do not access an object outside of its lifetime\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/6NUxBQ\"\u003eMSC00-C. Compile cleanly at high warning levels\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e MISRA C:2004, 17.6 - The address of an object with automatic storage shall not be assigned to another object that may persist after the first\n  object has ceased to exist \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 7-5-2 - The address of an object with automatic storage shall not be assigned to another object that may persist after the\n  first object has ceased to exist \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 18.6 - The address of an object with automatic storage shall not be copied to another object that persists after the first object\n  has ceased to exist \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e S837 detects attempts to return addresses of automatic variables \u003c/li\u003e\n  \u003cli\u003e S839 ensures that functions do not return references or pointers to parameters that are passed by reference \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "cert",
      "symbolic-execution"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5419",
    "name": "The order for arguments of the same type in a function call should be obvious",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "FOCUSED",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhen a function has several consecutive parameters of the same type, there is a risk that the arguments are not provided in the right order.\nMoreover, it is generally the sign of code which is too low-level. Maybe\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e the arguments should have a stronger type \u003c/li\u003e\n  \u003cli\u003e some arguments could be grouped together to form a higher level abstraction. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe use of two parameters of the same type is useful in situations like comparing arguments, combining arguments through a binary operation and\nswapping arguments but three or more arguments of the same type is considered bad practice.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when a function is defined with more than two consecutive parameters of the same type. For this rule, only the \"raw\" type\nof the parameter will be considered (a \u003ccode\u003estring const \u0026amp;\u003c/code\u003e will be considered the same type as a \u003ccode\u003estd::string\u003c/code\u003e).\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\ndouble acceleration(double initialSpeed, double finalSpeed, double deltaT) { // Noncompliant\n  return (finalSpeed - initialSpeed) / deltaT;\n}\ndouble dot_product(double x1, double y1, double x2, double y2); // Noncompliant\n\nvoid f() {\n  double x1,x2,y1,y2;\n  auto result \u003d dot_product(x1,x2,y1,y2);// The order is wrong, even if it might look logical\n  auto acc \u003d acceleration(10, 50, 110); // Very unclear, probably a bug...\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n// This code assumes the use of a strong type / units library\nAcceleration acceleration(Speed initialSpeed, Speed finalSpeed, Duration deltaT){\n  return (finalSpeed - initialSpeed) / deltaT;\n}\n\nstruct point {\n  double x;\n  double y;\n};\n\ndouble dot_product(point p1, point p2);\n\ndouble f() {\n  point p1,p2;\n  auto result \u003d dot_product(p1,p2);\n  auto acc \u003d acceleration(50 * km / hour, 110 * km / hour, 10s);\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#i4-make-interfaces-precisely-and-strongly-typed\"\u003eI.4: Make\n  interfaces precisely and strongly typed\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhen a function has several consecutive parameters of the same type, there is a risk that the arguments are not provided in the right order.\nMoreover, it is generally the sign of code which is too low-level. Maybe\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e the arguments should have a stronger type \u003c/li\u003e\n  \u003cli\u003e some arguments could be grouped together to form a higher level abstraction. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe use of two parameters of the same type is useful in situations like comparing arguments, combining arguments through a binary operation and\nswapping arguments but three or more arguments of the same type is considered bad practice.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when a function is defined with more than two consecutive parameters of the same type. For this rule, only the \"raw\" type\nof the parameter will be considered (a \u003ccode\u003estring const \u0026amp;\u003c/code\u003e will be considered the same type as a \u003ccode\u003estd::string\u003c/code\u003e).\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\ndouble acceleration(double initialSpeed, double finalSpeed, double deltaT) { // Noncompliant\n  return (finalSpeed - initialSpeed) / deltaT;\n}\ndouble dot_product(double x1, double y1, double x2, double y2); // Noncompliant\n\nvoid f() {\n  double x1,x2,y1,y2;\n  auto result \u003d dot_product(x1,x2,y1,y2);// The order is wrong, even if it might look logical\n  auto acc \u003d acceleration(10, 50, 110); // Very unclear, probably a bug...\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n// This code assumes the use of a strong type / units library\nAcceleration acceleration(Speed initialSpeed, Speed finalSpeed, Duration deltaT){\n  return (finalSpeed - initialSpeed) / deltaT;\n}\n\nstruct point {\n  double x;\n  double y;\n};\n\ndouble dot_product(point p1, point p2);\n\ndouble f() {\n  point p1,p2;\n  auto result \u003d dot_product(p1,p2);\n  auto acc \u003d acceleration(50 * km / hour, 110 * km / hour, 10s);\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#i4-make-interfaces-precisely-and-strongly-typed\"\u003eI.4: Make\n  interfaces precisely and strongly typed\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "bad-practice",
      "cppcoreguidelines",
      "pitfall",
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5417",
    "name": "\"std::move\" and \"std::forward\" should not be confused",
    "defaultSeverity": "BLOCKER",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003estd::forward\u003c/code\u003e and \u003ccode\u003estd::move\u003c/code\u003e have different purposes:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003estd::move\u003c/code\u003e takes an object and casts it as an \u003ccode\u003ervalue\u003c/code\u003e reference, which indicates that resources can be \"stolen\" from\n  this object. \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003estd::forward\u003c/code\u003e has a single use-case: to cast a templated function parameter of type \u003cem\u003eforwarding reference\u003c/em\u003e\n  (\u003ccode\u003eT\u0026amp;\u0026amp;\u003c/code\u003e) to the value category (\u003ccode\u003elvalue\u003c/code\u003e or \u003ccode\u003ervalue\u003c/code\u003e) the caller used to pass it. This allows\n  \u003ccode\u003ervalue\u003c/code\u003e arguments to be passed on as \u003ccode\u003ervalues\u003c/code\u003e, and \u003ccode\u003elvalues\u003c/code\u003e to be passed on as \u003ccode\u003elvalues\u003c/code\u003e. This scheme\n  is known as \u003cem\u003eperfect forwarding\u003c/em\u003e. Note that the standard states that \u003cem\u003e\"a forwarding reference is an rvalue reference to a cv-unqualified\n  template parameter that does NOT represent a template parameter of a class template\"\u003c/em\u003e. Refer to the last noncompliant code example. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSince both rvalue references and forwarding references use the same notation (\u003ccode\u003e\u0026amp;\u0026amp;\u003c/code\u003e), an unwary developer might confuse them. If\nthat happens, and a parameter is moved instead of forwarded, the original object can be emptied, probably crashing the software if the user tries to\nuse the original object normally after the function call. An error in the other direction has less dire consequences and might even work as intended\nif the right template argument is used, but the code would be clumsy and not clearly express the intent.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when \u003ccode\u003estd::forward\u003c/code\u003e is used with a parameter not passed as a forwarding reference or when\n\u003ccode\u003estd::move\u003c/code\u003e is used on a parameter passed as a forwarding reference.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;utility\u0026gt;\n\nclass S {};\n\ntemplate\u0026lt;typename T\u0026gt; void g(const T\u0026amp; t);\ntemplate\u0026lt;typename T\u0026gt; void g(T\u0026amp;\u0026amp; t);\n\ntemplate\u0026lt;typename T\u0026gt; void gt(T\u0026amp;\u0026amp; t) {\n  g(std::move(t)); // Noncompliant : std::move applied to a forwarding reference\n}\n\nvoid use_g() {\n  S s;\n  g(s);\n  g(std::forward\u0026lt;S\u0026gt;(s)); // Noncompliant : S isn\u0027t a forwarding reference.\n}\n\ntemplate \u0026lt;typename T\u0026gt;\nvoid foo(std::vector\u0026lt;T\u0026gt;\u0026amp;\u0026amp; t) {\n  std::forward\u0026lt;T\u0026gt;(t); // Noncompliant : std::vector\u0026lt;T\u0026gt;\u0026amp;\u0026amp; isn\u0027t a forwarding reference.\n}\n\ntemplate\u0026lt;typename T\u0026gt;\nstruct C {\n  // In class template argument deduction, template parameter of a class template is never a forwarding reference.\n  C(T\u0026amp;\u0026amp; t) {\n    g(std::forward\u0026lt;T\u0026gt;(t)); // Noncompliant : T\u0026amp;\u0026amp; isn\u0027t a forwarding reference. It is an r-value reference.\n  }\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;utility\u0026gt;\n\nclass S {};\n\ntemplate\u0026lt;typename T\u0026gt; void g(const T\u0026amp; t);\ntemplate\u0026lt;typename T\u0026gt; void g(T\u0026amp;\u0026amp; t);\n\ntemplate\u0026lt;typename T\u0026gt; void gt(T\u0026amp;\u0026amp; t) {\n  g(std::forward(t));\n}\n\nvoid use_g() {\n  S s;\n  g(s);\n  g(std::move(s));\n}\n\ntemplate \u0026lt;typename T\u0026gt;\nvoid (std::vector\u0026lt;T\u0026gt;\u0026amp;\u0026amp; t){\n  std::move(t);\n}\n\ntemplate\u0026lt;typename T\u0026gt;\nstruct C {\n  C(T\u0026amp;\u0026amp; t) {\n    g(std::move(t));\n  }\n};\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/utility/move\"\u003estd::move\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/utility/forward\"\u003estd::forward\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/reference#Forwarding_references\"\u003eForwarding references\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f18-for-will-move-from-parameters-pass-by-x-and-stdmove-the-parameter\"\u003eF.18: For \"will-move-from\" parameters, pass by \u003ccode\u003eX\u0026amp;\u0026amp;\u003c/code\u003e and \u003ccode\u003estd::move\u003c/code\u003e the parameter\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f19-for-forward-parameters-pass-by-tp-and-only-stdforward-the-parameter\"\u003eF.19: For \"forward\" parameters, pass by \u003ccode\u003eTP\u0026amp;\u0026amp;\u003c/code\u003e and only \u003ccode\u003estd::forward\u003c/code\u003e the parameter\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003ccode\u003estd::forward\u003c/code\u003e and \u003ccode\u003estd::move\u003c/code\u003e have different purposes:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003estd::move\u003c/code\u003e takes an object and casts it as an \u003ccode\u003ervalue\u003c/code\u003e reference, which indicates that resources can be \"stolen\" from\n  this object. \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003estd::forward\u003c/code\u003e has a single use-case: to cast a templated function parameter of type \u003cem\u003eforwarding reference\u003c/em\u003e\n  (\u003ccode\u003eT\u0026amp;\u0026amp;\u003c/code\u003e) to the value category (\u003ccode\u003elvalue\u003c/code\u003e or \u003ccode\u003ervalue\u003c/code\u003e) the caller used to pass it. This allows\n  \u003ccode\u003ervalue\u003c/code\u003e arguments to be passed on as \u003ccode\u003ervalues\u003c/code\u003e, and \u003ccode\u003elvalues\u003c/code\u003e to be passed on as \u003ccode\u003elvalues\u003c/code\u003e. This scheme\n  is known as \u003cem\u003eperfect forwarding\u003c/em\u003e. Note that the standard states that \u003cem\u003e\"a forwarding reference is an rvalue reference to a cv-unqualified\n  template parameter that does NOT represent a template parameter of a class template\"\u003c/em\u003e. Refer to the last noncompliant code example. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSince both rvalue references and forwarding references use the same notation (\u003ccode\u003e\u0026amp;\u0026amp;\u003c/code\u003e), an unwary developer might confuse them. If\nthat happens, and a parameter is moved instead of forwarded, the original object can be emptied, probably crashing the software if the user tries to\nuse the original object normally after the function call. An error in the other direction has less dire consequences and might even work as intended\nif the right template argument is used, but the code would be clumsy and not clearly express the intent.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when \u003ccode\u003estd::forward\u003c/code\u003e is used with a parameter not passed as a forwarding reference or when\n\u003ccode\u003estd::move\u003c/code\u003e is used on a parameter passed as a forwarding reference.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;utility\u0026gt;\n\nclass S {};\n\ntemplate\u0026lt;typename T\u0026gt; void g(const T\u0026amp; t);\ntemplate\u0026lt;typename T\u0026gt; void g(T\u0026amp;\u0026amp; t);\n\ntemplate\u0026lt;typename T\u0026gt; void gt(T\u0026amp;\u0026amp; t) {\n  g(std::move(t)); // Noncompliant : std::move applied to a forwarding reference\n}\n\nvoid use_g() {\n  S s;\n  g(s);\n  g(std::forward\u0026lt;S\u0026gt;(s)); // Noncompliant : S isn\u0027t a forwarding reference.\n}\n\ntemplate \u0026lt;typename T\u0026gt;\nvoid foo(std::vector\u0026lt;T\u0026gt;\u0026amp;\u0026amp; t) {\n  std::forward\u0026lt;T\u0026gt;(t); // Noncompliant : std::vector\u0026lt;T\u0026gt;\u0026amp;\u0026amp; isn\u0027t a forwarding reference.\n}\n\ntemplate\u0026lt;typename T\u0026gt;\nstruct C {\n  // In class template argument deduction, template parameter of a class template is never a forwarding reference.\n  C(T\u0026amp;\u0026amp; t) {\n    g(std::forward\u0026lt;T\u0026gt;(t)); // Noncompliant : T\u0026amp;\u0026amp; isn\u0027t a forwarding reference. It is an r-value reference.\n  }\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;utility\u0026gt;\n\nclass S {};\n\ntemplate\u0026lt;typename T\u0026gt; void g(const T\u0026amp; t);\ntemplate\u0026lt;typename T\u0026gt; void g(T\u0026amp;\u0026amp; t);\n\ntemplate\u0026lt;typename T\u0026gt; void gt(T\u0026amp;\u0026amp; t) {\n  g(std::forward(t));\n}\n\nvoid use_g() {\n  S s;\n  g(s);\n  g(std::move(s));\n}\n\ntemplate \u0026lt;typename T\u0026gt;\nvoid (std::vector\u0026lt;T\u0026gt;\u0026amp;\u0026amp; t){\n  std::move(t);\n}\n\ntemplate\u0026lt;typename T\u0026gt;\nstruct C {\n  C(T\u0026amp;\u0026amp; t) {\n    g(std::move(t));\n  }\n};\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/utility/move\"\u003estd::move\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/utility/forward\"\u003estd::forward\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/reference#Forwarding_references\"\u003eForwarding references\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f18-for-will-move-from-parameters-pass-by-x-and-stdmove-the-parameter\"\u003eF.18: For \"will-move-from\" parameters, pass by \u003ccode\u003eX\u0026amp;\u0026amp;\u003c/code\u003e and \u003ccode\u003estd::move\u003c/code\u003e the parameter\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f19-for-forward-parameters-pass-by-tp-and-only-stdforward-the-parameter\"\u003eF.19: For \"forward\" parameters, pass by \u003ccode\u003eTP\u0026amp;\u0026amp;\u003c/code\u003e and only \u003ccode\u003estd::forward\u003c/code\u003e the parameter\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cppcoreguidelines",
      "since-c++11",
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S6621",
    "name": "\"constexpr\" literal operators should be \"consteval\".",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eC++20 introduces the \u003ccode\u003econsteval\u003c/code\u003e keyword, which enforces that a function is always evaluated at compile time.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003econstexpr\u003c/code\u003e functions can produce a compile-time constant in some contexts and when called with appropriate arguments, but they can also\nbe invoked at run-time. \u003ccode\u003econsteval\u003c/code\u003e functions must always be evaluated at compile-time. If that cannot happen, a compilation error will\noccur.\u003c/p\u003e\n\u003cp\u003eUser-defined literal operators are designed to be called with constant operands known at compile time. Therefore, if these are intended to be\nevaluated at compile time with \u003ccode\u003econstexpr\u003c/code\u003e, \u003ccode\u003econsteval\u003c/code\u003e should be used instead to enforce compile time evaluation. This\nguarantees that no code is evaluated at run-time, and also enables error detection at compile-time.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nconstexpr unsigned char operator \"\"_u8(unsigned long long value) {\n  if (value \u0026gt;\u003d 256u) { throw std::overflow_error(\"Overflow on literal\"); }\n  return static_cast\u0026lt;unsigned char\u0026gt;(value);\n}\n\nvoid f() {\n  auto const a \u003d 128_u8; // evaluated at compile time\n  auto const b \u003d 512_u8; // evaluated at runtime, throws when evaluated\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nconsteval unsigned char operator \"\"_u8(unsigned long long value) {\n  if (value \u0026gt;\u003d 256u) { throw std::overflow_error(\"Overflow on literal\"); }\n  return static_cast\u0026lt;unsigned char\u0026gt;(value);\n}\n\nvoid f() {\n  auto const a \u003d 128_u8; // evaluated at compile time\n  auto const b \u003d 512_u8; // compilation error, the bug is detected\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eC++20 introduces the \u003ccode\u003econsteval\u003c/code\u003e keyword, which enforces that a function is always evaluated at compile time.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003econstexpr\u003c/code\u003e functions can produce a compile-time constant in some contexts and when called with appropriate arguments, but they can also\nbe invoked at run-time. \u003ccode\u003econsteval\u003c/code\u003e functions must always be evaluated at compile-time. If that cannot happen, a compilation error will\noccur.\u003c/p\u003e\n\u003cp\u003eUser-defined literal operators are designed to be called with constant operands known at compile time. Therefore, if these are intended to be\nevaluated at compile time with \u003ccode\u003econstexpr\u003c/code\u003e, \u003ccode\u003econsteval\u003c/code\u003e should be used instead to enforce compile time evaluation. This\nguarantees that no code is evaluated at run-time, and also enables error detection at compile-time.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nconstexpr unsigned char operator \"\"_u8(unsigned long long value) {\n  if (value \u0026gt;\u003d 256u) { throw std::overflow_error(\"Overflow on literal\"); }\n  return static_cast\u0026lt;unsigned char\u0026gt;(value);\n}\n\nvoid f() {\n  auto const a \u003d 128_u8; // evaluated at compile time\n  auto const b \u003d 512_u8; // evaluated at runtime, throws when evaluated\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nconsteval unsigned char operator \"\"_u8(unsigned long long value) {\n  if (value \u0026gt;\u003d 256u) { throw std::overflow_error(\"Overflow on literal\"); }\n  return static_cast\u0026lt;unsigned char\u0026gt;(value);\n}\n\nvoid f() {\n  auto const a \u003d 128_u8; // evaluated at compile time\n  auto const b \u003d 512_u8; // compilation error, the bug is detected\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "since-c++20"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S3231",
    "name": "Forward declarations should not be redundant",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eRedundant forward declarations simply clutter the code, and like any duplications, should be removed.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstruct S {\n  // ...\n};\n// ...\nstruct S;  // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstruct S {\n  // ...\n};\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eRedundant forward declarations simply clutter the code, and like any duplications, should be removed.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstruct S {\n  // ...\n};\n// ...\nstruct S;  // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstruct S {\n  // ...\n};\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "redundant",
      "unused"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1055",
    "name": "\"\u003ccstdio\u003e\" should not be used",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThis includes file and I/O functions \u003ccode\u003efgetpos\u003c/code\u003e, \u003ccode\u003efopen\u003c/code\u003e, \u003ccode\u003eftell\u003c/code\u003e, \u003ccode\u003egets\u003c/code\u003e, \u003ccode\u003eperror\u003c/code\u003e,\n\u003ccode\u003eremove\u003c/code\u003e, \u003ccode\u003erename\u003c/code\u003e, etc.\u003c/p\u003e\n\u003cp\u003eStreams and file I/O have a large number of unspecified, undefined and implementation-defined behaviors associated with them.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;cstdio\u0026gt;  /* Noncompliant */\n\nvoid fn()\n{\n  char_t array[10];\n  gets(array);           /* Can lead to buffer over-run */\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 27-0-1 - The stream input/output library \u003cem\u003e\u0026lt;cstdio\u0026gt;\u003c/em\u003e shall not be used. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThis includes file and I/O functions \u003ccode\u003efgetpos\u003c/code\u003e, \u003ccode\u003efopen\u003c/code\u003e, \u003ccode\u003eftell\u003c/code\u003e, \u003ccode\u003egets\u003c/code\u003e, \u003ccode\u003eperror\u003c/code\u003e,\n\u003ccode\u003eremove\u003c/code\u003e, \u003ccode\u003erename\u003c/code\u003e, etc.\u003c/p\u003e\n\u003cp\u003eStreams and file I/O have a large number of unspecified, undefined and implementation-defined behaviors associated with them.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;cstdio\u0026gt;  /* Noncompliant */\n\nvoid fn()\n{\n  char_t array[10];\n  gets(array);           /* Can lead to buffer over-run */\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 27-0-1 - The stream input/output library \u003cem\u003e\u0026lt;cstdio\u0026gt;\u003c/em\u003e shall not be used. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "lock-in"
    ],
    "deprecatedKeys": [
      "cpp:PPIncludeCstdio"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S2387",
    "name": "Child class fields should not shadow parent class fields",
    "defaultSeverity": "BLOCKER",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eHaving a variable with the same name in two unrelated classes is fine, but do the same thing within a class hierarchy and you’ll get confusion at\nbest, chaos at worst.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass Fruit {\n  protected:\n    Season ripe;\n    static Color flesh;\n\n  // ...\n};\n\nclass Raspberry : public Fruit {\n  private:\n    bool ripe;  // Noncompliant\n    static Color FLESH; // Noncompliant\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nclass Fruit {\n  protected:\n    Season ripe;\n    static Color flesh;\n\n  // ...\n};\n\nclass Raspberry : public Fruit {\n  private:\n    bool ripened;\n    static Color FLESH_COLOR;\n\n};\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThis rule ignores same-name fields that are \u003ccode\u003estatic\u003c/code\u003e in both the parent and child classes. This rule ignores \u003ccode\u003eprivate\u003c/code\u003e parent\nclass fields, but in all other such cases, the child class field should be renamed.\u003c/p\u003e\n\u003cpre\u003e\nclass Fruit {\n  private:\n    Season ripe;\n  // ...\n};\n\nclass Raspberry : public Fruit {\n  private:\n    Season ripe;  // Compliant as parent field \u0027ripe\u0027 is anyway not visible from Raspberry\n  // ...\n};\n\u003c/pre\u003e\n\u003cp\u003eor\u003c/p\u003e\n\u003cpre\u003e\nclass Fruit {\n  public:\n    Season ripe;\n  // ...\n};\n\nclass RedFruit : private Fruit {\n};\n\nclass Raspberry : public RedFruit { // RedFruit inherits from Fruit privately\n  private:\n    Season ripe;  // Compliant as parent field \u0027ripe\u0027 is anyway not visible from Raspberry\n  // ...\n};\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es12-do-not-reuse-names-in-nested-scopes\"\u003eES.12: Do not reuse\n  names in nested scopes\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eHaving a variable with the same name in two unrelated classes is fine, but do the same thing within a class hierarchy and you’ll get confusion at\nbest, chaos at worst.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass Fruit {\n  protected:\n    Season ripe;\n    static Color flesh;\n\n  // ...\n};\n\nclass Raspberry : public Fruit {\n  private:\n    bool ripe;  // Noncompliant\n    static Color FLESH; // Noncompliant\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nclass Fruit {\n  protected:\n    Season ripe;\n    static Color flesh;\n\n  // ...\n};\n\nclass Raspberry : public Fruit {\n  private:\n    bool ripened;\n    static Color FLESH_COLOR;\n\n};\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThis rule ignores same-name fields that are \u003ccode\u003estatic\u003c/code\u003e in both the parent and child classes. This rule ignores \u003ccode\u003eprivate\u003c/code\u003e parent\nclass fields, but in all other such cases, the child class field should be renamed.\u003c/p\u003e\n\u003cpre\u003e\nclass Fruit {\n  private:\n    Season ripe;\n  // ...\n};\n\nclass Raspberry : public Fruit {\n  private:\n    Season ripe;  // Compliant as parent field \u0027ripe\u0027 is anyway not visible from Raspberry\n  // ...\n};\n\u003c/pre\u003e\n\u003cp\u003eor\u003c/p\u003e\n\u003cpre\u003e\nclass Fruit {\n  public:\n    Season ripe;\n  // ...\n};\n\nclass RedFruit : private Fruit {\n};\n\nclass Raspberry : public RedFruit { // RedFruit inherits from Fruit privately\n  private:\n    Season ripe;  // Compliant as parent field \u0027ripe\u0027 is anyway not visible from Raspberry\n  // ...\n};\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es12-do-not-reuse-names-in-nested-scopes\"\u003eES.12: Do not reuse\n  names in nested scopes\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "confusing",
      "cppcoreguidelines"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5415",
    "name": "\"std::move\" should only be used where moving can happen",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhen calling \u003ccode\u003estd::move\u003c/code\u003e on an object, we usually expect the resulting operation to be fast, using move semantic to rip data off the\nsource object. If, despite the call to \u003ccode\u003estd::move\u003c/code\u003e, the source object ends up being copied, the code might be unexpectedly slow.\u003c/p\u003e\n\u003cp\u003eThis can happen:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e When \u003ccode\u003estd::move\u003c/code\u003e is called on an object which does not provide a specific move constructor and will resort to copying when requested\n  to move. \u003c/li\u003e\n  \u003cli\u003e When calling \u003ccode\u003estd::move\u003c/code\u003e with a const argument. \u003c/li\u003e\n  \u003cli\u003e When passing the result of \u003ccode\u003estd::move\u003c/code\u003e as a const reference argument. In this case, no object will be moved since it’s impossible to\n  call the move constructor from within the function. \u003ccode\u003estd::move\u003c/code\u003e should only be used when the argument is passed by value or by r-value\n  reference. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstruct MoveWillCopy{\n  MoveWillCopy() \u003d default;\n  // This user-provided copy constructor prevents the automatic generation of a move constructor\n  MoveWillCopy(NonMovable\u0026amp;) \u003d default;\n  Data d;\n};\n\nvoid f(MoveWillCopy m);\nvoid f(std::string s);\nvoid g(const std::string \u0026amp;s);\n\nvoid test() {\n  MoveWillCopy m;\n  f(std::move(m)); // Noncompliant: std::move is useless on objects like m: Any attempt to move it will copy it\n\n  const std::string constS\u003d\"***\";\n  f(std::move(constS)); // Noncompliant: constS will not be moved\n\n  std::string s\u003d\"****\";\n  g(std::move(s)); // Noncompliant: s is cast back to const l-value reference. g cannot move from it\n\n\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstruct Movable{\n  Movable() \u003d default;\n  // A move constructor is generated by default\n  Data d;\n};\n\nvoid f(Movable m);\nvoid f(std::string s);\nvoid g(const std::string \u0026amp;s);\n\nvoid test() {\n  Movables m;\n  f(std::move(m)); // Compliant: move constructor is available\n\n  std::string s\u003d\"****\";\n  f(std::move(s)); // Compliant:  move constructor is called\n\n  g(s); // Compliant: no misleading std::move is used\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es56-write-stdmove-only-when-you-need-to-explicitly-move-an-object-to-another-scope\"\u003eES.56: Write \u003ccode\u003estd::move()\u003c/code\u003e only when you need to explicitly move an object to another scope\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhen calling \u003ccode\u003estd::move\u003c/code\u003e on an object, we usually expect the resulting operation to be fast, using move semantic to rip data off the\nsource object. If, despite the call to \u003ccode\u003estd::move\u003c/code\u003e, the source object ends up being copied, the code might be unexpectedly slow.\u003c/p\u003e\n\u003cp\u003eThis can happen:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e When \u003ccode\u003estd::move\u003c/code\u003e is called on an object which does not provide a specific move constructor and will resort to copying when requested\n  to move. \u003c/li\u003e\n  \u003cli\u003e When calling \u003ccode\u003estd::move\u003c/code\u003e with a const argument. \u003c/li\u003e\n  \u003cli\u003e When passing the result of \u003ccode\u003estd::move\u003c/code\u003e as a const reference argument. In this case, no object will be moved since it’s impossible to\n  call the move constructor from within the function. \u003ccode\u003estd::move\u003c/code\u003e should only be used when the argument is passed by value or by r-value\n  reference. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstruct MoveWillCopy{\n  MoveWillCopy() \u003d default;\n  // This user-provided copy constructor prevents the automatic generation of a move constructor\n  MoveWillCopy(NonMovable\u0026amp;) \u003d default;\n  Data d;\n};\n\nvoid f(MoveWillCopy m);\nvoid f(std::string s);\nvoid g(const std::string \u0026amp;s);\n\nvoid test() {\n  MoveWillCopy m;\n  f(std::move(m)); // Noncompliant: std::move is useless on objects like m: Any attempt to move it will copy it\n\n  const std::string constS\u003d\"***\";\n  f(std::move(constS)); // Noncompliant: constS will not be moved\n\n  std::string s\u003d\"****\";\n  g(std::move(s)); // Noncompliant: s is cast back to const l-value reference. g cannot move from it\n\n\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstruct Movable{\n  Movable() \u003d default;\n  // A move constructor is generated by default\n  Data d;\n};\n\nvoid f(Movable m);\nvoid f(std::string s);\nvoid g(const std::string \u0026amp;s);\n\nvoid test() {\n  Movables m;\n  f(std::move(m)); // Compliant: move constructor is available\n\n  std::string s\u003d\"****\";\n  f(std::move(s)); // Compliant:  move constructor is called\n\n  g(s); // Compliant: no misleading std::move is used\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es56-write-stdmove-only-when-you-need-to-explicitly-move-an-object-to-another-scope\"\u003eES.56: Write \u003ccode\u003estd::move()\u003c/code\u003e only when you need to explicitly move an object to another scope\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "bad-practice",
      "confusing",
      "cppcoreguidelines",
      "since-c++11",
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5416",
    "name": "\"using\" should be preferred for type aliasing",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eSince C++11, type aliases can be declared via \u003ccode\u003eusing\u003c/code\u003e or \u003ccode\u003etypedef\u003c/code\u003e. \u003ccode\u003eusing\u003c/code\u003e should be preferred as more readable\nbecause you see the new name/alias first.\u003c/p\u003e\n\u003cp\u003eIn addition, \u003ccode\u003eusing\u003c/code\u003e can be templated, which makes it applicable to more situations than \u003ccode\u003etypedef\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\ntypedef void (*FunctionPointerType)(int);\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nusing FunctionPointerType \u003d void (*)(int);\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#t43-prefer-using-over-typedef-for-defining-aliases\"\u003eT.43: Prefer\n  \u003ccode\u003eusing\u003c/code\u003e over \u003ccode\u003etypedef\u003c/code\u003e for defining aliases\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eSince C++11, type aliases can be declared via \u003ccode\u003eusing\u003c/code\u003e or \u003ccode\u003etypedef\u003c/code\u003e. \u003ccode\u003eusing\u003c/code\u003e should be preferred as more readable\nbecause you see the new name/alias first.\u003c/p\u003e\n\u003cp\u003eIn addition, \u003ccode\u003eusing\u003c/code\u003e can be templated, which makes it applicable to more situations than \u003ccode\u003etypedef\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\ntypedef void (*FunctionPointerType)(int);\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nusing FunctionPointerType \u003d void (*)(int);\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#t43-prefer-using-over-typedef-for-defining-aliases\"\u003eT.43: Prefer\n  \u003ccode\u003eusing\u003c/code\u003e over \u003ccode\u003etypedef\u003c/code\u003e for defining aliases\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cppcoreguidelines",
      "design",
      "since-c++11"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5658",
    "name": "Relational and subtraction operators should not be used with pointers to different arrays",
    "defaultSeverity": "CRITICAL",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eAttempting to make a comparison between pointers using \u0026gt;, \u0026gt;\u003d, \u0026lt; or \u0026lt;\u003d will produce undefined behavior if the two pointers point to\ndifferent arrays.\u003c/p\u003e\n\u003cp\u003eAdditionally, directly comparing two arrays for equality or inequality has been deprecated in C++.\u003c/p\u003e\n\u003cp\u003eHowever, equality or inequality between an array and a pointer is still valid\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid f1 ( )\n{\n  int a1[ 10 ];\n  int a2[ 10 ];\n  int * p1 \u003d a1;\n  if ( p1 \u0026lt; a2 ) // Non-compliant, p1 and a2 point to different arrays.\n  {\n  }\n  if ( p1 - a2 \u0026gt; 0 ) // Non-compliant, p1 and a2 point to different arrays.\n  {\n  }\n  if ( a1 \u003d\u003d a2) // Non-compliant (in C++). Comparing different array for equality is deprecated\n  {\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid f1 ( )\n{\n  int a1[ 10 ];\n  int * p1 \u003d a1;\n  if ( p1 \u0026lt; a1 ) // Compliant, p1 and a1 point to the same array.\n  {\n  }\n  if ( p1 - a1 \u0026gt; 0 )  // Compliant, p1 and a1 point to the same array.\n  {\n  }\n  if ( p1 \u003d\u003d a2 ) // Compliant, comparing a pointer and an array for equality is valid\n  {\n  }\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 17.3 - \u0026gt;, \u0026gt;\u003d, \u0026lt;, \u0026lt;\u003d shall not be applied to pointer types except where they point to the same array. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 5-0-18 - \u0026gt;, \u0026gt;\u003d, \u0026lt;, \u0026lt;\u003d shall not be applied to objects of pointer type, except where they point to the same array.\n  \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es62-dont-compare-pointers-into-different-arrays\"\u003eES.62: Don’t\n  compare pointers into different arrays\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eAttempting to make a comparison between pointers using \u0026gt;, \u0026gt;\u003d, \u0026lt; or \u0026lt;\u003d will produce undefined behavior if the two pointers point to\ndifferent arrays.\u003c/p\u003e\n\u003cp\u003eAdditionally, directly comparing two arrays for equality or inequality has been deprecated in C++.\u003c/p\u003e\n\u003cp\u003eHowever, equality or inequality between an array and a pointer is still valid\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid f1 ( )\n{\n  int a1[ 10 ];\n  int a2[ 10 ];\n  int * p1 \u003d a1;\n  if ( p1 \u0026lt; a2 ) // Non-compliant, p1 and a2 point to different arrays.\n  {\n  }\n  if ( p1 - a2 \u0026gt; 0 ) // Non-compliant, p1 and a2 point to different arrays.\n  {\n  }\n  if ( a1 \u003d\u003d a2) // Non-compliant (in C++). Comparing different array for equality is deprecated\n  {\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid f1 ( )\n{\n  int a1[ 10 ];\n  int * p1 \u003d a1;\n  if ( p1 \u0026lt; a1 ) // Compliant, p1 and a1 point to the same array.\n  {\n  }\n  if ( p1 - a1 \u0026gt; 0 )  // Compliant, p1 and a1 point to the same array.\n  {\n  }\n  if ( p1 \u003d\u003d a2 ) // Compliant, comparing a pointer and an array for equality is valid\n  {\n  }\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 17.3 - \u0026gt;, \u0026gt;\u003d, \u0026lt;, \u0026lt;\u003d shall not be applied to pointer types except where they point to the same array. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 5-0-18 - \u0026gt;, \u0026gt;\u003d, \u0026lt;, \u0026lt;\u003d shall not be applied to objects of pointer type, except where they point to the same array.\n  \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es62-dont-compare-pointers-into-different-arrays\"\u003eES.62: Don’t\n  compare pointers into different arrays\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "cppcoreguidelines"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S3358",
    "name": "Conditional operators should not be nested",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eNested ternaries are hard to read and can make the order of operations complex to understand.\u003c/p\u003e\n\u003cpre\u003e\nint max(int p1, int p2, int p3) {\n  return p1 \u0026gt; p2 ? (p1 \u0026gt; p3 ? p1 : p3) : (p2 \u0026gt; p3 ? p2 : p3); // Noncompliant\n}\n\u003c/pre\u003e\n\u003cp\u003eInstead, use another line to express the nested operation in a separate statement.\u003c/p\u003e\n\u003cpre\u003e\nint max(int p1, int p2, int p3) {\n  if (p1 \u0026gt; p2) {\n    return p1 \u0026gt; p3 ? p1 : p3;\n  } else {\n    return p2 \u0026gt; p3 ? p2 : p3;\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eIn C++11, the rule ignores ternary operators inside \u003ccode\u003econstexpr\u003c/code\u003e functions.\u003c/p\u003e\n\u003cp\u003eIndeed, in C++11, such functions are limited to just a return statement, so using a ternary operator might be required. Later standards lifted this\nrestriction, so this exception does not apply to them.\u003c/p\u003e\n\u003cpre\u003e\nconstexpr int max(int p1, int p2, int p3) {\n  return p1 \u0026gt; p2 ? (p1 \u0026gt; p3 ? p1 : p3) : (p2 \u0026gt; p3 ? p2 : p3); // Compliant by exception in C++11\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eNested ternaries are hard to read and can make the order of operations complex to understand.\u003c/p\u003e\n\u003cpre\u003e\nint max(int p1, int p2, int p3) {\n  return p1 \u0026gt; p2 ? (p1 \u0026gt; p3 ? p1 : p3) : (p2 \u0026gt; p3 ? p2 : p3); // Noncompliant\n}\n\u003c/pre\u003e\n\u003cp\u003eInstead, use another line to express the nested operation in a separate statement.\u003c/p\u003e\n\u003cpre\u003e\nint max(int p1, int p2, int p3) {\n  if (p1 \u0026gt; p2) {\n    return p1 \u0026gt; p3 ? p1 : p3;\n  } else {\n    return p2 \u0026gt; p3 ? p2 : p3;\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eIn C++11, the rule ignores ternary operators inside \u003ccode\u003econstexpr\u003c/code\u003e functions.\u003c/p\u003e\n\u003cp\u003eIndeed, in C++11, such functions are limited to just a return statement, so using a ternary operator might be required. Later standards lifted this\nrestriction, so this exception does not apply to them.\u003c/p\u003e\n\u003cpre\u003e\nconstexpr int max(int p1, int p2, int p3) {\n  return p1 \u0026gt; p2 ? (p1 \u0026gt; p3 ? p1 : p3) : (p2 \u0026gt; p3 ? p2 : p3); // Compliant by exception in C++11\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "confusing"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5414",
    "name": "Classes should not contain both public and private data members",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "MODULAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eMixing (non-const) \u003ccode\u003epublic\u003c/code\u003e and \u003ccode\u003eprivate\u003c/code\u003e data members is a bad practice because it confuses the intention of the class:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e If the class is a collection of loosely related values, all the data members should be \u003ccode\u003epublic\u003c/code\u003e. \u003c/li\u003e\n  \u003cli\u003e On the other hand, if the class is trying to maintain an invariant, all the data members should be \u003ccode\u003eprivate\u003c/code\u003e. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIf we mix data members with different levels of accessibility, we lose clarity as to the purpose of the class.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass MyClass { // Noncompliant\npublic:\n  int firstNumber1() const { return firstNumber; }\n  void setFirstNumber(int firstNumber) { this-\u0026gt;firstNumber \u003d firstNumber; }\n  int secondNumber \u003d 2;\nprivate:\n  int firstNumber \u003d 1;\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nclass MyClass { // Depending on the case, the solution might be different. Here, since this class does not enforce any invariant, we make all the data members public\npublic:\n  int firstNumber;\n  int secondNumber;\n};\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eSince \u003ccode\u003econst\u003c/code\u003e data members cannot be modified, it’s not breaking encapsulation to make a const value public, even in a class that\nenforces an invariant.\u003c/p\u003e\n\u003cpre\u003e\nclass MyClass { // Compliant by exception\npublic:\n  const int constNumber \u003d 0; // const data members are fine\nprivate:\n  int number \u003d 1;\n};\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Wikipedia - \u003ca href\u003d\"https://en.wikipedia.org/wiki/Class_invariant\"\u003eClass invariant\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c134-ensure-all-non-const-data-members-have-the-same-access-level\"\u003eC.134: Ensure all non-\u003ccode\u003econst\u003c/code\u003e data members have the same access level\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c9-minimize-exposure-of-members\"\u003eC.9: Minimize exposure of\n  members\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eMixing (non-const) \u003ccode\u003epublic\u003c/code\u003e and \u003ccode\u003eprivate\u003c/code\u003e data members is a bad practice because it confuses the intention of the class:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e If the class is a collection of loosely related values, all the data members should be \u003ccode\u003epublic\u003c/code\u003e. \u003c/li\u003e\n  \u003cli\u003e On the other hand, if the class is trying to maintain an invariant, all the data members should be \u003ccode\u003eprivate\u003c/code\u003e. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIf we mix data members with different levels of accessibility, we lose clarity as to the purpose of the class.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass MyClass { // Noncompliant\npublic:\n  int firstNumber1() const { return firstNumber; }\n  void setFirstNumber(int firstNumber) { this-\u0026gt;firstNumber \u003d firstNumber; }\n  int secondNumber \u003d 2;\nprivate:\n  int firstNumber \u003d 1;\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nclass MyClass { // Depending on the case, the solution might be different. Here, since this class does not enforce any invariant, we make all the data members public\npublic:\n  int firstNumber;\n  int secondNumber;\n};\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eSince \u003ccode\u003econst\u003c/code\u003e data members cannot be modified, it’s not breaking encapsulation to make a const value public, even in a class that\nenforces an invariant.\u003c/p\u003e\n\u003cpre\u003e\nclass MyClass { // Compliant by exception\npublic:\n  const int constNumber \u003d 0; // const data members are fine\nprivate:\n  int number \u003d 1;\n};\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Wikipedia - \u003ca href\u003d\"https://en.wikipedia.org/wiki/Class_invariant\"\u003eClass invariant\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c134-ensure-all-non-const-data-members-have-the-same-access-level\"\u003eC.134: Ensure all non-\u003ccode\u003econst\u003c/code\u003e data members have the same access level\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c9-minimize-exposure-of-members\"\u003eC.9: Minimize exposure of\n  members\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "bad-practice",
      "cppcoreguidelines",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S856",
    "name": "Pointer conversions should be restricted to a safe subset",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eCasting an object pointer can very easily lead to undefined behavior. Only a few cases are supported, for instance casting an object pointer to a\nlarge enough integral type (and back again), casting an object pointer to a pointer to void (and back again)…​ Using a pointer cast to access an\nobject as if it was of another type than its real type is not supported in general.\u003c/p\u003e\n\u003cp\u003eThis rule detects casts between object pointers and incompatible types.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstruct S1 *p1;\nstruct S2;\nvoid f ()\n{\n  (float) p1; // Noncompliant, conversion to floating point type\n  (int *) p1; // Noncompliant\n  float f;\n  int *i \u003d (int *)\u0026amp;f; // Noncompliant, undefined behavior even if sizeof(int) \u003d\u003d sizeof(float)\n  (int) p1; // Compliant, but might be undefined behavior if \u0027int\u0027 is not large enough to hold the value of p1.\n  (void *) p1; // Compliant, conversion to \u0027void *\u0027\n  (struct S2 *)p1; // Noncompliant, conversion to another type.\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eIn C, it is allowed to cast an object pointer to a character pointer to access the byte representation of the object. This rule ignores this\ncase.\u003c/p\u003e\n\u003cp\u003eAnything can be safely cast to \u003ccode\u003evoid\u003c/code\u003e (since nothing can be done with a result of this cast), and doing so is a common pattern to\nsilence compiler warnings about unused variables. This rule ignores such casts.\u003c/p\u003e\n\u003cpre\u003e\nvoid f(int *p) {\n  (void)p;\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 11.2 - Conversions shall not be performed between a pointer to object and any type other than an integral type, another pointer\n  to object type or a pointer to void. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 11.3 - A cast shall not be performed between a pointer to object type and a pointer to a different object type. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eCasting an object pointer can very easily lead to undefined behavior. Only a few cases are supported, for instance casting an object pointer to a\nlarge enough integral type (and back again), casting an object pointer to a pointer to void (and back again)…​ Using a pointer cast to access an\nobject as if it was of another type than its real type is not supported in general.\u003c/p\u003e\n\u003cp\u003eThis rule detects casts between object pointers and incompatible types.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstruct S1 *p1;\nstruct S2;\nvoid f ()\n{\n  (float) p1; // Noncompliant, conversion to floating point type\n  (int *) p1; // Noncompliant\n  float f;\n  int *i \u003d (int *)\u0026amp;f; // Noncompliant, undefined behavior even if sizeof(int) \u003d\u003d sizeof(float)\n  (int) p1; // Compliant, but might be undefined behavior if \u0027int\u0027 is not large enough to hold the value of p1.\n  (void *) p1; // Compliant, conversion to \u0027void *\u0027\n  (struct S2 *)p1; // Noncompliant, conversion to another type.\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eIn C, it is allowed to cast an object pointer to a character pointer to access the byte representation of the object. This rule ignores this\ncase.\u003c/p\u003e\n\u003cp\u003eAnything can be safely cast to \u003ccode\u003evoid\u003c/code\u003e (since nothing can be done with a result of this cast), and doing so is a common pattern to\nsilence compiler warnings about unused variables. This rule ignores such casts.\u003c/p\u003e\n\u003cpre\u003e\nvoid f(int *p) {\n  (void)p;\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 11.2 - Conversions shall not be performed between a pointer to object and any type other than an integral type, another pointer\n  to object type or a pointer to void. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 11.3 - A cast shall not be performed between a pointer to object type and a pointer to a different object type. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "based-on-misra"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S977",
    "name": "Lines starting with \"#\" should contain valid preprocessing directives",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003ePreprocessing directives (lines that start with \u003ccode\u003e#\u003c/code\u003e) can be used to conditionally include or exclude code from compilation. Malformed\npreprocessing directives could lead to the exclusion or inclusion of more code than was intended. Therefore all preprocessing directives should be\nsyntactically meaningful.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#define AAA 2\n...\nint foo(void)\n{\n  int x \u003d 0;\n  ...\n\n#ifndef AAA\n  x \u003d 1;\n#else1  /* Noncompliant */\n  x \u003d AAA;\n#endif\n\n  ...\n  return x;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#define AAA 2\n...\nint foo(void)\n{\n  int x \u003d 0;\n  ...\n\n#ifndef AAA\n  x \u003d 1;\n#else\n  x \u003d AAA;\n#endif\n\n  ...\n  return x;\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 19.16 - Preprocessing directives shall be syntactically meaningful even when excluded by preprocessor. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 16-0-8 - If the # token appears as the first token on a line, then it shall be immediately followed by a preprocessing token.\n  \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 20.13 - A line whose first token is # shall be a valid preprocessing directive \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003ePreprocessing directives (lines that start with \u003ccode\u003e#\u003c/code\u003e) can be used to conditionally include or exclude code from compilation. Malformed\npreprocessing directives could lead to the exclusion or inclusion of more code than was intended. Therefore all preprocessing directives should be\nsyntactically meaningful.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#define AAA 2\n...\nint foo(void)\n{\n  int x \u003d 0;\n  ...\n\n#ifndef AAA\n  x \u003d 1;\n#else1  /* Noncompliant */\n  x \u003d AAA;\n#endif\n\n  ...\n  return x;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#define AAA 2\n...\nint foo(void)\n{\n  int x \u003d 0;\n  ...\n\n#ifndef AAA\n  x \u003d 1;\n#else\n  x \u003d AAA;\n#endif\n\n  ...\n  return x;\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 19.16 - Preprocessing directives shall be syntactically meaningful even when excluded by preprocessor. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 16-0-8 - If the # token appears as the first token on a line, then it shall be immediately followed by a preprocessing token.\n  \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 20.13 - A line whose first token is # shall be a valid preprocessing directive \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "preprocessor"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S978",
    "name": "Reserved identifiers and functions in the C standard library should not be defined or declared",
    "defaultSeverity": "BLOCKER",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eDefining or declaring identifiers with reserved names may lead to undefined behavior. Similarly, defining macros, variables or functions/methods\nwith the same names as functions from the C standard library is likely to lead to unexpected results.\u003c/p\u003e\n\u003cp\u003eAdditionally, such identifiers have the potential to thoroughly confuse people who are unfamiliar with the code base, possibly leading them to\nintroduce additional errors. Therefore reserved words and the names of C standard library functions should not be used as identifiers.\u003c/p\u003e\n\u003cp\u003eThis rule applies to:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003edefined\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e C standard library function names \u003c/li\u003e\n  \u003cli\u003e identifiers that contain two consecutive underscores \u003c/li\u003e\n  \u003cli\u003e identifiers that begin with an underscore, followed by an uppercase letter \u003c/li\u003e\n  \u003cli\u003e identifiers in the global namespace that start with an underscore \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#ifndef _MY_FILE\n#define _MY_FILE   // Noncompliant: starts with \u0027_\u0027\n\n#define FIELD__VAL(field) ##field // Noncompliant: contains \"__\"\n\nint free(void *pArg, int len) {  // Noncompliant: free is a standard function\n  int __i; // Noncompliant: starts with \"__\"\n  //...\n}\n#endif\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#ifndef MY_FILE\n#define MY_FILE\n\n#define FIELD_VAL(field) ##field\n\nint clean(void *pArg, int len) {\n  int i;\n  //...\n}\n#endif\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 20.1 - Reserved identifiers, macros and functions in the standard library, shall not be defined redefined or undefined. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 17-0-1 - Reserved identifiers, macros and functions in the standard library shall not be defined, redefined, or undefined.\n  \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 21.2 - A reserved identifier or macro name shall not be declared \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/tNYxBQ\"\u003eCERT, DCL37-C.\u003c/a\u003e - Do not declare or define a reserved identifier \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/Q30-BQ\"\u003eCERT, DCL51-CPP.\u003c/a\u003e - Do not declare or define a reserved identifier \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eDefining or declaring identifiers with reserved names may lead to undefined behavior. Similarly, defining macros, variables or functions/methods\nwith the same names as functions from the C standard library is likely to lead to unexpected results.\u003c/p\u003e\n\u003cp\u003eAdditionally, such identifiers have the potential to thoroughly confuse people who are unfamiliar with the code base, possibly leading them to\nintroduce additional errors. Therefore reserved words and the names of C standard library functions should not be used as identifiers.\u003c/p\u003e\n\u003cp\u003eThis rule applies to:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003edefined\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e C standard library function names \u003c/li\u003e\n  \u003cli\u003e identifiers that contain two consecutive underscores \u003c/li\u003e\n  \u003cli\u003e identifiers that begin with an underscore, followed by an uppercase letter \u003c/li\u003e\n  \u003cli\u003e identifiers in the global namespace that start with an underscore \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#ifndef _MY_FILE\n#define _MY_FILE   // Noncompliant: starts with \u0027_\u0027\n\n#define FIELD__VAL(field) ##field // Noncompliant: contains \"__\"\n\nint free(void *pArg, int len) {  // Noncompliant: free is a standard function\n  int __i; // Noncompliant: starts with \"__\"\n  //...\n}\n#endif\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#ifndef MY_FILE\n#define MY_FILE\n\n#define FIELD_VAL(field) ##field\n\nint clean(void *pArg, int len) {\n  int i;\n  //...\n}\n#endif\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 20.1 - Reserved identifiers, macros and functions in the standard library, shall not be defined redefined or undefined. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 17-0-1 - Reserved identifiers, macros and functions in the standard library shall not be defined, redefined, or undefined.\n  \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 21.2 - A reserved identifier or macro name shall not be declared \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/tNYxBQ\"\u003eCERT, DCL37-C.\u003c/a\u003e - Do not declare or define a reserved identifier \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/Q30-BQ\"\u003eCERT, DCL51-CPP.\u003c/a\u003e - Do not declare or define a reserved identifier \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "bad-practice",
      "based-on-misra",
      "cert"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S854",
    "name": "Constants of unsigned type should have a \"U\" suffix",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe type of an integer is dependent on a complex combination of factors including:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The magnitude of the constant; \u003c/li\u003e\n  \u003cli\u003e The implemented sizes of the integer types; \u003c/li\u003e\n  \u003cli\u003e The presence of any suffixes; \u003c/li\u003e\n  \u003cli\u003e The number base in which the value is expressed (i.e. decimal, octal or hexadecimal). \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eFor example, the value 0x8000 is of type \u003ccode\u003eunsigned int\u003c/code\u003e in a 16-bit environment, but of type (\u003ccode\u003esigned\u003c/code\u003e) \u003ccode\u003eint\u003c/code\u003e in a\n32-bit environment.\u003c/p\u003e\n\u003cp\u003eNote:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Any value with a \"U\" suffix is of unsigned type; \u003c/li\u003e\n  \u003cli\u003e An unsuffixed decimal value less than 2^31 is of signed type. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eBut:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e An unsuffixed hexadecimal value greater than or equal to 2^15 may be of signed or unsigned type; \u003c/li\u003e\n  \u003cli\u003e For C90, an unsuffixed decimal value greater than or equal to 2^31 may be of signed or unsigned type. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn C++, if an overload set includes candidates for an \u003ccode\u003eunsigned int\u003c/code\u003e and an \u003ccode\u003eint\u003c/code\u003e, then the overload that would be matched by\n0x8000 is therefore dependent on the implemented integer size. Adding a \"U\" suffix to the value specifies that it is unsigned.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 10.6 - A \"U\" suffix shall be applied to all constants of unsigned type. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 2-13-3 - A \"U\" suffix shall be applied to all octal or hexadecimal integer literals of unsigned type. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 7.2 - A \"u\" or \"U\" suffix shall be applied to all integer constants that are represented in an unsigned type. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe type of an integer is dependent on a complex combination of factors including:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The magnitude of the constant; \u003c/li\u003e\n  \u003cli\u003e The implemented sizes of the integer types; \u003c/li\u003e\n  \u003cli\u003e The presence of any suffixes; \u003c/li\u003e\n  \u003cli\u003e The number base in which the value is expressed (i.e. decimal, octal or hexadecimal). \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eFor example, the value 0x8000 is of type \u003ccode\u003eunsigned int\u003c/code\u003e in a 16-bit environment, but of type (\u003ccode\u003esigned\u003c/code\u003e) \u003ccode\u003eint\u003c/code\u003e in a\n32-bit environment.\u003c/p\u003e\n\u003cp\u003eNote:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Any value with a \"U\" suffix is of unsigned type; \u003c/li\u003e\n  \u003cli\u003e An unsuffixed decimal value less than 2^31 is of signed type. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eBut:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e An unsuffixed hexadecimal value greater than or equal to 2^15 may be of signed or unsigned type; \u003c/li\u003e\n  \u003cli\u003e For C90, an unsuffixed decimal value greater than or equal to 2^31 may be of signed or unsigned type. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn C++, if an overload set includes candidates for an \u003ccode\u003eunsigned int\u003c/code\u003e and an \u003ccode\u003eint\u003c/code\u003e, then the overload that would be matched by\n0x8000 is therefore dependent on the implemented integer size. Adding a \"U\" suffix to the value specifies that it is unsigned.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 10.6 - A \"U\" suffix shall be applied to all constants of unsigned type. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 2-13-3 - A \"U\" suffix shall be applied to all octal or hexadecimal integer literals of unsigned type. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 7.2 - A \"u\" or \"U\" suffix shall be applied to all integer constants that are represented in an unsigned type. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S855",
    "name": "Function pointers should not be converted to any other type",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eConversion of a function pointer to a different type of pointer results in undefined behaviour. This means, for example, that a pointer to a\nfunction cannot be converted to a pointer to a different type of function.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint f(int a)\n{\n  float (*p)(float) \u003d (float (*)(float)) \u0026amp; f; // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 11.1 - Conversions shall not be performed between a pointer to a function and any type other than an integral type. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 5-2-6 - A cast shall not convert a pointer to a function to any other pointer type, including a pointer to function type. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 11.1 - Conversions shall not be performed between a pointer to a function and any other type \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eConversion of a function pointer to a different type of pointer results in undefined behaviour. This means, for example, that a pointer to a\nfunction cannot be converted to a pointer to a different type of function.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint f(int a)\n{\n  float (*p)(float) \u003d (float (*)(float)) \u0026amp; f; // Noncompliant\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 11.1 - Conversions shall not be performed between a pointer to a function and any type other than an integral type. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 5-2-6 - A cast shall not convert a pointer to a function to any other pointer type, including a pointer to function type. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 11.1 - Conversions shall not be performed between a pointer to a function and any other type \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "based-on-misra"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S853",
    "name": "Results of ~ and \u003c\u003c operations on operands of underlying types unsigned char and unsigned short should immediately be cast to the operand\u0027s underlying type",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhen \u003ccode\u003e~\u003c/code\u003e and \u003ccode\u003e\u0026lt;\u0026lt;\u003c/code\u003e are applied to small integer types (\u003ccode\u003eunsigned char\u003c/code\u003e or \u003ccode\u003eunsigned short\u003c/code\u003e), the\noperations are preceded by integral promotion, and the result may contain high-order bits which have not been anticipated.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nunsigned char port \u003d 0x5aU;\nunsigned char result_8;\nunsigned short result_16;\nunsigned short mode;\nresult_8 \u003d (~port) \u0026gt;\u0026gt; 4; // Noncompliant; \u0027~port\u0027 is 0xFFA5 on a 16-bit machine but 0xFFFFFFA5 on a 32-bit machine. Result is 0xFA for both, but 0x0A may have been expected.\nresult_16 \u003d ((port \u0026lt;\u0026lt; 4) \u0026amp; mode) \u0026gt;\u0026gt; 6; // Noncompliant; result_16 value depends on the implemented size of an int.\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nresult_8 \u003d ((unsigned char)(~port)) \u0026gt;\u0026gt; 4; // Compliant\nresult_16 \u003d ((unsigned short)((unsigned short) port \u0026lt;\u0026lt; 4) \u0026amp; mode) \u0026gt;\u0026gt; 6; // Compliant\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C 2004, 10.5 - If the bitwise operators ~ and \u0026lt;\u0026lt; are applied to an operand of \u003cem\u003eunderlying type\u003c/em\u003e unsigned char or unsigned\n  short, the result shall be immediately cast to the \u003cem\u003eunderlying type\u003c/em\u003e of the operand. \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2008, 5-0-10 - If the bitwise operators ~ and \u0026lt;\u0026lt; are applied to an operand with an \u003cem\u003eunderlying type\u003c/em\u003e of unsigned char or\n  unsigned short, the result shall be immediately cast to the \u003cem\u003eunderlying type\u003c/em\u003e of the operand. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhen \u003ccode\u003e~\u003c/code\u003e and \u003ccode\u003e\u0026lt;\u0026lt;\u003c/code\u003e are applied to small integer types (\u003ccode\u003eunsigned char\u003c/code\u003e or \u003ccode\u003eunsigned short\u003c/code\u003e), the\noperations are preceded by integral promotion, and the result may contain high-order bits which have not been anticipated.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nunsigned char port \u003d 0x5aU;\nunsigned char result_8;\nunsigned short result_16;\nunsigned short mode;\nresult_8 \u003d (~port) \u0026gt;\u0026gt; 4; // Noncompliant; \u0027~port\u0027 is 0xFFA5 on a 16-bit machine but 0xFFFFFFA5 on a 32-bit machine. Result is 0xFA for both, but 0x0A may have been expected.\nresult_16 \u003d ((port \u0026lt;\u0026lt; 4) \u0026amp; mode) \u0026gt;\u0026gt; 6; // Noncompliant; result_16 value depends on the implemented size of an int.\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nresult_8 \u003d ((unsigned char)(~port)) \u0026gt;\u0026gt; 4; // Compliant\nresult_16 \u003d ((unsigned short)((unsigned short) port \u0026lt;\u0026lt; 4) \u0026amp; mode) \u0026gt;\u0026gt; 6; // Compliant\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C 2004, 10.5 - If the bitwise operators ~ and \u0026lt;\u0026lt; are applied to an operand of \u003cem\u003eunderlying type\u003c/em\u003e unsigned char or unsigned\n  short, the result shall be immediately cast to the \u003cem\u003eunderlying type\u003c/em\u003e of the operand. \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2008, 5-0-10 - If the bitwise operators ~ and \u0026lt;\u0026lt; are applied to an operand with an \u003cem\u003eunderlying type\u003c/em\u003e of unsigned char or\n  unsigned short, the result shall be immediately cast to the \u003cem\u003eunderlying type\u003c/em\u003e of the operand. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "based-on-misra"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1481",
    "name": "Unused local variables should be removed",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eAn unused local variable is a variable that has been declared but is not used anywhere in the block of code where it is defined. It is dead code,\ncontributing to unnecessary complexity and leading to confusion when reading the code. Therefore, it should be removed from your code to maintain\nclarity and efficiency.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eHaving unused local variables in your code can lead to several issues:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Decreased Readability: Unused variables can make your code more difficult to read. They add extra lines and complexity, which can distract from\n  the main logic of the code. \u003c/li\u003e\n  \u003cli\u003e Misunderstanding: When other developers read your code, they may wonder why a variable is declared but not used. This can lead to confusion and\n  misinterpretation of the code’s intent. \u003c/li\u003e\n  \u003cli\u003e Potential for Bugs: If a variable is declared but not used, it might indicate a bug or incomplete code. For example, if you declared a variable\n  intending to use it in a calculation, but then forgot to do so, your program might not work as expected. \u003c/li\u003e\n  \u003cli\u003e Maintenance Issues: Unused variables can make code maintenance more difficult. If a programmer sees an unused variable, they might think it is\n  a mistake and try to \u0027fix\u0027 the code, potentially introducing new bugs. \u003c/li\u003e\n  \u003cli\u003e Memory Usage: Although modern compilers are smart enough to ignore unused variables, not all compilers do this. In such cases, unused variables\n  take up memory space, leading to inefficient use of resources. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn summary, unused local variables can make your code less readable, more confusing, and harder to maintain, and they can potentially lead to bugs\nor inefficient memory use. Therefore, it is best to remove them.\u003c/p\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eNo issue is raised on local variables with the attribute \u003ccode\u003e[[maybe_unused]]\u003c/code\u003e or \u003ccode\u003eunused\u003c/code\u003e and object declarations with\nnon-empty arguments.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eThe fix for this issue is straightforward. Once you ensure the unused variable is not part of an incomplete implementation leading to bugs, you\njust need to remove it.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nint numberOfMinutes(int hours) {\n  int seconds \u003d 0; // Noncompliant second is unused\n  return hours * 60;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nint numberOfMinutes(int hours) {\n  return hours * 60;\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eAn unused local variable is a variable that has been declared but is not used anywhere in the block of code where it is defined. It is dead code,\ncontributing to unnecessary complexity and leading to confusion when reading the code. Therefore, it should be removed from your code to maintain\nclarity and efficiency.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eHaving unused local variables in your code can lead to several issues:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Decreased Readability: Unused variables can make your code more difficult to read. They add extra lines and complexity, which can distract from\n  the main logic of the code. \u003c/li\u003e\n  \u003cli\u003e Misunderstanding: When other developers read your code, they may wonder why a variable is declared but not used. This can lead to confusion and\n  misinterpretation of the code’s intent. \u003c/li\u003e\n  \u003cli\u003e Potential for Bugs: If a variable is declared but not used, it might indicate a bug or incomplete code. For example, if you declared a variable\n  intending to use it in a calculation, but then forgot to do so, your program might not work as expected. \u003c/li\u003e\n  \u003cli\u003e Maintenance Issues: Unused variables can make code maintenance more difficult. If a programmer sees an unused variable, they might think it is\n  a mistake and try to \u0027fix\u0027 the code, potentially introducing new bugs. \u003c/li\u003e\n  \u003cli\u003e Memory Usage: Although modern compilers are smart enough to ignore unused variables, not all compilers do this. In such cases, unused variables\n  take up memory space, leading to inefficient use of resources. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn summary, unused local variables can make your code less readable, more confusing, and harder to maintain, and they can potentially lead to bugs\nor inefficient memory use. Therefore, it is best to remove them.\u003c/p\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eNo issue is raised on local variables with the attribute \u003ccode\u003e[[maybe_unused]]\u003c/code\u003e or \u003ccode\u003eunused\u003c/code\u003e and object declarations with\nnon-empty arguments.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eThe fix for this issue is straightforward. Once you ensure the unused variable is not part of an incomplete implementation leading to bugs, you\njust need to remove it.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nint numberOfMinutes(int hours) {\n  int seconds \u003d 0; // Noncompliant second is unused\n  return hours * 60;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nint numberOfMinutes(int hours) {\n  return hours * 60;\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "unused"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:M23_146",
    "name": "A \"declaration\" should not declare more than one variable or member variable",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "FORMATTED",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 10.0.1\u003c/p\u003e\n\u003cp\u003eCategory: Advisory\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eAn \u003cem\u003einit-declarator-list\u003c/em\u003e or a \u003cem\u003emember-declarator-list\u003c/em\u003e should consist of a single \u003cem\u003einit-declarator\u003c/em\u003e or\n\u003cem\u003emember-declarator\u003c/em\u003e respectively.\u003c/p\u003e\n\u003cp\u003eStructured bindings are permitted by this rule.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eWhere multiple declarators appear in the same \u003cem\u003edeclaration\u003c/em\u003e [1], the type of an identifier may not meet developer expectations.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nint32_t   i1; int32_t j1;                 // Compliant\nint32_t   i2, * j2;                       // Non-compliant\nint32_t * i3,\n        \u0026amp; j3 \u003d i2;                        // Non-compliant\n\nstruct point\n{\n  int32_t x, y;                           // Non-compliant\n};\n\nstd::map\u0026lt; char, char \u0026gt; map \u003d f();\n\nauto [ loc, inserted ] \u003d\n  map.insert( make_pair( \u0027A\u0027, \u0027a\u0027 ) );    // Compliant - structured binding\n\u003c/pre\u003e\n\u003ch3\u003eGlossary\u003c/h3\u003e\n\u003ch4\u003e[1] Declaration\u003c/h4\u003e\n\u003cp\u003eA \u003cem\u003edeclaration\u003c/em\u003e introduces the name of an \u003cem\u003eentity\u003c/em\u003e into a \u003cem\u003etranslation unit\u003c/em\u003e (see [basic.def]/1).\u003c/p\u003e\n\u003cp\u003eAn \u003cem\u003eentity\u003c/em\u003e may be \u003cem\u003edeclared\u003c/em\u003e several times. The first \u003cem\u003edeclaration\u003c/em\u003e of an \u003cem\u003eentity\u003c/em\u003e in a \u003cem\u003etranslation unit\u003c/em\u003e is\ncalled an \u003cem\u003eintroduction\u003c/em\u003e [2]. All subsequent \u003cem\u003edeclarations\u003c/em\u003e are called \u003cem\u003eredeclarations\u003c/em\u003e [3].\u003c/p\u003e\n\u003cp\u003eA \u003cem\u003edefinition\u003c/em\u003e [4] is a \u003cem\u003edeclaration\u003c/em\u003e, as described in [basic.def]/2.\u003c/p\u003e\n\u003ch4\u003e[2] Introduction\u003c/h4\u003e\n\u003cp\u003eSee \u003cem\u003edeclaration\u003c/em\u003e [1].\u003c/p\u003e\n\u003ch4\u003e[3] Redeclaration\u003c/h4\u003e\n\u003cp\u003eSee \u003cem\u003edeclaration\u003c/em\u003e [1].\u003c/p\u003e\n\u003ch4\u003e[4] Definition\u003c/h4\u003e\n\u003cp\u003eSee \u003cem\u003edeclaration\u003c/em\u003e [1].\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003e{rule:cpp:S1659} targets the same defect as this rule but for a non-mission-critical context.\u003c/p\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/YTZGBQ\"\u003eCERT, DCL52-J.\u003c/a\u003e - Do not declare more than one variable per declaration \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/EtcxBQ\"\u003eCERT, DCL04-C.\u003c/a\u003e - Do not declare more than one variable per declaration \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/036324/CppCoreGuidelines.md#es10-declare-one-name-only-per-declaration\"\u003eC++ Core\n  Guidelines - ES.10\u003c/a\u003e - Declare one name (only) per declaration \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 10.0.1\u003c/p\u003e\n\u003cp\u003eCategory: Advisory\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eAn \u003cem\u003einit-declarator-list\u003c/em\u003e or a \u003cem\u003emember-declarator-list\u003c/em\u003e should consist of a single \u003cem\u003einit-declarator\u003c/em\u003e or\n\u003cem\u003emember-declarator\u003c/em\u003e respectively.\u003c/p\u003e\n\u003cp\u003eStructured bindings are permitted by this rule.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eWhere multiple declarators appear in the same \u003cem\u003edeclaration\u003c/em\u003e [1], the type of an identifier may not meet developer expectations.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nint32_t   i1; int32_t j1;                 // Compliant\nint32_t   i2, * j2;                       // Non-compliant\nint32_t * i3,\n        \u0026amp; j3 \u003d i2;                        // Non-compliant\n\nstruct point\n{\n  int32_t x, y;                           // Non-compliant\n};\n\nstd::map\u0026lt; char, char \u0026gt; map \u003d f();\n\nauto [ loc, inserted ] \u003d\n  map.insert( make_pair( \u0027A\u0027, \u0027a\u0027 ) );    // Compliant - structured binding\n\u003c/pre\u003e\n\u003ch3\u003eGlossary\u003c/h3\u003e\n\u003ch4\u003e[1] Declaration\u003c/h4\u003e\n\u003cp\u003eA \u003cem\u003edeclaration\u003c/em\u003e introduces the name of an \u003cem\u003eentity\u003c/em\u003e into a \u003cem\u003etranslation unit\u003c/em\u003e (see [basic.def]/1).\u003c/p\u003e\n\u003cp\u003eAn \u003cem\u003eentity\u003c/em\u003e may be \u003cem\u003edeclared\u003c/em\u003e several times. The first \u003cem\u003edeclaration\u003c/em\u003e of an \u003cem\u003eentity\u003c/em\u003e in a \u003cem\u003etranslation unit\u003c/em\u003e is\ncalled an \u003cem\u003eintroduction\u003c/em\u003e [2]. All subsequent \u003cem\u003edeclarations\u003c/em\u003e are called \u003cem\u003eredeclarations\u003c/em\u003e [3].\u003c/p\u003e\n\u003cp\u003eA \u003cem\u003edefinition\u003c/em\u003e [4] is a \u003cem\u003edeclaration\u003c/em\u003e, as described in [basic.def]/2.\u003c/p\u003e\n\u003ch4\u003e[2] Introduction\u003c/h4\u003e\n\u003cp\u003eSee \u003cem\u003edeclaration\u003c/em\u003e [1].\u003c/p\u003e\n\u003ch4\u003e[3] Redeclaration\u003c/h4\u003e\n\u003cp\u003eSee \u003cem\u003edeclaration\u003c/em\u003e [1].\u003c/p\u003e\n\u003ch4\u003e[4] Definition\u003c/h4\u003e\n\u003cp\u003eSee \u003cem\u003edeclaration\u003c/em\u003e [1].\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003e{rule:cpp:S1659} targets the same defect as this rule but for a non-mission-critical context.\u003c/p\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/YTZGBQ\"\u003eCERT, DCL52-J.\u003c/a\u003e - Do not declare more than one variable per declaration \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/EtcxBQ\"\u003eCERT, DCL04-C.\u003c/a\u003e - Do not declare more than one variable per declaration \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/036324/CppCoreGuidelines.md#es10-declare-one-name-only-per-declaration\"\u003eC++ Core\n  Guidelines - ES.10\u003c/a\u003e - Declare one name (only) per declaration \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "convention",
      "misra-advisory",
      "misra-c++2023"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:M23_388",
    "name": "\"Global variables\" shall not be used",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "MODULAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 6.7.2\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003e\u003cem\u003eGlobal variables\u003c/em\u003e are:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Variables defined in namespace scope; and \u003c/li\u003e\n  \u003cli\u003e Class static data members. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis rule does not apply to \u003cem\u003eglobal variables\u003c/em\u003e that are:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003econstexpr\u003c/code\u003e; or \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003econst\u003c/code\u003e and that are initialized through \u003cem\u003estatic initialization\u003c/em\u003e. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003e\u003cem\u003eGlobal variables\u003c/em\u003e can be accessed and modified from:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Anywhere within the \u003cem\u003etranslation unit\u003c/em\u003e, if they have internal linkage; or \u003c/li\u003e\n  \u003cli\u003e Anywhere within the program, if they have external linkage. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis can lead to uncontrollable interactions between functions, with the risk of \u003cem\u003eundefined behaviour\u003c/em\u003e occurring due to data races in\nconcurrent programs.\u003c/p\u003e\n\u003cp\u003eAdditionally, certain aspects of the order of initialization of global variables are \u003cem\u003eunspecified\u003c/em\u003e. This can lead to unpredictable results\nfor global variables that are initialized at run-time (\u003cem\u003edynamic initialization\u003c/em\u003e).\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nint32_t foo();\n\n      int32_t i1 { foo() };               // Non-compliant\nconst int32_t i2 { i1 };                  // Non-compliant - dynamic initialization\n\nnamespace\n{\n  int32_t i3 { 0 };                       // Non-compliant\n\n  constexpr int32_t bar()\n  {\n    return 42;\n  }\n\n  constexpr int32_t i4 { bar() };         // Rule does not apply - constexpr\n\n  const int32_t SIZE { 100 };             // Rule does not apply\n}                                         // - const without dynamic initialization\n\nstruct ComplexInit\n{\n  ComplexInit();\n};\n\nconst ComplexInit c1 {};                  // Non-compliant - dynamic initialization\n\nclass StaticMember\n{\n         int32_t x;                       // Rule does not apply\n  static int32_t numInstances;\n};\n\nint32_t StaticMember::numInstances \u003d 0;   // Non-compliant\n\nconstexpr auto add \u003d                      // Rule does not apply - add is const\n  []( auto x, auto y ) { return x + y; };\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S5421} targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:M23_233}: MISRA C++ 2023 Rule\u0026nbsp;6.7.1 - Local variables shall not have static storage duration \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cp\u003e\u003ca href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/036324/CppCoreGuidelines.md#i2-avoid-non-const-global-variables\"\u003eC++ Core Guidelines\nI.2\u003c/a\u003e - Avoid non-const global variables\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 6.7.2\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003e\u003cem\u003eGlobal variables\u003c/em\u003e are:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Variables defined in namespace scope; and \u003c/li\u003e\n  \u003cli\u003e Class static data members. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis rule does not apply to \u003cem\u003eglobal variables\u003c/em\u003e that are:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003econstexpr\u003c/code\u003e; or \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003econst\u003c/code\u003e and that are initialized through \u003cem\u003estatic initialization\u003c/em\u003e. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003e\u003cem\u003eGlobal variables\u003c/em\u003e can be accessed and modified from:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Anywhere within the \u003cem\u003etranslation unit\u003c/em\u003e, if they have internal linkage; or \u003c/li\u003e\n  \u003cli\u003e Anywhere within the program, if they have external linkage. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis can lead to uncontrollable interactions between functions, with the risk of \u003cem\u003eundefined behaviour\u003c/em\u003e occurring due to data races in\nconcurrent programs.\u003c/p\u003e\n\u003cp\u003eAdditionally, certain aspects of the order of initialization of global variables are \u003cem\u003eunspecified\u003c/em\u003e. This can lead to unpredictable results\nfor global variables that are initialized at run-time (\u003cem\u003edynamic initialization\u003c/em\u003e).\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nint32_t foo();\n\n      int32_t i1 { foo() };               // Non-compliant\nconst int32_t i2 { i1 };                  // Non-compliant - dynamic initialization\n\nnamespace\n{\n  int32_t i3 { 0 };                       // Non-compliant\n\n  constexpr int32_t bar()\n  {\n    return 42;\n  }\n\n  constexpr int32_t i4 { bar() };         // Rule does not apply - constexpr\n\n  const int32_t SIZE { 100 };             // Rule does not apply\n}                                         // - const without dynamic initialization\n\nstruct ComplexInit\n{\n  ComplexInit();\n};\n\nconst ComplexInit c1 {};                  // Non-compliant - dynamic initialization\n\nclass StaticMember\n{\n         int32_t x;                       // Rule does not apply\n  static int32_t numInstances;\n};\n\nint32_t StaticMember::numInstances \u003d 0;   // Non-compliant\n\nconstexpr auto add \u003d                      // Rule does not apply - add is const\n  []( auto x, auto y ) { return x + y; };\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S5421} targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:M23_233}: MISRA C++ 2023 Rule\u0026nbsp;6.7.1 - Local variables shall not have static storage duration \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cp\u003e\u003ca href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/036324/CppCoreGuidelines.md#i2-avoid-non-const-global-variables\"\u003eC++ Core Guidelines\nI.2\u003c/a\u003e - Avoid non-const global variables\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "confusing",
      "misra-c++2023",
      "misra-required"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S859",
    "name": "A cast shall not remove any const or volatile qualification from the type of a pointer or reference",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "MODULAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eUsing \u003ccode\u003econst\u003c/code\u003e in your code improves reliability and maintenance. When passing a \u003ccode\u003econst\u003c/code\u003e value, developers assume that its\nvalue won’t be changed. But using \u003ccode\u003econst_cast\u0026lt;\u0026gt;()\u003c/code\u003e to cast away a \u003ccode\u003econst\u003c/code\u003e qualifier, destroys developer assumptions and\ncode reliability. It is a bad practice and reveals a flaw in the design. Furthermore, it may have an undefined behavior.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nUser\u0026amp; func(const int\u0026amp; value, const User\u0026amp; user) {\n  const_cast\u0026lt;int\u0026amp;\u0026gt;(value) \u003d 2; // Noncompliant and undefined behavior\n  return const_cast\u0026lt;User\u0026amp;\u0026gt;(user); // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nUser\u0026amp; func(int\u0026amp; value, User\u0026amp; user) {\n  value \u003d 2;\n  return user;\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 11.5 - A cast shall not be performed that removes any const or volatile qualification from the type addressed by a pointer \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 5-2-5 - A cast shall not remove any const or volatile qualification from the type of a pointer or reference \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 11.8 - A cast shall not remove any const or volatile qualification from the type pointed to by a pointer \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/HNcxBQ\"\u003eCERT, EXP32-C.\u003c/a\u003e - Do not access a volatile object through a nonvolatile reference\n  \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/P9YxBQ\"\u003eCERT, EXP05-C.\u003c/a\u003e - Do not cast away a const qualification \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/AHw-BQ\"\u003eCERT, EXP55-CPP.\u003c/a\u003e - Do not access a cv-qualified object through a cv-unqualified type\n  \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines Type.3 - Don’t use const_cast to cast away const (i.e., at all): Don’t cast away const. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eUsing \u003ccode\u003econst\u003c/code\u003e in your code improves reliability and maintenance. When passing a \u003ccode\u003econst\u003c/code\u003e value, developers assume that its\nvalue won’t be changed. But using \u003ccode\u003econst_cast\u0026lt;\u0026gt;()\u003c/code\u003e to cast away a \u003ccode\u003econst\u003c/code\u003e qualifier, destroys developer assumptions and\ncode reliability. It is a bad practice and reveals a flaw in the design. Furthermore, it may have an undefined behavior.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nUser\u0026amp; func(const int\u0026amp; value, const User\u0026amp; user) {\n  const_cast\u0026lt;int\u0026amp;\u0026gt;(value) \u003d 2; // Noncompliant and undefined behavior\n  return const_cast\u0026lt;User\u0026amp;\u0026gt;(user); // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nUser\u0026amp; func(int\u0026amp; value, User\u0026amp; user) {\n  value \u003d 2;\n  return user;\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 11.5 - A cast shall not be performed that removes any const or volatile qualification from the type addressed by a pointer \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 5-2-5 - A cast shall not remove any const or volatile qualification from the type of a pointer or reference \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 11.8 - A cast shall not remove any const or volatile qualification from the type pointed to by a pointer \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/HNcxBQ\"\u003eCERT, EXP32-C.\u003c/a\u003e - Do not access a volatile object through a nonvolatile reference\n  \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/P9YxBQ\"\u003eCERT, EXP05-C.\u003c/a\u003e - Do not cast away a const qualification \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/AHw-BQ\"\u003eCERT, EXP55-CPP.\u003c/a\u003e - Do not access a cv-qualified object through a cv-unqualified type\n  \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines Type.3 - Don’t use const_cast to cast away const (i.e., at all): Don’t cast away const. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cert",
      "cppcoreguidelines",
      "misra-c++2008",
      "misra-c2004",
      "misra-c2012",
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1006",
    "name": "Parameters in an overriding virtual function shall either use the same default arguments as the function they override, or else shall not specify any default arguments",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eOverriding the default parameter value inherited from a parent class will lead to unexpected results when the child class is referenced from a\npointer to the parent class.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nenum E_ShapeColor {E_RED, E_GREEN, E_BLUE};\n\nclass Shape\n{\npublic:\n  virtual void draw(E_ShapeColor color \u003d E_RED) const\n  {\n    ...\n  }\n};\n\nclass Rectangle : public Shape\n{\npublic:\n  virtual void draw(E_ShapeColor color \u003d E_BLUE) const override // Noncompliant\n  {\n   ...\n  }\n};\n\nint main() {\n  Shape *shape \u003d new Rectangle{};\n  shape-\u0026gt;draw();  // unexpectedly calls Rectangle::draw(RED)\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nenum E_ShapeColor {E_RED, E_GREEN, E_BLUE};\n\nclass Shape\n{\npublic:\n  virtual void draw(E_ShapeColor color \u003d E_RED) const\n  {\n    ...\n  }\n};\n\nclass Rectangle : public Shape\n{\npublic:\n  virtual void draw(E_ShapeColor color) const override\n  // OR: virtual void draw(E_ShapeColor color \u003d E_RED) const override\n  {\n    ...\n  }\n};\n\nint main() {\n  Shape *shape \u003d new Rectangle{};\n  shape-\u0026gt;draw(); // expectedly calls Rectangle::draw(RED)\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++ 2008, 8-3-1 - Parameters in a overriding virtual function shall either use the same default arguments as the function they override,\n  or else shall not specify any default arguments. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eOverriding the default parameter value inherited from a parent class will lead to unexpected results when the child class is referenced from a\npointer to the parent class.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nenum E_ShapeColor {E_RED, E_GREEN, E_BLUE};\n\nclass Shape\n{\npublic:\n  virtual void draw(E_ShapeColor color \u003d E_RED) const\n  {\n    ...\n  }\n};\n\nclass Rectangle : public Shape\n{\npublic:\n  virtual void draw(E_ShapeColor color \u003d E_BLUE) const override // Noncompliant\n  {\n   ...\n  }\n};\n\nint main() {\n  Shape *shape \u003d new Rectangle{};\n  shape-\u0026gt;draw();  // unexpectedly calls Rectangle::draw(RED)\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nenum E_ShapeColor {E_RED, E_GREEN, E_BLUE};\n\nclass Shape\n{\npublic:\n  virtual void draw(E_ShapeColor color \u003d E_RED) const\n  {\n    ...\n  }\n};\n\nclass Rectangle : public Shape\n{\npublic:\n  virtual void draw(E_ShapeColor color) const override\n  // OR: virtual void draw(E_ShapeColor color \u003d E_RED) const override\n  {\n    ...\n  }\n};\n\nint main() {\n  Shape *shape \u003d new Rectangle{};\n  shape-\u0026gt;draw(); // expectedly calls Rectangle::draw(RED)\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C++ 2008, 8-3-1 - Parameters in a overriding virtual function shall either use the same default arguments as the function they override,\n  or else shall not specify any default arguments. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cppcoreguidelines",
      "misra-c++2008",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S3548",
    "name": "Declarations of functions defined outside of the class should not be marked as \"inline\"",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eIt is a best practice in the public part of a class body, to describe only information relevant for reusers of this class, without implementation\ndetails like \u003ccode\u003einline\u003c/code\u003e specifier.\u003c/p\u003e\n\u003cp\u003eFor inline member function defined outside of the class body, this rule verifies that \u003ccode\u003einline\u003c/code\u003e is set on the definition and not on the\ndeclaration of the function.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass Foo {\n  public:\n    inline void method();  // Noncompliant\n    // ...\n};\nvoid Foo::method() {\n  // ...\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nclass Foo {\n  public:\n    void method();\n    // ...\n};\ninline void Foo::method() {\n  // ...\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca\n  href\u003d\"https://isocpp.org/wiki/faq/inline-functions#where-to-put-inline-keyword\"\u003ehttps://isocpp.org/wiki/faq/inline-functions#where-to-put-inline-keyword\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eIt is a best practice in the public part of a class body, to describe only information relevant for reusers of this class, without implementation\ndetails like \u003ccode\u003einline\u003c/code\u003e specifier.\u003c/p\u003e\n\u003cp\u003eFor inline member function defined outside of the class body, this rule verifies that \u003ccode\u003einline\u003c/code\u003e is set on the definition and not on the\ndeclaration of the function.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass Foo {\n  public:\n    inline void method();  // Noncompliant\n    // ...\n};\nvoid Foo::method() {\n  // ...\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nclass Foo {\n  public:\n    void method();\n    // ...\n};\ninline void Foo::method() {\n  // ...\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e \u003ca\n  href\u003d\"https://isocpp.org/wiki/faq/inline-functions#where-to-put-inline-keyword\"\u003ehttps://isocpp.org/wiki/faq/inline-functions#where-to-put-inline-keyword\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "clumsy"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S2216",
    "name": "Single-bit named bit fields should not be of a signed type",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe values that can be represented by a signed bit field with a length of one bit may not meet developer expectations. For example, according to\nthe C99 Standard, a single-bit signed bit-field has a single (one) sign bit and no (zero) value bits.\u003c/p\u003e\n\u003cp\u003eThis rule does not apply to unnamed bit fields, as their values cannot be accessed.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nsigned int f:1;  // Noncompliant; there\u0027s only room here for the sign\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nunsigned int f:1;\n\u003c/pre\u003e\n\u003cp\u003eor\u003c/p\u003e\n\u003cpre\u003e\nsigned int:1; // unnamed\n\u003c/pre\u003e\n\u003cp\u003eor\u003c/p\u003e\n\u003cpre\u003e\nsigned int f:2;\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 6.5 - Bit fields of type signed int shall be at least 2 bits long \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 6.2 - Single-bit named bit fields shall not be of a signed type \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 9-6-4 - Named bit-fields with signed integer type shall have a length of more than one bit \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe values that can be represented by a signed bit field with a length of one bit may not meet developer expectations. For example, according to\nthe C99 Standard, a single-bit signed bit-field has a single (one) sign bit and no (zero) value bits.\u003c/p\u003e\n\u003cp\u003eThis rule does not apply to unnamed bit fields, as their values cannot be accessed.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nsigned int f:1;  // Noncompliant; there\u0027s only room here for the sign\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nunsigned int f:1;\n\u003c/pre\u003e\n\u003cp\u003eor\u003c/p\u003e\n\u003cpre\u003e\nsigned int:1; // unnamed\n\u003c/pre\u003e\n\u003cp\u003eor\u003c/p\u003e\n\u003cpre\u003e\nsigned int f:2;\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 6.5 - Bit fields of type signed int shall be at least 2 bits long \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 6.2 - Single-bit named bit fields shall not be of a signed type \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 9-6-4 - Named bit-fields with signed integer type shall have a length of more than one bit \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "based-on-misra"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5849",
    "name": "Setting capabilities is security-sensitive",
    "defaultSeverity": "MAJOR",
    "type": "SECURITY_HOTSPOT",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "SECURITY": "MEDIUM"
    },
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eSetting capabilities can lead to privilege escalation.\u003c/p\u003e\n\u003cp\u003eLinux capabilities allow you to assign narrow slices of \u003ccode\u003eroot\u003c/code\u003e\u0027s permissions to files or processes. A thread with capabilities bypasses\nthe normal kernel security checks to execute high-privilege actions such as mounting a device to a directory, without requiring (additional) root\nprivileges.\u003c/p\u003e"
      },
      {
        "key": "assess_the_problem",
        "htmlContent": "\u003ch2\u003eAsk Yourself Whether\u003c/h2\u003e\n\u003cp\u003eCapabilities are granted:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e To a process that does not require all capabilities to do its job. \u003c/li\u003e\n  \u003cli\u003e To a not trusted process. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere is a risk if you answered yes to any of those questions.\u003c/p\u003e\n\u003ch2\u003eSensitive Code Example\u003c/h2\u003e\n\u003cp\u003eWhen setting capabilities:\u003c/p\u003e\n\u003cpre\u003e\ncap_t caps \u003d cap_init();\ncap_value_t cap_list[2];\ncap_list[0] \u003d CAP_FOWNER;\ncap_list[1] \u003d CAP_CHOWN;\ncap_set_flag(caps, CAP_PERMITTED, 2, cap_list, CAP_SET);\n\ncap_set_file(\"file\", caps); // Sensitive\ncap_set_fd(fd, caps); // Sensitive\ncap_set_proc(caps); // Sensitive\ncapsetp(pid, caps); // Sensitive\ncapset(hdrp, datap); // Sensitive: is discouraged to be used because it is a system call\n\u003c/pre\u003e\n\u003cp\u003eWhen setting SUID/SGID attributes:\u003c/p\u003e\n\u003cpre\u003e\nchmod(\"file\", S_ISUID|S_ISGID); // Sensitive\nfchmod(fd, S_ISUID|S_ISGID); // Sensitive\n\u003c/pre\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003ch2\u003eRecommended Secure Coding Practices\u003c/h2\u003e\n\u003cp\u003eCapabilities are high privileges, traditionally associated with superuser (root), thus make sure that the most restrictive and necessary\ncapabilities are assigned to files and processes.\u003c/p\u003e\n\u003ch2\u003eSee\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/Top10/A01_2021-Broken_Access_Control/\"\u003eOWASP Top 10 2021 Category A1\u003c/a\u003e - Broken Access Control \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control\"\u003eOWASP Top 10 2017 Category A5\u003c/a\u003e - Broken Access Control\n  \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/250\"\u003eMITRE, CWE-250\u003c/a\u003e - Execution with Unnecessary Privileges \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/266\"\u003eMITRE, CWE-266\u003c/a\u003e - Incorrect Privilege Assignment \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://forums.grsecurity.net/viewtopic.php?f\u003d7\u0026amp;t\u003d2522\"\u003eFalse Boundaries and Arbitrary Code Execution\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://man7.org/linux/man-pages/man7/capabilities.7.html\"\u003eLinux manual page\u003c/a\u003e - capabilities(7) \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cwe"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": [],
    "vulnerabilityProbability": "MEDIUM"
  },
  {
    "key": "cpp:M23_152",
    "name": "The value of an object must not be read before it has been set",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 11.6.2\u003c/p\u003e\n\u003cp\u003eCategory: Mandatory\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Undecidable,System\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eFor the purposes of this rule, an array element or class member is considered to be a discrete object.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e struct members are also class members.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eObjects created with \u003cem\u003eautomatic storage duration\u003c/em\u003e or \u003cem\u003edynamic storage duration\u003c/em\u003e have an \u003cem\u003eindeterminate value\u003c/em\u003e. Reading an\nindeterminate value may result in \u003cem\u003eundefined behaviour\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eThis rule requires that all objects are written, either by implicit or explicit initialization in their declaration or by assignment, before they\nare read.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e jumping over an initializer by the use of a \u003ccode\u003egoto\u003c/code\u003e or \u003ccode\u003eswitch\u003c/code\u003e statement \"bypasses\" the declaration of\nthe object, rendering the program \u003cem\u003eill-formed\u003c/em\u003e.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nnamespace\n{\n  int32_t Z;                  // Compliant - implicitly initialized with \u00270\u0027\n}\n\nvoid f()\n{\n  int32_t  i;\n  int32_t  j \u003d i + 1;         // Non-compliant - i has not been assigned a value\n\n  int32_t * p \u003d new int32_t;\n  int32_t   k \u003d *p;           // Non-compliant - *p has not been assigned a value\n\n  int32_t * q;\n\n  if ( q \u003d\u003d p )               // Non-compliant - q has not been assigned a value\n  {\n  }\n}\n\nint32_t g( bool b )\n{\n  if ( b )\n  {\n    goto L1;\n  }\n\n  int32_t x;\n\n  x \u003d 10u;\n\nL1:\n  x \u003d x + 1u;               // Non-compliant - x may not have been assigned a value\n\n  return x;\n}\n\nstruct S { int32_t a; int32_t b; };\n\nvoid h()\n{\n  S s1;\n  S s2 \u003d { 10 };\n\n  auto i1 \u003d s1.a;           // Non-compliant\n  auto i2 \u003d s2.b;           // Compliant - s2.b implicitly initialized to 0\n\n  int32_t array1[ 10 ] \u003d { 1, 2, 3 };\n  int32_t array2[ 10 ];\n  auto i3 \u003d array1[ 5 ];    // Compliant - array1[ 5 ] implicitly initialized to 0\n  auto i4 \u003d array2[ 5 ];    // Non-compliant\n}\n\nclass C\n{\npublic:\n  C() : m_a( 10 ), m_b( 7 )   // Both m_a and m_b initialized\n  {\n  }\n\n  C( int32_t a ) : m_a( a )   // m_b not initialized\n  {\n  }\n\n  int32_t GetmB()\n  {\n    return m_b;\n  }\n\nprivate:\n  int32_t m_a;\n  int32_t m_b;\n};\n\nint main()\n{\n  C c1;\n  if ( c1.GetmB() \u0026gt; 0 )       // Compliant - m_b initialized\n  {\n  }\n\n  C c2( 5 );\n\n  if ( c2.GetmB() \u0026gt; 0 )       // Non-compliant - m_b not initialized\n  {\n  }\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S836} targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:M23_321}: MISRA C++ 2023 Rule\u0026nbsp;11.6.1 - All variables should be initialized \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2023 Rule\u0026nbsp;15.1.4 - All direct, non-static data members of a class should be initialized before the class object is\n  \u003cem\u003eaccessible\u003c/em\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cp\u003e\u003ca href\u003d\"https://cwe.mitre.org/data/definitions/457\"\u003eMITRE, CWE-457\u003c/a\u003e - Use of Uninitialized Variable\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 11.6.2\u003c/p\u003e\n\u003cp\u003eCategory: Mandatory\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Undecidable,System\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eFor the purposes of this rule, an array element or class member is considered to be a discrete object.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e struct members are also class members.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eObjects created with \u003cem\u003eautomatic storage duration\u003c/em\u003e or \u003cem\u003edynamic storage duration\u003c/em\u003e have an \u003cem\u003eindeterminate value\u003c/em\u003e. Reading an\nindeterminate value may result in \u003cem\u003eundefined behaviour\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eThis rule requires that all objects are written, either by implicit or explicit initialization in their declaration or by assignment, before they\nare read.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e jumping over an initializer by the use of a \u003ccode\u003egoto\u003c/code\u003e or \u003ccode\u003eswitch\u003c/code\u003e statement \"bypasses\" the declaration of\nthe object, rendering the program \u003cem\u003eill-formed\u003c/em\u003e.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nnamespace\n{\n  int32_t Z;                  // Compliant - implicitly initialized with \u00270\u0027\n}\n\nvoid f()\n{\n  int32_t  i;\n  int32_t  j \u003d i + 1;         // Non-compliant - i has not been assigned a value\n\n  int32_t * p \u003d new int32_t;\n  int32_t   k \u003d *p;           // Non-compliant - *p has not been assigned a value\n\n  int32_t * q;\n\n  if ( q \u003d\u003d p )               // Non-compliant - q has not been assigned a value\n  {\n  }\n}\n\nint32_t g( bool b )\n{\n  if ( b )\n  {\n    goto L1;\n  }\n\n  int32_t x;\n\n  x \u003d 10u;\n\nL1:\n  x \u003d x + 1u;               // Non-compliant - x may not have been assigned a value\n\n  return x;\n}\n\nstruct S { int32_t a; int32_t b; };\n\nvoid h()\n{\n  S s1;\n  S s2 \u003d { 10 };\n\n  auto i1 \u003d s1.a;           // Non-compliant\n  auto i2 \u003d s2.b;           // Compliant - s2.b implicitly initialized to 0\n\n  int32_t array1[ 10 ] \u003d { 1, 2, 3 };\n  int32_t array2[ 10 ];\n  auto i3 \u003d array1[ 5 ];    // Compliant - array1[ 5 ] implicitly initialized to 0\n  auto i4 \u003d array2[ 5 ];    // Non-compliant\n}\n\nclass C\n{\npublic:\n  C() : m_a( 10 ), m_b( 7 )   // Both m_a and m_b initialized\n  {\n  }\n\n  C( int32_t a ) : m_a( a )   // m_b not initialized\n  {\n  }\n\n  int32_t GetmB()\n  {\n    return m_b;\n  }\n\nprivate:\n  int32_t m_a;\n  int32_t m_b;\n};\n\nint main()\n{\n  C c1;\n  if ( c1.GetmB() \u0026gt; 0 )       // Compliant - m_b initialized\n  {\n  }\n\n  C c2( 5 );\n\n  if ( c2.GetmB() \u0026gt; 0 )       // Non-compliant - m_b not initialized\n  {\n  }\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S836} targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:M23_321}: MISRA C++ 2023 Rule\u0026nbsp;11.6.1 - All variables should be initialized \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2023 Rule\u0026nbsp;15.1.4 - All direct, non-static data members of a class should be initialized before the class object is\n  \u003cem\u003eaccessible\u003c/em\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cp\u003e\u003ca href\u003d\"https://cwe.mitre.org/data/definitions/457\"\u003eMITRE, CWE-457\u003c/a\u003e - Use of Uninitialized Variable\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "cwe",
      "misra-c++2023",
      "misra-mandatory",
      "symbolic-execution",
      "unpredictable"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:M23_394",
    "name": "A non-\"transient lambda\" shall not implicitly capture \"this\"",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 8.1.1\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eIf a lambda with implicit capture (having \u003ccode\u003e\u003d\u003c/code\u003e or \u003ccode\u003e\u0026amp;\u003c/code\u003e in the capture list) attempts to capture a member variable of a\nclass, what is in fact captured is the \u003ccode\u003ethis\u003c/code\u003e pointer. This behaviour can be surprising, and may result in \u003cem\u003eundefined behaviour\u003c/em\u003e if\nthe lambda is called after the object’s lifetime has ended. This issue cannot occur for a \u003cem\u003etransient lambda\u003c/em\u003e [1].\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e implicitly capturing \u003ccode\u003ethis\u003c/code\u003e using \u003ccode\u003e[\u003d]\u003c/code\u003e is deprecated from C++20.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nclass A\n{\n  int16_t val;\n\n  void f()\n  {\n    auto a1 \u003d [\u003d]()                 // Non-compliant - val is not captured, but\n              { return val; };      // \u0027this\u0027 is implicitly captured\n    auto a2 \u003d [\u0026amp;]()                 // Non-compliant - val is not captured, but\n              { return val; };      // \u0027this\u0027 is implicitly captured\n    auto a3 \u003d [this]()              // Compliant - \u0027this\u0027 explicitly captured\n              { return val; };\n    auto a4 \u003d [self \u003d *this]()      // Compliant - current object captured by copy\n              { return self.val; };\n    auto i  \u003d [\u0026amp;]()                 // Rule does not apply - transient lambda\n              { return val; } ();\n  }\n};\n\u003c/pre\u003e\n\u003ch3\u003eGlossary\u003c/h3\u003e\n\u003ch4\u003e[1] Transient lambda\u003c/h4\u003e\n\u003cp\u003eA lambda is \u003cem\u003etransient\u003c/em\u003e when:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e It is immediately invoked; or \u003c/li\u003e\n  \u003cli\u003e It is passed to a function that does not \u003cem\u003estore\u003c/em\u003e it. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eA function does not \u003cem\u003estore\u003c/em\u003e a lambda when:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The function is defined in the same \u003cem\u003etranslation unit\u003c/em\u003e as the lambda; and \u003c/li\u003e\n  \u003cli\u003e The lambda is only copied or moved when it is passed as an argument; and \u003c/li\u003e\n  \u003cli\u003e The function only calls the lambda and/or passes the lambda to another function that does not \u003cem\u003estore\u003c/em\u003e it. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S5019} targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:M23_279}: MISRA C++ 2023 Rule\u0026nbsp;28.6.2 ensures that variables are not implicit captured in non-transient lambda \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 8.1.1\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eIf a lambda with implicit capture (having \u003ccode\u003e\u003d\u003c/code\u003e or \u003ccode\u003e\u0026amp;\u003c/code\u003e in the capture list) attempts to capture a member variable of a\nclass, what is in fact captured is the \u003ccode\u003ethis\u003c/code\u003e pointer. This behaviour can be surprising, and may result in \u003cem\u003eundefined behaviour\u003c/em\u003e if\nthe lambda is called after the object’s lifetime has ended. This issue cannot occur for a \u003cem\u003etransient lambda\u003c/em\u003e [1].\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e implicitly capturing \u003ccode\u003ethis\u003c/code\u003e using \u003ccode\u003e[\u003d]\u003c/code\u003e is deprecated from C++20.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nclass A\n{\n  int16_t val;\n\n  void f()\n  {\n    auto a1 \u003d [\u003d]()                 // Non-compliant - val is not captured, but\n              { return val; };      // \u0027this\u0027 is implicitly captured\n    auto a2 \u003d [\u0026amp;]()                 // Non-compliant - val is not captured, but\n              { return val; };      // \u0027this\u0027 is implicitly captured\n    auto a3 \u003d [this]()              // Compliant - \u0027this\u0027 explicitly captured\n              { return val; };\n    auto a4 \u003d [self \u003d *this]()      // Compliant - current object captured by copy\n              { return self.val; };\n    auto i  \u003d [\u0026amp;]()                 // Rule does not apply - transient lambda\n              { return val; } ();\n  }\n};\n\u003c/pre\u003e\n\u003ch3\u003eGlossary\u003c/h3\u003e\n\u003ch4\u003e[1] Transient lambda\u003c/h4\u003e\n\u003cp\u003eA lambda is \u003cem\u003etransient\u003c/em\u003e when:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e It is immediately invoked; or \u003c/li\u003e\n  \u003cli\u003e It is passed to a function that does not \u003cem\u003estore\u003c/em\u003e it. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eA function does not \u003cem\u003estore\u003c/em\u003e a lambda when:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The function is defined in the same \u003cem\u003etranslation unit\u003c/em\u003e as the lambda; and \u003c/li\u003e\n  \u003cli\u003e The lambda is only copied or moved when it is passed as an argument; and \u003c/li\u003e\n  \u003cli\u003e The function only calls the lambda and/or passes the lambda to another function that does not \u003cem\u003estore\u003c/em\u003e it. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S5019} targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:M23_279}: MISRA C++ 2023 Rule\u0026nbsp;28.6.2 ensures that variables are not implicit captured in non-transient lambda \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "misra-c++2023",
      "misra-required",
      "pitfall",
      "since-c++11"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S4999",
    "name": "\"memcpy\", \"memmove\", and \"memset\" should only be called with pointers to trivially copyable types",
    "defaultSeverity": "BLOCKER",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe behavior is undefined when \u003ccode\u003ememcpy\u003c/code\u003e, \u003ccode\u003ememmove\u003c/code\u003e, or \u003ccode\u003ememset\u003c/code\u003e are invoked with objects of non-trivially copyable\ntypes.\u003c/p\u003e\n\u003cp\u003eTrivially copyable types include:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e scalar types \u003c/li\u003e\n  \u003cli\u003e trivially copyable classes \u003c/li\u003e\n  \u003cli\u003e arrays of these types \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eA class is trivially copyable when:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e all its non-static data members and base classes are trivially copyable types, \u003c/li\u003e\n  \u003cli\u003e it has no virtual functions or base classes, \u003c/li\u003e\n  \u003cli\u003e its destructor is trival, \u003c/li\u003e\n  \u003cli\u003e and one or more of the following special member functions is trivial, and the rest are deleted: copy constructor, move constructor, copy\n  assignment operator, and move assignment operator. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cem\u003eNote: a default implementation is always considered trivial, both when it is explicit (with \u003ccode\u003e\u003d default\u003c/code\u003e) or implicit (if the special\nmember function is omitted).\u003c/em\u003e\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003ememcpy\u003c/code\u003e, \u003ccode\u003ememmove\u003c/code\u003e, and \u003ccode\u003ememset\u003c/code\u003e should only be called on trivially-copyable objects. Fixing this code defect may\nrequire non-trivial refactoring, as illustrated in the following example.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cp\u003eHere, \u003ccode\u003ecopy\u003c/code\u003e is incorrect because it calls \u003ccode\u003ememcpy\u003c/code\u003e on non-trivial objects.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nclass Resource {\n  Handle* resource_handle;\n\npublic:\n  Resource() {\n    // Acquire the resource handle.\n  }\n\n  ~Resource() {\n    // Release the resource handle.\n  }\n};\n\nvoid copy(Resource* dest, Resource const* source) {\n  memcpy(dest, source, sizeof(Resource)); // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eInstead, the \u003ccode\u003eResource\u003c/code\u003e class can provide a copy assignment operator.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nclass Resource {\n  Handle* resource_handle;\n\npublic:\n  Resource() {\n    // Acquire the resource handle.\n  }\n\n  ~Resource() {\n    // Release the resource handle.\n  }\n\n  Resource\u0026amp; operator\u003d(Resource const\u0026amp; other) {\n    // Non-trivial copy assignement:\n    // copy the handle and update the reference count, etc...\n  }\n};\n\nvoid copy(Resource* dest, Resource const* source) {\n  (*dest) \u003d (*source);\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/classes#Trivially_copyable_class\"\u003eDefinition of a trivially copyable\n  class\u003c/a\u003e. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S5000} - \"memcmp\" should only be called with pointers to trivially copyable types with no padding \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe behavior is undefined when \u003ccode\u003ememcpy\u003c/code\u003e, \u003ccode\u003ememmove\u003c/code\u003e, or \u003ccode\u003ememset\u003c/code\u003e are invoked with objects of non-trivially copyable\ntypes.\u003c/p\u003e\n\u003cp\u003eTrivially copyable types include:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e scalar types \u003c/li\u003e\n  \u003cli\u003e trivially copyable classes \u003c/li\u003e\n  \u003cli\u003e arrays of these types \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eA class is trivially copyable when:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e all its non-static data members and base classes are trivially copyable types, \u003c/li\u003e\n  \u003cli\u003e it has no virtual functions or base classes, \u003c/li\u003e\n  \u003cli\u003e its destructor is trival, \u003c/li\u003e\n  \u003cli\u003e and one or more of the following special member functions is trivial, and the rest are deleted: copy constructor, move constructor, copy\n  assignment operator, and move assignment operator. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cem\u003eNote: a default implementation is always considered trivial, both when it is explicit (with \u003ccode\u003e\u003d default\u003c/code\u003e) or implicit (if the special\nmember function is omitted).\u003c/em\u003e\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003e\u003ccode\u003ememcpy\u003c/code\u003e, \u003ccode\u003ememmove\u003c/code\u003e, and \u003ccode\u003ememset\u003c/code\u003e should only be called on trivially-copyable objects. Fixing this code defect may\nrequire non-trivial refactoring, as illustrated in the following example.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cp\u003eHere, \u003ccode\u003ecopy\u003c/code\u003e is incorrect because it calls \u003ccode\u003ememcpy\u003c/code\u003e on non-trivial objects.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nclass Resource {\n  Handle* resource_handle;\n\npublic:\n  Resource() {\n    // Acquire the resource handle.\n  }\n\n  ~Resource() {\n    // Release the resource handle.\n  }\n};\n\nvoid copy(Resource* dest, Resource const* source) {\n  memcpy(dest, source, sizeof(Resource)); // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eInstead, the \u003ccode\u003eResource\u003c/code\u003e class can provide a copy assignment operator.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nclass Resource {\n  Handle* resource_handle;\n\npublic:\n  Resource() {\n    // Acquire the resource handle.\n  }\n\n  ~Resource() {\n    // Release the resource handle.\n  }\n\n  Resource\u0026amp; operator\u003d(Resource const\u0026amp; other) {\n    // Non-trivial copy assignement:\n    // copy the handle and update the reference count, etc...\n  }\n};\n\nvoid copy(Resource* dest, Resource const* source) {\n  (*dest) \u003d (*source);\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/classes#Trivially_copyable_class\"\u003eDefinition of a trivially copyable\n  class\u003c/a\u003e. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S5000} - \"memcmp\" should only be called with pointers to trivially copyable types with no padding \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S3549",
    "name": "\"inline\" should not be used redundantly",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eSince C++03, a member function that is contained within a class definition is by definition \u003ccode\u003einline\u003c/code\u003e, so an using an \u003ccode\u003einline\u003c/code\u003e\nspecifier on such functions is redundant.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass Foo {\n  inline void method() { // Noncompliant\n    // ...\n  }\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nclass Foo {\n  void method() {\n    // ...\n  }\n};\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eSince C++03, a member function that is contained within a class definition is by definition \u003ccode\u003einline\u003c/code\u003e, so an using an \u003ccode\u003einline\u003c/code\u003e\nspecifier on such functions is redundant.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass Foo {\n  inline void method() { // Noncompliant\n    // ...\n  }\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nclass Foo {\n  void method() {\n    // ...\n  }\n};\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "clumsy",
      "redundant"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5847",
    "name": "Accessing files should not introduce TOCTOU vulnerabilities",
    "defaultSeverity": "CRITICAL",
    "type": "VULNERABILITY",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "SECURITY": "HIGH"
    },
    "description": "\u003cp\u003eWhen an application manipulates files, \"Time-Of-Check to Time-Of-Use\" can occur when a file-checking operation is disconnected from the actual\noperation it is bound to.\u003c/p\u003e\n\u003cp\u003eFor example, such a vulnerability occurs when a file existence check is performed strictly before a file creation operation.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eRace conditions can happen when file operations and their associated pre-checks are disconnected. Indeed, while the application assumes that the\nchecked file property will not change before performing the operation, there is a chance that changes are applied to the file.\u003c/p\u003e\n\u003cp\u003eEspecially, a concurrent process, which an attacker can control, could modify a file right after a check is performed and before the actual use.\nThis file can be deleted, created, altered, or see its permissions changed depending on the use case.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eThe impact of a successfully exploited race condition is dependent on the business logic of the vulnerable application. The consequences will vary\ndepending on what check is performed and how the file is used.\u003c/p\u003e\n\u003cp\u003eIn general, attackers use such attacks to escalate privileges, execute arbitrary code, or perform a denial of service.\u003c/p\u003e\n\u003ch4\u003eArbitrary code execution\u003c/h4\u003e\n\u003cp\u003eExecutable or script file integrity and authenticity checks can be bypassed when exploiting a TOCTOU vulnerability. In such a scenario, attackers\nwould change an executable file content between when its integrity is checked and when the application executes it.\u003c/p\u003e\n\u003cp\u003eThis attack would allow attackers to trick the application into executing malicious, arbitrary code. They would then be granted the same privilege\nlevels as the application itself, which can be particularly severe when it runs with administration privileges.\u003c/p\u003e\n\u003ch4\u003ePrivileges escalation\u003c/h4\u003e\n\u003cp\u003eWhen the attacker is a local user on the same server as the running application, the same attack is possible with extended probability. In such a\ncase, attackers can exploit the reading and writing to configuration files, the creation of local network resources, or the use of temporary files to\nachieve the same code execution purpose.\u003c/p\u003e\n\u003cp\u003eHowever, in that case, the attack is only meaningful when the application is running with high or otherwise interesting privileges. Attackers\nexploiting a TOCTOU vulnerability that way would achieve horizontal or vertical privilege escalation.\u003c/p\u003e\n\u003ch4\u003eDenial of service\u003c/h4\u003e\n\u003cp\u003eWhen the application expects some file properties to be set at the operation time, it will often face unexpected errors when those properties have\nactually changed. This might be the case when writing to a file where newly set permissions forbid that operation or when reading from a deleted\nfile.\u003c/p\u003e\n\u003cp\u003eWhen such errors are faced, the application might unexpectedly stop, which can affect its availability. Depending on the application and hosting\narchitectures, the interruption can be temporary or permanent, partial or complete.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eTo prevent TOCTOU race condition issues, best practices recommend relying on file operations that can perform the necessary preliminary checks\natomically. For example, file opening functions usually accept a parameter to check the file exists and return an error depending on the result. This\ncheck is atomic and is not susceptible to race conditions.\u003c/p\u003e\n\u003cp\u003eWhen this is not possible, it might be possible to open a file directly, and to keep a reference to it for later use. If the conditions are set for\nthe subsequent operations, the application can continue with its processing and use the open file pointer to read or write to the file. In the\nopposite case, an error might be raised that will need to be properly handled.\u003c/p\u003e\n\u003cp\u003eTo finish, for most complex operations, the application can create a dedicated working directory and set tight permissions on it. This needs to be\nperformed atomically to prevent further race conditions. All subsequent sensitive file operations can then be performed in this dedicated\ndirectory.\u003c/p\u003e\n\u003cp\u003eNote that this last solution is imperfect and is still susceptible to race condition attacks from privileged users and the application itself. It\nshould be used when no other countermeasure is acceptable.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cp\u003eThe following code sample is susceptible to a race condition attack because it checks a file exists strictly before it opens it for writing.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nFILE *fopen_if_not_exists(const char *file) {\n  if (access(file, F_OK) \u003d\u003d -1 \u0026amp;\u0026amp; errno \u003d\u003d ENOENT) {\n    FILE *f \u003d fopen(file, \"w\"); // Noncompliant\n\n    return f;\n  }\n\n  return nullptr;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nFILE *fopen_if_not_exists(const char *file) {\n  FILE *f \u003d fopen(file, \"wx\");\n  return f;\n}\n\u003c/pre\u003e\n\u003ch3\u003eHow does this work?\u003c/h3\u003e\n\u003cp\u003eHere, the compliant code example uses an atomic operation to open the file and check for its existence beforehand.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Carnegie Mellon University Software Engineering Institure - \u003ca\n  href\u003d\"https://wiki.sei.cmu.edu/confluence/display/c/FIO45-C.+Avoid+TOCTOU+race+conditions+while+accessing+files\"\u003eFIO45-C. - Avoid TOCTOU race\n  conditions while accessing files\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e OWASP - \u003ca href\u003d\"https://owasp.org/Top10/A01_2021-Broken_Access_Control/\"\u003eTop 10 2021 Category A1 - Broken Access Control\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e OWASP - \u003ca href\u003d\"https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control\"\u003eTop 10 2017 Category A5 - Broken Access Control\u003c/a\u003e\n  \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/367\"\u003eCWE-367 - Time-of-check Time-of-use (TOCTOU) Race Condition\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eWhen an application manipulates files, \"Time-Of-Check to Time-Of-Use\" can occur when a file-checking operation is disconnected from the actual\noperation it is bound to.\u003c/p\u003e\n\u003cp\u003eFor example, such a vulnerability occurs when a file existence check is performed strictly before a file creation operation.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eRace conditions can happen when file operations and their associated pre-checks are disconnected. Indeed, while the application assumes that the\nchecked file property will not change before performing the operation, there is a chance that changes are applied to the file.\u003c/p\u003e\n\u003cp\u003eEspecially, a concurrent process, which an attacker can control, could modify a file right after a check is performed and before the actual use.\nThis file can be deleted, created, altered, or see its permissions changed depending on the use case.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eThe impact of a successfully exploited race condition is dependent on the business logic of the vulnerable application. The consequences will vary\ndepending on what check is performed and how the file is used.\u003c/p\u003e\n\u003cp\u003eIn general, attackers use such attacks to escalate privileges, execute arbitrary code, or perform a denial of service.\u003c/p\u003e\n\u003ch4\u003eArbitrary code execution\u003c/h4\u003e\n\u003cp\u003eExecutable or script file integrity and authenticity checks can be bypassed when exploiting a TOCTOU vulnerability. In such a scenario, attackers\nwould change an executable file content between when its integrity is checked and when the application executes it.\u003c/p\u003e\n\u003cp\u003eThis attack would allow attackers to trick the application into executing malicious, arbitrary code. They would then be granted the same privilege\nlevels as the application itself, which can be particularly severe when it runs with administration privileges.\u003c/p\u003e\n\u003ch4\u003ePrivileges escalation\u003c/h4\u003e\n\u003cp\u003eWhen the attacker is a local user on the same server as the running application, the same attack is possible with extended probability. In such a\ncase, attackers can exploit the reading and writing to configuration files, the creation of local network resources, or the use of temporary files to\nachieve the same code execution purpose.\u003c/p\u003e\n\u003cp\u003eHowever, in that case, the attack is only meaningful when the application is running with high or otherwise interesting privileges. Attackers\nexploiting a TOCTOU vulnerability that way would achieve horizontal or vertical privilege escalation.\u003c/p\u003e\n\u003ch4\u003eDenial of service\u003c/h4\u003e\n\u003cp\u003eWhen the application expects some file properties to be set at the operation time, it will often face unexpected errors when those properties have\nactually changed. This might be the case when writing to a file where newly set permissions forbid that operation or when reading from a deleted\nfile.\u003c/p\u003e\n\u003cp\u003eWhen such errors are faced, the application might unexpectedly stop, which can affect its availability. Depending on the application and hosting\narchitectures, the interruption can be temporary or permanent, partial or complete.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eTo prevent TOCTOU race condition issues, best practices recommend relying on file operations that can perform the necessary preliminary checks\natomically. For example, file opening functions usually accept a parameter to check the file exists and return an error depending on the result. This\ncheck is atomic and is not susceptible to race conditions.\u003c/p\u003e\n\u003cp\u003eWhen this is not possible, it might be possible to open a file directly, and to keep a reference to it for later use. If the conditions are set for\nthe subsequent operations, the application can continue with its processing and use the open file pointer to read or write to the file. In the\nopposite case, an error might be raised that will need to be properly handled.\u003c/p\u003e\n\u003cp\u003eTo finish, for most complex operations, the application can create a dedicated working directory and set tight permissions on it. This needs to be\nperformed atomically to prevent further race conditions. All subsequent sensitive file operations can then be performed in this dedicated\ndirectory.\u003c/p\u003e\n\u003cp\u003eNote that this last solution is imperfect and is still susceptible to race condition attacks from privileged users and the application itself. It\nshould be used when no other countermeasure is acceptable.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cp\u003eThe following code sample is susceptible to a race condition attack because it checks a file exists strictly before it opens it for writing.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nFILE *fopen_if_not_exists(const char *file) {\n  if (access(file, F_OK) \u003d\u003d -1 \u0026amp;\u0026amp; errno \u003d\u003d ENOENT) {\n    FILE *f \u003d fopen(file, \"w\"); // Noncompliant\n\n    return f;\n  }\n\n  return nullptr;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nFILE *fopen_if_not_exists(const char *file) {\n  FILE *f \u003d fopen(file, \"wx\");\n  return f;\n}\n\u003c/pre\u003e\n\u003ch3\u003eHow does this work?\u003c/h3\u003e\n\u003cp\u003eHere, the compliant code example uses an atomic operation to open the file and check for its existence beforehand.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Carnegie Mellon University Software Engineering Institure - \u003ca\n  href\u003d\"https://wiki.sei.cmu.edu/confluence/display/c/FIO45-C.+Avoid+TOCTOU+race+conditions+while+accessing+files\"\u003eFIO45-C. - Avoid TOCTOU race\n  conditions while accessing files\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e OWASP - \u003ca href\u003d\"https://owasp.org/Top10/A01_2021-Broken_Access_Control/\"\u003eTop 10 2021 Category A1 - Broken Access Control\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e OWASP - \u003ca href\u003d\"https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control\"\u003eTop 10 2017 Category A5 - Broken Access Control\u003c/a\u003e\n  \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/367\"\u003eCWE-367 - Time-of-check Time-of-use (TOCTOU) Race Condition\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cert",
      "cwe"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S3540",
    "name": "Base class access specifiers should not be redundant",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eAdding an access specifier that matches the class\u0027 current access level needlessly clutters the code.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstruct B {\n};\n\nstruct S : public B { // Noncompliant; \"struct\" has public access for its base classes by default\n};\n\nclass C : private B { // Noncompliant; \"class\" has private access for its base classes by default\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstruct B {\n};\n\nstruct S : B {\n};\n\nclass C : B {\n};\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S5965} and {rule:cpp:S5966} are other rules that favor different coding style for base classes. They should not be activated at the\n  same time as this rule. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eAdding an access specifier that matches the class\u0027 current access level needlessly clutters the code.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstruct B {\n};\n\nstruct S : public B { // Noncompliant; \"struct\" has public access for its base classes by default\n};\n\nclass C : private B { // Noncompliant; \"class\" has private access for its base classes by default\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstruct B {\n};\n\nstruct S : B {\n};\n\nclass C : B {\n};\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S5965} and {rule:cpp:S5966} are other rules that favor different coding style for base classes. They should not be activated at the\n  same time as this rule. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "clumsy",
      "redundant"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5962",
    "name": "Threads should not be detached",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eSometimes, you might want to make a thread run indefinitely in the background by not binding it to its creation scope. Even though calling\n\u003ccode\u003edetach()\u003c/code\u003e on an \u003ccode\u003estd::thread\u003c/code\u003e or \u003ccode\u003estd::jthread\u003c/code\u003e object would satisfy this need, it is not the easiest way to do it:\nthere will be no direct way to monitor and communicate with the detached thread, the \u003ccode\u003estd::thread\u003c/code\u003e or \u003ccode\u003estd::jthread\u003c/code\u003e object is\nno longer associated to any thread.\u003c/p\u003e\n\u003cp\u003eAn easier alternative to satisfy this need is giving the thread a global scope. This way the thread will run as long as the program does. The\nthread will not be bound to any scope. It is also possible to do it by giving the \u003ccode\u003estd::thread\u003c/code\u003e or \u003ccode\u003estd::jthread\u003c/code\u003e a scope that\nis big enough for your use case. For example, the program’s main function.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid backgroundTask();\nvoid startBackgroundTask(){\n  // Assume you want the thread to run after the end of startBackgroundTask\n  std::jthread backgroundThread(backgroundTask);\n  backgroundThread.detach(); // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid  backgroundTask();\nstd::jthread backgroundThread;\n\nvoid startBackgroundTask(){\n  // Assume you want the thread to run after the end of startBackgroundTask\n  backgroundThread \u003d std::move(std::jthread{backgroundTask});\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#cp26-dont-detach-a-thread\"\u003eCP.26:\n  Don’t \u003ccode\u003edetach()\u003c/code\u003e a thread\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eSometimes, you might want to make a thread run indefinitely in the background by not binding it to its creation scope. Even though calling\n\u003ccode\u003edetach()\u003c/code\u003e on an \u003ccode\u003estd::thread\u003c/code\u003e or \u003ccode\u003estd::jthread\u003c/code\u003e object would satisfy this need, it is not the easiest way to do it:\nthere will be no direct way to monitor and communicate with the detached thread, the \u003ccode\u003estd::thread\u003c/code\u003e or \u003ccode\u003estd::jthread\u003c/code\u003e object is\nno longer associated to any thread.\u003c/p\u003e\n\u003cp\u003eAn easier alternative to satisfy this need is giving the thread a global scope. This way the thread will run as long as the program does. The\nthread will not be bound to any scope. It is also possible to do it by giving the \u003ccode\u003estd::thread\u003c/code\u003e or \u003ccode\u003estd::jthread\u003c/code\u003e a scope that\nis big enough for your use case. For example, the program’s main function.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid backgroundTask();\nvoid startBackgroundTask(){\n  // Assume you want the thread to run after the end of startBackgroundTask\n  std::jthread backgroundThread(backgroundTask);\n  backgroundThread.detach(); // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid  backgroundTask();\nstd::jthread backgroundThread;\n\nvoid startBackgroundTask(){\n  // Assume you want the thread to run after the end of startBackgroundTask\n  backgroundThread \u003d std::move(std::jthread{backgroundTask});\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#cp26-dont-detach-a-thread\"\u003eCP.26:\n  Don’t \u003ccode\u003edetach()\u003c/code\u003e a thread\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "clumsy",
      "cppcoreguidelines",
      "since-c++11"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S860",
    "name": "Objects with integer type should not be converted to objects with pointer type",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eConverting an integer type to a pointer generally leads to unspecified behavior. There are several cases where it might be legitimate:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Converting the integral literal \u003ccode\u003e0\u003c/code\u003e to the null pointer (but you should use \u003ccode\u003enullptr\u003c/code\u003e instead, see {rule:cpp:S4962}),\n  \u003c/li\u003e\n  \u003cli\u003e Converting back to a pointer a pointer value that was converted to a large enough integer (see {rule:cpp:S1767}), \u003c/li\u003e\n  \u003cli\u003e On embedded devices, device drivers…​ converting a hard-coded address to a pointer to read some specific memory (this often goes together with\n  the use of \u003ccode\u003evolatile\u003c/code\u003e, since such memory values can change from the outside of the program). \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSince even legitimate cases are corner cases that require to be reviewed carefully, this rule simply reports all places where an integer is cast\ninto a pointer (except the literal \u003ccode\u003e0\u003c/code\u003e).\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstruct S {\n  int i;\n  int j;\n};\n\nvoid f(void* a);\n\nvoid g(int i) {\n  S* s1 \u003d (S*)i; // Noncompliant\n  f((void*)i); // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++ 2008, 5-2-8 - An object with integer type or pointer to void type shall not be converted to an object with pointer type. \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/0dUxBQ\"\u003eCERT, INT36-C.\u003c/a\u003e - Converting a pointer to integer or integer to pointer \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eConverting an integer type to a pointer generally leads to unspecified behavior. There are several cases where it might be legitimate:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Converting the integral literal \u003ccode\u003e0\u003c/code\u003e to the null pointer (but you should use \u003ccode\u003enullptr\u003c/code\u003e instead, see {rule:cpp:S4962}),\n  \u003c/li\u003e\n  \u003cli\u003e Converting back to a pointer a pointer value that was converted to a large enough integer (see {rule:cpp:S1767}), \u003c/li\u003e\n  \u003cli\u003e On embedded devices, device drivers…​ converting a hard-coded address to a pointer to read some specific memory (this often goes together with\n  the use of \u003ccode\u003evolatile\u003c/code\u003e, since such memory values can change from the outside of the program). \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSince even legitimate cases are corner cases that require to be reviewed carefully, this rule simply reports all places where an integer is cast\ninto a pointer (except the literal \u003ccode\u003e0\u003c/code\u003e).\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstruct S {\n  int i;\n  int j;\n};\n\nvoid f(void* a);\n\nvoid g(int i) {\n  S* s1 \u003d (S*)i; // Noncompliant\n  f((void*)i); // Noncompliant\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C++ 2008, 5-2-8 - An object with integer type or pointer to void type shall not be converted to an object with pointer type. \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/0dUxBQ\"\u003eCERT, INT36-C.\u003c/a\u003e - Converting a pointer to integer or integer to pointer \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "cert"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1000",
    "name": "Header files should not contain unnamed namespaces",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eAn unnamed namespace will be unique within each translation unit. Any declarations appearing in an unnamed namespace in a header will refer to a\ndifferent entity in each translation unit, which is probably not the expected behavior.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n// Header.hpp\nnamespace                  // Noncompliant\n{\n  extern int32_t x;\n}\n\u003c/pre\u003e\n\u003cpre\u003e\n// File1.cpp\n#include \"Header.hpp\"\n\nnamespace\n{\n  int32_t x;\n}\n\nvoid fn_a(void)\n{\n  x \u003d 42;\n}\n\u003c/pre\u003e\n\u003cpre\u003e\n// File2.cpp\n#include \"Header.hpp\"\n\nnamespace\n{\n  int32_t x;  // this is a different x than in File1.cpp\n}\n\nvoid fn_b(void)\n{\n  fn_a();                  // Is expected to initialize \"x\" to 42\n  if (x \u003d\u003d 42)             // But does not, as there are 2 distinct \"x\" variables\n  {\n  }\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 7-3-3 - There shall be no unnamed namespaces in header files. \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/VXs-BQ\"\u003eCERT, DCL59-CPP.\u003c/a\u003e - Do not define an unnamed namespace in a header file \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eAn unnamed namespace will be unique within each translation unit. Any declarations appearing in an unnamed namespace in a header will refer to a\ndifferent entity in each translation unit, which is probably not the expected behavior.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n// Header.hpp\nnamespace                  // Noncompliant\n{\n  extern int32_t x;\n}\n\u003c/pre\u003e\n\u003cpre\u003e\n// File1.cpp\n#include \"Header.hpp\"\n\nnamespace\n{\n  int32_t x;\n}\n\nvoid fn_a(void)\n{\n  x \u003d 42;\n}\n\u003c/pre\u003e\n\u003cpre\u003e\n// File2.cpp\n#include \"Header.hpp\"\n\nnamespace\n{\n  int32_t x;  // this is a different x than in File1.cpp\n}\n\nvoid fn_b(void)\n{\n  fn_a();                  // Is expected to initialize \"x\" to 42\n  if (x \u003d\u003d 42)             // But does not, as there are 2 distinct \"x\" variables\n  {\n  }\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 7-3-3 - There shall be no unnamed namespaces in header files. \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/VXs-BQ\"\u003eCERT, DCL59-CPP.\u003c/a\u003e - Do not define an unnamed namespace in a header file \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cert",
      "misra-c++2008",
      "pitfall"
    ],
    "deprecatedKeys": [
      "cpp:UnnamedNamespaceInHeader"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1121",
    "name": "Assignments should not be made from within conditions",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eAssigning a value inside a condition (of an \u003ccode\u003eif\u003c/code\u003e statement, a \u003ccode\u003efor\u003c/code\u003e statement, a \u003ccode\u003ewhile\u003c/code\u003e, or a\n\u003ccode\u003eswitch\u003c/code\u003e) can be confusing. It assigns the value and checks it at the same time, but it is easily confused with a simple equality check\nwith \u003ccode\u003e\u003d\u003d\u003c/code\u003e and the original intention can be unclear.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n  if (x \u003d getValue()) { // Noncompliant: assigning and checking. Is it on purpose?\n    doSomething();\n  }\n\u003c/pre\u003e\n\u003cp\u003eIt is better to assign before the statement and use the condition for the check only:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n  x \u003d getValue();\n  if (x) {\n    doSomething();\n  }\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThis rule ignores assignments explicitly enclosed in parentheses.\u003c/p\u003e\n\u003cpre\u003e\nwhile ((run \u003d keepRunning())) {\n  //...\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/481\"\u003e481: Assigning instead of Comparing\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/ZNYxBQ\"\u003eEXP45-C. Do not perform assignments in selection statements\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 13.1 - Assignment operators shall not be used in expressions that yield a Boolean value \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 6-2-1 - Assignment operators shall not be used in sub-expressions \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 13.4 - The result of an assignment operator should not be used \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eAssigning a value inside a condition (of an \u003ccode\u003eif\u003c/code\u003e statement, a \u003ccode\u003efor\u003c/code\u003e statement, a \u003ccode\u003ewhile\u003c/code\u003e, or a\n\u003ccode\u003eswitch\u003c/code\u003e) can be confusing. It assigns the value and checks it at the same time, but it is easily confused with a simple equality check\nwith \u003ccode\u003e\u003d\u003d\u003c/code\u003e and the original intention can be unclear.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n  if (x \u003d getValue()) { // Noncompliant: assigning and checking. Is it on purpose?\n    doSomething();\n  }\n\u003c/pre\u003e\n\u003cp\u003eIt is better to assign before the statement and use the condition for the check only:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n  x \u003d getValue();\n  if (x) {\n    doSomething();\n  }\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThis rule ignores assignments explicitly enclosed in parentheses.\u003c/p\u003e\n\u003cpre\u003e\nwhile ((run \u003d keepRunning())) {\n  //...\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/481\"\u003e481: Assigning instead of Comparing\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/ZNYxBQ\"\u003eEXP45-C. Do not perform assignments in selection statements\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 13.1 - Assignment operators shall not be used in expressions that yield a Boolean value \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 6-2-1 - Assignment operators shall not be used in sub-expressions \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 13.4 - The result of an assignment operator should not be used \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "cert",
      "cwe",
      "suspicious"
    ],
    "deprecatedKeys": [
      "cpp:AssignmentInSubExpression"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1242",
    "name": "Inherited functions should not be hidden",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eAn inherited member function can be hidden in a derived class\u0026nbsp;and that\u0026nbsp;creates a class that behaves differently depending on which\ninterface is used to manipulate it.\u003c/p\u003e\n\u003cp\u003eOverriding happens when the inherited method is virtual and a method declared in the derived class uses the same identifier as well as the same\nsignature (the return types can be different, as long as they are covariant). However, if the inherited method is non-virtual or if the two\ndeclarations of the method do not share the same signature, the method of the base class will be hidden.\u003c/p\u003e\n\u003cp\u003eSuch a class increases the inheritance complexity, and confuses consumers with its non-polymorphic behavior, which can lead to errors.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass Base {\npublic:\n  void shutdown();\n  virtual void log(int a);\n};\n\nclass Derived : public Base {\npublic:\n  void shutdown(); //Noncompliant\n  void log(float a); //Noncompliant\n};\n\nvoid stopServer(Base *obj, Derived *obj2) {\n  obj-\u0026gt;shutdown(); // always calls Base::shutdown even if the given object\u0027s type is Derived\n  obj-\u0026gt;log(2); // calls Base::log(int) even if the given object\u0027s type is Derived\n  obj2-\u0026gt;shutdown(); // calls Derived::shutdown\n  obj2-\u0026gt;log(2); // calls Derived::log(float), even if this requires a conversion int-\u0026gt;float.\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nclass Base {\npublic:\n  void shutdown();\n  virtual void log(int a);\n};\n\nclass Derived : public Base {\npublic:\n  void shutdownAndUpdate(); // Define a method with a different name\n  void log(int a) override; // Or make the method a proper override\n};\n\nvoid stopServer(Base *obj) {\n  obj-\u0026gt;shutdown(); // calls Base::shutdown and there is no confusion\n  obj-\u0026gt;log(2); // calls Derived::log(int) if the given object\u0027s type is Derived\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c138-create-an-overload-set-for-a-derived-class-and-its-bases-with-using\"\u003eC.138: Create an overload set for a derived class and its bases with \u003ccode\u003eusing\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eAn inherited member function can be hidden in a derived class\u0026nbsp;and that\u0026nbsp;creates a class that behaves differently depending on which\ninterface is used to manipulate it.\u003c/p\u003e\n\u003cp\u003eOverriding happens when the inherited method is virtual and a method declared in the derived class uses the same identifier as well as the same\nsignature (the return types can be different, as long as they are covariant). However, if the inherited method is non-virtual or if the two\ndeclarations of the method do not share the same signature, the method of the base class will be hidden.\u003c/p\u003e\n\u003cp\u003eSuch a class increases the inheritance complexity, and confuses consumers with its non-polymorphic behavior, which can lead to errors.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass Base {\npublic:\n  void shutdown();\n  virtual void log(int a);\n};\n\nclass Derived : public Base {\npublic:\n  void shutdown(); //Noncompliant\n  void log(float a); //Noncompliant\n};\n\nvoid stopServer(Base *obj, Derived *obj2) {\n  obj-\u0026gt;shutdown(); // always calls Base::shutdown even if the given object\u0027s type is Derived\n  obj-\u0026gt;log(2); // calls Base::log(int) even if the given object\u0027s type is Derived\n  obj2-\u0026gt;shutdown(); // calls Derived::shutdown\n  obj2-\u0026gt;log(2); // calls Derived::log(float), even if this requires a conversion int-\u0026gt;float.\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nclass Base {\npublic:\n  void shutdown();\n  virtual void log(int a);\n};\n\nclass Derived : public Base {\npublic:\n  void shutdownAndUpdate(); // Define a method with a different name\n  void log(int a) override; // Or make the method a proper override\n};\n\nvoid stopServer(Base *obj) {\n  obj-\u0026gt;shutdown(); // calls Base::shutdown and there is no confusion\n  obj-\u0026gt;log(2); // calls Derived::log(int) if the given object\u0027s type is Derived\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c138-create-an-overload-set-for-a-derived-class-and-its-bases-with-using\"\u003eC.138: Create an overload set for a derived class and its bases with \u003ccode\u003eusing\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "confusing",
      "cppcoreguidelines"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S3542",
    "name": "Digit separators should be used",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "FORMATTED",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eC++14 adds the ability to write numbers with digit separators for better readability. Splitting a number that has more than 4 consecutive digits\nimproves readability.\u003c/p\u003e\n\u003cp\u003eThis rule verifies that numbers are written using digit separators when they have more than 4 consecutive digits.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nlong decimal_int_value     \u003d 5543124;            // Noncompliant; insert \u0027 between groups of 3 digits.\ndouble decimal_float_value \u003d 7918714.3456;       // Noncompliant; insert \u0027 between groups of 3 digits.\nlong hexadecimal_value     \u003d 0x83A32486E2;       // Noncompliant; insert \u0027 between groups of 2 or 4 digits.\nlong octal_value           \u003d 04420343313726;     // Noncompliant; insert \u0027 between groups of 2, 3 or 4 digits.\nlong binary_value          \u003d 0b0101011011101010; // Noncompliant; insert \u0027 between groups of 2, 3 or 4 digits.\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nlong decimal_int_value     \u003d 5\u0027543\u0027124;\ndouble decimal_float_value \u003d 7\u0027918\u0027714.3456;\nlong hexadecimal_value     \u003d 0x83\u0027A324\u002786E2;\nlong octal_value           \u003d 04\u00274203\u00274331\u00273726;\nlong binary_value          \u003d 0b0101\u00270110\u00271110\u00271010;\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eNo issue is raised on the fractional or exponent part of floating point numbers, only the integral part should comply.\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eC++14 adds the ability to write numbers with digit separators for better readability. Splitting a number that has more than 4 consecutive digits\nimproves readability.\u003c/p\u003e\n\u003cp\u003eThis rule verifies that numbers are written using digit separators when they have more than 4 consecutive digits.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nlong decimal_int_value     \u003d 5543124;            // Noncompliant; insert \u0027 between groups of 3 digits.\ndouble decimal_float_value \u003d 7918714.3456;       // Noncompliant; insert \u0027 between groups of 3 digits.\nlong hexadecimal_value     \u003d 0x83A32486E2;       // Noncompliant; insert \u0027 between groups of 2 or 4 digits.\nlong octal_value           \u003d 04420343313726;     // Noncompliant; insert \u0027 between groups of 2, 3 or 4 digits.\nlong binary_value          \u003d 0b0101011011101010; // Noncompliant; insert \u0027 between groups of 2, 3 or 4 digits.\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nlong decimal_int_value     \u003d 5\u0027543\u0027124;\ndouble decimal_float_value \u003d 7\u0027918\u0027714.3456;\nlong hexadecimal_value     \u003d 0x83\u0027A324\u002786E2;\nlong octal_value           \u003d 04\u00274203\u00274331\u00273726;\nlong binary_value          \u003d 0b0101\u00270110\u00271110\u00271010;\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eNo issue is raised on the fractional or exponent part of floating point numbers, only the integral part should comply.\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "clumsy",
      "since-c++14"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1001",
    "name": "\"using-directives\" should not be used",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eusing\u003c/code\u003e directives add additional scopes to the set of scopes searched during name lookup. All identifiers in these scopes become\nvisible, increasing the possibility that the identifier found by the compiler does not meet developer expectations.\u003c/p\u003e\n\u003cp\u003eUsing-declarations or fully-qualified names restricts the set of names considered to only the name explicitly specified, and so these are safer\noptions.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nnamespace NS1 {\n  int f();\n}\n\nusing namespace NS1; // Noncompliant\n\nvoid g() {\n  f();\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nnamespace NS1 {\n  int f();\n}\n\nvoid g() {\n  NS1::f();\n}\n\n// Or\n\nusing NS1::f; // Compliant, this is a using declaration\n\nvoid g() {\n  f();\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 7-3-4 - using-directives shall not be used. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003ccode\u003eusing\u003c/code\u003e directives add additional scopes to the set of scopes searched during name lookup. All identifiers in these scopes become\nvisible, increasing the possibility that the identifier found by the compiler does not meet developer expectations.\u003c/p\u003e\n\u003cp\u003eUsing-declarations or fully-qualified names restricts the set of names considered to only the name explicitly specified, and so these are safer\noptions.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nnamespace NS1 {\n  int f();\n}\n\nusing namespace NS1; // Noncompliant\n\nvoid g() {\n  f();\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nnamespace NS1 {\n  int f();\n}\n\nvoid g() {\n  NS1::f();\n}\n\n// Or\n\nusing NS1::f; // Compliant, this is a using declaration\n\nvoid g() {\n  f();\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 7-3-4 - using-directives shall not be used. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "pitfall"
    ],
    "deprecatedKeys": [
      "cpp:UsingDirective"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S3541",
    "name": "Allocation and deallocation functions should not be explicitly declared \"static\"",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eAllocation functions are always \u003ccode\u003estatic\u003c/code\u003e. Explicitly declaring such a function \u003ccode\u003estatic\u003c/code\u003e needlessly clutters the code.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstruct S {\n  static void* operator new(std::size_t); // Noncompliant; static is redundant\n  static void  operator delete(void*);    // Noncompliant; static is redundant\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstruct S {\n  void* operator new(std::size_t);\n  void  operator delete(void*);\n};\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e Reference: Since C++98 (ISO IEC 14882 1998) 12.5 §1 and §6 \u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n  \u003cp\u003eAny allocation function for a class T is a static member (even if not explicitly declared static).\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n  \u003cp\u003eAny deallocation function for a class X is a static member (even if not explicitly declared static).\u003c/p\u003e\n\u003c/blockquote\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eAllocation functions are always \u003ccode\u003estatic\u003c/code\u003e. Explicitly declaring such a function \u003ccode\u003estatic\u003c/code\u003e needlessly clutters the code.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstruct S {\n  static void* operator new(std::size_t); // Noncompliant; static is redundant\n  static void  operator delete(void*);    // Noncompliant; static is redundant\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstruct S {\n  void* operator new(std::size_t);\n  void  operator delete(void*);\n};\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e Reference: Since C++98 (ISO IEC 14882 1998) 12.5 §1 and §6 \u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n  \u003cp\u003eAny allocation function for a class T is a static member (even if not explicitly declared static).\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n  \u003cp\u003eAny deallocation function for a class X is a static member (even if not explicitly declared static).\u003c/p\u003e\n\u003c/blockquote\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "clumsy",
      "redundant"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1002",
    "name": "Multiple declarations for an identifier in the same namespace shall not straddle a using-declaration for that identifier",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThis rule is a strict implementation of a MISRA (Motor Industry Software Reliability Association) rule. MISRA defines best practices for developing\nsafety-critical software. You can learn more about this rule in the MISRA documents referenced below.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++ 2008, 7-3-5 - Multiple declarations for an identifier in the same namespace shall not straddle a using-declaration for that\n  identifier. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThis rule is a strict implementation of a MISRA (Motor Industry Software Reliability Association) rule. MISRA defines best practices for developing\nsafety-critical software. You can learn more about this rule in the MISRA documents referenced below.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C++ 2008, 7-3-5 - Multiple declarations for an identifier in the same namespace shall not straddle a using-declaration for that\n  identifier. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "misra-c++2008"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1123",
    "name": "Deprecated attributes should include explanations",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003edeprecated\u003c/code\u003e attribute can be applied with or without explanations, but marking something \u003ccode\u003edeprecated\u003c/code\u003e without including\nadvice as to why it’s deprecated or on what to use instead will lead maintainers to waste time trying to figure those things out - every single time\nthe warning is encountered.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n[[deprecated]] // Noncompliant\nvoid foo1();\n\n__attribute__((deprecated)) // Noncompliant\nvoid foo2();\n\n__declspec(deprecated) // Noncompliant\nvoid foo3();\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n[[deprecated(\"use \u0027bar\u0027 instead\")]]\nvoid foo1();\n\n__attribute__((deprecated(\"use \u0027bar\u0027 instead\")))\nvoid foo2();\n\n__declspec(deprecated(\"use \u0027bar\u0027 instead\"))\nvoid foo3();\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe \u003ccode\u003edeprecated\u003c/code\u003e attribute can be applied with or without explanations, but marking something \u003ccode\u003edeprecated\u003c/code\u003e without including\nadvice as to why it’s deprecated or on what to use instead will lead maintainers to waste time trying to figure those things out - every single time\nthe warning is encountered.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n[[deprecated]] // Noncompliant\nvoid foo1();\n\n__attribute__((deprecated)) // Noncompliant\nvoid foo2();\n\n__declspec(deprecated) // Noncompliant\nvoid foo3();\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n[[deprecated(\"use \u0027bar\u0027 instead\")]]\nvoid foo1();\n\n__attribute__((deprecated(\"use \u0027bar\u0027 instead\")))\nvoid foo2();\n\n__declspec(deprecated(\"use \u0027bar\u0027 instead\"))\nvoid foo3();\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "bad-practice",
      "obsolete"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1244",
    "name": "Floating point numbers should not be tested for equality",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eFloating point math is imprecise because of the challenges of storing such values in a binary representation. Even worse, floating point math is\nnot associative; push a \u003ccode\u003efloat\u003c/code\u003e or a \u003ccode\u003edouble\u003c/code\u003e through a series of simple mathematical operations and the answer will be\ndifferent based on the order of those operation because of the rounding that takes place at each step.\u003c/p\u003e\n\u003cp\u003eEven simple floating point assignments are not simple:\u003c/p\u003e\n\u003cpre\u003e\nfloat f \u003d 0.1; // 0.100000001490116119384765625\ndouble d \u003d 0.1; // 0.1000000000000000055511151231257827021181583404541015625\n\u003c/pre\u003e\n\u003cp\u003e(Results will vary based on compiler and compiler settings.)\u003c/p\u003e\n\u003cp\u003eTherefore, the use of the equality (\u003ccode\u003e\u003d\u003d\u003c/code\u003e) and inequality (\u003ccode\u003e!\u003d\u003c/code\u003e) operators on \u003ccode\u003efloat\u003c/code\u003e or \u003ccode\u003edouble\u003c/code\u003e values\nis very often an error.\u003c/p\u003e\n\u003cp\u003eThe accepted solution is to use or write a float comparison library:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Either using a comparison taking into account the magnitude of the numbers being compared and an epsilon value (which may be based on the\n  capability of the floating point epsilon (FLT_EPSILON)). This comparison will often be absolute for very small values, and relative for larger ones\n  \u003c/li\u003e\n  \u003cli\u003e Or using the notion of \u003ca href\u003d\"https://en.wikipedia.org/wiki/Unit_in_the_last_place\"\u003eunits in the last place\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis rule checks for the use of equality/inequality tests on \u003ccode\u003efloat\u003c/code\u003es, \u003ccode\u003edouble\u003c/code\u003es and \u003ccode\u003elong double\u003c/code\u003es.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nfloat myNumber \u003d 3.146;\nif ( myNumber \u003d\u003d 3.146 ) {  //Noncompliant. Because of floating point imprecision, this will be false\n  // ...\n}\n\nif (myNumber \u0026lt;\u003d 3.146 \u0026amp;\u0026amp; mNumber \u0026gt;\u003d 3.146) { // Noncompliant indirect equality test\n  // ...\n}\n\nif (myNumber \u0026lt; 4 || myNumber \u0026gt; 4) { // Noncompliant indirect inequality test\n  // ...\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 13.3 - Floating-point expressions shall not be tested for equality or inequality. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 6-2-2 - Floating-point expressions shall not be directly or indirectly tested for equality or inequality \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/\"\u003eComparing Floating Point Numbers, 2012\n  Edition\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eFloating point math is imprecise because of the challenges of storing such values in a binary representation. Even worse, floating point math is\nnot associative; push a \u003ccode\u003efloat\u003c/code\u003e or a \u003ccode\u003edouble\u003c/code\u003e through a series of simple mathematical operations and the answer will be\ndifferent based on the order of those operation because of the rounding that takes place at each step.\u003c/p\u003e\n\u003cp\u003eEven simple floating point assignments are not simple:\u003c/p\u003e\n\u003cpre\u003e\nfloat f \u003d 0.1; // 0.100000001490116119384765625\ndouble d \u003d 0.1; // 0.1000000000000000055511151231257827021181583404541015625\n\u003c/pre\u003e\n\u003cp\u003e(Results will vary based on compiler and compiler settings.)\u003c/p\u003e\n\u003cp\u003eTherefore, the use of the equality (\u003ccode\u003e\u003d\u003d\u003c/code\u003e) and inequality (\u003ccode\u003e!\u003d\u003c/code\u003e) operators on \u003ccode\u003efloat\u003c/code\u003e or \u003ccode\u003edouble\u003c/code\u003e values\nis very often an error.\u003c/p\u003e\n\u003cp\u003eThe accepted solution is to use or write a float comparison library:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Either using a comparison taking into account the magnitude of the numbers being compared and an epsilon value (which may be based on the\n  capability of the floating point epsilon (FLT_EPSILON)). This comparison will often be absolute for very small values, and relative for larger ones\n  \u003c/li\u003e\n  \u003cli\u003e Or using the notion of \u003ca href\u003d\"https://en.wikipedia.org/wiki/Unit_in_the_last_place\"\u003eunits in the last place\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis rule checks for the use of equality/inequality tests on \u003ccode\u003efloat\u003c/code\u003es, \u003ccode\u003edouble\u003c/code\u003es and \u003ccode\u003elong double\u003c/code\u003es.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nfloat myNumber \u003d 3.146;\nif ( myNumber \u003d\u003d 3.146 ) {  //Noncompliant. Because of floating point imprecision, this will be false\n  // ...\n}\n\nif (myNumber \u0026lt;\u003d 3.146 \u0026amp;\u0026amp; mNumber \u0026gt;\u003d 3.146) { // Noncompliant indirect equality test\n  // ...\n}\n\nif (myNumber \u0026lt; 4 || myNumber \u0026gt; 4) { // Noncompliant indirect inequality test\n  // ...\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 13.3 - Floating-point expressions shall not be tested for equality or inequality. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 6-2-2 - Floating-point expressions shall not be directly or indirectly tested for equality or inequality \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/\"\u003eComparing Floating Point Numbers, 2012\n  Edition\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "based-on-misra"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S4997",
    "name": "\"std::auto_ptr\" should not be used",
    "defaultSeverity": "BLOCKER",
    "type": "BUG",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003estd::auto_ptr\u003c/code\u003e was a pre-C++11 attempt to do what \u003ccode\u003estd::unique_ptr\u003c/code\u003e now does. Unfortunately, the move semantics needed to\nmake it work properly weren’t in place, so copying a \u003ccode\u003estd::auto_ptr\u003c/code\u003e has the very surprising behavior of invalidating the source of the\ncopy.\u003c/p\u003e\n\u003cp\u003eThat problem has been fixed with \u003ccode\u003estd::unique_ptr\u003c/code\u003e, so \u003ccode\u003estd::auto_ptr\u003c/code\u003e has been deprecated in C++11 and removed in C++17.\u003c/p\u003e\n\u003cp\u003eIf your compiler allows it, you should replace all use of \u003ccode\u003estd::auto_ptr\u003c/code\u003e with \u003ccode\u003estd::unique_ptr\u003c/code\u003e. Otherwise, define your own\n(non-copyable) smart pointer.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid draw(std::auto_ptr\u0026lt;Shape\u0026gt; p) { // Noncompliant\n    std::cout \u0026lt;\u0026lt; s-\u0026gt;x() \u0026lt;\u0026lt; \", \" \u0026lt;\u0026lt; s.y() \u0026lt;\u0026lt; std::endl;\n}\n\nvoid f() {\n    std::auto_ptr\u0026lt;Shape\u0026gt; s \u003d createShape(); // Noncompliant\n    draw(s); // This call invalidates s\n    draw(s); // This call will crash, because s is null\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid draw(std::unique_ptr\u0026lt;Shape\u0026gt; p) { // Compliant\n    std::cout \u0026lt;\u0026lt; s-\u0026gt;x() \u0026lt;\u0026lt; \", \" \u0026lt;\u0026lt; s.y() \u0026lt;\u0026lt; std::endl;\n}\n\nvoid f() {\n    std::unique_ptr\u0026lt;Shape\u0026gt; s \u003d createShape();\n    // draw(s); // Would not compile\n    draw(move(s)); // Will compile, and the user knows s has been invalidated\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/memory/unique_ptr\"\u003estd::unique_ptr\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003ccode\u003estd::auto_ptr\u003c/code\u003e was a pre-C++11 attempt to do what \u003ccode\u003estd::unique_ptr\u003c/code\u003e now does. Unfortunately, the move semantics needed to\nmake it work properly weren’t in place, so copying a \u003ccode\u003estd::auto_ptr\u003c/code\u003e has the very surprising behavior of invalidating the source of the\ncopy.\u003c/p\u003e\n\u003cp\u003eThat problem has been fixed with \u003ccode\u003estd::unique_ptr\u003c/code\u003e, so \u003ccode\u003estd::auto_ptr\u003c/code\u003e has been deprecated in C++11 and removed in C++17.\u003c/p\u003e\n\u003cp\u003eIf your compiler allows it, you should replace all use of \u003ccode\u003estd::auto_ptr\u003c/code\u003e with \u003ccode\u003estd::unique_ptr\u003c/code\u003e. Otherwise, define your own\n(non-copyable) smart pointer.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid draw(std::auto_ptr\u0026lt;Shape\u0026gt; p) { // Noncompliant\n    std::cout \u0026lt;\u0026lt; s-\u0026gt;x() \u0026lt;\u0026lt; \", \" \u0026lt;\u0026lt; s.y() \u0026lt;\u0026lt; std::endl;\n}\n\nvoid f() {\n    std::auto_ptr\u0026lt;Shape\u0026gt; s \u003d createShape(); // Noncompliant\n    draw(s); // This call invalidates s\n    draw(s); // This call will crash, because s is null\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid draw(std::unique_ptr\u0026lt;Shape\u0026gt; p) { // Compliant\n    std::cout \u0026lt;\u0026lt; s-\u0026gt;x() \u0026lt;\u0026lt; \", \" \u0026lt;\u0026lt; s.y() \u0026lt;\u0026lt; std::endl;\n}\n\nvoid f() {\n    std::unique_ptr\u0026lt;Shape\u0026gt; s \u003d createShape();\n    // draw(s); // Would not compile\n    draw(move(s)); // Will compile, and the user knows s has been invalidated\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/memory/unique_ptr\"\u003estd::unique_ptr\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "since-c++11",
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5965",
    "name": "Classes should explicitly specify the access level when specifying base classes",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhen specifying base classes for a class, the access level is private by default. While private inheritance has its uses, it is far less used than\npublic inheritance. Therefore:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Either you want public inheritance, and you have to specify it \u003c/li\u003e\n  \u003cli\u003e Or you want private inheritance, and you should be explicit about this design decision, by specifying it too. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass B {\n};\n\nclass C : B {\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nclass B {\n};\n\nclass C :  private B { // Or public, if it was private by mistake\n};\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S5966} is a similar rule that deals with base visibility in structs \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S3540} is another rule that favors a different coding style for base classes. It should not be activated at the same time as this\n  rule. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhen specifying base classes for a class, the access level is private by default. While private inheritance has its uses, it is far less used than\npublic inheritance. Therefore:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Either you want public inheritance, and you have to specify it \u003c/li\u003e\n  \u003cli\u003e Or you want private inheritance, and you should be explicit about this design decision, by specifying it too. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass B {\n};\n\nclass C : B {\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nclass B {\n};\n\nclass C :  private B { // Or public, if it was private by mistake\n};\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S5966} is a similar rule that deals with base visibility in structs \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S3540} is another rule that favors a different coding style for base classes. It should not be activated at the same time as this\n  rule. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1003",
    "name": "\"using namespace\" directives should not be used in header files",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eA using directive makes names from another namespace available in the current scope. It should only be used when those names do not create an\nambiguity with other names, otherwise, it is better to fully qualify the names you want to use.\u003c/p\u003e\n\u003cp\u003eWhen you write a header file, you don’t know from which context it will be included. Therefore, if this header contains using directives, you\ncannot be sure that they will not create ambiguities in that context. Those ambiguities could lead to compilation failures or, worse, to a different\nfunction being selected by overload resolution depending on the order of inclusion of headers.\u003c/p\u003e\n\u003cp\u003eA using declaration behaves in the same way but only for one name. Because of their much narrower scope, this rule does not apply to using\ndeclarations.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n// f1.h\nvoid foo ( char_t a );\nnamespace NS1\n{\n  void foo( int32_t a );\n}\n\ninline void bar ( )\n{\n  foo ( 0 );\n}\n\n// f2.h\nnamespace NS1\n{\n}\nusing namespace NS1; // Noncompliant\n\n// f1.cc\n#include \"f1.h\"\n#include \"f2.h\"\n\nint32_t m1 ( )\n{\n  bar ( ); // bar calls foo ( char_t );\n}\n\n// f2.cc\n#include \"f2.h\"\n#include \"f1.h\"\nvoid m2 ( )\n{\n  bar ( ); // bar calls foo ( int32_t );\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThe issue only happens if the using directive is at global scope or at namespace scope. If is is inside a function body, it will cease to be in\neffect at the end of the current scope, and will not propagate to the users of the header file.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 7-3-6 - using-directives and using-declarations (excluding class scope or function scope using-declarations) shall not be used\n  in header files. \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#sf7-dont-write-using-namespace-at-global-scope-in-a-header-file\"\u003eSF.7: Don’t write \u003ccode\u003eusing namespace\u003c/code\u003e at global scope in a header file\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eA using directive makes names from another namespace available in the current scope. It should only be used when those names do not create an\nambiguity with other names, otherwise, it is better to fully qualify the names you want to use.\u003c/p\u003e\n\u003cp\u003eWhen you write a header file, you don’t know from which context it will be included. Therefore, if this header contains using directives, you\ncannot be sure that they will not create ambiguities in that context. Those ambiguities could lead to compilation failures or, worse, to a different\nfunction being selected by overload resolution depending on the order of inclusion of headers.\u003c/p\u003e\n\u003cp\u003eA using declaration behaves in the same way but only for one name. Because of their much narrower scope, this rule does not apply to using\ndeclarations.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n// f1.h\nvoid foo ( char_t a );\nnamespace NS1\n{\n  void foo( int32_t a );\n}\n\ninline void bar ( )\n{\n  foo ( 0 );\n}\n\n// f2.h\nnamespace NS1\n{\n}\nusing namespace NS1; // Noncompliant\n\n// f1.cc\n#include \"f1.h\"\n#include \"f2.h\"\n\nint32_t m1 ( )\n{\n  bar ( ); // bar calls foo ( char_t );\n}\n\n// f2.cc\n#include \"f2.h\"\n#include \"f1.h\"\nvoid m2 ( )\n{\n  bar ( ); // bar calls foo ( int32_t );\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThe issue only happens if the using directive is at global scope or at namespace scope. If is is inside a function body, it will cease to be in\neffect at the end of the current scope, and will not propagate to the users of the header file.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 7-3-6 - using-directives and using-declarations (excluding class scope or function scope using-declarations) shall not be used\n  in header files. \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#sf7-dont-write-using-namespace-at-global-scope-in-a-header-file\"\u003eSF.7: Don’t write \u003ccode\u003eusing namespace\u003c/code\u003e at global scope in a header file\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "cppcoreguidelines",
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S3543",
    "name": "Standard groupings should be used with digit separators",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eC++14 introduced the ability to use a digit separator (\u003ccode\u003e\u0027\u003c/code\u003e) to split a literal number into groups of digits for better readability.\u003c/p\u003e\n\u003cp\u003eTo ensure that readability is really improved by using digit separators, this rule verifies:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003cstrong\u003eHomogeneity\u003c/strong\u003e\n    \u003cul\u003e\n      \u003cli\u003e Except for the left-most group, which can be smaller, all groups in a number should contain the same number of digits. Mixing group sizes\n      is at best confusing for maintainers, and at worst a typographical error that is potentially a bug. \u003c/li\u003e\n    \u003c/ul\u003e  \u003c/li\u003e\n  \u003cli\u003e \u003cstrong\u003eStandardization\u003c/strong\u003e\n    \u003cul\u003e\n      \u003cli\u003e It is also confusing to regroup digits using a size that is not standard. This rule enforce the following standards:\n        \u003cul\u003e\n          \u003cli\u003e Decimal numbers should be separated using groups of 3 digits. \u003c/li\u003e\n          \u003cli\u003e Hexadecimal numbers should be separated using groups of 2 or 4 digits. \u003c/li\u003e\n          \u003cli\u003e Octal and Binary should be separated using groups of 2, 3 or 4 digits. \u003c/li\u003e\n        \u003c/ul\u003e  \u003c/li\u003e\n    \u003c/ul\u003e  \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eFurthermore, using groups with more than 4 consecutive digits is not allowed because they are difficult for maintainers to read.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nlong decimal_int_value     \u003d 1\u0027554\u00273124;          // Noncompliant; mixing groups of 3 and 4 digits\ndouble decimal_float_value \u003d 7\u002791\u002787\u002714.3456;     // Noncompliant; using groups of 2 instead of 3 digits\nlong hexadecimal_value     \u003d 0x8\u00273A3\u0027248\u00276E2;     // Noncompliant; using groups of 3 instead of 2 or 4 digits\nlong octal_value           \u003d 0442\u002703433\u002713726;    // Noncompliant; using groups of 5 instead of 2, 3 or 4 digits.\nlong binary_value          \u003d 0b01010110\u002711101010; // Noncompliant; using groups of 8 instead of 2, 3 or 4 digits.\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nlong decimal_int_value     \u003d 15\u0027543\u0027124;\ndouble decimal_float_value \u003d 7\u0027918\u0027714.3456;\nlong hexadecimal_value     \u003d 0x83\u0027A324\u002786E2;\nlong octal_value           \u003d 04\u00274203\u00274331\u00273726;\nlong binary_value          \u003d 0b0101\u00270110\u00271110\u00271010;\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eNo issue is raised on the fractional or exponent part of floating point numbers, only the integral part should comply.\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eC++14 introduced the ability to use a digit separator (\u003ccode\u003e\u0027\u003c/code\u003e) to split a literal number into groups of digits for better readability.\u003c/p\u003e\n\u003cp\u003eTo ensure that readability is really improved by using digit separators, this rule verifies:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003cstrong\u003eHomogeneity\u003c/strong\u003e\n    \u003cul\u003e\n      \u003cli\u003e Except for the left-most group, which can be smaller, all groups in a number should contain the same number of digits. Mixing group sizes\n      is at best confusing for maintainers, and at worst a typographical error that is potentially a bug. \u003c/li\u003e\n    \u003c/ul\u003e  \u003c/li\u003e\n  \u003cli\u003e \u003cstrong\u003eStandardization\u003c/strong\u003e\n    \u003cul\u003e\n      \u003cli\u003e It is also confusing to regroup digits using a size that is not standard. This rule enforce the following standards:\n        \u003cul\u003e\n          \u003cli\u003e Decimal numbers should be separated using groups of 3 digits. \u003c/li\u003e\n          \u003cli\u003e Hexadecimal numbers should be separated using groups of 2 or 4 digits. \u003c/li\u003e\n          \u003cli\u003e Octal and Binary should be separated using groups of 2, 3 or 4 digits. \u003c/li\u003e\n        \u003c/ul\u003e  \u003c/li\u003e\n    \u003c/ul\u003e  \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eFurthermore, using groups with more than 4 consecutive digits is not allowed because they are difficult for maintainers to read.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nlong decimal_int_value     \u003d 1\u0027554\u00273124;          // Noncompliant; mixing groups of 3 and 4 digits\ndouble decimal_float_value \u003d 7\u002791\u002787\u002714.3456;     // Noncompliant; using groups of 2 instead of 3 digits\nlong hexadecimal_value     \u003d 0x8\u00273A3\u0027248\u00276E2;     // Noncompliant; using groups of 3 instead of 2 or 4 digits\nlong octal_value           \u003d 0442\u002703433\u002713726;    // Noncompliant; using groups of 5 instead of 2, 3 or 4 digits.\nlong binary_value          \u003d 0b01010110\u002711101010; // Noncompliant; using groups of 8 instead of 2, 3 or 4 digits.\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nlong decimal_int_value     \u003d 15\u0027543\u0027124;\ndouble decimal_float_value \u003d 7\u0027918\u0027714.3456;\nlong hexadecimal_value     \u003d 0x83\u0027A324\u002786E2;\nlong octal_value           \u003d 04\u00274203\u00274331\u00273726;\nlong binary_value          \u003d 0b0101\u00270110\u00271110\u00271010;\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eNo issue is raised on the fractional or exponent part of floating point numbers, only the integral part should comply.\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "pitfall",
      "since-c++14"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S4998",
    "name": "Function parameters should not be of type \"std::unique_ptr\u003cT\u003e const \u0026\"",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eIf you use \u003ccode\u003estd::unique_ptr\u0026lt;T\u0026gt; const \u0026amp;\u003c/code\u003e for a function parameter type, it means that the function will not be able to alter\nthe ownership of the pointed-to object by the \u003ccode\u003eunique_ptr\u003c/code\u003e:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e It cannot acquire ownership of the pointed-to object (this would require a parameter of type \u003ccode\u003estd::unique_ptr\u0026lt;T\u0026gt;\u003c/code\u003e) \u003c/li\u003e\n  \u003cli\u003e It cannot transfer the object ownership to someone else (this would require a \u003ccode\u003estd::unique_ptr\u0026lt;T\u0026gt; \u0026amp;\u003c/code\u003e). \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThat means the function can only observe the pointed-to object, and in this case, passing a \u003ccode\u003eT*\u003c/code\u003e (if the \u003ccode\u003eunique_ptr\u003c/code\u003e can be\nnull) or a \u003ccode\u003eT\u0026amp;\u003c/code\u003e (if it cannot) provides the same features, while also allowing the function to work with objects that are not handled\nby a \u003ccode\u003eunique_ptr\u003c/code\u003e (e.g., objects on the stack, in a \u003ccode\u003evector\u003c/code\u003e, or in another kind of smart pointer), thus making the function\nmore general-purpose.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid draw(std::unique_ptr\u0026lt;Shape\u0026gt; const \u0026amp;shape); // Noncompliant\n\nvoid drawAll(std::vector\u0026lt;std::unique_ptr\u0026lt;Shape\u0026gt;\u0026gt; v)\n{\n  for (auto \u0026amp;shape : v) {\n      if (shape) {\n        draw(shape);\n      }\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid draw(Shape const \u0026amp;shape); // Compliant\n\nvoid drawAll(std::vector\u0026lt;std::unique_ptr\u0026lt;Shape\u0026gt;\u0026gt; v)\n{\n  for (auto \u0026amp;shape : v) {\n      if (shape) {\n        draw(*shape);\n      }\n  }\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/memory/unique_ptr\"\u003estd::unique_ptr\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#r32-take-a-unique_ptrwidget-parameter-to-express-that-a-function-assumes-ownership-of-a-widget\"\u003eR.32: Take a \u003ccode\u003eunique_ptr\u0026lt;widget\u0026gt;\u003c/code\u003e parameter to express that a function assumes ownership of a \u003ccode\u003ewidget\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eIf you use \u003ccode\u003estd::unique_ptr\u0026lt;T\u0026gt; const \u0026amp;\u003c/code\u003e for a function parameter type, it means that the function will not be able to alter\nthe ownership of the pointed-to object by the \u003ccode\u003eunique_ptr\u003c/code\u003e:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e It cannot acquire ownership of the pointed-to object (this would require a parameter of type \u003ccode\u003estd::unique_ptr\u0026lt;T\u0026gt;\u003c/code\u003e) \u003c/li\u003e\n  \u003cli\u003e It cannot transfer the object ownership to someone else (this would require a \u003ccode\u003estd::unique_ptr\u0026lt;T\u0026gt; \u0026amp;\u003c/code\u003e). \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThat means the function can only observe the pointed-to object, and in this case, passing a \u003ccode\u003eT*\u003c/code\u003e (if the \u003ccode\u003eunique_ptr\u003c/code\u003e can be\nnull) or a \u003ccode\u003eT\u0026amp;\u003c/code\u003e (if it cannot) provides the same features, while also allowing the function to work with objects that are not handled\nby a \u003ccode\u003eunique_ptr\u003c/code\u003e (e.g., objects on the stack, in a \u003ccode\u003evector\u003c/code\u003e, or in another kind of smart pointer), thus making the function\nmore general-purpose.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid draw(std::unique_ptr\u0026lt;Shape\u0026gt; const \u0026amp;shape); // Noncompliant\n\nvoid drawAll(std::vector\u0026lt;std::unique_ptr\u0026lt;Shape\u0026gt;\u0026gt; v)\n{\n  for (auto \u0026amp;shape : v) {\n      if (shape) {\n        draw(shape);\n      }\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid draw(Shape const \u0026amp;shape); // Compliant\n\nvoid drawAll(std::vector\u0026lt;std::unique_ptr\u0026lt;Shape\u0026gt;\u0026gt; v)\n{\n  for (auto \u0026amp;shape : v) {\n      if (shape) {\n        draw(*shape);\n      }\n  }\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/memory/unique_ptr\"\u003estd::unique_ptr\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#r32-take-a-unique_ptrwidget-parameter-to-express-that-a-function-assumes-ownership-of-a-widget\"\u003eR.32: Take a \u003ccode\u003eunique_ptr\u0026lt;widget\u0026gt;\u003c/code\u003e parameter to express that a function assumes ownership of a \u003ccode\u003ewidget\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "bad-practice",
      "clumsy",
      "cppcoreguidelines",
      "design",
      "since-c++11"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5966",
    "name": "Struct should explicitly specify the access level when specifying base classes",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eIt is not very common for a struct to have base classes. When they do, by default, they will have public inheritance. Since this is not a fact\nknown by everybody, it’s usually better to be explicit about the visibility of base classes in a struct.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass B {\n};\n\nstruct C : B {\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nclass B {\n};\n\nstruct C :  public B { // Or private, if it was public by mistake\n};\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S5965} is a similar rule that deals with base visibility in classes \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S3540} is another rule that favors a different coding style for base classes. It should not be activated at the same time as this\n  rule. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eIt is not very common for a struct to have base classes. When they do, by default, they will have public inheritance. Since this is not a fact\nknown by everybody, it’s usually better to be explicit about the visibility of base classes in a struct.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass B {\n};\n\nstruct C : B {\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nclass B {\n};\n\nstruct C :  public B { // Or private, if it was public by mistake\n};\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S5965} is a similar rule that deals with base visibility in classes \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S3540} is another rule that favors a different coding style for base classes. It should not be activated at the same time as this\n  rule. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1005",
    "name": "A function should have a single point of exit at the end of the function",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThis is required by IEC 61508, under good programming style.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint function1()\n{\n  return 3;\n}\n\nvoid function2()\n{\n  function1();\n}\n\nint function3(char* ptr) /* Noncompliant; two explicit returns */\n{\n  if (ptr \u003d\u003d NULL) return -1;\n\n  return 7;\n}\n\nvoid function4(char *ptr) /* Noncompliant; two returns, one explicit and one implicit */\n{\n  if (1) return;\n\n  printf(\"hello world!\\n\");\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 14.7 - A function shall have a single point of exit at the end of the function. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 6-6-5 - A function shall have a single point of exit at the end of the function \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 15.5 - A function should have a single point of exit at the end \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThis is required by IEC 61508, under good programming style.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint function1()\n{\n  return 3;\n}\n\nvoid function2()\n{\n  function1();\n}\n\nint function3(char* ptr) /* Noncompliant; two explicit returns */\n{\n  if (ptr \u003d\u003d NULL) return -1;\n\n  return 7;\n}\n\nvoid function4(char *ptr) /* Noncompliant; two returns, one explicit and one implicit */\n{\n  if (1) return;\n\n  printf(\"hello world!\\n\");\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 14.7 - A function shall have a single point of exit at the end of the function. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 6-6-5 - A function shall have a single point of exit at the end of the function \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 15.5 - A function should have a single point of exit at the end \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "brain-overload"
    ],
    "deprecatedKeys": [
      "cpp:FunctionSinglePointOfExit"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S2335",
    "name": "Octal and hexadecimal escape sequences should be terminated",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThere is potential for confusion if an octal or hexadecimal escape sequence is immediately followed by other characters. Instead, such sequences\nshall be terminated by either:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The start of another escape sequence. \u003c/li\u003e\n  \u003cli\u003e The end of the character constant or the end of a string literal. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nconst char *s1 \u003d \"\\x41g\";  // Noncompliant\nint c1 \u003d \u0027\\141t\u0027; // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nconst char *s2 \u003d \"\\x41\" \"g\"; // Compliant - terminated by end of literal\nconst char *s3 \u003d \"\\x41\\x67\"; // Compliant - terminated by another escape\nint c2 \u003d \u0027\\141\\t\u0027; // Compliant - terminated by another escape\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2012, 4.1 - Octal and hexadecimal escape sequences shall be terminated \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThere is potential for confusion if an octal or hexadecimal escape sequence is immediately followed by other characters. Instead, such sequences\nshall be terminated by either:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The start of another escape sequence. \u003c/li\u003e\n  \u003cli\u003e The end of the character constant or the end of a string literal. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nconst char *s1 \u003d \"\\x41g\";  // Noncompliant\nint c1 \u003d \u0027\\141t\u0027; // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nconst char *s2 \u003d \"\\x41\" \"g\"; // Compliant - terminated by end of literal\nconst char *s3 \u003d \"\\x41\\x67\"; // Compliant - terminated by another escape\nint c2 \u003d \u0027\\141\\t\u0027; // Compliant - terminated by another escape\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2012, 4.1 - Octal and hexadecimal escape sequences shall be terminated \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "misra-c2012",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5964",
    "name": "\"std::initializer_list\" constructor should not overlap with other constructors",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhen a class has a constructor accepting \u003ccode\u003einitializer_list\u003c/code\u003e of type \u003ccode\u003eX\u003c/code\u003e and another constructor that has n parameters of\neither type \u003ccode\u003eX\u003c/code\u003e or a type that can be converted to \u003ccode\u003eX\u003c/code\u003e, the constructor call resolution becomes complex. This makes code hard to\nreason about and might lead to calls resolving to unexpected constructors. What makes it even more complex, is that the constructor resolution rules\nare different if \u003ccode\u003eX\u003c/code\u003e is a type template parameter.\u003c/p\u003e\n\u003cp\u003eThis rule flags classes that have constructors overlapping with the \u003ccode\u003einitializer_list\u003c/code\u003e constructor. It is recommended to simplify the\nclass by:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e A technical change: replace \u003ccode\u003einitializer_list\u003c/code\u003e parameter by a \u003ccode\u003estd::vector\u003c/code\u003e, a \u003ccode\u003estd::array\u003c/code\u003e, or a variadic\n  template. This way the caller is forced to be more explicit. \u003c/li\u003e\n  \u003cli\u003e A design change: make the construction of an object of type \u003ccode\u003eX\u003c/code\u003e taking object(s) of type \u003ccode\u003eY\u003c/code\u003e as parameters equivalent to\n  constructing it with an initializer list containing the object(s) of type \u003ccode\u003eY\u003c/code\u003e. This way you can reduce the number of overlapping\n  constructors to the one that takes \u003ccode\u003einitializer_list\u003c/code\u003e. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass A { // Noncompliant\npublic:\n  A();\n  A(int); // This constructor  overlaps with the initializer_list constructor\n  A(int, long); // This constructor overlaps with the initializer_list constructor\n  A(std::initializer_list\u0026lt;int\u0026gt;); // \"initializer_list\" constructor\n  A(int, A);\n  A(int, double);\n};\n\nvoid f1() {\n  A a1(10); // A(int) is called\n  A a2{10}; // The \"initializer_list\" constructor is called\n  A a3(10, 1l); // A(int, long) is called\n  A a4{10, 1l}; // The \"initializer_list\" constructor is called\n  A a5{10, A{}}; // A(int, A) is called\n  // A a6{10, 1.2}; // doesn\u0027t compile\n}\n\nclass B { // Noncompliant\npublic:\n  B(int); // This constructor overlaps with the initializer_list constructor\n  B(int, long); // This constructor doesn\u0027t overlap with the initializer_list constructor. See b4\n  template\u0026lt;typename T\u0026gt;\n  B(std::initializer_list\u0026lt;T\u0026gt;); // \"initializer_list\" constructor\n};\n\nvoid f2() {\n  B b1(10); // The constructor with single \"int\" parameter is called\n  B b2{10}; // The \"initializer_list\" constructor is called\n  B b3(10, 1l); // B(int, long) is called\n  B b4{10, 1l}; // B(int, long) is called\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nclass A {\npublic:\n  A();\n  A(int);\n  A(int, long);\n  A(std::vector\u0026lt;int\u0026gt;);\n  A(int, A);\n  A(int, double);\n};\n\nvoid f1() {\n  A a1(10); // A(int) is called\n  A a2{10}; // A(int) is called\n  A a3(10, 1l); // A(int, long) is called\n  A a4{10, 1l}; // A(int, long)\n  A a5{10, A{}}; // A(int, A) is called\n  A a6{10, 1.2}; // A(int, A) is called\n  A a7 {{1,2,4}}; // vector is called no confusion\n}\n\nclass B {\npublic:\n  B(int, long);\n  template\u0026lt;typename T\u0026gt;\n  B(std::initializer_list\u0026lt;T\u0026gt;);\n};\n\nvoid f2() {\n  B b1({10}); // The \"initializer_list\" constructor is called\n  B b2{10}; // The \"initializer_list\" constructor is called\n  B b3(10, 1l); // B(int, long) is called\n  B b4{10, 1l}; // B(int, long) is called\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhen a class has a constructor accepting \u003ccode\u003einitializer_list\u003c/code\u003e of type \u003ccode\u003eX\u003c/code\u003e and another constructor that has n parameters of\neither type \u003ccode\u003eX\u003c/code\u003e or a type that can be converted to \u003ccode\u003eX\u003c/code\u003e, the constructor call resolution becomes complex. This makes code hard to\nreason about and might lead to calls resolving to unexpected constructors. What makes it even more complex, is that the constructor resolution rules\nare different if \u003ccode\u003eX\u003c/code\u003e is a type template parameter.\u003c/p\u003e\n\u003cp\u003eThis rule flags classes that have constructors overlapping with the \u003ccode\u003einitializer_list\u003c/code\u003e constructor. It is recommended to simplify the\nclass by:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e A technical change: replace \u003ccode\u003einitializer_list\u003c/code\u003e parameter by a \u003ccode\u003estd::vector\u003c/code\u003e, a \u003ccode\u003estd::array\u003c/code\u003e, or a variadic\n  template. This way the caller is forced to be more explicit. \u003c/li\u003e\n  \u003cli\u003e A design change: make the construction of an object of type \u003ccode\u003eX\u003c/code\u003e taking object(s) of type \u003ccode\u003eY\u003c/code\u003e as parameters equivalent to\n  constructing it with an initializer list containing the object(s) of type \u003ccode\u003eY\u003c/code\u003e. This way you can reduce the number of overlapping\n  constructors to the one that takes \u003ccode\u003einitializer_list\u003c/code\u003e. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass A { // Noncompliant\npublic:\n  A();\n  A(int); // This constructor  overlaps with the initializer_list constructor\n  A(int, long); // This constructor overlaps with the initializer_list constructor\n  A(std::initializer_list\u0026lt;int\u0026gt;); // \"initializer_list\" constructor\n  A(int, A);\n  A(int, double);\n};\n\nvoid f1() {\n  A a1(10); // A(int) is called\n  A a2{10}; // The \"initializer_list\" constructor is called\n  A a3(10, 1l); // A(int, long) is called\n  A a4{10, 1l}; // The \"initializer_list\" constructor is called\n  A a5{10, A{}}; // A(int, A) is called\n  // A a6{10, 1.2}; // doesn\u0027t compile\n}\n\nclass B { // Noncompliant\npublic:\n  B(int); // This constructor overlaps with the initializer_list constructor\n  B(int, long); // This constructor doesn\u0027t overlap with the initializer_list constructor. See b4\n  template\u0026lt;typename T\u0026gt;\n  B(std::initializer_list\u0026lt;T\u0026gt;); // \"initializer_list\" constructor\n};\n\nvoid f2() {\n  B b1(10); // The constructor with single \"int\" parameter is called\n  B b2{10}; // The \"initializer_list\" constructor is called\n  B b3(10, 1l); // B(int, long) is called\n  B b4{10, 1l}; // B(int, long) is called\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nclass A {\npublic:\n  A();\n  A(int);\n  A(int, long);\n  A(std::vector\u0026lt;int\u0026gt;);\n  A(int, A);\n  A(int, double);\n};\n\nvoid f1() {\n  A a1(10); // A(int) is called\n  A a2{10}; // A(int) is called\n  A a3(10, 1l); // A(int, long) is called\n  A a4{10, 1l}; // A(int, long)\n  A a5{10, A{}}; // A(int, A) is called\n  A a6{10, 1.2}; // A(int, A) is called\n  A a7 {{1,2,4}}; // vector is called no confusion\n}\n\nclass B {\npublic:\n  B(int, long);\n  template\u0026lt;typename T\u0026gt;\n  B(std::initializer_list\u0026lt;T\u0026gt;);\n};\n\nvoid f2() {\n  B b1({10}); // The \"initializer_list\" constructor is called\n  B b2{10}; // The \"initializer_list\" constructor is called\n  B b3(10, 1l); // B(int, long) is called\n  B b4{10, 1l}; // B(int, long) is called\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "confusing",
      "since-c++11"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S845",
    "name": "Signed and unsigned types should not be mixed in expressions",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eSome signed to unsigned conversions may lead to implementation-defined behavior. This behavior may not be consistent with developer\nexpectations.\u003c/p\u003e\n\u003cp\u003eIf you need to mix signed and unsigned types, you should make your intent explicit by using explicit casts and avoiding implicit casts.\u003c/p\u003e\n\u003cp\u003eThis rule will detect implicit conversions that change the signedness.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid f(int a) {\n  unsigned int b \u003d a; // Noncompliant\n  int c \u003d (a \u0026gt; 0) ? a : b; // Noncompliant\n\n  if (a \u0026gt; b) { // Noncompliant\n    // ...\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid f(int a) {\n  unsigned int b \u003d static_cast\u0026lt;unsigned int\u0026gt;(a); // Compliant\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++ 2008, 5-0-4 \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/U9YxBQ\"\u003eCERT, INT31-C.\u003c/a\u003e - Ensure that integer conversions do not result in lost or\n  misinterpreted data \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eSome signed to unsigned conversions may lead to implementation-defined behavior. This behavior may not be consistent with developer\nexpectations.\u003c/p\u003e\n\u003cp\u003eIf you need to mix signed and unsigned types, you should make your intent explicit by using explicit casts and avoiding implicit casts.\u003c/p\u003e\n\u003cp\u003eThis rule will detect implicit conversions that change the signedness.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid f(int a) {\n  unsigned int b \u003d a; // Noncompliant\n  int c \u003d (a \u0026gt; 0) ? a : b; // Noncompliant\n\n  if (a \u0026gt; b) { // Noncompliant\n    // ...\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nvoid f(int a) {\n  unsigned int b \u003d static_cast\u0026lt;unsigned int\u0026gt;(a); // Compliant\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C++ 2008, 5-0-4 \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/U9YxBQ\"\u003eCERT, INT31-C.\u003c/a\u003e - Ensure that integer conversions do not result in lost or\n  misinterpreted data \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "cert"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S966",
    "name": "Macros used in preprocessor directives should be defined before use",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eAn attempt to use an undefined identifier may elicit a warning from the preprocessor. Or it may not; the preprocessor may simply assume that the\nundefined token has a value of 0.\u003c/p\u003e\n\u003cp\u003eTherefore macro identifiers should not be used in preprocessor directives until after they have been defined, and this limited usage should be\nenforced with the use of definition tests.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#if x \u0026gt; 0  /* x assumed to be zero if not defined */\n#include SOMETHING_IMPORTANT\n#endif\n\n#ifdef y  /* Okay; y is not evaluated */\n#if y \u0026gt; 0 /* Okay; y must be defined to reach this point */\n...\n#endif\n#endif\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#define x 10\n...\n#if x \u0026gt; 0\n#include SOMETHING_IMPORTANT\n#endif\n\n#if defined ( y ) \u0026amp;\u0026amp; ( y \u0026gt; 0 )  /* more compact form, same result as before */\n...\n#endif\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 19.11 - All macro identifiers in preprocessor directives shall be defined before use, except in #ifdef and #ifndef preprocessor\n  directives and the defined() operator. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 20.9 - All identifiers used in the controlling expression of #if or #elif preprocessing directives shall be #define’d before\n  evaluation \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eAn attempt to use an undefined identifier may elicit a warning from the preprocessor. Or it may not; the preprocessor may simply assume that the\nundefined token has a value of 0.\u003c/p\u003e\n\u003cp\u003eTherefore macro identifiers should not be used in preprocessor directives until after they have been defined, and this limited usage should be\nenforced with the use of definition tests.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#if x \u0026gt; 0  /* x assumed to be zero if not defined */\n#include SOMETHING_IMPORTANT\n#endif\n\n#ifdef y  /* Okay; y is not evaluated */\n#if y \u0026gt; 0 /* Okay; y must be defined to reach this point */\n...\n#endif\n#endif\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#define x 10\n...\n#if x \u0026gt; 0\n#include SOMETHING_IMPORTANT\n#endif\n\n#if defined ( y ) \u0026amp;\u0026amp; ( y \u0026gt; 0 )  /* more compact form, same result as before */\n...\n#endif\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 19.11 - All macro identifiers in preprocessor directives shall be defined before use, except in #ifdef and #ifndef preprocessor\n  directives and the defined() operator. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 20.9 - All identifiers used in the controlling expression of #if or #elif preprocessing directives shall be #define’d before\n  evaluation \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "preprocessor"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S967",
    "name": "There shall be at most one occurrence of the # or ## operators in a single macro definition",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eBecause the evaluation order of \u003ccode\u003e#\u003c/code\u003e and \u003ccode\u003e##\u003c/code\u003e are not specified, the results of using them both in the same macro could be\nunpredictable. Therefore macros should contain at most once instance of either \u003ccode\u003e#\u003c/code\u003e or \u003ccode\u003e##\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#define NonCompliant(a, b)  # a ## b\nint main() {\n  std::cout \u0026lt;\u0026lt; NonCompliant(Hello, World);\n}\n\u003c/pre\u003e\n\u003cp\u003eThe result of this code is unspecified. It will either print \"HelloWorld\" or trigger a compilation error. If ## is evaluated first this will print\nHelloWorld. If # is evaluated first this will cause a compilation error telling that\u0026nbsp;\u003cstrong\u003e\"Hello\"World\u003c/strong\u003e is not a valid preprocessor\ntoken.\u003c/p\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#define Stringfy(a) #a\n#define Compliant(a, b)  Stringfy(a##b)\n\nint main(){\n  std::cout \u0026lt;\u0026lt; Compliant(Hello, World);\n}\n\u003c/pre\u003e\n\u003cp\u003eThis example will always print \"HelloWorld\".\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 19.12 \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2008, 16-3-1 \u003c/li\u003e\n  \u003cli\u003e Related: MISRA C:2012, 20.11 \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eBecause the evaluation order of \u003ccode\u003e#\u003c/code\u003e and \u003ccode\u003e##\u003c/code\u003e are not specified, the results of using them both in the same macro could be\nunpredictable. Therefore macros should contain at most once instance of either \u003ccode\u003e#\u003c/code\u003e or \u003ccode\u003e##\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#define NonCompliant(a, b)  # a ## b\nint main() {\n  std::cout \u0026lt;\u0026lt; NonCompliant(Hello, World);\n}\n\u003c/pre\u003e\n\u003cp\u003eThe result of this code is unspecified. It will either print \"HelloWorld\" or trigger a compilation error. If ## is evaluated first this will print\nHelloWorld. If # is evaluated first this will cause a compilation error telling that\u0026nbsp;\u003cstrong\u003e\"Hello\"World\u003c/strong\u003e is not a valid preprocessor\ntoken.\u003c/p\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#define Stringfy(a) #a\n#define Compliant(a, b)  Stringfy(a##b)\n\nint main(){\n  std::cout \u0026lt;\u0026lt; Compliant(Hello, World);\n}\n\u003c/pre\u003e\n\u003cp\u003eThis example will always print \"HelloWorld\".\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 19.12 \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2008, 16-3-1 \u003c/li\u003e\n  \u003cli\u003e Related: MISRA C:2012, 20.11 \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "misra-c++2008",
      "misra-c2004",
      "misra-c2012",
      "preprocessor"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S841",
    "name": "\"enum\" members other than the first one should not be explicitly initialized unless all members are explicitly initialized",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eIf an enumerator list is given with no explicit initialization of members, then C/C++ allocates a sequence of integers starting at zero for the\nfirst element and increasing by one for each subsequent element.\u003c/p\u003e\n\u003cp\u003eAn explicit initialization of the first element, as permitted by this rule, forces the allocation of integers to start at the given value. When\nadopting this approach it is essential to ensure that the initialization value used is small enough that no subsequent value in the list will exceed\nthe \u003ccode\u003eint\u003c/code\u003e storage used by enumeration constants.\u003c/p\u003e\n\u003cp\u003eExplicit initialization of all items in the list, which is also permissible, prevents the mixing of automatic and manual allocation, which is error\nprone.\u003c/p\u003e\n\u003cp\u003eHowever, it is then the responsibility of the developer to ensure that all values are in the required range, and that values are not\nunintentionally duplicated.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nenum color { red \u003d 3, blue, green, yellow \u003d 5 }; // Noncompliant; both green and yellow \u003d 5\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nenum color { red \u003d 3, blue \u003d 4, green \u003d 5, yellow \u003d 5 }; // Compliant\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 9.3 - In an enumerator list, the \"\u003d\" construct shall not be used to explicitly initialize members other than the first, unless\n  all items are explicitly initialized. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 8-5-3 - In an enumerator list, the \u003d construct shall not be used to explicitly initialize members other than the first, unless\n  all items are explicitly initialized. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eIf an enumerator list is given with no explicit initialization of members, then C/C++ allocates a sequence of integers starting at zero for the\nfirst element and increasing by one for each subsequent element.\u003c/p\u003e\n\u003cp\u003eAn explicit initialization of the first element, as permitted by this rule, forces the allocation of integers to start at the given value. When\nadopting this approach it is essential to ensure that the initialization value used is small enough that no subsequent value in the list will exceed\nthe \u003ccode\u003eint\u003c/code\u003e storage used by enumeration constants.\u003c/p\u003e\n\u003cp\u003eExplicit initialization of all items in the list, which is also permissible, prevents the mixing of automatic and manual allocation, which is error\nprone.\u003c/p\u003e\n\u003cp\u003eHowever, it is then the responsibility of the developer to ensure that all values are in the required range, and that values are not\nunintentionally duplicated.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nenum color { red \u003d 3, blue, green, yellow \u003d 5 }; // Noncompliant; both green and yellow \u003d 5\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nenum color { red \u003d 3, blue \u003d 4, green \u003d 5, yellow \u003d 5 }; // Compliant\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 9.3 - In an enumerator list, the \"\u003d\" construct shall not be used to explicitly initialize members other than the first, unless\n  all items are explicitly initialized. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 8-5-3 - In an enumerator list, the \u003d construct shall not be used to explicitly initialize members other than the first, unless\n  all items are explicitly initialized. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "based-on-misra"
    ],
    "deprecatedKeys": [
      "cpp:EnumPartialInitialization"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S963",
    "name": "In the definition of a function-like macro, each instance of a parameter shall be enclosed in parentheses, unless it is used as the operand of # or ##",
    "defaultSeverity": "BLOCKER",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThis rule is a strict implementation of a MISRA (Motor Industry Software Reliability Association) rule. MISRA defines best practices for developing\nsafety-critical software. You can learn more about this rule in the MISRA documents referenced below.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 19.10 \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2008, 16-0-6 \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/CdcxBQ\"\u003eCERT, PRE01-C.\u003c/a\u003e - Use parentheses within macros around parameter names \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThis rule is a strict implementation of a MISRA (Motor Industry Software Reliability Association) rule. MISRA defines best practices for developing\nsafety-critical software. You can learn more about this rule in the MISRA documents referenced below.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 19.10 \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2008, 16-0-6 \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/CdcxBQ\"\u003eCERT, PRE01-C.\u003c/a\u003e - Use parentheses within macros around parameter names \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "cert",
      "misra-c++2008"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S960",
    "name": "Function-like macros should not be used",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eIt is tempting to treat function-like macros as functions, but the two things work differently. For instance, the use of functions offers parameter\ntype-checking, while the use of macros does not. Additionally, with macros, there is the potential for a macro to be evaluated multiple times. In\ngeneral, functions offer a safer, more robust mechanism than function-like macros, and that safety usually outweighs the speed advantages offered by\nmacros. Therefore functions should be used instead when possible.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#define CUBE (X) ((X) * (X) * (X)) // Noncompliant\n\nvoid func(void) {\n  int i \u003d 2;\n  int a \u003d CUBE(++i); // Noncompliant. Expands to: int a \u003d ((++i) * (++i) * (++i))\n  // ...\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\ninline int cube(int i) {\n  return i * i * i;\n}\n\nvoid func(void) {\n  int i \u003d 2;\n  int a \u003d cube(++i); // yields 27\n  // ...\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 19.7 - A function should be used in preference to a function-like macro. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 16-0-4 - Function-like macros shall not be defined. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, Dir. 4.9 - A function should be used in preference to a function-like macro where they are interchangeable \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/INcxBQ\"\u003eCERT, PRE00-C.\u003c/a\u003e - Prefer inline or static functions to function-like macros \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es31-dont-use-macros-for-constants-or-functions\"\u003eES.31: Don’t\n  use macros for constants or \"functions\"\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eIt is tempting to treat function-like macros as functions, but the two things work differently. For instance, the use of functions offers parameter\ntype-checking, while the use of macros does not. Additionally, with macros, there is the potential for a macro to be evaluated multiple times. In\ngeneral, functions offer a safer, more robust mechanism than function-like macros, and that safety usually outweighs the speed advantages offered by\nmacros. Therefore functions should be used instead when possible.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#define CUBE (X) ((X) * (X) * (X)) // Noncompliant\n\nvoid func(void) {\n  int i \u003d 2;\n  int a \u003d CUBE(++i); // Noncompliant. Expands to: int a \u003d ((++i) * (++i) * (++i))\n  // ...\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\ninline int cube(int i) {\n  return i * i * i;\n}\n\nvoid func(void) {\n  int i \u003d 2;\n  int a \u003d cube(++i); // yields 27\n  // ...\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 19.7 - A function should be used in preference to a function-like macro. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 16-0-4 - Function-like macros shall not be defined. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, Dir. 4.9 - A function should be used in preference to a function-like macro where they are interchangeable \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/INcxBQ\"\u003eCERT, PRE00-C.\u003c/a\u003e - Prefer inline or static functions to function-like macros \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es31-dont-use-macros-for-constants-or-functions\"\u003eES.31: Don’t\n  use macros for constants or \"functions\"\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "bad-practice",
      "based-on-misra",
      "cert",
      "cppcoreguidelines",
      "preprocessor"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S961",
    "name": "Function-like macros should not be invoked without all of their arguments",
    "defaultSeverity": "BLOCKER",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eBefore compilation, the preprocessor replaces macros with the code they expand to. The resulting code may be invalid when a function-like macro is\ninvoked without all its arguments, which can cause the program to fail to compile or to behave unexpectedly at runtime.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/preprocessor/replace\"\u003eReplacing text macros\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/translation_phases#Phase_3\"\u003ePhases of translation: Phase 3\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e MISRA C:2004, 19.8 - A function-like macro shall not be invoked without all of its arguments. \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/628\"\u003eCWE\u003c/a\u003e - CWE-628: Function Call with Incorrectly Specified Arguments \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eBefore compilation, the preprocessor replaces macros with the code they expand to. The resulting code may be invalid when a function-like macro is\ninvoked without all its arguments, which can cause the program to fail to compile or to behave unexpectedly at runtime.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/preprocessor/replace\"\u003eReplacing text macros\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/translation_phases#Phase_3\"\u003ePhases of translation: Phase 3\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e MISRA C:2004, 19.8 - A function-like macro shall not be invoked without all of its arguments. \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/628\"\u003eCWE\u003c/a\u003e - CWE-628: Function Call with Incorrectly Specified Arguments \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "cwe",
      "preprocessor"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:M23_039",
    "name": "\"#include\" directives should only be preceded by preprocessor directives or comments",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 19.0.3\u003c/p\u003e\n\u003cp\u003eCategory: Advisory\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eThis rule shall be applied to the contents of a file before preprocessing occurs.\u003c/p\u003e\n\u003cp\u003eFor purposes of this rule, the tokens used to open and close a \u003cem\u003elinkage-specification\u003c/em\u003e are ignored.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eTo aid code readability, all of the \u003ccode\u003e#include\u003c/code\u003e directives in a particular code file should be grouped together near the top of the\nfile.\u003c/p\u003e\n\u003cp\u003eAdditionally, using \u003ccode\u003e#include\u003c/code\u003e to include a \u003cem\u003estandard header file\u003c/em\u003e within a declaration or definition, or using part of the C++\nStandard Library before the inclusion of the related \u003cem\u003estandard header file\u003c/em\u003e results in \u003cem\u003eundefined behaviour\u003c/em\u003e.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\n// f.h\nxyz \u003d 0;\n\n// f.cpp\nint16_t             // No more includes allowed in f.cpp after this code\n#include \"f.h\"      // Non-compliant\n\n// f1.cpp\n#define F1_MACRO\n#include \"a.h\"      // Compliant\n\nextern \"C\"          // Linkage-specification tokens are ignored\n{                   // Linkage-specification token is ignored\n  #include \"b.h\"    // Compliant\n}                   // Linkage-specification token is ignored\n\n#include \"c.h\"      // Compliant\n\nextern \"C\"          // Linkage-specification tokens are ignored\n{                   // Linkage-specification token is ignored\n  #include \"d.h\"    // Compliant\n\n  void g();         // No more includes allowed in f1.cpp after this code\n}                   // Linkage-specification token is ignored\n\n#include \"e.h\"      // Non-compliant\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003e{rule:cpp:S954} targets the same defect as this rule but for a non-mission-critical context.\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 19.0.3\u003c/p\u003e\n\u003cp\u003eCategory: Advisory\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eThis rule shall be applied to the contents of a file before preprocessing occurs.\u003c/p\u003e\n\u003cp\u003eFor purposes of this rule, the tokens used to open and close a \u003cem\u003elinkage-specification\u003c/em\u003e are ignored.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eTo aid code readability, all of the \u003ccode\u003e#include\u003c/code\u003e directives in a particular code file should be grouped together near the top of the\nfile.\u003c/p\u003e\n\u003cp\u003eAdditionally, using \u003ccode\u003e#include\u003c/code\u003e to include a \u003cem\u003estandard header file\u003c/em\u003e within a declaration or definition, or using part of the C++\nStandard Library before the inclusion of the related \u003cem\u003estandard header file\u003c/em\u003e results in \u003cem\u003eundefined behaviour\u003c/em\u003e.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\n// f.h\nxyz \u003d 0;\n\n// f.cpp\nint16_t             // No more includes allowed in f.cpp after this code\n#include \"f.h\"      // Non-compliant\n\n// f1.cpp\n#define F1_MACRO\n#include \"a.h\"      // Compliant\n\nextern \"C\"          // Linkage-specification tokens are ignored\n{                   // Linkage-specification token is ignored\n  #include \"b.h\"    // Compliant\n}                   // Linkage-specification token is ignored\n\n#include \"c.h\"      // Compliant\n\nextern \"C\"          // Linkage-specification tokens are ignored\n{                   // Linkage-specification token is ignored\n  #include \"d.h\"    // Compliant\n\n  void g();         // No more includes allowed in f1.cpp after this code\n}                   // Linkage-specification token is ignored\n\n#include \"e.h\"      // Non-compliant\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003e{rule:cpp:S954} targets the same defect as this rule but for a non-mission-critical context.\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "confusing",
      "misra-advisory",
      "misra-c++2023"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S968",
    "name": "Preprocessor operators \"#\" and \"##\" should not be used",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe evaluation order of both the \u003ccode\u003e#\u003c/code\u003e and \u003ccode\u003e##\u003c/code\u003e preprocessor operators is unspecified. Compilers have been known to implement\nthese operators inconsistently, therefore, to avoid these problems, do not use them.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#define A(Y)   #Y    /* Noncompliant */\n#define A(X,Y) X##Y  /* Noncompliant */\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 19.13 - The # and ## preprocessor operators should not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 16-3-2 - The # and ## operators should not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 20.10 - The # and ## preprocessor operators should not be used \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe evaluation order of both the \u003ccode\u003e#\u003c/code\u003e and \u003ccode\u003e##\u003c/code\u003e preprocessor operators is unspecified. Compilers have been known to implement\nthese operators inconsistently, therefore, to avoid these problems, do not use them.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#define A(Y)   #Y    /* Noncompliant */\n#define A(X,Y) X##Y  /* Noncompliant */\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 19.13 - The # and ## preprocessor operators should not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 16-3-2 - The # and ## operators should not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 20.10 - The # and ## preprocessor operators should not be used \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "lock-in"
    ],
    "deprecatedKeys": [
      "cpp:PPStringifyAndPastingUsage"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:M23_036",
    "name": "Unsigned \"integer literals\" shall be appropriately suffixed",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 5.13.4\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eThis rule applies to any \u003cem\u003einteger-literal\u003c/em\u003e that exists after preprocessing. It does not apply to \u003cem\u003euser-defined-integer-literals\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eAn unsigned \u003cem\u003einteger-suffix\u003c/em\u003e is required when the type of the \u003cem\u003einteger literal\u003c/em\u003e, as specified by the C++ Standard in [lex.icon], is\nunsigned.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e this rule does not depend on the context in which a literal is used; promotion and other conversions that may be applied to\nthe value are not relevant in determining compliance with this rule.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eThe type of an \u003cem\u003einteger literal\u003c/em\u003e is a potential source of confusion, because it is dependent on a complex combination of factors\nincluding:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The magnitude of the constant; \u003c/li\u003e\n  \u003cli\u003e The implemented sizes of the integer types; \u003c/li\u003e\n  \u003cli\u003e The presence of any suffixes; \u003c/li\u003e\n  \u003cli\u003e The number base that is used. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eFor example, the decimal \u003cem\u003einteger literal\u003c/em\u003e \u003ccode\u003e32768\u003c/code\u003e always has signed type. However, the \u003cem\u003einteger literal\u003c/em\u003e\n\u003ccode\u003e0x8000\u003c/code\u003e is of type \u003ccode\u003eunsigned int\u003c/code\u003e in a 16-bit environment, but of type \u003ccode\u003esigned int\u003c/code\u003e in a 32-bit environment. Adding\na \u003ccode\u003eU\u003c/code\u003e or \u003ccode\u003eu\u003c/code\u003e suffix to the \u003cem\u003einteger literal\u003c/em\u003e makes the signedness of the value explicit on a 16-bit platform.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e compliance checks against this rule will only be valid if an analysis tool has been configured with the same integer sizes\nas the compiler that is being used within the project.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cp\u003eThe following examples assume that \u003ccode\u003eint\u003c/code\u003e is 16 bits:\u003c/p\u003e\n\u003cpre\u003e\n    auto x \u003d 32768;     // Compliant - signed type\n    auto y \u003d 0x8000;    // Non-compliant - unsigned type\nuint16_t z \u003d 123;       // Compliant - \u0027u\u0027 is not required as \u0027123\u0027 is signed\n\nvoid f( uint16_t );     // #1\nvoid f(  int16_t );     // #2\n\nvoid b()\n{\n  f( 0x8000  );         // Non-compliant - calls #1 as 0x8000 is unsigned\n  f( 0x8000u );         // Compliant - calls #1\n  f( 0x7FFF  );         // Compliant - calls #2 as 0x7FFF is signed\n  f( 0x7FFFu );         // Compliant - calls #1\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003e{rule:cpp:S854} targets the same defect as this rule but for a non-mission-critical context.\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 5.13.4\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eThis rule applies to any \u003cem\u003einteger-literal\u003c/em\u003e that exists after preprocessing. It does not apply to \u003cem\u003euser-defined-integer-literals\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eAn unsigned \u003cem\u003einteger-suffix\u003c/em\u003e is required when the type of the \u003cem\u003einteger literal\u003c/em\u003e, as specified by the C++ Standard in [lex.icon], is\nunsigned.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e this rule does not depend on the context in which a literal is used; promotion and other conversions that may be applied to\nthe value are not relevant in determining compliance with this rule.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eThe type of an \u003cem\u003einteger literal\u003c/em\u003e is a potential source of confusion, because it is dependent on a complex combination of factors\nincluding:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The magnitude of the constant; \u003c/li\u003e\n  \u003cli\u003e The implemented sizes of the integer types; \u003c/li\u003e\n  \u003cli\u003e The presence of any suffixes; \u003c/li\u003e\n  \u003cli\u003e The number base that is used. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eFor example, the decimal \u003cem\u003einteger literal\u003c/em\u003e \u003ccode\u003e32768\u003c/code\u003e always has signed type. However, the \u003cem\u003einteger literal\u003c/em\u003e\n\u003ccode\u003e0x8000\u003c/code\u003e is of type \u003ccode\u003eunsigned int\u003c/code\u003e in a 16-bit environment, but of type \u003ccode\u003esigned int\u003c/code\u003e in a 32-bit environment. Adding\na \u003ccode\u003eU\u003c/code\u003e or \u003ccode\u003eu\u003c/code\u003e suffix to the \u003cem\u003einteger literal\u003c/em\u003e makes the signedness of the value explicit on a 16-bit platform.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e compliance checks against this rule will only be valid if an analysis tool has been configured with the same integer sizes\nas the compiler that is being used within the project.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cp\u003eThe following examples assume that \u003ccode\u003eint\u003c/code\u003e is 16 bits:\u003c/p\u003e\n\u003cpre\u003e\n    auto x \u003d 32768;     // Compliant - signed type\n    auto y \u003d 0x8000;    // Non-compliant - unsigned type\nuint16_t z \u003d 123;       // Compliant - \u0027u\u0027 is not required as \u0027123\u0027 is signed\n\nvoid f( uint16_t );     // #1\nvoid f(  int16_t );     // #2\n\nvoid b()\n{\n  f( 0x8000  );         // Non-compliant - calls #1 as 0x8000 is unsigned\n  f( 0x8000u );         // Compliant - calls #1\n  f( 0x7FFF  );         // Compliant - calls #2 as 0x7FFF is signed\n  f( 0x7FFFu );         // Compliant - calls #1\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003e{rule:cpp:S854} targets the same defect as this rule but for a non-mission-critical context.\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "misra-c++2023",
      "misra-required",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S969",
    "name": "Only standard forms of the \"defined\" directive should be used",
    "defaultSeverity": "BLOCKER",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003edefined\u003c/code\u003e preprocessing directive is used in the context of \u003ccode\u003e#if\u003c/code\u003e and \u003ccode\u003e#elif\u003c/code\u003e expressions to see whether a\ngiven identifier has been defined as a macro. It returns a value of 0 (false) or 1 (true), and has two valid forms, \u003ccode\u003edefined IDENTIFIER\u003c/code\u003e\nand \u003ccode\u003edefined ( IDENTIFIER )\u003c/code\u003e. Since it is essentially a macro existence check, it cannot take expressions as arguments.\u003c/p\u003e\n\u003cp\u003eNote that since\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e#if defined AN_IDENTIFIER\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eis equivalent to\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e#ifdef AN_IDENTIFIER\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003edefined\u003c/code\u003e is most useful when there are multiple arguments to check, E.G.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e#if defined AAA || defined BBB\u003c/code\u003e\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#if defined ( X \u0026gt; Y ) // Noncompliant; expressions not allowed\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#if defined X \u0026amp;\u0026amp; defined Y \u0026amp;\u0026amp; X \u0026gt; Y\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 19.14 - The defined preprocessor operator shall only be used in one of the two standard forms. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 16-1-1 - The defined preprocessor operator shall only be used in one of the two standard forms. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe \u003ccode\u003edefined\u003c/code\u003e preprocessing directive is used in the context of \u003ccode\u003e#if\u003c/code\u003e and \u003ccode\u003e#elif\u003c/code\u003e expressions to see whether a\ngiven identifier has been defined as a macro. It returns a value of 0 (false) or 1 (true), and has two valid forms, \u003ccode\u003edefined IDENTIFIER\u003c/code\u003e\nand \u003ccode\u003edefined ( IDENTIFIER )\u003c/code\u003e. Since it is essentially a macro existence check, it cannot take expressions as arguments.\u003c/p\u003e\n\u003cp\u003eNote that since\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e#if defined AN_IDENTIFIER\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eis equivalent to\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e#ifdef AN_IDENTIFIER\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003edefined\u003c/code\u003e is most useful when there are multiple arguments to check, E.G.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e#if defined AAA || defined BBB\u003c/code\u003e\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#if defined ( X \u0026gt; Y ) // Noncompliant; expressions not allowed\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#if defined X \u0026amp;\u0026amp; defined Y \u0026amp;\u0026amp; X \u0026gt; Y\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 19.14 - The defined preprocessor operator shall only be used in one of the two standard forms. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 16-1-1 - The defined preprocessor operator shall only be used in one of the two standard forms. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "bad-practice",
      "based-on-misra"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:M23_158",
    "name": "The \"union\" keyword shall not be used",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 12.3.1\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eA member of a union can be written and the same member can then be read back in a well-defined manner.\u003c/p\u003e\n\u003cp\u003eHowever, writing to one union member and then reading back from a different union member results in \u003cem\u003eundefined behaviour\u003c/em\u003e. In addition, the\nuse of a member of non-trivial type requires manual control of its lifetime. For these reasons, unions shall not be used.\u003c/p\u003e\n\u003cp\u003eThe class \u003ccode\u003estd::variant\u003c/code\u003e, available since C++17, provides a type-safe union that can be used to store a value of one type from a fixed\nset of alternatives. In contrast to unions, the alternatives are accessed by type (if the types are different) or index, not by name. It is impossible\nto access an inactive member of a \u003ccode\u003estd::variant\u003c/code\u003e. For example, trying to access an inactive member via \u003ccode\u003estd::get\u003c/code\u003e will lead to\nan exception being thrown.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nunion Data1                                    // Non-compliant\n{\n  int32_t i;\n  float   j;\n};\n\nusing Data2 \u003d std::variant\u0026lt; int32_t, float \u0026gt;;  // Rule does not apply\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003e{rule:cpp:S6147} targets the same defect as this rule but for a non-mission-critical context.\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 12.3.1\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eA member of a union can be written and the same member can then be read back in a well-defined manner.\u003c/p\u003e\n\u003cp\u003eHowever, writing to one union member and then reading back from a different union member results in \u003cem\u003eundefined behaviour\u003c/em\u003e. In addition, the\nuse of a member of non-trivial type requires manual control of its lifetime. For these reasons, unions shall not be used.\u003c/p\u003e\n\u003cp\u003eThe class \u003ccode\u003estd::variant\u003c/code\u003e, available since C++17, provides a type-safe union that can be used to store a value of one type from a fixed\nset of alternatives. In contrast to unions, the alternatives are accessed by type (if the types are different) or index, not by name. It is impossible\nto access an inactive member of a \u003ccode\u003estd::variant\u003c/code\u003e. For example, trying to access an inactive member via \u003ccode\u003estd::get\u003c/code\u003e will lead to\nan exception being thrown.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nunion Data1                                    // Non-compliant\n{\n  int32_t i;\n  float   j;\n};\n\nusing Data2 \u003d std::variant\u0026lt; int32_t, float \u0026gt;;  // Rule does not apply\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003e{rule:cpp:S6147} targets the same defect as this rule but for a non-mission-critical context.\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "bad-practice",
      "misra-c++2023",
      "misra-required"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:M23_279",
    "name": "\"Forwarding references\" and \"std::forward\" shall be used together",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 28.6.2\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eA \u003cem\u003eforwarding reference\u003c/em\u003e parameter (of type \u003ccode\u003eT \u0026amp;\u0026amp;\u003c/code\u003e) shall be forwarded when passed to other functions by wrapping the\nparameter in a call to the function \u003ccode\u003estd::forward\u0026lt; T \u0026gt;\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eFurthermore, \u003ccode\u003estd::forward\u003c/code\u003e shall only be used to forward a \u003cem\u003eforwarding reference\u003c/em\u003e.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003ePerfect forwarding relies on language features such as reference collapsing and type deduction which are complex to master. Enforcing the use of\nwell known idioms avoids the risk of writing code that does not do what was intended.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e care must be taken not to forward the same argument twice — see {rule:cpp:M23_280}: MISRA C++ 2023 Rule\u0026nbsp;28.6.3.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nvoid f1( std::string \u0026amp;  );          // #1\nvoid f1( std::string \u0026amp;\u0026amp; );          // #2\n\ntemplate\u0026lt; typename T1, typename T2 \u0026gt;\nvoid f2( T1 \u0026amp;\u0026amp; t1, T2 \u0026amp; t2 )\n{\n  f1( t1 );                         // Non-compliant - calls #1\n\n  f1( std::forward\u0026lt; T1 \u0026gt;( t1 ) );   // Compliant - calls #1 (for #4) or #2 (for #3)\n  f1( std::forward\u0026lt; T2 \u0026gt;( t2 ) );   // Non-compliant - calls #2\n  f1( std::forward\u0026lt; T2 \u0026gt;( t1 ) );   // Non-compliant - wrong template parameter\n\n  f1( std::move( t1 ) );            // Non-compliant - calls #2\n  f1( std::move( t2 ) );            // Rule does not apply - calls #2\n\n  auto lambda \u003d [] ( auto \u0026amp;\u0026amp; t )\n                   { f1(t); };      // Non-compliant - calls #1\n}\n\nvoid f3()\n{\n  std::string s;\n\n  f2( std::string { \"Hello\" }, s ); // #3\n  f2( s, s );                       // #4\n}\n\ntemplate\u0026lt; typename T \u0026gt;\nstruct A\n{\n  void foo( T \u0026amp;\u0026amp; t )\n  {\n    std::move( t );    //\u0026nbsp;Rule does not apply - not a forwarding reference\n  }\n};\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S5425} detects when a parameter of forwarding reference type is never used in a \u003ccode\u003estd::forward\u003c/code\u003e call \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S5417} ensures that \u003ccode\u003estd::forward\u003c/code\u003e is not confused with \u003ccode\u003estd::move\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S6031} reports when the incorrect template parameter is provided to std::forward \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:M23_280}: MISRA C++ 2023 Rule\u0026nbsp;28.6.3 ensures that a parameter is never moved or forwarded more than once \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2023 Rule\u0026nbsp;28.6.1 - The argument to \u003ccode\u003estd::move\u003c/code\u003e shall be a non-const \u003cem\u003elvalue\u003c/em\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/27e662b/CppCoreGuidelines.md#f19-for-forward-parameters-pass-by-tp-and-only-stdforward-the-parameter\"\u003eF.19 For \"forward\" parameters, pass by \u003ccode\u003eTP\u0026amp;\u0026amp;\u003c/code\u003e and only \u003ccode\u003estd::forward\u003c/code\u003e the parameter\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/reference#Forwarding_references\"\u003eForwarding references\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e Stack Overflow - Answer by Konrad Rudolph for \u003ca href\u003d\"https://stackoverflow.com/a/24535491\"\u003eHow to perfectly forward\n  \u003ccode\u003eauto\u0026amp;\u0026amp;\u003c/code\u003e in a generic lambda?\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 28.6.2\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eA \u003cem\u003eforwarding reference\u003c/em\u003e parameter (of type \u003ccode\u003eT \u0026amp;\u0026amp;\u003c/code\u003e) shall be forwarded when passed to other functions by wrapping the\nparameter in a call to the function \u003ccode\u003estd::forward\u0026lt; T \u0026gt;\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eFurthermore, \u003ccode\u003estd::forward\u003c/code\u003e shall only be used to forward a \u003cem\u003eforwarding reference\u003c/em\u003e.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003ePerfect forwarding relies on language features such as reference collapsing and type deduction which are complex to master. Enforcing the use of\nwell known idioms avoids the risk of writing code that does not do what was intended.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e care must be taken not to forward the same argument twice — see {rule:cpp:M23_280}: MISRA C++ 2023 Rule\u0026nbsp;28.6.3.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nvoid f1( std::string \u0026amp;  );          // #1\nvoid f1( std::string \u0026amp;\u0026amp; );          // #2\n\ntemplate\u0026lt; typename T1, typename T2 \u0026gt;\nvoid f2( T1 \u0026amp;\u0026amp; t1, T2 \u0026amp; t2 )\n{\n  f1( t1 );                         // Non-compliant - calls #1\n\n  f1( std::forward\u0026lt; T1 \u0026gt;( t1 ) );   // Compliant - calls #1 (for #4) or #2 (for #3)\n  f1( std::forward\u0026lt; T2 \u0026gt;( t2 ) );   // Non-compliant - calls #2\n  f1( std::forward\u0026lt; T2 \u0026gt;( t1 ) );   // Non-compliant - wrong template parameter\n\n  f1( std::move( t1 ) );            // Non-compliant - calls #2\n  f1( std::move( t2 ) );            // Rule does not apply - calls #2\n\n  auto lambda \u003d [] ( auto \u0026amp;\u0026amp; t )\n                   { f1(t); };      // Non-compliant - calls #1\n}\n\nvoid f3()\n{\n  std::string s;\n\n  f2( std::string { \"Hello\" }, s ); // #3\n  f2( s, s );                       // #4\n}\n\ntemplate\u0026lt; typename T \u0026gt;\nstruct A\n{\n  void foo( T \u0026amp;\u0026amp; t )\n  {\n    std::move( t );    //\u0026nbsp;Rule does not apply - not a forwarding reference\n  }\n};\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S5425} detects when a parameter of forwarding reference type is never used in a \u003ccode\u003estd::forward\u003c/code\u003e call \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S5417} ensures that \u003ccode\u003estd::forward\u003c/code\u003e is not confused with \u003ccode\u003estd::move\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S6031} reports when the incorrect template parameter is provided to std::forward \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:M23_280}: MISRA C++ 2023 Rule\u0026nbsp;28.6.3 ensures that a parameter is never moved or forwarded more than once \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2023 Rule\u0026nbsp;28.6.1 - The argument to \u003ccode\u003estd::move\u003c/code\u003e shall be a non-const \u003cem\u003elvalue\u003c/em\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/27e662b/CppCoreGuidelines.md#f19-for-forward-parameters-pass-by-tp-and-only-stdforward-the-parameter\"\u003eF.19 For \"forward\" parameters, pass by \u003ccode\u003eTP\u0026amp;\u0026amp;\u003c/code\u003e and only \u003ccode\u003estd::forward\u003c/code\u003e the parameter\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/reference#Forwarding_references\"\u003eForwarding references\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e Stack Overflow - Answer by Konrad Rudolph for \u003ca href\u003d\"https://stackoverflow.com/a/24535491\"\u003eHow to perfectly forward\n  \u003ccode\u003eauto\u0026amp;\u0026amp;\u003c/code\u003e in a generic lambda?\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "misra-c++2023",
      "misra-required",
      "pitfall",
      "since-c++11"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1116",
    "name": "Empty statements should be removed",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eEmpty statements represented by a semicolon \u003ccode\u003e;\u003c/code\u003e are statements that do not perform any operation. They are often the result of a typo or\na misunderstanding of the language syntax. It is a good practice to remove empty statements since they don’t add value and lead to confusion and\nerrors.\u003c/p\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eIn the case of an empty expanded macro, the issue is not raised.\u003c/p\u003e\n\u003cpre\u003e\n#define LOG(x)\n\nvoid fun() {\n  LOG(X);\n}\n\u003c/pre\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid doSomething() {\n  ;                // Noncompliant - was used as a kind of TODO marker\n}\n\n#define A(x) x;    // Noncompliant - macro definitions should not end with a semi-colon when they are used as functions\n\nvoid fun() {\n  A(5);            // Noncompliant - after expansion, there are 2 consecutive semi-colons\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid doSomething() {\n}\n\n#define A(x) x\n\nvoid fun() {\n  A(5);\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 14.3 - Before preprocessing, a null statement shall only occur on a line by itself; it may be followed by a comment provided that\n  the first character following the null statement is a white-space character. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 6-2-3 - Before preprocessing, a null statement shall only occur on a line by itself; it may be followed by a comment, provided\n  that the first character following the null statement is a white-space character. \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/5dUxBQ\"\u003eCERT, MSC12-C.\u003c/a\u003e - Detect and remove code that has no effect or is never executed\n  \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/WtYxBQ\"\u003eCERT, EXP15-C.\u003c/a\u003e - Do not place a semicolon on the same line as an if, for, or while\n  statement \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eEmpty statements represented by a semicolon \u003ccode\u003e;\u003c/code\u003e are statements that do not perform any operation. They are often the result of a typo or\na misunderstanding of the language syntax. It is a good practice to remove empty statements since they don’t add value and lead to confusion and\nerrors.\u003c/p\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eIn the case of an empty expanded macro, the issue is not raised.\u003c/p\u003e\n\u003cpre\u003e\n#define LOG(x)\n\nvoid fun() {\n  LOG(X);\n}\n\u003c/pre\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid doSomething() {\n  ;                // Noncompliant - was used as a kind of TODO marker\n}\n\n#define A(x) x;    // Noncompliant - macro definitions should not end with a semi-colon when they are used as functions\n\nvoid fun() {\n  A(5);            // Noncompliant - after expansion, there are 2 consecutive semi-colons\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid doSomething() {\n}\n\n#define A(x) x\n\nvoid fun() {\n  A(5);\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 14.3 - Before preprocessing, a null statement shall only occur on a line by itself; it may be followed by a comment provided that\n  the first character following the null statement is a white-space character. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 6-2-3 - Before preprocessing, a null statement shall only occur on a line by itself; it may be followed by a comment, provided\n  that the first character following the null statement is a white-space character. \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/5dUxBQ\"\u003eCERT, MSC12-C.\u003c/a\u003e - Detect and remove code that has no effect or is never executed\n  \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/WtYxBQ\"\u003eCERT, EXP15-C.\u003c/a\u003e - Do not place a semicolon on the same line as an if, for, or while\n  statement \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "cert",
      "unused"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1479",
    "name": "\"switch\" statements should not have too many \"case\" clauses",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "FOCUSED",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhen \u003ccode\u003eswitch\u003c/code\u003e statements have large sets of \u003ccode\u003ecase\u003c/code\u003e clauses, it is usually an attempt to map two sets of data. A real map\nstructure would be more readable and maintainable, and should be used instead.\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhen \u003ccode\u003eswitch\u003c/code\u003e statements have large sets of \u003ccode\u003ecase\u003c/code\u003e clauses, it is usually an attempt to map two sets of data. A real map\nstructure would be more readable and maintainable, and should be used instead.\u003c/p\u003e"
      }
    ],
    "params": {
      "maximum": {
        "key": "maximum",
        "name": "maximum",
        "description": "Maximum number of case",
        "defaultValue": "30",
        "type": "INTEGER",
        "multiple": false,
        "possibleValues": []
      }
    },
    "defaultParams": {
      "maximum": "30"
    },
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "brain-overload"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:M23_162",
    "name": "A named bit-field with \"signed integer type\" shall not have a length of one bit",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 12.2.3\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eA single-bit signed bit-field is unlikely to behave in a useful way and its presence is likely to indicate an error.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e anonymous signed bit-fields of any length are allowed as they cannot be accessed.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nstruct S\n{\n  signed int a : 1;    // Non-compliant\n  signed int   : 1;    // Rule does not apply\n  signed int   : 0;    // Rule does not apply\n  signed int b : 2;    // Compliant\n         int c : 1;    // Non-compliant\n};\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003e{rule:cpp:S2216} targets the same defect as this rule but for a non-mission-critical context.\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 12.2.3\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eA single-bit signed bit-field is unlikely to behave in a useful way and its presence is likely to indicate an error.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e anonymous signed bit-fields of any length are allowed as they cannot be accessed.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nstruct S\n{\n  signed int a : 1;    // Non-compliant\n  signed int   : 1;    // Rule does not apply\n  signed int   : 0;    // Rule does not apply\n  signed int b : 2;    // Compliant\n         int c : 1;    // Non-compliant\n};\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003e{rule:cpp:S2216} targets the same defect as this rule but for a non-mission-critical context.\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "misra-c++2023",
      "misra-required",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1117",
    "name": "Variables should not be shadowed",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eVariable shadowing happens when a variable declared in a specific scope has the same name as a variable in an outer scope.\u003c/p\u003e\n\u003cp\u003eThis can lead to three main problems:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Confusion: The same name can refer to different variables in different parts of the scope, making the code hard to read and understand. \u003c/li\u003e\n  \u003cli\u003e Unintended Behavior: You might accidentally use the wrong variable, leading to hard-to-detect bugs. \u003c/li\u003e\n  \u003cli\u003e Maintenance Issues: If the inner variable is removed or renamed, the code’s behavior might change unexpectedly because the outer variable is\n  now being used. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eTo avoid these problems, rename the shadowing, shadowed, or both variables to accurately represent their purpose with unique and meaningful\nnames.\u003c/p\u003e\n\u003cp\u003eThe examples below show typical situations in which shadowing can occur.\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Parameter shadowing \u003cpre\u003e\nvoid f(int x, bool b) {\n  int y \u003d 4;\n  if (b) {\n    int x \u003d 7; // Noncompliant: the parameter \"x\" is shadowed.\n    int y \u003d 9; // Noncompliant: the local variable \"y\" is shadowed.\n    // ...\n  }\n}\n\u003c/pre\u003e \u003c/li\u003e\n  \u003cli\u003e Member variable shadowing \u003cpre\u003e\nclass Foo {\nprivate:\n  int myField;\n\npublic:\n  void doSomething() {\n    int myField \u003d 0; // Noncompliant: Foo::myField is shadowed.\n    // ...\n  }\n};\n\u003c/pre\u003e \u003c/li\u003e\n  \u003cli\u003e Global variable shadowing \u003cpre\u003e\nnamespace ns {\n  int state;\n\n  void bar() {\n    int state \u003d 0; // Noncompliant: the namespace variable is shadowed.\n  }\n}\n\u003c/pre\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eIt is common practice to have constructor arguments shadowing the fields they initialize in the \u003cem\u003emember initializer list\u003c/em\u003e. This pattern\navoids the need to select new names for the constructor arguments and will not be reported by this rule.\u003c/p\u003e\n\u003cpre\u003e\nclass Point {\npublic:\n  Point(int x, int y)\n    : x(x) // Compliant by exception: the parameter \"x\" is used\n           // in the member initializer list.\n  {\n    y \u003d y; // Noncompliant: the parameter is assigned to itself\n           // and the member \"y\" is not initialized.\n  }\n\nprivate:\n  int x;\n  int y;\n};\n\u003c/pre\u003e\n\u003ch3\u003eCaveats\u003c/h3\u003e\n\u003ch4\u003eShadowing in \u003ccode\u003eif\u003c/code\u003e, \u003ccode\u003eelse if\u003c/code\u003e, and \u003ccode\u003eelse\u003c/code\u003e\u003c/h4\u003e\n\u003cp\u003eVariables can be introduced in the condition of an \u003ccode\u003eif\u003c/code\u003e statement. Their scope includes the optional \u003ccode\u003eelse\u003c/code\u003e statement, which\nmay be surprising. Consequently, such variables can be shadowed in an \u003ccode\u003eelse if\u003c/code\u003e statement. This can be even more confusing and result in\nunintended behavior, as illustrated in this example:\u003c/p\u003e\n\u003cpre\u003e\nusing ExpectedData \u003d std::expected\u0026lt;std::string, std::error_code\u0026gt;;\n\nif (ExpectedData e \u003d readData()) {\n  printMessage(e.value());\n} else if (ExpectedData e \u003d readFallbackSource()) { // Noncompliant\n  printMessage(e.value());\n} else {\n  logError(\n    \"Initial source failed with: \",\n    e.error() // Contrary to the intention, the second \"e\" is used.\n  );\n}\n\u003c/pre\u003e\n\u003ch4\u003eShadowing of inaccessible declarations\u003c/h4\u003e\n\u003cp\u003eThis rule also raises issues on some variables, although they do not shadow another variable according to a strict interpretation of the C++\nlanguage. There are mainly two reasons for this.\u003c/p\u003e\n\u003col\u003e\n  \u003cli\u003e Primarily, the readability and maintainability of the code are impaired. Readers need an advanced understanding of the C++ language to\n  understand the subtle differences. \u003c/li\u003e\n  \u003cli\u003e Secondly, a small change can lead to actual shadowing. This can lead to subtle bugs when updating the code. \u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eHere is an example with nested classes:\u003c/p\u003e\n\u003cpre\u003e\nclass A {\npublic:\n  int x;\n  class B;\n};\n\nclass A::B {\n  void f(int x) { // Noncompliant: The parameter \"x\" shadows the field \"A::x\".\n    // ...\n  }\n};\n\u003c/pre\u003e\n\u003cp\u003eIn the above example, \u003ccode\u003eA::x\u003c/code\u003e cannot be used from \u003ccode\u003eA::B\u003c/code\u003e member functions because it is not a \u003ccode\u003estatic\u003c/code\u003e field. This\ncan lead to surprising effects when moving code around, particularly if the declaration of \u003ccode\u003eA::x\u003c/code\u003e was changed from \u003ccode\u003eint x;\u003c/code\u003e to\n\u003ccode\u003estatic int x;\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eYou should always avoid shadowing to avoid any confusion and increase the maintainability of your code.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 5.2 - Identifiers in an inner scope shall not use the same name as an identifier in an outer scope, and therefore hide that\n  identifier \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 2-10-2 - Identifiers declared in an inner scope shall not hide an identifier declared in an outer scope \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 5.3 - An identifier declared in an inner scope shall not hide an identifier declared in an outer scope \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/display/c/DCL01-C.+Do+not+reuse+variable+names+in+subscopes\"\u003eDCL01-C. Do not reuse variable\n  names in subscopes\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S2387} - Child class fields should not shadow parent class fields \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eVariable shadowing happens when a variable declared in a specific scope has the same name as a variable in an outer scope.\u003c/p\u003e\n\u003cp\u003eThis can lead to three main problems:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Confusion: The same name can refer to different variables in different parts of the scope, making the code hard to read and understand. \u003c/li\u003e\n  \u003cli\u003e Unintended Behavior: You might accidentally use the wrong variable, leading to hard-to-detect bugs. \u003c/li\u003e\n  \u003cli\u003e Maintenance Issues: If the inner variable is removed or renamed, the code’s behavior might change unexpectedly because the outer variable is\n  now being used. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eTo avoid these problems, rename the shadowing, shadowed, or both variables to accurately represent their purpose with unique and meaningful\nnames.\u003c/p\u003e\n\u003cp\u003eThe examples below show typical situations in which shadowing can occur.\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Parameter shadowing \u003cpre\u003e\nvoid f(int x, bool b) {\n  int y \u003d 4;\n  if (b) {\n    int x \u003d 7; // Noncompliant: the parameter \"x\" is shadowed.\n    int y \u003d 9; // Noncompliant: the local variable \"y\" is shadowed.\n    // ...\n  }\n}\n\u003c/pre\u003e \u003c/li\u003e\n  \u003cli\u003e Member variable shadowing \u003cpre\u003e\nclass Foo {\nprivate:\n  int myField;\n\npublic:\n  void doSomething() {\n    int myField \u003d 0; // Noncompliant: Foo::myField is shadowed.\n    // ...\n  }\n};\n\u003c/pre\u003e \u003c/li\u003e\n  \u003cli\u003e Global variable shadowing \u003cpre\u003e\nnamespace ns {\n  int state;\n\n  void bar() {\n    int state \u003d 0; // Noncompliant: the namespace variable is shadowed.\n  }\n}\n\u003c/pre\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eIt is common practice to have constructor arguments shadowing the fields they initialize in the \u003cem\u003emember initializer list\u003c/em\u003e. This pattern\navoids the need to select new names for the constructor arguments and will not be reported by this rule.\u003c/p\u003e\n\u003cpre\u003e\nclass Point {\npublic:\n  Point(int x, int y)\n    : x(x) // Compliant by exception: the parameter \"x\" is used\n           // in the member initializer list.\n  {\n    y \u003d y; // Noncompliant: the parameter is assigned to itself\n           // and the member \"y\" is not initialized.\n  }\n\nprivate:\n  int x;\n  int y;\n};\n\u003c/pre\u003e\n\u003ch3\u003eCaveats\u003c/h3\u003e\n\u003ch4\u003eShadowing in \u003ccode\u003eif\u003c/code\u003e, \u003ccode\u003eelse if\u003c/code\u003e, and \u003ccode\u003eelse\u003c/code\u003e\u003c/h4\u003e\n\u003cp\u003eVariables can be introduced in the condition of an \u003ccode\u003eif\u003c/code\u003e statement. Their scope includes the optional \u003ccode\u003eelse\u003c/code\u003e statement, which\nmay be surprising. Consequently, such variables can be shadowed in an \u003ccode\u003eelse if\u003c/code\u003e statement. This can be even more confusing and result in\nunintended behavior, as illustrated in this example:\u003c/p\u003e\n\u003cpre\u003e\nusing ExpectedData \u003d std::expected\u0026lt;std::string, std::error_code\u0026gt;;\n\nif (ExpectedData e \u003d readData()) {\n  printMessage(e.value());\n} else if (ExpectedData e \u003d readFallbackSource()) { // Noncompliant\n  printMessage(e.value());\n} else {\n  logError(\n    \"Initial source failed with: \",\n    e.error() // Contrary to the intention, the second \"e\" is used.\n  );\n}\n\u003c/pre\u003e\n\u003ch4\u003eShadowing of inaccessible declarations\u003c/h4\u003e\n\u003cp\u003eThis rule also raises issues on some variables, although they do not shadow another variable according to a strict interpretation of the C++\nlanguage. There are mainly two reasons for this.\u003c/p\u003e\n\u003col\u003e\n  \u003cli\u003e Primarily, the readability and maintainability of the code are impaired. Readers need an advanced understanding of the C++ language to\n  understand the subtle differences. \u003c/li\u003e\n  \u003cli\u003e Secondly, a small change can lead to actual shadowing. This can lead to subtle bugs when updating the code. \u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eHere is an example with nested classes:\u003c/p\u003e\n\u003cpre\u003e\nclass A {\npublic:\n  int x;\n  class B;\n};\n\nclass A::B {\n  void f(int x) { // Noncompliant: The parameter \"x\" shadows the field \"A::x\".\n    // ...\n  }\n};\n\u003c/pre\u003e\n\u003cp\u003eIn the above example, \u003ccode\u003eA::x\u003c/code\u003e cannot be used from \u003ccode\u003eA::B\u003c/code\u003e member functions because it is not a \u003ccode\u003estatic\u003c/code\u003e field. This\ncan lead to surprising effects when moving code around, particularly if the declaration of \u003ccode\u003eA::x\u003c/code\u003e was changed from \u003ccode\u003eint x;\u003c/code\u003e to\n\u003ccode\u003estatic int x;\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eYou should always avoid shadowing to avoid any confusion and increase the maintainability of your code.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 5.2 - Identifiers in an inner scope shall not use the same name as an identifier in an outer scope, and therefore hide that\n  identifier \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 2-10-2 - Identifiers declared in an inner scope shall not hide an identifier declared in an outer scope \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 5.3 - An identifier declared in an inner scope shall not hide an identifier declared in an outer scope \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/display/c/DCL01-C.+Do+not+reuse+variable+names+in+subscopes\"\u003eDCL01-C. Do not reuse variable\n  names in subscopes\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S2387} - Child class fields should not shadow parent class fields \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "cert",
      "pitfall",
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1238",
    "name": "Pass by reference to const should be used for large input parameters",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "EFFICIENT",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eTo pass an input parameter to a function, there are two possibilities: pass by value, or pass by reference to const. Which one is best depends of\nthe size of the object, which is an indicator of the cost to copy it. A small one, with cheap copy constructors, should be passed by value, while a\nlarger one should be passed by reference to const.\u003c/p\u003e\n\u003cp\u003eThis rule detects when a parameter has been passed by value, while it should have been passed by reference to const:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Because it is too large \u003c/li\u003e\n  \u003cli\u003e Because it contains virtual functions and passing it by value will slice the extra members if you happen to pass an object of a derived class.\n  \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn some cases, you may want to pass by value a large object, if you modify it in the function but you don’t want the initial object to be impacted\nby these changes. We do not detect such a situation, which will be a false positive.\u003c/p\u003e\n\u003cp\u003eThere are other ways to pass input parameters for sinks (for instance by rvalue references), but this rule is only about the choice between pass by\nvalue and pass by reference to const.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstruct Student {string firstName; string lastName; Date birthDate;};\nclass XmlNode {\n  virtual ~XmlNode();\n  virtual string toString();\n};\nvoid registerStudent(School \u0026amp;school, Student p); // Noncompliant, Student is a large object\nvoid dump(ostream \u0026amp;out, XmlNode node); // Noncompliant, XmlNode is a polymorphic type\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstruct Student {string firstName; string lastName; Date birthDate;};\nclass XmlNode {\n  virtual ~XmlNode();\n  virtual string toString();\n};\nvoid registerStudent(School \u0026amp;school, Student const \u0026amp; p); // Compliant, avoids useless copy\nvoid dump(ostream \u0026amp;out, XmlNode const \u0026amp;node); // Compliant, no slicing\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThis rule does not flag large objects passed by value to coroutines because passing arguments by reference to a coroutine often leads to dangling\nreferences, e.g., after suspension and resumpion of the coroutine.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f16-for-in-parameters-pass-cheaply-copied-types-by-value-and-others-by-reference-to-const\"\u003eF.16: For \"in\" parameters, pass cheaply-copied types by value and others by reference to \u003ccode\u003econst\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eTo pass an input parameter to a function, there are two possibilities: pass by value, or pass by reference to const. Which one is best depends of\nthe size of the object, which is an indicator of the cost to copy it. A small one, with cheap copy constructors, should be passed by value, while a\nlarger one should be passed by reference to const.\u003c/p\u003e\n\u003cp\u003eThis rule detects when a parameter has been passed by value, while it should have been passed by reference to const:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Because it is too large \u003c/li\u003e\n  \u003cli\u003e Because it contains virtual functions and passing it by value will slice the extra members if you happen to pass an object of a derived class.\n  \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn some cases, you may want to pass by value a large object, if you modify it in the function but you don’t want the initial object to be impacted\nby these changes. We do not detect such a situation, which will be a false positive.\u003c/p\u003e\n\u003cp\u003eThere are other ways to pass input parameters for sinks (for instance by rvalue references), but this rule is only about the choice between pass by\nvalue and pass by reference to const.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstruct Student {string firstName; string lastName; Date birthDate;};\nclass XmlNode {\n  virtual ~XmlNode();\n  virtual string toString();\n};\nvoid registerStudent(School \u0026amp;school, Student p); // Noncompliant, Student is a large object\nvoid dump(ostream \u0026amp;out, XmlNode node); // Noncompliant, XmlNode is a polymorphic type\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstruct Student {string firstName; string lastName; Date birthDate;};\nclass XmlNode {\n  virtual ~XmlNode();\n  virtual string toString();\n};\nvoid registerStudent(School \u0026amp;school, Student const \u0026amp; p); // Compliant, avoids useless copy\nvoid dump(ostream \u0026amp;out, XmlNode const \u0026amp;node); // Compliant, no slicing\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThis rule does not flag large objects passed by value to coroutines because passing arguments by reference to a coroutine often leads to dangling\nreferences, e.g., after suspension and resumpion of the coroutine.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f16-for-in-parameters-pass-cheaply-copied-types-by-value-and-others-by-reference-to-const\"\u003eF.16: For \"in\" parameters, pass cheaply-copied types by value and others by reference to \u003ccode\u003econst\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cppcoreguidelines",
      "performance"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S3657",
    "name": "Assignment operators should not be \"virtual\"",
    "defaultSeverity": "BLOCKER",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eC++ does not support polymorphic copy or move assignment operators. For example, the signature of a copy assignment operator on a \"Base\" class\nwould be \u003ccode\u003eBase\u0026amp; operator\u003d(const Base\u0026amp; other)\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eAnd on a \"Derived\" class that extends \"Base\", it would be \u003ccode\u003eDerived\u0026amp; operator\u003d(const Derived\u0026amp; other)\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eBecause these are two entirely different method signatures, the second method does not override the first, and adding \u003ccode\u003evirtual\u003c/code\u003e to the\n\"Base\" signature does not change which method is called.\u003c/p\u003e\n\u003cp\u003eIt is possible to add an \u003ccode\u003eoperator\u003d\u003c/code\u003e override in a derived class, but doing so is an indication that you may need to reexamine your\napplication architecture.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass Base {\npublic:\n  virtual Base\u0026amp; operator\u003d(const Base\u0026amp; other); // Noncompliant\n};\n\nclass Derived : public Base {\npublic:\n  Derived\u0026amp; operator\u003d(const Derived\u0026amp; other);\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nclass Base {\nprotected:\n  Base\u0026amp; operator\u003d(const Base\u0026amp; other); // not virtual\n};\n\nclass Derived : public Base {\npublic:\n  Derived\u0026amp; operator\u003d(const Derived\u0026amp; other);\n};\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c60-make-copy-assignment-non-virtual-take-the-parameter-by-const-and-return-by-non-const\"\u003eC.60: Make copy assignment non-\u003ccode\u003evirtual\u003c/code\u003e, take the parameter by \u003ccode\u003econst\u0026amp;\u003c/code\u003e, and return by non-\u003ccode\u003econst\u0026amp;\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c63-make-move-assignment-non-virtual-take-the-parameter-by—​and-return-by-non-const\"\u003eC.63: Make move assignment non-\u003ccode\u003evirtual\u003c/code\u003e, take the parameter by \u003ccode\u003e\u0026amp;\u0026amp;\u003c/code\u003e, and return by non-\u003ccode\u003econst\u0026amp;\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eC++ does not support polymorphic copy or move assignment operators. For example, the signature of a copy assignment operator on a \"Base\" class\nwould be \u003ccode\u003eBase\u0026amp; operator\u003d(const Base\u0026amp; other)\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eAnd on a \"Derived\" class that extends \"Base\", it would be \u003ccode\u003eDerived\u0026amp; operator\u003d(const Derived\u0026amp; other)\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eBecause these are two entirely different method signatures, the second method does not override the first, and adding \u003ccode\u003evirtual\u003c/code\u003e to the\n\"Base\" signature does not change which method is called.\u003c/p\u003e\n\u003cp\u003eIt is possible to add an \u003ccode\u003eoperator\u003d\u003c/code\u003e override in a derived class, but doing so is an indication that you may need to reexamine your\napplication architecture.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass Base {\npublic:\n  virtual Base\u0026amp; operator\u003d(const Base\u0026amp; other); // Noncompliant\n};\n\nclass Derived : public Base {\npublic:\n  Derived\u0026amp; operator\u003d(const Derived\u0026amp; other);\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nclass Base {\nprotected:\n  Base\u0026amp; operator\u003d(const Base\u0026amp; other); // not virtual\n};\n\nclass Derived : public Base {\npublic:\n  Derived\u0026amp; operator\u003d(const Derived\u0026amp; other);\n};\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c60-make-copy-assignment-non-virtual-take-the-parameter-by-const-and-return-by-non-const\"\u003eC.60: Make copy assignment non-\u003ccode\u003evirtual\u003c/code\u003e, take the parameter by \u003ccode\u003econst\u0026amp;\u003c/code\u003e, and return by non-\u003ccode\u003econst\u0026amp;\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c63-make-move-assignment-non-virtual-take-the-parameter-by—​and-return-by-non-const\"\u003eC.63: Make move assignment non-\u003ccode\u003evirtual\u003c/code\u003e, take the parameter by \u003ccode\u003e\u0026amp;\u0026amp;\u003c/code\u003e, and return by non-\u003ccode\u003econst\u0026amp;\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cppcoreguidelines",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:M23_042",
    "name": "Function-like macros shall not be defined",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 19.0.2\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eFunctions have a number of advantages over function-like macros, including:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Function arguments and return values are type-checked; \u003c/li\u003e\n  \u003cli\u003e Function arguments are evaluated once, preventing problems with potential multiple side effects; \u003c/li\u003e\n  \u003cli\u003e Function names follow classical scoping rules; \u003c/li\u003e\n  \u003cli\u003e Functions can be overloaded and templatized; \u003c/li\u003e\n  \u003cli\u003e The address of a function can be passed to another function; \u003c/li\u003e\n  \u003cli\u003e Function calls can be inlined, providing the same performance characteristics as macros; \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003econstexpr\u003c/code\u003e functions can be evaluated at compile-time and may be used in all contexts where a compile-time constant is required;\n  \u003c/li\u003e\n  \u003cli\u003e In many debugging systems, it is easier to step through execution of a function than a macro. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eException\u003c/h3\u003e\n\u003cp\u003eAs it is not possible to implement equivalent behaviour within a function, a function-like macro may be defined if its definition includes any of\nthe following:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003e__LINE__\u003c/code\u003e, \u003ccode\u003e__FILE__\u003c/code\u003e or \u003ccode\u003e__func__\u003c/code\u003e; \u003c/li\u003e\n  \u003cli\u003e The \u003ccode\u003e#\u003c/code\u003e or \u003ccode\u003e##\u003c/code\u003e operators. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\n#define FUNC( X ) \\\n  ( ( X ) + ( X ) )             // Non-compliant\n\ntemplate\u0026lt; typename T \u0026gt;\nconstexpr auto func( T x )      // Possible alternative\n{\n  return x + x;\n}\n\u003c/pre\u003e\n\u003cp\u003eThe following examples are compliant by exception:\u003c/p\u003e\n\u003cpre\u003e\n#define ID( name ) \\\n  constexpr auto name \u003d #name;  // Compliant - use of #\n\n#define TAG( name ) \\\n  class name##Tag {};           // Compliant - use of ##\n\n#define LOG( message ) \\\n  log( __func__, message );     // Compliant - use of __func__\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S960} targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S6190} proposes a replacement for \u003ccode\u003e__FILE__\u003c/code\u003e, \u003ccode\u003e__LINE__\u003c/code\u003e and \u003ccode\u003e__func__\u003c/code\u003e in C++20 \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:M23_212}: MISRA C++ 2023 Rule\u0026nbsp;19.3.1 - The \u003ccode\u003e#\u003c/code\u003e and \u003ccode\u003e##\u003c/code\u003e preprocessor operators should not be used \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/INcxBQ\"\u003eCERT, PRE00-C.\u003c/a\u003e - Prefer inline or static functions to function-like macros \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/036324/CppCoreGuidelines.md#es31-dont-use-macros-for-constants-or-functions\"\u003eC++ Core\n  Guidelines ES.31\u003c/a\u003e - Don’t use macros for constants or \"functions\" \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 19.0.2\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eFunctions have a number of advantages over function-like macros, including:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Function arguments and return values are type-checked; \u003c/li\u003e\n  \u003cli\u003e Function arguments are evaluated once, preventing problems with potential multiple side effects; \u003c/li\u003e\n  \u003cli\u003e Function names follow classical scoping rules; \u003c/li\u003e\n  \u003cli\u003e Functions can be overloaded and templatized; \u003c/li\u003e\n  \u003cli\u003e The address of a function can be passed to another function; \u003c/li\u003e\n  \u003cli\u003e Function calls can be inlined, providing the same performance characteristics as macros; \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003econstexpr\u003c/code\u003e functions can be evaluated at compile-time and may be used in all contexts where a compile-time constant is required;\n  \u003c/li\u003e\n  \u003cli\u003e In many debugging systems, it is easier to step through execution of a function than a macro. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eException\u003c/h3\u003e\n\u003cp\u003eAs it is not possible to implement equivalent behaviour within a function, a function-like macro may be defined if its definition includes any of\nthe following:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003e__LINE__\u003c/code\u003e, \u003ccode\u003e__FILE__\u003c/code\u003e or \u003ccode\u003e__func__\u003c/code\u003e; \u003c/li\u003e\n  \u003cli\u003e The \u003ccode\u003e#\u003c/code\u003e or \u003ccode\u003e##\u003c/code\u003e operators. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\n#define FUNC( X ) \\\n  ( ( X ) + ( X ) )             // Non-compliant\n\ntemplate\u0026lt; typename T \u0026gt;\nconstexpr auto func( T x )      // Possible alternative\n{\n  return x + x;\n}\n\u003c/pre\u003e\n\u003cp\u003eThe following examples are compliant by exception:\u003c/p\u003e\n\u003cpre\u003e\n#define ID( name ) \\\n  constexpr auto name \u003d #name;  // Compliant - use of #\n\n#define TAG( name ) \\\n  class name##Tag {};           // Compliant - use of ##\n\n#define LOG( message ) \\\n  log( __func__, message );     // Compliant - use of __func__\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S960} targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S6190} proposes a replacement for \u003ccode\u003e__FILE__\u003c/code\u003e, \u003ccode\u003e__LINE__\u003c/code\u003e and \u003ccode\u003e__func__\u003c/code\u003e in C++20 \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:M23_212}: MISRA C++ 2023 Rule\u0026nbsp;19.3.1 - The \u003ccode\u003e#\u003c/code\u003e and \u003ccode\u003e##\u003c/code\u003e preprocessor operators should not be used \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/INcxBQ\"\u003eCERT, PRE00-C.\u003c/a\u003e - Prefer inline or static functions to function-like macros \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/036324/CppCoreGuidelines.md#es31-dont-use-macros-for-constants-or-functions\"\u003eC++ Core\n  Guidelines ES.31\u003c/a\u003e - Don’t use macros for constants or \"functions\" \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "misra-c++2023",
      "misra-required",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:M23_163",
    "name": "Classes should not be inherited virtually",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 13.1.1\u003c/p\u003e\n\u003cp\u003eCategory: Advisory\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eVirtual inheritance of base classes is not recommended as it introduces a number of potentially confusing behaviours, such as call by dominance in\ndiamond hierarchies and changes to the order of initialization of bases.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nstruct A\n{\n  virtual int32_t foo() { return 1; }\n};\n\nstruct B : public virtual A            // Non-compliant\n{\n  int32_t goo()\n  {\n    return foo();\n  }\n};\n\nstruct C : public virtual A            // Non-compliant\n{\n  int32_t foo() override { return 2; }\n};\n\nstruct D : C, B\n{\n};\n\nint main()\n{\n  D d;\n\n  return d.goo();                      // Calls C::foo(), which may not be expected\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S1011} targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:M23_087}: MISRA C++ 2023 Rule\u0026nbsp;8.2.1 - A virtual base class shall only be cast to a derived class by means of\n  \u003ccode\u003edynamic_cast\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2023 Rule\u0026nbsp;13.1.2 - An accessible base class shall not be both virtual and non-virtual in the same hierarchy \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2023 Rule\u0026nbsp;15.1.1 - An object’s dynamic type shall not be used from within its constructor or destructor \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 13.1.1\u003c/p\u003e\n\u003cp\u003eCategory: Advisory\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eVirtual inheritance of base classes is not recommended as it introduces a number of potentially confusing behaviours, such as call by dominance in\ndiamond hierarchies and changes to the order of initialization of bases.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nstruct A\n{\n  virtual int32_t foo() { return 1; }\n};\n\nstruct B : public virtual A            // Non-compliant\n{\n  int32_t goo()\n  {\n    return foo();\n  }\n};\n\nstruct C : public virtual A            // Non-compliant\n{\n  int32_t foo() override { return 2; }\n};\n\nstruct D : C, B\n{\n};\n\nint main()\n{\n  D d;\n\n  return d.goo();                      // Calls C::foo(), which may not be expected\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S1011} targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:M23_087}: MISRA C++ 2023 Rule\u0026nbsp;8.2.1 - A virtual base class shall only be cast to a derived class by means of\n  \u003ccode\u003edynamic_cast\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2023 Rule\u0026nbsp;13.1.2 - An accessible base class shall not be both virtual and non-virtual in the same hierarchy \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2023 Rule\u0026nbsp;15.1.1 - An object’s dynamic type shall not be used from within its constructor or destructor \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "bad-practice",
      "misra-advisory",
      "misra-c++2023"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S3539",
    "name": "Access specifiers should not be redundant",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eRedundant access specifiers should be removed because they needlessly clutter the code.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nstruct S {\n  public: // Noncompliant; does not affect any declaration\n  private:\n    void method();\n  private: // Noncompliant; does not change accessibility level\n    int member;\n  private: // Noncompliant; does not affect any declaration\n};\nclass C {\n    int member;\n  private: // Noncompliant;  does not change accessibility level\n    void method();\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nstruct S {\n  private:\n    void method();\n    int member;\n};\nclass C {\n    int member;\n    void method();\n};\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eAn access specifier at the very beginning of a \u003ccode\u003eclass\u003c/code\u003e or \u003ccode\u003estruct\u003c/code\u003e that matches the default access level is ignored even when\nit doesn’t change any accessibility levels.\u003c/p\u003e\n\u003cpre\u003e\nclass C {\n  private: // redundant but accepted\n    // ...\n};\nstruct S {\n  public: // redundant but accepted\n    // ...\n};\n\u003c/pre\u003e\n\u003cp\u003eSuch a specifier is redundant but ignored to allow \u003ccode\u003eclass\u003c/code\u003ees and \u003ccode\u003estruct\u003c/code\u003es to be described uniformly.\u003c/p\u003e\n\u003cpre\u003e\nclass C {\n  public:\n    void call();\n\n  protected:\n    int delete();\n\n  private:\n    int code;\n};\nstruct S {\n  public: // redundant but accepted\n    int sum();\n\n  protected:\n    int min();\n\n  private:\n    int count;\n};\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eRedundant access specifiers should be removed because they needlessly clutter the code.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nstruct S {\n  public: // Noncompliant; does not affect any declaration\n  private:\n    void method();\n  private: // Noncompliant; does not change accessibility level\n    int member;\n  private: // Noncompliant; does not affect any declaration\n};\nclass C {\n    int member;\n  private: // Noncompliant;  does not change accessibility level\n    void method();\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nstruct S {\n  private:\n    void method();\n    int member;\n};\nclass C {\n    int member;\n    void method();\n};\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eAn access specifier at the very beginning of a \u003ccode\u003eclass\u003c/code\u003e or \u003ccode\u003estruct\u003c/code\u003e that matches the default access level is ignored even when\nit doesn’t change any accessibility levels.\u003c/p\u003e\n\u003cpre\u003e\nclass C {\n  private: // redundant but accepted\n    // ...\n};\nstruct S {\n  public: // redundant but accepted\n    // ...\n};\n\u003c/pre\u003e\n\u003cp\u003eSuch a specifier is redundant but ignored to allow \u003ccode\u003eclass\u003c/code\u003ees and \u003ccode\u003estruct\u003c/code\u003es to be described uniformly.\u003c/p\u003e\n\u003cpre\u003e\nclass C {\n  public:\n    void call();\n\n  protected:\n    int delete();\n\n  private:\n    int code;\n};\nstruct S {\n  public: // redundant but accepted\n    int sum();\n\n  protected:\n    int min();\n\n  private:\n    int count;\n};\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "clumsy",
      "redundant"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:M23_043",
    "name": "Tokens that look like a preprocessing directive shall not occur within a macro argument",
    "defaultSeverity": "BLOCKER",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW",
      "RELIABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 19.3.5\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eA macro argument containing sequences of tokens that would otherwise act as preprocessing directives results in \u003cem\u003eundefined behaviour\u003c/em\u003e.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\n#define M(A) printf ( #A )\n\nint main()\n{\n   M(\n#ifdef SW        // Non-compliant\n   \"Message 1\"\n#else            // Non-compliant\n   \"Message 2\"\n#endif           // Non-compliant\n    );\n}\n\u003c/pre\u003e\n\u003cp\u003eThe above could print:\u003c/p\u003e\n\u003cpre\u003e\n#ifdef SW \"Message 1\" #else \"Message 2\" #endif\n\u003c/pre\u003e\n\u003cp\u003eor it could print:\u003c/p\u003e\n\u003cpre\u003e\nMessage 2\n\u003c/pre\u003e\n\u003cp\u003eor it could exhibit some other behaviour.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cp\u003e\u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/display/c/PRE32-C.+Do+not+use+preprocessor+directives+in+invocations+of+function-like+macros\"\u003eCERT,\nPRE32-C.\u003c/a\u003e - Do not use preprocessor directives in invocations of function-like macros\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 19.3.5\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eA macro argument containing sequences of tokens that would otherwise act as preprocessing directives results in \u003cem\u003eundefined behaviour\u003c/em\u003e.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\n#define M(A) printf ( #A )\n\nint main()\n{\n   M(\n#ifdef SW        // Non-compliant\n   \"Message 1\"\n#else            // Non-compliant\n   \"Message 2\"\n#endif           // Non-compliant\n    );\n}\n\u003c/pre\u003e\n\u003cp\u003eThe above could print:\u003c/p\u003e\n\u003cpre\u003e\n#ifdef SW \"Message 1\" #else \"Message 2\" #endif\n\u003c/pre\u003e\n\u003cp\u003eor it could print:\u003c/p\u003e\n\u003cpre\u003e\nMessage 2\n\u003c/pre\u003e\n\u003cp\u003eor it could exhibit some other behaviour.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cp\u003e\u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/display/c/PRE32-C.+Do+not+use+preprocessor+directives+in+invocations+of+function-like+macros\"\u003eCERT,\nPRE32-C.\u003c/a\u003e - Do not use preprocessor directives in invocations of function-like macros\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "misra-c++2023",
      "misra-required",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S3659",
    "name": "Alternative operators should not be used",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eEven though the C++ standard defines both \"Primary\" and \"Alternative\" operators, it is \u003cem\u003enot\u003c/em\u003e a good idea to use the alternatives. Developers\nseeing an alphabetical name expect a variable, a function, a class, a namespace…​ in short, anything but an operator, and they will be confused at\nbest by code that uses such operators.\u003c/p\u003e\n\u003ctable\u003e\n  \u003ccolgroup\u003e\n    \u003ccol style\u003d\"width: 50%;\"\u003e\n    \u003ccol style\u003d\"width: 50%;\"\u003e\n  \u003c/colgroup\u003e\n  \u003cthead\u003e\n    \u003ctr\u003e\n      \u003cth\u003ePrimary\u003c/th\u003e\n      \u003cth\u003eAlternative\u003c/th\u003e\n    \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003e\u0026amp;\u0026amp;\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003eand\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003e\u0026amp;\u003d\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003eand_eq\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003e\u0026amp;\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003ebitand\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003e|\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003ebitor\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003e~\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003ecompl\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003e!\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003enot\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003e!\u003d\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003enot_eq\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003e||\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003eor\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003e|\u003d\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003eor_eq\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003e^\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003exor\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003e^\u003d\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003exor_eq\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nif (not valid or error) { // Noncompliant\n  /* ... */\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nif (!valid || error) {\n  /* ... */\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eEven though the C++ standard defines both \"Primary\" and \"Alternative\" operators, it is \u003cem\u003enot\u003c/em\u003e a good idea to use the alternatives. Developers\nseeing an alphabetical name expect a variable, a function, a class, a namespace…​ in short, anything but an operator, and they will be confused at\nbest by code that uses such operators.\u003c/p\u003e\n\u003ctable\u003e\n  \u003ccolgroup\u003e\n    \u003ccol style\u003d\"width: 50%;\"\u003e\n    \u003ccol style\u003d\"width: 50%;\"\u003e\n  \u003c/colgroup\u003e\n  \u003cthead\u003e\n    \u003ctr\u003e\n      \u003cth\u003ePrimary\u003c/th\u003e\n      \u003cth\u003eAlternative\u003c/th\u003e\n    \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003e\u0026amp;\u0026amp;\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003eand\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003e\u0026amp;\u003d\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003eand_eq\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003e\u0026amp;\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003ebitand\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003e|\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003ebitor\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003e~\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003ecompl\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003e!\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003enot\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003e!\u003d\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003enot_eq\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003e||\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003eor\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003e|\u003d\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003eor_eq\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003e^\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003exor\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003e^\u003d\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003exor_eq\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nif (not valid or error) { // Noncompliant\n  /* ... */\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nif (!valid || error) {\n  /* ... */\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S2209",
    "name": "\"static\" members should be accessed statically",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhile it is \u003cem\u003epossible\u003c/em\u003e to access \u003ccode\u003estatic\u003c/code\u003e members from a class instance, it’s bad form, and considered by most to be misleading\nbecause it implies to the readers of your code that there’s an instance of the member per class instance.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass MyClass {\npublic :\n  static void Mymethod() {\n    // ...\n  }\n};\n\nMyClass* pmyclass \u003d new MyClass();\npmyclass-\u0026gt;Mymethod(); // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nclass MyClass {\npublic :\n  static Mymethod() {\n    // ...\n  }\n};\n\nMyclass::Mymethod();\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhile it is \u003cem\u003epossible\u003c/em\u003e to access \u003ccode\u003estatic\u003c/code\u003e members from a class instance, it’s bad form, and considered by most to be misleading\nbecause it implies to the readers of your code that there’s an instance of the member per class instance.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass MyClass {\npublic :\n  static void Mymethod() {\n    // ...\n  }\n};\n\nMyClass* pmyclass \u003d new MyClass();\npmyclass-\u0026gt;Mymethod(); // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nclass MyClass {\npublic :\n  static Mymethod() {\n    // ...\n  }\n};\n\nMyclass::Mymethod();\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:M23_280",
    "name": "An object shall not be used while in a \"potentially moved-from state\"",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 28.6.3\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable, Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eCalling \u003ccode\u003estd::move\u003c/code\u003e, \u003ccode\u003estd::forward\u003c/code\u003e or an equivalent \u003ccode\u003estatic_cast\u003c/code\u003e puts its argument into a \u003cem\u003epotentially\nmoved-from state\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eAn object in a \u003cem\u003epotentially moved-from state\u003c/em\u003e shall not be used on any path, regardless of the path’s feasibility.\u003c/p\u003e\n\u003cp\u003eAn object passed as an \u003cem\u003elvalue reference\u003c/em\u003e function parameter shall not be in a \u003cem\u003epotentially moved-from state\u003c/em\u003e when the function\nreturns. This additional restriction is included as it allows compliance to be determined within a \u003cem\u003etranslation unit\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eThis rule does not apply to the following:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Assigning to an object; or \u003c/li\u003e\n  \u003cli\u003e Destroying an object; or \u003c/li\u003e\n  \u003cli\u003e Using an object having type \u003ccode\u003estd::unique_ptr\u003c/code\u003e. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eFor the purposes of this rule, aliases of an object are considered to refer to different objects. This allows compliance checks to be\ndecidable.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eUsing \u003ccode\u003estd::forward\u003c/code\u003e or \u003ccode\u003estd::move\u003c/code\u003e on an \u003cem\u003elvalue\u003c/em\u003e to pass it as an \u003cem\u003ervalue reference\u003c/em\u003e argument in a function\ncall can result in the \u003cem\u003elvalue\u003c/em\u003e object being in an indeterminate state after the call. However, a \u003ccode\u003estd::unique_ptr\u003c/code\u003e that has been\n\u003cem\u003emoved-from\u003c/em\u003e is in a well-defined state, equal to \u003ccode\u003enullptr\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nsize_t a( std::string s1 )\n{\n  std::string s2 \u003d std::move( s1 );\n  return s1.size();                      // Non-compliant - s1 has potentially\n}                                        //                 moved-from state\n\nsize_t b( std::string s1 )\n{\n  std::string s2 \u003d\n    static_cast\u0026lt; std::string \u0026amp;\u0026amp; \u0026gt;( s1 ); // Equivalent to std::move\n  return s1.size();                      // Non-compliant - s1 has potentially\n}                                        //                 moved-from state\n\nvoid c( std::string s1 )\n{\n  std::string s2 \u003d std::move( s1 );\n  std::string s3 \u003d s1;                   // Non-compliant - s1 has potentially\n}                                        //                 moved-from state\n\ntemplate\u0026lt; typename T \u0026gt;\nvoid bar( T \u0026amp; t );\n\ntemplate\u0026lt; typename T \u0026gt;\nvoid foo( T \u0026amp;\u0026amp; t )\n{\n  bar( std::forward\u0026lt; T \u0026gt;( t ) );\n  ++t;                                   // Non-compliant - std::forward leaves t\n}                                        //   in a potentially moved-from state\n\nstruct X { std::string s; };\n\nvoid f( X \u0026amp; x )\n{\n  X y ( std::move( x ) );                // Non-compliant - lvalue reference\n                                         //   parameter left in potentially moved-\n}                                        //   from state when function returns\n\nvoid g( X x )\n{\n  X y;\n\n  y \u003d std::move( x );                    // Compliant - no more uses of x\n}\n\nvoid h( X x )\n{\n  X y;\n\n  y \u003d std::move( x );\n  x \u003d X{};                               // Compliant - assigns to potentially\n}                                        //             moved-from object\n\u003c/pre\u003e\n\u003cp\u003eThe following example is non-compliant as the evaluation order of the arguments to \u003ccode\u003ed1\u003c/code\u003e is \u003cem\u003eimplementation-defined\u003c/em\u003e and there is\na permitted order in which the first argument \u003ccode\u003es\u003c/code\u003e has \u003cem\u003epotentially moved-from state\u003c/em\u003e.\u003c/p\u003e\n\u003cpre\u003e\nvoid    d1 ( std::string const \u0026amp;, int32_t );\nint32_t d2 ( std::string \u0026amp;\u0026amp; );\n\nvoid d3( std::string s )\n{\n  d1( s, d2( std::move( s ) ) );         // Non-compliant\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003e{rule:cpp:S5272} targets the same defect as this rule but for a non-mission-critical context.\u003c/p\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cp\u003e\u003ca href\u003d\"https://www.securecoding.cert.org/confluence/x/O3s-BQ\"\u003eCERT, EXP63-CPP.\u003c/a\u003e - Do not rely on the value of a moved-from object\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 28.6.3\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable, Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eCalling \u003ccode\u003estd::move\u003c/code\u003e, \u003ccode\u003estd::forward\u003c/code\u003e or an equivalent \u003ccode\u003estatic_cast\u003c/code\u003e puts its argument into a \u003cem\u003epotentially\nmoved-from state\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eAn object in a \u003cem\u003epotentially moved-from state\u003c/em\u003e shall not be used on any path, regardless of the path’s feasibility.\u003c/p\u003e\n\u003cp\u003eAn object passed as an \u003cem\u003elvalue reference\u003c/em\u003e function parameter shall not be in a \u003cem\u003epotentially moved-from state\u003c/em\u003e when the function\nreturns. This additional restriction is included as it allows compliance to be determined within a \u003cem\u003etranslation unit\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eThis rule does not apply to the following:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Assigning to an object; or \u003c/li\u003e\n  \u003cli\u003e Destroying an object; or \u003c/li\u003e\n  \u003cli\u003e Using an object having type \u003ccode\u003estd::unique_ptr\u003c/code\u003e. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eFor the purposes of this rule, aliases of an object are considered to refer to different objects. This allows compliance checks to be\ndecidable.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eUsing \u003ccode\u003estd::forward\u003c/code\u003e or \u003ccode\u003estd::move\u003c/code\u003e on an \u003cem\u003elvalue\u003c/em\u003e to pass it as an \u003cem\u003ervalue reference\u003c/em\u003e argument in a function\ncall can result in the \u003cem\u003elvalue\u003c/em\u003e object being in an indeterminate state after the call. However, a \u003ccode\u003estd::unique_ptr\u003c/code\u003e that has been\n\u003cem\u003emoved-from\u003c/em\u003e is in a well-defined state, equal to \u003ccode\u003enullptr\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nsize_t a( std::string s1 )\n{\n  std::string s2 \u003d std::move( s1 );\n  return s1.size();                      // Non-compliant - s1 has potentially\n}                                        //                 moved-from state\n\nsize_t b( std::string s1 )\n{\n  std::string s2 \u003d\n    static_cast\u0026lt; std::string \u0026amp;\u0026amp; \u0026gt;( s1 ); // Equivalent to std::move\n  return s1.size();                      // Non-compliant - s1 has potentially\n}                                        //                 moved-from state\n\nvoid c( std::string s1 )\n{\n  std::string s2 \u003d std::move( s1 );\n  std::string s3 \u003d s1;                   // Non-compliant - s1 has potentially\n}                                        //                 moved-from state\n\ntemplate\u0026lt; typename T \u0026gt;\nvoid bar( T \u0026amp; t );\n\ntemplate\u0026lt; typename T \u0026gt;\nvoid foo( T \u0026amp;\u0026amp; t )\n{\n  bar( std::forward\u0026lt; T \u0026gt;( t ) );\n  ++t;                                   // Non-compliant - std::forward leaves t\n}                                        //   in a potentially moved-from state\n\nstruct X { std::string s; };\n\nvoid f( X \u0026amp; x )\n{\n  X y ( std::move( x ) );                // Non-compliant - lvalue reference\n                                         //   parameter left in potentially moved-\n}                                        //   from state when function returns\n\nvoid g( X x )\n{\n  X y;\n\n  y \u003d std::move( x );                    // Compliant - no more uses of x\n}\n\nvoid h( X x )\n{\n  X y;\n\n  y \u003d std::move( x );\n  x \u003d X{};                               // Compliant - assigns to potentially\n}                                        //             moved-from object\n\u003c/pre\u003e\n\u003cp\u003eThe following example is non-compliant as the evaluation order of the arguments to \u003ccode\u003ed1\u003c/code\u003e is \u003cem\u003eimplementation-defined\u003c/em\u003e and there is\na permitted order in which the first argument \u003ccode\u003es\u003c/code\u003e has \u003cem\u003epotentially moved-from state\u003c/em\u003e.\u003c/p\u003e\n\u003cpre\u003e\nvoid    d1 ( std::string const \u0026amp;, int32_t );\nint32_t d2 ( std::string \u0026amp;\u0026amp; );\n\nvoid d3( std::string s )\n{\n  d1( s, d2( std::move( s ) ) );         // Non-compliant\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003e{rule:cpp:S5272} targets the same defect as this rule but for a non-mission-critical context.\u003c/p\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cp\u003e\u003ca href\u003d\"https://www.securecoding.cert.org/confluence/x/O3s-BQ\"\u003eCERT, EXP63-CPP.\u003c/a\u003e - Do not rely on the value of a moved-from object\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "misra-c++2023",
      "misra-required",
      "pitfall",
      "unpredictable"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5950",
    "name": "\"make_unique\" and \"make_shared\" should be used to construct \"unique_ptr\" and \"shared_ptr\"",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003emake_unique\u003c/code\u003e and \u003ccode\u003emake_shared\u003c/code\u003e are more concise than explicitly calling the constructor of \u003ccode\u003eunique_ptr\u003c/code\u003e and\n\u003ccode\u003eshared_ptr\u003c/code\u003e since they don’t require specifying the type multiple times and eliminate the need to use \u003ccode\u003enew\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003emake_unique\u003c/code\u003e and \u003ccode\u003emake_shared\u003c/code\u003e should also be preferred for exception-safety and performance reasons.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eException-Safety\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eWhile \u003ccode\u003emake_unique\u003c/code\u003e and \u003ccode\u003emake_shared\u003c/code\u003e are exception-safe, complex constructions of \u003ccode\u003eunique_ptr\u003c/code\u003e and\n\u003ccode\u003eshared_ptr\u003c/code\u003e might not be because C++ allows arbitrary order of evaluation of subexpressions (until C++17).\u003c/p\u003e\n\u003cp\u003eConsider this example:\u003c/p\u003e\n\u003cpre\u003e\nf(unique_ptr\u0026lt;Lhs\u0026gt;(new Lhs()), throwingFunction());\n\u003c/pre\u003e\n\u003cp\u003eThe following scenario can happen:\u003c/p\u003e\n\u003col\u003e\n  \u003cli\u003e Memory allocation for \u003ccode\u003eLhs\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e Construction of the \u003ccode\u003eLhs\u003c/code\u003e object \u003c/li\u003e\n  \u003cli\u003e Call to \u003ccode\u003ethrowingFunction\u003c/code\u003e (before the \u003ccode\u003eunique_ptr\u003c/code\u003e construction) \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003ethrowingFunction\u003c/code\u003e throws an exception \u003c/li\u003e\n  \u003cli\u003e The constructed \u003ccode\u003eLhs\u003c/code\u003e object is leaked since the \u003ccode\u003eunique_ptr\u003c/code\u003e isn’t constructed yet \u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eNote: This scenario can only happen before C++17. Since C++17, the standard states that even though the order of evaluation of each argument is\nstill unspecified, interleaving the evaluation of different arguments is no longer allowed. This makes the direct construction of\n\u003ccode\u003eunique_ptr\u003c/code\u003e and \u003ccode\u003eshared_ptr\u003c/code\u003e exception-safe.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003ePerformance\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eUsing \u003ccode\u003emake_unique()\u003c/code\u003e doesn’t impact performance, but \u003ccode\u003emake_shared()\u003c/code\u003e improves it slightly.\u003cbr\u003e Indeed, constructing\nexplicitly a \u003ccode\u003eshared_ptr()\u003c/code\u003e requires two heap allocations: one for the managed object and the other for the control block that stores data\nabout the ref-counts and the \u003ccode\u003eshared_ptr()\u003c/code\u003e deleter. \u003ccode\u003emake_shared()\u003c/code\u003e on the other hand, performs only one heap allocation.\u003c/p\u003e\n\u003cp\u003eNote: Because \u003ccode\u003emake_shared\u003c/code\u003e performs only one allocation for both the object and the control block, the memory occupied by the object\nwill be deallocated when no \u003ccode\u003eshared_ptr\u003c/code\u003e or \u003ccode\u003eweak_ptr\u003c/code\u003e points to it. If the object is large, a \u003ccode\u003eweak_ptr\u003c/code\u003e is used,\nand memory is a concern, explicitly calling the constructor of \u003ccode\u003eshared_ptr\u003c/code\u003e may be preferred. This way, the object’s memory will be\ndeallocated when there are no more shared owners, independently of any \u003ccode\u003eweak_ptr\u003c/code\u003es.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstd::unique_ptr\u0026lt;MyClass\u0026gt; uniqueP(new MyClass(42)); // Noncompliant\nstd::shared_ptr\u0026lt;MyClass\u0026gt; sharedP(new MyClass(42)); // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nauto uniqueP \u003d std::make_unique\u0026lt;MyClass\u0026gt;(42);\nauto sharedP \u003d std::make_shared\u0026lt;MyClass\u0026gt;(42);\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThis rule ignores code that uses features not supported by \u003ccode\u003emake_shared\u003c/code\u003e and \u003ccode\u003emake_unique\u003c/code\u003e:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e custom deleters \u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\nstd::unique_ptr\u0026lt;std::FILE, std::function\u0026lt;void(std::FILE*)\u0026gt;\u0026gt; file(\n  fopen(\"example.txt\", \"r\"),\n  [](FILE* inFile) { fclose(inFile); }); // Compliant: custom deleter is specified\n\u003c/pre\u003e\n\u003cul\u003e\n  \u003cli\u003e calling placement-new, i.e., version of \u003ccode\u003enew\u003c/code\u003e with arguments, like \u003ccode\u003enew(std::nothrow)\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn addition, \u003ccode\u003emake_shared\u003c/code\u003e does not support the following:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e custom operator \u003ccode\u003enew\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e allocating arrays (before C++20) \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c150-use-make_unique-to-construct-objects-owned-by-unique_ptrs\"\u003eC.150: Use \u003ccode\u003emake_unique()\u003c/code\u003e to construct objects owned by \u003ccode\u003eunique_ptr\u003c/code\u003es\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c151-use-make_shared-to-construct-objects-owned-by-shared_ptrs\"\u003eC.151: Use \u003ccode\u003emake_shared()\u003c/code\u003e to construct objects owned by \u003ccode\u003eshared_ptr\u003c/code\u003es\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003ccode\u003emake_unique\u003c/code\u003e and \u003ccode\u003emake_shared\u003c/code\u003e are more concise than explicitly calling the constructor of \u003ccode\u003eunique_ptr\u003c/code\u003e and\n\u003ccode\u003eshared_ptr\u003c/code\u003e since they don’t require specifying the type multiple times and eliminate the need to use \u003ccode\u003enew\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003emake_unique\u003c/code\u003e and \u003ccode\u003emake_shared\u003c/code\u003e should also be preferred for exception-safety and performance reasons.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eException-Safety\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eWhile \u003ccode\u003emake_unique\u003c/code\u003e and \u003ccode\u003emake_shared\u003c/code\u003e are exception-safe, complex constructions of \u003ccode\u003eunique_ptr\u003c/code\u003e and\n\u003ccode\u003eshared_ptr\u003c/code\u003e might not be because C++ allows arbitrary order of evaluation of subexpressions (until C++17).\u003c/p\u003e\n\u003cp\u003eConsider this example:\u003c/p\u003e\n\u003cpre\u003e\nf(unique_ptr\u0026lt;Lhs\u0026gt;(new Lhs()), throwingFunction());\n\u003c/pre\u003e\n\u003cp\u003eThe following scenario can happen:\u003c/p\u003e\n\u003col\u003e\n  \u003cli\u003e Memory allocation for \u003ccode\u003eLhs\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e Construction of the \u003ccode\u003eLhs\u003c/code\u003e object \u003c/li\u003e\n  \u003cli\u003e Call to \u003ccode\u003ethrowingFunction\u003c/code\u003e (before the \u003ccode\u003eunique_ptr\u003c/code\u003e construction) \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003ethrowingFunction\u003c/code\u003e throws an exception \u003c/li\u003e\n  \u003cli\u003e The constructed \u003ccode\u003eLhs\u003c/code\u003e object is leaked since the \u003ccode\u003eunique_ptr\u003c/code\u003e isn’t constructed yet \u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eNote: This scenario can only happen before C++17. Since C++17, the standard states that even though the order of evaluation of each argument is\nstill unspecified, interleaving the evaluation of different arguments is no longer allowed. This makes the direct construction of\n\u003ccode\u003eunique_ptr\u003c/code\u003e and \u003ccode\u003eshared_ptr\u003c/code\u003e exception-safe.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003ePerformance\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eUsing \u003ccode\u003emake_unique()\u003c/code\u003e doesn’t impact performance, but \u003ccode\u003emake_shared()\u003c/code\u003e improves it slightly.\u003cbr\u003e Indeed, constructing\nexplicitly a \u003ccode\u003eshared_ptr()\u003c/code\u003e requires two heap allocations: one for the managed object and the other for the control block that stores data\nabout the ref-counts and the \u003ccode\u003eshared_ptr()\u003c/code\u003e deleter. \u003ccode\u003emake_shared()\u003c/code\u003e on the other hand, performs only one heap allocation.\u003c/p\u003e\n\u003cp\u003eNote: Because \u003ccode\u003emake_shared\u003c/code\u003e performs only one allocation for both the object and the control block, the memory occupied by the object\nwill be deallocated when no \u003ccode\u003eshared_ptr\u003c/code\u003e or \u003ccode\u003eweak_ptr\u003c/code\u003e points to it. If the object is large, a \u003ccode\u003eweak_ptr\u003c/code\u003e is used,\nand memory is a concern, explicitly calling the constructor of \u003ccode\u003eshared_ptr\u003c/code\u003e may be preferred. This way, the object’s memory will be\ndeallocated when there are no more shared owners, independently of any \u003ccode\u003eweak_ptr\u003c/code\u003es.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstd::unique_ptr\u0026lt;MyClass\u0026gt; uniqueP(new MyClass(42)); // Noncompliant\nstd::shared_ptr\u0026lt;MyClass\u0026gt; sharedP(new MyClass(42)); // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nauto uniqueP \u003d std::make_unique\u0026lt;MyClass\u0026gt;(42);\nauto sharedP \u003d std::make_shared\u0026lt;MyClass\u0026gt;(42);\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThis rule ignores code that uses features not supported by \u003ccode\u003emake_shared\u003c/code\u003e and \u003ccode\u003emake_unique\u003c/code\u003e:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e custom deleters \u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\nstd::unique_ptr\u0026lt;std::FILE, std::function\u0026lt;void(std::FILE*)\u0026gt;\u0026gt; file(\n  fopen(\"example.txt\", \"r\"),\n  [](FILE* inFile) { fclose(inFile); }); // Compliant: custom deleter is specified\n\u003c/pre\u003e\n\u003cul\u003e\n  \u003cli\u003e calling placement-new, i.e., version of \u003ccode\u003enew\u003c/code\u003e with arguments, like \u003ccode\u003enew(std::nothrow)\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn addition, \u003ccode\u003emake_shared\u003c/code\u003e does not support the following:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e custom operator \u003ccode\u003enew\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e allocating arrays (before C++20) \u003c/li\u003e\n\u003c/ul\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c150-use-make_unique-to-construct-objects-owned-by-unique_ptrs\"\u003eC.150: Use \u003ccode\u003emake_unique()\u003c/code\u003e to construct objects owned by \u003ccode\u003eunique_ptr\u003c/code\u003es\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c151-use-make_shared-to-construct-objects-owned-by-shared_ptrs\"\u003eC.151: Use \u003ccode\u003emake_shared()\u003c/code\u003e to construct objects owned by \u003ccode\u003eshared_ptr\u003c/code\u003es\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cppcoreguidelines",
      "since-c++11"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S2681",
    "name": "Multiline blocks should be enclosed in curly braces",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "FORMATTED",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eHaving inconsistent indentation and omitting curly braces from a control structure, such as an \u003ccode\u003eif\u003c/code\u003e statement or \u003ccode\u003efor\u003c/code\u003e loop,\nis misleading and can induce bugs.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when the indentation of the lines after a control structure indicates an intent to include those lines in the block, but\nthe omission of curly braces means the lines will be unconditionally executed once.\u003c/p\u003e\n\u003cp\u003eThe following patterns are recognized:\u003c/p\u003e\n\u003cpre\u003e\nif (condition)\n  firstActionInBlock();\n  secondAction();  // Noncompliant: secondAction is executed unconditionally\nthirdAction();\n\u003c/pre\u003e\n\u003cpre\u003e\nif (condition) firstActionInBlock(); secondAction();  // Noncompliant: secondAction is executed unconditionally\n\u003c/pre\u003e\n\u003cpre\u003e\nif (condition) firstActionInBlock();\n  secondAction();  // Noncompliant: secondAction is executed unconditionally\n\u003c/pre\u003e\n\u003cpre\u003e\nif (condition); secondAction();  // Noncompliant: secondAction is executed unconditionally\n\u003c/pre\u003e\n\u003cpre\u003e\nfor (int i \u003d 0; i \u0026lt; array.length; i++)\n  str \u003d array[i];\n  doTheThing(str);  // Noncompliant: executed only on the last element\n\u003c/pre\u003e\n\u003cp\u003eNote that this rule considers tab characters to be equivalent to 1 space. When mixing spaces and tabs, a code may look fine in one editor but be\nconfusing in another configured differently.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/483\"\u003eMITRE, CWE-483\u003c/a\u003e - Incorrect Block Delimitation \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eHaving inconsistent indentation and omitting curly braces from a control structure, such as an \u003ccode\u003eif\u003c/code\u003e statement or \u003ccode\u003efor\u003c/code\u003e loop,\nis misleading and can induce bugs.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when the indentation of the lines after a control structure indicates an intent to include those lines in the block, but\nthe omission of curly braces means the lines will be unconditionally executed once.\u003c/p\u003e\n\u003cp\u003eThe following patterns are recognized:\u003c/p\u003e\n\u003cpre\u003e\nif (condition)\n  firstActionInBlock();\n  secondAction();  // Noncompliant: secondAction is executed unconditionally\nthirdAction();\n\u003c/pre\u003e\n\u003cpre\u003e\nif (condition) firstActionInBlock(); secondAction();  // Noncompliant: secondAction is executed unconditionally\n\u003c/pre\u003e\n\u003cpre\u003e\nif (condition) firstActionInBlock();\n  secondAction();  // Noncompliant: secondAction is executed unconditionally\n\u003c/pre\u003e\n\u003cpre\u003e\nif (condition); secondAction();  // Noncompliant: secondAction is executed unconditionally\n\u003c/pre\u003e\n\u003cpre\u003e\nfor (int i \u003d 0; i \u0026lt; array.length; i++)\n  str \u003d array[i];\n  doTheThing(str);  // Noncompliant: executed only on the last element\n\u003c/pre\u003e\n\u003cp\u003eNote that this rule considers tab characters to be equivalent to 1 space. When mixing spaces and tabs, a code may look fine in one editor but be\nconfusing in another configured differently.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/483\"\u003eMITRE, CWE-483\u003c/a\u003e - Incorrect Block Delimitation \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cert",
      "cwe"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5951",
    "name": "Return type of functions shouldn\u0027t be const qualified value",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThere is no reason to add a const qualifier to the return type of a function that returns by \u003cstrong\u003evalue\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eAt best, it will be superfluous. At worst, it will be a performance bug: it can prevent move operation (when copy elision doesn’t take place). When\nan object is const-qualified the copy constructor/assignment will be a better match than the move constructor/assignment.\u003c/p\u003e\n\u003cp\u003eOne might think about adding this qualifier in order to forbid the call of unintended functions on the returned object. A common example is to\navoid unintended assignments:\u003c/p\u003e\n\u003cpre\u003e\nX x1, x2, x3;\nif (x1 + x2 \u003d x3) { // Compiler will complain since const object cannot be assigned. Should be \"x1 + x2 \u003d\u003d x3\"\n...\n}\n\u003c/pre\u003e\n\u003cp\u003eC++11 introduced reference qualifiers for member functions. This feature provides a better approach to forbid calling unintended functions:\u003c/p\u003e\n\u003cpre\u003e\nstruct X {\nX\u0026amp; operator\u003d(const X\u0026amp; other) \u0026amp;;\n};\n...\nX x1, x2, x3;\nif (x1 + x2 \u003d x3) { // Compiler will complain since assignment cannot be called on r-value.  Should be \"x1 + x2 \u003d\u003d x3\"\n...\n}\n\u003c/pre\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass A {...};\nconst A f();  // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nclass A {...};\nA f();\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f20-for-out-output-values-prefer-return-values-to-output-parameters\"\u003eF.20: For \"out\" output values, prefer return values to output parameters\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThere is no reason to add a const qualifier to the return type of a function that returns by \u003cstrong\u003evalue\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eAt best, it will be superfluous. At worst, it will be a performance bug: it can prevent move operation (when copy elision doesn’t take place). When\nan object is const-qualified the copy constructor/assignment will be a better match than the move constructor/assignment.\u003c/p\u003e\n\u003cp\u003eOne might think about adding this qualifier in order to forbid the call of unintended functions on the returned object. A common example is to\navoid unintended assignments:\u003c/p\u003e\n\u003cpre\u003e\nX x1, x2, x3;\nif (x1 + x2 \u003d x3) { // Compiler will complain since const object cannot be assigned. Should be \"x1 + x2 \u003d\u003d x3\"\n...\n}\n\u003c/pre\u003e\n\u003cp\u003eC++11 introduced reference qualifiers for member functions. This feature provides a better approach to forbid calling unintended functions:\u003c/p\u003e\n\u003cpre\u003e\nstruct X {\nX\u0026amp; operator\u003d(const X\u0026amp; other) \u0026amp;;\n};\n...\nX x1, x2, x3;\nif (x1 + x2 \u003d x3) { // Compiler will complain since assignment cannot be called on r-value.  Should be \"x1 + x2 \u003d\u003d x3\"\n...\n}\n\u003c/pre\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass A {...};\nconst A f();  // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nclass A {...};\nA f();\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f20-for-out-output-values-prefer-return-values-to-output-parameters\"\u003eF.20: For \"out\" output values, prefer return values to output parameters\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "clumsy",
      "cppcoreguidelines",
      "performance"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1110",
    "name": "Redundant pairs of parentheses should be removed",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eParentheses can disambiguate the order of operations in complex expressions and make the code easier to understand.\u003c/p\u003e\n\u003cpre\u003e\na \u003d (b * c) + (d * e); // Compliant: the intent is clear.\n\u003c/pre\u003e\n\u003cp\u003eRedundant parentheses are parenthesis that do not change the behavior of the code, and do not clarify the intent. They can mislead and complexify\nthe code. They should be removed.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nint x \u003d ((y / 2 + 1)); // Noncompliant\n\nif (a \u0026amp;\u0026amp; ((x + y \u0026gt; 0))) { // Noncompliant\n  return ((x + 1)); // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nint x \u003d (y / 2 + 1);\n\nif (a \u0026amp;\u0026amp; (x + y \u0026gt; 0)) {\n  return (x + 1);\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eAssignments inside conditions are often the result of a mistake. {rule:cpp:S1121} flags this potential bug.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\nif (x \u003d 7) { // Noncompliant: Did the author mean \"x \u003d\u003d 7\"?\n  // ...\n}\n\u003c/pre\u003e\n\u003cp\u003eAdding a pair of parentheses to clearly state the intent is standard practice and is accepted by this rule.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\nif ((x \u003d 7)) { // Compliant\n  // ...\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eParentheses can disambiguate the order of operations in complex expressions and make the code easier to understand.\u003c/p\u003e\n\u003cpre\u003e\na \u003d (b * c) + (d * e); // Compliant: the intent is clear.\n\u003c/pre\u003e\n\u003cp\u003eRedundant parentheses are parenthesis that do not change the behavior of the code, and do not clarify the intent. They can mislead and complexify\nthe code. They should be removed.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nint x \u003d ((y / 2 + 1)); // Noncompliant\n\nif (a \u0026amp;\u0026amp; ((x + y \u0026gt; 0))) { // Noncompliant\n  return ((x + 1)); // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nint x \u003d (y / 2 + 1);\n\nif (a \u0026amp;\u0026amp; (x + y \u0026gt; 0)) {\n  return (x + 1);\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eAssignments inside conditions are often the result of a mistake. {rule:cpp:S1121} flags this potential bug.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\nif (x \u003d 7) { // Noncompliant: Did the author mean \"x \u003d\u003d 7\"?\n  // ...\n}\n\u003c/pre\u003e\n\u003cp\u003eAdding a pair of parentheses to clearly state the intent is standard practice and is accepted by this rule.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\nif ((x \u003d 7)) { // Compliant\n  // ...\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "confusing"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1231",
    "name": "C-style memory allocation routines should not be used",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003emalloc\u003c/code\u003e, \u003ccode\u003erealloc\u003c/code\u003e, \u003ccode\u003ecalloc\u003c/code\u003e and \u003ccode\u003efree\u003c/code\u003e routines are used to dynamically allocate memory in the\nheap. But, in contrast to the \u003ccode\u003enew\u003c/code\u003e and \u003ccode\u003edelete\u003c/code\u003e operators introduced in C++, they allocate raw memory, which is not type-safe,\nand they do not correctly invoke object constructors. Additionally, mixing them with \u003ccode\u003enew\u003c/code\u003e/\u003ccode\u003edelete\u003c/code\u003e results in undefined\nbehavior.\u003c/p\u003e\n\u003cp\u003eNote that directly replacing those functions with \u003ccode\u003enew\u003c/code\u003e/\u003ccode\u003edelete\u003c/code\u003e is usually not a good idea (see {rule:cpp:S5025}).\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstring* pStringArray1 \u003d static_cast\u0026lt;string*\u0026gt;(malloc(10 * sizeof(string))); // Noncompliant\nPerson *p \u003d (Person*)malloc(sizeof(Person)); // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstd::array\u0026lt;string, 10\u0026gt; stringArray1 ; // Compliant, use std::vector instead if the size is dynamic\nauto p1 \u003d new Person(\"Bjarne\"); // Compliant, but don\u0027t do that, prefer the version on next line\nauto p2 \u003d std::make_unique\u0026lt;Person\u0026gt;(\"Bjarne\"); // Compliant\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#r10-avoid-malloc-and-free\"\u003eR.10:\n  Avoid \u003ccode\u003emalloc()\u003c/code\u003e and \u003ccode\u003efree()\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe \u003ccode\u003emalloc\u003c/code\u003e, \u003ccode\u003erealloc\u003c/code\u003e, \u003ccode\u003ecalloc\u003c/code\u003e and \u003ccode\u003efree\u003c/code\u003e routines are used to dynamically allocate memory in the\nheap. But, in contrast to the \u003ccode\u003enew\u003c/code\u003e and \u003ccode\u003edelete\u003c/code\u003e operators introduced in C++, they allocate raw memory, which is not type-safe,\nand they do not correctly invoke object constructors. Additionally, mixing them with \u003ccode\u003enew\u003c/code\u003e/\u003ccode\u003edelete\u003c/code\u003e results in undefined\nbehavior.\u003c/p\u003e\n\u003cp\u003eNote that directly replacing those functions with \u003ccode\u003enew\u003c/code\u003e/\u003ccode\u003edelete\u003c/code\u003e is usually not a good idea (see {rule:cpp:S5025}).\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstring* pStringArray1 \u003d static_cast\u0026lt;string*\u0026gt;(malloc(10 * sizeof(string))); // Noncompliant\nPerson *p \u003d (Person*)malloc(sizeof(Person)); // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstd::array\u0026lt;string, 10\u0026gt; stringArray1 ; // Compliant, use std::vector instead if the size is dynamic\nauto p1 \u003d new Person(\"Bjarne\"); // Compliant, but don\u0027t do that, prefer the version on next line\nauto p2 \u003d std::make_unique\u0026lt;Person\u0026gt;(\"Bjarne\"); // Compliant\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#r10-avoid-malloc-and-free\"\u003eR.10:\n  Avoid \u003ccode\u003emalloc()\u003c/code\u003e and \u003ccode\u003efree()\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cppcoreguidelines",
      "leak",
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1232",
    "name": "Appropriate memory de-allocation should be used",
    "defaultSeverity": "BLOCKER",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003cp\u003eUse the matching way of deallocating the objects to the one used to allocate them to avoid segmentation faults and memory leaks.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe same form that was used to create an object should always be used to delete it. Specifically, deallocation should correspond to allocation as\nper the table below.\u003c/p\u003e\n\u003ctable\u003e\n  \u003ccaption\u003e\n    Table 1. Matching allocation and deallocation ways\n  \u003c/caption\u003e\n  \u003ccolgroup\u003e\n    \u003ccol style\u003d\"width: 50%;\"\u003e\n    \u003ccol style\u003d\"width: 50%;\"\u003e\n  \u003c/colgroup\u003e\n  \u003cthead\u003e\n    \u003ctr\u003e\n      \u003cth\u003eAllocation\u003c/th\u003e\n      \u003cth\u003eDeallocation\u003c/th\u003e\n    \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003e\u003ccode\u003ep \u003d new T();\u003c/code\u003e\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003e\u003ccode\u003edelete p;\u003c/code\u003e\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003e\u003ccode\u003ep \u003d new T[5];\u003c/code\u003e\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003e\u003ccode\u003edelete[] p;\u003c/code\u003e\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003e\u003ccode\u003ep \u003d malloc(sizeof(int)*5);\u003c/code\u003e\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003e\u003ccode\u003efree(p);\u003c/code\u003e\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eUsing a mismatching deallocation construct leads to undefined behavior. This means the compiler is not bound by the language standard anymore and\nyour program has no meaning assigned to it.\u003c/p\u003e\n\u003cp\u003ePractically, you can observe the following effects:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Deleting a single object with \u003ccode\u003edelete[]\u003c/code\u003e leads to a segmentation fault trying to access memory-manager metadata that is not there.\n  \u003c/li\u003e\n  \u003cli\u003e Deleting an array with \u003ccode\u003edelete\u003c/code\u003e leads to a memory leak because it will delete and deallocate only the first element of the array.\n  \u003c/li\u003e\n  \u003cli\u003e Freeing with \u003ccode\u003efree()\u003c/code\u003e the underlying memory for an object constructed with \u003ccode\u003enew\u003c/code\u003e will skip the destructor call, most\n  likely leading to a memory leak. Additionally, a destructor might still be called on deallocated memory causing further undefined behavior. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eWhy is the issue raised for a type with a trivial destructor?\u003c/h3\u003e\n\u003cp\u003eAutomatic constructor and destructor invocation is not the only difference between the C-style \u003ccode\u003emalloc\u003c/code\u003e/\u003ccode\u003efree\u003c/code\u003e memory\nallocator, and the C++-style \u003ccode\u003enew\u003c/code\u003e/\u003ccode\u003edelete\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThese two memory allocators use different metadata and different algorithms. For example, \u003ccode\u003enew\u003c/code\u003e has an array form \u003ccode\u003enew[]\u003c/code\u003e\nthat stores an \"array cookie\".\u003c/p\u003e\n\u003cp\u003eThe following example causes undefined behavior, even though the destructor has now effect, because \u003ccode\u003efree()\u003c/code\u003e expects different metadata\nfor the pointer it is passed than what is arranged by the \u003ccode\u003enew\u003c/code\u003e operator:\u003c/p\u003e\n\u003cpre\u003e\nstruct TrivialClass {};\n\n\nTrivialClass* p \u003d new TrivialClass();\nfree(p); // Noncompliant: no-op destructor is skipped; still undefined behavior\n\u003c/pre\u003e\n\u003cp\u003eIn the code below, \u003ccode\u003edelete[]\u003c/code\u003e expects to find an array cookie and fails:\u003c/p\u003e\n\u003cpre\u003e\nint* p \u003d malloc(10 * sizeof(int));\ndelete[] p; // Noncompliant: expect array cookie\n\u003c/pre\u003e\n\u003cp\u003eIf you need allocate memory in a custom \u003ccode\u003eT::operator new(std::size_t)\u003c/code\u003e, you should use \u003ccode\u003evoid* ::operator new(std::size_t)\u003c/code\u003e\nand not \u003ccode\u003efree()\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eNote that \u003ccode\u003e::operator new\u003c/code\u003e is still not compatible with \u003ccode\u003efree()\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\nauto p \u003d ::operator new(10 * sizeof(int));\nfree(p); // Noncompliant\n\u003c/pre\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eUse the deallocation mechanism that matches the allocation.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nstd::string* _pString1 \u003d new std::string;\nstd::string* _pString2 \u003d new std::string[100];\nchar* _pChar \u003d (char *) malloc(100);\n\ndelete [] _pString1; // Noncompliant: an object was declared, but array deletion is attempted\ndelete _pString2;  // Noncompliant: an array was declared, but an object (the first in the array) is deleted\ndelete _pChar; // Noncompliant\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nstd::string* _pString1 \u003d new std::string;\nstd::string* _pString2 \u003d new std::string[100];\nchar* _pChar \u003d (char *) malloc(100);\n\ndelete _pString1; // Compliant: delete the object\ndelete [] _pString2; // Compliant: delete the entire array\nfree(_pChar); // Compliant: free the memory C-style\n\u003c/pre\u003e\n\u003ch3\u003eGoing the extra mile\u003c/h3\u003e\n\u003cp\u003eIn C++, manually allocating and deallocating memory is considered a code smell.\u003c/p\u003e\n\u003cp\u003eIt is recommended to follow the \u003cem\u003eRAII\u003c/em\u003e idiom and create a class that manages the memory by allocating it when the object is constructed and\nfreeing it when it is destroyed. Furthermore, copy and move operations on such objects are designed such that this object can be passed by value\nbetween functions (either as an argument or by being returned) in place of raw pointers.\u003c/p\u003e\n\u003cp\u003eDepending on the type, passing an \u003cem\u003eRAII\u003c/em\u003e object operations may either:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Allocate a new block of memory and copy the elements (\u003ccode\u003estd::vector\u003c/code\u003e). \u003c/li\u003e\n  \u003cli\u003e Transfer ownership of the memory to constructed object (\u003ccode\u003estd::unique_ptr\u003c/code\u003e). \u003c/li\u003e\n  \u003cli\u003e Use shared ownership and free memory when the last object is destroyed (\u003ccode\u003estd::shared_ptr\u003c/code\u003e). \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis guarantees that the memory managed by such object is automatically deallocated by the destructor, using the matching form of deallocation.\u003c/p\u003e\n\u003cpre\u003e\nstd::string _pString1a; // A local variable, that manages heap memory\n\n// Use a smart pointer when you do need heap allocation\nauto _pString1b \u003d std::make_unique\u0026lt;std::string\u0026gt;();\n\nstd::vector\u0026lt;std::string\u0026gt; _pString2(100);\nstd::string _pChar{100, \u0027\\0\u0027};\n\n// No need to call \"delete\" or \"free\".\n// Memory allocated for the three objects above will be freed automatically\n// when they go out of scope.\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/Gns-BQ\"\u003eMEM51-CPP. Properly deallocate dynamically allocated resources\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S5025} recommends avoiding manual memory management \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/raii\"\u003eRAII (Resource Acquisition Is Initialization)\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eUse the matching way of deallocating the objects to the one used to allocate them to avoid segmentation faults and memory leaks.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe same form that was used to create an object should always be used to delete it. Specifically, deallocation should correspond to allocation as\nper the table below.\u003c/p\u003e\n\u003ctable\u003e\n  \u003ccaption\u003e\n    Table 1. Matching allocation and deallocation ways\n  \u003c/caption\u003e\n  \u003ccolgroup\u003e\n    \u003ccol style\u003d\"width: 50%;\"\u003e\n    \u003ccol style\u003d\"width: 50%;\"\u003e\n  \u003c/colgroup\u003e\n  \u003cthead\u003e\n    \u003ctr\u003e\n      \u003cth\u003eAllocation\u003c/th\u003e\n      \u003cth\u003eDeallocation\u003c/th\u003e\n    \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003e\u003ccode\u003ep \u003d new T();\u003c/code\u003e\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003e\u003ccode\u003edelete p;\u003c/code\u003e\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003e\u003ccode\u003ep \u003d new T[5];\u003c/code\u003e\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003e\u003ccode\u003edelete[] p;\u003c/code\u003e\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cp\u003e\u003ccode\u003ep \u003d malloc(sizeof(int)*5);\u003c/code\u003e\u003c/p\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cp\u003e\u003ccode\u003efree(p);\u003c/code\u003e\u003c/p\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eUsing a mismatching deallocation construct leads to undefined behavior. This means the compiler is not bound by the language standard anymore and\nyour program has no meaning assigned to it.\u003c/p\u003e\n\u003cp\u003ePractically, you can observe the following effects:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Deleting a single object with \u003ccode\u003edelete[]\u003c/code\u003e leads to a segmentation fault trying to access memory-manager metadata that is not there.\n  \u003c/li\u003e\n  \u003cli\u003e Deleting an array with \u003ccode\u003edelete\u003c/code\u003e leads to a memory leak because it will delete and deallocate only the first element of the array.\n  \u003c/li\u003e\n  \u003cli\u003e Freeing with \u003ccode\u003efree()\u003c/code\u003e the underlying memory for an object constructed with \u003ccode\u003enew\u003c/code\u003e will skip the destructor call, most\n  likely leading to a memory leak. Additionally, a destructor might still be called on deallocated memory causing further undefined behavior. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eWhy is the issue raised for a type with a trivial destructor?\u003c/h3\u003e\n\u003cp\u003eAutomatic constructor and destructor invocation is not the only difference between the C-style \u003ccode\u003emalloc\u003c/code\u003e/\u003ccode\u003efree\u003c/code\u003e memory\nallocator, and the C++-style \u003ccode\u003enew\u003c/code\u003e/\u003ccode\u003edelete\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThese two memory allocators use different metadata and different algorithms. For example, \u003ccode\u003enew\u003c/code\u003e has an array form \u003ccode\u003enew[]\u003c/code\u003e\nthat stores an \"array cookie\".\u003c/p\u003e\n\u003cp\u003eThe following example causes undefined behavior, even though the destructor has now effect, because \u003ccode\u003efree()\u003c/code\u003e expects different metadata\nfor the pointer it is passed than what is arranged by the \u003ccode\u003enew\u003c/code\u003e operator:\u003c/p\u003e\n\u003cpre\u003e\nstruct TrivialClass {};\n\n\nTrivialClass* p \u003d new TrivialClass();\nfree(p); // Noncompliant: no-op destructor is skipped; still undefined behavior\n\u003c/pre\u003e\n\u003cp\u003eIn the code below, \u003ccode\u003edelete[]\u003c/code\u003e expects to find an array cookie and fails:\u003c/p\u003e\n\u003cpre\u003e\nint* p \u003d malloc(10 * sizeof(int));\ndelete[] p; // Noncompliant: expect array cookie\n\u003c/pre\u003e\n\u003cp\u003eIf you need allocate memory in a custom \u003ccode\u003eT::operator new(std::size_t)\u003c/code\u003e, you should use \u003ccode\u003evoid* ::operator new(std::size_t)\u003c/code\u003e\nand not \u003ccode\u003efree()\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eNote that \u003ccode\u003e::operator new\u003c/code\u003e is still not compatible with \u003ccode\u003efree()\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\nauto p \u003d ::operator new(10 * sizeof(int));\nfree(p); // Noncompliant\n\u003c/pre\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eUse the deallocation mechanism that matches the allocation.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nstd::string* _pString1 \u003d new std::string;\nstd::string* _pString2 \u003d new std::string[100];\nchar* _pChar \u003d (char *) malloc(100);\n\ndelete [] _pString1; // Noncompliant: an object was declared, but array deletion is attempted\ndelete _pString2;  // Noncompliant: an array was declared, but an object (the first in the array) is deleted\ndelete _pChar; // Noncompliant\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nstd::string* _pString1 \u003d new std::string;\nstd::string* _pString2 \u003d new std::string[100];\nchar* _pChar \u003d (char *) malloc(100);\n\ndelete _pString1; // Compliant: delete the object\ndelete [] _pString2; // Compliant: delete the entire array\nfree(_pChar); // Compliant: free the memory C-style\n\u003c/pre\u003e\n\u003ch3\u003eGoing the extra mile\u003c/h3\u003e\n\u003cp\u003eIn C++, manually allocating and deallocating memory is considered a code smell.\u003c/p\u003e\n\u003cp\u003eIt is recommended to follow the \u003cem\u003eRAII\u003c/em\u003e idiom and create a class that manages the memory by allocating it when the object is constructed and\nfreeing it when it is destroyed. Furthermore, copy and move operations on such objects are designed such that this object can be passed by value\nbetween functions (either as an argument or by being returned) in place of raw pointers.\u003c/p\u003e\n\u003cp\u003eDepending on the type, passing an \u003cem\u003eRAII\u003c/em\u003e object operations may either:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Allocate a new block of memory and copy the elements (\u003ccode\u003estd::vector\u003c/code\u003e). \u003c/li\u003e\n  \u003cli\u003e Transfer ownership of the memory to constructed object (\u003ccode\u003estd::unique_ptr\u003c/code\u003e). \u003c/li\u003e\n  \u003cli\u003e Use shared ownership and free memory when the last object is destroyed (\u003ccode\u003estd::shared_ptr\u003c/code\u003e). \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis guarantees that the memory managed by such object is automatically deallocated by the destructor, using the matching form of deallocation.\u003c/p\u003e\n\u003cpre\u003e\nstd::string _pString1a; // A local variable, that manages heap memory\n\n// Use a smart pointer when you do need heap allocation\nauto _pString1b \u003d std::make_unique\u0026lt;std::string\u0026gt;();\n\nstd::vector\u0026lt;std::string\u0026gt; _pString2(100);\nstd::string _pChar{100, \u0027\\0\u0027};\n\n// No need to call \"delete\" or \"free\".\n// Memory allocated for the three objects above will be freed automatically\n// when they go out of scope.\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/Gns-BQ\"\u003eMEM51-CPP. Properly deallocate dynamically allocated resources\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S5025} recommends avoiding manual memory management \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/raii\"\u003eRAII (Resource Acquisition Is Initialization)\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cert",
      "denial-of-service",
      "symbolic-execution"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S2323",
    "name": "Line-splicing should not be used in \"//\" comments",
    "defaultSeverity": "CRITICAL",
    "type": "BUG",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhen a line of code ends with the \u003ccode\u003e\\\u003c/code\u003e (backslash) character, the newline character is deleted. The compiler considers the next line a\ncontinuation of the current line, resulting in only one logical line of code.\u003c/p\u003e\n\u003cp\u003eThis source code transformation, known as \u003cem\u003eline-splicing\u003c/em\u003e, occurs during the second phase of C and C++ translation.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eLine-splicing\u003c/em\u003e is often harmless and is sometimes used to improve the readability of macros:\u003c/p\u003e\n\u003cpre\u003e\n#define LOG_FAILURE(CONDITION, MESSAGE) \\\n  do {                                  \\\n    if (!(CONDITION)) {                 \\\n      log(MESSAGE);                     \\\n    }                                   \\\n  } while (0)\n\u003c/pre\u003e\n\u003cp\u003eFurthermore, \u003cem\u003eline-splicing\u003c/em\u003e does not apply inside C++11 raw string literal.\u003c/p\u003e\n\u003cp\u003eHowever, the effect of \u003cem\u003eline-splicing\u003c/em\u003e in single-line comments (\u003ccode\u003e//\u003c/code\u003e) can be surprising, leading to unintentional code removal\nand possibly undefined behavior.\u003c/p\u003e\n\u003cp\u003eIn the following example, the \u003ccode\u003ereturn\u003c/code\u003e expression is considered part of the previous comment. The function has undefined behavior\nbecause it exits without returning a value.\u003c/p\u003e\n\u003cpre\u003e\nbool isSpecialCharacter(char c)\n{\n  // Noncompliant comment: it ends with a backslash.\n  // Characters considered special: [ ] \\\n  return 91 \u0026lt;\u003d c \u0026amp;\u0026amp; c \u0026lt;\u003d 93;\n}\n\u003c/pre\u003e\n\u003cp\u003eCompilers may also delete whitespace characters between a backslash and the newline characters. This practice is standard-compliant since C++23. In\nother words, trailing whitespaces do not disable \u003cem\u003eline-splicing\u003c/em\u003e.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/translation_phases\"\u003ePhases of translation\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2012, 3.2 - Line-splicing shall not be used in // comments \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S1916} is a companion rule and detects trailing whitespace after \u003ccode\u003e\\\u003c/code\u003e. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhen a line of code ends with the \u003ccode\u003e\\\u003c/code\u003e (backslash) character, the newline character is deleted. The compiler considers the next line a\ncontinuation of the current line, resulting in only one logical line of code.\u003c/p\u003e\n\u003cp\u003eThis source code transformation, known as \u003cem\u003eline-splicing\u003c/em\u003e, occurs during the second phase of C and C++ translation.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eLine-splicing\u003c/em\u003e is often harmless and is sometimes used to improve the readability of macros:\u003c/p\u003e\n\u003cpre\u003e\n#define LOG_FAILURE(CONDITION, MESSAGE) \\\n  do {                                  \\\n    if (!(CONDITION)) {                 \\\n      log(MESSAGE);                     \\\n    }                                   \\\n  } while (0)\n\u003c/pre\u003e\n\u003cp\u003eFurthermore, \u003cem\u003eline-splicing\u003c/em\u003e does not apply inside C++11 raw string literal.\u003c/p\u003e\n\u003cp\u003eHowever, the effect of \u003cem\u003eline-splicing\u003c/em\u003e in single-line comments (\u003ccode\u003e//\u003c/code\u003e) can be surprising, leading to unintentional code removal\nand possibly undefined behavior.\u003c/p\u003e\n\u003cp\u003eIn the following example, the \u003ccode\u003ereturn\u003c/code\u003e expression is considered part of the previous comment. The function has undefined behavior\nbecause it exits without returning a value.\u003c/p\u003e\n\u003cpre\u003e\nbool isSpecialCharacter(char c)\n{\n  // Noncompliant comment: it ends with a backslash.\n  // Characters considered special: [ ] \\\n  return 91 \u0026lt;\u003d c \u0026amp;\u0026amp; c \u0026lt;\u003d 93;\n}\n\u003c/pre\u003e\n\u003cp\u003eCompilers may also delete whitespace characters between a backslash and the newline characters. This practice is standard-compliant since C++23. In\nother words, trailing whitespaces do not disable \u003cem\u003eline-splicing\u003c/em\u003e.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/translation_phases\"\u003ePhases of translation\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2012, 3.2 - Line-splicing shall not be used in // comments \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S1916} is a companion rule and detects trailing whitespace after \u003ccode\u003e\\\u003c/code\u003e. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "based-on-misra"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S3654",
    "name": "Destructors should be \"noexcept\"",
    "defaultSeverity": "BLOCKER",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThrowing an exception from a destructor may result in a call to \u003ccode\u003estd::terminate\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eBy default, compilers implicitly declare destructors as \u003ccode\u003enoexcept\u003c/code\u003e, so \u003ccode\u003estd::terminate\u003c/code\u003e is called when they exit with an\nexception. Destructors may still propagate an exception if they are explicitly declared as \u003ccode\u003enoexcept(false)\u003c/code\u003e. However, even a destructor\ndeclared as \u003ccode\u003enoexcept(false)\u003c/code\u003e calls \u003ccode\u003estd::terminate\u003c/code\u003e when it throws during stack unwinding.\u003c/p\u003e\n\u003cp\u003eThe following example illustrates the severity of the underlying problem:\u003c/p\u003e\n\u003cp\u003eThe destructor of a container needs to call the destructors for all managed objects. Suppose a call to an object’s destructor throws an exception.\nIn that case, there are only two \u003cem\u003econceptual\u003c/em\u003e ways to proceed:\u003c/p\u003e\n\u003col\u003e\n  \u003cli\u003e Abort the destruction. This results in a partially destroyed object and possibly many more objects whose destructors are never called. \u003c/li\u003e\n  \u003cli\u003e Ignore the exception and proceed with destroying the remaining objects. However, this potentially results in more partially destroyed objects\n  if further destructors throw an exception. \u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eBecause both options are undesired, destructors should never \u003ccode\u003ethrow\u003c/code\u003e exceptions.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eIn most cases, throwing exceptions in destructors makes the program unreliable:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e If \u003ccode\u003estd::terminate\u003c/code\u003e is called, the program terminates in an implementation-defined, abrupt, and unclean manner. \u003c/li\u003e\n  \u003cli\u003e The program’s behavior is undefined if a standard library component (a container, an algorithm, …​) manages a user-defined object that throws\n  an exception from its destructor. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eThis rule raises an issue when a destructor is not \u003ccode\u003enoexcept\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eUsually, nothing needs to be written in the source code because destructors are \u003ccode\u003enoexcept\u003c/code\u003e by default. However, a destructor becomes not\n\u003ccode\u003enoexcept\u003c/code\u003e when:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The base class or a data member has a non \u003ccode\u003enoexcept\u003c/code\u003e destructor; \u003c/li\u003e\n  \u003cli\u003e The destructor is decorated with the \u003ccode\u003enoexcept(expression)\u003c/code\u003e and \u003ccode\u003eexpression\u003c/code\u003e evaluates to \u003ccode\u003efalse\u003c/code\u003e. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe code should be modified to avoid those two scenarios.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre\u003e\nstruct A {\n  ~A() noexcept(false) {} // Noncompliant\n};\n\nstruct C {\n  A a; // This member data prevents automatic declaration of the destructor as noexcept\n\n  ~C() { // Noncompliant by transitivity\n    // ...\n  }\n};\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre\u003e\nstruct A {\n  ~A() noexcept(true) {} // Compliant\n};\n\nstruct C {\n  A a;\n\n  ~C() { // Compliant, noexcept by default\n    // ...\n  }\n};\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/noexcept_spec\"\u003e\u003ccode\u003enoexcept\u003c/code\u003e specifier\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c36-a-destructor-must-not-fail\"\u003eC.36: A destructor must not\n  fail\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c37-make-destructors-noexcept\"\u003eC.37: Make destructors\n  \u003ccode\u003enoexcept\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 15-5-1 - A class destructor shall not exit with an exception. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S1048} - Destructors should not throw exceptions \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThrowing an exception from a destructor may result in a call to \u003ccode\u003estd::terminate\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eBy default, compilers implicitly declare destructors as \u003ccode\u003enoexcept\u003c/code\u003e, so \u003ccode\u003estd::terminate\u003c/code\u003e is called when they exit with an\nexception. Destructors may still propagate an exception if they are explicitly declared as \u003ccode\u003enoexcept(false)\u003c/code\u003e. However, even a destructor\ndeclared as \u003ccode\u003enoexcept(false)\u003c/code\u003e calls \u003ccode\u003estd::terminate\u003c/code\u003e when it throws during stack unwinding.\u003c/p\u003e\n\u003cp\u003eThe following example illustrates the severity of the underlying problem:\u003c/p\u003e\n\u003cp\u003eThe destructor of a container needs to call the destructors for all managed objects. Suppose a call to an object’s destructor throws an exception.\nIn that case, there are only two \u003cem\u003econceptual\u003c/em\u003e ways to proceed:\u003c/p\u003e\n\u003col\u003e\n  \u003cli\u003e Abort the destruction. This results in a partially destroyed object and possibly many more objects whose destructors are never called. \u003c/li\u003e\n  \u003cli\u003e Ignore the exception and proceed with destroying the remaining objects. However, this potentially results in more partially destroyed objects\n  if further destructors throw an exception. \u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eBecause both options are undesired, destructors should never \u003ccode\u003ethrow\u003c/code\u003e exceptions.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eIn most cases, throwing exceptions in destructors makes the program unreliable:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e If \u003ccode\u003estd::terminate\u003c/code\u003e is called, the program terminates in an implementation-defined, abrupt, and unclean manner. \u003c/li\u003e\n  \u003cli\u003e The program’s behavior is undefined if a standard library component (a container, an algorithm, …​) manages a user-defined object that throws\n  an exception from its destructor. \u003c/li\u003e\n\u003c/ul\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eThis rule raises an issue when a destructor is not \u003ccode\u003enoexcept\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eUsually, nothing needs to be written in the source code because destructors are \u003ccode\u003enoexcept\u003c/code\u003e by default. However, a destructor becomes not\n\u003ccode\u003enoexcept\u003c/code\u003e when:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e The base class or a data member has a non \u003ccode\u003enoexcept\u003c/code\u003e destructor; \u003c/li\u003e\n  \u003cli\u003e The destructor is decorated with the \u003ccode\u003enoexcept(expression)\u003c/code\u003e and \u003ccode\u003eexpression\u003c/code\u003e evaluates to \u003ccode\u003efalse\u003c/code\u003e. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe code should be modified to avoid those two scenarios.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre\u003e\nstruct A {\n  ~A() noexcept(false) {} // Noncompliant\n};\n\nstruct C {\n  A a; // This member data prevents automatic declaration of the destructor as noexcept\n\n  ~C() { // Noncompliant by transitivity\n    // ...\n  }\n};\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre\u003e\nstruct A {\n  ~A() noexcept(true) {} // Compliant\n};\n\nstruct C {\n  A a;\n\n  ~C() { // Compliant, noexcept by default\n    // ...\n  }\n};\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/noexcept_spec\"\u003e\u003ccode\u003enoexcept\u003c/code\u003e specifier\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c36-a-destructor-must-not-fail\"\u003eC.36: A destructor must not\n  fail\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c37-make-destructors-noexcept\"\u003eC.37: Make destructors\n  \u003ccode\u003enoexcept\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 15-5-1 - A class destructor shall not exit with an exception. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S1048} - Destructors should not throw exceptions \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cppcoreguidelines",
      "error-handling",
      "since-c++11"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5954",
    "name": "\"shared_ptr\" should not be taken by rvalue reference",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eTaking a \u003ccode\u003eshared_ptr\u003c/code\u003e by r-value reference is unnecessary. If done on purpose, it might imply that \u003ccode\u003eunique_ptr\u003c/code\u003e is a better\nchoice since it transfers unique ownership.\u003c/p\u003e\n\u003cp\u003eIn general, a function should take:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e A copy of a \u003ccode\u003eshared_ptr\u003c/code\u003e, if the function takes part in the ownership of the managed object \u003c/li\u003e\n  \u003cli\u003e A reference to a \u003ccode\u003eshared_ptr\u003c/code\u003e if the function plans to modify the shared_ptr itself by calling \u003ccode\u003ereset\u003c/code\u003e or\n  \u003ccode\u003eswap\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e A reference to a \u003ccode\u003econst\u003c/code\u003e \u003ccode\u003eshared_ptr\u003c/code\u003e, if the function might take part in the ownership by copying the reference to\n  another shared_ptr on at least one of its paths \u003c/li\u003e\n  \u003cli\u003e A raw pointer/reference to the object, if the function is only interested in the current value of the managed object \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nClass Circle{};\n\nvoid fn(shared_ptr\u0026lt;Circle\u0026gt;\u0026amp;\u0026amp; circle);  // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nClass Circle{};\n\nvoid fn(shared_ptr\u0026lt;Circle\u0026gt; circle);\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThe move constructor of the \u003ccode\u003eshared_ptr\u003c/code\u003e itself.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#r34-take-a-shared_ptrwidget-parameter-to-express-shared-ownership\"\u003eR.34: Take a \u003ccode\u003eshared_ptr\u0026lt;widget\u0026gt;\u003c/code\u003e parameter to express shared ownership\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eTaking a \u003ccode\u003eshared_ptr\u003c/code\u003e by r-value reference is unnecessary. If done on purpose, it might imply that \u003ccode\u003eunique_ptr\u003c/code\u003e is a better\nchoice since it transfers unique ownership.\u003c/p\u003e\n\u003cp\u003eIn general, a function should take:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e A copy of a \u003ccode\u003eshared_ptr\u003c/code\u003e, if the function takes part in the ownership of the managed object \u003c/li\u003e\n  \u003cli\u003e A reference to a \u003ccode\u003eshared_ptr\u003c/code\u003e if the function plans to modify the shared_ptr itself by calling \u003ccode\u003ereset\u003c/code\u003e or\n  \u003ccode\u003eswap\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e A reference to a \u003ccode\u003econst\u003c/code\u003e \u003ccode\u003eshared_ptr\u003c/code\u003e, if the function might take part in the ownership by copying the reference to\n  another shared_ptr on at least one of its paths \u003c/li\u003e\n  \u003cli\u003e A raw pointer/reference to the object, if the function is only interested in the current value of the managed object \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nClass Circle{};\n\nvoid fn(shared_ptr\u0026lt;Circle\u0026gt;\u0026amp;\u0026amp; circle);  // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nClass Circle{};\n\nvoid fn(shared_ptr\u0026lt;Circle\u0026gt; circle);\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThe move constructor of the \u003ccode\u003eshared_ptr\u003c/code\u003e itself.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#r34-take-a-shared_ptrwidget-parameter-to-express-shared-ownership\"\u003eR.34: Take a \u003ccode\u003eshared_ptr\u0026lt;widget\u0026gt;\u003c/code\u003e parameter to express shared ownership\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "clumsy",
      "confusing",
      "cppcoreguidelines",
      "since-c++11"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5955",
    "name": "Loop variables should be declared in the minimal possible scope",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "MODULAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhen a loop variable is not used outside of a loop, it should be declared inside the loop declaration:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e It improves readability. The scope of the variable is clearly defined. \u003c/li\u003e\n  \u003cli\u003e It reduces the number of mistakes. The variable can’t be accidentally misused outside of the loop. \u003c/li\u003e\n  \u003cli\u003e Resources are not retained longer than necessary. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid f() {\n  int i \u003d 0; // Noncompliant: i is not used outside of the loop\n  for (i \u003d 0; i \u0026lt; 10; ++i) {\n    std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; std::endl;\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid f() {\n  for (int i \u003d 0; i \u0026lt; 10; ++i) {\n    std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; std::endl;\n  }\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es5-keep-scopes-small\"\u003eES.5: Keep\n  scopes small\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhen a loop variable is not used outside of a loop, it should be declared inside the loop declaration:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e It improves readability. The scope of the variable is clearly defined. \u003c/li\u003e\n  \u003cli\u003e It reduces the number of mistakes. The variable can’t be accidentally misused outside of the loop. \u003c/li\u003e\n  \u003cli\u003e Resources are not retained longer than necessary. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid f() {\n  int i \u003d 0; // Noncompliant: i is not used outside of the loop\n  for (i \u003d 0; i \u0026lt; 10; ++i) {\n    std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; std::endl;\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid f() {\n  for (int i \u003d 0; i \u0026lt; 10; ++i) {\n    std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; std::endl;\n  }\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es5-keep-scopes-small\"\u003eES.5: Keep\n  scopes small\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "clumsy",
      "cppcoreguidelines"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1235",
    "name": "Polymorphic base class destructor should be either public virtual or protected non-virtual",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhen a class with no \u003ccode\u003evirtual\u003c/code\u003e destructor is used as a base class, surprises can occur if pointers to instances of this class are used.\nSpecifically, if an instance of a derived class is \u003ccode\u003edelete\u003c/code\u003ed through a pointer to the base type, the behavior is undefined and can lead to\nresource leaks, crashes or corrupted memory.\u003c/p\u003e\n\u003cp\u003eIf it is not expected for base class pointers to be deleted, then the destructor should be made \u003ccode\u003eprotected\u003c/code\u003e to avoid such a misuse.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass Base { // Noncompliant: no destructor is supplied, and the default version is not virtual\npublic:\n  Base() {}\n  virtual void doSomething() {}\n};\n\nclass Derived : public Base {\n}\n\nvoid f() {\n  Base *p \u003d new Derived();\n  delete p; // Undefined behavior\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nclass Base {\npublic:\n  Base() {}\n  virtual ~Base() \u003d default;\n  virtual void doSomething() {}\n};\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/5Xs-BQ\"\u003eCERT, OOP52-CPP.\u003c/a\u003e - Do not delete a polymorphic object without a virtual destructor\n  \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"http://www.gotw.ca/publications/mill18.htm\"\u003eVirtuality article\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c35-a-base-class-destructor-should-be-either-public-and-virtual-or-protected-and-non-virtual\"\u003eC.35: A base class destructor should be either public and virtual, or protected and non-virtual\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c127-a-class-with-a-virtual-function-should-have-a-virtual-or-protected-destructor\"\u003eC.127: A class with a virtual function should have a virtual or protected destructor\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhen a class with no \u003ccode\u003evirtual\u003c/code\u003e destructor is used as a base class, surprises can occur if pointers to instances of this class are used.\nSpecifically, if an instance of a derived class is \u003ccode\u003edelete\u003c/code\u003ed through a pointer to the base type, the behavior is undefined and can lead to\nresource leaks, crashes or corrupted memory.\u003c/p\u003e\n\u003cp\u003eIf it is not expected for base class pointers to be deleted, then the destructor should be made \u003ccode\u003eprotected\u003c/code\u003e to avoid such a misuse.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass Base { // Noncompliant: no destructor is supplied, and the default version is not virtual\npublic:\n  Base() {}\n  virtual void doSomething() {}\n};\n\nclass Derived : public Base {\n}\n\nvoid f() {\n  Base *p \u003d new Derived();\n  delete p; // Undefined behavior\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nclass Base {\npublic:\n  Base() {}\n  virtual ~Base() \u003d default;\n  virtual void doSomething() {}\n};\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/5Xs-BQ\"\u003eCERT, OOP52-CPP.\u003c/a\u003e - Do not delete a polymorphic object without a virtual destructor\n  \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"http://www.gotw.ca/publications/mill18.htm\"\u003eVirtuality article\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c35-a-base-class-destructor-should-be-either-public-and-virtual-or-protected-and-non-virtual\"\u003eC.35: A base class destructor should be either public and virtual, or protected and non-virtual\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c127-a-class-with-a-virtual-function-should-have-a-virtual-or-protected-destructor\"\u003eC.127: A class with a virtual function should have a virtual or protected destructor\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cert",
      "cppcoreguidelines",
      "denial-of-service"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S3656",
    "name": "Member variables should not be \"protected\"",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "MODULAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eProtected member variables are similar to global variables; any derived class can modify them. When protected member variables are used, invariants\ncannot be enforced. Also, protected member variables are hard to maintain since they can be manipulated through multiple classes in different\nfiles.\u003c/p\u003e\n\u003cp\u003eIf a class is just a data store without logic, it can safely contain only \u003ccode\u003epublic\u003c/code\u003e member variables and no member functions. Otherwise,\ndata members are tightly coupled to the class logic, and encapsulation must be used. In this case, having only private member variables enforces\ninvariants for data and ensures that logic is defined only in the member functions of the class. Structuring it this way makes it easier to guarantee\nintegrity and easier for maintainers to understand the code.\u003c/p\u003e\n\u003cp\u003eUsing \u003ccode\u003eprotected\u003c/code\u003e member variables breaks the encapsulation. The risk is that data integrity logic spreads through the class and all its\nderived classes, becoming a source of complexity that will be error-prone for maintainers and extenders.\u003c/p\u003e\n\u003cp\u003eThat is why \u003ccode\u003eprotected\u003c/code\u003e member variables should be changed to \u003ccode\u003eprivate\u003c/code\u003e and manipulated exclusively through\n\u003ccode\u003epublic\u003c/code\u003e or \u003ccode\u003eprotected\u003c/code\u003e member functions of the base class.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when a \u003ccode\u003eclass\u003c/code\u003e or \u003ccode\u003estruct\u003c/code\u003e contains \u003ccode\u003eprotected\u003c/code\u003e member variables.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nclass Stat {\npublic:\n  long int getCount() {\n    return count;\n  }\nprotected:\n  long int count \u003d 0; // Noncompliant; expose a protected member variable.\n                      // By just looking at \"Stat\" class, it\u0027s not possible to be sure that \"count\"\n                      // is modified properly, we also need to check all derived classes\n};\n\nclass EventStat : public Stat {\npublic:\n  void onEvent() {\n    if (count \u0026lt; LONG_MAX) {\n      count++;\n    }\n  }\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nclass Stat {\npublic:\n  long int getCount() {\n    return count;\n  }\nprotected:\n  void increment() { // Compliant; expose a protected member function\n    if (count \u0026lt; LONG_MAX) {\n      count++;\n    }\n  }\nprivate:\n  long int count \u003d 0; // member variable is private\n};\n\nclass EventStat : public Stat {\npublic:\n  void onEvent() {\n    increment();\n  }\n};\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eConst member variables and reference member variables are ignored since they don’t break invariants.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 11-0-1 - Member data in non-POD class types shall be private. \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c133-avoid-protected-data\"\u003eC.133:\n  Avoid \u003ccode\u003eprotected\u003c/code\u003e data\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eProtected member variables are similar to global variables; any derived class can modify them. When protected member variables are used, invariants\ncannot be enforced. Also, protected member variables are hard to maintain since they can be manipulated through multiple classes in different\nfiles.\u003c/p\u003e\n\u003cp\u003eIf a class is just a data store without logic, it can safely contain only \u003ccode\u003epublic\u003c/code\u003e member variables and no member functions. Otherwise,\ndata members are tightly coupled to the class logic, and encapsulation must be used. In this case, having only private member variables enforces\ninvariants for data and ensures that logic is defined only in the member functions of the class. Structuring it this way makes it easier to guarantee\nintegrity and easier for maintainers to understand the code.\u003c/p\u003e\n\u003cp\u003eUsing \u003ccode\u003eprotected\u003c/code\u003e member variables breaks the encapsulation. The risk is that data integrity logic spreads through the class and all its\nderived classes, becoming a source of complexity that will be error-prone for maintainers and extenders.\u003c/p\u003e\n\u003cp\u003eThat is why \u003ccode\u003eprotected\u003c/code\u003e member variables should be changed to \u003ccode\u003eprivate\u003c/code\u003e and manipulated exclusively through\n\u003ccode\u003epublic\u003c/code\u003e or \u003ccode\u003eprotected\u003c/code\u003e member functions of the base class.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when a \u003ccode\u003eclass\u003c/code\u003e or \u003ccode\u003estruct\u003c/code\u003e contains \u003ccode\u003eprotected\u003c/code\u003e member variables.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nclass Stat {\npublic:\n  long int getCount() {\n    return count;\n  }\nprotected:\n  long int count \u003d 0; // Noncompliant; expose a protected member variable.\n                      // By just looking at \"Stat\" class, it\u0027s not possible to be sure that \"count\"\n                      // is modified properly, we also need to check all derived classes\n};\n\nclass EventStat : public Stat {\npublic:\n  void onEvent() {\n    if (count \u0026lt; LONG_MAX) {\n      count++;\n    }\n  }\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nclass Stat {\npublic:\n  long int getCount() {\n    return count;\n  }\nprotected:\n  void increment() { // Compliant; expose a protected member function\n    if (count \u0026lt; LONG_MAX) {\n      count++;\n    }\n  }\nprivate:\n  long int count \u003d 0; // member variable is private\n};\n\nclass EventStat : public Stat {\npublic:\n  void onEvent() {\n    increment();\n  }\n};\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eConst member variables and reference member variables are ignored since they don’t break invariants.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 11-0-1 - Member data in non-POD class types shall be private. \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c133-avoid-protected-data\"\u003eC.133:\n  Avoid \u003ccode\u003eprotected\u003c/code\u003e data\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "cppcoreguidelines",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5952",
    "name": "Inheriting constructors should be used",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhen inheriting from a class, if you need to inherit its constructors without additional initialization you should prefer\n\u003ccode\u003eusing-declaration\u003c/code\u003e to inherit all base class’s constructors instead of writing them by hand.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eusing-declaration\u003c/code\u003e for inheriting constructor is a C++11 feature that makes all constructors of the base visible to the overload\nresolution when initializing the derived class.\u003c/p\u003e\n\u003cp\u003eIf you need to change the accessibility of one of the inherited constructors, you can do it by keeping the \u003ccode\u003eusing-declaration\u003c/code\u003e and\ndeclaring that constructor explicitly as private:\u003c/p\u003e\n\u003cpre\u003e\nclass Base {\npublic:\n  Base(int p) {}\n  Base(int p1, int p2) {}\n};\n\nclass Derived : public Base {\n  using Base::Base;\n  Derived(int p1, int p2);  // Changes constructor to private accessibility\n};\n\nint f(){\n  Derived b(1); // Base(int p) is visible when initializing the derived class\n  Derived b1(1,2); // Compilation error: Base(int p1, int p2) is not visible when initializing the derived class\n}\n\u003c/pre\u003e\n\u003cp\u003eThis rule raises an issue when a constructor inherits the base class constructor without requiring any additional initialization.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass Base {\npublic:\n  Base(int p) {}\n};\n\nclass Derived : public Base {\npublic:\n  Derived(int p) : Base(p) {} // Noncompliant\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nclass Base {\npublic:\n  Base(int p) {}\n};\n\nclass Derived : public Base {\n  using Base::Base;\n};\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c52-use-inheriting-constructors-to-import-constructors-into-a-derived-class-that-does-not-need-further-explicit-initialization\"\u003eC.52: Use inheriting constructors to import constructors into a derived class that does not need further explicit initialization\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhen inheriting from a class, if you need to inherit its constructors without additional initialization you should prefer\n\u003ccode\u003eusing-declaration\u003c/code\u003e to inherit all base class’s constructors instead of writing them by hand.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eusing-declaration\u003c/code\u003e for inheriting constructor is a C++11 feature that makes all constructors of the base visible to the overload\nresolution when initializing the derived class.\u003c/p\u003e\n\u003cp\u003eIf you need to change the accessibility of one of the inherited constructors, you can do it by keeping the \u003ccode\u003eusing-declaration\u003c/code\u003e and\ndeclaring that constructor explicitly as private:\u003c/p\u003e\n\u003cpre\u003e\nclass Base {\npublic:\n  Base(int p) {}\n  Base(int p1, int p2) {}\n};\n\nclass Derived : public Base {\n  using Base::Base;\n  Derived(int p1, int p2);  // Changes constructor to private accessibility\n};\n\nint f(){\n  Derived b(1); // Base(int p) is visible when initializing the derived class\n  Derived b1(1,2); // Compilation error: Base(int p1, int p2) is not visible when initializing the derived class\n}\n\u003c/pre\u003e\n\u003cp\u003eThis rule raises an issue when a constructor inherits the base class constructor without requiring any additional initialization.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass Base {\npublic:\n  Base(int p) {}\n};\n\nclass Derived : public Base {\npublic:\n  Derived(int p) : Base(p) {} // Noncompliant\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nclass Base {\npublic:\n  Base(int p) {}\n};\n\nclass Derived : public Base {\n  using Base::Base;\n};\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c52-use-inheriting-constructors-to-import-constructors-into-a-derived-class-that-does-not-need-further-explicit-initialization\"\u003eC.52: Use inheriting constructors to import constructors into a derived class that does not need further explicit initialization\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "clumsy",
      "cppcoreguidelines",
      "since-c++11"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1236",
    "name": "Assignment operators should return non-\"const\" references",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eCopy assignment operators and move assignment operators can return anything, including \u003ccode\u003evoid\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eHowever, if you decide to declare them yourself (don’t forget the \"Rule-of-Zero\", {rule:cpp:S4963}), it is a recommended practice to return a\nnon-const reference to the left-operand. It allows the developer to chain the assignment operations, increasing consistency with what other types do,\nand in some cases enabling writing concise code.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass A {\npublic:\n  ~A() \u003d default;\n  A(A const \u0026amp;) \u003d default;\n  A(A\u0026amp;\u0026amp;) \u003d default;\n  const A\u0026amp; operator\u003d(const A\u0026amp; other) ; // Noncompliant\n  A operator\u003d(A\u0026amp;\u0026amp; other) noexcept; // Noncompliant\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nclass A {\npublic:\n  ~A() \u003d default;\n  A(A const \u0026amp;) \u003d default;\n  A(A\u0026amp;\u0026amp;) \u003d default;\n  A\u0026amp; operator\u003d(const A\u0026amp; other);\n  A\u0026amp; operator\u003d(A\u0026amp;\u0026amp; other) noexcept;\n};\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c60-make-copy-assignment-non-virtual-take-the-parameter-by-const-and-return-by-non-const\"\u003eC.60: Make copy assignment non-\u003ccode\u003evirtual\u003c/code\u003e, take the parameter by \u003ccode\u003econst\u0026amp;\u003c/code\u003e, and return by non-\u003ccode\u003econst\u0026amp;\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c63-make-move-assignment-non-virtual-take-the-parameter-by—​and-return-by-non-const\"\u003eC.63: Make move assignment non-\u003ccode\u003evirtual\u003c/code\u003e, take the parameter by \u003ccode\u003e\u0026amp;\u0026amp;\u003c/code\u003e, and return by non-\u003ccode\u003econst\u0026amp;\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eCopy assignment operators and move assignment operators can return anything, including \u003ccode\u003evoid\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eHowever, if you decide to declare them yourself (don’t forget the \"Rule-of-Zero\", {rule:cpp:S4963}), it is a recommended practice to return a\nnon-const reference to the left-operand. It allows the developer to chain the assignment operations, increasing consistency with what other types do,\nand in some cases enabling writing concise code.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass A {\npublic:\n  ~A() \u003d default;\n  A(A const \u0026amp;) \u003d default;\n  A(A\u0026amp;\u0026amp;) \u003d default;\n  const A\u0026amp; operator\u003d(const A\u0026amp; other) ; // Noncompliant\n  A operator\u003d(A\u0026amp;\u0026amp; other) noexcept; // Noncompliant\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nclass A {\npublic:\n  ~A() \u003d default;\n  A(A const \u0026amp;) \u003d default;\n  A(A\u0026amp;\u0026amp;) \u003d default;\n  A\u0026amp; operator\u003d(const A\u0026amp; other);\n  A\u0026amp; operator\u003d(A\u0026amp;\u0026amp; other) noexcept;\n};\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c60-make-copy-assignment-non-virtual-take-the-parameter-by-const-and-return-by-non-const\"\u003eC.60: Make copy assignment non-\u003ccode\u003evirtual\u003c/code\u003e, take the parameter by \u003ccode\u003econst\u0026amp;\u003c/code\u003e, and return by non-\u003ccode\u003econst\u0026amp;\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c63-make-move-assignment-non-virtual-take-the-parameter-by—​and-return-by-non-const\"\u003eC.63: Make move assignment non-\u003ccode\u003evirtual\u003c/code\u003e, take the parameter by \u003ccode\u003e\u0026amp;\u0026amp;\u003c/code\u003e, and return by non-\u003ccode\u003econst\u0026amp;\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "convention",
      "cppcoreguidelines",
      "user-experience"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S2324",
    "name": "Flexible array members should not be declared",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eFlexible array members are most likely to be used in conjunction with dynamic memory allocation.\u003c/p\u003e\n\u003cp\u003eThe presence of flexible array members modifies the behaviour of the \u003ccode\u003esizeof\u003c/code\u003e operator in ways that might not be expected by a\nprogrammer. The assignment of a structure that contains a flexible array member to another structure of the same type may not behave in the expected\nmanner as it copies only those elements up to but not including the start of the flexible array member.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;stdlib.h\u0026gt;\nstruct s\n{\n  uint16_t len;\n  uint32_t data[ ]; // Noncompliant - flexible array member\n} str;\n\nstruct s *copy ( struct s *s1 )\n{\n  struct s *s2 \u003d malloc ( sizeof ( struct s ) + ( s1-\u0026gt;len * sizeof ( uint32_t ) ) );\n  /* Omit malloc ( ) return check for brevity */\n  *s2 \u003d *s1; /* Only copies s1-\u0026gt;len */\n  return s2;\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2012, 18.7 - Flexible array members shall not be declared. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eFlexible array members are most likely to be used in conjunction with dynamic memory allocation.\u003c/p\u003e\n\u003cp\u003eThe presence of flexible array members modifies the behaviour of the \u003ccode\u003esizeof\u003c/code\u003e operator in ways that might not be expected by a\nprogrammer. The assignment of a structure that contains a flexible array member to another structure of the same type may not behave in the expected\nmanner as it copies only those elements up to but not including the start of the flexible array member.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;stdlib.h\u0026gt;\nstruct s\n{\n  uint16_t len;\n  uint32_t data[ ]; // Noncompliant - flexible array member\n} str;\n\nstruct s *copy ( struct s *s1 )\n{\n  struct s *s2 \u003d malloc ( sizeof ( struct s ) + ( s1-\u0026gt;len * sizeof ( uint32_t ) ) );\n  /* Omit malloc ( ) return check for brevity */\n  *s2 \u003d *s1; /* Only copies s1-\u0026gt;len */\n  return s2;\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2012, 18.7 - Flexible array members shall not be declared. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S3776",
    "name": "Cognitive Complexity of functions should not be too high",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "FOCUSED",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003cp\u003eThis rule raises an issue when the code cognitive complexity of a function is above a certain threshold.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eCognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard\nto read, understand, test, and modify.\u003c/p\u003e\n\u003cp\u003eAs a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.\u003c/p\u003e\n\u003ch3\u003eWhich syntax in code does impact cognitive complexity score?\u003c/h3\u003e\n\u003cp\u003eHere are the core concepts:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003cstrong\u003eCognitive complexity is incremented each time the code breaks the normal linear reading flow.\u003c/strong\u003e\u003cbr\u003e This concerns, for example:\n  Loop structures, Conditionals, Catches, Switches, Jumps to label and mixed operators in condition. \u003c/li\u003e\n  \u003cli\u003e \u003cstrong\u003eEach nesting level adds a malus to the breaking call.\u003c/strong\u003e\u003cbr\u003e During code reading, the deeper you go through nested layers, the\n  harder it becomes to keep the context in mind. \u003c/li\u003e\n  \u003cli\u003e \u003cstrong\u003eMethod calls are free\u003c/strong\u003e\u003cbr\u003e A well-picked method name is a summary of multiple lines of code. A reader can first explore a\n  high-level view of what the code is performing then go deeper and deeper by looking at called functions content.\u003cbr\u003e \u003cem\u003eNote:\u003c/em\u003e This does not\n  apply to recursive calls, those will increment cognitive score. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe method of computation is fully detailed in the pdf linked in the resources.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eDevelopers spend more time reading and understanding code than writing it. High cognitive complexity slows down changes and increases the cost of\nmaintenance.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eReducing cognitive complexity can be challenging.\u003cbr\u003e Here are a few suggestions:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003cstrong\u003eExtract complex conditions in a new function.\u003c/strong\u003e\u003cbr\u003e Mixed operators in condition will increase complexity. Extracting the\n  condition in a new function with an appropriate name will reduce cognitive load. \u003c/li\u003e\n  \u003cli\u003e \u003cstrong\u003eBreak down large functions.\u003c/strong\u003e\u003cbr\u003e Large functions can be hard to understand and maintain. If a function is doing too many\n  things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. \u003c/li\u003e\n  \u003cli\u003e \u003cstrong\u003eAvoid deep nesting by returning early.\u003c/strong\u003e\u003cbr\u003e To avoid the nesting of conditions, process exceptional cases first and return\n  early. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eExtraction of a complex condition in a new function.\u003c/strong\u003e\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cp\u003eThe code is using a complex condition and has a cognitive cost of 3.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid processEligibleUser(User user) {\n  if ((user.isActive() \u0026amp;\u0026amp; user.hasProfile()) // +1 (if) +1 (multiple conditions)\n     || (user.getAge() \u0026gt; 18)) {              // +1 (mixing operators)\n    // process the user\n  }\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eEven if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the\n\u003ccode\u003eprocessEligibleUser\u003c/code\u003e function, which now only has a cognitive score of 1.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid processEligibleUser(User user) {\n  if (isEligibleUser(user)) {  // +1 (if)\n    // process the user\n  }\n}\n\nbool isEligibleUser(User user) {\n  return (user.isActive() \u0026amp;\u0026amp; user.hasProfile()) // +1 (multiple conditions)\n      || (user.getAge() \u0026gt; 18));                 // +1 (mixing operators)\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eBreak down large functions.\u003c/strong\u003e\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cp\u003eThe code is simplified here to illustrate the purpose. Please imagine there is more happening in the process.\u003cbr\u003e The overall complexity of\n\u003ccode\u003eprocessUser\u003c/code\u003e is 8.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid processUser(User user) {\n  if (user.isActive()) {      // +1 (if)\n    if (user.hasProfile()) {  // +1 (if) +1 (nested)\n      // process active user with profile\n    } else {                  // +1 (else)\n      // process active user without profile\n    }\n  } else {                    // +1 (else)\n    if (user.hasProfile()) {  // +1 (if) +1 (nested)\n      // process inactive user with profile\n    } else {                  // +1 (else)\n      // process inactive user without profile\n    }\n  }\n}\n\u003c/pre\u003e\n\u003cp\u003eThis function could be refactored into smaller functions: The complexity is spread over multiple functions, and the breaks in flow are no longer\nnested.\u003cbr\u003e The \u003ccode\u003eprocessUser\u003c/code\u003e now has a complexity score of two.\u003c/p\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"compliant\"\u003e\nvoid processUser(User user) {\n  if (user.isActive()) {      // +1 (if)\n    processActiveUser(user);\n  } else {                    // +1 (else)\n    processInactiveUser(user);\n  }\n}\n\nvoid processActiveUser(User user) {\n  if (user.hasProfile()) {    // +1 (if)\n      // process active user with profile\n  } else {                    // +1 (else)\n      // process active user without profile\n  }\n}\n\nvoid processInactiveUser(User user) {\n  if (user.hasProfile()) {    // +1 (if)\n    // process inactive user with profile\n  } else {                    // +1 (else)\n    // process inactive user without profile\n  }\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eAvoid deep nesting by returning early.\u003c/strong\u003e\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cp\u003eThe below code has a cognitive complexity of 3.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"4\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid checkUser(User user) {\n  if (user.isActive()) {     // +1 (if)\n    if (user.hasProfile()) { // +1 (if) +1 (nested)\n      // do something\n    }\n  }\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eChecking for the edge case first flattens the \u003ccode\u003eif\u003c/code\u003e statements and reduces the cognitive complexity to 2.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"4\" data-diff-type\u003d\"compliant\"\u003e\nvoid checkUser(User user) {\n  if (!user.isActive()) {\n    return;\n  }\n  if (!user.hasProfile()) {\n    return;\n  }\n  // do something\n}\n\u003c/pre\u003e\n\u003ch3\u003ePitfalls\u003c/h3\u003e\n\u003cp\u003eAs this code is complex, ensure that you have unit tests that cover the code before refactoring.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Sonar - \u003ca href\u003d\"https://www.sonarsource.com/docs/CognitiveComplexity.pdf\"\u003eCognitive Complexity\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eArticles \u0026amp; blog posts\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Sonar Blog - \u003ca href\u003d\"https://www.sonarsource.com/blog/5-clean-code-tips-for-reducing-cognitive-complexity/\"\u003e5 Clean Code Tips for Reducing\n  Cognitive Complexity\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eThis rule raises an issue when the code cognitive complexity of a function is above a certain threshold.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eCognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard\nto read, understand, test, and modify.\u003c/p\u003e\n\u003cp\u003eAs a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.\u003c/p\u003e\n\u003ch3\u003eWhich syntax in code does impact cognitive complexity score?\u003c/h3\u003e\n\u003cp\u003eHere are the core concepts:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003cstrong\u003eCognitive complexity is incremented each time the code breaks the normal linear reading flow.\u003c/strong\u003e\u003cbr\u003e This concerns, for example:\n  Loop structures, Conditionals, Catches, Switches, Jumps to label and mixed operators in condition. \u003c/li\u003e\n  \u003cli\u003e \u003cstrong\u003eEach nesting level adds a malus to the breaking call.\u003c/strong\u003e\u003cbr\u003e During code reading, the deeper you go through nested layers, the\n  harder it becomes to keep the context in mind. \u003c/li\u003e\n  \u003cli\u003e \u003cstrong\u003eMethod calls are free\u003c/strong\u003e\u003cbr\u003e A well-picked method name is a summary of multiple lines of code. A reader can first explore a\n  high-level view of what the code is performing then go deeper and deeper by looking at called functions content.\u003cbr\u003e \u003cem\u003eNote:\u003c/em\u003e This does not\n  apply to recursive calls, those will increment cognitive score. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe method of computation is fully detailed in the pdf linked in the resources.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eDevelopers spend more time reading and understanding code than writing it. High cognitive complexity slows down changes and increases the cost of\nmaintenance.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eReducing cognitive complexity can be challenging.\u003cbr\u003e Here are a few suggestions:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003cstrong\u003eExtract complex conditions in a new function.\u003c/strong\u003e\u003cbr\u003e Mixed operators in condition will increase complexity. Extracting the\n  condition in a new function with an appropriate name will reduce cognitive load. \u003c/li\u003e\n  \u003cli\u003e \u003cstrong\u003eBreak down large functions.\u003c/strong\u003e\u003cbr\u003e Large functions can be hard to understand and maintain. If a function is doing too many\n  things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility. \u003c/li\u003e\n  \u003cli\u003e \u003cstrong\u003eAvoid deep nesting by returning early.\u003c/strong\u003e\u003cbr\u003e To avoid the nesting of conditions, process exceptional cases first and return\n  early. \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u003cstrong\u003eExtraction of a complex condition in a new function.\u003c/strong\u003e\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cp\u003eThe code is using a complex condition and has a cognitive cost of 3.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid processEligibleUser(User user) {\n  if ((user.isActive() \u0026amp;\u0026amp; user.hasProfile()) // +1 (if) +1 (multiple conditions)\n     || (user.getAge() \u0026gt; 18)) {              // +1 (mixing operators)\n    // process the user\n  }\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eEven if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the\n\u003ccode\u003eprocessEligibleUser\u003c/code\u003e function, which now only has a cognitive score of 1.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid processEligibleUser(User user) {\n  if (isEligibleUser(user)) {  // +1 (if)\n    // process the user\n  }\n}\n\nbool isEligibleUser(User user) {\n  return (user.isActive() \u0026amp;\u0026amp; user.hasProfile()) // +1 (multiple conditions)\n      || (user.getAge() \u0026gt; 18));                 // +1 (mixing operators)\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eBreak down large functions.\u003c/strong\u003e\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cp\u003eThe code is simplified here to illustrate the purpose. Please imagine there is more happening in the process.\u003cbr\u003e The overall complexity of\n\u003ccode\u003eprocessUser\u003c/code\u003e is 8.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid processUser(User user) {\n  if (user.isActive()) {      // +1 (if)\n    if (user.hasProfile()) {  // +1 (if) +1 (nested)\n      // process active user with profile\n    } else {                  // +1 (else)\n      // process active user without profile\n    }\n  } else {                    // +1 (else)\n    if (user.hasProfile()) {  // +1 (if) +1 (nested)\n      // process inactive user with profile\n    } else {                  // +1 (else)\n      // process inactive user without profile\n    }\n  }\n}\n\u003c/pre\u003e\n\u003cp\u003eThis function could be refactored into smaller functions: The complexity is spread over multiple functions, and the breaks in flow are no longer\nnested.\u003cbr\u003e The \u003ccode\u003eprocessUser\u003c/code\u003e now has a complexity score of two.\u003c/p\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"3\" data-diff-type\u003d\"compliant\"\u003e\nvoid processUser(User user) {\n  if (user.isActive()) {      // +1 (if)\n    processActiveUser(user);\n  } else {                    // +1 (else)\n    processInactiveUser(user);\n  }\n}\n\nvoid processActiveUser(User user) {\n  if (user.hasProfile()) {    // +1 (if)\n      // process active user with profile\n  } else {                    // +1 (else)\n      // process active user without profile\n  }\n}\n\nvoid processInactiveUser(User user) {\n  if (user.hasProfile()) {    // +1 (if)\n    // process inactive user with profile\n  } else {                    // +1 (else)\n    // process inactive user without profile\n  }\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eAvoid deep nesting by returning early.\u003c/strong\u003e\u003c/p\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cp\u003eThe below code has a cognitive complexity of 3.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"4\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid checkUser(User user) {\n  if (user.isActive()) {     // +1 (if)\n    if (user.hasProfile()) { // +1 (if) +1 (nested)\n      // do something\n    }\n  }\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cp\u003eChecking for the edge case first flattens the \u003ccode\u003eif\u003c/code\u003e statements and reduces the cognitive complexity to 2.\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"4\" data-diff-type\u003d\"compliant\"\u003e\nvoid checkUser(User user) {\n  if (!user.isActive()) {\n    return;\n  }\n  if (!user.hasProfile()) {\n    return;\n  }\n  // do something\n}\n\u003c/pre\u003e\n\u003ch3\u003ePitfalls\u003c/h3\u003e\n\u003cp\u003eAs this code is complex, ensure that you have unit tests that cover the code before refactoring.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Sonar - \u003ca href\u003d\"https://www.sonarsource.com/docs/CognitiveComplexity.pdf\"\u003eCognitive Complexity\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eArticles \u0026amp; blog posts\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Sonar Blog - \u003ca href\u003d\"https://www.sonarsource.com/blog/5-clean-code-tips-for-reducing-cognitive-complexity/\"\u003e5 Clean Code Tips for Reducing\n  Cognitive Complexity\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {
      "maximumFunctionCognitiveComplexityThreshold": {
        "key": "maximumFunctionCognitiveComplexityThreshold",
        "name": "maximumFunctionCognitiveComplexityThreshold",
        "description": "The maximum authorized complexity.",
        "defaultValue": "25",
        "type": "INTEGER",
        "multiple": false,
        "possibleValues": []
      }
    },
    "defaultParams": {
      "maximumFunctionCognitiveComplexityThreshold": "25"
    },
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "brain-overload"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5832",
    "name": "Account validity should be verified when authenticating users with PAM",
    "defaultSeverity": "MAJOR",
    "type": "VULNERABILITY",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "SECURITY": "MEDIUM"
    },
    "description": "\u003cp\u003ePluggable authentication module (PAM) is a mechanism used on many UNIX variants to provide a unified way to authenticate users, independently of\nthe underlying authentication scheme.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhen authenticating users, if the validity of the account is not checked (not locked, not expired …​), it may lead to unauthorized access to\nresources.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nint valid(pam_handle_t *pamh) {\n    if (pam_authenticate(pamh, PAM_DISALLOW_NULL_AUTHTOK) !\u003d PAM_SUCCESS) { // Noncompliant\n        return -1;\n    }\n\n    return 0;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nint valid(pam_handle_t *pamh) {\n    if (pam_authenticate(pamh, PAM_DISALLOW_NULL_AUTHTOK) !\u003d PAM_SUCCESS) {\n        return -1;\n    }\n    if (pam_acct_mgmt(pamh, 0) !\u003d PAM_SUCCESS) {\n        return -1;\n    }\n\n    return 0;\n}\n\u003c/pre\u003e\n\u003ch3\u003eHow does this work?\u003c/h3\u003e\n\u003cp\u003eThe account validity is checked with \u003ccode\u003epam_acct_mgmt\u003c/code\u003e when authenticating a user with \u003ccode\u003epam_authenticate\u003c/code\u003e.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e The Open Group - \u003ca href\u003d\"https://pubs.opengroup.org/onlinepubs/8329799/pam_acct_mgmt.htm\"\u003e\u003ccode\u003epam_acct_mgmt\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eArticles \u0026amp; blog posts\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Packt hub - \u003ca href\u003d\"https://hub.packtpub.com/development-pluggable-authentication-modules-pam/\"\u003eDevelopment with Pluggable Authentication\n  Modules (PAM)\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e OWASP - \u003ca href\u003d\"https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures/\"\u003eTop 10 2021 Category A7 - Identification and\n  Authentication Failures\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e OWASP - \u003ca href\u003d\"https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A5-Broken_Access_Control\"\u003eTop 10 2017 Category A5 -\n  Broken Access Control\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/304\"\u003eCWE-304 - Missing Critical Step in Authentication\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003ePluggable authentication module (PAM) is a mechanism used on many UNIX variants to provide a unified way to authenticate users, independently of\nthe underlying authentication scheme.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhen authenticating users, if the validity of the account is not checked (not locked, not expired …​), it may lead to unauthorized access to\nresources.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nint valid(pam_handle_t *pamh) {\n    if (pam_authenticate(pamh, PAM_DISALLOW_NULL_AUTHTOK) !\u003d PAM_SUCCESS) { // Noncompliant\n        return -1;\n    }\n\n    return 0;\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nint valid(pam_handle_t *pamh) {\n    if (pam_authenticate(pamh, PAM_DISALLOW_NULL_AUTHTOK) !\u003d PAM_SUCCESS) {\n        return -1;\n    }\n    if (pam_acct_mgmt(pamh, 0) !\u003d PAM_SUCCESS) {\n        return -1;\n    }\n\n    return 0;\n}\n\u003c/pre\u003e\n\u003ch3\u003eHow does this work?\u003c/h3\u003e\n\u003cp\u003eThe account validity is checked with \u003ccode\u003epam_acct_mgmt\u003c/code\u003e when authenticating a user with \u003ccode\u003epam_authenticate\u003c/code\u003e.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e The Open Group - \u003ca href\u003d\"https://pubs.opengroup.org/onlinepubs/8329799/pam_acct_mgmt.htm\"\u003e\u003ccode\u003epam_acct_mgmt\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eArticles \u0026amp; blog posts\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e Packt hub - \u003ca href\u003d\"https://hub.packtpub.com/development-pluggable-authentication-modules-pam/\"\u003eDevelopment with Pluggable Authentication\n  Modules (PAM)\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e OWASP - \u003ca href\u003d\"https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures/\"\u003eTop 10 2021 Category A7 - Identification and\n  Authentication Failures\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e OWASP - \u003ca href\u003d\"https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A5-Broken_Access_Control\"\u003eTop 10 2017 Category A5 -\n  Broken Access Control\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e CWE - \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/304\"\u003eCWE-304 - Missing Critical Step in Authentication\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cwe",
      "symbolic-execution"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S878",
    "name": "Comma operator should not be used",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe comma operator takes two expressions, executes them from left to right, and returns the result of the second one. The use of this operator is\ngenerally detrimental to the readability and reliability of code, and the same effect can be achieved by other means.\u003c/p\u003e\n\u003cpre\u003e\ni \u003d a +\u003d 2, a + b;  // Noncompliant: What is the value of i?\n\u003c/pre\u003e\n\u003cp\u003eWriting each expression on its own line will improve readability and might fix misunderstandings.\u003c/p\u003e\n\u003cpre\u003e\na +\u003d 2;\ni \u003d a + b; // We probably expected to assign the result of the addition to i, although the previous code wasn\u0027t doing it.\n\u003c/pre\u003e\n\u003cp\u003eIt is especially error-prone in array subscripts - until C++20 - where it might be misinterpreted as accessing a multidimensional array.\u003c/p\u003e\n\u003cpre\u003e\na[1, 2] \u003d 3; // Noncompliant: until C++20, 1 is ignored. This is not an access to a multidimensional array.\n\u003c/pre\u003e\n\u003cp\u003eUsing a comma in this context was deprecated in C++20, and a real multi-dimensional subscript operator was introduced in C++23.\u003c/p\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThe comma operator is tolerated in initializations and increment expressions of \u003ccode\u003efor\u003c/code\u003e loops.\u003c/p\u003e\n\u003cpre\u003e\nfor (i \u003d 0, j \u003d 5; i \u0026lt; 6; i++, j++) { ... }\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 12.10 - The comma operator shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 5-18-1 - The comma operator shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 12.3 - The comma operator should not be used \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/operators#Array_subscript_operator\"\u003eArray subscript operator\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe comma operator takes two expressions, executes them from left to right, and returns the result of the second one. The use of this operator is\ngenerally detrimental to the readability and reliability of code, and the same effect can be achieved by other means.\u003c/p\u003e\n\u003cpre\u003e\ni \u003d a +\u003d 2, a + b;  // Noncompliant: What is the value of i?\n\u003c/pre\u003e\n\u003cp\u003eWriting each expression on its own line will improve readability and might fix misunderstandings.\u003c/p\u003e\n\u003cpre\u003e\na +\u003d 2;\ni \u003d a + b; // We probably expected to assign the result of the addition to i, although the previous code wasn\u0027t doing it.\n\u003c/pre\u003e\n\u003cp\u003eIt is especially error-prone in array subscripts - until C++20 - where it might be misinterpreted as accessing a multidimensional array.\u003c/p\u003e\n\u003cpre\u003e\na[1, 2] \u003d 3; // Noncompliant: until C++20, 1 is ignored. This is not an access to a multidimensional array.\n\u003c/pre\u003e\n\u003cp\u003eUsing a comma in this context was deprecated in C++20, and a real multi-dimensional subscript operator was introduced in C++23.\u003c/p\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThe comma operator is tolerated in initializations and increment expressions of \u003ccode\u003efor\u003c/code\u003e loops.\u003c/p\u003e\n\u003cpre\u003e\nfor (i \u003d 0, j \u003d 5; i \u0026lt; 6; i++, j++) { ... }\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 12.10 - The comma operator shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 5-18-1 - The comma operator shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 12.3 - The comma operator should not be used \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/operators#Array_subscript_operator\"\u003eArray subscript operator\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "based-on-misra"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S999",
    "name": "\"goto\" should jump to labels declared later in the same function",
    "defaultSeverity": "BLOCKER",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eUnconstrained use of \u003ccode\u003egoto\u003c/code\u003e can lead to programs that are extremely difficult to comprehend and analyse. For C++, it can also lead to\nthe program exhibiting unspecified behavior.\u003c/p\u003e\n\u003cp\u003eHowever, in many cases a total ban on \u003ccode\u003egoto\u003c/code\u003e requires the introduction of flags to ensure correct control flow, and it is possible that\nthese flags may themselves be less transparent than the \u003ccode\u003egoto\u003c/code\u003e they replace.\u003c/p\u003e\n\u003cp\u003eTherefore, the restricted use of \u003ccode\u003egoto\u003c/code\u003e is allowed where that use will not lead to semantics contrary to developer expectations. \"Back\"\njumps are prohibited, since they can be used to create iterations without using the well-defined iteration statements supplied by the core\nlanguage.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint f() {\n  int j \u003d 0;\nL1:\n  ++j;\n  if (10 \u003d\u003d j) {\n    goto L2;         // forward jump ignored\n  }\n  // ...\n  goto L1;           // Noncompliant\nL2:\n  return ++j;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint f() {\n  for (int j \u003d 0; j \u0026lt; 11; j++) {\n    // ...\n  }\n  return ++j;\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 6-6-2 - The goto statement shall jump to a label declared later in the same function body \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 15.2 - The goto statement shall jump to a label declared later in the same function \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eUnconstrained use of \u003ccode\u003egoto\u003c/code\u003e can lead to programs that are extremely difficult to comprehend and analyse. For C++, it can also lead to\nthe program exhibiting unspecified behavior.\u003c/p\u003e\n\u003cp\u003eHowever, in many cases a total ban on \u003ccode\u003egoto\u003c/code\u003e requires the introduction of flags to ensure correct control flow, and it is possible that\nthese flags may themselves be less transparent than the \u003ccode\u003egoto\u003c/code\u003e they replace.\u003c/p\u003e\n\u003cp\u003eTherefore, the restricted use of \u003ccode\u003egoto\u003c/code\u003e is allowed where that use will not lead to semantics contrary to developer expectations. \"Back\"\njumps are prohibited, since they can be used to create iterations without using the well-defined iteration statements supplied by the core\nlanguage.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint f() {\n  int j \u003d 0;\nL1:\n  ++j;\n  if (10 \u003d\u003d j) {\n    goto L2;         // forward jump ignored\n  }\n  // ...\n  goto L1;           // Noncompliant\nL2:\n  return ++j;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint f() {\n  for (int j \u003d 0; j \u0026lt; 11; j++) {\n    // ...\n  }\n  return ++j;\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 6-6-2 - The goto statement shall jump to a label declared later in the same function body \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 15.2 - The goto statement shall jump to a label declared later in the same function \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "pitfall"
    ],
    "deprecatedKeys": [
      "cpp:BackJumpWithGoto"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S876",
    "name": "Unary minus should not be applied to an unsigned expression",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eApplying the unary minus operator to an unsigned variable or expression will always yield another unsigned expression. More plainly, in some cases\nthe operation itself is meaningless, and in some other cases the result will be unexpected. In all cases it is bad practice. Therefore the unary minus\noperator should not be applied to unsigned variables or expressions.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nuint8_t a \u003d -1U;\nint32_t b \u003d -a; // Noncompliant; b is assigned -255\nuint32_t c \u003d 1U;\nint64_t d \u003d -c; // Noncompliant; d is assigned MAX_UINT\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThis rule ignores \u003ccode\u003e-1U\u003c/code\u003e because it is commonly used as shorthand for \u003ccode\u003eMAX_UINT\u003c/code\u003e.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 12.9 - The unary minus operator shall not be applied to an expression whose underlying type is unsigned. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 5-3-2 - The unary minus operator shall not be applied to an expression whose underlying type is unsigned. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 10.1 - Operands shall not be of an inappropriate essential type \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eApplying the unary minus operator to an unsigned variable or expression will always yield another unsigned expression. More plainly, in some cases\nthe operation itself is meaningless, and in some other cases the result will be unexpected. In all cases it is bad practice. Therefore the unary minus\noperator should not be applied to unsigned variables or expressions.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nuint8_t a \u003d -1U;\nint32_t b \u003d -a; // Noncompliant; b is assigned -255\nuint32_t c \u003d 1U;\nint64_t d \u003d -c; // Noncompliant; d is assigned MAX_UINT\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThis rule ignores \u003ccode\u003e-1U\u003c/code\u003e because it is commonly used as shorthand for \u003ccode\u003eMAX_UINT\u003c/code\u003e.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 12.9 - The unary minus operator shall not be applied to an expression whose underlying type is unsigned. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 5-3-2 - The unary minus operator shall not be applied to an expression whose underlying type is unsigned. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 10.1 - Operands shall not be of an inappropriate essential type \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "based-on-misra"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S997",
    "name": "The global namespace should only contain \"main\", namespace declarations, and \"extern\" C declarations",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "MODULAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eDeclaring names in appropriate namespaces reduces the number of names found during lookup, decreasing the risk of name clash and of surprising name\nlookup.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when a name in the global namespace has external linkage and therefore can be accessed from outside a particular\ntranslation unit.\u003c/p\u003e\n\u003cp\u003eSome names have to be declared in the global namespace, and are excluded from this rule:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003emain\u003c/code\u003e (or its variants) \u003c/li\u003e\n  \u003cli\u003e Overloads of the global \u003ccode\u003enew\u003c/code\u003e \u0026amp; \u003ccode\u003edelete\u003c/code\u003e operators \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn addition, no issue is raised for function definitions because they can only be accessed from different translation units through a forward\ndeclaration that will be flagged.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint a; // Noncompliant\nint b \u003d 1; // Noncompliant\nextern int  c \u003d 1; // Noncompliant\nextern const int d \u003d 1; // Noncompliant\n\nvoid f(); // Noncompliant\n\nclass A { // Noncompliant\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nnamespace MY_API { // Compliant\nint a;\nint b \u003d 1;\nextern int  c \u003d 1;\nextern const int d \u003d 1;\n\nvoid  f();\n\nclass A {\n};\n} // namespace MY_API\n\nnamespace { // Compliant, anonymous namespace\n  int  a \u003d 1;\n  void m2() {\n  }\n}\n\nint main() { // Compliant, exception for main\n}\n\nstatic int a; // Compliant, internal linkage\nstatic void m1(); // Compliant, internal linkage\n\nconst int a \u003d 1; // Compliant, a global constant is implicitly static\n\nextern \"C\" int a \u003d 1; // Compliant\n\nextern \"C\" void f1(); // Compliant\nvoid f2() {} // Compliant\n\ntypedef int a; // Compliant, we don\u0027t detect aliases\n\nvoid *operator new(size_t bytes, const X::Y\u0026amp; context) { return X::malloc(bytes,context); } // Compliant by exception\nvoid operator delete(void* ptr,  const X::Y\u0026amp; context) { X::free(bytes,context); } // Compliant by exception\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 7-3-1 - The global namespace shall only contain main, namespace declarations and extern \"C\" declarations. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eDeclaring names in appropriate namespaces reduces the number of names found during lookup, decreasing the risk of name clash and of surprising name\nlookup.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when a name in the global namespace has external linkage and therefore can be accessed from outside a particular\ntranslation unit.\u003c/p\u003e\n\u003cp\u003eSome names have to be declared in the global namespace, and are excluded from this rule:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003emain\u003c/code\u003e (or its variants) \u003c/li\u003e\n  \u003cli\u003e Overloads of the global \u003ccode\u003enew\u003c/code\u003e \u0026amp; \u003ccode\u003edelete\u003c/code\u003e operators \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn addition, no issue is raised for function definitions because they can only be accessed from different translation units through a forward\ndeclaration that will be flagged.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint a; // Noncompliant\nint b \u003d 1; // Noncompliant\nextern int  c \u003d 1; // Noncompliant\nextern const int d \u003d 1; // Noncompliant\n\nvoid f(); // Noncompliant\n\nclass A { // Noncompliant\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nnamespace MY_API { // Compliant\nint a;\nint b \u003d 1;\nextern int  c \u003d 1;\nextern const int d \u003d 1;\n\nvoid  f();\n\nclass A {\n};\n} // namespace MY_API\n\nnamespace { // Compliant, anonymous namespace\n  int  a \u003d 1;\n  void m2() {\n  }\n}\n\nint main() { // Compliant, exception for main\n}\n\nstatic int a; // Compliant, internal linkage\nstatic void m1(); // Compliant, internal linkage\n\nconst int a \u003d 1; // Compliant, a global constant is implicitly static\n\nextern \"C\" int a \u003d 1; // Compliant\n\nextern \"C\" void f1(); // Compliant\nvoid f2() {} // Compliant\n\ntypedef int a; // Compliant, we don\u0027t detect aliases\n\nvoid *operator new(size_t bytes, const X::Y\u0026amp; context) { return X::malloc(bytes,context); } // Compliant by exception\nvoid operator delete(void* ptr,  const X::Y\u0026amp; context) { X::free(bytes,context); } // Compliant by exception\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 7-3-1 - The global namespace shall only contain main, namespace declarations and extern \"C\" declarations. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "brain-overload"
    ],
    "deprecatedKeys": [
      "cpp:GlobalNamespaceMembers"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S877",
    "name": "The unary \"\u0026\" operator should not be overloaded",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eTaking the address of an object of incomplete type, where the complete type contains a user declared \u003ccode\u003eoperator \u0026amp;\u003c/code\u003e leads to undefined\nbehavior.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n// A.h\nclass A\n{\npublic:\n  A * operator \u0026amp; ( ); // Noncompliant\n};\n\n// f1.cc\nclass A;\nvoid f ( A \u0026amp; a )\n{\n  \u0026amp;a; // uses built-in operator \u0026amp;\n}\n\n// f2.cc\n#include \"A.h\"\nvoid f2 ( A \u0026amp; a )\n{\n  \u0026amp;a; // use user-defined operator \u0026amp;\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++ 2008, 5-3-3 - The unary \u0026amp; operator shall not be overloaded. \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c166-overload-unary—​only-as-part-of-a-system-of-smart-pointers-and-references\"\u003eC.166: Overload unary \u003ccode\u003e\u0026amp;\u003c/code\u003e only as part of a system of smart pointers and references\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eTaking the address of an object of incomplete type, where the complete type contains a user declared \u003ccode\u003eoperator \u0026amp;\u003c/code\u003e leads to undefined\nbehavior.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n// A.h\nclass A\n{\npublic:\n  A * operator \u0026amp; ( ); // Noncompliant\n};\n\n// f1.cc\nclass A;\nvoid f ( A \u0026amp; a )\n{\n  \u0026amp;a; // uses built-in operator \u0026amp;\n}\n\n// f2.cc\n#include \"A.h\"\nvoid f2 ( A \u0026amp; a )\n{\n  \u0026amp;a; // use user-defined operator \u0026amp;\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C++ 2008, 5-3-3 - The unary \u0026amp; operator shall not be overloaded. \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c166-overload-unary—​only-as-part-of-a-system-of-smart-pointers-and-references\"\u003eC.166: Overload unary \u003ccode\u003e\u0026amp;\u003c/code\u003e only as part of a system of smart pointers and references\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cppcoreguidelines",
      "misra-c++2008"
    ],
    "deprecatedKeys": [
      "cpp:UnaryAndOverloaded"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S998",
    "name": "The name \"main\" should not be used for any function other than the global \"main\" function",
    "defaultSeverity": "BLOCKER",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eA global function named \u003ccode\u003emain\u003c/code\u003e is the entry point to the program, and is the only identifier which must be in the global namespace. The\nuse of \u003ccode\u003emain\u003c/code\u003e for other functions may not meet developer expectations.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint main() {       // Compliant\n}\n\nnamespace {\n  int main() {     // Noncompliant\n  }\n}\nnamespace NS {\n  int main() {     // Noncompliant\n  }\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 7-3-2 - The identifier main shall not be used for a function other than global function main. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eA global function named \u003ccode\u003emain\u003c/code\u003e is the entry point to the program, and is the only identifier which must be in the global namespace. The\nuse of \u003ccode\u003emain\u003c/code\u003e for other functions may not meet developer expectations.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint main() {       // Compliant\n}\n\nnamespace {\n  int main() {     // Noncompliant\n  }\n}\nnamespace NS {\n  int main() {     // Noncompliant\n  }\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 7-3-2 - The identifier main shall not be used for a function other than global function main. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "misra-c++2008",
      "pitfall"
    ],
    "deprecatedKeys": [
      "cpp:GlobalMainFunction"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S874",
    "name": "Bitwise operators should not be applied to signed operands",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eMost built-in bitwise operators (\u003ccode\u003e~\u003c/code\u003e, \u003ccode\u003e\u0026gt;\u0026gt;\u003c/code\u003e, \u003ccode\u003e\u0026gt;\u0026gt;\u003d\u003c/code\u003e, \u003ccode\u003e\u0026amp;\u003c/code\u003e, \u003ccode\u003e\u0026amp;\u003d\u003c/code\u003e,\n\u003ccode\u003e^\u003c/code\u003e, \u003ccode\u003e^\u003d\u003c/code\u003e, \u003ccode\u003e|\u003c/code\u003e, and \u003ccode\u003e|\u003d\u003c/code\u003e) have implementation-dependent results when performed on signed operands, and\nbitwise left shift (\u003ccode\u003e\u0026lt;\u0026lt;\u003c/code\u003e and \u003ccode\u003e\u0026lt;\u0026lt;\u003d\u003c/code\u003e) has unspecified or undefined behavior when performed on negative operands.\u003c/p\u003e\n\u003cp\u003eTherefore, bitwise operations should not be performed on signed operands.\u003c/p\u003e\n\u003cp\u003eStarting with C++20, the behaviors have been defined more accurately (negative values have to be represented using two’s complement), and therefore\nthis rule will only report an issue when the second operand of a shift operator is signed (shifting by a negative value is still undefined\nbehavior).\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nif ( ( uint16_a \u0026amp; int16_b ) \u003d\u003d 0x1234U ) // Noncompliant until C++20\nif ( ~int16_a \u003d\u003d 0x1234U ) // Noncompliant until C++20\n\nauto f(int i) {\n    return 1 \u0026lt;\u0026lt; i; // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nif ( ( uint16_a | uint16_b ) \u003d\u003d 0x1234U )\nif ( ~uint16_a \u003d\u003d 0x1234U )\n\nauto f(unsigned int i) {\n    return 1 \u0026lt;\u0026lt; i;\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eWhen used as bit flags, it is acceptable to use preprocessor macros as arguments to the \u0026amp; and | operators even if the value is not explicitly\ndeclared as unsigned.\u003c/p\u003e\n\u003cpre\u003e\nfd \u003d open(file_name, UO_WRONLY | UO_CREAT | UO_EXCL | UO_TRUNC, 0600);\n\u003c/pre\u003e\n\u003cp\u003eIf the right-side operand to a shift operator is known at compile time, it is acceptable for the value to be represented with a signed type\nprovided it is positive.\u003c/p\u003e\n\u003cpre\u003e\n#define SHIFT 24\nfoo \u003d 15u \u0026gt;\u0026gt; SHIFT;\n\u003c/pre\u003e\n\u003cp\u003eWhen combining several bitwise operations, even if all leaf operands are unsigned, if they are smaller than an \u003ccode\u003eint\u003c/code\u003e, some intermediate\nresults will be of type \u003ccode\u003esigned int\u003c/code\u003e, due to integral promotion. However, this situation is usually not an issue, and is an exception for\nthis rule:\u003c/p\u003e\n\u003cpre\u003e\nunsigned int f(unsigned short src) {\n  return (src \u0026gt;\u0026gt; 3) \u0026amp; 0x1F; // (src \u0026gt;\u0026gt; 3) is of type signed int\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 12.7 - Bitwise operators shall not be applied to operands whose underlying type is signed \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 5-0-21 - Bitwise operators shall only be applied to operands of unsigned underlying type \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 10.1 - Operands shall not be of an inappropriate essential type \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/9tYxBQ\"\u003eCERT, INT13-C.\u003c/a\u003e - Use bitwise operators only on unsigned operands \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/682\"\u003eMITRE, CWE-682\u003c/a\u003e - Incorrect Calculation \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eMost built-in bitwise operators (\u003ccode\u003e~\u003c/code\u003e, \u003ccode\u003e\u0026gt;\u0026gt;\u003c/code\u003e, \u003ccode\u003e\u0026gt;\u0026gt;\u003d\u003c/code\u003e, \u003ccode\u003e\u0026amp;\u003c/code\u003e, \u003ccode\u003e\u0026amp;\u003d\u003c/code\u003e,\n\u003ccode\u003e^\u003c/code\u003e, \u003ccode\u003e^\u003d\u003c/code\u003e, \u003ccode\u003e|\u003c/code\u003e, and \u003ccode\u003e|\u003d\u003c/code\u003e) have implementation-dependent results when performed on signed operands, and\nbitwise left shift (\u003ccode\u003e\u0026lt;\u0026lt;\u003c/code\u003e and \u003ccode\u003e\u0026lt;\u0026lt;\u003d\u003c/code\u003e) has unspecified or undefined behavior when performed on negative operands.\u003c/p\u003e\n\u003cp\u003eTherefore, bitwise operations should not be performed on signed operands.\u003c/p\u003e\n\u003cp\u003eStarting with C++20, the behaviors have been defined more accurately (negative values have to be represented using two’s complement), and therefore\nthis rule will only report an issue when the second operand of a shift operator is signed (shifting by a negative value is still undefined\nbehavior).\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nif ( ( uint16_a \u0026amp; int16_b ) \u003d\u003d 0x1234U ) // Noncompliant until C++20\nif ( ~int16_a \u003d\u003d 0x1234U ) // Noncompliant until C++20\n\nauto f(int i) {\n    return 1 \u0026lt;\u0026lt; i; // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nif ( ( uint16_a | uint16_b ) \u003d\u003d 0x1234U )\nif ( ~uint16_a \u003d\u003d 0x1234U )\n\nauto f(unsigned int i) {\n    return 1 \u0026lt;\u0026lt; i;\n}\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eWhen used as bit flags, it is acceptable to use preprocessor macros as arguments to the \u0026amp; and | operators even if the value is not explicitly\ndeclared as unsigned.\u003c/p\u003e\n\u003cpre\u003e\nfd \u003d open(file_name, UO_WRONLY | UO_CREAT | UO_EXCL | UO_TRUNC, 0600);\n\u003c/pre\u003e\n\u003cp\u003eIf the right-side operand to a shift operator is known at compile time, it is acceptable for the value to be represented with a signed type\nprovided it is positive.\u003c/p\u003e\n\u003cpre\u003e\n#define SHIFT 24\nfoo \u003d 15u \u0026gt;\u0026gt; SHIFT;\n\u003c/pre\u003e\n\u003cp\u003eWhen combining several bitwise operations, even if all leaf operands are unsigned, if they are smaller than an \u003ccode\u003eint\u003c/code\u003e, some intermediate\nresults will be of type \u003ccode\u003esigned int\u003c/code\u003e, due to integral promotion. However, this situation is usually not an issue, and is an exception for\nthis rule:\u003c/p\u003e\n\u003cpre\u003e\nunsigned int f(unsigned short src) {\n  return (src \u0026gt;\u0026gt; 3) \u0026amp; 0x1F; // (src \u0026gt;\u0026gt; 3) is of type signed int\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 12.7 - Bitwise operators shall not be applied to operands whose underlying type is signed \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 5-0-21 - Bitwise operators shall only be applied to operands of unsigned underlying type \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 10.1 - Operands shall not be of an inappropriate essential type \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/9tYxBQ\"\u003eCERT, INT13-C.\u003c/a\u003e - Use bitwise operators only on unsigned operands \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/682\"\u003eMITRE, CWE-682\u003c/a\u003e - Incorrect Calculation \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "bad-practice",
      "based-on-misra",
      "cert",
      "cwe",
      "lock-in"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S995",
    "name": "Pointer and reference parameters should be \"const\" if the corresponding object is not modified",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eConst correctness is an important tool for type safety. It allows for catching coding errors at compile time and it documents the code for\nmaintainers.\u003c/p\u003e\n\u003cp\u003eCorrectly const-qualifying pointers can be tricky because the indirection they add can also be const.\u003c/p\u003e\n\u003cp\u003eFor a pointer \u003ccode\u003eX * ptr\u003c/code\u003e, const can be written in three different places:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003econst X * ptr\u003c/code\u003e and \u003ccode\u003eX const * ptr\u003c/code\u003e are identical and mean that the X object \u003ccode\u003eptr\u003c/code\u003e points to cannot be\n  changed. \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003eX * const ptr\u003c/code\u003e means that the pointer cannot be changed to point to a different X object. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn a function signature, the first \u003ccode\u003econst X * ptr\u003c/code\u003e (or its equivalent \u003ccode\u003eX const * ptr\u003c/code\u003e) is the one that will bring\ntype-safety. It protects against changing the value pointed at.\u003c/p\u003e\n\u003cpre\u003e\nvoid externalFunction(int * a, const int * b);\n\nvoid myfunc() {\n  int a \u003d 1;\n  int b \u003d 2;\n  externalFunction(\u0026amp;a, \u0026amp;b);\n  // a can now have any value\n  // We know that b is still \u00272\u0027\n}\n\u003c/pre\u003e\n\u003cp\u003eThis rule detects when a pointer or reference parameter could be made const\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid myfunc (      int * param1,  // object is modified\n             const int * param2,\n                   int * param3, // Noncompliant\n             int * const param4) // Noncompliant: const doesn\u0027t qualify what is pointed at.\n{\n  *param1 \u003d *param2 + *param3 + *param4;\n}\n\nvoid increment (int \u0026amp; value,\n                int \u0026amp; increment) // Noncompliant\n{\n  value +\u003d increment;\n}\n\u003c/pre\u003e\n\u003cp\u003eWhen adding all possible \u003ccode\u003econst\u003c/code\u003e qualifications, we get:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid myfunc (      int * param1,  // object is modified\n             const int * param2,\n             const int * param3,\n             const int * param4)\n{\n  *param1 \u003d *param2 + *param3 + *param4;\n}\n\nvoid increment (int \u0026amp; value,\n                const int \u0026amp; increment)\n{\n  value +\u003d increment;\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eArticles \u0026amp; blog posts\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://isocpp.org/wiki/faq/const-correctness\"\u003eISO C++ FAQ about const correctness\u003c/a\u003e. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify\n  the addressed object. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the\n  corresponding object is not modified. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eConst correctness is an important tool for type safety. It allows for catching coding errors at compile time and it documents the code for\nmaintainers.\u003c/p\u003e\n\u003cp\u003eCorrectly const-qualifying pointers can be tricky because the indirection they add can also be const.\u003c/p\u003e\n\u003cp\u003eFor a pointer \u003ccode\u003eX * ptr\u003c/code\u003e, const can be written in three different places:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003econst X * ptr\u003c/code\u003e and \u003ccode\u003eX const * ptr\u003c/code\u003e are identical and mean that the X object \u003ccode\u003eptr\u003c/code\u003e points to cannot be\n  changed. \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003eX * const ptr\u003c/code\u003e means that the pointer cannot be changed to point to a different X object. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn a function signature, the first \u003ccode\u003econst X * ptr\u003c/code\u003e (or its equivalent \u003ccode\u003eX const * ptr\u003c/code\u003e) is the one that will bring\ntype-safety. It protects against changing the value pointed at.\u003c/p\u003e\n\u003cpre\u003e\nvoid externalFunction(int * a, const int * b);\n\nvoid myfunc() {\n  int a \u003d 1;\n  int b \u003d 2;\n  externalFunction(\u0026amp;a, \u0026amp;b);\n  // a can now have any value\n  // We know that b is still \u00272\u0027\n}\n\u003c/pre\u003e\n\u003cp\u003eThis rule detects when a pointer or reference parameter could be made const\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid myfunc (      int * param1,  // object is modified\n             const int * param2,\n                   int * param3, // Noncompliant\n             int * const param4) // Noncompliant: const doesn\u0027t qualify what is pointed at.\n{\n  *param1 \u003d *param2 + *param3 + *param4;\n}\n\nvoid increment (int \u0026amp; value,\n                int \u0026amp; increment) // Noncompliant\n{\n  value +\u003d increment;\n}\n\u003c/pre\u003e\n\u003cp\u003eWhen adding all possible \u003ccode\u003econst\u003c/code\u003e qualifications, we get:\u003c/p\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid myfunc (      int * param1,  // object is modified\n             const int * param2,\n             const int * param3,\n             const int * param4)\n{\n  *param1 \u003d *param2 + *param3 + *param4;\n}\n\nvoid increment (int \u0026amp; value,\n                const int \u0026amp; increment)\n{\n  value +\u003d increment;\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eArticles \u0026amp; blog posts\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://isocpp.org/wiki/faq/const-correctness\"\u003eISO C++ FAQ about const correctness\u003c/a\u003e. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 16.7 - A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify\n  the addressed object. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 7-1-2 - A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the\n  corresponding object is not modified. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "bad-practice",
      "misra-c++2008",
      "misra-c2004",
      "misra-c2012"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S872",
    "name": "\"bool\" expressions should not be used as operands to built-in operators other than \u003d, \u0026\u0026, ||, !, \u003d\u003d, !\u003d, unary \u0026, and the conditional operator",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe use of \u003ccode\u003ebool\u003c/code\u003e operands with other operators is unlikely to be meaningful (or intended). Best case it will be confusing to\nmaintainers, worst case it will not have the intended effect. Either way, it is highly recommended to stick to boolean operators when dealing with\n\u003ccode\u003ebool\u003c/code\u003e operands.\u003c/p\u003e\n\u003cp\u003eThis rule allows the detection of such uses, which often occur because the logical operators (\u003ccode\u003e\u0026amp;\u0026amp;\u003c/code\u003e, \u003ccode\u003e||\u003c/code\u003e and\n\u003ccode\u003e!\u003c/code\u003e) can be easily confused with the bitwise operators (\u003ccode\u003e\u0026amp;\u003c/code\u003e, \u003ccode\u003e|\u003c/code\u003e and \u003ccode\u003e~\u003c/code\u003e).\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nbool b1 \u003d true;\nbool b2 \u003d false;\nint8_t s8a;\nif ( b1 \u0026amp; b2 ) // Noncompliant\nif ( ~b1 ) // Noncompliant\nif ( b1 \u0026lt; b2 ) // Noncompliant\nif ( b1 ^ b2 ) // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nif ( b1 \u0026amp;\u0026amp; b2 )\nif ( !b1 )\nif ( b1 \u003d\u003d false )\nif ( b1 \u003d\u003d b2 )\nif ( b1 !\u003d b2 )\ns8a \u003d b1 ? 3 : 7;\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eOperators \u003ccode\u003e|\u003d\u003c/code\u003e and \u003ccode\u003e\u0026amp;\u003d\u003c/code\u003e are ignored when used with \u003ccode\u003ebool\u003c/code\u003e operands. Operator \u003ccode\u003e++\u003c/code\u003e is also ignored\nwith a \u003ccode\u003ebool\u003c/code\u003e operand because it is covered by rule {rule:cpp:S2668}.\u003c/p\u003e\n\u003cpre\u003e\nvoid test(bool b1, bool b2, int i1) {\n  b1 |\u003d b2; // ignored\n  b1++; // ignored here, handled by S2668\n  b1 \u0026amp;\u003d b2; // ignored\n  b1 \u0026amp;\u003d i1; // Noncompliant; right operand is not a bool\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 4-5-1 - Expressions with type bool shall not be used as operands to built-in operators other than the assignment operator \u003d,\n  the logical operators \u0026amp;\u0026amp;, ||, !, the equality operators \u003d\u003d and !\u003d, the unary \u0026amp; operator, and the conditional operator. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe use of \u003ccode\u003ebool\u003c/code\u003e operands with other operators is unlikely to be meaningful (or intended). Best case it will be confusing to\nmaintainers, worst case it will not have the intended effect. Either way, it is highly recommended to stick to boolean operators when dealing with\n\u003ccode\u003ebool\u003c/code\u003e operands.\u003c/p\u003e\n\u003cp\u003eThis rule allows the detection of such uses, which often occur because the logical operators (\u003ccode\u003e\u0026amp;\u0026amp;\u003c/code\u003e, \u003ccode\u003e||\u003c/code\u003e and\n\u003ccode\u003e!\u003c/code\u003e) can be easily confused with the bitwise operators (\u003ccode\u003e\u0026amp;\u003c/code\u003e, \u003ccode\u003e|\u003c/code\u003e and \u003ccode\u003e~\u003c/code\u003e).\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nbool b1 \u003d true;\nbool b2 \u003d false;\nint8_t s8a;\nif ( b1 \u0026amp; b2 ) // Noncompliant\nif ( ~b1 ) // Noncompliant\nif ( b1 \u0026lt; b2 ) // Noncompliant\nif ( b1 ^ b2 ) // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nif ( b1 \u0026amp;\u0026amp; b2 )\nif ( !b1 )\nif ( b1 \u003d\u003d false )\nif ( b1 \u003d\u003d b2 )\nif ( b1 !\u003d b2 )\ns8a \u003d b1 ? 3 : 7;\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eOperators \u003ccode\u003e|\u003d\u003c/code\u003e and \u003ccode\u003e\u0026amp;\u003d\u003c/code\u003e are ignored when used with \u003ccode\u003ebool\u003c/code\u003e operands. Operator \u003ccode\u003e++\u003c/code\u003e is also ignored\nwith a \u003ccode\u003ebool\u003c/code\u003e operand because it is covered by rule {rule:cpp:S2668}.\u003c/p\u003e\n\u003cpre\u003e\nvoid test(bool b1, bool b2, int i1) {\n  b1 |\u003d b2; // ignored\n  b1++; // ignored here, handled by S2668\n  b1 \u0026amp;\u003d b2; // ignored\n  b1 \u0026amp;\u003d i1; // Noncompliant; right operand is not a bool\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 4-5-1 - Expressions with type bool shall not be used as operands to built-in operators other than the assignment operator \u003d,\n  the logical operators \u0026amp;\u0026amp;, ||, !, the equality operators \u003d\u003d and !\u003d, the unary \u0026amp; operator, and the conditional operator. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S873",
    "name": "\"enum\" values should not be used as operands to built-in operators other than [ ], \u003d, \u003d\u003d, !\u003d, unary \u0026, and the relational operators \u003c, \u003c\u003d, \u003e, \u003e\u003d",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eEnumerations are used to represent symbolic values, or sometimes bit fields. They are not supposed to be used in arithmetic contexts.\u003c/p\u003e\n\u003cp\u003eAdditionally, even though comparing them with integer numbers can make sense (for instance, to test if an enum lies with a certain range),\ncomparing them with floating point numbers does not (and is deprecated since C++20).\u003c/p\u003e\n\u003cp\u003eThere are other restrictions related to the use of enums, see for instance {rule:cpp:S2753}.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nenum { COLOUR_0, COLOUR_1, COLOUR_2, COLOUR_COUNT } colour;\nif ( COLOUR_0 \u003d\u003d colour ) { ... }\nif ( ( COLOUR_0 + COLOUR_1 ) \u003d\u003d colour ) { ... } // Noncompliant, arithmetic used\nif ( colour \u0026lt; COLOUR_COUNT ) { ... }\nif ( colour \u0026gt; 3.14 ) { ... } // Noncompliant, comparison with float\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 4-5-2 - Expressions with type enum shall not be used as operands to builtin operators other than the subscript operator [ ],\n  the assignment operator \u003d, the equality operators \u003d\u003d and !\u003d, the unary \u0026amp; operator, and the relational operators \u0026lt;, \u0026lt;\u003d, \u0026gt;, \u0026gt;\u003d \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eEnumerations are used to represent symbolic values, or sometimes bit fields. They are not supposed to be used in arithmetic contexts.\u003c/p\u003e\n\u003cp\u003eAdditionally, even though comparing them with integer numbers can make sense (for instance, to test if an enum lies with a certain range),\ncomparing them with floating point numbers does not (and is deprecated since C++20).\u003c/p\u003e\n\u003cp\u003eThere are other restrictions related to the use of enums, see for instance {rule:cpp:S2753}.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nenum { COLOUR_0, COLOUR_1, COLOUR_2, COLOUR_COUNT } colour;\nif ( COLOUR_0 \u003d\u003d colour ) { ... }\nif ( ( COLOUR_0 + COLOUR_1 ) \u003d\u003d colour ) { ... } // Noncompliant, arithmetic used\nif ( colour \u0026lt; COLOUR_COUNT ) { ... }\nif ( colour \u0026gt; 3.14 ) { ... } // Noncompliant, comparison with float\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 4-5-2 - Expressions with type enum shall not be used as operands to builtin operators other than the subscript operator [ ],\n  the assignment operator \u003d, the equality operators \u003d\u003d and !\u003d, the unary \u0026amp; operator, and the relational operators \u0026lt;, \u0026lt;\u003d, \u0026gt;, \u0026gt;\u003d \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S994",
    "name": "A variable which is not modified shall be const qualified",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThis rule is a strict implementation of a MISRA (Motor Industry Software Reliability Association) rule. MISRA defines best practices for developing\nsafety-critical software. You can learn more about this rule in the MISRA documents referenced below.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++ 2008, 7-1-1 \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThis rule is a strict implementation of a MISRA (Motor Industry Software Reliability Association) rule. MISRA defines best practices for developing\nsafety-critical software. You can learn more about this rule in the MISRA documents referenced below.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C++ 2008, 7-1-1 \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "misra-c++2008"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:M23_045",
    "name": "All identifiers used in the controlling expression of \"#if\" or \"#elif\" preprocessing directives shall be defined prior to evaluation",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 19.1.3\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eAs well as using a \u003ccode\u003e#define\u003c/code\u003e preprocessor directive, macro names may effectively be defined in other \u003cem\u003eimplementation-defined\u003c/em\u003e,\nways. For example some implementations support:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Using a compiler command-line option, such as \u003ccode\u003e-D\u003c/code\u003e, to allow macros to be defined prior to translation; \u003c/li\u003e\n  \u003cli\u003e Pre-defined macros provided by the compiler. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eIf an attempt is made to use an identifier in a preprocessor directive, and that identifier has not been defined as a macro name, then the\npreprocessor will assume that it has a value of zero. This may not meet developer expectations.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cp\u003eThe following example assumes that the identifier \u003ccode\u003eM\u003c/code\u003e is not defined as a macro name.\u003c/p\u003e\n\u003cpre\u003e\n#if M \u003d\u003d 0        // Non-compliant\n#endif\n\n#if defined( N )  // Compliant - N is not evaluated, even if not a macro\n#if N \u003d\u003d 0        // Compliant - N is known to be defined at this point\n#endif\n#endif\n\n// Compliant - B is only evaluated in ( B \u003d\u003d 0 ) if it is defined\n#if defined( B ) \u0026amp;\u0026amp; ( B \u003d\u003d 0 )\n#endif\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003e{rule:cpp:S966} targets the same defect as this rule but for a non-mission-critical context.\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 19.1.3\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eAs well as using a \u003ccode\u003e#define\u003c/code\u003e preprocessor directive, macro names may effectively be defined in other \u003cem\u003eimplementation-defined\u003c/em\u003e,\nways. For example some implementations support:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Using a compiler command-line option, such as \u003ccode\u003e-D\u003c/code\u003e, to allow macros to be defined prior to translation; \u003c/li\u003e\n  \u003cli\u003e Pre-defined macros provided by the compiler. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eIf an attempt is made to use an identifier in a preprocessor directive, and that identifier has not been defined as a macro name, then the\npreprocessor will assume that it has a value of zero. This may not meet developer expectations.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cp\u003eThe following example assumes that the identifier \u003ccode\u003eM\u003c/code\u003e is not defined as a macro name.\u003c/p\u003e\n\u003cpre\u003e\n#if M \u003d\u003d 0        // Non-compliant\n#endif\n\n#if defined( N )  // Compliant - N is not evaluated, even if not a macro\n#if N \u003d\u003d 0        // Compliant - N is known to be defined at this point\n#endif\n#endif\n\n// Compliant - B is only evaluated in ( B \u003d\u003d 0 ) if it is defined\n#if defined( B ) \u0026amp;\u0026amp; ( B \u003d\u003d 0 )\n#endif\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003e{rule:cpp:S966} targets the same defect as this rule but for a non-mission-critical context.\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "confusing",
      "misra-c++2023",
      "misra-required"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:M23_287",
    "name": "The result of \"std::remove\", \"std::remove_if\", \"std::unique\" and \"empty\" shall be \"used\"",
    "defaultSeverity": "BLOCKER",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 28.6.4\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eFor the purposes of this rule, a cast to \u003ccode\u003evoid\u003c/code\u003e is not considered to be a \u003cem\u003euse\u003c/em\u003e [1].\u003c/p\u003e\n\u003cp\u003eThis rule applies to member and non-member forms of \u003ccode\u003eempty\u003c/code\u003e within the C++ Standard Library.\u003c/p\u003e\n\u003cp\u003eThis rule does not apply to the \u003ccode\u003estd::remove( const char * )\u003c/code\u003e overload defined in \u003ccode\u003e\u0026lt;cstdio\u0026gt;\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eThe mutating algorithms \u003ccode\u003estd::remove\u003c/code\u003e, \u003ccode\u003estd::remove_if\u003c/code\u003e and overloads of \u003ccode\u003estd::unique\u003c/code\u003e operate by swapping or\nmoving elements of the range they are operating over. On completion, they return an iterator to one past the last valid element. In the majority of\ncases, the correct behaviour is to use this result as the first operand in a call to \u003ccode\u003estd::erase\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eIgnoring the result of \u003ccode\u003eempty\u003c/code\u003e may indicate that a developer expects the call to purge the contents of the container, while it actually\nreports if it contains data.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nvoid f1()\n{\n  std::vector\u0026lt; int32_t \u0026gt; v1 \u003d { 0, 0, 1, 1, 2, 2, 3, 3 };\n  std::vector\u0026lt; int32_t \u0026gt; v2 \u003d v1;\n\n  std::unique( v1.begin(), v1.end() );           // Non-compliant\n\n  // v1 now holds { 0, 1, 2, 3, ?, ?, ?, ? }\n  // where ? represents an unknown value\n\n  v2.erase( std::unique( v2.begin(), v2.end() ),\n                         v2.end() );             // Compliant\n\n  // Contents of v2 is now { 0, 1, 2, 3 }\n}\n\nvoid f2( std::vector\u0026lt; int32_t \u0026gt; \u0026amp; v3 )\n{\n  empty( v3 );                                   // Non-compliant - result not used\n  v3.empty();                                    // Non-compliant - result not used\n\n  if ( !empty( v3 ) )                            // Compliant\n  {\n    v3.clear();                                  // Purges the vector\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eGlossary\u003c/h3\u003e\n\u003ch4\u003e[1] Use / used / using\u003c/h4\u003e\n\u003cp\u003eAn object is \u003cem\u003eused\u003c/em\u003e if:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e It is the subject of a cast; or \u003c/li\u003e\n  \u003cli\u003e It is explicitly initialized at declaration time; or \u003c/li\u003e\n  \u003cli\u003e It is an operand in an expression; or \u003c/li\u003e\n  \u003cli\u003e It is referenced. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eA function is \u003cem\u003eused\u003c/em\u003e as defined in {rule:cpp:M23_331}: MISRA C++ 2023 Rule\u0026nbsp;0.2.4.\u003c/p\u003e\n\u003cp\u003eA type is \u003cem\u003eused\u003c/em\u003e as defined in MISRA C++ 2023 Rule\u0026nbsp;0.2.3 (Types with \u003cem\u003elimited visibility\u003c/em\u003e should be \u003cem\u003eused\u003c/em\u003e at least\nonce).\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S5277} targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S6223} targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:M23_007}: MISRA C++ 2023 Rule\u0026nbsp;0.1.2 - The value returned by a function shall be \u003cem\u003eused\u003c/em\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 28.6.4\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eFor the purposes of this rule, a cast to \u003ccode\u003evoid\u003c/code\u003e is not considered to be a \u003cem\u003euse\u003c/em\u003e [1].\u003c/p\u003e\n\u003cp\u003eThis rule applies to member and non-member forms of \u003ccode\u003eempty\u003c/code\u003e within the C++ Standard Library.\u003c/p\u003e\n\u003cp\u003eThis rule does not apply to the \u003ccode\u003estd::remove( const char * )\u003c/code\u003e overload defined in \u003ccode\u003e\u0026lt;cstdio\u0026gt;\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eThe mutating algorithms \u003ccode\u003estd::remove\u003c/code\u003e, \u003ccode\u003estd::remove_if\u003c/code\u003e and overloads of \u003ccode\u003estd::unique\u003c/code\u003e operate by swapping or\nmoving elements of the range they are operating over. On completion, they return an iterator to one past the last valid element. In the majority of\ncases, the correct behaviour is to use this result as the first operand in a call to \u003ccode\u003estd::erase\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eIgnoring the result of \u003ccode\u003eempty\u003c/code\u003e may indicate that a developer expects the call to purge the contents of the container, while it actually\nreports if it contains data.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nvoid f1()\n{\n  std::vector\u0026lt; int32_t \u0026gt; v1 \u003d { 0, 0, 1, 1, 2, 2, 3, 3 };\n  std::vector\u0026lt; int32_t \u0026gt; v2 \u003d v1;\n\n  std::unique( v1.begin(), v1.end() );           // Non-compliant\n\n  // v1 now holds { 0, 1, 2, 3, ?, ?, ?, ? }\n  // where ? represents an unknown value\n\n  v2.erase( std::unique( v2.begin(), v2.end() ),\n                         v2.end() );             // Compliant\n\n  // Contents of v2 is now { 0, 1, 2, 3 }\n}\n\nvoid f2( std::vector\u0026lt; int32_t \u0026gt; \u0026amp; v3 )\n{\n  empty( v3 );                                   // Non-compliant - result not used\n  v3.empty();                                    // Non-compliant - result not used\n\n  if ( !empty( v3 ) )                            // Compliant\n  {\n    v3.clear();                                  // Purges the vector\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eGlossary\u003c/h3\u003e\n\u003ch4\u003e[1] Use / used / using\u003c/h4\u003e\n\u003cp\u003eAn object is \u003cem\u003eused\u003c/em\u003e if:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e It is the subject of a cast; or \u003c/li\u003e\n  \u003cli\u003e It is explicitly initialized at declaration time; or \u003c/li\u003e\n  \u003cli\u003e It is an operand in an expression; or \u003c/li\u003e\n  \u003cli\u003e It is referenced. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eA function is \u003cem\u003eused\u003c/em\u003e as defined in {rule:cpp:M23_331}: MISRA C++ 2023 Rule\u0026nbsp;0.2.4.\u003c/p\u003e\n\u003cp\u003eA type is \u003cem\u003eused\u003c/em\u003e as defined in MISRA C++ 2023 Rule\u0026nbsp;0.2.3 (Types with \u003cem\u003elimited visibility\u003c/em\u003e should be \u003cem\u003eused\u003c/em\u003e at least\nonce).\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S5277} targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S6223} targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:M23_007}: MISRA C++ 2023 Rule\u0026nbsp;0.1.2 - The value returned by a function shall be \u003cem\u003eused\u003c/em\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "misra-c++2023",
      "misra-required",
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:M23_046",
    "name": "A line whose first token is \"#\" shall be a valid preprocessing directive",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 19.0.1\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eThis rule applies to all the lines within a \u003cem\u003etranslation unit\u003c/em\u003e, even if they are excluded by preprocessing.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e white-space is permitted before and after the \u003ccode\u003e#\u003c/code\u003e token.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eA preprocessor directive may be used to conditionally exclude source code until a corresponding \u003ccode\u003e#else\u003c/code\u003e, \u003ccode\u003e#elif\u003c/code\u003e or\n\u003ccode\u003e#endif\u003c/code\u003e directive is encountered. A malformed or invalid preprocessing directive contained within the excluded source code may not be\ndetected by the compiler, possibly leading to the exclusion of more code than was intended.\u003c/p\u003e\n\u003cp\u003eRequiring all preprocessor directives to be syntactically valid, even when they occur within an excluded block of code, ensures that this cannot\nhappen.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cp\u003eIn the following example all the code between the \u003ccode\u003e#ifndef\u003c/code\u003e and \u003ccode\u003e#endif\u003c/code\u003e directives may be excluded if \u003ccode\u003eAAA\u003c/code\u003e is\ndefined. The developer intended that \u003ccode\u003eAAA\u003c/code\u003e be assigned to \u003ccode\u003ex\u003c/code\u003e, but the \u003ccode\u003e#else\u003c/code\u003e directive was entered incorrectly and\nnot diagnosed by the compiler.\u003c/p\u003e\n\u003cpre\u003e\n#define AAA 2\n\nint32_t foo()\n{\n  int32_t x \u003d 0;\n\n#ifndef AAA\n  x \u003d 1;\n#else1        // Non-compliant\n  x \u003d AAA;\n#endif\n\n  return x;\n}\n\u003c/pre\u003e\n\u003cp\u003eThis rule does not apply to the following examples as the \u003ccode\u003e#\u003c/code\u003e is not a preprocessing token:\u003c/p\u003e\n\u003cpre\u003e\n// Not a preprocessing token within a comment \\\n#not a token\n\nauto s \u003d R\"(\n#text)\";      // Use in a raw string literal is not a preprocessing token\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003e{rule:cpp:S977} targets the same defect as this rule but for a non-mission-critical context.\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 19.0.1\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eThis rule applies to all the lines within a \u003cem\u003etranslation unit\u003c/em\u003e, even if they are excluded by preprocessing.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e white-space is permitted before and after the \u003ccode\u003e#\u003c/code\u003e token.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eA preprocessor directive may be used to conditionally exclude source code until a corresponding \u003ccode\u003e#else\u003c/code\u003e, \u003ccode\u003e#elif\u003c/code\u003e or\n\u003ccode\u003e#endif\u003c/code\u003e directive is encountered. A malformed or invalid preprocessing directive contained within the excluded source code may not be\ndetected by the compiler, possibly leading to the exclusion of more code than was intended.\u003c/p\u003e\n\u003cp\u003eRequiring all preprocessor directives to be syntactically valid, even when they occur within an excluded block of code, ensures that this cannot\nhappen.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cp\u003eIn the following example all the code between the \u003ccode\u003e#ifndef\u003c/code\u003e and \u003ccode\u003e#endif\u003c/code\u003e directives may be excluded if \u003ccode\u003eAAA\u003c/code\u003e is\ndefined. The developer intended that \u003ccode\u003eAAA\u003c/code\u003e be assigned to \u003ccode\u003ex\u003c/code\u003e, but the \u003ccode\u003e#else\u003c/code\u003e directive was entered incorrectly and\nnot diagnosed by the compiler.\u003c/p\u003e\n\u003cpre\u003e\n#define AAA 2\n\nint32_t foo()\n{\n  int32_t x \u003d 0;\n\n#ifndef AAA\n  x \u003d 1;\n#else1        // Non-compliant\n  x \u003d AAA;\n#endif\n\n  return x;\n}\n\u003c/pre\u003e\n\u003cp\u003eThis rule does not apply to the following examples as the \u003ccode\u003e#\u003c/code\u003e is not a preprocessing token:\u003c/p\u003e\n\u003cpre\u003e\n// Not a preprocessing token within a comment \\\n#not a token\n\nauto s \u003d R\"(\n#text)\";      // Use in a raw string literal is not a preprocessing token\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003e{rule:cpp:S977} targets the same defect as this rule but for a non-mission-critical context.\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "misra-c++2023",
      "misra-required",
      "unpredictable"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5507",
    "name": "Pointers or references obtained from aliased smart pointers should not be used as function parameters",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eOne way to end up with a dangling pointer or a dangling reference is to pass to a function a pointer or a reference which lifecycle is not\ncontrolled. This is the case when the pointer or the reference is obtained from a smart pointer (\u003ccode\u003eshared_ptr\u003c/code\u003e or \u003ccode\u003eunique_ptr\u003c/code\u003e)\nwhich is not locally defined or which is potentially aliased.\u003c/p\u003e\n\u003cp\u003eIn this case, nothing can guarantee the developer that the pointer or the reference coming from this smart pointer will always be valid: for\nexample, this smart pointer could be reset somewhere in the call chain.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass Shape;\n\nstd::shared_ptr\u0026lt;Shape\u0026gt; globalShape;\n\nvoid g(Shape\u0026amp; s) {\n  globalShape.reset();\n  // do something with parameter s\n}\n\nvoid f1() {\n  g(*globalShape); // Noncompliant, lifecycle of the reference is not controlled, parameter s of function g will be a dangling reference\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nclass Shape;\n\nstd::shared_ptr\u0026lt;Shape\u0026gt; globalShape;\n\nvoid g(Shape\u0026amp; s) {\n  globalShape.reset();\n  // do something with parameter s\n}\n\nvoid f1() {\n  auto myShape \u003d globalShape; // reference count of the smart pointer is incremented, the pointer-to object is kept alive\n  g(*myShape );\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#r37-do-not-pass-a-pointer-or-reference-obtained-from-an-aliased-smart-pointer\"\u003eR.37: Do not pass a pointer or reference obtained from an aliased smart pointer\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eOne way to end up with a dangling pointer or a dangling reference is to pass to a function a pointer or a reference which lifecycle is not\ncontrolled. This is the case when the pointer or the reference is obtained from a smart pointer (\u003ccode\u003eshared_ptr\u003c/code\u003e or \u003ccode\u003eunique_ptr\u003c/code\u003e)\nwhich is not locally defined or which is potentially aliased.\u003c/p\u003e\n\u003cp\u003eIn this case, nothing can guarantee the developer that the pointer or the reference coming from this smart pointer will always be valid: for\nexample, this smart pointer could be reset somewhere in the call chain.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass Shape;\n\nstd::shared_ptr\u0026lt;Shape\u0026gt; globalShape;\n\nvoid g(Shape\u0026amp; s) {\n  globalShape.reset();\n  // do something with parameter s\n}\n\nvoid f1() {\n  g(*globalShape); // Noncompliant, lifecycle of the reference is not controlled, parameter s of function g will be a dangling reference\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nclass Shape;\n\nstd::shared_ptr\u0026lt;Shape\u0026gt; globalShape;\n\nvoid g(Shape\u0026amp; s) {\n  globalShape.reset();\n  // do something with parameter s\n}\n\nvoid f1() {\n  auto myShape \u003d globalShape; // reference count of the smart pointer is incremented, the pointer-to object is kept alive\n  g(*myShape );\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#r37-do-not-pass-a-pointer-or-reference-obtained-from-an-aliased-smart-pointer\"\u003eR.37: Do not pass a pointer or reference obtained from an aliased smart pointer\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cppcoreguidelines",
      "since-c++11",
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5506",
    "name": "\"try_lock\", \"lock\" and \"unlock\" should not be directly used for mutexes",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cem\u003eMutexes\u003c/em\u003e are synchronization primitives that allow managing concurrency using a mechanism of \u003ccode\u003elock\u003c/code\u003e/\u003ccode\u003eunlock\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eWhile explicitly locking or unlocking a \u003cem\u003emutex\u003c/em\u003e is possible, it is error-prone. This is particularly true in complex code paths (or with\nexceptions) where it is easy to have a mismatch between \u003ccode\u003elock\u003c/code\u003es and \u003ccode\u003eunlock\u003c/code\u003es.\u003c/p\u003e\n\u003cp\u003eAs a result, \u003cem\u003emutexes\u003c/em\u003e should not be locked or unlocked manually.\u003c/p\u003e\n\u003cp\u003eAdopting the C++ RAII (\u003cem\u003eResource Acquisition Is Initialization\u003c/em\u003e) idiom solves this problem by creating an object that will lock the\n\u003cem\u003emutex\u003c/em\u003e on creation and unlock it on destruction. Furthermore, using this idiom can also greatly improve the readability of the code.\u003c/p\u003e\n\u003cp\u003eSeveral classes are available as RAII wrappers:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003estd::scoped_lock\u003c/code\u003e is the default, most efficient wrapper for simple cases (only available since C++17) \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003estd::lock_guard\u003c/code\u003e is similar to \u003ccode\u003estd::scoped_lock\u003c/code\u003e, but with fewer features. It should only be used if you don’t have\n  access to \u003ccode\u003estd::scoped_lock\u003c/code\u003e. \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003estd::unique_lock\u003c/code\u003e allows more manual unlocking/locking again and should only be used when these features are needed, for instance,\n  with condition variables. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;mutex\u0026gt;\n\nclass DataItem;\n\nclass DataStore {\npublic:\n  bool store(const DataItem \u0026amp;dataItem);\n  bool has(const DataItem \u0026amp;dataItem);\n};\n\nDataStore sharedDataStore;\nstd::mutex sharedDataStoreMutex;\n\nbool storeIfRelevantInSharedContext(const DataItem \u0026amp;dataItem) {\n  sharedDataStoreMutex.lock(); // Noncompliant\n  if (sharedDataStore.has(dataItem)) {\n    sharedDataStoreMutex.unlock(); // Noncompliant\n    return false;\n  }\n  bool result \u003d sharedDataStore.store(dataItem);\n  sharedDataStoreMutex.unlock(); // Noncompliant\n  return result;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;mutex\u0026gt;\n\nclass DataItem;\n\nclass DataStore {\npublic:\n  bool store(const DataItem \u0026amp;dataItem);\n  bool has(const DataItem \u0026amp;dataItem);\n};\n\nDataStore sharedDataStore;\nstd::mutex sharedDataStoreMutex;\n\nbool storeIfRelevantInSharedContext(const DataItem \u0026amp;dataItem) {\n  std::scoped_lock\u0026lt;std::mutex\u0026gt; lock(sharedDataStoreMutex);\n  if (sharedDataStore.has(dataItem)) {\n    return false;\n  }\n  return sharedDataStore.store(dataItem);\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/raii\"\u003eRAII\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#cp20-use-raii-never-plain-lockunlock\"\u003eCP.20: Use RAII, never\n  plain \u003ccode\u003elock()\u003c/code\u003e/\u003ccode\u003eunlock()\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cem\u003eMutexes\u003c/em\u003e are synchronization primitives that allow managing concurrency using a mechanism of \u003ccode\u003elock\u003c/code\u003e/\u003ccode\u003eunlock\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eWhile explicitly locking or unlocking a \u003cem\u003emutex\u003c/em\u003e is possible, it is error-prone. This is particularly true in complex code paths (or with\nexceptions) where it is easy to have a mismatch between \u003ccode\u003elock\u003c/code\u003es and \u003ccode\u003eunlock\u003c/code\u003es.\u003c/p\u003e\n\u003cp\u003eAs a result, \u003cem\u003emutexes\u003c/em\u003e should not be locked or unlocked manually.\u003c/p\u003e\n\u003cp\u003eAdopting the C++ RAII (\u003cem\u003eResource Acquisition Is Initialization\u003c/em\u003e) idiom solves this problem by creating an object that will lock the\n\u003cem\u003emutex\u003c/em\u003e on creation and unlock it on destruction. Furthermore, using this idiom can also greatly improve the readability of the code.\u003c/p\u003e\n\u003cp\u003eSeveral classes are available as RAII wrappers:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003estd::scoped_lock\u003c/code\u003e is the default, most efficient wrapper for simple cases (only available since C++17) \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003estd::lock_guard\u003c/code\u003e is similar to \u003ccode\u003estd::scoped_lock\u003c/code\u003e, but with fewer features. It should only be used if you don’t have\n  access to \u003ccode\u003estd::scoped_lock\u003c/code\u003e. \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003estd::unique_lock\u003c/code\u003e allows more manual unlocking/locking again and should only be used when these features are needed, for instance,\n  with condition variables. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\n#include \u0026lt;mutex\u0026gt;\n\nclass DataItem;\n\nclass DataStore {\npublic:\n  bool store(const DataItem \u0026amp;dataItem);\n  bool has(const DataItem \u0026amp;dataItem);\n};\n\nDataStore sharedDataStore;\nstd::mutex sharedDataStoreMutex;\n\nbool storeIfRelevantInSharedContext(const DataItem \u0026amp;dataItem) {\n  sharedDataStoreMutex.lock(); // Noncompliant\n  if (sharedDataStore.has(dataItem)) {\n    sharedDataStoreMutex.unlock(); // Noncompliant\n    return false;\n  }\n  bool result \u003d sharedDataStore.store(dataItem);\n  sharedDataStoreMutex.unlock(); // Noncompliant\n  return result;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\n#include \u0026lt;mutex\u0026gt;\n\nclass DataItem;\n\nclass DataStore {\npublic:\n  bool store(const DataItem \u0026amp;dataItem);\n  bool has(const DataItem \u0026amp;dataItem);\n};\n\nDataStore sharedDataStore;\nstd::mutex sharedDataStoreMutex;\n\nbool storeIfRelevantInSharedContext(const DataItem \u0026amp;dataItem) {\n  std::scoped_lock\u0026lt;std::mutex\u0026gt; lock(sharedDataStoreMutex);\n  if (sharedDataStore.has(dataItem)) {\n    return false;\n  }\n  return sharedDataStore.store(dataItem);\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/raii\"\u003eRAII\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#cp20-use-raii-never-plain-lockunlock\"\u003eCP.20: Use RAII, never\n  plain \u003ccode\u003elock()\u003c/code\u003e/\u003ccode\u003eunlock()\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "bad-practice",
      "cppcoreguidelines",
      "pitfall",
      "since-c++11"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1141",
    "name": "Try-catch blocks should not be nested",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eNesting \u003ccode\u003etry\u003c/code\u003e/\u003ccode\u003ecatch\u003c/code\u003e or \u003ccode\u003e@try\u003c/code\u003e/\u003ccode\u003e@catch\u003c/code\u003e blocks severely impacts the readability of source code because\nit makes it too difficult to understand which block will catch which exception.\u003c/p\u003e\n\u003cp\u003eThis C++ example also applies to Objective-C.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\ntry {\n  try {                                     // Noncompliant\n    doSomething();\n  } catch (RuntimeException e) {\n    /* Ignore */\n  }\n\n  doSomethingElse();\n} catch (Exception e) {\n  /* ... */\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\ntry {\n  dedicatedMethod();                        // Compliant\n  doSomethingElse();\n} catch (Exception e) {\n  /* ... */\n}\n\n/* ... */\n\nprivate void dedicatedMethod() {\n  try {                                     // Compliant\n    doSomething();\n  } catch (RuntimeException e) {\n    /* Ignore */\n  }\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eNesting \u003ccode\u003etry\u003c/code\u003e/\u003ccode\u003ecatch\u003c/code\u003e or \u003ccode\u003e@try\u003c/code\u003e/\u003ccode\u003e@catch\u003c/code\u003e blocks severely impacts the readability of source code because\nit makes it too difficult to understand which block will catch which exception.\u003c/p\u003e\n\u003cp\u003eThis C++ example also applies to Objective-C.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\ntry {\n  try {                                     // Noncompliant\n    doSomething();\n  } catch (RuntimeException e) {\n    /* Ignore */\n  }\n\n  doSomethingElse();\n} catch (Exception e) {\n  /* ... */\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\ntry {\n  dedicatedMethod();                        // Compliant\n  doSomethingElse();\n} catch (Exception e) {\n  /* ... */\n}\n\n/* ... */\n\nprivate void dedicatedMethod() {\n  try {                                     // Compliant\n    doSomething();\n  } catch (RuntimeException e) {\n    /* Ignore */\n  }\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "confusing",
      "error-handling"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S3562",
    "name": "\"switch\" statements should cover all cases",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eFor completeness, a \u003ccode\u003eswitch\u003c/code\u003e over the values of an \u003ccode\u003eenum\u003c/code\u003e must either address each value in the \u003ccode\u003eenum\u003c/code\u003e or contain\na \u003ccode\u003edefault\u003c/code\u003e case. \u003ccode\u003eswitch\u003c/code\u003e statements that are not over \u003ccode\u003eenum\u003c/code\u003e must end with a \u003ccode\u003edefault\u003c/code\u003e case.\u003c/p\u003e\n\u003cp\u003eThis rule is a more nuanced version of {rule:cpp:S131}. Use {rule:cpp:S131} if you want to require a \u003ccode\u003edefault\u003c/code\u003e case for every\n\u003ccode\u003eswitch\u003c/code\u003e even if it already handles all enumerators of an \u003ccode\u003eenum\u003c/code\u003e. Otherwise, use this rule.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\ntypedef enum {APPLE, GRAPE, KIWI} fruit;\n\nvoid example(fruit f, int i) {\n  switch (f) {  // Noncompliant; no case for KIWI\n    case APPLE:\n      //...\n    case GRAPE:\n      //...\n    case 3: // Noncompliant; case value not in enum\n      // ...\n  }\n\n  switch (i) { // Noncompliant; no default\n    case 0:\n      // ...\n    case 1:\n      // ...\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\ntypedef enum {APPLE, GRAPE, KIWI} fruit;\n\nvoid example(fruit f) {\n  switch (f) {\n    case APPLE:\n      //...\n    case GRAPE:\n      //...\n    default:\n      // ...\n  }\n\n  switch (i) {\n    case 0:\n      // ...\n    case 1:\n      // ...\n    default:\n      // ...\n  }\n}\n\u003c/pre\u003e\n\u003cp\u003eor\u003c/p\u003e\n\u003cpre\u003e\ntypedef enum {APPLE, GRAPE, KIWI} fruit;\n\nvoid example(fruit f) {\n  switch (f) {\n    case APPLE:\n      //...\n    case GRAPE:\n      //...\n    case KIWI:\n      //...\n  }\n\n  switch (i) {\n    case 0:\n    case 1:\n      // ...\n    default:\n      // ...\n  }\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#enum2-use-enumerations-to-represent-sets-of-related-named-constants\"\u003eEnum.2: Use enumerations to represent sets of related named constants\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S131} \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eFor completeness, a \u003ccode\u003eswitch\u003c/code\u003e over the values of an \u003ccode\u003eenum\u003c/code\u003e must either address each value in the \u003ccode\u003eenum\u003c/code\u003e or contain\na \u003ccode\u003edefault\u003c/code\u003e case. \u003ccode\u003eswitch\u003c/code\u003e statements that are not over \u003ccode\u003eenum\u003c/code\u003e must end with a \u003ccode\u003edefault\u003c/code\u003e case.\u003c/p\u003e\n\u003cp\u003eThis rule is a more nuanced version of {rule:cpp:S131}. Use {rule:cpp:S131} if you want to require a \u003ccode\u003edefault\u003c/code\u003e case for every\n\u003ccode\u003eswitch\u003c/code\u003e even if it already handles all enumerators of an \u003ccode\u003eenum\u003c/code\u003e. Otherwise, use this rule.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\ntypedef enum {APPLE, GRAPE, KIWI} fruit;\n\nvoid example(fruit f, int i) {\n  switch (f) {  // Noncompliant; no case for KIWI\n    case APPLE:\n      //...\n    case GRAPE:\n      //...\n    case 3: // Noncompliant; case value not in enum\n      // ...\n  }\n\n  switch (i) { // Noncompliant; no default\n    case 0:\n      // ...\n    case 1:\n      // ...\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\ntypedef enum {APPLE, GRAPE, KIWI} fruit;\n\nvoid example(fruit f) {\n  switch (f) {\n    case APPLE:\n      //...\n    case GRAPE:\n      //...\n    default:\n      // ...\n  }\n\n  switch (i) {\n    case 0:\n      // ...\n    case 1:\n      // ...\n    default:\n      // ...\n  }\n}\n\u003c/pre\u003e\n\u003cp\u003eor\u003c/p\u003e\n\u003cpre\u003e\ntypedef enum {APPLE, GRAPE, KIWI} fruit;\n\nvoid example(fruit f) {\n  switch (f) {\n    case APPLE:\n      //...\n    case GRAPE:\n      //...\n    case KIWI:\n      //...\n  }\n\n  switch (i) {\n    case 0:\n    case 1:\n      // ...\n    default:\n      // ...\n  }\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#enum2-use-enumerations-to-represent-sets-of-related-named-constants\"\u003eEnum.2: Use enumerations to represent sets of related named constants\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S131} \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S881",
    "name": "Increment (++) and decrement (--) operators should not be used in a method call or mixed with other operators in an expression",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe use of increment and decrement operators in method calls or in combination with other arithmetic operators is not recommended, because:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e It can significantly impair the readability of the code. \u003c/li\u003e\n  \u003cli\u003e It introduces additional side effects into a statement, with the potential for undefined behavior. \u003c/li\u003e\n  \u003cli\u003e It is safer to use these operators in isolation from any other arithmetic operators. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nu8a \u003d ++u8b + u8c--;\nfoo \u003d bar++ / 4;\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cp\u003eThe following sequence is clearer and therefore safer:\u003c/p\u003e\n\u003cpre\u003e\n++u8b;\nu8a \u003d u8b + u8c;\nu8c--;\nfoo \u003d bar / 4;\nbar++;\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 12.1 - Limited dependence should be placed on the C operator precedence rules in expressions. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2004, 12.13 - The increment (++) and decrement (--) operators should not be mixed with other operators in an expression. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 5-2-10 - The increment (++) and decrement (--) operator should not be mixed with other operators in an expression. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 12.1 - The precedence of operators within expressions should be made explicit \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 13.3 - A full expression containing an increment (++) or decrement (--) operator should have no other potential side effects\n  other than that cause by the increment or decrement operator \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/StYxBQ\"\u003eCERT, EXP30-C.\u003c/a\u003e - Do not depend on the order of evaluation for side effects \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/IXw-BQ\"\u003eCERT, EXP50-CPP.\u003c/a\u003e - Do not depend on the order of evaluation for side effects \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe use of increment and decrement operators in method calls or in combination with other arithmetic operators is not recommended, because:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e It can significantly impair the readability of the code. \u003c/li\u003e\n  \u003cli\u003e It introduces additional side effects into a statement, with the potential for undefined behavior. \u003c/li\u003e\n  \u003cli\u003e It is safer to use these operators in isolation from any other arithmetic operators. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nu8a \u003d ++u8b + u8c--;\nfoo \u003d bar++ / 4;\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cp\u003eThe following sequence is clearer and therefore safer:\u003c/p\u003e\n\u003cpre\u003e\n++u8b;\nu8a \u003d u8b + u8c;\nu8c--;\nfoo \u003d bar / 4;\nbar++;\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 12.1 - Limited dependence should be placed on the C operator precedence rules in expressions. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2004, 12.13 - The increment (++) and decrement (--) operators should not be mixed with other operators in an expression. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 5-2-10 - The increment (++) and decrement (--) operator should not be mixed with other operators in an expression. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 12.1 - The precedence of operators within expressions should be made explicit \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 13.3 - A full expression containing an increment (++) or decrement (--) operator should have no other potential side effects\n  other than that cause by the increment or decrement operator \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/StYxBQ\"\u003eCERT, EXP30-C.\u003c/a\u003e - Do not depend on the order of evaluation for side effects \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/IXw-BQ\"\u003eCERT, EXP50-CPP.\u003c/a\u003e - Do not depend on the order of evaluation for side effects \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "cert"
    ],
    "deprecatedKeys": [
      "cpp:IncAndDecMixedWithOtherOperators"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1142",
    "name": "Functions should not contain too many return statements",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eHaving too many return statements in a function increases the function’s essential complexity because the flow of execution is broken each time a\nreturn statement is encountered. This makes it harder to read and understand the logic of the function.\u003c/p\u003e\n\u003cp\u003eThe way of counting the return statements is aligned with the way we compute \u003ca\nhref\u003d\"https://www.sonarsource.com/docs/CognitiveComplexity.pdf\"\u003e\u003cstrong\u003eCognitive Complexity\u003c/strong\u003e\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e\"Under Cyclomatic Complexity, a switch is treated as an analog to an if-else if chain […​] but from a maintainer’s point of view, a switch -\nwhich compares a single variable to an explicitly named set of literal values - is much easier to understand than an if-else if chain because the\nlatter may make any number of comparisons, using any number of variables and values. \"\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eAs a consequence, all the return statements located at the top level of case statements (including default) of a same switch statement count all\ntogether as 1.\u003c/p\u003e\n\u003cpre\u003e\n// this counts as 1 return\nint fun() {\n  switch(variable) {\n  case value1:\n    return 1;\n  case value2:\n    return 2;\n  default:\n    return 3;\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cp\u003eWith the default threshold of 3:\u003c/p\u003e\n\u003cpre\u003e\n// this counts as 3 returns\nint fun() {\n  if (condition1) {\n    return 1;\n  } else {\n    if (condition2) {\n      return 0;\n    } else {\n      return 1;\n    }\n  }\n  return 0;\n}\n\u003c/pre\u003e\n\u003cpre\u003e\n// this counts as 3 returns\nint fun() {\n  switch(variable) {\n  case value1:\n    if(condition1) {\n      return 1;\n    } else {\n      return -1;\n    }\n  default:\n    return 2;\n  }\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eHaving too many return statements in a function increases the function’s essential complexity because the flow of execution is broken each time a\nreturn statement is encountered. This makes it harder to read and understand the logic of the function.\u003c/p\u003e\n\u003cp\u003eThe way of counting the return statements is aligned with the way we compute \u003ca\nhref\u003d\"https://www.sonarsource.com/docs/CognitiveComplexity.pdf\"\u003e\u003cstrong\u003eCognitive Complexity\u003c/strong\u003e\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003e\"Under Cyclomatic Complexity, a switch is treated as an analog to an if-else if chain […​] but from a maintainer’s point of view, a switch -\nwhich compares a single variable to an explicitly named set of literal values - is much easier to understand than an if-else if chain because the\nlatter may make any number of comparisons, using any number of variables and values. \"\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eAs a consequence, all the return statements located at the top level of case statements (including default) of a same switch statement count all\ntogether as 1.\u003c/p\u003e\n\u003cpre\u003e\n// this counts as 1 return\nint fun() {\n  switch(variable) {\n  case value1:\n    return 1;\n  case value2:\n    return 2;\n  default:\n    return 3;\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cp\u003eWith the default threshold of 3:\u003c/p\u003e\n\u003cpre\u003e\n// this counts as 3 returns\nint fun() {\n  if (condition1) {\n    return 1;\n  } else {\n    if (condition2) {\n      return 0;\n    } else {\n      return 1;\n    }\n  }\n  return 0;\n}\n\u003c/pre\u003e\n\u003cpre\u003e\n// this counts as 3 returns\nint fun() {\n  switch(variable) {\n  case value1:\n    if(condition1) {\n      return 1;\n    } else {\n      return -1;\n    }\n  default:\n    return 2;\n  }\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {
      "max": {
        "key": "max",
        "name": "max",
        "description": "Maximum allowed return statements per function",
        "defaultValue": "3",
        "type": "INTEGER",
        "multiple": false,
        "possibleValues": []
      }
    },
    "defaultParams": {
      "max": "3"
    },
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "brain-overload"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5500",
    "name": "Functions having rvalue reference arguments should \"std::move\" those arguments",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eRvalue reference arguments allow to transfer ownership of objects.\u003c/p\u003e\n\u003cp\u003eWhen a function has an argument of type rvalue reference, it is expected to call \u003ccode\u003estd::move\u003c/code\u003e to take ownership of the corresponding\nparameter when it is called.\u003c/p\u003e\n\u003cp\u003eIf it does not do it or if it does it conditionally, ownership is unclear and this might lead to bugs.\u003c/p\u003e\n\u003cp\u003eThis rule does not apply when the argument is a forwarding reference.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nenum class Shape {\n  empty, circle, square\n};\n\nclass DrawingStore {\n  std::vector\u0026lt;Shape\u0026gt; store;\npublic:\n  void insertShape(Shape \u0026amp;\u0026amp;shape) {\n    store.emplace_back(shape); // Noncompliant, call to std::move is expected\n  }\n\n  void insertIfCircle(Shape \u0026amp;\u0026amp;shape) {\n      if (shape \u003d\u003d Shape::circle) {\n          store.emplace_back(std::move(shape)); // Noncompliant, std::move is not always called, ownership of shape is not clear\n      }\n  }\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nenum class Shape {\n  empty, circle, square\n};\n\nclass DrawingStoreOk {\n  std::vector\u0026lt;Shape\u0026gt; store;\npublic:\n  void insertShape(Shape \u0026amp;\u0026amp;shape) {\n    store.emplace_back(std::move(shape));\n  }\n\n  void insertIfCircle(const Shape \u0026amp;shape) {\n      if (shape \u003d\u003d Shape::circle) {\n          store.emplace_back(shape);\n      }\n  }\n};\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f18-for-will-move-from-parameters-pass-by-x-and-stdmove-the-parameter\"\u003eF.18: For \"will-move-from\" parameters, pass by \u003ccode\u003eX\u0026amp;\u0026amp;\u003c/code\u003e and \u003ccode\u003estd::move\u003c/code\u003e the parameter\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eRvalue reference arguments allow to transfer ownership of objects.\u003c/p\u003e\n\u003cp\u003eWhen a function has an argument of type rvalue reference, it is expected to call \u003ccode\u003estd::move\u003c/code\u003e to take ownership of the corresponding\nparameter when it is called.\u003c/p\u003e\n\u003cp\u003eIf it does not do it or if it does it conditionally, ownership is unclear and this might lead to bugs.\u003c/p\u003e\n\u003cp\u003eThis rule does not apply when the argument is a forwarding reference.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nenum class Shape {\n  empty, circle, square\n};\n\nclass DrawingStore {\n  std::vector\u0026lt;Shape\u0026gt; store;\npublic:\n  void insertShape(Shape \u0026amp;\u0026amp;shape) {\n    store.emplace_back(shape); // Noncompliant, call to std::move is expected\n  }\n\n  void insertIfCircle(Shape \u0026amp;\u0026amp;shape) {\n      if (shape \u003d\u003d Shape::circle) {\n          store.emplace_back(std::move(shape)); // Noncompliant, std::move is not always called, ownership of shape is not clear\n      }\n  }\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nenum class Shape {\n  empty, circle, square\n};\n\nclass DrawingStoreOk {\n  std::vector\u0026lt;Shape\u0026gt; store;\npublic:\n  void insertShape(Shape \u0026amp;\u0026amp;shape) {\n    store.emplace_back(std::move(shape));\n  }\n\n  void insertIfCircle(const Shape \u0026amp;shape) {\n      if (shape \u003d\u003d Shape::circle) {\n          store.emplace_back(shape);\n      }\n  }\n};\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#f18-for-will-move-from-parameters-pass-by-x-and-stdmove-the-parameter\"\u003eF.18: For \"will-move-from\" parameters, pass by \u003ccode\u003eX\u0026amp;\u0026amp;\u003c/code\u003e and \u003ccode\u003estd::move\u003c/code\u003e the parameter\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "bad-practice",
      "cppcoreguidelines",
      "pitfall",
      "since-c++11"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1264",
    "name": "A \"while\" loop should be used instead of a \"for\" loop",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhen only the condition expression is defined in a \u003ccode\u003efor\u003c/code\u003e loop, and the initialization and increment expressions are missing, a\n\u003ccode\u003ewhile\u003c/code\u003e loop should be used instead to increase readability.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nfor (;condition;) { /*...*/ }\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nwhile (condition) { /*...*/ }\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhen only the condition expression is defined in a \u003ccode\u003efor\u003c/code\u003e loop, and the initialization and increment expressions are missing, a\n\u003ccode\u003ewhile\u003c/code\u003e loop should be used instead to increase readability.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nfor (;condition;) { /*...*/ }\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nwhile (condition) { /*...*/ }\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "clumsy"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S3685",
    "name": "String literals should not be immediately followed by macros",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eC++ allows you to append a macro value onto the end of a string literal. Prior to C++11, it was possible to do this either with or without a space\nbetween the two. But with the introduction of user-defined literals in C++11, the preprocessing of string suffixes changed. To get the same string +\nmacro behavior under C++ 11, you must separate the string literal and the macro with a space. Without the space, you’ll get a compile error.\u003c/p\u003e\n\u003cp\u003eFor the purpose of preparing for migration to C++11, this rule raises an issue when there’s no space between a string literal and a macro.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#define _Hrs \" hours\"\nstatic const char* OPENING \u003d \"7\"_Hrs; // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#define _Hrs \" hours\"\nstatic const char* OPENING \u003d \"7\" _Hrs; // there\u0027s one space after \"7\"\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eC++ allows you to append a macro value onto the end of a string literal. Prior to C++11, it was possible to do this either with or without a space\nbetween the two. But with the introduction of user-defined literals in C++11, the preprocessing of string suffixes changed. To get the same string +\nmacro behavior under C++ 11, you must separate the string literal and the macro with a space. Without the space, you’ll get a compile error.\u003c/p\u003e\n\u003cp\u003eFor the purpose of preparing for migration to C++11, this rule raises an issue when there’s no space between a string literal and a macro.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#define _Hrs \" hours\"\nstatic const char* OPENING \u003d \"7\"_Hrs; // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#define _Hrs \" hours\"\nstatic const char* OPENING \u003d \"7\" _Hrs; // there\u0027s one space after \"7\"\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "lock-in"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5981",
    "name": "\"dynamic_cast\" should be used for downcasting",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eCasting a base-class pointer/reference to a\u0026nbsp;derived-class pointer/reference is commonly referred to as downcasting which can only be done\nusing an explicit cast.\u003c/p\u003e\n\u003cp\u003eHowever, the use of \u003ccode\u003estatic_cast\u003c/code\u003e for such a cast is unsafe because it doesn’t do any runtime check. \u0026nbsp;If the cast memory doesn’t\ncontain an object of the expected derived type,\u0026nbsp;your program enters the undefined behavior territory.\u003c/p\u003e\n\u003cp\u003eIf your object is polymorphic, you might prefer using \u003ccode\u003edynamic_cast\u003c/code\u003e instead, as it allows safe downcasting by performing a run-time\ncheck:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e If the cast memory contains an object of the expected derived type, the check succeeds. The result of the\n  \u003ccode\u003edynamic_cast\u003c/code\u003e\u0026nbsp;points/refers to the derived object.\u0026nbsp; \u003c/li\u003e\n  \u003cli\u003e If the cast memory doesn’t contain an object of the expected derived type, the check fails. If the\u0026nbsp;\u003ccode\u003edynamic_cast\u003c/code\u003e is used on a\n  pointer, \u003ccode\u003enullptr\u003c/code\u003e is returned.\u0026nbsp;If it was used on a reference, \u003ccode\u003estd::bad_cast\u003c/code\u003e\u0026nbsp;is thrown. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis rule raises an issue when \u003ccode\u003estatic_cast\u003c/code\u003e is used for downcasting.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstruct Shape {\n  virtual ~Shape();\n  // ...\n};\n\nstruct Rectangle : public Shape {\n  double width;\n  double height;\n};\n\nstruct Circle : public Shape {\n  double radius;\n};\n\ndouble computeArea(const Shape* shape) {\n  const auto* rectangle \u003d static_cast\u0026lt;const Rectangle*\u0026gt;(shape); // Noncompliant\n  return rectangle-\u0026gt;width * rectangle-\u0026gt;height;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstruct Shape {\n  virtual ~Shape();\n  // ...\n};\n\nstruct Rectangle : public Shape {\n  double width;\n  double height;\n};\n\nstruct Circle : public Shape {\n  int radius;\n};\n\ndouble computeArea(const Shape* shape) {\n  if(const auto* rectangle \u003d dynamic_cast\u0026lt;const Rectangle*\u0026gt;(shape)) { // Compliant\n    return rectangle-\u0026gt;width * rectangle-\u0026gt;height;\n  }\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#prosafety-type-safety-profile\"\u003eType.2: Don’t use\n  \u003ccode\u003estatic_cast\u003c/code\u003e to downcast\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eCasting a base-class pointer/reference to a\u0026nbsp;derived-class pointer/reference is commonly referred to as downcasting which can only be done\nusing an explicit cast.\u003c/p\u003e\n\u003cp\u003eHowever, the use of \u003ccode\u003estatic_cast\u003c/code\u003e for such a cast is unsafe because it doesn’t do any runtime check. \u0026nbsp;If the cast memory doesn’t\ncontain an object of the expected derived type,\u0026nbsp;your program enters the undefined behavior territory.\u003c/p\u003e\n\u003cp\u003eIf your object is polymorphic, you might prefer using \u003ccode\u003edynamic_cast\u003c/code\u003e instead, as it allows safe downcasting by performing a run-time\ncheck:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e If the cast memory contains an object of the expected derived type, the check succeeds. The result of the\n  \u003ccode\u003edynamic_cast\u003c/code\u003e\u0026nbsp;points/refers to the derived object.\u0026nbsp; \u003c/li\u003e\n  \u003cli\u003e If the cast memory doesn’t contain an object of the expected derived type, the check fails. If the\u0026nbsp;\u003ccode\u003edynamic_cast\u003c/code\u003e is used on a\n  pointer, \u003ccode\u003enullptr\u003c/code\u003e is returned.\u0026nbsp;If it was used on a reference, \u003ccode\u003estd::bad_cast\u003c/code\u003e\u0026nbsp;is thrown. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis rule raises an issue when \u003ccode\u003estatic_cast\u003c/code\u003e is used for downcasting.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstruct Shape {\n  virtual ~Shape();\n  // ...\n};\n\nstruct Rectangle : public Shape {\n  double width;\n  double height;\n};\n\nstruct Circle : public Shape {\n  double radius;\n};\n\ndouble computeArea(const Shape* shape) {\n  const auto* rectangle \u003d static_cast\u0026lt;const Rectangle*\u0026gt;(shape); // Noncompliant\n  return rectangle-\u0026gt;width * rectangle-\u0026gt;height;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstruct Shape {\n  virtual ~Shape();\n  // ...\n};\n\nstruct Rectangle : public Shape {\n  double width;\n  double height;\n};\n\nstruct Circle : public Shape {\n  int radius;\n};\n\ndouble computeArea(const Shape* shape) {\n  if(const auto* rectangle \u003d dynamic_cast\u0026lt;const Rectangle*\u0026gt;(shape)) { // Compliant\n    return rectangle-\u0026gt;width * rectangle-\u0026gt;height;\n  }\n  return 0;\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#prosafety-type-safety-profile\"\u003eType.2: Don’t use\n  \u003ccode\u003estatic_cast\u003c/code\u003e to downcast\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "cppcoreguidelines",
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1144",
    "name": "Unused functions and methods should be removed",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003cp\u003eThis rule raises an issue when a function is never referenced in the code.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eA function that is never called is dead code, and should be removed. Cleaning out dead code decreases the size of the maintained codebase, making\nit easier to understand the program and preventing bugs from being introduced.\u003c/p\u003e\n\u003cp\u003eThis rule detects functions that are never referenced from inside a translation unit, and cannot be referenced from the outside.\u003c/p\u003e\n\u003cpre\u003e\nstatic void unusedStaticFunction() { // Noncompliant\n}\n\nclass Server {\npublic:\n  void start() { // Compliant, the member function \"start()\" is public\n    log(\"start\");\n  }\nprivate:\n  void clear() { // Noncompliant, the member function \"clear()\" is unused\n  }\n  void log(const char * msg) { // Compliant, the member function \"log()\" is used in \"start() { ... }\"\n    printf(msg);\n  }\n};\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 0-1-10 - Every defined function shall be called at least once. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eThis rule raises an issue when a function is never referenced in the code.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eA function that is never called is dead code, and should be removed. Cleaning out dead code decreases the size of the maintained codebase, making\nit easier to understand the program and preventing bugs from being introduced.\u003c/p\u003e\n\u003cp\u003eThis rule detects functions that are never referenced from inside a translation unit, and cannot be referenced from the outside.\u003c/p\u003e\n\u003cpre\u003e\nstatic void unusedStaticFunction() { // Noncompliant\n}\n\nclass Server {\npublic:\n  void start() { // Compliant, the member function \"start()\" is public\n    log(\"start\");\n  }\nprivate:\n  void clear() { // Noncompliant, the member function \"clear()\" is unused\n  }\n  void log(const char * msg) { // Compliant, the member function \"log()\" is used in \"start() { ... }\"\n    printf(msg);\n  }\n};\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 0-1-10 - Every defined function shall be called at least once. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "unused"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1265",
    "name": "\"operator delete\" should be written along with \"operator new\"",
    "defaultSeverity": "CRITICAL",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003eoperator new\u003c/code\u003e allocates memory for objects, and the \u003ccode\u003eoperator delete\u003c/code\u003e frees the memory allocated by the matching\n\u003ccode\u003eoperator new\u003c/code\u003e. When a class needs to customize memory allocation, it can override the \u003ccode\u003eoperator new\u003c/code\u003e to use a custom memory\nallocation strategy and override the \u003ccode\u003eoperator delete\u003c/code\u003e accordingly.\u003c/p\u003e\n\u003cp\u003eIf the \u003ccode\u003eoperator delete\u003c/code\u003e is not overridden alongside the \u003ccode\u003eoperator new\u003c/code\u003e, the program will call its default implementation,\nwhich may not be suitable for the custom memory allocation strategy used by the overridden \u003ccode\u003eoperator new\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eFor instance, if the \u003ccode\u003eoperator new\u003c/code\u003e draws memory from a preallocated buffer instead of allocating memory, the \u003ccode\u003eoperator\ndelete\u003c/code\u003e should not call the \u003ccode\u003efree\u003c/code\u003e function to release the memory. Reciprocally, if the \u003ccode\u003eoperator new\u003c/code\u003e allocate memory\nwith \u003ccode\u003emalloc\u003c/code\u003e, the \u003ccode\u003eoperator delete\u003c/code\u003e must call \u003ccode\u003efree\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eOn the other hand, if the \u003ccode\u003eoperator delete\u003c/code\u003e is overridden without overriding the \u003ccode\u003eoperator new\u003c/code\u003e, it is suspicious because it\nmay not correctly release the memory allocated by the default \u003ccode\u003eoperator new\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eBy defining the \u003ccode\u003eoperator delete\u003c/code\u003e along with the \u003ccode\u003eoperator new\u003c/code\u003e, the memory is deallocated in a way consistent with the\ncustom allocation strategy used by the \u003ccode\u003eoperator new\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eOverriding only one of the two operators may result in your program consuming more and more memory over time, eventually leading to a crash.\u003c/p\u003e\n\u003cp\u003eDeallocating memory that was not allocated with the corresponding strategy results in undefined behavior.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eEach override of the \u003ccode\u003eoperator new\u003c/code\u003e should have a matching overridden \u003ccode\u003eoperator delete\u003c/code\u003e and vice versa.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003cp\u003eImagine a custom allocator \u003ccode\u003eMyAllocator\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\nclass MyAllocator {\npublic:\n    void* allocate(size_t size) {\n        void* p \u003d malloc(size);\n        if (!p) {\n            throw std::bad_alloc();\n        }\n        return p;\n    }\n\n    void deallocate(void* p) {\n        free(p);\n    }\n};\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nclass MyClass {\npublic:\n    // Noncompliant: there is no matching override of the delete operator\n    void* operator new(size_t size) {\n        return allocator.allocate(size);\n    }\n\nprivate:\n    static MyAllocator allocator;\n};\n\nvoid f() {\n    MyClass* obj \u003d new MyClass();\n    delete obj; // It will call the default implementation of the operator delete\n    // and this latter will not call the MyAllocator::deallocate function to correctly release the memory\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nclass MyClass {\npublic:\n    void* operator new(size_t size) {\n        return allocator.allocate(size);\n    }\n\n    void operator delete(void* p) {\n        allocator.deallocate(p);\n    }\n\nprivate:\n    static MyAllocator allocator;\n};\n\nvoid f() {\n    MyClass* obj \u003d new MyClass();\n    delete obj; // It will call MyClass::delete to correctly deallocate the memory\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/memory/new/operator_new\"\u003e\u003ccode\u003eoperator new\u003c/code\u003e, \u003ccode\u003eoperator new[]\u003c/code\u003e\u003c/a\u003e\n  \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/memory/new/operator_delete\"\u003e\u003ccode\u003eoperator delete\u003c/code\u003e, \u003ccode\u003eoperator\n  delete[]\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/KX0-BQ\"\u003eDCL54-CPP. Overload allocation and deallocation functions as a pair in the same\n  scope\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#r15-always-overload-matched-allocationdeallocation-pairs\"\u003eR.15:\n  Always overload matched allocation/deallocation pairs\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S1232} - Appropriate memory de-allocation should be used \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe \u003ccode\u003eoperator new\u003c/code\u003e allocates memory for objects, and the \u003ccode\u003eoperator delete\u003c/code\u003e frees the memory allocated by the matching\n\u003ccode\u003eoperator new\u003c/code\u003e. When a class needs to customize memory allocation, it can override the \u003ccode\u003eoperator new\u003c/code\u003e to use a custom memory\nallocation strategy and override the \u003ccode\u003eoperator delete\u003c/code\u003e accordingly.\u003c/p\u003e\n\u003cp\u003eIf the \u003ccode\u003eoperator delete\u003c/code\u003e is not overridden alongside the \u003ccode\u003eoperator new\u003c/code\u003e, the program will call its default implementation,\nwhich may not be suitable for the custom memory allocation strategy used by the overridden \u003ccode\u003eoperator new\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eFor instance, if the \u003ccode\u003eoperator new\u003c/code\u003e draws memory from a preallocated buffer instead of allocating memory, the \u003ccode\u003eoperator\ndelete\u003c/code\u003e should not call the \u003ccode\u003efree\u003c/code\u003e function to release the memory. Reciprocally, if the \u003ccode\u003eoperator new\u003c/code\u003e allocate memory\nwith \u003ccode\u003emalloc\u003c/code\u003e, the \u003ccode\u003eoperator delete\u003c/code\u003e must call \u003ccode\u003efree\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eOn the other hand, if the \u003ccode\u003eoperator delete\u003c/code\u003e is overridden without overriding the \u003ccode\u003eoperator new\u003c/code\u003e, it is suspicious because it\nmay not correctly release the memory allocated by the default \u003ccode\u003eoperator new\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eBy defining the \u003ccode\u003eoperator delete\u003c/code\u003e along with the \u003ccode\u003eoperator new\u003c/code\u003e, the memory is deallocated in a way consistent with the\ncustom allocation strategy used by the \u003ccode\u003eoperator new\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eOverriding only one of the two operators may result in your program consuming more and more memory over time, eventually leading to a crash.\u003c/p\u003e\n\u003cp\u003eDeallocating memory that was not allocated with the corresponding strategy results in undefined behavior.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eEach override of the \u003ccode\u003eoperator new\u003c/code\u003e should have a matching overridden \u003ccode\u003eoperator delete\u003c/code\u003e and vice versa.\u003c/p\u003e\n\n\u003cp\u003eImagine a custom allocator \u003ccode\u003eMyAllocator\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\nclass MyAllocator {\npublic:\n    void* allocate(size_t size) {\n        void* p \u003d malloc(size);\n        if (!p) {\n            throw std::bad_alloc();\n        }\n        return p;\n    }\n\n    void deallocate(void* p) {\n        free(p);\n    }\n};\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nclass MyClass {\npublic:\n    // Noncompliant: there is no matching override of the delete operator\n    void* operator new(size_t size) {\n        return allocator.allocate(size);\n    }\n\nprivate:\n    static MyAllocator allocator;\n};\n\nvoid f() {\n    MyClass* obj \u003d new MyClass();\n    delete obj; // It will call the default implementation of the operator delete\n    // and this latter will not call the MyAllocator::deallocate function to correctly release the memory\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nclass MyClass {\npublic:\n    void* operator new(size_t size) {\n        return allocator.allocate(size);\n    }\n\n    void operator delete(void* p) {\n        allocator.deallocate(p);\n    }\n\nprivate:\n    static MyAllocator allocator;\n};\n\nvoid f() {\n    MyClass* obj \u003d new MyClass();\n    delete obj; // It will call MyClass::delete to correctly deallocate the memory\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/memory/new/operator_new\"\u003e\u003ccode\u003eoperator new\u003c/code\u003e, \u003ccode\u003eoperator new[]\u003c/code\u003e\u003c/a\u003e\n  \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/memory/new/operator_delete\"\u003e\u003ccode\u003eoperator delete\u003c/code\u003e, \u003ccode\u003eoperator\n  delete[]\u003c/code\u003e\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eStandards\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e CERT - \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/KX0-BQ\"\u003eDCL54-CPP. Overload allocation and deallocation functions as a pair in the same\n  scope\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#r15-always-overload-matched-allocationdeallocation-pairs\"\u003eR.15:\n  Always overload matched allocation/deallocation pairs\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S1232} - Appropriate memory de-allocation should be used \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cert",
      "cppcoreguidelines"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5982",
    "name": "Changing working directories without verifying the success is security-sensitive",
    "defaultSeverity": "CRITICAL",
    "type": "SECURITY_HOTSPOT",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "SECURITY": "HIGH"
    },
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe purpose of changing the current working directory is to modify the base path when the process performs relative path resolutions. When the\nworking directory cannot be changed, the process keeps the directory previously defined as the active working directory. Thus, verifying the success\nof chdir() type of functions is important to prevent unintended relative paths and unauthorized access.\u003c/p\u003e"
      },
      {
        "key": "assess_the_problem",
        "htmlContent": "\u003ch2\u003eAsk Yourself Whether\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e The success of changing the working directory is relevant for the application. \u003c/li\u003e\n  \u003cli\u003e Changing the working directory is required by chroot to make the new root effective. \u003c/li\u003e\n  \u003cli\u003e Subsequent disk operations are using relative paths. \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere is a risk if you answered yes to any of those questions.\u003c/p\u003e\n\u003ch2\u003eSensitive Code Example\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003echdir\u003c/code\u003e operation could fail and the process still has access to unauthorized resources. The return code should be verified:\u003c/p\u003e\n\u003cpre\u003e\nconst char* any_dir \u003d \"/any/\";\nchdir(any_dir); // Sensitive: missing check of the return value\n\nint fd \u003d open(any_dir, O_RDONLY | O_DIRECTORY);\nfchdir(fd); // Sensitive: missing check of the return value\n\u003c/pre\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003ch2\u003eRecommended Secure Coding Practices\u003c/h2\u003e\n\u003cp\u003eAfter changing the current working directory verify the success of the operation and handle errors.\u003c/p\u003e\n\u003ch2\u003eCompliant Solution\u003c/h2\u003e\n\u003cp\u003eVerify the return code of \u003ccode\u003echdir\u003c/code\u003e and handle errors:\u003c/p\u003e\n\u003cpre\u003e\nconst char* root_dir \u003d \"/jail/\";\nif (chdir(root_dir) \u003d\u003d -1) {\n  exit(-1);\n} // Compliant\n\nint fd \u003d open(any_dir, O_RDONLY | O_DIRECTORY);\nif(fchdir(fd) \u003d\u003d -1) {\n  exit(-1);\n} // Compliant\n\u003c/pre\u003e\n\u003ch2\u003eSee\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/Top10/A01_2021-Broken_Access_Control/\"\u003eOWASP Top 10 2021 Category A1\u003c/a\u003e - Broken Access Control \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A5-Broken_Access_Control\"\u003eOWASP Top 10 2017 Category A5\u003c/a\u003e -\n  Broken Access Control \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/252\"\u003eMITRE, CWE-252\u003c/a\u003e - Unchecked Return Value \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://man7.org/linux/man-pages/man2/chdir.2.html\"\u003eman7.org\u003c/a\u003e - chdir \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cwe"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": [],
    "vulnerabilityProbability": "LOW"
  },
  {
    "key": "cpp:S3687",
    "name": "Atomic types should be used instead of \"volatile\" types",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe main intended use-case for \u003ccode\u003evolatile\u003c/code\u003e in C and C++ is to access data that can be modified by something external to the program,\ntypically some hardware register. In contrast with other languages that provide a \u003ccode\u003evolatile\u003c/code\u003e keyword, it does not provide any useful\nguarantees related to atomicity, memory ordering, or inter-thread synchronization. It is only really needed for the kind of low-level code found in\nkernels or embedded software, i.e. using memory-mapped I/O registers to manipulate hardware directly.\u003c/p\u003e\n\u003cp\u003eAccording to the C standard:\u003c/p\u003e\n\u003cblockquote\u003e\n  \u003cp\u003e\u003ccode\u003evolatile\u003c/code\u003e is a hint to the implementation to avoid aggressive optimization involving the object because the value of the object might\n  be changed by means undetectable by an implementation.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eOnly C11/C++11 \"atomic types\" are free from data races, and you should use them or synchronization primitives if you want to avoid race\nconditions.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when a local variable or class data member is declared as \u003ccode\u003evolatile\u003c/code\u003e (at the top level of the type, pointers\nto volatile are not reported).\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvolatile int counter; // Noncompliant\nUser * volatile vpUser; // Noncompliant; pointer is volatile\nUser volatile * pvUser;  // Compliant; User instance is volatile, not the pointer\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\natomic_int counter;\nstd::atomic\u0026lt;User*\u0026gt; vpUser;\nUser volatile * pvUser;\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/display/c/CON02-C.+Do+not+use+volatile+as+a+synchronization+primitive\"\u003eCERT CON02-C\u003c/a\u003e - Do not\n  use volatile as a synchronization primitive \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#cp200-use-volatile-only-to-talk-to-non-c-memory\"\u003eCP.200: Use\n  \u003ccode\u003evolatile\u003c/code\u003e only to talk to non-C++ memory\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe main intended use-case for \u003ccode\u003evolatile\u003c/code\u003e in C and C++ is to access data that can be modified by something external to the program,\ntypically some hardware register. In contrast with other languages that provide a \u003ccode\u003evolatile\u003c/code\u003e keyword, it does not provide any useful\nguarantees related to atomicity, memory ordering, or inter-thread synchronization. It is only really needed for the kind of low-level code found in\nkernels or embedded software, i.e. using memory-mapped I/O registers to manipulate hardware directly.\u003c/p\u003e\n\u003cp\u003eAccording to the C standard:\u003c/p\u003e\n\u003cblockquote\u003e\n  \u003cp\u003e\u003ccode\u003evolatile\u003c/code\u003e is a hint to the implementation to avoid aggressive optimization involving the object because the value of the object might\n  be changed by means undetectable by an implementation.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eOnly C11/C++11 \"atomic types\" are free from data races, and you should use them or synchronization primitives if you want to avoid race\nconditions.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when a local variable or class data member is declared as \u003ccode\u003evolatile\u003c/code\u003e (at the top level of the type, pointers\nto volatile are not reported).\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvolatile int counter; // Noncompliant\nUser * volatile vpUser; // Noncompliant; pointer is volatile\nUser volatile * pvUser;  // Compliant; User instance is volatile, not the pointer\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\natomic_int counter;\nstd::atomic\u0026lt;User*\u0026gt; vpUser;\nUser volatile * pvUser;\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/display/c/CON02-C.+Do+not+use+volatile+as+a+synchronization+primitive\"\u003eCERT CON02-C\u003c/a\u003e - Do not\n  use volatile as a synchronization primitive \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#cp200-use-volatile-only-to-talk-to-non-c-memory\"\u003eCP.200: Use\n  \u003ccode\u003evolatile\u003c/code\u003e only to talk to non-C++ memory\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "c11",
      "cert",
      "cppcoreguidelines",
      "multi-threading",
      "since-c++11"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S2234",
    "name": "Parameters should be passed in the correct order",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eWhen the names of parameters in a method call match the names of the method arguments, it contributes to clearer, more readable code. However, when\nthe names match, but are passed in a different order than the method arguments, it indicates a mistake in the parameter order which will likely lead\nto unexpected results.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint divide(int divisor, int dividend) {\n  return divisor / dividend;\n}\n\nvoid doTheThing() {\n  int divisor \u003d 15;\n  int dividend \u003d 5;\n\n  int result \u003d divide(dividend, divisor);  // Noncompliant; operation succeeds, but result is unexpected\n  //...\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint divide(int divisor, int dividend) {\n  return divisor / dividend;\n}\n\nvoid doTheThing() {\n  int divisor \u003d 15;\n  int dividend \u003d 5;\n\n  int result \u003d divide(divisor, dividend);\n  //...\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eWhen the names of parameters in a method call match the names of the method arguments, it contributes to clearer, more readable code. However, when\nthe names match, but are passed in a different order than the method arguments, it indicates a mistake in the parameter order which will likely lead\nto unexpected results.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint divide(int divisor, int dividend) {\n  return divisor / dividend;\n}\n\nvoid doTheThing() {\n  int divisor \u003d 15;\n  int dividend \u003d 5;\n\n  int result \u003d divide(dividend, divisor);  // Noncompliant; operation succeeds, but result is unexpected\n  //...\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint divide(int divisor, int dividend) {\n  return divisor / dividend;\n}\n\nvoid doTheThing() {\n  int divisor \u003d 15;\n  int dividend \u003d 5;\n\n  int result \u003d divide(divisor, dividend);\n  //...\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S2479",
    "name": "Control characters should not be used in literals",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eControl characters (e.g., tabs or carriage returns) are not visible to maintainers, so they should be escaped.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nconst char* foo \u003d \"A\tB\";  // Noncompliant: contains a tabulation\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nconst char* foo \u003d \"A\\tB\";  // Compliant: use escaped value\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThis rule does not raise issues in raw string literals since they have no escape character mechanism.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e Wikipedia - \u003ca href\u003d\"https://en.wikipedia.org/wiki/Control_character\"\u003eControl character\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eControl characters (e.g., tabs or carriage returns) are not visible to maintainers, so they should be escaped.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nconst char* foo \u003d \"A\tB\";  // Noncompliant: contains a tabulation\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nconst char* foo \u003d \"A\\tB\";  // Compliant: use escaped value\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eThis rule does not raise issues in raw string literals since they have no escape character mechanism.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e Wikipedia - \u003ca href\u003d\"https://en.wikipedia.org/wiki/Control_character\"\u003eControl character\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S3689",
    "name": "Declaration specifiers should not be redundant",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eRedundant declaration specifiers should be removed or corrected. Typically, they represent bugs. A specifier modifies the type or pointer to its\nleft. Only when it is at the far left does it apply to the right.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nconst int const * v1a; // Noncompliant; both const specifiers apply to int\nconst int const * v1b; // Noncompliant\nstatic static int v2;  // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nconst int *       v1a;  // pointer to a const int. same meaning as before but less confusing\nint const * const v1b;  // const pointer to a const int\nstatic int         v2;\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eRedundant declaration specifiers should be removed or corrected. Typically, they represent bugs. A specifier modifies the type or pointer to its\nleft. Only when it is at the far left does it apply to the right.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nconst int const * v1a; // Noncompliant; both const specifiers apply to int\nconst int const * v1b; // Noncompliant\nstatic static int v2;  // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nconst int *       v1a;  // pointer to a const int. same meaning as before but less confusing\nint const * const v1b;  // const pointer to a const int\nstatic int         v2;\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "redundant"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5501",
    "name": "\"#pragma pack\" should be used correctly",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003e#pragma pack\u003c/code\u003e is a non-standard extension that specifies the packing alignment for structure, union, and class members.\u003c/p\u003e\n\u003cp\u003eIt is useful to\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e remove padding and decrease the size of objects \u003c/li\u003e\n  \u003cli\u003e align members to better fit optimal cpu alignment \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eHowever, the pragma pack directives need to be correctly defined to work properly.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue if:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e the specified packing value is incorrect: it can only be 1, 2, 4, 8, or 16 \u003c/li\u003e\n  \u003cli\u003e a parameter is ill-formed \u003c/li\u003e\n  \u003cli\u003e the \u003ccode\u003epop\u003c/code\u003e variant of this \u003ccode\u003e#pragma\u003c/code\u003e is called with both arguments \u003ccode\u003eidentifier\u003c/code\u003e and \u003ccode\u003evalue\u003c/code\u003e: such a\n  call is undefined behavior \u003c/li\u003e\n  \u003cli\u003e a \u003ccode\u003e#pragma pack(push...)\u003c/code\u003e is performed but there is not corresponding use of \u003ccode\u003e#pragma pack(pop...)\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e a \u003ccode\u003e#pragma pack(pop...)\u003c/code\u003e is performed but there is not corresponding use of \u003ccode\u003e#pragma pack(push...)\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e a \u003ccode\u003e#pragma pack\u003c/code\u003e is in effect across several files: this becomes too complex and could easily lead to undefined behavior, the same\n  structure having a different layout when seen from different translation units \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#pragma pack(5) // Noncompliant, value is invalid\n#pragma pack(2+2) // Noncompliant, value should be a literal\n\n#pragma pack(4)\n#include \"myFile.h\" // Noncompliant, the specified alignment value will be applied to this file\n\nstruct T {\n   int i;\n   short j;\n   double k;\n};\n\n#pragma pack(push, r1, 16)\n#pragma pack(pop, r1, 4)  // Noncompliant, call to pop with two arguments is undefined\n\n#pragma pack(push, r2, 16) // Noncompliant, call to push with no matching pop\n#pragma pack(pop, r3)  // Noncompliant, call to pop with no matching push\n\n#pragma pack(push, 8) // Noncompliant, unmatched push\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#include \"myFile.h\"\n\n#pragma pack(4)\n\nstruct T {\n   int i;\n   short j;\n   double k;\n};\n\n#pragma pack(push, r1, 16)\n#pragma pack(pop, r1)\n\n#pragma pack(push, r2, 16)\n#pragma pack(pop, r2)\n\n#pragma pack(push, 8)\n#pragma pack(pop)\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003ccode\u003e#pragma pack\u003c/code\u003e is a non-standard extension that specifies the packing alignment for structure, union, and class members.\u003c/p\u003e\n\u003cp\u003eIt is useful to\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e remove padding and decrease the size of objects \u003c/li\u003e\n  \u003cli\u003e align members to better fit optimal cpu alignment \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eHowever, the pragma pack directives need to be correctly defined to work properly.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue if:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e the specified packing value is incorrect: it can only be 1, 2, 4, 8, or 16 \u003c/li\u003e\n  \u003cli\u003e a parameter is ill-formed \u003c/li\u003e\n  \u003cli\u003e the \u003ccode\u003epop\u003c/code\u003e variant of this \u003ccode\u003e#pragma\u003c/code\u003e is called with both arguments \u003ccode\u003eidentifier\u003c/code\u003e and \u003ccode\u003evalue\u003c/code\u003e: such a\n  call is undefined behavior \u003c/li\u003e\n  \u003cli\u003e a \u003ccode\u003e#pragma pack(push...)\u003c/code\u003e is performed but there is not corresponding use of \u003ccode\u003e#pragma pack(pop...)\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e a \u003ccode\u003e#pragma pack(pop...)\u003c/code\u003e is performed but there is not corresponding use of \u003ccode\u003e#pragma pack(push...)\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e a \u003ccode\u003e#pragma pack\u003c/code\u003e is in effect across several files: this becomes too complex and could easily lead to undefined behavior, the same\n  structure having a different layout when seen from different translation units \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#pragma pack(5) // Noncompliant, value is invalid\n#pragma pack(2+2) // Noncompliant, value should be a literal\n\n#pragma pack(4)\n#include \"myFile.h\" // Noncompliant, the specified alignment value will be applied to this file\n\nstruct T {\n   int i;\n   short j;\n   double k;\n};\n\n#pragma pack(push, r1, 16)\n#pragma pack(pop, r1, 4)  // Noncompliant, call to pop with two arguments is undefined\n\n#pragma pack(push, r2, 16) // Noncompliant, call to push with no matching pop\n#pragma pack(pop, r3)  // Noncompliant, call to pop with no matching push\n\n#pragma pack(push, 8) // Noncompliant, unmatched push\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#include \"myFile.h\"\n\n#pragma pack(4)\n\nstruct T {\n   int i;\n   short j;\n   double k;\n};\n\n#pragma pack(push, r1, 16)\n#pragma pack(pop, r1)\n\n#pragma pack(push, r2, 16)\n#pragma pack(pop, r2)\n\n#pragma pack(push, 8)\n#pragma pack(pop)\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5502",
    "name": "A single statement should not have more than one resource allocation",
    "defaultSeverity": "BLOCKER",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eIn a statement, the order of evaluation of sub-expressions (e.g., the arguments of a function call) is not totally specified. This means the\ncompiler can even interleave the evaluation of these sub-expressions, especially for optimization purposes.\u003c/p\u003e\n\u003cp\u003eIf you have several resource allocations in one statement, and the first succeeds while the second fails and throws an exception, the first\nallocated resource can leak. The classical mitigation for this issue is to use an RAII (\u003cem\u003eResource Acquisition Is Initialization\u003c/em\u003e) manager to\nwrap the raw resource. Yet, this solution may not be sufficient since the execution order is not specified.\u003c/p\u003e\n\u003cp\u003eIt is possible to write code that contains several allocations and still behaves correctly. C++17 made this even easier since the evaluation order\nrules are more strict. However, it requires expert-level knowledge of the language. It is simpler and more future-proof to simply avoid using several\nallocations in a single statement.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;memory\u0026gt;\n\nclass S {\npublic:\n  explicit S(int a, int b);\n};\n\nvoid g(std::shared_ptr\u0026lt;S\u0026gt; p1, std::shared_ptr\u0026lt;S\u0026gt; p2);\n\nvoid f() {\n  g(std::shared_ptr\u0026lt;S\u0026gt;(new S(1, 2)), std::shared_ptr\u0026lt;S\u0026gt;(new S(3, 4))); // Noncompliant: 2 resources are allocated in the same expression statement\n}\n\u003c/pre\u003e\n\u003cp\u003eIn this example, it would be valid for a pre-C++17 compiler to run the code in this order:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003enew S(1, 2) \u003d\u0026gt; p1\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003enew S(3, 4) \u003d\u0026gt; p2\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003estd::shared_ptr\u0026lt;S\u0026gt;(p1) \u003d\u0026gt; s1\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003estd::shared_ptr\u0026lt;S\u0026gt;(p2) \u003d\u0026gt; s2\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003eg(s1, s2)\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn that case, if the second allocation fails, the memory allocated for the first one will be leaked since the \u003ccode\u003eshared_ptr\u003c/code\u003e has not yet\nbeen able to claim ownership of the object.\u003c/p\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;memory\u0026gt;\n\nclass S {\npublic:\n  explicit S(int a, int b);\n};\n\nvoid g(std::shared_ptr\u0026lt;S\u0026gt; p1, std::shared_ptr\u0026lt;S\u0026gt; p2);\n\nvoid f() {\n  auto s \u003d std::shared_ptr\u0026lt;S\u0026gt;(new S(1, 2));\n  g(s, std::shared_ptr\u0026lt;S\u0026gt;(new S(3, 4))); // Compliant, only one resource allocation, even if a bit messy\n\n  // Or, a better alternative:\n\n  g(std::make_shared\u0026lt;S\u0026gt;(1, 2), std::make_shared\u0026lt;S\u0026gt;(3, 4)); // Compliant: no explicit allocation\n}\n\u003c/pre\u003e\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/eval_order\"\u003eOrder of evaluation\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/raii\"\u003eRAII\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#r13-perform-at-most-one-explicit-resource-allocation-in-a-single-expression-statement\"\u003eR.13: Perform at most one explicit resource allocation in a single expression statement\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eIn a statement, the order of evaluation of sub-expressions (e.g., the arguments of a function call) is not totally specified. This means the\ncompiler can even interleave the evaluation of these sub-expressions, especially for optimization purposes.\u003c/p\u003e\n\u003cp\u003eIf you have several resource allocations in one statement, and the first succeeds while the second fails and throws an exception, the first\nallocated resource can leak. The classical mitigation for this issue is to use an RAII (\u003cem\u003eResource Acquisition Is Initialization\u003c/em\u003e) manager to\nwrap the raw resource. Yet, this solution may not be sufficient since the execution order is not specified.\u003c/p\u003e\n\u003cp\u003eIt is possible to write code that contains several allocations and still behaves correctly. C++17 made this even easier since the evaluation order\nrules are more strict. However, it requires expert-level knowledge of the language. It is simpler and more future-proof to simply avoid using several\nallocations in a single statement.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;memory\u0026gt;\n\nclass S {\npublic:\n  explicit S(int a, int b);\n};\n\nvoid g(std::shared_ptr\u0026lt;S\u0026gt; p1, std::shared_ptr\u0026lt;S\u0026gt; p2);\n\nvoid f() {\n  g(std::shared_ptr\u0026lt;S\u0026gt;(new S(1, 2)), std::shared_ptr\u0026lt;S\u0026gt;(new S(3, 4))); // Noncompliant: 2 resources are allocated in the same expression statement\n}\n\u003c/pre\u003e\n\u003cp\u003eIn this example, it would be valid for a pre-C++17 compiler to run the code in this order:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003enew S(1, 2) \u003d\u0026gt; p1\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003enew S(3, 4) \u003d\u0026gt; p2\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003estd::shared_ptr\u0026lt;S\u0026gt;(p1) \u003d\u0026gt; s1\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003estd::shared_ptr\u0026lt;S\u0026gt;(p2) \u003d\u0026gt; s2\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003eg(s1, s2)\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn that case, if the second allocation fails, the memory allocated for the first one will be leaked since the \u003ccode\u003eshared_ptr\u003c/code\u003e has not yet\nbeen able to claim ownership of the object.\u003c/p\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;memory\u0026gt;\n\nclass S {\npublic:\n  explicit S(int a, int b);\n};\n\nvoid g(std::shared_ptr\u0026lt;S\u0026gt; p1, std::shared_ptr\u0026lt;S\u0026gt; p2);\n\nvoid f() {\n  auto s \u003d std::shared_ptr\u0026lt;S\u0026gt;(new S(1, 2));\n  g(s, std::shared_ptr\u0026lt;S\u0026gt;(new S(3, 4))); // Compliant, only one resource allocation, even if a bit messy\n\n  // Or, a better alternative:\n\n  g(std::make_shared\u0026lt;S\u0026gt;(1, 2), std::make_shared\u0026lt;S\u0026gt;(3, 4)); // Compliant: no explicit allocation\n}\n\u003c/pre\u003e\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/eval_order\"\u003eOrder of evaluation\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/raii\"\u003eRAII\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#r13-perform-at-most-one-explicit-resource-allocation-in-a-single-expression-statement\"\u003eR.13: Perform at most one explicit resource allocation in a single expression statement\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "bad-practice",
      "cppcoreguidelines",
      "pitfall",
      "unpredictable"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S867",
    "name": "Boolean operations should not have numeric operands, and vice versa",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThere are several constructs in the language that work with boolean:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e If statements: \u003ccode\u003eif (b) ...\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e Conditional operator: \u003ccode\u003eint i \u003d b ? 0 : 42;\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e Logical operators: \u003ccode\u003e(b1 || b2) \u0026amp;\u0026amp; !b3\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThose operations would also work with arithmetic or enum values operands, because there is a conversion from those types to bool. However, this\nconversion might not always be obvious, for instance, an integer return code might use the value \u003ccode\u003e0\u003c/code\u003e to indicate that everything worked as\nexpected, but converted to boolean, this value would be \u003ccode\u003efalse\u003c/code\u003e, which often denotes failure. Conversion from integer to bool should be\nexplicit.\u003c/p\u003e\n\u003cp\u003eMoreover, a logical operation with integer types might also be a confusion with the bitwise operators (\u003ccode\u003e\u0026amp;\u003c/code\u003e, \u003ccode\u003e|\u003c/code\u003e and\n\u003ccode\u003e~\u003c/code\u003e).\u003c/p\u003e\n\u003cp\u003eConverting a pointer to \u003ccode\u003ebool\u003c/code\u003e to check if it is null is idiomatic and is allowed by this rule. We also allow the use of any\nuser-defined type convertible to bool (for instance \u003ccode\u003estd::ostream\u003c/code\u003e), since they were specifically designed to be used in such situations.\nWhat this rule really detects is the use or arithmetic types (\u003ccode\u003eint\u003c/code\u003e, \u003ccode\u003elong\u003c/code\u003e…​) and of enum types.\u003c/p\u003e\n\u003cp\u003eOn the other hand, arithmetic operations are defined with booleans, but usually make little sense (think of adding two booleans). Booleans should\nnot be used in an arithmetic context.\u003c/p\u003e\n\u003cp\u003eFinally, comparing a boolean with the literals \u003ccode\u003etrue\u003c/code\u003e or \u003ccode\u003efalse\u003c/code\u003e is unnecessarily verbose, and should be avoided.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nif ( 1 \u0026amp;\u0026amp; ( c \u0026lt; d ) ) // Noncompliant\nif ( ( a \u0026lt; b ) \u0026amp;\u0026amp; ( c + d ) ) // Noncompliant\nif ( u8_a \u0026amp;\u0026amp; ( c + d ) ) // Noncompliant\nif ( !0 ) // Noncompliant, always true\nif ( !ptr ) // Compliant\nif ( ( a \u0026lt; b ) \u0026amp;\u0026amp; ( c \u0026lt; d ) ) // Compliant\nif ( !false ) // Compliant\nif (!!a) // Compliant by exception\nif ( ( a \u0026lt; b ) \u003d\u003d true) // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nif ( 1 !\u003d 0 \u0026amp;\u0026amp; ( c \u0026lt; d ) ) // Compliant, but left operand is always true\nif ( ( a \u0026lt; b ) \u0026amp;\u0026amp; ( c + d ) !\u003d 0 ) // Compliant\nif ( u8_a !\u003d 0 \u0026amp;\u0026amp; ( c + d ) !\u003d 0) // Compliant\nif ( 0 \u003d\u003d 0 ) // Compliant, always true\nif ( a \u0026lt; b )\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eSome people use \u003ccode\u003e!!\u003c/code\u003e as a shortcut to cast an integer to bool. This usage of the \u003ccode\u003e!\u003c/code\u003e operator with an integer argument is\nallowed for this rule.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 12.6 - The operands of logical operators (\u0026amp;\u0026amp;, || and !) should be effectively Boolean. Expressions that are effectively\n  Boolean should not be used as operands to operators other than (\u0026amp;\u0026amp;, || and !). \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 5-3-1 - Each operand of the ! operator, the logical \u0026amp;\u0026amp; or the logical || operators shall have type bool. \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/display/c/EXP13-C.+Treat+relational+and+equality+operators+as+if+they+were+nonassociative\"\u003eCERT,\n  EXP13-C.\u003c/a\u003e - Treat relational and equality operators as if they were nonassociative \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es87-dont-add-redundant—​or—​to-conditions\"\u003eES.87: Don’t add\n  redundant \u003ccode\u003e\u003d\u003d\u003c/code\u003e or \u003ccode\u003e!\u003d\u003c/code\u003e to conditions\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThere are several constructs in the language that work with boolean:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e If statements: \u003ccode\u003eif (b) ...\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e Conditional operator: \u003ccode\u003eint i \u003d b ? 0 : 42;\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e Logical operators: \u003ccode\u003e(b1 || b2) \u0026amp;\u0026amp; !b3\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThose operations would also work with arithmetic or enum values operands, because there is a conversion from those types to bool. However, this\nconversion might not always be obvious, for instance, an integer return code might use the value \u003ccode\u003e0\u003c/code\u003e to indicate that everything worked as\nexpected, but converted to boolean, this value would be \u003ccode\u003efalse\u003c/code\u003e, which often denotes failure. Conversion from integer to bool should be\nexplicit.\u003c/p\u003e\n\u003cp\u003eMoreover, a logical operation with integer types might also be a confusion with the bitwise operators (\u003ccode\u003e\u0026amp;\u003c/code\u003e, \u003ccode\u003e|\u003c/code\u003e and\n\u003ccode\u003e~\u003c/code\u003e).\u003c/p\u003e\n\u003cp\u003eConverting a pointer to \u003ccode\u003ebool\u003c/code\u003e to check if it is null is idiomatic and is allowed by this rule. We also allow the use of any\nuser-defined type convertible to bool (for instance \u003ccode\u003estd::ostream\u003c/code\u003e), since they were specifically designed to be used in such situations.\nWhat this rule really detects is the use or arithmetic types (\u003ccode\u003eint\u003c/code\u003e, \u003ccode\u003elong\u003c/code\u003e…​) and of enum types.\u003c/p\u003e\n\u003cp\u003eOn the other hand, arithmetic operations are defined with booleans, but usually make little sense (think of adding two booleans). Booleans should\nnot be used in an arithmetic context.\u003c/p\u003e\n\u003cp\u003eFinally, comparing a boolean with the literals \u003ccode\u003etrue\u003c/code\u003e or \u003ccode\u003efalse\u003c/code\u003e is unnecessarily verbose, and should be avoided.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nif ( 1 \u0026amp;\u0026amp; ( c \u0026lt; d ) ) // Noncompliant\nif ( ( a \u0026lt; b ) \u0026amp;\u0026amp; ( c + d ) ) // Noncompliant\nif ( u8_a \u0026amp;\u0026amp; ( c + d ) ) // Noncompliant\nif ( !0 ) // Noncompliant, always true\nif ( !ptr ) // Compliant\nif ( ( a \u0026lt; b ) \u0026amp;\u0026amp; ( c \u0026lt; d ) ) // Compliant\nif ( !false ) // Compliant\nif (!!a) // Compliant by exception\nif ( ( a \u0026lt; b ) \u003d\u003d true) // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nif ( 1 !\u003d 0 \u0026amp;\u0026amp; ( c \u0026lt; d ) ) // Compliant, but left operand is always true\nif ( ( a \u0026lt; b ) \u0026amp;\u0026amp; ( c + d ) !\u003d 0 ) // Compliant\nif ( u8_a !\u003d 0 \u0026amp;\u0026amp; ( c + d ) !\u003d 0) // Compliant\nif ( 0 \u003d\u003d 0 ) // Compliant, always true\nif ( a \u0026lt; b )\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eSome people use \u003ccode\u003e!!\u003c/code\u003e as a shortcut to cast an integer to bool. This usage of the \u003ccode\u003e!\u003c/code\u003e operator with an integer argument is\nallowed for this rule.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 12.6 - The operands of logical operators (\u0026amp;\u0026amp;, || and !) should be effectively Boolean. Expressions that are effectively\n  Boolean should not be used as operands to operators other than (\u0026amp;\u0026amp;, || and !). \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 5-3-1 - Each operand of the ! operator, the logical \u0026amp;\u0026amp; or the logical || operators shall have type bool. \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/display/c/EXP13-C.+Treat+relational+and+equality+operators+as+if+they+were+nonassociative\"\u003eCERT,\n  EXP13-C.\u003c/a\u003e - Treat relational and equality operators as if they were nonassociative \u003c/li\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#es87-dont-add-redundant—​or—​to-conditions\"\u003eES.87: Don’t add\n  redundant \u003ccode\u003e\u003d\u003d\u003c/code\u003e or \u003ccode\u003e!\u003d\u003c/code\u003e to conditions\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "cert",
      "cppcoreguidelines"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S988",
    "name": "\"\u003cstdio.h\u003e\" should not be used in production code",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThis includes file and I/O functions \u003ccode\u003efgetpos\u003c/code\u003e, \u003ccode\u003efopen\u003c/code\u003e, \u003ccode\u003eftell\u003c/code\u003e, \u003ccode\u003egets\u003c/code\u003e, \u003ccode\u003eperror\u003c/code\u003e,\n\u003ccode\u003eremove\u003c/code\u003e, \u003ccode\u003erename\u003c/code\u003e and \u003ccode\u003eungetc\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eStreams and file I/O have a large number of unspecified, undefined and implementation-defined behaviors associated with them. It is assumed within\nMISRA C that they will not normally be needed in production code in embedded systems.\u003c/p\u003e\n\u003cp\u003eIf any of the features of \u003ccode\u003estdio.h\u003c/code\u003e need to be used in production code, then the issues associated with the features need to be\nunderstood.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;stdio.h\u0026gt; /* Noncompliant */\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 20.9 - The input/output library \u0026lt;stdio.h\u0026gt; shall not be used in production code. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 27-0-1 - The stream input/output library \u0026lt;cstdio\u0026gt; shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 21.6 - The Standard Library input/output functions shall not be used \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThis includes file and I/O functions \u003ccode\u003efgetpos\u003c/code\u003e, \u003ccode\u003efopen\u003c/code\u003e, \u003ccode\u003eftell\u003c/code\u003e, \u003ccode\u003egets\u003c/code\u003e, \u003ccode\u003eperror\u003c/code\u003e,\n\u003ccode\u003eremove\u003c/code\u003e, \u003ccode\u003erename\u003c/code\u003e and \u003ccode\u003eungetc\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eStreams and file I/O have a large number of unspecified, undefined and implementation-defined behaviors associated with them. It is assumed within\nMISRA C that they will not normally be needed in production code in embedded systems.\u003c/p\u003e\n\u003cp\u003eIf any of the features of \u003ccode\u003estdio.h\u003c/code\u003e need to be used in production code, then the issues associated with the features need to be\nunderstood.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;stdio.h\u0026gt; /* Noncompliant */\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 20.9 - The input/output library \u0026lt;stdio.h\u0026gt; shall not be used in production code. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 27-0-1 - The stream input/output library \u0026lt;cstdio\u0026gt; shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 21.6 - The Standard Library input/output functions shall not be used \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "lock-in"
    ],
    "deprecatedKeys": [
      "cpp:PPIncludeStdio"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S868",
    "name": "Operands of \"\u0026\u0026\" and \"||\" should be primary (C) or postfix (C++) expressions",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe effect of this rule is to require that operands are appropriately parenthesized. Parentheses are important in this situation both for\nreadability of code and for ensuring that the behavior is as the developer intended.\u003c/p\u003e\n\u003cp\u003eWhere an expression consists of either a sequence of only logical \u003ccode\u003e\u0026amp;\u0026amp;\u003c/code\u003e or a sequence of logical \u003ccode\u003e||\u003c/code\u003e, extra\nparentheses are not required.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nif (x \u003d\u003d 0 \u0026amp;\u0026amp; ishigh);                   // Noncompliant\nif (x || y || z);\nif (x || y \u0026amp;\u0026amp; z);                        // Noncompliant\nif (x \u0026amp;\u0026amp; !y);                            // Noncompliant\nif (is_odd(y) \u0026amp;\u0026amp; x);\nif ((x \u0026gt; c1) \u0026amp;\u0026amp; (y \u0026gt; c2) \u0026amp;\u0026amp; (z \u0026gt; c3));\nif ((x \u0026gt; c1) \u0026amp;\u0026amp; (y \u0026gt; c2) || (z \u0026gt; c3));   // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nif ((x \u003d\u003d 0) \u0026amp;\u0026amp; ishigh);\nif (x || y || z);\nif (x || (y \u0026amp;\u0026amp; z));\nif (x \u0026amp;\u0026amp; (!y));\nif (is_odd(y) \u0026amp;\u0026amp; x);\nif ((x \u0026gt; c1) \u0026amp;\u0026amp; (y \u0026gt; c2) \u0026amp;\u0026amp; (z \u0026gt; c3));\nif ((x \u0026gt; c1) \u0026amp;\u0026amp; ((y \u0026gt; c2) || (z \u0026gt; c3)));\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 12.5 - The operands of a logical \u0026amp;\u0026amp; or || shall be primary-expressions. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 5-2-1 - Each operand of a logical \u0026amp;\u0026amp; or || shall be a postfix-expression. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe effect of this rule is to require that operands are appropriately parenthesized. Parentheses are important in this situation both for\nreadability of code and for ensuring that the behavior is as the developer intended.\u003c/p\u003e\n\u003cp\u003eWhere an expression consists of either a sequence of only logical \u003ccode\u003e\u0026amp;\u0026amp;\u003c/code\u003e or a sequence of logical \u003ccode\u003e||\u003c/code\u003e, extra\nparentheses are not required.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nif (x \u003d\u003d 0 \u0026amp;\u0026amp; ishigh);                   // Noncompliant\nif (x || y || z);\nif (x || y \u0026amp;\u0026amp; z);                        // Noncompliant\nif (x \u0026amp;\u0026amp; !y);                            // Noncompliant\nif (is_odd(y) \u0026amp;\u0026amp; x);\nif ((x \u0026gt; c1) \u0026amp;\u0026amp; (y \u0026gt; c2) \u0026amp;\u0026amp; (z \u0026gt; c3));\nif ((x \u0026gt; c1) \u0026amp;\u0026amp; (y \u0026gt; c2) || (z \u0026gt; c3));   // Noncompliant\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nif ((x \u003d\u003d 0) \u0026amp;\u0026amp; ishigh);\nif (x || y || z);\nif (x || (y \u0026amp;\u0026amp; z));\nif (x \u0026amp;\u0026amp; (!y));\nif (is_odd(y) \u0026amp;\u0026amp; x);\nif ((x \u0026gt; c1) \u0026amp;\u0026amp; (y \u0026gt; c2) \u0026amp;\u0026amp; (z \u0026gt; c3));\nif ((x \u0026gt; c1) \u0026amp;\u0026amp; ((y \u0026gt; c2) || (z \u0026gt; c3)));\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 12.5 - The operands of a logical \u0026amp;\u0026amp; or || shall be primary-expressions. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 5-2-1 - Each operand of a logical \u0026amp;\u0026amp; or || shall be a postfix-expression. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "based-on-misra"
    ],
    "deprecatedKeys": [
      "cpp:LogicalExpressionOperands"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S989",
    "name": "\"atof\", \"atoi\" and \"atol\" from \u003cstdlib.h\u003e should not be used",
    "defaultSeverity": "CRITICAL",
    "type": "BUG",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003e\u0026lt;stdlib.h\u0026gt;\u003c/code\u003e\u0027s \u003ccode\u003eatof\u003c/code\u003e, \u003ccode\u003eatoi\u003c/code\u003e, and \u003ccode\u003eatol\u003c/code\u003e functions, which convert strings to numbers, have\nundefined behavior when the strings cannot be converted, and should therefore be avoided.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint converter (const char * numstr) {\n  return atoi(numstr); // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint converter (const char * numstr) {\n  return strtol(numstr, NULL, 10);\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 20.10 - The library functions atof, atoi and atol from library \u0026lt;stdlib.h\u0026gt; shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 18-0-2 - The library functions atof, atoi and atol from library \u0026lt;cstdlib\u0026gt; shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 21.7 - The atof, atoi, atol and atoll functions of \u0026lt;stdlib.h\u0026gt; shall not be used \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/C9cxBQ\"\u003eCERT, ERR34-C.\u003c/a\u003e - Detect errors when converting a string to a number \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003ccode\u003e\u0026lt;stdlib.h\u0026gt;\u003c/code\u003e\u0027s \u003ccode\u003eatof\u003c/code\u003e, \u003ccode\u003eatoi\u003c/code\u003e, and \u003ccode\u003eatol\u003c/code\u003e functions, which convert strings to numbers, have\nundefined behavior when the strings cannot be converted, and should therefore be avoided.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint converter (const char * numstr) {\n  return atoi(numstr); // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint converter (const char * numstr) {\n  return strtol(numstr, NULL, 10);\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 20.10 - The library functions atof, atoi and atol from library \u0026lt;stdlib.h\u0026gt; shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 18-0-2 - The library functions atof, atoi and atol from library \u0026lt;cstdlib\u0026gt; shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 21.7 - The atof, atoi, atol and atoll functions of \u0026lt;stdlib.h\u0026gt; shall not be used \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/C9cxBQ\"\u003eCERT, ERR34-C.\u003c/a\u003e - Detect errors when converting a string to a number \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "cert"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S986",
    "name": "\"offsetof\" macro should not be used",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eoffsetof\u003c/code\u003e can lead to undefined behavior when the argument types are incompatible or when bit fields are used. Therefore\n\u003ccode\u003eoffsetof\u003c/code\u003e should be avoided.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;stddef.h\u0026gt;\n\nstruct A\n{\n  int32_t i;\n};\n\nvoid f1 ( )\n{\n  offsetof ( A, i ); // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 20.6 - The macro offsetof, in library \u0026lt;stddef.h\u0026gt;, shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2008, 18-2-1 - The macro offsetof, in library \u0026lt;stddef.h\u0026gt;, shall not be used. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003ccode\u003eoffsetof\u003c/code\u003e can lead to undefined behavior when the argument types are incompatible or when bit fields are used. Therefore\n\u003ccode\u003eoffsetof\u003c/code\u003e should be avoided.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;stddef.h\u0026gt;\n\nstruct A\n{\n  int32_t i;\n};\n\nvoid f1 ( )\n{\n  offsetof ( A, i ); // Noncompliant\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 20.6 - The macro offsetof, in library \u0026lt;stddef.h\u0026gt;, shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2008, 18-2-1 - The macro offsetof, in library \u0026lt;stddef.h\u0026gt;, shall not be used. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "misra-c++2008",
      "misra-c2004",
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S987",
    "name": "\"\u003csignal.h\u003e\" should not be used",
    "defaultSeverity": "CRITICAL",
    "type": "BUG",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eSignal handling contains implementation-defined and undefined behavior.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;signal.h\u0026gt; /* Noncompliant */\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 20.8 - The signal handling facilities of \u0026lt;signal.h\u0026gt; shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 21.5 - The standard header file \u0026lt;signal.h\u0026gt; shall not be used \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eSignal handling contains implementation-defined and undefined behavior.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;signal.h\u0026gt; /* Noncompliant */\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 20.8 - The signal handling facilities of \u0026lt;signal.h\u0026gt; shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 21.5 - The standard header file \u0026lt;signal.h\u0026gt; shall not be used \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "lock-in"
    ],
    "deprecatedKeys": [
      "cpp:PPIncludeSignal"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S984",
    "name": "Dynamic heap memory allocation should not be used",
    "defaultSeverity": "CRITICAL",
    "type": "BUG",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe use of dynamic memory can lead to out-of-storage run-time failures, which are undesirable.\u003c/p\u003e\n\u003cp\u003eThe built-in \u003ccode\u003enew\u003c/code\u003e and \u003ccode\u003edelete\u003c/code\u003e operators, other than the placement versions, use dynamic heap memory. The functions\n\u003ccode\u003ecalloc\u003c/code\u003e, \u003ccode\u003emalloc\u003c/code\u003e, \u003ccode\u003erealloc\u003c/code\u003e and \u003ccode\u003efree\u003c/code\u003e also use dynamic heap memory.\u003c/p\u003e\n\u003cp\u003eThere is a range of unspecified, undefined and implementation-defined behaviour associated with dynamic memory allocation, as well as a number of\nother potential pitfalls. Dynamic heap memory allocation may lead to memory leaks, data inconsistency, memory exhaustion, non-deterministic behaviour,\netc.\u003c/p\u003e\n\u003cp\u003eNote that some implementations may use dynamic heap memory allocation to implement other functions (for example, functions in the library\n\u003ccode\u003ecstring\u003c/code\u003e). If this is the case, then these functions shall also be avoided.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint *b;\nvoid initialize()\n{\n  b \u003d (int*) malloc(1024 * sizeof(int)); // Noncompliant, could lead to an out-of-storage run-time failure.\n  if (b \u003d\u003d 0)\n  {\n    // handle case when dynamic allocation failed.\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint b[1024]; // Compliant solution.\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 20.4 - Dynamic heap memory allocation shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2008, 18-4-1 - Dynamic heap memory allocation shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 21.3 The memory allocation and deallocation functions of \u0026lt;stdlib.h\u0026gt; shall not be used \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe use of dynamic memory can lead to out-of-storage run-time failures, which are undesirable.\u003c/p\u003e\n\u003cp\u003eThe built-in \u003ccode\u003enew\u003c/code\u003e and \u003ccode\u003edelete\u003c/code\u003e operators, other than the placement versions, use dynamic heap memory. The functions\n\u003ccode\u003ecalloc\u003c/code\u003e, \u003ccode\u003emalloc\u003c/code\u003e, \u003ccode\u003erealloc\u003c/code\u003e and \u003ccode\u003efree\u003c/code\u003e also use dynamic heap memory.\u003c/p\u003e\n\u003cp\u003eThere is a range of unspecified, undefined and implementation-defined behaviour associated with dynamic memory allocation, as well as a number of\nother potential pitfalls. Dynamic heap memory allocation may lead to memory leaks, data inconsistency, memory exhaustion, non-deterministic behaviour,\netc.\u003c/p\u003e\n\u003cp\u003eNote that some implementations may use dynamic heap memory allocation to implement other functions (for example, functions in the library\n\u003ccode\u003ecstring\u003c/code\u003e). If this is the case, then these functions shall also be avoided.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nint *b;\nvoid initialize()\n{\n  b \u003d (int*) malloc(1024 * sizeof(int)); // Noncompliant, could lead to an out-of-storage run-time failure.\n  if (b \u003d\u003d 0)\n  {\n    // handle case when dynamic allocation failed.\n  }\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint b[1024]; // Compliant solution.\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 20.4 - Dynamic heap memory allocation shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C++ 2008, 18-4-1 - Dynamic heap memory allocation shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 21.3 The memory allocation and deallocation functions of \u0026lt;stdlib.h\u0026gt; shall not be used \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S864",
    "name": "Limited dependence should be placed on operator precedence",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe rules of operator precedence are complicated and can lead to errors. For this reason, parentheses should be used for clarification in complex\nstatements. However, this does not mean that parentheses should be gratuitously added around every operation.\u003c/p\u003e\n\u003cp\u003eParentheses are not needed:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e with a unary operator, except when \u003ccode\u003e!\u003c/code\u003e is used as left operand in comparison expressions \u003c/li\u003e\n  \u003cli\u003e when all the operators in an expression are the same \u003c/li\u003e\n  \u003cli\u003e when only a single operator is involved \u003c/li\u003e\n  \u003cli\u003e around the right-hand side of an assignment operator unless the right-hand side itself contains an assignment \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eParentheses are needed:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e in the condition of a ternary operator if it uses operators \u003c/li\u003e\n  \u003cli\u003e when overloaded shift operator \u003ccode\u003e\u0026lt;\u0026lt;\u003c/code\u003e or \u003ccode\u003e\u0026gt;\u0026gt;\u003c/code\u003e is used in an expression with comparison operators \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nx \u003d a + b;\nx \u003d a * -1;\nx \u003d a + b + c;\nx \u003d f ( a + b, c );\n\nx \u003d a \u003d\u003d b ? a : a - b; // Noncompliant\nx \u003d a + b - c + d; // Noncompliant\nx \u003d a * 3 + c + d; // Noncompliant\n\nif (a \u003d f(b,c) \u003d\u003d true) { ... } // Noncompliant; \u003d\u003d evaluated first\nx - b ? a : c; // Noncompliant; \"-\" evaluated first\ns \u0026lt;\u0026lt; 5 \u003d\u003d 1; // Noncompliant; \"\u0026lt;\u0026lt;\" evaluated first\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nx \u003d a + b;\nx \u003d a * -1;\nx \u003d a + b + c;\nx \u003d f ( a + b, c );\n\nx \u003d ( a \u003d\u003d b ) ? a : ( a - b );\nx \u003d ( a + b ) - ( c + d );\nx \u003d ( a * 3 ) + c + d;\n\nif ( (a \u003d f(b,c)) \u003d\u003d true) { ... }\n(x - b) ? a : c; // Compliant\n(s \u0026lt;\u0026lt; 5) \u003d\u003d 1; // Compliant\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 12.1 - Limited dependence should be placed on C’s operator precedence rules in expressions \u003c/li\u003e\n  \u003cli\u003e MISRA C:2004, 12.2 - The value of an expression shall be the same under any order of evaluation that the standard permits. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2004, 12.5 - The operands of a logical \u0026amp;\u0026amp; or || shall be primary-expressions. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 5-0-1 - The value of an expression shall be the same under any order of evaluation that the standard permits. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 5-0-2 - Limited dependence should be placed on C++ operator precedence rules in expressions \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 5-2-1 - Each operand of a logical \u0026amp;\u0026amp; or || shall be a postfix-expression. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 12.1 - The precedence of operators within expressions should be made explicit \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/YdYxBQ\"\u003eCERT, EXP00-C.\u003c/a\u003e - Use parentheses for precedence of operation \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/783\"\u003eMITRE, CWE-783\u003c/a\u003e - Operator Precedence Logic Error \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe rules of operator precedence are complicated and can lead to errors. For this reason, parentheses should be used for clarification in complex\nstatements. However, this does not mean that parentheses should be gratuitously added around every operation.\u003c/p\u003e\n\u003cp\u003eParentheses are not needed:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e with a unary operator, except when \u003ccode\u003e!\u003c/code\u003e is used as left operand in comparison expressions \u003c/li\u003e\n  \u003cli\u003e when all the operators in an expression are the same \u003c/li\u003e\n  \u003cli\u003e when only a single operator is involved \u003c/li\u003e\n  \u003cli\u003e around the right-hand side of an assignment operator unless the right-hand side itself contains an assignment \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eParentheses are needed:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e in the condition of a ternary operator if it uses operators \u003c/li\u003e\n  \u003cli\u003e when overloaded shift operator \u003ccode\u003e\u0026lt;\u0026lt;\u003c/code\u003e or \u003ccode\u003e\u0026gt;\u0026gt;\u003c/code\u003e is used in an expression with comparison operators \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nx \u003d a + b;\nx \u003d a * -1;\nx \u003d a + b + c;\nx \u003d f ( a + b, c );\n\nx \u003d a \u003d\u003d b ? a : a - b; // Noncompliant\nx \u003d a + b - c + d; // Noncompliant\nx \u003d a * 3 + c + d; // Noncompliant\n\nif (a \u003d f(b,c) \u003d\u003d true) { ... } // Noncompliant; \u003d\u003d evaluated first\nx - b ? a : c; // Noncompliant; \"-\" evaluated first\ns \u0026lt;\u0026lt; 5 \u003d\u003d 1; // Noncompliant; \"\u0026lt;\u0026lt;\" evaluated first\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nx \u003d a + b;\nx \u003d a * -1;\nx \u003d a + b + c;\nx \u003d f ( a + b, c );\n\nx \u003d ( a \u003d\u003d b ) ? a : ( a - b );\nx \u003d ( a + b ) - ( c + d );\nx \u003d ( a * 3 ) + c + d;\n\nif ( (a \u003d f(b,c)) \u003d\u003d true) { ... }\n(x - b) ? a : c; // Compliant\n(s \u0026lt;\u0026lt; 5) \u003d\u003d 1; // Compliant\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 12.1 - Limited dependence should be placed on C’s operator precedence rules in expressions \u003c/li\u003e\n  \u003cli\u003e MISRA C:2004, 12.2 - The value of an expression shall be the same under any order of evaluation that the standard permits. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2004, 12.5 - The operands of a logical \u0026amp;\u0026amp; or || shall be primary-expressions. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 5-0-1 - The value of an expression shall be the same under any order of evaluation that the standard permits. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 5-0-2 - Limited dependence should be placed on C++ operator precedence rules in expressions \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 5-2-1 - Each operand of a logical \u0026amp;\u0026amp; or || shall be a postfix-expression. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 12.1 - The precedence of operators within expressions should be made explicit \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/YdYxBQ\"\u003eCERT, EXP00-C.\u003c/a\u003e - Use parentheses for precedence of operation \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/783\"\u003eMITRE, CWE-783\u003c/a\u003e - Operator Precedence Logic Error \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "cert",
      "cwe"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S985",
    "name": "\"errno\" should not be used",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eerrno\u003c/code\u003e is a facility of C++ which should in theory be useful, but which in practice is poorly defined by ISO/IEC 14882:2003. A non-zero\nvalue may or may not indicate that a problem has occurred; therefore \u003ccode\u003eerrno\u003c/code\u003e shall not be used.\u003c/p\u003e\n\u003cp\u003eEven for those functions for which the behaviour of \u003ccode\u003eerrno\u003c/code\u003e is well defined, it is preferable to check the values of inputs before\ncalling the function rather than relying on using \u003ccode\u003eerrno\u003c/code\u003e to trap errors.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;cstdlib\u0026gt;\n#include \u0026lt;cerrno\u0026gt;\n\nvoid f1 (const char * str)\n{\n  errno \u003d 0; // Noncompliant\n  int i \u003d atoi(str);\n  if ( 0 !\u003d errno ) // Noncompliant\n  {\n    // handle error case???\n  }\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 20.5 - The error indicator errno shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 19-3-1 - The error indicator errno shall not be used. \u003c/li\u003e\n  \u003cli\u003e ISO/IEC 14882:2003 \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003ccode\u003eerrno\u003c/code\u003e is a facility of C++ which should in theory be useful, but which in practice is poorly defined by ISO/IEC 14882:2003. A non-zero\nvalue may or may not indicate that a problem has occurred; therefore \u003ccode\u003eerrno\u003c/code\u003e shall not be used.\u003c/p\u003e\n\u003cp\u003eEven for those functions for which the behaviour of \u003ccode\u003eerrno\u003c/code\u003e is well defined, it is preferable to check the values of inputs before\ncalling the function rather than relying on using \u003ccode\u003eerrno\u003c/code\u003e to trap errors.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;cstdlib\u0026gt;\n#include \u0026lt;cerrno\u0026gt;\n\nvoid f1 (const char * str)\n{\n  errno \u003d 0; // Noncompliant\n  int i \u003d atoi(str);\n  if ( 0 !\u003d errno ) // Noncompliant\n  {\n    // handle error case???\n  }\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 20.5 - The error indicator errno shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 19-3-1 - The error indicator errno shall not be used. \u003c/li\u003e\n  \u003cli\u003e ISO/IEC 14882:2003 \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S982",
    "name": "\"setjmp\" and \"longjmp\" should not be used",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003esetjmp.h\u003c/code\u003e functions allow the normal function mechanisms to be bypassed and should be used only with extreme caution, if at all.\u003c/p\u003e\n\u003cp\u003eCalling \u003ccode\u003esetjmp\u003c/code\u003e saves the program environment into the buffer passed into the call. Later calling \u003ccode\u003elongjmp\u003c/code\u003e returns\nexecution to the point at which \u003ccode\u003esetjmp\u003c/code\u003e was called and restores the context that was saved into the buffer. But the values of non-volatile\nlocal variables after \u003ccode\u003elongjmp\u003c/code\u003e are indeterminate. Additionally invoking \u003ccode\u003elongjmp\u003c/code\u003e from a nested signal handler is undefined, as\nis \u003ccode\u003elongjmp\u003c/code\u003eing back to a method that has already completed execution.\u003c/p\u003e\n\u003cp\u003eThis rule flags all instances of \u003ccode\u003esetjmp\u003c/code\u003e, \u003ccode\u003e_setjmp\u003c/code\u003e, \u003ccode\u003elongjmp\u003c/code\u003e, \u003ccode\u003e_longjmp\u003c/code\u003e, \u003ccode\u003esigsetjmp\u003c/code\u003e,\n\u003ccode\u003esiglongjmp\u003c/code\u003e and \u003ccode\u003e\u0026lt;setjmp.h\u0026gt;\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;setjmp.h\u0026gt;  // Noncompliant\n\njmp_buf buf;\n\nint main(int argc, char* argv[]) {\n  int i \u003d setjmp(buf);  // Noncompliant\n  if (i \u003d\u003d 0) { // value of i was assigned after env was saved \u0026amp; will be indeterminate after longjmp();\n    // normal execution\n  } else {\n    // recover\n  }\n}\n\n//...\n\nvoid fun() {\n  //...\n  longjmp(buf, 1);  // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint main(int argc, char* argv[]) {\n  // normal execution\n}\n\n//...\n\nvoid fun() {\n  //...\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 20.7 - The setjmp macro and the longjmp function shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 17-0-5 - The setjmp macro and the longjmp function shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 21.4 - The standard header file \u0026lt;setjmp.h\u0026gt; shall not be used \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/ktYxBQ\"\u003eCERT, MSC22-C.\u003c/a\u003e - Use the setjmp(), longjmp() facility securely \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/nHs-BQ\"\u003eCERT, ERR52-CPP.\u003c/a\u003e - Do not use setjmp() or longjmp() \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003ccode\u003esetjmp.h\u003c/code\u003e functions allow the normal function mechanisms to be bypassed and should be used only with extreme caution, if at all.\u003c/p\u003e\n\u003cp\u003eCalling \u003ccode\u003esetjmp\u003c/code\u003e saves the program environment into the buffer passed into the call. Later calling \u003ccode\u003elongjmp\u003c/code\u003e returns\nexecution to the point at which \u003ccode\u003esetjmp\u003c/code\u003e was called and restores the context that was saved into the buffer. But the values of non-volatile\nlocal variables after \u003ccode\u003elongjmp\u003c/code\u003e are indeterminate. Additionally invoking \u003ccode\u003elongjmp\u003c/code\u003e from a nested signal handler is undefined, as\nis \u003ccode\u003elongjmp\u003c/code\u003eing back to a method that has already completed execution.\u003c/p\u003e\n\u003cp\u003eThis rule flags all instances of \u003ccode\u003esetjmp\u003c/code\u003e, \u003ccode\u003e_setjmp\u003c/code\u003e, \u003ccode\u003elongjmp\u003c/code\u003e, \u003ccode\u003e_longjmp\u003c/code\u003e, \u003ccode\u003esigsetjmp\u003c/code\u003e,\n\u003ccode\u003esiglongjmp\u003c/code\u003e and \u003ccode\u003e\u0026lt;setjmp.h\u0026gt;\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;setjmp.h\u0026gt;  // Noncompliant\n\njmp_buf buf;\n\nint main(int argc, char* argv[]) {\n  int i \u003d setjmp(buf);  // Noncompliant\n  if (i \u003d\u003d 0) { // value of i was assigned after env was saved \u0026amp; will be indeterminate after longjmp();\n    // normal execution\n  } else {\n    // recover\n  }\n}\n\n//...\n\nvoid fun() {\n  //...\n  longjmp(buf, 1);  // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nint main(int argc, char* argv[]) {\n  // normal execution\n}\n\n//...\n\nvoid fun() {\n  //...\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 20.7 - The setjmp macro and the longjmp function shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 17-0-5 - The setjmp macro and the longjmp function shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 21.4 - The standard header file \u0026lt;setjmp.h\u0026gt; shall not be used \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/ktYxBQ\"\u003eCERT, MSC22-C.\u003c/a\u003e - Use the setjmp(), longjmp() facility securely \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/nHs-BQ\"\u003eCERT, ERR52-CPP.\u003c/a\u003e - Do not use setjmp() or longjmp() \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "cert",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:M23_058",
    "name": "The names of the \"standard signed integer types\" and \"standard unsigned integer types\" should not be used",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW",
      "RELIABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 6.9.2\u003c/p\u003e\n\u003cp\u003eCategory: Advisory\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eThis rule applies to the names of integral types constructed using the keywords \u003ccode\u003echar\u003c/code\u003e, \u003ccode\u003eshort\u003c/code\u003e, \u003ccode\u003eint\u003c/code\u003e,\n\u003ccode\u003elong\u003c/code\u003e, \u003ccode\u003esigned\u003c/code\u003e and \u003ccode\u003eunsigned\u003c/code\u003e (ignoring any \u003cem\u003ecv-qualification\u003c/em\u003e). It does not apply to the use of plain\n\u003ccode\u003echar\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eIt is \u003cem\u003eimplementation-defined\u003c/em\u003e how much storage is required for any object of the \u003cem\u003estandard signed integer types\u003c/em\u003e or \u003cem\u003estandard\nunsigned integer types\u003c/em\u003e. When the amount of storage being used is important, the use of types having specified widths makes it clear how much\nstorage is being reserved for each object.\u003c/p\u003e\n\u003cp\u003eThe C++ Standard Library \u003cem\u003eheader file\u003c/em\u003e [1] \u003ccode\u003e\u0026lt;cstdint\u0026gt;\u003c/code\u003e often provides a suitable set of integer types having specified\nwidths. If a project defines its own type aliases, it is good practice to use \u003ccode\u003estatic_assert\u003c/code\u003e to validate any size assumptions. For\nexample:\u003c/p\u003e\n\u003cpre\u003e\nusing torque_t \u003d unsigned short;\n\nstatic_assert( sizeof( torque_t ) \u0026gt;\u003d 2 );\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eNotes:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Adherence to this rule does not prevent integer promotion, which is influenced by the implemented size of \u003ccode\u003eint\u003c/code\u003e and the type used\n  for an alias. For example, an expression of type \u003ccode\u003eint16_t\u003c/code\u003e will only be promoted if the aliased type has a rank lower than that of\n  \u003ccode\u003eint\u003c/code\u003e. The presence or absence of integer promotion may have an influence on overload resolution. \u003c/li\u003e\n  \u003cli\u003e Strong typing, which may be provided by class or enum types, is more robust than the use of type aliases to represent specific width types.\n  \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eException\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e The names of the \u003cem\u003estandard signed integer types\u003c/em\u003e and \u003cem\u003estandard unsigned integer types\u003c/em\u003e may be used to define a type alias. \u003c/li\u003e\n  \u003cli\u003e The name \u003ccode\u003eint\u003c/code\u003e may be used for: \u003c/li\u003e\n  \u003cli\u003e The parameter to a postfix operator, which \u003cem\u003emust\u003c/em\u003e use that type; and \u003c/li\u003e\n  \u003cli\u003e The return type of \u003ccode\u003emain\u003c/code\u003e; and \u003c/li\u003e\n  \u003cli\u003e The \u003ccode\u003eargc\u003c/code\u003e parameter to \u003ccode\u003emain\u003c/code\u003e. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;cstdint\u0026gt;\n\nint           x \u003d 0;                     // Non-compliant - use of int\nint32_t       y \u003d 0;                     // Compliant\nint_least32_t z \u003d 0;                     // Compliant\n\nusing torque_t \u003d int;                    // Compliant by exception #1\ntorque_t w \u003d 0;\n\nclass C\n{\npublic:\n  C  operator++ ( int );                 // Compliant by exception #2.1\n};\n\nint main() { }                           // Compliant by exception #2.2\nint main( int argc, char * argv[] ) { }  // Compliant by exception #2.2 and #2.3\n\u003c/pre\u003e\n\u003ch3\u003eGlossary\u003c/h3\u003e\n\u003ch4\u003e[1] Header file\u003c/h4\u003e\n\u003cp\u003eA \u003cem\u003eheader file\u003c/em\u003e is considered to be any file that is included during preprocessing (for example via the \u003ccode\u003e#include\u003c/code\u003e directive),\nregardless of its name or suffix.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 6.9.2\u003c/p\u003e\n\u003cp\u003eCategory: Advisory\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eThis rule applies to the names of integral types constructed using the keywords \u003ccode\u003echar\u003c/code\u003e, \u003ccode\u003eshort\u003c/code\u003e, \u003ccode\u003eint\u003c/code\u003e,\n\u003ccode\u003elong\u003c/code\u003e, \u003ccode\u003esigned\u003c/code\u003e and \u003ccode\u003eunsigned\u003c/code\u003e (ignoring any \u003cem\u003ecv-qualification\u003c/em\u003e). It does not apply to the use of plain\n\u003ccode\u003echar\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eIt is \u003cem\u003eimplementation-defined\u003c/em\u003e how much storage is required for any object of the \u003cem\u003estandard signed integer types\u003c/em\u003e or \u003cem\u003estandard\nunsigned integer types\u003c/em\u003e. When the amount of storage being used is important, the use of types having specified widths makes it clear how much\nstorage is being reserved for each object.\u003c/p\u003e\n\u003cp\u003eThe C++ Standard Library \u003cem\u003eheader file\u003c/em\u003e [1] \u003ccode\u003e\u0026lt;cstdint\u0026gt;\u003c/code\u003e often provides a suitable set of integer types having specified\nwidths. If a project defines its own type aliases, it is good practice to use \u003ccode\u003estatic_assert\u003c/code\u003e to validate any size assumptions. For\nexample:\u003c/p\u003e\n\u003cpre\u003e\nusing torque_t \u003d unsigned short;\n\nstatic_assert( sizeof( torque_t ) \u0026gt;\u003d 2 );\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eNotes:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e Adherence to this rule does not prevent integer promotion, which is influenced by the implemented size of \u003ccode\u003eint\u003c/code\u003e and the type used\n  for an alias. For example, an expression of type \u003ccode\u003eint16_t\u003c/code\u003e will only be promoted if the aliased type has a rank lower than that of\n  \u003ccode\u003eint\u003c/code\u003e. The presence or absence of integer promotion may have an influence on overload resolution. \u003c/li\u003e\n  \u003cli\u003e Strong typing, which may be provided by class or enum types, is more robust than the use of type aliases to represent specific width types.\n  \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eException\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e The names of the \u003cem\u003estandard signed integer types\u003c/em\u003e and \u003cem\u003estandard unsigned integer types\u003c/em\u003e may be used to define a type alias. \u003c/li\u003e\n  \u003cli\u003e The name \u003ccode\u003eint\u003c/code\u003e may be used for: \u003c/li\u003e\n  \u003cli\u003e The parameter to a postfix operator, which \u003cem\u003emust\u003c/em\u003e use that type; and \u003c/li\u003e\n  \u003cli\u003e The return type of \u003ccode\u003emain\u003c/code\u003e; and \u003c/li\u003e\n  \u003cli\u003e The \u003ccode\u003eargc\u003c/code\u003e parameter to \u003ccode\u003emain\u003c/code\u003e. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;cstdint\u0026gt;\n\nint           x \u003d 0;                     // Non-compliant - use of int\nint32_t       y \u003d 0;                     // Compliant\nint_least32_t z \u003d 0;                     // Compliant\n\nusing torque_t \u003d int;                    // Compliant by exception #1\ntorque_t w \u003d 0;\n\nclass C\n{\npublic:\n  C  operator++ ( int );                 // Compliant by exception #2.1\n};\n\nint main() { }                           // Compliant by exception #2.2\nint main( int argc, char * argv[] ) { }  // Compliant by exception #2.2 and #2.3\n\u003c/pre\u003e\n\u003ch3\u003eGlossary\u003c/h3\u003e\n\u003ch4\u003e[1] Header file\u003c/h4\u003e\n\u003cp\u003eA \u003cem\u003eheader file\u003c/em\u003e is considered to be any file that is included during preprocessing (for example via the \u003ccode\u003e#include\u003c/code\u003e directive),\nregardless of its name or suffix.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "misra-advisory",
      "misra-c++2023",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1017",
    "name": "Pure \"virtual\" functions should not override non-pure \"virtual\" functions",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eA \u003ccode\u003evirtual\u003c/code\u003e function has an implementation that \u003cem\u003emay\u003c/em\u003e be replaced in a child class. A pure \u003ccode\u003evirtual\u003c/code\u003e has no\nimplementation, and \u003cem\u003emust\u003c/em\u003e be implemented in child classes.\u003c/p\u003e\n\u003cp\u003eHiding a base class implementation with a \"pure implementation\" (\u003ccode\u003e\u003d0\u003c/code\u003e) is sure to confuse extenders, who may not be aware of the base\nclass\u0027 implementation. Instead, they’ll see there’s no implementation in the class they’re extending and assume that none exists. When that base class\nimplementation contains crucial functionality such as freeing resources, this could cause future users of the class to introduce bugs.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue if a pure virtual function overrides a virtual function that is not pure.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstruct A {\n  virtual void func1();\n  virtual void func2() \u003d 0;\n};\n\nstruct B : A {\n  virtual void func1() \u003d 0; // Noncompliant; override non-pure virtual\n  virtual void func2() \u003d 0; // Compliant; but useless\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstruct A {\n  virtual void func1();\n  virtual void func2() \u003d 0;\n};\n\nstruct B : A {\n  virtual void func1(); // Compliant; non-pure virtual\n};\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 10-3-3 - A virtual function shall only be overridden by a pure virtual function if it is itself declared as pure virtual. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eA \u003ccode\u003evirtual\u003c/code\u003e function has an implementation that \u003cem\u003emay\u003c/em\u003e be replaced in a child class. A pure \u003ccode\u003evirtual\u003c/code\u003e has no\nimplementation, and \u003cem\u003emust\u003c/em\u003e be implemented in child classes.\u003c/p\u003e\n\u003cp\u003eHiding a base class implementation with a \"pure implementation\" (\u003ccode\u003e\u003d0\u003c/code\u003e) is sure to confuse extenders, who may not be aware of the base\nclass\u0027 implementation. Instead, they’ll see there’s no implementation in the class they’re extending and assume that none exists. When that base class\nimplementation contains crucial functionality such as freeing resources, this could cause future users of the class to introduce bugs.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue if a pure virtual function overrides a virtual function that is not pure.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nstruct A {\n  virtual void func1();\n  virtual void func2() \u003d 0;\n};\n\nstruct B : A {\n  virtual void func1() \u003d 0; // Noncompliant; override non-pure virtual\n  virtual void func2() \u003d 0; // Compliant; but useless\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nstruct A {\n  virtual void func1();\n  virtual void func2() \u003d 0;\n};\n\nstruct B : A {\n  virtual void func1(); // Compliant; non-pure virtual\n};\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 10-3-3 - A virtual function shall only be overridden by a pure virtual function if it is itself declared as pure virtual. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1259",
    "name": "\"typedef\" should be used for function pointers",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eFunction pointer syntax can be hard on the eyes, particularly when one function is used as a parameter to another. Providing and using a\n\u003ccode\u003etypedef\u003c/code\u003e instead (or a \u003ccode\u003eusing\u003c/code\u003e in C++) can make code easier to read, and should be preferred.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nextern void (*signal(int, void(*)(int)))(int);\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\ntypedef void (*SignalHandler)(int signum);\nextern SignalHandler signal(int signum, SignalHandler handler);\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eFunction pointer syntax can be hard on the eyes, particularly when one function is used as a parameter to another. Providing and using a\n\u003ccode\u003etypedef\u003c/code\u003e instead (or a \u003ccode\u003eusing\u003c/code\u003e in C++) can make code easier to read, and should be preferred.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nextern void (*signal(int, void(*)(int)))(int);\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\ntypedef void (*SignalHandler)(int signum);\nextern SignalHandler signal(int signum, SignalHandler handler);\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S2107",
    "name": "Member variables should be initialized",
    "defaultSeverity": "CRITICAL",
    "type": "BUG",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003cp\u003ePartially-initialized objects are surprising to the \u003ccode\u003eclass\u003c/code\u003e users and might lead to hard-to-catch bugs. \u003ccode\u003eclass\u003c/code\u003ees with\nconstructors are expected to have all members initialized after their constructor finishes.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when some members are left uninitialized after a constructor finishes.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eIn the following example, \u003ccode\u003ePartInit::x\u003c/code\u003e is left uninitialized after the constructor finishes.\u003c/p\u003e\n\u003cpre\u003e\nstruct AutomaticallyInitialized {\n  int x;\n  AutomaticallyInitialized() : x(0) {}\n};\n\nstruct PartInit {\n  AutomaticallyInitialized ai;\n  int x;\n  int y;\n  PartInit(int n) :y(n) {\n    // this-\u0026gt;ai is initialized\n    // this-\u0026gt;y is initialized\n    // Noncompliant: this-\u0026gt;x is left uninitialized\n  }\n};\n\u003c/pre\u003e\n\u003cp\u003eThis leads to undefined behavior in benign-looking code like on the example below. In this particular case, garbage value may be printed, or a\ncompiler may optimize away the print statement completely.\u003c/p\u003e\n\u003cpre\u003e\nPartInit pi(1);\nstd::cout \u0026lt;\u0026lt;pi.y; // Undefined behavior\n\u003c/pre\u003e\n\u003cp\u003eFor this reason, constructors should always initialize all data members of a class.\u003c/p\u003e\n\u003cp\u003eWhile in some cases data members are initialized by their default constructor, in others, they are left with garbage.\u003c/p\u003e\n\u003cp\u003eTypes with a \u003ccode\u003edefault\u003c/code\u003eed or implicit trivial default constructor follow the aggregate initialization syntax: if you omit them in the\ninitialization list, they will not be initialized.\u003c/p\u003e\n\u003cpre\u003e\nstruct Trivial {\n  int x;\n  int y;\n};\nstruct Container {\n  Trivial t;\n  int arr[2];\n  Container() {\n    // Noncompliant\n    // this-\u0026gt;t is not initialized\n    // this-\u0026gt;t.x and this-\u0026gt;t.y contain garbage\n    // this-\u0026gt;arr contains garbage\n  }\n  Container(int) :t{}, arr{} {\n    // Compliant\n    // this-\u0026gt;t.x and this-\u0026gt;t.y are initialized to 0\n    // this-\u0026gt;arr is initialized to {0, 0}\n  }\n  Container(int, int) :t{1}, arr{1} {\n    // Compliant\n    // this-\u0026gt;t.x is 1\n    // this-\u0026gt;t.y is 0\n    // this-\u0026gt;arr is initialized to {1, 0}\n  }\n};\nstruct DefaultedContainer {\n  Trivial t;\n  int arr[2];\n  DefaultedContainer() \u003d default; // Noncompliant\n  // this-\u0026gt;t and this-\u0026gt;arr are not initialized\n};\n\u003c/pre\u003e\n\u003cp\u003eThe same is true for a \u003ccode\u003edefault\u003c/code\u003eed default constructor.\u003c/p\u003e\n\u003cpre\u003e\nstruct Defaulted {\n  int x;\n  Defaulted() \u003d default;\n};\nstruct ContainerDefaulted {\n  Defaulted d;\n  ContainerDefaulted() {\n    // Noncompliant this-\u0026gt;d.x is not initialized\n  }\n};\n\u003c/pre\u003e\n\u003cp\u003eEven if some of the members have class initializers, the other members are still not initialized by default.\u003c/p\u003e\n\u003cpre\u003e\nstruct Partial {\n  int x;\n  int y \u003d 1;\n  int z;\n};\nstruct ContainerPartial {\n  Partial p;\n  ContainrePartial() {\n    // Noncompliant\n    // this-\u0026gt;p.x is not initialized\n    // this-\u0026gt;p.y is initialized to 1\n    // this-\u0026gt;p.z is not initialized\n  }\n  ContainrePartial(bool) :p{3} {\n    // Compliant\n    // this-\u0026gt;p.x is initialized to 3\n    // this-\u0026gt;p.y is initialized to 1\n    // this-\u0026gt;p.z is initialized to 0\n  }\n};\n\u003c/pre\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eIt is a common expectation that an object be in a fully-initialized state after its construction. A partially initialized object breaks this\nassumption.\u003c/p\u003e\n\u003cp\u003eThis comes with all the risks associated with uninitialized variables, and these risks propagate to all the classes using the faulty class as a\ntype as a base class or a data member. This is all the more surprising that most programmers expect a constructor to correctly initialize the members\nof its class.\u003c/p\u003e\n\u003cp\u003eUsing garbage values will cause the program to behave nondeterministically at runtime. The program may produce a different output or crash\ndepending on the run.\u003c/p\u003e\n\u003cp\u003eIn some situations, loading a variable may expose a sensitive data, such as a password that was previously stored in the same location, leading to\na vulnerability that uses such a defect as a gadget for extracting information from the instance of the program.\u003c/p\u003e\n\u003cp\u003eFinally, in C++, outside of a few exceptions related to the uses of \u003ccode\u003eunsigned char\u003c/code\u003e or \u003ccode\u003estd::byte\u003c/code\u003e, loading data from an\nuninitialized variable causes undefined behavior. This means that the compiler is not bound by the language standard anymore, and the program has no\nmeaning assigned to it. As a consequence, the impact of such a defect is not limited to the use of garbage values.\u003c/p\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eAggregate classes do not initialize most of their data members (unless you explicitly value initialize them with \u003ccode\u003ex{}\u003c/code\u003e or\n\u003ccode\u003ex()\u003c/code\u003e) but allow their users to use nice and flexible initialization syntax. They will be ignored by this rule (but are the subject of rule\nS5558).\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eTo avoid partially-initialized objects, all non \u003ccode\u003eclass\u003c/code\u003e-type fields should always be initialized (in order of preference):\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e With an in-class initializer \u003c/li\u003e\n  \u003cli\u003e In the initialization list of a constructor \u003c/li\u003e\n  \u003cli\u003e In the constructor body \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSee rule {rule:cpp:S3230} for more details about this order.\u003c/p\u003e\n\u003cp\u003eIf none of the above places is a good fit for a data member, ask yourself whether it belongs to this class. Instead of a data member, it might be\nmore appropriate to keep the value\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e as part of the class of a data member (delegating initialization to the constructor of the member type), \u003c/li\u003e\n  \u003cli\u003e in a derived class (delegating initialization to the derived class), \u003c/li\u003e\n  \u003cli\u003e in a (potentially \u003ccode\u003estatic\u003c/code\u003e) local variable of a member function, or \u003c/li\u003e\n  \u003cli\u003e in a parameter of a member function. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nclass C {\n  int val \u003d 42;\n};\n\nclass S {\npublic:\n  C c;\n  int i;\n  int j;\n\n  S() : i(0) {} // Noncompliant: this-\u0026gt;j is left uninitialized\n  S(bool) : i(0), j(0) {}\n};\n\nclass T {\npublic:\n  S s;\n\n  T() : s() {} // Noncompliant: s.j is left uninitialized\n  T(bool b) : s(b) {}\n};\n\nclass U {\npublic:\n  T t;\n\n  U() : t() {} // Noncompliant: t.s.j is left uninitialized\n};\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nclass C {\n  int val \u003d 42;\n};\n\nclass S_fixed {\npublic:\n  C c;\n  int i;\n  int j;\n\n  S_fixed() : i(0), j(0) {} // Compliant\n  S_fixed(bool) : i(0), j(0) {}\n};\n\nclass T_fixed {\npublic:\n  S_fixed s;\n\n  T_fixed() : s() {}  // Compliant\n  T_fixed(bool b) : s(b) {}\n};\n\nclass U {\npublic:\n  T t;\n\n  U() : t() { t.s.j \u003d 0; }  // Compliant\n};\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\nstruct Partial {\n  int x;\n  int y \u003d 1;\n};\nstruct ContainerPartial {\n  Partial p;\n  ContainrePartial() {\n    // Noncompliant: this-\u0026gt;p.x is not initialized\n  }\n};\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\nstruct Partial {\n  int x \u003d 0;\n  int y \u003d 1;\n};\nstruct ContainerPartial {\n  Partial p;\n  ContainrePartial() {\n    // Compliant\n  }\n};\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c41-a-constructor-should-create-a-fully-initialized-object\"\u003eC.41: A constructor should create a fully initialized object\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S836} detects the uses of uninitialized variables. \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S3230} describes the preferred place for initializing class data members. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/aggregate_initialization\"\u003eAggregate initialization\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/direct_initialization\"\u003eDirect initialization\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/value_initialization\"\u003eValue initialization\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003ePartially-initialized objects are surprising to the \u003ccode\u003eclass\u003c/code\u003e users and might lead to hard-to-catch bugs. \u003ccode\u003eclass\u003c/code\u003ees with\nconstructors are expected to have all members initialized after their constructor finishes.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when some members are left uninitialized after a constructor finishes.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eIn the following example, \u003ccode\u003ePartInit::x\u003c/code\u003e is left uninitialized after the constructor finishes.\u003c/p\u003e\n\u003cpre\u003e\nstruct AutomaticallyInitialized {\n  int x;\n  AutomaticallyInitialized() : x(0) {}\n};\n\nstruct PartInit {\n  AutomaticallyInitialized ai;\n  int x;\n  int y;\n  PartInit(int n) :y(n) {\n    // this-\u0026gt;ai is initialized\n    // this-\u0026gt;y is initialized\n    // Noncompliant: this-\u0026gt;x is left uninitialized\n  }\n};\n\u003c/pre\u003e\n\u003cp\u003eThis leads to undefined behavior in benign-looking code like on the example below. In this particular case, garbage value may be printed, or a\ncompiler may optimize away the print statement completely.\u003c/p\u003e\n\u003cpre\u003e\nPartInit pi(1);\nstd::cout \u0026lt;\u0026lt;pi.y; // Undefined behavior\n\u003c/pre\u003e\n\u003cp\u003eFor this reason, constructors should always initialize all data members of a class.\u003c/p\u003e\n\u003cp\u003eWhile in some cases data members are initialized by their default constructor, in others, they are left with garbage.\u003c/p\u003e\n\u003cp\u003eTypes with a \u003ccode\u003edefault\u003c/code\u003eed or implicit trivial default constructor follow the aggregate initialization syntax: if you omit them in the\ninitialization list, they will not be initialized.\u003c/p\u003e\n\u003cpre\u003e\nstruct Trivial {\n  int x;\n  int y;\n};\nstruct Container {\n  Trivial t;\n  int arr[2];\n  Container() {\n    // Noncompliant\n    // this-\u0026gt;t is not initialized\n    // this-\u0026gt;t.x and this-\u0026gt;t.y contain garbage\n    // this-\u0026gt;arr contains garbage\n  }\n  Container(int) :t{}, arr{} {\n    // Compliant\n    // this-\u0026gt;t.x and this-\u0026gt;t.y are initialized to 0\n    // this-\u0026gt;arr is initialized to {0, 0}\n  }\n  Container(int, int) :t{1}, arr{1} {\n    // Compliant\n    // this-\u0026gt;t.x is 1\n    // this-\u0026gt;t.y is 0\n    // this-\u0026gt;arr is initialized to {1, 0}\n  }\n};\nstruct DefaultedContainer {\n  Trivial t;\n  int arr[2];\n  DefaultedContainer() \u003d default; // Noncompliant\n  // this-\u0026gt;t and this-\u0026gt;arr are not initialized\n};\n\u003c/pre\u003e\n\u003cp\u003eThe same is true for a \u003ccode\u003edefault\u003c/code\u003eed default constructor.\u003c/p\u003e\n\u003cpre\u003e\nstruct Defaulted {\n  int x;\n  Defaulted() \u003d default;\n};\nstruct ContainerDefaulted {\n  Defaulted d;\n  ContainerDefaulted() {\n    // Noncompliant this-\u0026gt;d.x is not initialized\n  }\n};\n\u003c/pre\u003e\n\u003cp\u003eEven if some of the members have class initializers, the other members are still not initialized by default.\u003c/p\u003e\n\u003cpre\u003e\nstruct Partial {\n  int x;\n  int y \u003d 1;\n  int z;\n};\nstruct ContainerPartial {\n  Partial p;\n  ContainrePartial() {\n    // Noncompliant\n    // this-\u0026gt;p.x is not initialized\n    // this-\u0026gt;p.y is initialized to 1\n    // this-\u0026gt;p.z is not initialized\n  }\n  ContainrePartial(bool) :p{3} {\n    // Compliant\n    // this-\u0026gt;p.x is initialized to 3\n    // this-\u0026gt;p.y is initialized to 1\n    // this-\u0026gt;p.z is initialized to 0\n  }\n};\n\u003c/pre\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eIt is a common expectation that an object be in a fully-initialized state after its construction. A partially initialized object breaks this\nassumption.\u003c/p\u003e\n\u003cp\u003eThis comes with all the risks associated with uninitialized variables, and these risks propagate to all the classes using the faulty class as a\ntype as a base class or a data member. This is all the more surprising that most programmers expect a constructor to correctly initialize the members\nof its class.\u003c/p\u003e\n\u003cp\u003eUsing garbage values will cause the program to behave nondeterministically at runtime. The program may produce a different output or crash\ndepending on the run.\u003c/p\u003e\n\u003cp\u003eIn some situations, loading a variable may expose a sensitive data, such as a password that was previously stored in the same location, leading to\na vulnerability that uses such a defect as a gadget for extracting information from the instance of the program.\u003c/p\u003e\n\u003cp\u003eFinally, in C++, outside of a few exceptions related to the uses of \u003ccode\u003eunsigned char\u003c/code\u003e or \u003ccode\u003estd::byte\u003c/code\u003e, loading data from an\nuninitialized variable causes undefined behavior. This means that the compiler is not bound by the language standard anymore, and the program has no\nmeaning assigned to it. As a consequence, the impact of such a defect is not limited to the use of garbage values.\u003c/p\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eAggregate classes do not initialize most of their data members (unless you explicitly value initialize them with \u003ccode\u003ex{}\u003c/code\u003e or\n\u003ccode\u003ex()\u003c/code\u003e) but allow their users to use nice and flexible initialization syntax. They will be ignored by this rule (but are the subject of rule\nS5558).\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eTo avoid partially-initialized objects, all non \u003ccode\u003eclass\u003c/code\u003e-type fields should always be initialized (in order of preference):\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e With an in-class initializer \u003c/li\u003e\n  \u003cli\u003e In the initialization list of a constructor \u003c/li\u003e\n  \u003cli\u003e In the constructor body \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSee rule {rule:cpp:S3230} for more details about this order.\u003c/p\u003e\n\u003cp\u003eIf none of the above places is a good fit for a data member, ask yourself whether it belongs to this class. Instead of a data member, it might be\nmore appropriate to keep the value\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e as part of the class of a data member (delegating initialization to the constructor of the member type), \u003c/li\u003e\n  \u003cli\u003e in a derived class (delegating initialization to the derived class), \u003c/li\u003e\n  \u003cli\u003e in a (potentially \u003ccode\u003estatic\u003c/code\u003e) local variable of a member function, or \u003c/li\u003e\n  \u003cli\u003e in a parameter of a member function. \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nclass C {\n  int val \u003d 42;\n};\n\nclass S {\npublic:\n  C c;\n  int i;\n  int j;\n\n  S() : i(0) {} // Noncompliant: this-\u0026gt;j is left uninitialized\n  S(bool) : i(0), j(0) {}\n};\n\nclass T {\npublic:\n  S s;\n\n  T() : s() {} // Noncompliant: s.j is left uninitialized\n  T(bool b) : s(b) {}\n};\n\nclass U {\npublic:\n  T t;\n\n  U() : t() {} // Noncompliant: t.s.j is left uninitialized\n};\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nclass C {\n  int val \u003d 42;\n};\n\nclass S_fixed {\npublic:\n  C c;\n  int i;\n  int j;\n\n  S_fixed() : i(0), j(0) {} // Compliant\n  S_fixed(bool) : i(0), j(0) {}\n};\n\nclass T_fixed {\npublic:\n  S_fixed s;\n\n  T_fixed() : s() {}  // Compliant\n  T_fixed(bool b) : s(b) {}\n};\n\nclass U {\npublic:\n  T t;\n\n  U() : t() { t.s.j \u003d 0; }  // Compliant\n};\n\u003c/pre\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"noncompliant\"\u003e\nstruct Partial {\n  int x;\n  int y \u003d 1;\n};\nstruct ContainerPartial {\n  Partial p;\n  ContainrePartial() {\n    // Noncompliant: this-\u0026gt;p.x is not initialized\n  }\n};\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"2\" data-diff-type\u003d\"compliant\"\u003e\nstruct Partial {\n  int x \u003d 0;\n  int y \u003d 1;\n};\nstruct ContainerPartial {\n  Partial p;\n  ContainrePartial() {\n    // Compliant\n  }\n};\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ Core Guidelines - \u003ca\n  href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/e49158a/CppCoreGuidelines.md#c41-a-constructor-should-create-a-fully-initialized-object\"\u003eC.41: A constructor should create a fully initialized object\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S836} detects the uses of uninitialized variables. \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:S3230} describes the preferred place for initializing class data members. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/aggregate_initialization\"\u003eAggregate initialization\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/direct_initialization\"\u003eDirect initialization\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/language/value_initialization\"\u003eValue initialization\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "bad-practice",
      "pitfall",
      "symbolic-execution"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:M23_064",
    "name": "\"nullptr\" shall be the only form of the \"null-pointer-constant\"",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 7.11.1\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eUsing any integral literal representing zero, including the literal \u003ccode\u003e0\u003c/code\u003e or the macro \u003ccode\u003eNULL\u003c/code\u003e, to represent the\n\u003cem\u003enull-pointer-constant\u003c/em\u003e is a violation of this rule.\u003c/p\u003e\n\u003cp\u003eIn addition, the macro \u003ccode\u003eNULL\u003c/code\u003e shall not be used in any other context.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eThe C++ Standard defines the object \u003ccode\u003enullptr\u003c/code\u003e as the \u003cem\u003enull-pointer-constant\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eThe literal \u003ccode\u003e0\u003c/code\u003e can also be used to represent a \u003cem\u003enull-pointer-constant\u003c/em\u003e. However, \u003ccode\u003e0\u003c/code\u003e has type \u003ccode\u003eint\u003c/code\u003e, and\nits use can lead to unexpected overload resolution. Note that the macro \u003ccode\u003eNULL\u003c/code\u003e expands to \u003ccode\u003e0\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e some library functions provide overloads for \u003ccode\u003estd::nullptr_t\u003c/code\u003e so that they can be selected during overload\nresolution at compile-time, avoiding the need for a run-time check against \u003ccode\u003enullptr\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nvoid f1( int32_t * );\n\nvoid f2()\n{\n  f1( nullptr );     // Compliant\n  f1( 0 );           // Non-compliant - 0 used as the null pointer constant\n}\n\u003c/pre\u003e\n\u003cp\u003eThe following example shows the selection of an integer overload when \u003ccode\u003eNULL\u003c/code\u003e (which has a value of \u003ccode\u003e0\u003c/code\u003e) is used instead of\n\u003ccode\u003enullptr\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\nvoid f3( int32_t   );\nvoid f3( int32_t * );\n\nvoid f4()\n{\n  f3( NULL );        // Non-compliant - calls the int32_t   overload\n  f3( nullptr );     // Compliant     - calls the int32_t * overload\n}\n\u003c/pre\u003e\n\u003cp\u003eThe following example shows non-compliant uses of \u003ccode\u003eNULL\u003c/code\u003e, where it is not used as the \u003cem\u003enull-pointer-constant\u003c/em\u003e:\u003c/p\u003e\n\u003cpre\u003e\n#define MYNULL NULL        // Non-compliant\n\nvoid f5()\n{\n  int32_t one \u003d NULL + 1;  // Non-compliant - NULL used as an integer\n\n  throw NULL;              // Non-compliant - caught by catch ( int )\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003e{rule:cpp:S4962} targets the same defect as this rule but for a non-mission-critical context.\u003c/p\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cp\u003e\u003ca href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/036324/CppCoreGuidelines.md#es47-use-nullptr-rather-than-0-or-null\"\u003eC++ Core Guidelines\nES.47\u003c/a\u003e - Use nullptr rather than 0 or NULL\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 7.11.1\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eAmplification\u003c/h3\u003e\n\u003cp\u003eUsing any integral literal representing zero, including the literal \u003ccode\u003e0\u003c/code\u003e or the macro \u003ccode\u003eNULL\u003c/code\u003e, to represent the\n\u003cem\u003enull-pointer-constant\u003c/em\u003e is a violation of this rule.\u003c/p\u003e\n\u003cp\u003eIn addition, the macro \u003ccode\u003eNULL\u003c/code\u003e shall not be used in any other context.\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eThe C++ Standard defines the object \u003ccode\u003enullptr\u003c/code\u003e as the \u003cem\u003enull-pointer-constant\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eThe literal \u003ccode\u003e0\u003c/code\u003e can also be used to represent a \u003cem\u003enull-pointer-constant\u003c/em\u003e. However, \u003ccode\u003e0\u003c/code\u003e has type \u003ccode\u003eint\u003c/code\u003e, and\nits use can lead to unexpected overload resolution. Note that the macro \u003ccode\u003eNULL\u003c/code\u003e expands to \u003ccode\u003e0\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e some library functions provide overloads for \u003ccode\u003estd::nullptr_t\u003c/code\u003e so that they can be selected during overload\nresolution at compile-time, avoiding the need for a run-time check against \u003ccode\u003enullptr\u003c/code\u003e.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nvoid f1( int32_t * );\n\nvoid f2()\n{\n  f1( nullptr );     // Compliant\n  f1( 0 );           // Non-compliant - 0 used as the null pointer constant\n}\n\u003c/pre\u003e\n\u003cp\u003eThe following example shows the selection of an integer overload when \u003ccode\u003eNULL\u003c/code\u003e (which has a value of \u003ccode\u003e0\u003c/code\u003e) is used instead of\n\u003ccode\u003enullptr\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\nvoid f3( int32_t   );\nvoid f3( int32_t * );\n\nvoid f4()\n{\n  f3( NULL );        // Non-compliant - calls the int32_t   overload\n  f3( nullptr );     // Compliant     - calls the int32_t * overload\n}\n\u003c/pre\u003e\n\u003cp\u003eThe following example shows non-compliant uses of \u003ccode\u003eNULL\u003c/code\u003e, where it is not used as the \u003cem\u003enull-pointer-constant\u003c/em\u003e:\u003c/p\u003e\n\u003cpre\u003e\n#define MYNULL NULL        // Non-compliant\n\nvoid f5()\n{\n  int32_t one \u003d NULL + 1;  // Non-compliant - NULL used as an integer\n\n  throw NULL;              // Non-compliant - caught by catch ( int )\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cp\u003e{rule:cpp:S4962} targets the same defect as this rule but for a non-mission-critical context.\u003c/p\u003e\n\u003ch3\u003eExternal coding guidelines\u003c/h3\u003e\n\u003cp\u003e\u003ca href\u003d\"https://github.com/isocpp/CppCoreGuidelines/blob/036324/CppCoreGuidelines.md#es47-use-nullptr-rather-than-0-or-null\"\u003eC++ Core Guidelines\nES.47\u003c/a\u003e - Use nullptr rather than 0 or NULL\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "confusing",
      "misra-c++2023",
      "misra-required",
      "since-c++11"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5978",
    "name": "Multicharacter literals should not be used",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eMulticharacter literals have \u003ccode\u003eint\u003c/code\u003e type and have an implementation-defined value. This means they might be interpreted differently by\ndifferent compilers. For example, they might lead to different behavior when compiled with GCC than when compiled with MSVC.\u003c/p\u003e\n\u003cp\u003eEven if they work as you expect with a specific compiler, they will make your code less portable. They are also misleading as they look like\nstrings, hence make your code less readable.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid f(int i) {\n  // ...\n  if (i \u003d\u003d \u0027abcd\u0027) { // Noncompliant\n    // ...\n  }\n}\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eMulticharacter literals have \u003ccode\u003eint\u003c/code\u003e type and have an implementation-defined value. This means they might be interpreted differently by\ndifferent compilers. For example, they might lead to different behavior when compiled with GCC than when compiled with MSVC.\u003c/p\u003e\n\u003cp\u003eEven if they work as you expect with a specific compiler, they will make your code less portable. They are also misleading as they look like\nstrings, hence make your code less readable.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid f(int i) {\n  // ...\n  if (i \u003d\u003d \u0027abcd\u0027) { // Noncompliant\n    // ...\n  }\n}\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "confusing",
      "lock-in"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:M23_187",
    "name": "An exception object shall not have pointer type",
    "defaultSeverity": "CRITICAL",
    "type": "BUG",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 18.1.1\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eIf an exception object of pointer type is thrown and that pointer refers to a dynamically created object, then it may be unclear which function is\nresponsible for destroying it, and when. This ambiguity does not exist if the object is thrown by value.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nclass A\n{\n  // Implementation\n};\n\nvoid fn( int16_t i )\n{\n  static A   a1;\n         A * a2 \u003d new A;\n\n  if ( i \u0026gt; 10 )\n  {\n    throw \u0026amp;a1;              // Non-compliant - pointer type thrown\n  }\n\n  else\n  {\n    throw a2;               // Non-compliant - pointer type thrown\n  }\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S1035} targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:M23_196}: MISRA C++ 2023 Rule\u0026nbsp;18.3.2 - An exception of class type shall be caught by const reference or reference \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003cstrong\u003eThis is a draft version of a MISRA C++ 202x rule proposed for public review.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMISRA Rule 18.1.1\u003c/p\u003e\n\u003cp\u003eCategory: Required\u003c/p\u003e\n\u003cp\u003eAnalysis Type: Decidable,Single Translation Unit\u003c/p\u003e\n\u003ch3\u003eRationale\u003c/h3\u003e\n\u003cp\u003eIf an exception object of pointer type is thrown and that pointer refers to a dynamically created object, then it may be unclear which function is\nresponsible for destroying it, and when. This ambiguity does not exist if the object is thrown by value.\u003c/p\u003e\n\u003ch3\u003eExample\u003c/h3\u003e\n\u003cpre\u003e\nclass A\n{\n  // Implementation\n};\n\nvoid fn( int16_t i )\n{\n  static A   a1;\n         A * a2 \u003d new A;\n\n  if ( i \u0026gt; 10 )\n  {\n    throw \u0026amp;a1;              // Non-compliant - pointer type thrown\n  }\n\n  else\n  {\n    throw a2;               // Non-compliant - pointer type thrown\n  }\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eCopyright The MISRA Consortium Limited © 2023\u003c/strong\u003e\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e {rule:cpp:S1035} targets the same defect as this rule but for a non-mission-critical context. \u003c/li\u003e\n  \u003cli\u003e {rule:cpp:M23_196}: MISRA C++ 2023 Rule\u0026nbsp;18.3.2 - An exception of class type shall be caught by const reference or reference \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "misra-c++2023",
      "misra-required",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S2583",
    "name": "Conditionally executed code should be reachable",
    "defaultSeverity": "MAJOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eConditional expressions which are always \u003ccode\u003etrue\u003c/code\u003e or \u003ccode\u003efalse\u003c/code\u003e can lead to \u003ca\nhref\u003d\"https://en.wikipedia.org/wiki/Unreachable_code\"\u003eunreachable code\u003c/a\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\na \u003d false;\nif (a) { // Noncompliant\n  doSomething(); // never executed\n}\n\nif (!a || b) { // Noncompliant; \"!a\" is always \"true\", \"b\" is never evaluated\n  doSomething();\n} else {\n  doSomethingElse(); // never executed\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 13.7 - Boolean operations whose results are invariant shall not be permitted. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 14.3 - Controlling expressions shall not be invariant \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/570\"\u003eMITRE, CWE-570\u003c/a\u003e - Expression is Always False \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/571\"\u003eMITRE, CWE-571\u003c/a\u003e - Expression is Always True \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/5dUxBQ\"\u003eCERT, MSC12-C.\u003c/a\u003e - Detect and remove code that has no effect or is never executed\n  \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eConditional expressions which are always \u003ccode\u003etrue\u003c/code\u003e or \u003ccode\u003efalse\u003c/code\u003e can lead to \u003ca\nhref\u003d\"https://en.wikipedia.org/wiki/Unreachable_code\"\u003eunreachable code\u003c/a\u003e.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\na \u003d false;\nif (a) { // Noncompliant\n  doSomething(); // never executed\n}\n\nif (!a || b) { // Noncompliant; \"!a\" is always \"true\", \"b\" is never evaluated\n  doSomething();\n} else {\n  doSomethingElse(); // never executed\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 13.7 - Boolean operations whose results are invariant shall not be permitted. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 14.3 - Controlling expressions shall not be invariant \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/570\"\u003eMITRE, CWE-570\u003c/a\u003e - Expression is Always False \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/571\"\u003eMITRE, CWE-571\u003c/a\u003e - Expression is Always True \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/5dUxBQ\"\u003eCERT, MSC12-C.\u003c/a\u003e - Detect and remove code that has no effect or is never executed\n  \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "cert",
      "cwe",
      "pitfall",
      "suspicious",
      "unused"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S5972",
    "name": "Values returned from string find-related methods should not be treated as boolean",
    "defaultSeverity": "CRITICAL",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003estd::string\u003c/code\u003e and \u003ccode\u003estd::string_view\u003c/code\u003e provide functions to search for specific characters or groups of characters within a\nstring. If the search is successful, these functions will return the position of the first character in the string that matches the search pattern. If\nthe search fails, the functions will return the special value \u003ccode\u003enpos\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003enpos\u003c/code\u003e is converted to \u003ccode\u003etrue\u003c/code\u003e when used in a boolean context. Therefore, using the returned value in a boolean context to\ndetermine if the search was successful does not work.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eThe returned value of the following functions should be compared to \u003ccode\u003enpos\u003c/code\u003e when used in a boolean context:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003efind\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003erfind\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003efind_first_of\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003efind_last_of\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003efind_first_not_of\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003efind_last_not_of\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid f() {\n  std::string s \u003d \"\";\n  if (s.find(\"42\")) { // Noncompliant: the condition is true even if \"s\" does not contain \"42\"\n    // ...\n  }\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid f() {\n  std::string s \u003d \"\";\n  if (s.find(\"42\") !\u003d std::string::npos) {\n    // ...\n  }\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/string/basic_string\"\u003eSearch functions for std::basic_string\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/string/basic_string_view\"\u003eSearch functions for std::basic_string_view\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/string/basic_string/npos\"\u003estd::basic_string\u0026lt;CharT,Traits\u0026gt;::npos\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/string/basic_string_view/npos\"\u003estd::basic_string_view\u0026lt;CharT,Traits\u0026gt;::npos\u003c/a\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003ccode\u003estd::string\u003c/code\u003e and \u003ccode\u003estd::string_view\u003c/code\u003e provide functions to search for specific characters or groups of characters within a\nstring. If the search is successful, these functions will return the position of the first character in the string that matches the search pattern. If\nthe search fails, the functions will return the special value \u003ccode\u003enpos\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003enpos\u003c/code\u003e is converted to \u003ccode\u003etrue\u003c/code\u003e when used in a boolean context. Therefore, using the returned value in a boolean context to\ndetermine if the search was successful does not work.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eThe returned value of the following functions should be compared to \u003ccode\u003enpos\u003c/code\u003e when used in a boolean context:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003efind\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003erfind\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003efind_first_of\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003efind_last_of\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003efind_first_not_of\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003efind_last_not_of\u003c/code\u003e \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\nvoid f() {\n  std::string s \u003d \"\";\n  if (s.find(\"42\")) { // Noncompliant: the condition is true even if \"s\" does not contain \"42\"\n    // ...\n  }\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\nvoid f() {\n  std::string s \u003d \"\";\n  if (s.find(\"42\") !\u003d std::string::npos) {\n    // ...\n  }\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/string/basic_string\"\u003eSearch functions for std::basic_string\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/string/basic_string_view\"\u003eSearch functions for std::basic_string_view\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/string/basic_string/npos\"\u003estd::basic_string\u0026lt;CharT,Traits\u0026gt;::npos\u003c/a\u003e \u003c/li\u003e\n  \u003cli\u003e C++ reference - \u003ca href\u003d\"https://en.cppreference.com/w/cpp/string/basic_string_view/npos\"\u003estd::basic_string_view\u0026lt;CharT,Traits\u0026gt;::npos\u003c/a\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S991",
    "name": "\"\u003ctime.h\u003e\" should not be used",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eIncludes \u003ccode\u003etime\u003c/code\u003e, \u003ccode\u003estrftime\u003c/code\u003e. This library is associated with clock times. Various aspects are implementation dependent or\nunspecified, such as the formats of times. If any of the facilities of \u003ccode\u003etime.h\u003c/code\u003e are used, then the exact implementation for the compiler\nbeing used must be determined, and a deviation raised.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;time.h\u0026gt;  /* Noncompliant */\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 20.12 - The time handling functions of library \u0026lt;time.h\u0026gt; shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 21.10 - The Standard Library time and date functions shall not be used \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eIncludes \u003ccode\u003etime\u003c/code\u003e, \u003ccode\u003estrftime\u003c/code\u003e. This library is associated with clock times. Various aspects are implementation dependent or\nunspecified, such as the formats of times. If any of the facilities of \u003ccode\u003etime.h\u003c/code\u003e are used, then the exact implementation for the compiler\nbeing used must be determined, and a deviation raised.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;time.h\u0026gt;  /* Noncompliant */\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 20.12 - The time handling functions of library \u0026lt;time.h\u0026gt; shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 21.10 - The Standard Library time and date functions shall not be used \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "lock-in"
    ],
    "deprecatedKeys": [
      "cpp:PPIncludeTime"
    ],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1131",
    "name": "Lines should not end with trailing whitespaces",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "FORMATTED",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eTrailing whitespaces bring no information, they may generate noise when comparing different versions of the same file, and they can create bugs\nwhen they appear after a \u003ccode\u003e\\\u003c/code\u003e marking a line continuation. They should be systematically removed.\u003c/p\u003e\n\u003cp\u003eAn automated code formatter allows to completely avoid this family of issues and should be used wherever possible.\u003c/p\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eTrailing whitespaces bring no information, they may generate noise when comparing different versions of the same file, and they can create bugs\nwhen they appear after a \u003ccode\u003e\\\u003c/code\u003e marking a line continuation. They should be systematically removed.\u003c/p\u003e\n\u003cp\u003eAn automated code formatter allows to completely avoid this family of issues and should be used wherever possible.\u003c/p\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "convention"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S871",
    "name": "C-style and functional notation casts should not be used",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eC++ allows the traditional C-style casts [E.G. \u003ccode\u003e(int) f\u003c/code\u003e] and functional notation casts [E.G. \u003ccode\u003eint(f)\u003c/code\u003e], but adds its own\nforms:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003estatic_cast\u0026lt;type\u0026gt;(expression)\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003econst_cast\u0026lt;type\u0026gt;(expression)\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003edynamic_cast\u0026lt;type\u0026gt;(expression)\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003ereinterpret_cast\u0026lt;type\u0026gt;(expression)\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003estd::bit_cast\u0026lt;type\u0026gt;(expression)\u003c/code\u003e (since C++20) \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eC-style casts and functional notation casts are largely functionally equivalent. However, when they do not invoke a converting constructor, C-style\ncasts are capable of performing dangerous conversions between unrelated types and of changing a variable’s \u003ccode\u003econst\u003c/code\u003e-ness. Attempt to do\nthese things with an explicit C++-style cast, and the compiler will catch the error. Use a C-style or functional notation cast, and it cannot.\u003c/p\u003e\n\u003cp\u003eMoreover, C++20 has introduced a \u003ccode\u003estd::bit_cast\u003c/code\u003e as a way of reinterpreting a value as being of a different type of the same length\npreserving its binary representation. The behavior of such conversion when performed via C-style cast or \u003ccode\u003ereinterpret_cast\u003c/code\u003e is\nundefined.\u003c/p\u003e\n\u003cp\u003eAdditionally, C++-style casts are preferred because they are visually striking. The visual subtlety of a C-style or functional cast may mask that a\ncast has taken place, but a C++-style cast draws attention to itself, and makes the the programmer’s intention explicit.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when C-style cast or functional notation cast is used.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;iostream\u0026gt;\n\nclass Base { };\n\nclass Derived: public Base\n{\npublic:\n  int a;\n};\n\nvoid DoSomethingElse(Derived *ptr)\n{\n  ptr-\u0026gt;a \u003d 42;\n}\n\nvoid DoSomething(const Base *ptr)\n{\n  Derived* derived \u003d (Derived*)ptr; // Noncompliant; inadvertently removes constness\n  DoSomethingElse(derived);\n}\n\nvoid checksBits(float f)\n{\n    int x \u003d *(int*)\u0026amp;f; // Noncompliant; has undefined behavior\n}\n\nint main(int argc, char* argv[])\n{\n  Derived *ptr \u003d new Derived();\n  ptr-\u0026gt;a \u003d 1337;\n\n  DoSomething(ptr);\n\n  std::cout \u0026lt;\u0026lt; ptr-\u0026gt;a \u0026lt;\u0026lt; std::endl; /* 1337 was expected, but 42 is printed */\n\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n/* ... */\n\nvoid DoSomething(const Base *ptr)\n{\n  /* error: static_cast from type \u0027const Base*\u0027 to type \u0027Derived*\u0027 casts away qualifiers */\n  Derived* derived \u003d static_cast\u0026lt;Derived*\u0026gt;(ptr); // Compliant. Compile fails with above error\n  DoSomethingElse(derived);\n}\n\nvoid checksBits(float f)\n{\n    int x \u003d std::bit_cast\u0026lt;int\u0026gt;(f);\n}\n\n/* ... */\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eVoid casts and explicit constructor calls are allowed.\u003c/p\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 5-2-4 - C-style casts (other than void casts) and functional notation casts (other than explicit constructor calls) shall not\n  be used. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eC++ allows the traditional C-style casts [E.G. \u003ccode\u003e(int) f\u003c/code\u003e] and functional notation casts [E.G. \u003ccode\u003eint(f)\u003c/code\u003e], but adds its own\nforms:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ccode\u003estatic_cast\u0026lt;type\u0026gt;(expression)\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003econst_cast\u0026lt;type\u0026gt;(expression)\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003edynamic_cast\u0026lt;type\u0026gt;(expression)\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003ereinterpret_cast\u0026lt;type\u0026gt;(expression)\u003c/code\u003e \u003c/li\u003e\n  \u003cli\u003e \u003ccode\u003estd::bit_cast\u0026lt;type\u0026gt;(expression)\u003c/code\u003e (since C++20) \u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eC-style casts and functional notation casts are largely functionally equivalent. However, when they do not invoke a converting constructor, C-style\ncasts are capable of performing dangerous conversions between unrelated types and of changing a variable’s \u003ccode\u003econst\u003c/code\u003e-ness. Attempt to do\nthese things with an explicit C++-style cast, and the compiler will catch the error. Use a C-style or functional notation cast, and it cannot.\u003c/p\u003e\n\u003cp\u003eMoreover, C++20 has introduced a \u003ccode\u003estd::bit_cast\u003c/code\u003e as a way of reinterpreting a value as being of a different type of the same length\npreserving its binary representation. The behavior of such conversion when performed via C-style cast or \u003ccode\u003ereinterpret_cast\u003c/code\u003e is\nundefined.\u003c/p\u003e\n\u003cp\u003eAdditionally, C++-style casts are preferred because they are visually striking. The visual subtlety of a C-style or functional cast may mask that a\ncast has taken place, but a C++-style cast draws attention to itself, and makes the the programmer’s intention explicit.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue when C-style cast or functional notation cast is used.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;iostream\u0026gt;\n\nclass Base { };\n\nclass Derived: public Base\n{\npublic:\n  int a;\n};\n\nvoid DoSomethingElse(Derived *ptr)\n{\n  ptr-\u0026gt;a \u003d 42;\n}\n\nvoid DoSomething(const Base *ptr)\n{\n  Derived* derived \u003d (Derived*)ptr; // Noncompliant; inadvertently removes constness\n  DoSomethingElse(derived);\n}\n\nvoid checksBits(float f)\n{\n    int x \u003d *(int*)\u0026amp;f; // Noncompliant; has undefined behavior\n}\n\nint main(int argc, char* argv[])\n{\n  Derived *ptr \u003d new Derived();\n  ptr-\u0026gt;a \u003d 1337;\n\n  DoSomething(ptr);\n\n  std::cout \u0026lt;\u0026lt; ptr-\u0026gt;a \u0026lt;\u0026lt; std::endl; /* 1337 was expected, but 42 is printed */\n\n  return 0;\n}\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\n/* ... */\n\nvoid DoSomething(const Base *ptr)\n{\n  /* error: static_cast from type \u0027const Base*\u0027 to type \u0027Derived*\u0027 casts away qualifiers */\n  Derived* derived \u003d static_cast\u0026lt;Derived*\u0026gt;(ptr); // Compliant. Compile fails with above error\n  DoSomethingElse(derived);\n}\n\nvoid checksBits(float f)\n{\n    int x \u003d std::bit_cast\u0026lt;int\u0026gt;(f);\n}\n\n/* ... */\n\u003c/pre\u003e\n\u003ch3\u003eExceptions\u003c/h3\u003e\n\u003cp\u003eVoid casts and explicit constructor calls are allowed.\u003c/p\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 5-2-4 - C-style casts (other than void casts) and functional notation casts (other than explicit constructor calls) shall not\n  be used. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "pitfall"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1011",
    "name": "Classes should not be derived from virtual bases",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThe use of virtual base classes can introduce a number of undefined and potentially confusing behaviours. The use of virtual bases is not\nrecommended.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass B {};\nclass D: public virtual B {}; // Noncompliant, B is a virtual base\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 10-1-1 - Classes should not be derived from virtual bases. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThe use of virtual base classes can introduce a number of undefined and potentially confusing behaviours. The use of virtual bases is not\nrecommended.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass B {};\nclass D: public virtual B {}; // Noncompliant, B is a virtual base\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 10-1-1 - Classes should not be derived from virtual bases. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "based-on-misra"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S2343",
    "name": "Enumeration values should comply with a naming convention",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "IDENTIFIABLE",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eShared coding conventions allow teams to collaborate efficiently. This rule checks that all enumeration values match a provided regular\nexpression.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cp\u003eWith default provided regular expression:\u003c/p\u003e\n\u003cpre\u003e\nenum SomeEnumeration {\n    some  // Non-Compliant\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nenum SomeEnumeration {\n    SOME\n};\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eShared coding conventions allow teams to collaborate efficiently. This rule checks that all enumeration values match a provided regular\nexpression.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cp\u003eWith default provided regular expression:\u003c/p\u003e\n\u003cpre\u003e\nenum SomeEnumeration {\n    some  // Non-Compliant\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nenum SomeEnumeration {\n    SOME\n};\n\u003c/pre\u003e"
      }
    ],
    "params": {
      "format": {
        "key": "format",
        "name": "format",
        "description": "POSIX regular expression used to check the enumeration value names against.",
        "defaultValue": "^[A-Z][A-Z_0-9]*$",
        "type": "STRING",
        "multiple": false,
        "possibleValues": []
      }
    },
    "defaultParams": {
      "format": "^[A-Z][A-Z_0-9]*$"
    },
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "convention"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S3432",
    "name": "Destructors should not be called explicitly",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eDestructors are invoked automatically when control leaves the scope in which the object was created. Add an \u003cem\u003eexplicit\u003c/em\u003e destructor call to\nthat, and you end up with undefined behavior because the automatic destructor invocation will be invoked on an object that no longer exists. However\nsometimes it is acceptable to have destructor calls for some specific use-cases, i.e. when it is desired to destroy the object but without releasing\nthe memory.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nMyClass mc;\n//...\nmc.~MyClass();  // Noncompliant\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eDestructors are invoked automatically when control leaves the scope in which the object was created. Add an \u003cem\u003eexplicit\u003c/em\u003e destructor call to\nthat, and you end up with undefined behavior because the automatic destructor invocation will be invoked on an object that no longer exists. However\nsometimes it is acceptable to have destructor calls for some specific use-cases, i.e. when it is desired to destroy the object but without releasing\nthe memory.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nMyClass mc;\n//...\nmc.~MyClass();  // Noncompliant\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "unpredictable"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1133",
    "name": "Deprecated code should be removed",
    "defaultSeverity": "INFO",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eThis rule is meant to be used as a way to track code which is marked as being deprecated. Deprecated code should eventually be removed.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n// C++14 attribute\n[[deprecated]] // Noncompliant\nvoid fun();\n\n// GNU attribute\n__attribute__((deprecated)) // Noncompliant\nvoid fun();\n\n// Microsoft attribute\n__declspec(deprecated) // Noncompliant\nvoid fun();\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eThis rule is meant to be used as a way to track code which is marked as being deprecated. Deprecated code should eventually be removed.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n// C++14 attribute\n[[deprecated]] // Noncompliant\nvoid fun();\n\n// GNU attribute\n__attribute__((deprecated)) // Noncompliant\nvoid fun();\n\n// Microsoft attribute\n__declspec(deprecated) // Noncompliant\nvoid fun();\n\u003c/pre\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "obsolete"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S2342",
    "name": "Enumeration names should comply with a naming convention",
    "defaultSeverity": "MINOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "IDENTIFIABLE",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eShared naming conventions allow teams to collaborate efficiently. This rule checks that all \u003ccode\u003eenum\u003c/code\u003e names match a provided regular\nexpression.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cp\u003eWith default provided regular expression \u003ccode\u003e^[A-Z][a-zA-Z0-9]*$\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\nenum someEnumeration { // Noncompliant\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nenum SomeEnumeration {\n};\n\u003c/pre\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eShared naming conventions allow teams to collaborate efficiently. This rule checks that all \u003ccode\u003eenum\u003c/code\u003e names match a provided regular\nexpression.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cp\u003eWith default provided regular expression \u003ccode\u003e^[A-Z][a-zA-Z0-9]*$\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\nenum someEnumeration { // Noncompliant\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nenum SomeEnumeration {\n};\n\u003c/pre\u003e"
      }
    ],
    "params": {
      "format": {
        "key": "format",
        "name": "format",
        "description": "POSIX regular expression used to check the enumeration names against",
        "defaultValue": "^[A-Z][a-zA-Z0-9]*$",
        "type": "STRING",
        "multiple": false,
        "possibleValues": []
      }
    },
    "defaultParams": {
      "format": "^[A-Z][a-zA-Z0-9]*$"
    },
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "convention"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S990",
    "name": "\"abort\", \"exit\", \"getenv\" and \"system\" from \u003cstdlib.h\u003e should not be used",
    "defaultSeverity": "CRITICAL",
    "type": "BUG",
    "cleanCodeAttribute": "CONVENTIONAL",
    "defaultImpacts": {
      "RELIABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003e\u0026lt;stdlib.h\u0026gt;\u003c/code\u003e\u0027s \u003ccode\u003eabort\u003c/code\u003e, \u003ccode\u003eexit\u003c/code\u003e, \u003ccode\u003egetenv\u003c/code\u003e, and \u003ccode\u003esystem\u003c/code\u003e have implementation-defined\nbehaviors, and should therefore be avoided.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;stdlib.h\u0026gt;\n\nvoid f( ) {\n  exit(0); // Noncompliant\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 20.11 - The library functions abort, exit, getenv and system from library \u0026lt;stdlib.h\u0026gt; shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 18-0-3 - The library functions abort, exit, getenv and system from library \u0026lt;cstdlib\u0026gt; shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 21.8 - The library functions abort, exit, getenv and system of \u0026lt;stdlib.h\u0026gt; shall not be used \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003ccode\u003e\u0026lt;stdlib.h\u0026gt;\u003c/code\u003e\u0027s \u003ccode\u003eabort\u003c/code\u003e, \u003ccode\u003eexit\u003c/code\u003e, \u003ccode\u003egetenv\u003c/code\u003e, and \u003ccode\u003esystem\u003c/code\u003e have implementation-defined\nbehaviors, and should therefore be avoided.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\n#include \u0026lt;stdlib.h\u0026gt;\n\nvoid f( ) {\n  exit(0); // Noncompliant\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 20.11 - The library functions abort, exit, getenv and system from library \u0026lt;stdlib.h\u0026gt; shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 18-0-3 - The library functions abort, exit, getenv and system from library \u0026lt;cstdlib\u0026gt; shall not be used. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 21.8 - The library functions abort, exit, getenv and system of \u0026lt;stdlib.h\u0026gt; shall not be used \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "cert",
      "misra-c++2008",
      "misra-c2004",
      "misra-c2012"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1013",
    "name": "Accessible base classes should not be both \"virtual\" and non-virtual in the same hierarchy",
    "defaultSeverity": "MINOR",
    "type": "BUG",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "RELIABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eIf a base class is both \u003ccode\u003evirtual\u003c/code\u003e and non-virtual in a multiple inheritance hierarchy then there will be at least two copies of the base\nclass sub-object in the derived object. This may not be consistent with developer expectations.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass A {};\nclass B1: public virtual A {};\nclass B2: public virtual A {};\nclass B3: public A {};\nclass C: public B1, B2, B3 {}; // Noncompliant, A is both virtual (through B1 and B2) and non-virtual (through B3)\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nclass A {};\nclass B1: public virtual A {};\nclass B2: public virtual A {};\nclass B3: public virtual A {};\nclass C: public B1, B2, B3 {}; // Compliant, A is always virtual\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 10-1-3 - An accessible base class shall not be both virtual and non-virtual in the same hierarchy. \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eIf a base class is both \u003ccode\u003evirtual\u003c/code\u003e and non-virtual in a multiple inheritance hierarchy then there will be at least two copies of the base\nclass sub-object in the derived object. This may not be consistent with developer expectations.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass A {};\nclass B1: public virtual A {};\nclass B2: public virtual A {};\nclass B3: public A {};\nclass C: public B1, B2, B3 {}; // Noncompliant, A is both virtual (through B1 and B2) and non-virtual (through B3)\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nclass A {};\nclass B1: public virtual A {};\nclass B2: public virtual A {};\nclass B3: public virtual A {};\nclass C: public B1, B2, B3 {}; // Compliant, A is always virtual\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 10-1-3 - An accessible base class shall not be both virtual and non-virtual in the same hierarchy. \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": false,
    "language": "CPP",
    "tags": [
      "based-on-misra"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1134",
    "name": "Track uses of \"FIXME\" tags",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eFIXME\u003c/code\u003e tags are commonly used to mark places where a bug is suspected, but which the developer wants to deal with later.\u003c/p\u003e\n\u003cp\u003eSometimes the developer will not have the time or will simply forget to get back to that tag.\u003c/p\u003e\n\u003cp\u003eThis rule is meant to track those tags and to ensure that they do not go unnoticed.\u003c/p\u003e\n\u003cpre\u003e\nint Divide(int numerator, int denominator)\n{\n    return numerator / denominator; // FIXME denominator value might be 0\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/546\"\u003eMITRE, CWE-546 - Suspicious Comment\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003ccode\u003eFIXME\u003c/code\u003e tags are commonly used to mark places where a bug is suspected, but which the developer wants to deal with later.\u003c/p\u003e\n\u003cp\u003eSometimes the developer will not have the time or will simply forget to get back to that tag.\u003c/p\u003e\n\u003cp\u003eThis rule is meant to track those tags and to ensure that they do not go unnoticed.\u003c/p\u003e\n\u003cpre\u003e\nint Divide(int numerator, int denominator)\n{\n    return numerator / denominator; // FIXME denominator value might be 0\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003ch3\u003eDocumentation\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/546\"\u003eMITRE, CWE-546 - Suspicious Comment\u003c/a\u003e \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cwe"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S4524",
    "name": "\"default\" clauses should be first or last",
    "defaultSeverity": "CRITICAL",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "FORMATTED",
    "defaultImpacts": {
      "MAINTAINABILITY": "HIGH"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eswitch\u003c/code\u003e can contain a \u003ccode\u003edefault\u003c/code\u003e clause for various reasons: to handle unexpected values, to show that all the cases were\nproperly considered, etc.\u003c/p\u003e\n\u003cp\u003eFor readability purposes, to help a developer quickly spot the default behavior of a \u003ccode\u003eswitch\u003c/code\u003e statement, it is recommended to put the\n\u003ccode\u003edefault\u003c/code\u003e clause at the beginning or the end of the \u003ccode\u003eswitch\u003c/code\u003e statement.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue if the \u003ccode\u003edefault\u003c/code\u003e clause is not the first or the last one of the \u003ccode\u003eswitch\u003c/code\u003e\u0027s cases.\u003c/p\u003e\n\u003cpre\u003e\nswitch (param) {\n  case 0:\n    doSomething();\n    break;\n  default: // Noncompliant: default clause should be the first or last one\n    error();\n    break;\n  case 1:\n    doSomethingElse();\n    break;\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 15.3 - The final clause of a switch statement shall be the default clause \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 6-4-6 - The final clause of a switch statement shall be the default-clause \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 16.4 - Every switch statement shall have a default label \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 16.5 - A default label shall appear as either the first or the last switch label of a switch statement \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003e\u003ccode\u003eswitch\u003c/code\u003e can contain a \u003ccode\u003edefault\u003c/code\u003e clause for various reasons: to handle unexpected values, to show that all the cases were\nproperly considered, etc.\u003c/p\u003e\n\u003cp\u003eFor readability purposes, to help a developer quickly spot the default behavior of a \u003ccode\u003eswitch\u003c/code\u003e statement, it is recommended to put the\n\u003ccode\u003edefault\u003c/code\u003e clause at the beginning or the end of the \u003ccode\u003eswitch\u003c/code\u003e statement.\u003c/p\u003e\n\u003cp\u003eThis rule raises an issue if the \u003ccode\u003edefault\u003c/code\u003e clause is not the first or the last one of the \u003ccode\u003eswitch\u003c/code\u003e\u0027s cases.\u003c/p\u003e\n\u003cpre\u003e\nswitch (param) {\n  case 0:\n    doSomething();\n    break;\n  default: // Noncompliant: default clause should be the first or last one\n    error();\n    break;\n  case 1:\n    doSomethingElse();\n    break;\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 15.3 - The final clause of a switch statement shall be the default clause \u003c/li\u003e\n  \u003cli\u003e MISRA C++:2008, 6-4-6 - The final clause of a switch statement shall be the default-clause \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 16.4 - Every switch statement shall have a default label \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 16.5 - A default label shall appear as either the first or the last switch label of a switch statement \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "misra-c2004",
      "misra-c2012"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1135",
    "name": "Track uses of \"TODO\" tags",
    "defaultSeverity": "INFO",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "COMPLETE",
    "defaultImpacts": {
      "MAINTAINABILITY": "LOW"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eDevelopers often use \u003ccode\u003eTODO\u003c/code\u003e tags to mark areas in the code where additional work or improvements are needed but are not implemented\nimmediately. However, these \u003ccode\u003eTODO\u003c/code\u003e tags sometimes get overlooked or forgotten, leading to incomplete or unfinished code. This code smell\nclass aims to identify and address such unattended \u003ccode\u003eTODO\u003c/code\u003e tags to ensure a clean and maintainable codebase. This description will explore\nwhy this is a problem and how it can be fixed to improve the overall code quality.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eUnattended \u003ccode\u003eTODO\u003c/code\u003e tags in code can have significant implications for the development process and the overall codebase.\u003c/p\u003e\n\u003cp\u003eIncomplete Functionality: When developers leave \u003ccode\u003eTODO\u003c/code\u003e tags without implementing the corresponding code, it results in incomplete\nfunctionality within the software. This can lead to unexpected behavior or missing features, adversely affecting the end-user experience.\u003c/p\u003e\n\u003cp\u003eMissed Bug Fixes: If developers do not promptly address \u003ccode\u003eTODO\u003c/code\u003e tags, they might overlook critical bug fixes and security updates.\nDelayed bug fixes can result in more severe issues and increase the effort required to resolve them later.\u003c/p\u003e\n\u003cp\u003eImpact on Collaboration: In team-based development environments, unattended \u003ccode\u003eTODO\u003c/code\u003e tags can hinder collaboration. Other team members\nmight not be aware of the intended changes, leading to conflicts or redundant efforts in the codebase.\u003c/p\u003e\n\u003cp\u003eCodebase Bloat: Accumulation of unattended \u003ccode\u003eTODO\u003c/code\u003e tags over time can clutter the codebase and make it difficult to distinguish between\nwork in progress and completed code. This bloat can make it challenging to maintain an organized and efficient codebase.\u003c/p\u003e\n\u003cp\u003eAddressing this code smell is essential to ensure a maintainable, readable, reliable codebase and promote effective collaboration among\ndevelopers.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid foo() {\n  // TODO\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/546\"\u003eMITRE, CWE-546\u003c/a\u003e - Suspicious Comment \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eDevelopers often use \u003ccode\u003eTODO\u003c/code\u003e tags to mark areas in the code where additional work or improvements are needed but are not implemented\nimmediately. However, these \u003ccode\u003eTODO\u003c/code\u003e tags sometimes get overlooked or forgotten, leading to incomplete or unfinished code. This code smell\nclass aims to identify and address such unattended \u003ccode\u003eTODO\u003c/code\u003e tags to ensure a clean and maintainable codebase. This description will explore\nwhy this is a problem and how it can be fixed to improve the overall code quality.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eUnattended \u003ccode\u003eTODO\u003c/code\u003e tags in code can have significant implications for the development process and the overall codebase.\u003c/p\u003e\n\u003cp\u003eIncomplete Functionality: When developers leave \u003ccode\u003eTODO\u003c/code\u003e tags without implementing the corresponding code, it results in incomplete\nfunctionality within the software. This can lead to unexpected behavior or missing features, adversely affecting the end-user experience.\u003c/p\u003e\n\u003cp\u003eMissed Bug Fixes: If developers do not promptly address \u003ccode\u003eTODO\u003c/code\u003e tags, they might overlook critical bug fixes and security updates.\nDelayed bug fixes can result in more severe issues and increase the effort required to resolve them later.\u003c/p\u003e\n\u003cp\u003eImpact on Collaboration: In team-based development environments, unattended \u003ccode\u003eTODO\u003c/code\u003e tags can hinder collaboration. Other team members\nmight not be aware of the intended changes, leading to conflicts or redundant efforts in the codebase.\u003c/p\u003e\n\u003cp\u003eCodebase Bloat: Accumulation of unattended \u003ccode\u003eTODO\u003c/code\u003e tags over time can clutter the codebase and make it difficult to distinguish between\nwork in progress and completed code. This bloat can make it challenging to maintain an organized and efficient codebase.\u003c/p\u003e\n\u003cp\u003eAddressing this code smell is essential to ensure a maintainable, readable, reliable codebase and promote effective collaboration among\ndevelopers.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nvoid foo() {\n  // TODO\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/546\"\u003eMITRE, CWE-546\u003c/a\u003e - Suspicious Comment \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "cwe"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S2589",
    "name": "Boolean expressions should not be gratuitous",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "LOGICAL",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003cp\u003eGratuitous boolean expressions are conditions that do not change the evaluation of a program. This issue can indicate logical errors and affect the\ncorrectness of an application, as well as its maintainability.\u003c/p\u003e\n\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eControl flow constructs like \u003ccode\u003eif\u003c/code\u003e-statements allow the programmer to direct the flow of a program depending on a boolean expression.\nHowever, if the condition is always true or always false, only one of the branches will ever be executed. In that case, the control flow construct and\nthe condition no longer serve a purpose; they become \u003cem\u003egratuitous\u003c/em\u003e.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eThe presence of gratuitous conditions can indicate a logical error. For example, the programmer \u003cem\u003eintended\u003c/em\u003e to have the program branch into\ndifferent paths but made a mistake when formulating the branching condition. In this case, this issue might result in a bug and thus affect the\nreliability of the application. For instance, it might lead to the computation of incorrect results.\u003c/p\u003e\n\u003cp\u003eAdditionally, gratuitous conditions and control flow constructs introduce unnecessary complexity. The source code becomes harder to understand, and\nthus, the application becomes more difficult to maintain.\u003c/p\u003e\n\u003ch2\u003eHow to fix it\u003c/h2\u003e\n\u003cp\u003eGratuitous boolean expressions are suspicious and should be carefully removed from the code.\u003c/p\u003e\n\u003cp\u003eFirst, the boolean expression in question should be closely inspected for logical errors. If a mistake was made, it can be corrected so the\ncondition is no longer gratuitous.\u003c/p\u003e\n\u003cp\u003eIf it becomes apparent that the condition is actually unnecessary, it can be removed. The associated control flow construct (e.g., the\n\u003ccode\u003eif\u003c/code\u003e-statement containing the condition) will be adapted or even removed, leaving only the necessary branches.\u003c/p\u003e\n\u003ch3\u003eCode examples\u003c/h3\u003e\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\na \u003d true;\nif (a) { // Noncompliant\n  doSomething();\n}\n\nif (b \u0026amp;\u0026amp; a) { // Noncompliant; \"a\" is always \"true\"\n  doSomething();\n}\n\nif (c || !a) { // Noncompliant; \"!a\" is always \"false\"\n  doSomething();\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\na \u003d true;\nif (foo(a)) {\n  doSomething();\n}\n\nif (b) {\n  doSomething();\n}\n\nif (c) {\n  doSomething();\n}\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 13.7 - Boolean operations whose results are invariant shall not be permitted. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 14.3 - Controlling expressions shall not be invariant \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/571\"\u003eMITRE, CWE-571\u003c/a\u003e - Expression is Always True \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/570\"\u003eMITRE, CWE-570\u003c/a\u003e - Expression is Always False \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/5dUxBQ\"\u003eCERT, MSC12-C.\u003c/a\u003e - Detect and remove code that has no effect or is never executed\n  \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "introduction",
        "htmlContent": "\u003cp\u003eGratuitous boolean expressions are conditions that do not change the evaluation of a program. This issue can indicate logical errors and affect the\ncorrectness of an application, as well as its maintainability.\u003c/p\u003e"
      },
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eControl flow constructs like \u003ccode\u003eif\u003c/code\u003e-statements allow the programmer to direct the flow of a program depending on a boolean expression.\nHowever, if the condition is always true or always false, only one of the branches will ever be executed. In that case, the control flow construct and\nthe condition no longer serve a purpose; they become \u003cem\u003egratuitous\u003c/em\u003e.\u003c/p\u003e\n\u003ch3\u003eWhat is the potential impact?\u003c/h3\u003e\n\u003cp\u003eThe presence of gratuitous conditions can indicate a logical error. For example, the programmer \u003cem\u003eintended\u003c/em\u003e to have the program branch into\ndifferent paths but made a mistake when formulating the branching condition. In this case, this issue might result in a bug and thus affect the\nreliability of the application. For instance, it might lead to the computation of incorrect results.\u003c/p\u003e\n\u003cp\u003eAdditionally, gratuitous conditions and control flow constructs introduce unnecessary complexity. The source code becomes harder to understand, and\nthus, the application becomes more difficult to maintain.\u003c/p\u003e"
      },
      {
        "key": "how_to_fix",
        "htmlContent": "\u003cp\u003eGratuitous boolean expressions are suspicious and should be carefully removed from the code.\u003c/p\u003e\n\u003cp\u003eFirst, the boolean expression in question should be closely inspected for logical errors. If a mistake was made, it can be corrected so the\ncondition is no longer gratuitous.\u003c/p\u003e\n\u003cp\u003eIf it becomes apparent that the condition is actually unnecessary, it can be removed. The associated control flow construct (e.g., the\n\u003ccode\u003eif\u003c/code\u003e-statement containing the condition) will be adapted or even removed, leaving only the necessary branches.\u003c/p\u003e\n\n\u003ch4\u003eNoncompliant code example\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"noncompliant\"\u003e\na \u003d true;\nif (a) { // Noncompliant\n  doSomething();\n}\n\nif (b \u0026amp;\u0026amp; a) { // Noncompliant; \"a\" is always \"true\"\n  doSomething();\n}\n\nif (c || !a) { // Noncompliant; \"!a\" is always \"false\"\n  doSomething();\n}\n\u003c/pre\u003e\n\u003ch4\u003eCompliant solution\u003c/h4\u003e\n\u003cpre data-diff-id\u003d\"1\" data-diff-type\u003d\"compliant\"\u003e\na \u003d true;\nif (foo(a)) {\n  doSomething();\n}\n\nif (b) {\n  doSomething();\n}\n\nif (c) {\n  doSomething();\n}\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C:2004, 13.7 - Boolean operations whose results are invariant shall not be permitted. \u003c/li\u003e\n  \u003cli\u003e MISRA C:2012, 14.3 - Controlling expressions shall not be invariant \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/571\"\u003eMITRE, CWE-571\u003c/a\u003e - Expression is Always True \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://cwe.mitre.org/data/definitions/570\"\u003eMITRE, CWE-570\u003c/a\u003e - Expression is Always False \u003c/li\u003e\n  \u003cli\u003e \u003ca href\u003d\"https://wiki.sei.cmu.edu/confluence/x/5dUxBQ\"\u003eCERT, MSC12-C.\u003c/a\u003e - Detect and remove code that has no effect or is never executed\n  \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "based-on-misra",
      "cert",
      "cwe",
      "misra-c2004",
      "misra-c2012",
      "redundant",
      "suspicious"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  },
  {
    "key": "cpp:S1016",
    "name": "Virtual functions should be declared with the \"virtual\" keyword",
    "defaultSeverity": "MAJOR",
    "type": "CODE_SMELL",
    "cleanCodeAttribute": "CLEAR",
    "defaultImpacts": {
      "MAINTAINABILITY": "MEDIUM"
    },
    "description": "\u003ch2\u003eWhy is this an issue?\u003c/h2\u003e\n\u003cp\u003eFor code compliant with C++98 or C++03 standards, declaring overriding virtual functions with the\u0026nbsp;\u003ccode\u003evirtual\u003c/code\u003e\u0026nbsp;keyword removes\nthe need to check the base class to determine whether a function is virtual.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass Base\n{\n  virtual void f();\n};\nclass Derived : public Base\n{\n  void f(); // Noncompliant, implicitly declared \"virtual\"\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nclass Base\n{\n  virtual void f();\n};\nclass Derived : public Base\n{\n  virtual void f(); // Compliant, explicitly declared \"virtual\"\n};\n\u003c/pre\u003e\n\u003ch2\u003eResources\u003c/h2\u003e\n\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 10-3-2 - Each overriding virtual function shall be declared with the virtual keyword. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e This rule will only trigger with code compliant with C++98 and C++03. For code compliant with C++11 and above see {rule:cpp:S3471} \u003c/li\u003e\n\u003c/ul\u003e",
    "descriptionSections": [
      {
        "key": "root_cause",
        "htmlContent": "\u003cp\u003eFor code compliant with C++98 or C++03 standards, declaring overriding virtual functions with the\u0026nbsp;\u003ccode\u003evirtual\u003c/code\u003e\u0026nbsp;keyword removes\nthe need to check the base class to determine whether a function is virtual.\u003c/p\u003e\n\u003ch3\u003eNoncompliant code example\u003c/h3\u003e\n\u003cpre\u003e\nclass Base\n{\n  virtual void f();\n};\nclass Derived : public Base\n{\n  void f(); // Noncompliant, implicitly declared \"virtual\"\n};\n\u003c/pre\u003e\n\u003ch3\u003eCompliant solution\u003c/h3\u003e\n\u003cpre\u003e\nclass Base\n{\n  virtual void f();\n};\nclass Derived : public Base\n{\n  virtual void f(); // Compliant, explicitly declared \"virtual\"\n};\n\u003c/pre\u003e"
      },
      {
        "key": "resources",
        "htmlContent": "\u003cul\u003e\n  \u003cli\u003e MISRA C++:2008, 10-3-2 - Each overriding virtual function shall be declared with the virtual keyword. \u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRelated rules\u003c/h3\u003e\n\u003cul\u003e\n  \u003cli\u003e This rule will only trigger with code compliant with C++98 and C++03. For code compliant with C++11 and above see {rule:cpp:S3471} \u003c/li\u003e\n\u003c/ul\u003e"
      }
    ],
    "params": {},
    "defaultParams": {},
    "isActiveByDefault": true,
    "language": "CPP",
    "tags": [
      "based-on-misra"
    ],
    "deprecatedKeys": [],
    "educationPrincipleKeys": []
  }
]