/*
 * SonarLint for Visual Studio
 * Copyright (C) 2016-2025 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */

using SonarLint.VisualStudio.Core.ConfigurationScope;
using SonarLint.VisualStudio.IssueVisualization.Models;
using SonarLint.VisualStudio.IssueVisualization.Security.Taint;
using SonarLint.VisualStudio.SLCore.Common.Models;
using SonarLint.VisualStudio.SLCore.Core;
using SonarLint.VisualStudio.SLCore.Service.Rules.Models;

namespace SonarLint.VisualStudio.SLCore.Listeners.UnitTests.Implementation;

[TestClass]
public class TaintVulnerabilityListenerTests
{
    private TaintVulnerabilityListener testSubject;
    private ITaintStore taintStore;
    private ITaintIssueToIssueVisualizationConverter converter;
    private IActiveConfigScopeTracker configScopeTracker;

    [TestMethod]
    public void MefCtor_CheckIsExported() =>
        MefTestHelpers.CheckTypeCanBeImported<TaintVulnerabilityListener, ISLCoreListener>(
            MefTestHelpers.CreateExport<ITaintStore>(),
            MefTestHelpers.CreateExport<ITaintIssueToIssueVisualizationConverter>(),
            MefTestHelpers.CreateExport<IActiveConfigScopeTracker>());

    [TestMethod]
    public void MefCtor_CheckIsSingleton() => MefTestHelpers.CheckIsSingletonMefComponent<TaintVulnerabilityListener>();

    [TestInitialize]
    public void TestInitialize()
    {
        taintStore = Substitute.For<ITaintStore>();
        converter = Substitute.For<ITaintIssueToIssueVisualizationConverter>();
        configScopeTracker = Substitute.For<IActiveConfigScopeTracker>();
        testSubject = new TaintVulnerabilityListener(taintStore, converter, configScopeTracker);
    }

    [TestMethod]
    public void DidChangeTaintVulnerabilities_MismatchingConfiguration_Ignores()
    {
        configScopeTracker.Current.Returns(new ConfigurationScope("Some Config Scope"));

        testSubject.DidChangeTaintVulnerabilities(new ("Some Other Config Scope", [], [], []));

        taintStore.ReceivedCalls().Should().BeEmpty();
    }

    [TestMethod]
    public void DidChangeTaintVulnerabilities_CorrectConfiguration_CallsTaintStore()
    {
        const string rootPath = "some/root";
        const string configurationScopeId = "Some Config Scope";
        configScopeTracker.Current.Returns(new ConfigurationScope(configurationScopeId, RootPath: rootPath));
        var (addedDto1, addedVisualization1) = SetUpDtoConversion(rootPath);
        var (addedDto2, addedVisualization2) = SetUpDtoConversion(rootPath);
        var (updatedDto1, updatedVisualization1) = SetUpDtoConversion(rootPath);
        var closedId = Guid.NewGuid();

        testSubject.DidChangeTaintVulnerabilities(new (configurationScopeId, [closedId], [addedDto1, addedDto2], [updatedDto1]));

        _ = configScopeTracker.Received(1).Current;
        taintStore.Received(1).Update(Arg.Any<TaintVulnerabilitiesUpdate>());
        taintStore
            .ReceivedCalls()
            .Single()
            .GetArguments()[0]
            .Should()
            .BeOfType<TaintVulnerabilitiesUpdate>()
            .Which
            .Should()
            .BeEquivalentTo(new TaintVulnerabilitiesUpdate(configurationScopeId, [addedVisualization1, addedVisualization2], [updatedVisualization1], [closedId]),
                options => options.ComparingByMembers<TaintVulnerabilitiesUpdate>());
    }

    private (TaintVulnerabilityDto dto, IAnalysisIssueVisualization visualization) SetUpDtoConversion(string rootPath)
    {
        var dto = CreateDefaultTaintDto();
        var visualization = CreateAnalysisIssueVisualization();
        converter.Convert(dto, rootPath).Returns(visualization);
        return (dto, visualization);
    }

    private static IAnalysisIssueVisualization CreateAnalysisIssueVisualization()
    {
        var mock = Substitute.For<IAnalysisIssueVisualization>();
        mock.IssueId.Returns(Guid.NewGuid());
        return mock;
    }

    private static TaintVulnerabilityDto CreateDefaultTaintDto() =>
        new(
            Guid.Parse("efa697a2-9cfd-4faf-ba21-71b378667a81"),
            "serverkey",
            true,
            "rulekey:S123",
            "message1",
            "file\\path\\1",
            DateTimeOffset.Now,
            new StandardModeDetails(IssueSeverity.MINOR, RuleType.VULNERABILITY),
            [],
            new TextRangeWithHashDto(1, 2, 3, 4, "hash1"),
            "rulecontext",
            false);
}
