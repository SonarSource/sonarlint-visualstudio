<p><code>emplace</code> enables you to avoid copying or moving the value you are about to insert and, instead, it constructs it in-place with the
arguments provided.</p>
<p>Prefer using <code>emplace</code>, or <code>emplace_hint</code> if all the conditions hold:</p>
<ul>
  <li> You are inserting a single value. </li>
  <li> You are constructing a fresh temporary value just to insert it into the set. </li>
  <li> You expect that the key is not in the set. </li>
</ul>
<p>You should keep the <code>insert</code> in any of the cases below:</p>
<ul>
  <li> You are inserting multiple values in one shot. </li>
  <li> You are inserting a pre-existing value that is constructed for another purpose. </li>
  <li> You are inserting an object that is cheap to move or to copy (e.g., an integer). </li>
  <li> The key you are inserting is likely to be in the set (in this case by using <code>insert</code> you avoid creating a useless temporary node).
  </li>
</ul>
<p>This rule detects calls to <code>insert</code> that lead to the creation of a large temporary object that&nbsp;can be avoided by using the
<code>emplace</code> member function.</p>
<h2>Noncompliant Code Example</h2>
<pre>
struct A {
  int x;
  std::array&lt;std::string, 100&gt; more;// Expensive to copy or move
public:
  A(int x, const std::string&amp; more) : x(x), more({more}) {}
  bool operator&lt;(A const &amp;other) const {
    return x &lt; other.x;
  }
};
std::array&lt;std::string, 3&gt; strs = {"big brown fox", "little kitten", "regular human"};
void f() {
  std::set&lt;A&gt; set;
  for (int i = 0; i &lt; 1'000'000; ++i) {
    set.insert(A{i, strs[i%3]});// Noncompliant
  }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
struct A {
  int x;
  std::array&lt;std::string, 100&gt; more;// Expensive to copy or move
public:
  A(int x, const std::string&amp; more) : x(x), more({more}) {}
  bool operator&lt;(A const &amp;other) const {
    return x &lt; other.x;
  }
};
std::array&lt;std::string, 3&gt; strs = {"big brown fox", "little kitten", "regular human"};
void f() {
  std::set&lt;A&gt; set;
  for (int i = 0; i &lt; 1'000'000; ++i) {
    set.emplace(i, strs[i%3]);// Compliant
  }
}
</pre>
<h2>Exceptions</h2>
<p>You should keep <code>insert</code> for exception safety if your key type is a smart pointer and the argument is a new expression.</p>