<p>When calling <code>std::move</code> on an object, we usually expect the resulting operation to be fast, using move semantic to rip data off the
source object. If, despite the call to <code>std::move</code>, the source object ends up being copied, the code might be unexpectedly slow.</p>
<p>This can happen:</p>
<ul>
  <li> When <code>std::move</code> is called on an object which does not provide a specific move constructor and will resort to copying when requested
  to move. </li>
  <li> When calling <code>std::move</code> with a const argument. </li>
  <li> When passing the result of <code>std::move</code> as a const reference argument. In this case, no object will be moved since itâ€™s impossible to
  call the move constructor from within the function. <code>std::move</code> should only be used when the argument is passed by value or by r-value
  reference. </li>
</ul>
<h2>Noncompliant Code Example</h2>
<pre>
struct MoveWillCopy{
  MoveWillCopy() = default;
  // This user-provided copy constructor prevents the automatic generation of a move constructor
  MoveWillCopy(NonMovable&amp;) = default;
  Data d;
};

void f(MoveWillCopy m);
void f(std::string s);
void g(const std::string &amp;s);

void test() {
  MoveWillCopy m;
  f(std::move(m)); // Noncompliant: std::move is useless on objects like m: Any attempt to move it will copy it

  const std::string constS="***";
  f(std::move(constS)); // Noncompliant: constS will not be moved

  std::string s="****";
  g(std::move(s)); // Noncompliant: s is cast back to const l-value reference. g cannot move from it


}
</pre>
<h2>Compliant Solution</h2>
<pre>
struct Movable{
  Movable() = default;
  // A move constructor is generated by default
  Data d;
};

void f(Movable m);
void f(std::string s);
void g(const std::string &amp;s);

void test() {
  Movables m;
  f(std::move(m)); // Compliant: move constructor is available

  std::string s="****";
  f(std::move(s)); // Compliant:  move constructor is called

  g(s); // Compliant: no misleading std::move is used
}
</pre>
<h2>See</h2>
<ul>
  <li> <a
  href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#es56-write-stdmove-only-when-you-need-to-explicitly-move-an-object-to-another-scope">C++ Core Guidelines ES.56</a> - Write "std::move()" only when you need to explicitly move an object to another scope </li>
</ul>