<p>Since C++17, class template arguments can be automatically deduced by the compiler, either by looking at the arguments of the class constructors or
by using an explicitly defined deduction guide.</p>
<p>Using the class template argument deduction allow to:</p>
<ul>
  <li> Avoid verbose specification of all template parameter types for a class template. </li>
  <li> Avoid writing helper function that only serves the purpose of deducing the type of a class from its arguments. For example,
  <code>std::make_pair</code>. </li>
  <li> Be able to instantiate a class template with hard to spell or unutterable names, such as the closure type of a lambda. </li>
</ul>
<p>This rule raises an issue when explicit class template arguments that can be automatically deduced is specified.</p>
<h2>Noncompliant Code Example</h2>
<pre>
void f() {
    std::vector&lt;int&gt; v1 {1, 2, 3}; // Noncompliant, int could have been deduced
}{code}
</pre>
<h2>Compliant Solution</h2>
<pre>
using namespace std::literals;
void f() {
    std::vector v1 {1, 2, 3}; // Compliant, int could be deduced
    std::vector&lt;std::string&gt; v2 {"a", "b", "c"}; // Compliant, automatic deduction would create a vector&lt;char const *&gt;
    std::vector v3 {"a"s, "b"s, "c"s}; // Still compliant, another option
}
</pre>