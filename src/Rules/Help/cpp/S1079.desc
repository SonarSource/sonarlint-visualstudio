<p>The <code>%s</code> placeholder is used to read a word into a string.</p>
<p>By default, there is no restriction on the length of that word, and the developer is required to pass a sufficiently large buffer for storing
it.</p>
<p>No matter how large the buffer is, there will always be a longer word.</p>
<p>Therefore, programs relying on <code>%s</code> are vulnerable to buffer overflows.</p>
<p>A field width specifier can be used together with the <code>%s</code> placeholder to limit the number of bytes which will by written to the
buffer.</p>
<p>Note that an additional byte is required to store the null terminator.</p>
<h2>Noncompliant Code Example</h2>
<pre>
char buffer[10];
scanf("%s", buffer);      // Noncompliant - will overflow when a word longer than 9 characters is entered
</pre>
<h2>Compliant Solution</h2>
<pre>
char buffer[10];
scanf("%9s", buffer);     // Compliant - will not overflow
</pre>
<h2>See</h2>
<ul>
  <li> <a href="https://owasp.org/www-project-top-ten/2017/A9_2017-Using_Components_with_Known_Vulnerabilities">OWASP Top 10 2017 Category A9</a> -
  Using Components with Known Vulnerabilities </li>
  <li> <a href="https://cwe.mitre.org/data/definitions/120">MITRE, CWE-120</a> - Buffer Copy without Checking Size of Input ('Classic Buffer
  Overflow') </li>
  <li> <a href="https://cwe.mitre.org/data/definitions/676">MITRE, CWE-676</a> - Use of Potentially Dangerous Function </li>
  <li> <a href="https://www.sans.org/top25-software-errors/#cat2">SANS Top 25</a> - Risky Resource Management </li>
</ul>