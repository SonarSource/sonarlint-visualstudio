<p>Throwing an exception from a destructor may result in a call to <code>std::terminate</code> and can introduce undefined behavior, meaning that your
program could be terminated abruptly without being allowed to perform a clean shutdown.</p>
<p>Destructors are usually (implicitly) declared as <code>noexcept</code> by default such that <code>std::terminate</code> is called when they throw
an exception. Destructors may still propagate an exception if they are explicitly declared as <code>noexcept(false)</code>. However, even a destructor
that is declared as <code>noexcept(false)</code> will call <code>std::terminate</code> if it throws during stack unwinding.</p>
<p>A commonly used example that highlights the severity of the underlying problem is presented in what follows: The destructor of a container needs to
call the destructors for all managed objects. Suppose a call to an objectâ€™s destructor throws an exception. In that case, there are only two
<em>conceptual</em> ways to proceed:</p>
<ol>
  <li> Abort destruction. This will result in a partially destroyed object and possibly many more objects whose destructor has not been called. </li>
  <li> Ignore the exception and proceed with destroying the remaining objects. However, this potentially results in more partially destroyed objects,
  if further destructors throw an exception. </li>
</ol>
<p>Both of these options are undesired and hence, whenever an object that is managed using a C++ standard container throws an exception, the behavior
is undefined.</p>
<p>Thus, destructors should never <code>throw</code> exceptions. Instead, they should catch and handle those thrown by the functions they call, and be
<code>noexcept</code>.</p>
<p>This rule raises an issue when a destructor is not <code>noexcept</code>. By default, destructors are <code>noexcept</code>, therefore most of the
time, nothing needs to be written in the source code. A destructor is not <code>noexcept</code> if:</p>
<ul>
  <li> the base class or a data member has a non <code>noexcept</code> destructor, </li>
  <li> the destructor is decorated with the <code>noexcept</code> keyword followed by something that evaluates to false. </li>
</ul>
<h2>Noncompliant Code Example</h2>
<pre>
struct A {
  ~A() noexcept(false) {} // Noncompliant
};

struct C {
  /* ... */
  A a; // This member data prevents automatic declaration of the destructor as noexcept
  ~C() { // Noncompliant
    /* ... */
  }
};
</pre>
<h2>Compliant Solution</h2>
<pre>
struct A {
  ~A() noexcept(true) {}
};

struct C {
  /* ... */
  A a;
  ~C() { // Compliant, noexcept by default
    /* ... */
  }
};
</pre>
<h2>See</h2>
<ul>
  <li> <a href="https://github.com/isocpp/CppCoreGuidelines/blob/036324/CppCoreGuidelines.md#c36-a-destructor-may-not-fail">C++ Core Guidelines
  C.36</a> - A destructor may not fail </li>
  <li> <a href="https://github.com/isocpp/CppCoreGuidelines/blob/036324/CppCoreGuidelines.md#c37-make-destructors-noexcept">C++ Core Guidelines
  C.37</a> - Make destructors noexcept </li>
</ul>