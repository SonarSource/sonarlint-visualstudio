<p><code>auto</code>&nbsp;is a type placeholder that may be used in variable declarations to instruct the compiler to infer the type from the
initializer.</p>
<p>The use of <code>auto</code> reduces unnecessary boilerplate in situations where the type of the variable is apparent from the context (see rule
{rule:cpp:S5827}). In other situations, though, whether <code>auto</code> increases or decreases readability is a matter of personal taste.</p>
<p>In the case of variables initialized from a function that conventionally returns an iterator (e.g. <code>begin</code>, <code>end</code>,
<code>std::find</code>), it is clear that the type of the variable is some iterator. Spelling the exact type of the iterator in such a situation does
not improve the clarity of the code, especially considering the usual verbosity of such types. The same can be told for functions returning
ranges.</p>
<p>This rule raises an issue on the declaration of a variable that is initialized with the return value of a function that conventionally returns an
iterator when the variable is declared with an explicit type equal to the functionâ€™s return type. The detected functions are:</p>
<ul>
  <li> <code>begin</code> and <code>end</code> functions and their const and reverse variants </li>
  <li> standard algorithms that return iterators or ranges </li>
</ul>
<h2>Noncompliant Code Example</h2>
<pre>
std::vector&lt;int&gt;::iterator someFunction(std::vector&lt;int&gt;&amp; v);

void f() {
  std::vector&lt;int&gt; v;
  const std::vector&lt;int&gt;&amp; cv = v;
  std::vector&lt;int&gt;::iterator it1 = v.begin(); // Noncompliant
  std::vector&lt;int&gt;::const_iterator it2 = v.begin(); // Compliant, the type is different
  std::vector&lt;int&gt;::const_iterator it3 = v.cbegin(); // Noncompliant
  std::vector&lt;int&gt;::const_iterator it4 = cv.cbegin(); // Noncompliant
  std::vector&lt;int&gt;::const_iterator it5 = std::begin(cv); // Noncompliant

  std::vector&lt;int&gt;::iterator it6 = std::find(v.begin(), v.end(), 10);  // Noncompliant
  std::vector&lt;int&gt;::iterator it7 = someFunction(10);  // Compliant, the function is not a well known function returning an iterator

   std::map&lt;int, std::string&gt; m;
   if (std::map&lt;int, std::string&gt;::iterator it = m.find(20); it != m.end()) { // Noncompliant
      // do something
  }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
/* ... */

void f() {
  std::vector&lt;int&gt; v;
  const std::vector&lt;int&gt;&amp; cv = v;
  auto it1 = v.begin();
  std::vector&lt;int&gt;::const_iterator it2 = v.begin();
  auto it3 = v.cbegin();
  auto it4 = cv.cbegin();
  auto it5 = std::begin(cv);

  auto it6 = std::find(v.begin(), v.end(), 10);
  std::vector&lt;int&gt;::iterator it7 = someFunction(10);

   std::map&lt;int, std::string&gt; m;
   if (auto it = m.find(20); it != m.end()) {
      // do something
  }
}
</pre>
<h2>See</h2>
<ul>
  <li> {rule:cpp:S5827} - use auto to avoid repetition of types </li>
</ul>