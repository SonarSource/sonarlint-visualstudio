<p>With C++20 coroutines, the <code>co_await</code>/<code>co_yield</code> expression suspends the currently executed coroutine and resumes the
execution of either the caller or the coroutine function or to some already suspended coroutine (including the current coroutine).</p>
<p>The resumption of the coroutine represented by the <code>std::coroutine_handle</code> object is usually performed by calling the
<code>.resume()</code> on it. However, performing such an operation during the execution of <code>await_suspend</code> (that is part of
<code>co_await</code> expression evaluation) will preserve the activation frame of the <code>await_suspend</code> function and the calling code on the
stack. This may lead to stack overflows in a situation where the chain of directly resumed coroutines is deep enough.</p>
<p>The use of the symmetric transfer may avoid this problem. When the <code>await_suspend</code> function returns a
<code>std::coroutine_handle</code>, the compiler will automatically use this handle to resume its coroutine after <code>await_suspend</code> returns
(and its activation frame is removed from the stack). Or, when a <code>std::noop_coroutine_handle</code> is returned, the execution will be passed to
the caller.</p>
<p>Symmetric transfer solution can also be used to resume the current coroutine (by returning handle passed as the parameter). However, in such cases,
conditional suspension can be a more optimal solution.</p>
<p>This rule raises an issue on <code>await_suspend</code> functions that could use symmetric transfer.</p>
<h2>Noncompliant Code Example</h2>
<pre>
struct InvokeOtherAwaiter {
  /* .... */
  void await_suspend(std::coroutine_handle&lt;PromiseType&gt; current) {
    if (auto other = current.promise().other_handle) {
      other.resume(); // Noncompliant
    }
  }
};

struct WaitForAwaiter {
  Event&amp; event;
  /* .... */
  void await_suspend(std::coroutine_handle&lt;&gt; current) {
    if (bool ready = event.register_callback(current)) {
      current.resume(); // Noncompliant
    }
  }
};

struct BufferedExecutionAwaiter {
  std::queue&lt;std::coroutine_handle&lt;&gt;&gt;&amp; taskQueue;
  /* .... */
  void await_suspend(std::coroutine_handle&lt;&gt; current) {
    if (taskQueue.empty()) {
      current.resume(); // Noncompliant
    }
    auto next = taskQueue.front();
    taskQueue.pop();
    taskQueue.push(current);
    next.resume(); // Noncompliant
  }
};
</pre>
<h2>Compliant Solution</h2>
<pre>
struct InvokeOtherAwaiter {
  /* .... */
  std::coroutine_handle&lt;&gt; await_suspend(std::coroutine_handle&lt;PromiseType&gt; current) {
    if (auto other = current.promise().other_handle) {
      return other;
    } else {
      return std::noop_coroutine();
    }
  }
};

struct WaitForAwaiter {
  Event&amp; event;
  /* .... */
  std::coroutine_handle&lt;&gt; await_suspend(std::coroutine_handle&lt;&gt; current) {
    if (bool ready = event.register_callback(current)) {
      return current;
    } else {
      return std::noop_coroutine()
    }
  }
  // Alternatively
  bool await_suspend(std::coroutine_handle&lt;&gt; current) {
    return !event.register_callback(current);
  }
};

struct BufferedExecutionAwaiter {
  std::queue&lt;std::coroutine_handle&lt;&gt;&gt;&amp; taskQueue;
  /* .... */
  std::coroutine_handle&lt;&gt; await_suspend(std::coroutine_handle&lt;&gt; current) {
    if (taskQueue.empty()) {
       return current;
    }
    auto next = list.front();
    taskQueue.pop();
    taskQueue.push(current);
    return next;
  }
};
</pre>
<h2>See</h2>
<p>{rule:cpp:S6366} - conditionally suspending current coroutine in optimal way</p>