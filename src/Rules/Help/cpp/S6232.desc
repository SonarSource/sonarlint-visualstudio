<p>C++20 introduced the <code>std::bit_cast</code> function. It standardizes the diverse and sub-optimal approaches of reinterpreting a value as a
different type of the same length preserving its binary representation.</p>
<p>One of the superseded solutions, know as "union type-punning", is to use a <code>union</code> with two members with types corresponding to the
source and the target types of the cast. The operation is performed by saving the value in the member with source type and then reading the value of
the target type. Despite being allowed in C, this operation has undefined behavior according to C++ standard and should be replaced by either
<code>std::bit_cast</code> (or <code>std::memcpy</code>).</p>
<p>This rule raises an issue on any use of a <code>union</code> that should be replaced with <code>std::bit_cast</code>.</p>
<h2>Noncompliant Code Example</h2>
<pre>
float fastInvSqrt(float number)
  constexpr float threehalfs = 1.5F;
  const float x2 = number * 0.5F;

  union {
     float f;
     uint32_t i;
  } conv;
  conv.f = number
  conv.i = 0x5f3759df - (conv.i &gt;&gt; 1);  // Noncompliant: undefined behavior
  conv.f *= threehalfs - (x2 * conv.f * conv.f); // Noncompliant: undefined behavior
  return conv.f;
}
</pre>
<h2>Compliant Solution</h2>
<pre>
float fastInvSqrt(float number) {
  constexpr float threehalfs = 1.5F;
  const float x2 = number * 0.5F;

  auto i = std::bit_cast&lt;std::uint32_t&gt;(number);
  i  = 0x5f3759df - (i &gt;&gt; 1);
  auto result = std::bit_cast&lt;float&gt;(i);
  result  *= threehalfs - (x2 * result * result);
  return result;
}
</pre>
<h2>See</h2>
<ul>
  <li> {rule:cpp:S6181} - replacing <code>std::memcpy</code> with <code>std::bit_cast</code>. </li>
</ul>