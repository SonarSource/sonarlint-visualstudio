<p><em>Mutexes</em> are synchronization primitives that allow to manage concurrency. It is a common situation to have to use multiple <em>mutexes</em>
to protect multiple resources with different access patterns.</p>
<p>In such a situation, it is crucial to define an order on the set of all <em>mutexes</em>.</p>
<p>This order should be strictly followed when <em>locking</em> <em>mutexes</em>.</p>
<p>The reverse order should be strictly followed when <em>unlocking</em> <em>mutexes</em>.</p>
<p>Failure in doing so can lead to <em>deadlocks</em>.</p>
<p>In C++, an easy way to make sure the unlocks are called in reverse order from the lock is to wrap the lock/unlock operations in a RAII class (since
destructors of local variables are called in reverse order of their creation).</p>
<p>If instead of <code>pthread_mutex_t</code> you are using <code>std::mutex</code>, there are other mechanisms that allow you to avoid deadlocks in
that case, see {rule:cpp:S5524}.</p>
<h2>Noncompliant Code Example</h2>
<pre>
pthread_mutex_t mtx1,mtx2;

void bad(void)
{
  pthread_mutex_lock(&amp;mtx1);
  pthread_mutex_lock(&amp;mtx2);
  pthread_mutex_unlock(&amp;mtx1);
  pthread_mutex_unlock(&amp;mtx2);
}
</pre>
<h2>Compliant Solution</h2>
<pre>
pthread_mutex_t mtx1, mtx2; // if both have to be locked, mtx1 should always be locked before mtx2

void good(void)
{
  pthread_mutex_lock(&amp;mtx1);
  pthread_mutex_lock(&amp;mtx2);
  pthread_mutex_unlock(&amp;mtx2);
  pthread_mutex_unlock(&amp;mtx1);
}
</pre>