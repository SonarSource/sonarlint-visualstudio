<p><em>Forwarding references</em> (also known as <em>universal references</em>) provide the ability to write a template that can deduce and accept any
kind of reference to the object (<em>rvalue</em>/<em>lvalue</em> <em>mutable</em>/<em>const</em>). This enables the creation of a perfect forwarding
constructor for wrapper types, which allows a wrapper to be constructed with any type that the underlying type can be constructed with:</p>
<pre>
template&lt;typename T&gt;
class Wrapper {
public:
  Wrapper() = default;
  Wrapper(const Wrapper&amp; other) : value(other.value) {}

  template&lt;typename U&gt;
  Wrapper(U&amp;&amp; u) // forwarding constructor
    : value(std::forward&lt;U&gt;(u))
  {}

private:
  T value;
};
</pre>
<p>However, this constructor is too greedy: It will be preferred by overload resolution over the copy constructor as soon as the argument type is
slightly different from a <code>const Wrapper&amp;</code>. For instance, when passing a non-const <em>lvalue</em>, calling the copy constructor
requires a benign non-const to const conversion, while the forwarding reference parameter is an exact match, and will therefore be selected. This is
usually not the correct behaviour.</p>
<pre>
Wrapper&lt;int&gt; w;
Wrapper&lt;int&gt; const cw;
Wrapper&lt;int&gt; w2(cw); // ok, calls Wrapper(Wrapper const&amp; other)
Wrapper&lt;int&gt; w3(w); // ill-formed, calls Wrapper(U&amp;&amp; u) with U = Wrapper&lt;int&gt;&amp;
</pre>
<p>The greediness of forwarding references is a general problem, but it is even stronger for constructors that can be called with a single argument of
<em>forwarding reference</em> type (including variadic template constructors), because in that case they compete with copy or move constructors.</p>
<p>To eliminate this pitfall, such constructors should be constrained in a way that it is not considered a candidate when <code>U&amp;&amp;</code> is
a reference to the class type or to a class derived from the class type. In the previous example, this can be achieved by adding to the forwarding
reference constructor:</p>
<ul>
  <li> A check of the concept <code>!same_as&lt;remove_cvref_t&lt;U&gt;, Wrapper&gt;</code> </li>
  <li> A check of type predicate <code>!is_same_v&lt;remove_cvref_t&lt;U&gt;, Wrapper&gt;</code>, or </li>
  <li> An <code>enable_if</code> with the equivalent condition. </li>
</ul>
<p>If <code>Wrapper</code> were a base class, those checks would become:</p>
<ul>
  <li> The concept <code>derived_from&lt;std::remove_cvref_t&lt;U&gt;, Wrapper&gt;</code> </li>
  <li> A type-predicate <code>!is_base_of_v&lt;Wrapper, std::remove_cvref_t&lt;U&gt;&gt;</code>, or </li>
  <li> An <code>enable_if</code> with the equivalent condition. </li>
</ul>
<p>The concept-based solutions require C++20; while the <code>enable_if</code> solution, which is more cumbersome to write, can always be used.</p>
<p>This rule raises an issue when a class has a template constructor that can be called with a single argument bound to a forwarding reference
parameter, and that constructor is not constrained in one of the previously mentioned ways. There are other ways to ensure that such a constructor
cannot be used for objects of the same type, but this rule only detects explicit checks.</p>
<h2>Noncompliant Code Example</h2>
<pre>
template&lt;typename T&gt;
class Wrapper {
public:
  Wrapper(Wrapper const&amp; other) : value(other.value) {}

  template&lt;typename U&gt;
  Wrapper(U&amp;&amp; u) // noncompliant
    : value(std::forward&lt;U&gt;(u))
  {}

private:
  T value;
};

template&lt;typename T&gt;
class OtherWrapper {
public:
  OtherWrapper(OtherWrapper const&amp; other) = default;

  template&lt;typename U&gt;
    requires std::constructible_from&lt;T, U&gt;
  OtherWrapper(U&amp;&amp; u) // noncompliant, constructible_from check is not sufficient in general
    : value(std::forward&lt;U&gt;(u))
  {}

private:
  T value;
};

template&lt;typename T&gt;
class EmplaceWrapper {
public:
  EmplaceWrapper(EmplaceWrapper const&amp; other) = default;

  template&lt;typename... Args&gt;
    requires std::constructible_from&lt;T, Args...&gt;
  EmplaceWrapper(Args&amp;&amp;... args) // noncompliant, will compete with copy-constructor
    : value(std::forward&lt;Args&gt;(args)...)
  {}

private:
  T value;
};
</pre>
<h2>Compliant Solution</h2>
<pre>
template&lt;typename T&gt;
class WrapperCpp20 {
public:
  WrapperCpp20(WrapperCpp20 const&amp; other) : value(other.value) {}

  template&lt;typename U&gt;
    requires (!std::same_as&lt;WrapperCpp20, std::remove_cvref_t&lt;U&gt;&gt;)
  WrapperCpp20(U&amp;&amp; u)
    : value(std::forward&lt;U&gt;(u))
  {}

private:
  T value;
};

template&lt;typename T&gt;
class WrapperCpp11 {
public:
  WrapperCpp11(WrapperCpp11 const&amp; other) : value(other.value) {}

  template&lt;typename U,
    typename std::enable_if&lt;
      !std::is_same&lt;
        WrapperCpp11,
        typename std::remove_cv&lt;typename std::remove_reference&lt;U&gt;::type&gt;::type
      &gt;::value,
      int&gt;::type /* Unnamed */ = 0&gt;
  WrapperCpp11(U&amp;&amp; u)
    : value(std::forward&lt;U&gt;(u))
 {}

private:
  T value;
};

template&lt;typename T&gt;
class OtherWrapper {
public:
  OtherWrapper(OtherWrapper const&amp; other) : value(other.value) {}

  template&lt;typename U&gt;
    requires (!std::derived_from&lt;std::remove_cvref_t&lt;U&gt;, OtherWrapper&gt;) &amp;&amp; std::constructible_from&lt;T, U&gt;
  OtherWrapper(U&amp;&amp; u)
    : value(std::forward&lt;U&gt;(u))
  {}

private:
  T value;
};

template&lt;typename T&gt;
class EmplaceWrapper {
public:
  EmplaceWrapper(EmplaceWrapper const&amp; other) = default;

  template&lt;typename... Args&gt;
    requires std::constructible_from&lt;T, Args...&gt;
  EmplaceWrapper(std::in_place_t, Args&amp;&amp;... args)  // compliant, no longer competes with copy-constructor
    : value(std::forward&lt;Args&gt;(args)...)
  {}

private:
  T value;
};
</pre>
<h2>See</h2>
<ul>
  <li> Effective Modern C++ item 29: Avoid overloading on universal references </li>
</ul>