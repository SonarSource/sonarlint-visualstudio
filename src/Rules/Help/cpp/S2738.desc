<p>A general <code>catch</code> block seems like an efficient way to handle multiple possible exceptions. Unfortunately, it traps all exception types,
casting too broad a net, and perhaps mishandling extraordinary cases. Instead, specific exception sub-types should be caught.</p>
<h2>Noncompliant Code Example</h2>
<pre>
try {
  file.open("test.txt");
} catch (...) {  // Noncompliant
  // ...
}
</pre>
<h2>Compliant Solution</h2>
<pre>
try {
  file.open("test.txt");
} catch (std::ifstream::failure e) {
  // ...
}
</pre>
<h2>Exceptions</h2>
<p>There are cases though where you want to catch all exceptions, because no exceptions should be allowed to escape the function, and generic
<code>catch</code> handlers are excluded from the rule:</p>
<ul>
  <li> In the main function </li>
  <li> In a class destructor </li>
  <li> In a <code>noexcept</code> function </li>
  <li> In an <code>extern "C"</code> function </li>
</ul>
<p>Additionally, if the <code>catch</code> handler is throwing an exception (either the same as before, with <code>throw;</code> or a new one that may
make more sense to the callers of the function), or is never exiting (because it calls a <code>noreturn</code> function, for instance
<code>exit</code>), then the accurate type of the exception usually does not matter any longer: this case is excluded too.</p>