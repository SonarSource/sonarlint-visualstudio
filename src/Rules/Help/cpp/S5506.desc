<p><em>Mutexes</em> are synchronization primitives that allow to manage concurrency using a mechanism of <code>lock</code>/<code>unlock</code>.</p>
<p>While explicitly locking or unlocking a <em>mutex</em> is possible, it is error prone. And this is particularly true in complex code paths (or with
exceptions) where it is easy to have a mismatch between <code>lock</code>s and <code>unlock</code>s.</p>
<p>As a result, <em>mutexes</em> should not be locked or unlocked manually.</p>
<p>Adopting the C++ RAII idiom solves this problem by creating an object that will lock the <em>mutex</em> on creation and unlock it on destruction.
Furthermore, using this idiom can also greatly improve the readability of the code.</p>
<p>Several classes are available as RAII wrappers:</p>
<ul>
  <li> <code>std::scoped_lock</code> is the default, most efficient wrapper for simple cases (only available since C++17) </li>
  <li> <code>std::lock_guard</code> is similar to <code>std::scoped_lock</code>, but with less features. It should only be used if you donâ€™t have
  access to <code>std::scoped_lock</code>. </li>
  <li> <code>std::unique_lock</code> allows more manual unlocking/locking again, and should only be used when these features are needed, for instance
  with condition variables. </li>
</ul>
<h2>Noncompliant Code Example</h2>
<pre>
#include &lt;mutex&gt;

class DataItem;

class DataStore {
public:
  bool store(const DataItem &amp;dataItem);
  bool has(const DataItem &amp;dataItem);
};

DataStore sharedDataStore;
std::mutex sharedDataStoreMutex;

bool storeIfRelevantInSharedContext(const DataItem &amp;dataItem) {
  sharedDataStoreMutex.lock(); // Noncompliant
  if (sharedDataStore.has(dataItem)) {
    sharedDataStoreMutex.unlock(); // Noncompliant
    return false;
  }
  bool result = sharedDataStore.store(dataItem);
  sharedDataStoreMutex.unlock(); // Noncompliant
  return result;
}
</pre>
<h2>Compliant Solution</h2>
<pre>
#include &lt;mutex&gt;

class DataItem;

class DataStore {
public:
  bool store(const DataItem &amp;dataItem);
  bool has(const DataItem &amp;dataItem);
};

DataStore sharedDataStore;
std::mutex sharedDataStoreMutex;

bool storeIfRelevantInSharedContext(const DataItem &amp;dataItem) {
  std::scoped_lock&lt;std::mutex&gt; lock(sharedDataStoreMutex);
  if (sharedDataStore.has(dataItem)) {
    return false;
  }
  return sharedDataStore.store(dataItem);
}
</pre>
<h2>See</h2>
<ul>
  <li> <a href="https://github.com/isocpp/CppCoreGuidelines/blob/036324/CppCoreGuidelines.md#cp20-use-raii-never-plain-lockunlock">C++ Core Guidelines
  CP.20</a> - Use RAII, never plain lock()/unlock() </li>
</ul>