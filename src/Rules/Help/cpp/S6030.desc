<p><code>emplace</code> and <code>insert</code> in <code>std::map</code> and <code>std::unordered_map</code> might construct the (key, value) pair,
including the value object, even when it is not necessary.</p>
<p><code>emplace</code> destroys the constructed pair if the key is already present, wasting the effort on construction and destruction of the
value.</p>
<p>If <code>insert</code> was called with a temporary, it leads to an extra copy or move construction and destruction of the temporary.</p>
<p>C++17 introduced <code>try_emplace</code> that does not construct the value if the key is already present in the map and constructs the value in
place if necessary.</p>
<p>In most cases, you should use <code>try_emplace</code>. In particular, if two conditions hold:</p>
<ul>
  <li> You are inserting a single object at a time. </li>
  <li> You are creating a new mapped-to value and/or (key, value) pair just to insert it into the map. </li>
</ul>
<p>You should keep the <code>insert</code> if one of the conditions holds:</p>
<ul>
  <li> The (key, value) pair is already constructed (for another purpose). </li>
  <li> You want to insert multiple (key, value) pairs with a single call. </li>
</ul>
<p>You should keep <code>emplace</code> and <code>emplace_hint</code> if</p>
<ul>
  <li> You use piecewise construction with <code>std::piecewise_construct</code>. </li>
</ul>
<p>This rule detects calls to <code>insert</code> that lead to the construction of a large temporary object, as well as calls to <code>emplace</code>
and <code>emplace_hint</code> with no piecewise construction.</p>
<h2>Noncompliant Code Example</h2>
<pre>
void f() {
  std::map&lt;int, std::string&gt; bodies({{3, "Lorem ipsum..."}});
  bodies.emplace(3, "Lorem ipsum..."); // Noncompliant
  bodies.insert({3, "Lorem ipsum..."}); // Noncompliant
}
</pre>
<h2>Compliant Solution</h2>
<pre>
void f() {
  std::map&lt;int, std::string&gt; bodies({{3, "Lorem ipsum..."}});
  bodies.try_emplace(3, "Lorem ipsum..."); // Compliant
  auto p = std::make_pair(3, "Lorem ipsum..."); // The (key, value) pair is already constructed for another purpose
  bodies.insert(p); // Compliant
  use_the_pair(p);
}
</pre>
<h2>Exceptions</h2>
<p>You should keep <code>insert</code> for exception safety if your mapped-to type is a smart pointer and the argument is a <code>new</code>
expression.</p>