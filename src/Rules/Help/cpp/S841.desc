<p>If an enumerator list is given with no explicit initialization of members, then C/C++ allocates a sequence of integers starting at zero for the
first element and increasing by one for each subsequent element.</p>
<p>An explicit initialization of the first element, as permitted by this rule, forces the allocation of integers to start at the given value. When
adopting this approach it is essential to ensure that the initialization value used is small enough that no subsequent value in the list will exceed
the <code>int</code> storage used by enumeration constants.</p>
<p>Explicit initialization of all items in the list, which is also permissible, prevents the mixing of automatic and manual allocation, which is error
prone.</p>
<p>However, it is then the responsibility of the developer to ensure that all values are in the required range, and that values are not
unintentionally duplicated.</p>
<h2>Noncompliant Code Example</h2>
<pre>
enum color { red = 3, blue, green, yellow = 5 }; // Noncompliant; both green and yellow = 5
</pre>
<h2>Compliant Solution</h2>
<pre>
enum color { red = 3, blue = 4, green = 5, yellow = 5 }; // Compliant
</pre>
<h2>See</h2>
<ul>
  <li> MISRA C:2004, 9.3 - In an enumerator list, the "=" construct shall not be used to explicitly initialize members other than the first, unless
  all items are explicitly initialized. </li>
  <li> MISRA C++:2008, 8-5-3 - In an enumerator list, the = construct shall not be used to explicitly initialize members other than the first, unless
  all items are explicitly initialized. </li>
</ul>