<p><code>std::jthread</code>, introduced in C++20, is a wrapper around <code>std::thread</code>. This way, it has the same functionalities as
<code>std::thread</code>, making the substitution really straightforward, while adding two interesting behaviors:</p>
<ul>
  <li> It joins by default in its destructor. If a <code>std::thread</code> was not joined or detached before being destroyed, a call to
  <code>std::terminate</code> was made. This canâ€™t happen with <code>std::jthread</code>. </li>
  <li> It can be canceled or stopped in some situations by calling <code>request_stop()</code> </li>
</ul>
<p>This rule raises an issue as soon as <code>std::thread</code> is used.</p>
<h2>Noncompliant Code Example</h2>
<pre>
void backgroundTask();
int main() {
  std::thread t(backgroundTask); // Noncompliant
  t.join();
}
</pre>
<h2>Compliant Solution</h2>
<pre>
void backgroundTask();
int main() {
  std::jthread jt(backgroundTask);
}
</pre>
<h2>See</h2>
<ul>
  <li> <a href="https://github.com/isocpp/CppCoreGuidelines/blob/036324/CppCoreGuidelines.md#cp25-prefer-gsljoining_thread-over-stdthread">C++ Core
  Guidelines CP.25</a>&nbsp;- Prefer "gsl::joining_thread" over "std::thread" </li>
</ul>