<p>Slicing is what happens when an object from a derived type is cast to an object of one of its base classes. When this happens, the newly created
object will not have any of the member variables that are specific to the derived type. This is usually not what was intended. Most of the time,
polymorphism is achieved by casting a reference or a pointer to an object of the derived class to a reference or a pointer to an object of a base
class.</p>
<p>Note that it’s usually a good idea to design a base class so that slicing cannot happen (it can be <em>abstract</em>, or
<em>non-copiable</em>).</p>
<h2>Noncompliant Code Example</h2>
<pre>
struct Shape {
  Point position;
  virtual ~Shape() = default;
};
struct Circle : public Shape {
  double radius;
};

void f() {
  vector&lt;Shape&gt; myShapes;
  Circle c;
  myShapes.push_back(c); // Noncompliant. What will be in the vector is a Shape, not a Circle, and won't contain any radius
}
</pre>
<h2>Compliant Solution</h2>
<pre>
void f() {
  vector&lt;unique_ptr&lt;Shape&gt;&gt; myShapes;
  auto c = make_unique&lt;Circle&gt;();
  myShapes.push_back(move(c)); // Compliant. A pointer to Shape that happens to point to a Circle
}
</pre>
<h2>See</h2>
<ul>
  <li> <a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#es63-dont-slice">C++ Core Guidelines ES.63</a> - Don’t slice </li>
</ul>