<p>C++20 introduces the "spaceship" <code>operator&lt;=&gt;</code> that replaces all the other comparison operators in most cases. When this operator
is defined, the compiler can rewrite expressions using <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code> and <code>&gt;=</code> to use this
operator instead. This presents three advantages:</p>
<ul>
  <li> Less code to write (and therefore fewer bugs too), </li>
  <li> Guaranteed consistency between all the comparison operators (for instance, in this situation, <code>a &lt; b</code> and <code>!(a &gt;=
  b)</code> will always return the same value). </li>
  <li> Guaranteed symmetry for comparisons: If you can write <code>a&lt;b</code>, and that operation is resolved through
  <code>operator&lt;=&gt;</code>, you can also write <code>b&lt;a</code>, and get a consistent result. Achieving the same result with classical
  comparison operators require to double the number overloads if <code>a</code> and <code>b</code> are of different types. </li>
</ul>
<p>Additionally, if the <code>operator&lt;=&gt;</code> has the defaulted implementation, the compiler can also implicitly generate a defaulted
implementation of operator==, simplifying the class definition one step further.</p>
<p>Before C++20, if was common to provide only <code>operator&lt;</code> for a class, and ask the user of this class to write all his code only using
this operator (this is what <code>std::map</code> requires of its key type, for instance). It is still advised in this case to replace the operator
with <code>&lt;=&gt;</code>: The quantity of required work is similar, and the user of the class will benefit from a much greater expressivity.</p>
<p>This rule reports user-provided comparison operators (member functions or free functions) <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>
and <code>&gt;=</code>.</p>
<h2>Noncompliant Code Example</h2>
<pre>
class A { // Noncompliant: defines operator&lt; that can be replaced with operator&lt;=&gt;
  int field;
  public:
    bool operator&lt;(const A&amp; other) const {
      return field &lt; other.field;
    }
};
class C;
class B { // Noncompliant: defines 12 comparison operators that can be replaced with 2 operators
  int field;
  public:
    bool operator==(const C&amp;) const;
    bool operator!=(const C&amp;) const;
    bool operator&lt;=(const C&amp;) const;
    bool operator&lt;(const C&amp;) const;
    bool operator&gt;=(const C&amp;) const;
    bool operator&gt;(const C&amp;) const;
    friend bool operator==(const C&amp;, const B&amp;);
    friend bool operator!=(const C&amp;, const B&amp;);
    friend bool operator&lt;=(const C&amp;, const B&amp;);
    friend bool operator&lt;(const C&amp;, const B&amp;);
    friend bool operator&gt;=(const C&amp;, const B&amp;);
    friend bool operator&gt;(const C&amp;, const B&amp;);
};

enum class MyEnum {low = 1, high = 2};
bool operator&lt;(MyEnum lhs, MyEnum rhs) { // Noncompliant: can be replaced with operator&lt;=&gt;
    return static_cast&lt;int&gt;(lhs) &lt; static_cast&lt;int&gt;(rhs);
}
</pre>
<h2>Compliant Solution</h2>
<pre>
class A {
  int field;
  public:
    auto operator&lt;=&gt;(const A&amp; other) const = default;
    // Note that here, operator == will be implicitly defaulted
};
class B { // Compliant. the same comparisons are possible as with the 12 operators
  int field;
  public:
    auto operator&lt;=&gt;(const C&amp;) const;
    auto operator==(const C&amp;) const;
};

enum class MyEnum {low = 1, high = 2};
auto operator&lt;=&gt;(MyEnum lhs, MyEnum rhs) {
    return static_cast&lt;int&gt;(lhs) &lt;=&gt; static_cast&lt;int&gt;(rhs);
}
</pre>
<h2>See</h2>
<ul>
  <li> {rule:cpp:S6186} - Redundant comparison operators should not be defined. </li>
</ul>