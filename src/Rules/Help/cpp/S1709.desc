<p>If you invoked a method with arguments of the wrong type, you would typically expect an error at compile time (if not in the IDE). However, when
the expected parameter is a class with a single-argument constructor, the compiler will implicitly pass the method argument to that constructor to
implicitly create an object of the correct type for the method invocation. Alternately, if the wrong type has a conversion operator to the correct
type, the operator will be called to create an object of the needed type.</p>
<p>But just because you <em>can</em> do something, that doesnâ€™t mean you <em>should</em>, and using implicit conversions makes the execution flow
difficult to understand. Readers may not notice that a conversion occurs, and if they do notice, it will raise a lot of questions: Is the source type
able to convert to the destination type? Is the destination type able to construct an instance from the source? Is it both? And if so, which method is
called by the compiler?</p>
<p>Moreover, implicit promotions can lead to unexpected behavior, so they should be prevented by using the <code>explicit</code> keyword on
single-argument constructors and (C++11) conversion operators. Doing so will prevent the compiler from performing implicit conversions.</p>
<h2>Noncompliant Code Example</h2>
<pre>
struct Bar {
};

struct Foo {
  Foo(Bar&amp; bar); // Noncompliant; allow implicit conversion from 'Bar' to 'Foo'
};

struct Baz {
  operator Foo(); // Noncompliant; allow implicit conversion from 'Baz' to 'Foo'
};

void func(const Foo&amp; b); // this function needs a 'Foo' not a 'Bar' nor a 'Baz'

int test(Bar&amp; bar, Baz&amp; baz) {
  func(bar); // implicit conversion using Foo::Foo(Bar&amp; bar)
  func(baz); // implicit conversion using Baz::operator Foo()
  func(baz);
}
</pre>
<h2>Compliant Solution</h2>
<pre>
struct Bar {
};

struct Foo {
  explicit Foo(Bar&amp; bar); // Compliant, using "explicit" keyword
};

struct Baz {
  Foo asFoo();             // Compliant, explicit function
  explicit operator Foo(); // Compliant, using C++11 "explicit" keyword for conversion function
};

void func(const Foo&amp; b); // this function needs a 'Foo' not a 'Bar' nor a 'Baz'

int test(Bar&amp; bar, Baz&amp; baz) {
  func(Foo(bar));              // explicit conversion using Foo::Foo(Bar&amp; bar)
  func(baz.asFoo());           // explicit conversion using Baz::asFoo()
  func(static_cast&lt;Foo&gt;(baz)); // explicit conversion using Baz::operator Foo()
}
</pre>
<h2>Exceptions</h2>
<p>C++20 introduced conditional <code>explicit(expr)</code> that allows developers to make a constructor or conversion operator conditionally explicit
depending on the value of <code>expr</code>. The new syntax allows a constructor or conversion operator declared with an <code>explicit(expr)</code>
specifier to be implicit when <code>expr</code> evaluates to <code>false</code>. The issue is not raised in such situation.</p>
<p>Additionally, developers can use <code>explicit(false)</code> to mark constructors or conversion operators as intentionally implicit.</p>
<h2>See</h2>
<ul>
  <li> MISRA C++:2008, 12-1-3 - All constructors that are callable with a single argument of fundamental type shall be declared <code>explicit</code>.
  </li>
  <li> <a
  href="https://github.com/isocpp/CppCoreGuidelines/blob/036324/CppCoreGuidelines.md#c46-by-default-declare-single-argument-constructors-explicit">C++
  Core Guidelines C.46</a> - By default, declare single-argument constructors explicit </li>
  <li> <a href="https://github.com/isocpp/CppCoreGuidelines/blob/036324/CppCoreGuidelines.md#c164-avoid-implicit-conversion-operators">C++ Core
  Guidelines C.164</a> - Avoid implicit conversion operators </li>
</ul>