<p><em>Type-constraints</em> provide a terse way to express constraints on the type deduced for a given template parameter or auto placeholder. In a
situation when a type-constraint is applied to a forwarding reference parameter (<code>T&amp;&amp;</code>), the corresponding concept will be checked
against the <em>lvalue reference</em> (if the argument is an <em>lvalue</em>) or the plain type (if the argument is an <em>rvalue</em>).</p>
<p>Even if it is possible to write a check that works for both plain types and references, it requires a dedicated effort, and a naive attempt may
silently fail for one or the other. For instance, a <code>std::copyable</code> constraint is never satisfied for references, regardless of the
referenced type, while a <code>std::copy_constructible</code> constraint always is.</p>
<p>This rule detects forwarding reference parameters that are constrained by the standard-provided concepts using <em>type-constraint</em> syntax.</p>
<h2>Noncompliant Code Example</h2>
<pre>
auto func(std::copy_constructible auto&amp;&amp; arg) // noncompliant
{ /* … */ }

template&lt;std::copyable T&gt;
auto func2(T&amp;&amp; arg)  // noncompliant
{ /* … */ }
</pre>
<h2>Compliant Solution</h2>
<pre>
auto func(auto&amp;&amp; argc)
  requires std::copy_constructible&lt;std::remove_cvref_t&lt;decltype(arg)&gt;&gt;
{ /* … */ }

template&lt;typename T&gt;
  requires std::copyable&lt;std::remove_cvref_t&lt;T&gt;&gt;
auto func2(T&amp;&amp; arg)
{ /* … */ }
</pre>
<h2>Exceptions</h2>
<p>The <code>std::ranges::range</code> concept and its refinements (like <code>std::ranges::forward_range</code>,
<code>std::ranges::bidirectional_range</code>) are designed to handle forwarding references parameters, and will not raise issues for this rule.</p>