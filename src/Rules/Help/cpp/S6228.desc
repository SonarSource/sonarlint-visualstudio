<p>Since integers are usually represented in binary form in computers, it is efficient to check if a given number is a power of two by checking if its
<code>unsigned</code> representation has a single bit set.</p>
<p>In C++ such check could be expressed as <code>x &amp; (x-1) == 0</code>. However, the intent of this expression is unclear. Furthermore, it
requires to take special care for the value <code>0</code>, which would pass the above check, while not having any bit set and not being a power of
two.</p>
<p>This check can be expressed more clearly with the <code>std::has_single_bit</code> function template, introduced in C++20.</p>
<p>This rule reports computations that could be replaced with <code>std::has_single_bit</code> .</p>
<h2>Noncompliant Code Example</h2>
<pre>
void f(unsigned x) {
  if ((x &gt; 0) &amp;&amp; !(x &amp; (x-1))) { // Noncompliant
    // Special algorithm for powers of 2
  }
  // Normal algorithm
}
</pre>
<h2>Compliant Solution</h2>
<pre>
void f(unsigned x) {
  if (std::has_single_bit(x)) {
    // Special algorithm for powers of 2
  }
  // Normal algorithm
}
</pre>