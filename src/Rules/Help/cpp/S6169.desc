<p><code>std::is_constant_evaluated</code> is used to determine whether or not a context is constant-evaluated. This can be useful when, for example,
two different implementations are provided for an algorithm: one, usually slow, for compile-time and the other one, faster, for runtime.</p>
<p>However, some contexts are either always constant-evaluated or never constant-evaluated. In these cases, a call to
<code>std::is_constant_evaluated</code> is unnecessary as it will always return the same result.</p>
<p><code>std::is_constant_evaluated</code> will always return <code>true</code> when called in:</p>
<ul>
  <li> the condition of <code>if constexpr</code> </li>
  <li> the condition of <code>static_assert</code> </li>
  <li> <code>consteval</code> functions </li>
</ul>
<p>And it will always return <code>false</code> in:</p>
<ul>
  <li> non-<code>constexpr</code>/<code>consteval</code> functions </li>
</ul>
<p>This rule raises an issue when <code>std::is_constant_evaluated()</code> is called in an <code>if constexpr</code> or a <code>static_assert</code>
condition, where it is always <code>true</code>.</p>
<h2>Noncompliant Code Example</h2>
<pre>
constexpr double power(double b, int x) {
  if constexpr (std::is_constant_evaluated()) {  // Noncompliant: will always be true
    // compile-time implementation
  } else {
    // runtime implementation
  }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
constexpr double power(double b, int x) {
  if (std::is_constant_evaluated()) {
    // compile-time implementation
  } else {
    // runtime implementation
  }
}
</pre>