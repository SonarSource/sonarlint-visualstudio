<p>To configure an algorithm with a function in C++, you can use one of the following techniques:</p>
<ul>
  <li> A function pointer (see {rule:cpp:S5205} that explains why it is a bad idea) </li>
  <li> An <code>std::function</code> </li>
  <li> A template argument </li>
</ul>
<p>How do you select between an <code>std::function</code> and a template argument?</p>
<p><code>std::function</code> offers the most flexibility. You can store them in a variable, in a container (as <code>std::map&lt;string,
std::function&lt;void(void)&gt;&gt;</code> for instance…​ This flexibility is provided by type erasure: A single <code>std::function</code> can wrap
any kind of functor, as long as the signature is compatible. It also comes with a cost: Due to this type erasure, a compiler will typically not be
able to inline a call to a <code>std::function</code>.</p>
<p>Template parameters, on the other hand, are less flexible. Each functor has its own type, which prevents storing several of them together even if
they all have compatible signatures. But since each template instance knows the type of the functor, calls can be inlined making this a zero-cost
abstraction.</p>
<p>As a conclusion, if the functor can be known at compile-time, you should prefer using a template parameter, if it has to be dynamic,
<code>std::function</code> will give you greater flexibility.</p>
<p>This rule detects function parameters of type <code>std::function</code> that would probably benefit from being replaced by a template parameter.
It does so by looking if the functor is only called inside the function, or if it participates in other operations.</p>
<h2>Noncompliant Code Example</h2>
<pre>
using Criterion = std::function&lt;bool(DataPoint const&amp;)&gt;;
void filter(DataSet* data, Criterion criterion) { // Noncompliant
  for (auto &amp;dataPoint : data) {
    if (criterion(dataPoint)) {
      data.markForRemoval(dataPoint);
    }
  }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
template&lt;class Criterion&gt;
void filter(DataSet* data, Criterion criterion) { // Compliant
  for (auto &amp;dataPoint : data) {
    if (criterion(dataPoint)) {
      data.markForRemoval(dataPoint);
    }
  }
}
</pre>
<h2>Exceptions</h2>
<p>This rule ignores virtual functions, that don’t work well with templates.</p>
<h2>See</h2>
<ul>
  <li> <a href="https://github.com/isocpp/CppCoreGuidelines/blob/036324/CppCoreGuidelines.md#t49-where-possible-avoid-type-erasure">C++ Core
  Guidelines T.49</a> - Where possible, avoid type-erasure </li>
</ul>