<p>A <code>virtual</code> function has an implementation that <em>may</em> be replaced in a child class. A pure <code>virtual</code> has no
implementation, and <em>must</em> be implemented in child classes.</p>
<p>Hiding a base class implementation with a "pure implementation" (<code>=0</code>) is sure to confuse extenders, who may not be aware of the base
class' implementation. Instead, they’ll see there’s no implementation in the class they’re extending and assume that none exists. When that base class
implementation contains crucial functionality such as freeing resources, this could cause future users of the class to introduce bugs.</p>
<p>This rule raises an issue if a pure virtual function overrides a virtual function that is not pure.</p>
<h2>Noncompliant Code Example</h2>
<pre>
struct A {
  virtual void func1();
  virtual void func2() = 0;
};

struct B : A {
  virtual void func1() = 0; // Noncompliant; override non-pure virtual
  virtual void func2() = 0; // Compliant; but useless
};
</pre>
<h2>Compliant Solution</h2>
<pre>
struct A {
  virtual void func1();
  virtual void func2() = 0;
};

struct B : A {
  virtual void func1(); // Compliant; non-pure virtual
};
</pre>
<h2>See</h2>
<ul>
  <li> MISRA C++:2008, 10-3-3 - A virtual function shall only be overridden by a pure virtual function if it is itself declared as pure virtual. </li>
</ul>