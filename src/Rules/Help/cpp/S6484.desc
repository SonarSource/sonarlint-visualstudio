<p><code>std::format</code> accepts a format string composed of ordinary text and replacement fields (surrounded with <code>{}</code>) that are
replaced with a textual representation of the next <code>std::format</code> arguments. This allows generating a complex string with a single
invocation of <code>std::format</code>.</p>
<p>Since calls to <code>std::format</code> produce string objects, it is possible to concatenate them with other string objects or string literals.
However, compared to a single <code>std::format</code> invocation with an adjusted format string, this concatenation is inefficient and less
readable.</p>
<p>This rule raises an issue when a concatenation an <code>std::format</code> invocation can be replaced with a simple <code>std::format</code>
invocation.</p>
<h2>Noncompliant Code Example</h2>
<pre>
void formatExamples(std::string str, char const* cstr, int i) {
  std::string s1 = "You have been greeted " + std::format("{}", i) + " times."; // Noncompliant
  std::string s2 = "Hello " + std::format("{:*^20}", str) + "! " + std::format("{:-&gt;15}", cstr) + '.'; // Noncompliant
}

std::string fullName(std::string name, std::string secondName, std::string surname, std::size_t number) {
  // Compliant, as the formatted output depends on runtime properties
  std::string result = std::format("({}) {}", number, name);
  if (!secondName.empty()) {
     result += " ";
     result += secondName.front();
  }
  result += surname;
  return result;
}
</pre>
<h2>Compliant Solution</h2>
<pre>
void formatExamples(std::string str, char const* cstr, int i) {
  std::string s1 = std::format("You have been greeted {} times.", i); // Compliant
  std::string s2 = std::format("Hello {:*^20}! {:-&gt;15}.", str, cstr); // Compliant
  std::string s3 = std::format("Welcome {:*^20}! {:-&gt;15}.", str, cstr); // Compliant
}
</pre>