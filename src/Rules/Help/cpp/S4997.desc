<p><code>std::auto_ptr</code> was a pre-C++11 attempt to do what <code>std::unique_ptr</code> now does. Unfortunately, the move semantics needed to
make it work properly werenâ€™t in place, so copying a <code>std::auto_ptr</code> has the very surprising behavior of invalidating the source of the
copy.</p>
<p>That problem has been fixed with <code>std::unique_ptr</code>, so <code>std::auto_ptr</code> has been deprecated in C++11 and removed in C++17.</p>
<p>If your compiler allows it, you should replace all use of <code>std::auto_ptr</code> with <code>std::unique_ptr</code>. Otherwise, define your own
(non-copyable) smart pointer.</p>
<h2>Noncompliant Code Example</h2>
<pre>
using namespace std;

void draw(auto_ptr&lt;Shape&gt; p) { cout &lt;&lt; s-&gt;x() &lt;&lt; ", " &lt;&lt; s.y() &lt;&lt; endl;} // Noncompliant

void f()
{
    std::auto_ptr&lt;Shape&gt; s = createShape(); // Noncompliant
    draw(s); // This call invalidates s
    draw(s); // This call will crash, because s is null
}
</pre>
<h2>Compliant Solution</h2>
<pre>
using namespace std;

void draw(unique_ptr&lt;Shape&gt; p) { cout &lt;&lt; s-&gt;x() &lt;&lt; ", " &lt;&lt; s.y() &lt;&lt; endl;} // Compliant

void f()
{
    std::unique_ptr&lt;Shape&gt; s = createShape();
    // draw(s); // Would not compile
    draw(move(s)); // Will compile, and the user knows s has been invalidated
}
</pre>