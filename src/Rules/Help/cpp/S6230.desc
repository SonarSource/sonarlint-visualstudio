<p>Comparison operators like <code>==</code> or <code>&lt;=&gt;</code>, despite being not hard to write, remain a source of bugs as they need to be
updated with every change in the classâ€™s member list. For instance, if a newly introduced member in the class is not considered by the operation, the
issue will only manifest if two instances are identical, except for the newly introduced member. As a consequence, this type of bug is usually hard to
spot.</p>
<p>C++20 introduced the ability to define both <code>operator&lt;=&gt;</code> and <code>operator==</code> as defaulted (<code>= default</code>) to
indicate that they should consider all members in the order of their declaration. This not only makes code concise but also makes all the comparison
operators resilient to the changes to the list of members. Thanks to operator rewriting, all other comparison operations (<code>!=</code>,
<code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>=&gt;</code>) can also rely on these robust operators.</p>
<p>Furthermore, when <code>operator&lt;=&gt;</code> is defined as defaulted, the compiler will generate a defaulted version of <code>operator==</code>
if no other version is declared.</p>
<p>This rule raises an issue when the implementation of <code>operator&lt;=&gt;</code> or <code>operator==</code> has an equivalent semantic to the
defaulted implementation.</p>
<h2>Noncompliant Code Example</h2>
<pre>
struct Comparable {
    int x;
    int y;
};

bool operator==(const Comparable&amp; lhs, const Comparable&amp; rhs) { // Noncompliant
    return lhs.x == rhs.x &amp;&amp; lhs.y == rhs.y;
}

struct Ordered {
    int x;
    int y;
};

bool operator==(const Ordered&amp; lhs, const Ordered&amp; rhs) { // Noncompliant
    return lhs.x == rhs.x &amp;&amp; lhs.y == rhs.y;
}

auto operator&lt;=&gt;(const Ordered&amp; lhs, const Ordered&amp; rhs) { // Noncompliant
    if (res = lhs.x &lt;=&gt; rhs.x; res != 0)
        return x;
    return lhs.y &lt;=&gt; rhs.y;
}
</pre>
<h2>Compliant Solution</h2>
<pre>
struct Comparable {
    int x;
    int y;

friend bool operator==(const Comparable&amp;, const Comparable&amp;) = default;
};

struct Ordered {
    int x;
    int y;

friend auto operator&lt;=&gt;(const Ordered&amp;, const Ordered&amp;) = default;
};
</pre>
<h2>See</h2>
<ul>
  <li> {rule:cpp:S6186} - removing redundant comparison operators </li>
  <li> {rule:cpp:S6187} - replacing multiple comparison operators with <code>operator&lt;=&gt;</code> </li>
</ul>