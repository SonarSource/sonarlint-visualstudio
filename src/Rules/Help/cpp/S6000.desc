<p><code>std::variant</code> is a type-safe union that can hold values of a type out of a fixed list of types.</p>
<p>Depending on the current alternative inside a <code>variant</code>, it is common to execute dedicated code. There are basically two ways to achieve
that:</p>
<ul>
  <li> Writing code that checks the current alternative, then getting it and running specific code </li>
  <li> Letting <code>std::visit</code> perform the check and select the code to run by using overload resolution with the different alternatives </li>
</ul>
<p>The second option is usually preferable:</p>
<ul>
  <li> It requires less boilerplate code. </li>
  <li> It is easy to handle multiple similar alternatives together if desired. </li>
  <li> It is usually more robust: if a new alternative is added to the variant, but the visitor does not support it, it will not compile. </li>
</ul>
<p>This rule raises an issue when <code>variant::index</code> is called, or when <code>variant::holds_alternative</code> or
<code>variant::get_if</code> is used in a series of <code>if</code> - <code>else if</code> (calling one of these functions in isolation can be an
acceptable lightweight alternative to <code>std::visit</code> in some cases).</p>
<p>Note: When defining the visitor of a variant, it can be nicer to use a series of lambdas by making use of <a
href="https://www.bfilipek.com/2019/02/2lines3featuresoverload.html">the <em>overloaded</em> pattern</a></p>
<h2>Noncompliant Code Example</h2>
<pre>
using Variant = std::variant&lt;int, float, string&gt;;
void printType1(Variant const &amp;v) {
    switch(v.index()) { // Noncompliant
        case 0: cout &lt;&lt; "int " &lt;&lt;get&lt;int&gt;(v) &lt;&lt; "\n"; break;
        case 1: cout &lt;&lt; "float " &lt;&lt;get&lt;float&gt;(v) &lt;&lt; "\n"; break;
        case 2: cout &lt;&lt; "string " &lt;&lt;get&lt;string&gt;(v) &lt;&lt; "\n";break;
    }
}
void printType2(Variant const &amp;v) {
    if(auto p = get_if&lt;int&gt;(&amp;v)) { // Noncompliant
        cout &lt;&lt; "int " &lt;&lt; *p &lt;&lt; "\n";
    } else if (auto p = get_if&lt;float&gt;(&amp;v)) {
        cout &lt;&lt; "float " &lt;&lt; *p &lt;&lt; "\n";
    } else if (auto p = get_if&lt;string&gt;(&amp;v)) {
        cout &lt;&lt; "string " &lt;&lt; *p &lt;&lt; "\n";
    }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
using Variant = std::variant&lt;int, float, string&gt;;

struct VariantPrinter {
    void operator() (int i) { cout &lt;&lt; "int " &lt;&lt; i &lt;&lt; "\n"; }
    void operator() (float f) { cout &lt;&lt; "float " &lt;&lt; f &lt;&lt; "\n"; }
    void operator() (std::string const &amp;s) { cout &lt;&lt; "string " &lt;&lt; s &lt;&lt; "\n"; }
};

void printType3(Variant const &amp;v) {
    std::visit(VariantPrinter{}, v);
}

// Same principle, but using the overloaded pattern
void printType4(Variant const &amp;v) {
    std::visit(overloaded{
        [](int i){cout &lt;&lt; "int " &lt;&lt; i &lt;&lt; "\n";},
        [](float f){cout &lt;&lt; "float " &lt;&lt; f &lt;&lt; "\n";},
        [](std::string const &amp;s){cout &lt;&lt; "string " &lt;&lt; s &lt;&lt; "\n";}
    }, v);
}
</pre>