<p>Explicit specializations of function templates are not considered in overload resolution, only the main template. As a consequence, the function
that will be selected might very well be different from what seems natural to the developer, leading to hard to understand bugs. Moreover, function
templates don’t allow partial specialization.</p>
<p>Instead of specializing a function template, you may choose to overload it with another template or non template function, since a more specialized
overload will be preferred to a generic overload.</p>
<h2>Noncompliant Code Example</h2>
<pre>
template &lt;typename T&gt; void f ( T );
template &lt;&gt; void f&lt;char*&gt; ( char * ); // explicit specialization, noncompliant
</pre>
<h2>Compliant Solution</h2>
<pre>
template &lt;typename T&gt; void f ( T );
void f( char * ); // overload, compliant
</pre>
<h2>Exceptions</h2>
<p>This rule ignores cases where none of the main function template arguments depend on a template parameter: Even if the code could still be written
without function template specialization (by deferring the real work to a class template, and offering specializations of this class template as
customization point to the user), there is no risk of confusion for overload resolution in these cases.</p>
<pre>
// For real code, use std::numeric_limits instead...
template &lt;class T&gt; T max();
template &lt;&gt; float max&lt;float&gt;() { return FLT_MAX; }  // Ignored

template&lt;class T&gt;
bool isMax(T t){
    return t == max&lt;T&gt;();
}
</pre>
<h2>See</h2>
<ul>
  <li> MISRA C++:2008, 14-8-1 </li>
  <li> <a href="https://github.com/isocpp/CppCoreGuidelines/blob/036324/CppCoreGuidelines.md#t144-dont-specialize-function-templates">C++ Core
  Guidelines T.144</a> - Don’t specialize function templates </li>
</ul>