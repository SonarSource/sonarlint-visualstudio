<p>C++11 introduced the concept of <em>forwarding-reference</em>, as a way to transfer values efficiently. In combination with
<code>std::forward</code>, their usage allows passing values without unnecessary copies.</p>
<p>The expression <code>std::forward&lt;T&gt;(obj).mem</code>, can be used to forward the value of the member, according to the type of
<code>obj</code>: move the value of member <code>mem</code> if the <code>obj</code> is an rvalue reference and copy it otherwise. However, in the
corner case, when the member <code>mem</code> is of rvalue reference type, the value it references will be copied even if <code>obj</code> itself is
an rvalue, the referenced value will not be moved.</p>
<p>Similarly for <code>std::move</code>: if <code>mem</code> is of rvalue reference type, <code>std::move(obj).mem</code> will copy the value
referenced by <code>mem</code>.</p>
<p>This rule raises issues when a templates is instantiated with a type that leads to an accidental copy of members of forwarded objects.</p>
<h2>Noncompliant Code Example</h2>
<pre>
template&lt;typename... Ts&gt;
void consume(Ts&amp;&amp;... ts)


template&lt;typename T, typename U&gt;
void consumePair(std::pair&lt;T, U&gt;&amp;&amp; p) {
  consume(std::move(p).first, std::move(p).second); // Noncompliant (see later)
}
void use1() {
  std::string x = "x", y = "y";
  std::pair&lt;std:string&amp;&amp;, std::string&amp;&amp;&gt; rRefPair(std::move(x), std::move(y));
  consumePair(std::move(rRefPair)); // Triggers noncompliant instantiation of consumePair
                                    // with T = std:::string&amp;&amp; and U = std::string&amp;&amp;
}


template&lt;typename Pair&gt;
void forwardPair(Pair&amp;&amp; p) {
  consume(std::forward&lt;Pair&gt;(p).first, std::forward&lt;Pair&gt;(p).second); // Noncompliant (see later)
}
void use2() {
  std::string x = "x", y = "y";
  std::pair&lt;std:string&amp;&amp;, std::string&amp;&amp;&gt; rRefPair(std::move(x), std::move(y));
  forwardPair(rRefPair); // OK, lvalue is passed, and the members should and are copied
                         // Pair = std::pair&lt;std:string&amp;&amp;, std::string&amp;&amp;&gt;&amp;
  forwardPair(std::move(rRefPair)); // Triggers noncompliant instantiation of forwardPair
                                    // with Pair = std::pair&lt;std:string&amp;&amp;, std::string&amp;&amp;&gt;
}


template&lt;typename Pair&gt;
void forwardStruct(T&amp;&amp; p) {
  consume(std::forward&lt;T&gt;(p).mem); // Noncompliant (see later)
}
struct Proxy {
    std::vector&lt;int&gt;&amp;&amp; mem;
};
void use3() {
  std::vector&lt;int&gt; v;
  Proxy proxy{std::move(v)};
  forwardStruct(proxy); // OK, lvalue is passed, and the members should and are copied
                        // T = Proxy&amp;
  forwardStruct(std::move(proxy)); // Triggers noncompliant instantiation of forwardStruct
                                   // with T = Proxy
}


void compiler_error() {
  std::unique_ptr&lt;int&gt; u;
  std::pair&lt;std::unique_ptr&lt;int&gt;&amp;&amp;, int&gt; pair(std::move(u), 1);
  // std::unique_ptr&lt;int&gt; u2 = std::move(pair).first; // ill-formed trying to copy
}
</pre>
<h2>Compliant Solution</h2>
<pre>
template&lt;typename T, typename U&gt;
void consumePair(std::pair&lt;T, U&gt;&amp;&amp; p) {
    consume(std::get&lt;0&gt;(std::move(p)), std::get&lt;1&gt;(std::move(p)));
}


template&lt;typename Pair&gt;
void forwardPair(Pair&amp;&amp; p) {
    consume(std::get&lt;0&gt;(std::forward&lt;Pair&gt;(p)), std::get&lt;1&gt;(std::forward&lt;Pair&gt;(p)));
}


template&lt;typename Pair&gt;
void forwardStruct(T&amp;&amp; t) {
  constexpr bool isMoveOfRvalueReferenceMember
      = std::is_rvalue_reference_v&lt;decltype(t.mem)&gt; &amp;&amp; std::is_rvalue_reference_v&lt;T&amp;&amp;&gt;;
  if constexpr (isMoveOfRvalueReferenceMember) {
    consume(std::move(t.mem));
  } else {
    consume(std::forward&lt;T&gt;(t).mem);
  }
}


void compiler_error() {
  std::unique_ptr&lt;int&gt; u;
  std::pair&lt;std::unique_ptr&lt;int&gt;&amp;&amp;, int&gt; pair(std::move(u), 1);
  std::unique_ptr&lt;int&gt; u2 = std::move(pair.first);
}
</pre>