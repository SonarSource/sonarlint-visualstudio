<p>Objects should be initialized as soon as they are declared. It will be implicitly the case if they have a default constructor, as this latter will
be called, but otherwise the initialization must be explicit. Even when an object has a default constructor, it may be interesting to use another more
relevant constructor to directly give the the object its right value.</p>
<p>Such direct initialization increases the readability of the code:</p>
<ul>
  <li> seeing the initial value of a variable is usually a good indicator of its purpose, </li>
  <li> waiting until we know a good initial value before declaring a variable can lead to a reduced variable scope, </li>
  <li> it makes reasoning on the source code simpler: we remove the burden of having to know if a variable is initialized at a specific point in the
  code, </li>
  <li> it is a first step that can lead to the possibility of declaring the variable <code>const</code>, which further simplifies reasoning, </li>
  <li> it is also a first step toward declaring it <code>auto</code>, which could increase readability by shifting the focus away from the exact type.
  </li>
</ul>
<p>Please note that the intent of the rule is not to initialize any variable with some semi-random value, but with the value that is meaningful for
this variable.</p>
<p>This rule raises an issue when a variable of a non-array type with no constructor is declared without initial value.</p>
<p>The related rule {rule:cpp:S836} detects situations when a variable is actually read before being initialized, while this rule promotes the good
practice of systematically initializing the variable.</p>
<h2>Noncompliant Code Example</h2>
<pre>
double init1();
double init2();
double init3();
double init4();

void f(bool b) {
  int i; // Noncompliant
  string s; // Compliant: default constructor will be called, but we could probably find a better value

  double d1; // Noncompliant
  double d2; // Noncompliant
  if (b) {
    d1 = init1();
    d2 = init2();
  } else {
    d1 = init3();
    d2 = init4();
  }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
double init1();
double init2();
double init3();
double init4();

std::pair&lt;double, double&gt; init(bool b) {
    return b ? std::make_pair(init1(), init2()) : std::make_pair(init3(), init4());
}

void f(bool b) {
  int i = 0;
  string s;

  auto [d1, d2] = init(b);
}

// Or:
void f(bool b) {
  auto [d1, d2] = [b](){
    if (b) {
      return std::make_pair(init1(), init2());
    } else {
      return std::make_pair(init3(), init4());
    }
  }();
}
</pre>
<h2>Exceptions</h2>
<p>Buffers can be left uninitialized as long as they are written into immediately after their declarations.</p>
<pre>
  int buf[10]; // allowed but it should be initialized right after the declaration
</pre>
<h2>See</h2>
<ul>
  <li> <a href="https://github.com/isocpp/CppCoreGuidelines/blob/036324/CppCoreGuidelines.md#es20-always-initialize-an-object">C++ Core Guidelines
  ES.20</a> - Always initialize an object </li>
</ul>