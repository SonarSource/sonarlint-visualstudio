<p>When you are using lambdas in a member function, you can capture <code>this</code> implicitly through <code>[=]</code> or <code>[&amp;]</code> or
explicitly through <code>[this]</code>. This will capture&nbsp;the current object pointer by reference or by value, but the underlying object will
always be captured by reference (see {rule:cpp:S5019}).</p>
<p>This will become a problem:</p>
<ul>
  <li> When the lifetime of the lambda exceeds the one of the current object. </li>
  <li> When you want to capture the current state of the object. </li>
  <li> When you want to pass a copy of the object to avoid any concurrency issue. </li>
</ul>
<p><code>C++14</code> provides a workaround to solve this problem. Where you can take the underlying object by copy using the following pattern:</p>
<pre>
auto lam = [copyOfThis = *this] { std::cout &lt;&lt; copyOfThis.field; };
</pre>
<p>This is verbose and error-prone, as you might implicitly not use the copied object:</p>
<pre>
auto lam = [&amp; , copyOfThis = *this] {
std::cout &lt;&lt; field; // implicitly calling “this” captured by reference
};
</pre>
<p><code>C++17</code> solves this problem by introducing an explicit consistent way to capture <code>this</code> by copy:</p>
<pre>
auto lam = [&amp;, *this] {
std::cout &lt;&lt; field // implicitly calling “this” captured by copy
};
</pre>
<p>This rule will flag the <code>C++14</code> way of capturing the current object by copy and suggest to replace it with the <code>C++17</code>
way.</p>
<h2>Noncompliant Code Example</h2>
<pre>
struct A {
  int field = 0;
  void memfn() const {
    auto lam = [copyOfThis = *this] { // Noncompliant
      std::cout &lt;&lt; copyOfThis.field;
    };
  }
};
</pre>
<h2>Compliant Solution</h2>
<pre>
struct A {
  int field = 0;
  void memfn() const {
    auto lam = [*this] { // Compliant
      std::cout &lt;&lt; field;
    };
  }
};
</pre>