<p>Proprietary compiler extensions can be handy, but they commit you to always using that compiler. This rule raises an issue when GNU extensions are
used, such as:</p>
<ul>
  <li> Ternary operator with omitted second operand </li>
  <li> Case ranges in switch statements </li>
  <li> Expression statements, i.e. code blocks producing value </li>
  <li> Index range in array initializers </li>
  <li> A array initializer without <code>=</code> </li>
  <li> A structure member initializer with a colon </li>
  <li> Decimal floating points numbers <code>_Decimal32</code>, <code>_Decimal64</code>, and <code>_Decimal128</code> </li>
  <li> Structures and union without named data members </li>
</ul>
<h2>Noncompliant Code Example</h2>
<pre>
struct S {
  int f;
};

struct S s[] = {
  [0] { // Noncompliant
    f : 0 // Noncompliant
  }
  [1 ... 3] = { // CHECK :8 :11 S3715:use of GNU array range extension
    .f = 2
  }
};

int fun(int p) {
  switch (p) {
    case 0 ... 1: // Noncompliant
      do_the_thing();
      break;
    case 2:
      //...
  }

  p = ({ // Noncompliant
    int a = 10, b = 20;
    (a * b) + 10;
  });

  return p ?: 0; // Noncompliant
}

_Decimal32 d32; // Noncompliant

struct Empty {}; // Noncompliant in C
</pre>
<h2>Compliant Solution</h2>
<pre>
struct S {
  int f;
};

struct S s[] = {
  [0] = {
    .f = 0
  },
  [1] = {
    .f = 2
  }
  [2] = {
    .f = 2
  },
  [3] = {
    .f = 2
  }

};

int fun(int p) {
  switch (p) {
    case 0:
    case 1:
      do_the_thing();
      break;
    case 2:
      //...
  }

  int a = 10, b = 20;
  p = (a * b) + 10;

  return p ? p: 0;
}
</pre>