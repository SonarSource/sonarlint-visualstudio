<p>The behavior of volatile types in compound expressions that both read and write the same variable (for instance <code>a++</code> or
<code>a+=2</code>, where <code>a</code> is a <code>volatile int</code>) is not well defined, and is deprecated since C++20.</p>
<p>Such expressions should be replaced by explicit operations that only read or write the value.</p>
<h2>Noncompliant Code Example</h2>
<pre>
void f1(int volatile* p) {
  ++(*p); // Noncompliant
}

void f2(volatile int&amp; in) {
  in += 2; // Noncompliant
}

void f3(volatile int&amp; in) {
  int i = in = 2; // Noncompliant
}
</pre>
<h2>Compliant Solution</h2>
<pre>
void f1(int volatile* p) {
  auto val = *p;  // One access to read the register
  *p = val + 1; // One access to write to it (and potentially overwrite another change)
}

void f2(volatile int&amp; in) {
  auto val = in;
  in = val + 2;
}

void f3(volatile int&amp; in) {
  in = 2;
  int i = in;
}
</pre>