<p>A <em>requires-expression</em> is a list of requirements that can be of different natures. <em>Simple-requirements</em> are expressions that do not
start with the keyword <code>requires</code> and <em>compound-requirements</em> are expressions surrounded by curly brackets potentially followed by a
<code>noexcept</code> specification and return type requirements.</p>
<p>In both cases, the expressions are not evaluated. They will only be checked for validity, and if the expression is invalid, the
<em>requires-expression</em> evaluates to <code>false</code>.</p>
<p>When we write a concept check or a type predicate, the intent is usually to evaluate them, therefore, they donâ€™t really belong in a
<em>simple-requirement</em> or a <em>compound-requirement</em>. Instead, they should either be used directly in a concept definition (outside of a
<em>requires-expression</em>) or, less often, as a <em>nested-requirement</em> (a requirement introduced by the <code>requires</code> keyword within
the <em>requires-expression</em>).</p>
<p>This rule detects concept checks and standard type predicates (from the header <code>&lt;type_traits&gt;</code>) in single and compound
requirements of <em>requires-expressions</em>.</p>
<h2>Noncompliant Code Example</h2>
<pre>
template&lt;typename T&gt;
concept TriviallyCopyable = requires {
   std::copyable&lt;T&gt;;  // Noncompliant
   {std::is_trivally_copy_constructible_v&lt;T&gt;}; // Noncompliant
   std::is_trivally_move_constructible&lt;T&gt;::value; // Noncompliant
};
</pre>
<p>This concept is always <code>true</code>, for every type <code>T</code>, because expressions such as <code>std::copyable&lt;T&gt;</code> are always
well-formed.</p>
<h2>Compliant Solution</h2>
<pre>
template&lt;typename T&gt;
concept TriviallyCopyable =
    std::copyable&lt;T&gt; &amp;&amp;
    std::is_trivially_copy_constructible_v&lt;T&gt; &amp;&amp;
    std::is_trivially_move_constructible&lt;T&gt;::value;
</pre>
<p>Or:</p>
<pre>
template&lt;typename T&gt;
concept TriviallyCopyable = requires {
   requires std::copyable&lt;T&gt;;
   requires std::is_trivially_copy_constructible_v&lt;T&gt; &amp;&amp;
       std::is_trivially_move_constructible&lt;T&gt;::value;
};
</pre>