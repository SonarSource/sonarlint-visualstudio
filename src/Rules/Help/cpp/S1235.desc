<p>When a class with no <code>virtual</code> destructor is used as a base class, surprises can occur if pointers to instances of this class are used.
Specifically, if an instance of a derived class is <code>delete</code>d through a pointer to the base type, the behavior is undefined and can lead to
resource leaks, crashes or corrupted memory.</p>
<p>If it is not expected for base class pointers to be deleted, then the destructor should be made <code>protected</code> to avoid such a misuse.</p>
<h2>Noncompliant Code Example</h2>
<pre>
class Base { // Noncompliant: no destructor is supplied, and the default version is not virtual
public:
  Base() {}
  virtual void doSomething() {}
};

class Derived : public Base {
}

void f() {
  Base *p = new Derived();
  delete p; // Undefined behavior
}
</pre>
<h2>Compliant Solution</h2>
<pre>
class Base {
public:
  Base() {}
  virtual ~Base() = default;
  virtual void doSomething() {}
};
</pre>
<h2>See</h2>
<ul>
  <li> <a href="https://wiki.sei.cmu.edu/confluence/x/5Xs-BQ">CERT, OOP52-CPP.</a> - Do not delete a polymorphic object without a virtual destructor
  </li>
  <li> <a href="http://www.gotw.ca/publications/mill18.htm">Virtuality article</a> </li>
  <li> <a
  href="https://github.com/isocpp/CppCoreGuidelines/blob/036324/CppCoreGuidelines.md#c35-a-base-class-destructor-should-be-either-public-and-virtual-or-protected-and-nonvirtual">C++ Core Guidelines C.35</a> - A base class destructor should be either public and virtual, or protected and nonvirtual </li>
  <li> <a
  href="https://github.com/isocpp/CppCoreGuidelines/blob/036324/CppCoreGuidelines.md#c127-a-class-with-a-virtual-function-should-have-a-virtual-or-protected-destructor">C++ Core Guidelines C.127</a> - A class with a virtual function should have a virtual or protected destructor </li>
</ul>