<p>Since C++17, the class <code>std::filesystem::path</code> can be used to store a file path. Compared to a regular string, it offers several
advantages:</p>
<ul>
  <li> Having a dedicated type makes the intention clear </li>
  <li> This class stores the path with an encoding that is appropriate to the OS where the program runs </li>
  <li> It provides several functions that make it more convenient to manipulate than a <code>string</code> (for instance <code>operator/</code> for
  concatenations) </li>
  <li> It provides a normalized way to specify the path, easing the portability of the code (on Windows and Linux, the native way is equivalent to the
  normalized way, which reduces overhead). </li>
</ul>
<p>This rule raises an issue when the same <code>string</code> is converted several times to a <code>path</code>&nbsp;because it indicates that a
single path object could have been used in all occurrences. Additionally, it can also be more efficient, since a conversion from <code>string</code>
to&nbsp;<code>path</code> may require a change of encoding and a memory allocation.</p>
<h2>Noncompliant Code Example</h2>
<pre>
std::string getUserData();
namespace fs = std::filesystem;
void f() {
  std::string const filePath = getUserData();
  if (fs::exists(filePath)) {
    logTime(fs::last_write_time(filePath)); // Noncompliant
  }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
std::string getUserData();
namespace fs = std::filesystem;
void f() {
  fs::path const filePath = getUserData();
  if (fs::exists(filePath) {
    logTime(fs::last_write_time(filePath)); // Compliant
  }
}
</pre>