<p><code>std::string_view</code> (introduced in C++17) and <code>std::span</code> (introduced in C++20) are thin generic wrappers for a contiguous
sequence of elements. These wrappers can be used to unify the interface of functions that were previously accepting references to specific container
types: <code>const std::string&amp;</code>, <code>const std::vector&lt;int&gt;&amp;</code>…​</p>
<p>One of the benefits of such modernization is that it eliminates the need to explicitly create a temporary container. This happens in situations
where part of the sequence is passed as an argument: <code>substr</code> is called on <code>std::string</code>. It can also happen when the type of
the container elements needs to be adjusted: converting <code>std::vector&lt;T*&gt;</code> to <code>std::vector&lt;const T*&gt;</code>. When changing
the type of a function parameter to <code>std::string_view</code> or <code>std::span</code> the modification of the function call site to remove the
no longer needed temporary might be missed and the code will still compile. This rule will help eliminate these temporaries.</p>
<p>This rule raises an issue when an unnecessary temporary is passed as an argument to a parameter of <code>std::string_view</code> or
<code>std::span</code> type.</p>
<h2>Noncompliant Code Example</h2>
<pre>
void parse(std::string_view sv);
bool oddAre0(std::span&lt;int const* const&gt; nums);
std::vector&lt;int*&gt; getNums();

void caller(std::string const&amp; s) {
  parse(s.substr(10)); // Noncompliant
  parse(std::string(s, 2, 5)); // Noncompliant
  parse(std::string(s.data(), 20)); // Noncompliant
  parse(std::string(s.data(), 10)); // Noncompliant

  std::vector&lt;int*&gt; nums = getNums();
  if (oddAre0(std::vector&lt;int const*&gt;{nums.begin(), nums.end()})) { // Noncompliant: This copy is verbose and slow
    // ...
  }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
void parse(std::string_view sv);
bool oddAre0(std::span&lt;int const* const&gt; nums);
std::vector&lt;int*&gt; getNums();

void caller(std::string const&amp; s) {
  parse(std::string_view(s).substr(10));
  parse(std::string_view(s).substr(2, 5));
  parse(std::string_view(s.data(), 20));
  parse({ s.data(), 10 });

  std::vector&lt;int*&gt; nums = getNums();
  if (oddAre0(nums)) {
      // ...
  }
}
</pre>
<h2>See</h2>
<ul>
  <li> RSPEC-6009 - using <code>std::string_view</code> as a parameter type </li>
  <li> RSPEC-6188 - using <code>std::span</code> as a parameter type </li>
</ul>