<p><code>for</code>-loops are a very powerful and versatile tool that can be used for many purposes. This flexibility comes with drawbacks:</p>
<ul>
  <li> It is very easy to make a small mistake when writing them, </li>
  <li> They are relatively verbose to write, </li>
  <li> They do not express the intent of the code, the reader has to look at loop details to understand what the loop does. </li>
</ul>
<p>There are algorithms that encapsulate a <code>for</code>-loop and give it some meaning (<code>std::all_of</code>, <code>std::count_if</code>,
<code>std::remove_if</code>…​). These algorithms are well tested, efficient, and explicit and therefore should be your first choice.</p>
<p>This rule detects loops that go through all consecutive elements of a sequence (eg: containers, objects with begin() and end() member functions),
and deal only with the current element without side-effects on the rest of the sequence.</p>
<p>This rule suggests using one of the supported STL algorithm patterns corresponding to your C++ standard when a loop matches it.</p>
<p>Currently, this rule supports:</p>
<ul>
  <li> <code>std::all_of</code> (since C++11) and <code>std::ranges::all_of</code> (since C++20): returns <code>true</code> if all elements in the
  given range are matching the given predicate, <code>false</code> otherwise </li>
  <li> <code>std::none_of</code> (since C++11) and <code>std::ranges::none_of</code> (since C++20): returns <code>true</code> if no elements in the
  given range are matching the given predicate, <code>false</code> otherwise </li>
  <li> <code>std::any_of</code> (since C++11) and <code>std::ranges::any_of</code> (since C++20): returns <code>true</code> if at least one element in
  the given range is matching the given predicate, <code>false</code> otherwise </li>
</ul>
<p>This rule suggests two options below when the loop doesn’t match any of the supported STL algorithm patterns and you just want to iterate over all
elements of a sequence:</p>
<ul>
  <li> Range-based <code>for</code>-loops, which were introduced in C++11 and will run through all elements of a sequence </li>
  <li> <code>std::for_each</code>, an algorithm that performs the same operation between two iterators (allowing more flexibility, for instance by
  using <code>reverse_iterator</code>s, or with a variant that can loop in parallel on several elements at a time). </li>
</ul>
<h2>Noncompliant Code Example</h2>
<pre>
#include &lt;vector&gt;
#include &lt;iostream&gt;

using namespace std;

bool asDesired(const int v);

bool areAllDesired(std::vector&lt;int&gt; values) {
  for (int val : values) { // Noncompliant, replace it by a call to std::all_of
    if (!asDesired(val)) {
      return false;
    }
  }
  return true;
}

int f(vector&lt;int&gt; &amp;v) {

  for (auto it = v.begin(); it != v.end(); ++it) { // Noncompliant
    if (*it &gt; 0) {
      cout &lt;&lt; "Positive number : " &lt;&lt; *it &lt;&lt; endl;
    } else {
      cout &lt;&lt; "Negative number : " &lt;&lt; *it &lt;&lt; endl;
    }
  }

  auto sum = 0;
  for (auto it = v.begin(); it != v.end(); ++it) { // Noncompliant
    sum += *it;
  }
  return sum;
}
</pre>
<h2>Compliant Solution</h2>
<pre>
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

bool asDesired(const int v);

bool areAllDesired2(std::vector&lt;int&gt; values) {
  return std::all_of(std::begin(values), std::end(values), asDesired);
}

bool areAllDesiredCpp20(std::vector&lt;int&gt; values) {
  return std::ranges::all_of(values, asDesired);
}

void displayNumber(int i) {
  if (i &gt; 0) {
    cout &lt;&lt; "Positive number : " &lt;&lt; i &lt;&lt; endl;
  } else {
    cout &lt;&lt; "Negative number : " &lt;&lt; i &lt;&lt; endl;
  }
}

void f(vector&lt;int&gt; &amp;v) {

  std::for_each(v.begin(), v.end(), displayNumber);
  // Or since C++20:
  std::ranges::for_each(v, displayNumber);

  auto sum = 0;
  for (auto elt : v) {
    sum += elt;
  }
  return sum;
  // An even better way to write this would be:
  // return std::accumulate(v.begin(), v.end(), 0);
}
</pre>
<h2>See</h2>
<ul>
  <li> <a
  href="https://github.com/isocpp/CppCoreGuidelines/blob/036324/CppCoreGuidelines.md#es71-prefer-a-range-for-statement-to-a-for-statement-when-there-is-a-choice">C++ Core Guidelines ES.71</a> - Prefer a range-for-statement to a for-statement when there is a choice </li>
  <li> <a href="https://github.com/isocpp/CppCoreGuidelines/blob/036324/CppCoreGuidelines.md#p3-express-intent">C++ Core Guidelines P.3</a> - Express
  intent </li>
</ul>