<p>Prefer <code>make_unique</code> and <code>make_shared</code>&nbsp;over explicitly calling the constructor
of&nbsp;<code>unique_ptr</code>&nbsp;and&nbsp;<code>shared_ptr</code>, they are more concise since they don’t require specifying the type multiple
times and they eliminate the need to use new!</p>
<p><strong>Exception-Safety</strong></p>
<p>While <code>make_unique</code> and <code>make_shared</code> are exception-safe, complex construction of <code>unique_ptr</code> and
<code>shared_ptr</code> might not be.</p>
<p>This is because C++ allows arbitrary order of evaluation of subexpressions.</p>
<p>Consider this example:</p>
<pre>
f(unique_ptr&lt;Lhs&gt;(new Lhs()), throwingFunction());
</pre>
<p>This scenario can happen:</p>
<ol>
  <li> Memory is allocated for <code>Lhs</code> </li>
  <li> <code>Lhs</code> object is constructed </li>
  <li> <code>throwingFunction</code> is called before the <code>unique_ptr</code> construction </li>
  <li> <code>throwingFunction</code> throws an exception. </li>
  <li> The constructed <code>Lhs</code> object is leaked since the <code>unique_ptr</code> isn’t constructed yet </li>
</ol>
<p>Note: This scenario can only happen before <code>C++17</code>. the new standard states that each argument needs to be fully evaluated before the
evaluation of the other arguments. In this case, the explicit construction of <code>unique_ptr</code>&nbsp;and&nbsp;<code>shared_ptr</code> is
exception-safe.</p>
<p><strong>Performance</strong></p>
<p>While <code>make_uniqe()</code> doesn’t have an impact on performance, <code>make_shared()</code> does.</p>
<p><code>make_shared()</code> performs one heap-allocation. While constructing <code>shared_ptr()</code> explicitly will require two: one for the
object being managed and the other for the control block that stores data about the ref-counts and the <code>shared_ptr()</code> deleter.</p>
<h2>Noncompliant Code Example</h2>
<pre>
std::unique_ptr&lt;MyClass&gt; uniqueP(new MyClass(42)); // Noncompliant
std::shared_ptr&lt;MyClass&gt; sharedP(new MyClass(42)); // Noncompliant
</pre>
<h2>Compliant Solution</h2>
<pre>
auto uniqueP = std::make_unique&lt;MyClass&gt;(42);
auto sharedP = std::make_shared&lt;MyClass&gt;(42);
std::unique_ptr&lt;std::FILE, std::function&lt;void(std::FILE*)&gt;&gt; file(
  fopen("example.txt", "r"),
  [](FILE* inFile) { fclose(inFile); }); // compliant: custom deleter is specified
</pre>
<h2>Exceptions</h2>
<p>This rule ignores code that uses features not supported by <code>make_shared</code> or <code>make_unique</code>:</p>
<ul>
  <li> <code>make_shared</code> and <code>make_unique</code>: using custom deleters, </li>
  <li> <code>make_shared</code> and <code>make_unique</code>: calling placement-new, i.e. version of <code>new</code> with arguments, like
  <code>new(std::nothrow)</code> </li>
  <li> <code>make_shared</code> only: using operator <code>new</code> provided by class </li>
  <li> <code>make_shared</code> before C++20: allocating arrays </li>
</ul>
<h2>See</h2>
<ul>
  <li> <a
  href="https://github.com/isocpp/CppCoreGuidelines/blob/c553535fb8dda2839d13ab5f807ffbc66b63d67b/CppCoreGuidelines.md#c150-use-make_unique-to-construct-objects-owned-by-unique_ptrs">C++ Core Guidelines C.150</a> - Use make_unique() to construct objects owned by unique_ptrs </li>
  <li> <a
  href="https://github.com/isocpp/CppCoreGuidelines/blob/c553535fb8dda2839d13ab5f807ffbc66b63d67b/CppCoreGuidelines.md#c151-use-make_shared-to-construct-objects-owned-by-shared_ptrs">C++ Core Guidelines C.151</a> - Use make_shared() to construct objects owned by shared_ptrs </li>
</ul>