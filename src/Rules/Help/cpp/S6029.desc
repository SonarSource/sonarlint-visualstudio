<p>Starting C++17, exception specifications became a part of a function type. This implies that these two functions, for example, have different
types:</p>
<pre>
void first() noexcept;
void second();
</pre>
<p>Making exception specifications part of the type will, for the right reason, break code where a function that throws an exception is provided in a
context where <code>noexcept</code> function is expected.</p>
<p>It is important to note that the same way it is not allowed to overload based on the return type, it is also not allowed to overload based on the
exception specifications.</p>
<p>This rule will trigger on code that will stop compiling starting C++17, and on explicit casts that add <code>noexcept</code> to a type.</p>
<h2>Noncompliant Code Example</h2>
<pre>
template&lt;typename T&gt;
void callF1(T t1, T t2) {
  t1();
  t2();
}

void f1();
void f1NoExcept() noexcept;

int main() {
  callF1(f1, f1NoExcept); // Noncompliant, f1 and f1NoExcept have different types
  std::function&lt;void() noexcept&gt; fptr1 = f1; // Noncompliant
  void (*fptr2)() noexcept = f1; // Noncompliant
  void (*fptr3)() noexcept = (void (*)() noexcept) f1; // Noncompliant, it works even in c++17
}
</pre>
<h2>Compliant Solution</h2>
<pre>
template&lt;typename T1, typename T2&gt;
void callF1(T1 t1, T2 t2) {
  t1();
  t2();
}

void f1();
void f1NoExcept() noexcept;

int main() {
  callF1(f1, f1NoExcept); // Compliant
  std::function&lt;void() noexcept&gt; fptr1 = f1NoExcept; // Compliant
  void (*fptr2)() = f1; // Compliant
}
</pre>