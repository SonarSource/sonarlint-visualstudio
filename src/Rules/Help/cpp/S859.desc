<p>Using <code>const</code> in your code improves reliability and maintenance. When passing a <code>const</code> value, developers assume that its
value won’t be changed. But using <code>const_cast&lt;&gt;()</code> to cast away a <code>const</code> qualifier, destroys developer assumptions and
code reliability. It is a bad practice and reveals a flaw in the design. Furthermore, it may have an undefined behavior.</p>
<h2>Noncompliant Code Example</h2>
<pre>
User&amp; func(const int&amp; value, const User&amp; user) {
  const_cast&lt;int&amp;&gt;(value) = 2; // Noncompliant and undefined behavior
  return const_cast&lt;User&amp;&gt;(user); // Noncompliant
}
</pre>
<h2>Compliant Solution</h2>
<pre>
User&amp; func(int&amp; value, User&amp; user) {
  value = 2;
  return user;
}
</pre>
<h2>See</h2>
<ul>
  <li> MISRA C:2004, 11.5 - A cast shall not be performed that removes any const or volatile qualification from the type addressed by a pointer </li>
  <li> MISRA C++:2008, 5-2-5 - A cast shall not remove any const or volatile qualification from the type of a pointer or reference </li>
  <li> MISRA C:2012, 11.8 - A cast shall not remove any const or volatile qualification from the type pointed to by a pointer </li>
  <li> <a href="https://wiki.sei.cmu.edu/confluence/x/HNcxBQ">CERT, EXP32-C.</a> - Do not access a volatile object through a nonvolatile reference
  </li>
  <li> <a href="https://wiki.sei.cmu.edu/confluence/x/P9YxBQ">CERT, EXP05-C.</a> - Do not cast away a const qualification </li>
  <li> <a href="https://wiki.sei.cmu.edu/confluence/x/AHw-BQ">CERT, EXP55-CPP.</a> - Do not access a cv-qualified object through a cv-unqualified type
  </li>
  <li> C++ Core Guidelines Type.3 - Don’t use const_cast to cast away const (i.e., at all): Don’t cast away const. </li>
</ul>