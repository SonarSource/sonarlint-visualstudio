<p>If the lifetime of the arguments passed to a lambda function is longer than the lifetime of the lambda itself, these arguments can be passed by
reference.</p>
<p>Doing so avoids copying potentially big objects and it should be preferred over using copy capture.</p>
<p>This rule reports an issue if a lambda passed into an algorithm that uses it locally (all algorithms in headers <code>&lt;algorithm&gt;</code> and
<code>&lt;numeric&gt;</code>) captures some values.</p>
<h2>Noncompliant Code Example</h2>
<pre>
using Vec = vector&lt;int&gt;;

Vec applyPermutation(const Vec&amp; v, const Vec&amp; permutation) {
    assert(v.size() == permutation.size());

    const auto n = v.size();
    Vec result(n);

    // Noncompliant: this will copy the entire v vector for each iteration, resulting in n^2 operations
    transform(permutation.begin(), permutation.end(), back_inserter(result),
      [v](int position){ return v[position]; });

     return result;
}
</pre>
<h2>Compliant Solution</h2>
<pre>
using Vec = vector&lt;int&gt;;

Vec applyPermutation(const Vec&amp; v, const Vec&amp; permutation) {
    assert(v.size() == permutation.size());

    const auto n = v.size();
    Vec result(n);

    // Compliant: this will NOT copy the entire v vector for each iteration, resulting in n operations
    transform(permutation.begin(), permutation.end(), back_inserter(result),
      [&amp;v](int position){ return v[position]; });

     return result;
}
</pre>
<h2>See</h2>
<ul>
  <li> <a
  href="https://github.com/isocpp/CppCoreGuidelines/blob/036324/CppCoreGuidelines.md#f52-prefer-capturing-by-reference-in-lambdas-that-will-be-used-locally-including-passed-to-algorithms">C++ Core Guidelines F.52</a> - Prefer capturing by reference in lambdas that will be used locally, including passed to algorithms </li>
</ul>