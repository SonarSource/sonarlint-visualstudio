<p>C++ allows the traditional C-style casts [E.G. <code>(int) f</code>] and functional notation casts [E.G. <code>int(f)</code>], but adds its own
forms:</p>
<ul>
  <li> <code>static_cast&lt;type&gt;(expression)</code> </li>
  <li> <code>const_cast&lt;type&gt;(expression)</code> </li>
  <li> <code>dynamic_cast&lt;type&gt;(expression)</code> </li>
  <li> <code>reinterpret_cast&lt;type&gt;(expression)</code> </li>
  <li> <code>std::bit_cast&lt;type&gt;(expression)</code> (since C++20) </li>
</ul>
<p>C-style casts and functional notation casts are largely functionally equivalent. However, when they do not invoke a converting constructor, C-style
casts are capable of performing dangerous conversions between unrelated types and of changing a variable’s <code>const</code>-ness. Attempt to do
these things with an explicit C++-style cast, and the compiler will catch the error. Use a C-style or functional notation cast, and it cannot.</p>
<p>Moreover, C++20 has introduced a <code>std::bit_cast</code> as a way of reinterpreting a value as being of a different type of the same length
preserving its binary representation. The behavior of such conversion when performed via C-style cast or <code>reinterpret_cast</code> is
undefined.</p>
<p>Additionally, C++-style casts are preferred because they are visually striking. The visual subtlety of a C-style or functional cast may mask that a
cast has taken place, but a C++-style cast draws attention to itself, and makes the the programmer’s intention explicit.</p>
<p>This rule raises an issue when C-style cast or functional notation cast is used.</p>
<h2>Noncompliant Code Example</h2>
<pre>
#include &lt;iostream&gt;

class Base { };

class Derived: public Base
{
public:
  int a;
};

void DoSomethingElse(Derived *ptr)
{
  ptr-&gt;a = 42;
}

void DoSomething(const Base *ptr)
{
  Derived* derived = (Derived*)ptr; // Noncompliant; inadvertently removes constness
  DoSomethingElse(derived);
}

void checksBits(float f)
{
    int x = *(int*)&amp;f; // Noncompliant; has undefined behavior
}

int main(int argc, char* argv[])
{
  Derived *ptr = new Derived();
  ptr-&gt;a = 1337;

  DoSomething(ptr);

  std::cout &lt;&lt; ptr-&gt;a &lt;&lt; std::endl; /* 1337 was expected, but 42 is printed */

  return 0;
}
</pre>
<h2>Compliant Solution</h2>
<pre>
/* ... */

void DoSomething(const Base *ptr)
{
  /* error: static_cast from type 'const Base*' to type 'Derived*' casts away qualifiers */
  Derived* derived = static_cast&lt;Derived*&gt;(ptr); // Compliant. Compile fails with above error
  DoSomethingElse(derived);
}

void checksBits(float f)
{
    int x = std::bit_cast&lt;int&gt;(f);
}

/* ... */
</pre>
<h2>Exceptions</h2>
<p>Void casts and explicit constructor calls are allowed.</p>
<h2>See</h2>
<ul>
  <li> MISRA C++:2008, 5-2-4 - C-style casts (other than void casts) and functional notation casts (other than explicit constructor calls) shall not
  be used. </li>
</ul>