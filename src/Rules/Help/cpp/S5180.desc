<p>Taking the address of a library function is not something robust: The library might make changes to a function that are compatible with a normal
use of a function, but not with taking its address (for instance, adding a parameter with a default value, or adding an overload to an overload set).
More specifically, the standard library has stated that there would be no barrier against such changes, and that for stability users should not take
the address of standard library functions.</p>
<p>Starting with C++20, itâ€™s no longer allowed to take the address of a standard library function (with some exceptions with functions for formatting
streams).</p>
<h2>Noncompliant Code Example</h2>
<pre>
int main() {
  std::unique_ptr&lt;std::FILE, int(*)(std::FILE*)&gt; fp(
    std::fopen("test.txt", "r"),
    std::fclose); // Noncompliant, address of fclose is implicitly taken
  // Work with fp
}
</pre>
<h2>Compliant Solution</h2>
<pre>
int main() {
  std::unique_ptr&lt;std::FILE, int(*)(std::FILE*)&gt; fp(
    std::fopen("test.txt", "r"),
    [](std::FILE*file){return std::fclose(file);});
  // Work with fp
}
</pre>
<h2>See</h2>
<ul>
  <li> <a href="https://wg21.link/P0921">Document of the C++ standardization committee about change management in the standard library.</a> </li>
</ul>