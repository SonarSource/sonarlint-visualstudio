<p>The class <code>std::optional</code> stores an optional value: a <code>std::optional&lt;T&gt;</code> can either contain a value of type
<code>T</code> or be empty. One way to access the value of a non-empty optional is the <code>operator*</code>, making an optional look like a
pointer.</p>
<p>However, the similarity ends there. In particular, the preferred way to assign a value to an optional is to assign it directly (as opposed to
assigning it to the dereferenced value or to the result of the function <code>value()</code>). In that case, the assignment works even if the optional
does not have a prior value.</p>
<h2>Noncompliant Code Example</h2>
<pre>
void g(std::optional&lt;int&gt; &amp;val, bool b) {
    if (b) {
      *val = 314; // Noncompliant, will throw if the optional was previously empty
    } else {
      val.value() = 42; // Noncompliant, will throw if the optional was previously empty
    }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
void g(std::optional&lt;int&gt; &amp;val, bool b) {
    if (b) {
      val = 314; // Compliant
    } else {
      val = 42; // Compliant
    }
}
</pre>