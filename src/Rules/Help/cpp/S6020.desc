<p>When they were first introduced in the language, type traits, defined in header <code>&lt;type_traits&gt;,</code>&nbsp;required to use nested types
(with <code>::type</code>)&nbsp;or nested values (with <code>::value</code>) to access the result of the trait. Since then, the language introduced
templated alias declaration and variable templates that allow to define traits in a more direct and readable way.</p>
<p>Even if the old variant still exists, the new one, which uses <code>_t</code> (C++14) and <code>_v</code> (C++17) suffixes as discriminant, should
be preferred.</p>
<h2>Noncompliant Code Example</h2>
<pre>
template&lt;class T&gt;
void f(T t) {
  static_assert (std::is_arithmetic&lt;T&gt;::value); // Noncompliant
  using rawType = std::remove_cv&lt;T&gt;::type; // Noncompliant
}
</pre>
<h2>Compliant Solution</h2>
<pre>
template&lt;class T&gt;
void f(T t) {
  static_assert (std::is_arithmetic_v&lt;T&gt;); // Compliant, C++17
  using rawType = std::remove_cv_t&lt;T&gt;; // Compliant, C++14
}
</pre>