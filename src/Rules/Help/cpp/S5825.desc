<p>C provides a way of defining or aliasing a type through <code>typedef</code>. On top of it, C++ adds <code>using</code> that can do the same and
more.</p>
<p>Using a macro to define a type is inferior to the previous ways for two reasons:</p>
<ul>
  <li> macros cannot be enclosed into scopes. Or at least, doing so is cumbersome and error-prone as in that case, the macro needs to be defined and
  undefined manually. </li>
  <li> macros are handled by the preprocessor and are not understood from the compiler. They can easily pollute the code in places where types are not
  expected. <code>typedef</code> and <code>using</code> are known to the compiler to define types and can be more strictly checked. </li>
</ul>
<p>As a result, macros should not be used as a replacement to&nbsp;<code>typedef</code> or <code>using</code>.</p>
<h2>Noncompliant Code Example</h2>
<pre>
#define UINT unsigned int  // Noncompliant
#define INT int  // Noncompliant
UINT uabs( INT i );
</pre>
<h2>Compliant Solution</h2>
<pre>
typedef unsigned int UINT;
typedef int INT;
UINT uabs( INT i );
</pre>
<p>or</p>
<pre>
using UINT = unsigned int;
using INT = int;
UINT uabs( INT i );
</pre>
<h2>See</h2>
<ul>
  <li> <a href="https://wiki.sei.cmu.edu/confluence/display/c/PRE03-C.+Prefer+typedefs+to+defines+for+encoding+non-pointer+types">CERT, PRE03-C.</a> -
  Prefer typedefs to defines for encoding non-pointer types </li>
</ul>