<p>Using <code>std::bind</code> or <code>boost::bind</code> allows to create a wrapper to a function where some arguments are bound to fixed values,
or the order of arguments is changed. However, this way of wrapping a function comes with some issues:</p>
<ul>
  <li> The code is not really clear, the usage of placeholders makes it difficult to follow, </li>
  <li> The complexity of the implementation of <code>std::bind</code> often results in sub-optimal code, </li>
  <li> The possibilities offered by <code>bind</code> are limited, for instance, itâ€™s not possible to bind a function with variable arguments, </li>
  <li> <code>bind</code> allows to silently discard some arguments, which is often not what was expected, </li>
  <li> Fixed arguments are evaluated when <code>bind</code> is called, not when the bound function is called, which might be surprising in some cases,
  </li>
  <li> <code>bind</code> requires to take the address of a function, which can be difficult (if the function is overloaded) or not recommended (for
  standard library functions, see {rule:cpp:S5180}). </li>
</ul>
<p>To create such a wrapper, it is usually better to:</p>
<ul>
  <li> either write a simple lambda that just calls the wrapped function with the full power of the language concerning how the arguments are going to
  be tinkered with. </li>
  <li> or, if the function <code>bind</code> is only applied to the first arguments, call <code>std::bind_front</code> that has been introduced in
  C++20 and that is safer to use and a simpler replacement than lambdas. </li>
</ul>
<h2>Noncompliant Code Example</h2>
<pre>
constexpr int multiply(int a, int b) {return a*b;}
auto flipMultiplication = std::bind(multiply, std::placeholders::_2, std::placeholders::_1); // Noncompliant
int i = flipMultiplication (6, 7);

struct Logger {
    string subsystem;
    template &lt;class T&gt;
    void operator()(T const &amp;what) {  cout &lt;&lt; subsystem &lt;&lt; ": " &lt;&lt; what &lt;&lt; "\n"; }
};

void f(){
    Logger net {"network"};
    // Noncompliant in C++14, compliant by exception in C++11 because it would require a polymorphic lambda
    auto networkLog = bind(net, _1);
    networkLog(4);
}
</pre>
<h2>Compliant Solution</h2>
<pre>
constexpr int multiply(int a, int b) {return a*b;}
auto flipMultiplication = [](int a, int b) {return multiply(b, a);}; // Compliant
int i2 = flipMultiplication (6, 7);

void f(){
    Logger net {"network"};
    auto networkLog = [&amp;](auto what) {net(what);}; // Compliant
    networkLog(4);
}{code}
</pre>
<h2>Exceptions</h2>
<p>Before C++14 lambda was limited and could not capture by move or be polymorphic. Therefore, if the call to <code>bind</code> makes use of those
features, it will not be reported in C++11.</p>
<h2>See</h2>
<ul>
  <li> <a href="https://abseil.io/tips/108">Abseil - Avoid std::bind</a> </li>
  <li> Effective modern C++ item 34: Prefer lambdas to <code>std::bind</code> </li>
</ul>