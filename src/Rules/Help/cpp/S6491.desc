<p><code>std::format</code> and the related formatting functions provide two different options to pad numerical values up to a specific width:</p>
<ul>
  <li> The usual character padding that applies to many types and looks like: <code>std::format(“{:*&gt;5}”, num);</code>. This adds as many '*'
  characters as necessary to reach a width of 5. </li>
  <li> Adding the number 0 just before the width to declare numeric padding: <code>std::format(“{:05}”, num);</code>. This numeric padding adds 0
  before the number and therefore takes no alignment option. </li>
</ul>
<p>When working with numeric values, one almost always wants to use the numeric padding as it works correctly with signed numbers:</p>
<pre>
std::format("{:0&gt;5}", -10); // Usual padding, prints 00-10
std::format("{:05}", -10);  // Numeric padding, -0010
</pre>
<p>This rule raises an issue when a format specification uses '0' as a padding character instead of using numeric padding.</p>
<h2>Noncompliant Code Example</h2>
<pre>
void formatted(int i, double d) {
 std::cout &lt;&lt; std::format("{:0&gt;5}\n", i); // Noncompliant
 std::cout &lt;&lt; std::format("{:0&gt;#5}\n", d); // Noncompliant
}
</pre>
<h2>Compliant Solution</h2>
<pre>
void formatted(int i, double d) {
 std::cout &lt;&lt; std::format("{:05}\n", i); // Compliant
 std::cout &lt;&lt; std::format("{:#05}\n", d); // Compliant
}
</pre>