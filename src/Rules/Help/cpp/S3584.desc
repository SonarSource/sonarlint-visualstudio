<p>Memory allocated dynamically with <code>calloc(...)</code>, <code>malloc(...)</code>, <code>realloc(...)</code> or <code>new</code> should be
released when it’s not needed anymore. Failure to do so will result in a memory leak that could bring the box to its knees.</p>
<p>This rule raises an issue when memory is allocated and not freed in the same function. Allocated memory is ignored if a pointer to it is
<code>return</code>ed to the caller or stored in a structure that’s external to the function.</p>
<h2>Noncompliant Code Example</h2>
<pre>
int fun() {
  char* name = (char *) malloc (size);
  if (!name) {
    return 1;
  }
  // ...
  return 0; // Noncompliant, memory pointed by "name" has not been released
}
</pre>
<h2>Compliant Solution</h2>
<pre>
int fun() {
  char* name = (char *) malloc (size);
  if (!name) {
    return 1;
  }
  // ...
  free(name);
  return 0;
}
</pre>
<h2>See</h2>
<ul>
  <li> <a href="https://cwe.mitre.org/data/definitions/401">MITRE, CWE-401</a> - Improper Release of Memory Before Removing Last Reference ('Memory
  Leak') </li>
  <li> <a href="https://wiki.sei.cmu.edu/confluence/x/FtYxBQ">MEM00-C.</a> - Allocate and free memory in the same module, at the same level of
  abstraction </li>
  <li> <a href="https://wiki.sei.cmu.edu/confluence/x/GNYxBQ">CERT, MEM31-C.</a> - Free dynamically allocated memory when no longer needed </li>
</ul>