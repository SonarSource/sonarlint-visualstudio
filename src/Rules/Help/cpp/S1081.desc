<p>When using typical C functions, itâ€™s up to the developer to make sure the size of the buffer to be written to is large enough to avoid buffer
overflows. Buffer overflows can cause the program to crash at a minimum. At worst, a carefully crafted overflow can cause malicious code to be
executed.</p>
<p>This rule reports use of the following insecure functions, for which knowing the required size is not generally possible: <code>gets()</code> and
<code>getpw()</code>.</p>
<p>In such cases. The only way to prevent buffer overflow while using these functions would be to control the execution context of the
application.</p>
<p>It is much safer to secure the application from within and to use an alternate, secure function which allows you to define the maximum number of
characters to be written to the buffer:</p>
<ul>
  <li> <code>fgets</code> or <code>gets_s</code> </li>
  <li> <code>getpwuid</code> </li>
</ul>
<h2>Noncompliant Code Example</h2>
<pre>
gets(str); // Noncompliant; `str` buffer size is not checked and it is vulnerable to overflows
</pre>
<h2>Compliant Solution</h2>
<pre>
gets_s(str, sizeof(str)); // Prevent overflows by enforcing a maximum size for `str` buffer
</pre>
<h2>See</h2>
<ul>
  <li> <a href="https://owasp.org/www-project-top-ten/2017/A9_2017-Using_Components_with_Known_Vulnerabilities">OWASP Top 10 2017 Category A9</a> -
  Using Components with Known Vulnerabilities </li>
  <li> <a href="https://cwe.mitre.org/data/definitions/676">MITRE, CWE-676</a> - Use of Potentially Dangerous Function </li>
  <li> <a href="https://cwe.mitre.org/data/definitions/119">MITRE, CWE-119</a> - Improper Restriction of Operations within the Bounds of a Memory
  Buffer </li>
  <li> <a href="https://www.sans.org/top25-software-errors/#cat2">SANS Top 25</a> - Risky Resource Management </li>
</ul>