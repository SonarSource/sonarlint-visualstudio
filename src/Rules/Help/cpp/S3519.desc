<p>Array overruns and buffer overflows happen when memory access accidentally goes beyond the boundary of the allocated array or buffer. These
overreaching accesses cause some of the most damaging, and hard to track defects.</p>
<h2>Noncompliant Code Example</h2>
<pre>
int array[10];
array[10] = 0; // Noncompliant: index should be between 0 &amp; 9

char *buffer1 = (char *) malloc(100);
char *buffer2 = (char *) malloc(50);
memcpy(buffer2, buffer1, 100); // Noncompliant: buffer2 will overflow.
</pre>
<h2>Compliant Solution</h2>
<pre>
int array[10];
array[9] = 0;

char *buffer1 = (char *) malloc(100);
char *buffer2 = (char *) malloc(50);
memcpy(buffer2, buffer1, 50);
</pre>
<h2>See</h2>
<ul>
  <li> <a href="https://cwe.mitre.org/data/definitions/119">MITRE, CWE-119</a> - Improper Restriction of Operations within the Bounds of a Memory
  Buffer </li>
  <li> <a href="https://cwe.mitre.org/data/definitions/131">MITRE, CWE-131</a> - Incorrect Calculation of Buffer Size </li>
  <li> <a href="https://cwe.mitre.org/data/definitions/788">MITRE, CWE-788</a> - Access of Memory Location After End of Buffer </li>
  <li> <a href="https://wiki.sei.cmu.edu/confluence/x/wtYxBQ">CERT, ARR30-C.</a> - Do not form or use out-of-bounds pointers or array subscripts </li>
  <li> <a href="https://wiki.sei.cmu.edu/confluence/x/i3w-BQ">CERT, STR50-CPP.</a> - Guarantee that storage for strings has sufficient space for
  character data and the null terminator </li>
</ul>