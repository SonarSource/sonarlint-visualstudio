<p>It is a best practice to make lambda return types implicit whenever possible. First and foremost, doing so avoids implicit conversions, which could
result in data or precision loss. Second, omitting the return type often helps future-proof the code.</p>
<p>The issue is raised when explicit return types are used.</p>
<h2>Noncompliant Code Example</h2>
<pre>
// Noncompliant: the explicit return types are redundant.
[](int i) -&gt; int { return i + 42; }
[]() -&gt; auto { return foo(); }
[](int x) -&gt; std::vector&lt;int&gt; { return std::vector&lt;int&gt;{ x }; }
</pre>
<h2>Compliant Solution</h2>
<pre>
// Compliant: no explicit return type.
[](int i) { return i + 42; }
[]() { return foo(); }
[](int x) { return std::vector&lt;int&gt;{ x }; }
</pre>
<h2>Exceptions</h2>
<p>There are a few exceptions to this rule.</p>
<p>First, no issue is raised when the compiler is not deducing the same type by itself. This can happens when a conversion is requested.</p>
<pre>
// Compliant: the compiler would deduce a different return type.
[](int x) -&gt; double { return x; }
[](float x) -&gt; int { return x; } // Precision loss, see S5276.
</pre>
<p>The compiler also deduces a different type when there are no <code>return</code> statements and the explicit return type is not
<code>void</code>.</p>
<pre>
// Compliant: removing these explicit return types would result in a different signature.
[](int x) -&gt; int { throw std::runtime_error("No more eggs"); }
[](int x) -&gt; int { std::terminate(); }
</pre>
<p>Another similar situation is when references are involved: instead, the compiler deduces a value without an explicit return type. This can have an
impact on both correctness and performance.</p>
<pre>
// Compliant: removing the explicit return type would return a copy.
[](std::vector&lt;int&gt;&amp; data) -&gt; auto&amp; {
    std::sort(data.begin(), data.end());
    return data;
}
</pre>
<p>Additionally, no issues are raised when the deduction of the return type is not available. This is the case with C++20 coroutines in their lambda
form.</p>
<pre>
// Compliant: coroutine lambdas cannot rely on type deduction.
[]() -&gt; Task { co_await std::suspend_always{}; }
</pre>
<p>In some other cases, removing the explicit return type would result in ill-formed programs. This is the case when using initializer lists or
aggregate initializations.</p>
<pre>
// Compliant: type deduction wouldn't work.
[](int x) -&gt; std::vector&lt;int&gt; { return { x }; }
[]() -&gt; std::array&lt;int, 4&gt; { return { 1, 2, 3, 4 }; }
</pre>
<p>Removing the explicit return type when a lambda has multiple <code>return</code> statements of different types would also result in ill-formed
programs. Here are two examples where the explicit return type introduces useful implicit conversions.</p>
<pre>
// Compliant: omitting the return type would result in a compilation error.
[](Base* ptr) -&gt; Derived* {
    if (auto* derived = dynamic_cast&lt;Derived*&gt;(ptr)) {
        actOnDerived(derived);
        return derived;
    }

    // "nullptr_t" mismatches the previous return type "Derived*".
    return nullptr;
}

// Compliant: omitting the return type would result in a compilation error.
[](std::string_view request) -&gt; std::variant&lt;Error, Data&gt; {
    if (!isRequestValid(request)) {
        return Error{ "invalid request" };
    }

    auto reader = readRequest(request);
    // "Data" mismatches the previous return type "Error".
    return Data{ reader.data(), reader.size() };
}
</pre>
<p>Finally, this rule does not trigger on explicit template-dependent or constrained return types since they can have a use of their own, help
readability or improve maintainability.</p>
<pre>
// Compliant: enforce "process()" returns a reference.
[](auto x) -&gt; auto&amp; { return process(x); }

// Compliant: ensure the lambda returns a reference when "f()" does.
[f](auto arg) -&gt; decltype(f(arg)) { return f(arg); }

// Compliant: the return type restricts possible input types.
[](auto x) -&gt; std::enable_if_t&lt;std::is_integral_v&lt;decltype(x)&gt;&gt; { process(x); }

template &lt;typename T&gt;
T getGlobalProperty(std::string_view name, T defaultValue) { /* ... */ }

// Compliant: the return type is constrained (C++20) and can help maintainability.
auto getProperty = [](std::string_view name) -&gt; std::totally_ordered auto {
    return getGlobalProperty(name, 0);
}
</pre>
<h2>See</h2>
<ul>
  <li> {rule:cpp:S5276}: Implicit casts should not lower precision </li>
</ul>