<p>When <code>~</code> and <code>&lt;&lt;</code> are applied to small integer types (<code>unsigned char</code> or <code>unsigned short</code>), the
operations are preceded by integral promotion, and the result may contain high-order bits which have not been anticipated.</p>
<h2>Noncompliant Code Example</h2>
<pre>
unsigned char port = 0x5aU;
unsigned char result_8;
unsigned short result_16;
unsigned short mode;
result_8 = (~port) &gt;&gt; 4; // Noncompliant; '~port' is 0xFFA5 on a 16-bit machine but 0xFFFFFFA5 on a 32-bit machine. Result is 0xFA for both, but 0x0A may have been expected.
result_16 = ((port &lt;&lt; 4) &amp; mode) &gt;&gt; 6; // Noncompliant; result_16 value depends on the implemented size of an int.
</pre>
<h2>Compliant Solution</h2>
<pre>
result_8 = ((unsigned char)(~port)) &gt;&gt; 4; // Compliant
result_16 = ((unsigned short)((unsigned short) port &lt;&lt; 4) &amp; mode) &gt;&gt; 6; // Compliant
</pre>
<h2>See</h2>
<ul>
  <li> MISRA C 2004, 10.5 - If the bitwise operators ~ and &lt;&lt; are applied to an operand of <em>underlying type</em> unsigned char or unsigned
  short, the result shall be immediately cast to the <em>underlying type</em> of the operand. </li>
  <li> MISRA C++ 2008, 5-0-10 - If the bitwise operators ~ and &lt;&lt; are applied to an operand with an <em>underlying type</em> of unsigned char or
  unsigned short, the result shall be immediately cast to the <em>underlying type</em> of the operand. </li>
</ul>