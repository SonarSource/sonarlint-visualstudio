<p><code>C++17</code> introduces <code>std::optional&lt;T&gt;</code>, a template class which manages an optional contained value. By default, the
container doesnâ€™t contain any value. The contained value can be accessed through member functions like <code>value()</code>, <code>operator*()</code>,
or <code>operator-&gt;()</code>. Before accessing the value it is a good practice to check its presence using <code>has_value()</code> or
<code>operator bool()</code>.</p>
<p><code>value_or(default_value)</code> member function returns the contained value if present or <code>default_value</code> otherwise. This rule
flags patterns which could be simplified by a single call to <code>value_or(default_value)</code> instead of two steps logic:</p>
<ul>
  <li> check presence, i.e. with <code>has_value</code> </li>
  <li> use <code>value()</code> if present, <code>default_value</code> otherwise </li>
</ul>
<h2>Noncompliant Code Example</h2>
<pre>
void fun(const std::optional&lt;std::string&gt; &amp;arg) {
  if (arg.has_value()) { // Noncompliant, the entire if statement can be simplified to a simpler statement using "value_or(default_value)"
    std::cout &lt;&lt; arg.value();
  } else {
    std::cout &lt;&lt; "magic";
  }

  // another way to check presence and access value
  std::cout &lt;&lt; (arg ? *arg : "magic"); // Noncompliant, replace the ternary operator by using "value_or(default_value)"
}
</pre>
<pre>
void moveFun(std::optional&lt;std::string&gt; arg) {
  if (arg.has_value()) { // Noncompliant, the entire if statement can be simplified to a simpler statement using "value_or(default_value)"
    sink(std::move(arg.value()));
  } else {
    sink("magic");
  }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
void fun(const std::optional&lt;std::string&gt; &amp;arg) {
  std::cout &lt;&lt; arg.value_or("magic"); // Compliant, neat and simple
}
</pre>
<pre>
void moveFun(std::optional&lt;std::string&gt; arg) {
  sink(std::move(arg).value_or("magic"));
}
</pre>