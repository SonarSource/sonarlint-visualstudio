<p>It is often considered a better style to access objects in generic code with free functions than with member functions, because it allows to adapt
an object to a template without modifying it, just by adding the right overload of the free function. This is especially true with containers, which
can come in a wide variety (and some of them canâ€™t even have member function, for instance, C-style arrays).</p>
<p>Therefore, the C++ standard library provides free functions that can be applied on any standard container, and that can be adapted for user-defined
containers. They are:</p>
<ul>
  <li> Since C++11: <code>std::begin</code>, <code>std::end</code>, <code>std::cbegin</code>, <code>std::cend</code> </li>
  <li> Since C++14: <code>std::rbegin</code>, <code>std::rend</code>, <code>std::crbegin</code>, <code>std::crend</code> </li>
  <li> Since C++17: <code>std::size</code>, <code>std::empty</code>, <code>std::data</code> </li>
  <li> Since C++20: <code>std::ssize</code> </li>
</ul>
<p>When writing generic code, you should prefer using those functions for objects that depend on the template arguments: it will allow your code to
work with a broader variety of containers.</p>
<h2>Noncompliant Code Example</h2>
<pre>
template&lt;class T&gt;
bool f(T const &amp;t, std::vector&lt;int&gt; const &amp;v) {
  if (!t.empty()) { // Noncompliant in C++17
    auto val = (t.begin() // Noncompliant in C++11
      -&gt;size()); // Noncompliant in C++17
    return val == v.size(); // Compliant, v does not depend on a template parameter
  }
  return false;
}
</pre>
<h2>Compliant Solution</h2>
<pre>
template&lt;class T&gt;
bool f(T const &amp;t, std::vector&lt;int&gt; const &amp;v) {
  if (!std::empty(t)) { // Compliant
    auto val = std::size(*std::begin(t)); // Compliant
    return val == v.size();
  }
  return false;
}
</pre>