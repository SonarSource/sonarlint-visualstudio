<p>In some cases, <code>emplace_back</code> is more efficient and less verbose than <code>push_back</code>. It is expected to be faster when the
object is constructed into the container instead of being constructed then assigned. This also happens when the pushed object has a different type
from the one held by the container.</p>
<p>This rule supports standard sequence containers: <code>std::vector</code>, <code>std::list</code>, <code>std::deque</code>,
<code>std::forward_list</code>, <code>std::stack</code>, <code>std::queue</code> and <code>std::priority_queue</code>.</p>
<p>An issue will only be raised when an insertion function on a supported container leads to the construction of a large temporary object that can be
avoided by using the provided emplacement member function.</p>
<h2>Noncompliant Code Example</h2>
<pre>
class Circle { // Large object
std::string s;
int x;
int y;
int radius;
public:
  Circle(int x, int y, int radius);
}

void f() {
  std::vector&lt;std::pair&lt;int, std::string&gt;&gt; vec1;
  std::string s;
  vec1.push_back(std::make_pair(21, s)); // Noncompliant
  std::vector&lt;std::string&gt; vec2;
  vec2.push_back("randomStr"); // Noncompliant, conversion from char const * to string
  std::vector&lt;Circle&gt; circles;
  circles.push_back(Circle{2, 42, 10}); // Noncompliant
}
</pre>
<h2>Compliant Solution</h2>
<pre>
void f() {
  std::vector&lt;std::pair&lt;int, std::string&gt;&gt; vec1;
  std::string s;
  vec1.emplace_back(21, s); // Compliant
  std::vector&lt;std::string&gt; vec2;
  vec2.emplace_back("randomStr"); // Compliant
  std::vector&lt;Circle&gt; circles;
  circles.emplace_back(2, 42, 10); // Compliant
}
</pre>
<h2>Exceptions</h2>
<ul>
  <li> When <code>emplace_back</code> isnâ€™t exception-safe. When emplacing in a container of smart pointers a raw new expression, the memory will be
  leaked if <code>emplace_back</code> throws an exception. </li>
</ul>
<h2>See</h2>
<ul>
  <li> Effective modern C++ item 42: Consider emplacement instead of insertion. </li>
</ul>