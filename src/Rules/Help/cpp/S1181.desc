<p>Some exception classes are designed to be used only as base classes to more specific exceptions, for instance <code>std::exception</code> (the base
class of all standard C++ exceptions), <code>std::logic_error</code> or <code>std::runtime_error</code>.</p>
<p>Catching such a generic exception types is a usually bad idea, because it implies that the "catch" block is clever enough to handle any type of
exception.</p>
<h2>Noncompliant Code Example</h2>
<pre>
try {
  /* code that may throw std::system_error */
} catch (const std::exception &amp;ex) { // Noncompliant
  /*...*/
}
</pre>
<h2>Compliant Solution</h2>
<pre>
try {
  /* code that may throw std::system_error */
} catch (const std::system_error &amp;ex) {
  /*...*/
}
</pre>
<h2>Exceptions</h2>
<p>There are cases though where you want to catch all exceptions, because no exceptions should be allowed to escape the function, and generic
<code>catch</code> handlers are excluded from the rule:</p>
<ul>
  <li> In the main function </li>
  <li> In a class destructor </li>
  <li> In a <code>noexcept</code> function </li>
  <li> In an <code>extern "C"</code> function </li>
</ul>
<p>Additionally, if the <code>catch</code> handler is throwing an exception (either the same as before, with <code>throw;</code> or a new one that may
make more sense to the callers of the function), or is never exiting (because it calls a <code>noreturn</code> function, for instance
<code>exit</code>), then the accurate type of the exception usually does not matter any longer: this case is excluded too.</p>
<h2>See</h2>
<ul>
  <li> <a href="https://cwe.mitre.org/data/definitions/396">MITRE, CWE-396</a> - Declaration of Catch for Generic Exception </li>
  <li> <a href="https://github.com/isocpp/CppCoreGuidelines/blob/036324/CppCoreGuidelines.md#Re-exception-types">C++ Core Guidelines E.14</a> - Use
  purpose-designed user-defined types as exceptions (not built-in types) </li>
</ul>