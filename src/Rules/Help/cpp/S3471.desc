<p>In a base class, <code>virtual</code> indicates that a function can be overridden. In a derived class, it indicates an override. But given the
specifierâ€™s dual meaning, it would be both clearer and more sound to use derived class-specific specifiers instead: <code>override</code> or
<code>final</code>.</p>
<ul>
  <li> <code>final</code> indicates a function <code>override</code> that cannot itself be overridden. The compiler will issue a warning if the
  signature does not match the signature of a base-class <code>virtual</code> function. </li>
  <li> <code>override</code> indicates that a function is intended to override a base-class function. The compiler will issue a warning if this is not
  the case. It is redundant in combination with <code>final</code>. </li>
</ul>
<h2>Noncompliant Code Example</h2>
<pre>
class Counter {
protected:
  int c = 0;
public:
  virtual void count() {
    c++;
  }
};

class FastCounter: public Counter {
public:
  virtual void count() {  // Noncompliant
    c += 2;
  }
};
</pre>
<h2>Compliant Solution</h2>
<pre>
class Counter {
protected:
  int c = 0;
public:
  virtual void count() {
    c++;
  }
};

class FastCounter: public Counter {
public:
  void count() override {
    c += 2;
  }
};
</pre>
<p>or</p>
<pre>
class Counter {
protected:
  int c = 0;
public:
  virtual void count() {
    c++;
  }
};

class FastCounter: public Counter {
public:
  void count() final {
    c += 2;
  }
};
</pre>
<h3>See</h3>
<ul>
  <li> {rule:cpp:S1016} </li>
  <li> <a
  href="https://github.com/isocpp/CppCoreGuidelines/blob/036324/CppCoreGuidelines.md#c128-virtual-functions-should-specify-exactly-one-of-virtual-override-or-final">C++ Core Guidelines C.128</a> - Virtual functions should specify exactly one of virtual, override, or final </li>
</ul>