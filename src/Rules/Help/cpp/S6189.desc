<p>C++20 introduces full template support for lambda functions on par with the regular template functions. The full template syntax for a lambda adds
a template-arguments clause after the capture clause completing the panoply of brackets: []&lt;&gt;(){}. For example:</p>
<pre>
[]&lt;typename T&gt;(T arg) { return arg; }
</pre>
<p>Although more verbose than using <code>auto</code> for the types of the arguments, this syntax enables you to name the types for the parameters,
constrain these types (see Concepts), and reuse these types for multiple arguments.</p>
<p>One common use case for the named template argument is a lambda with multiple arguments of the same type. Pre-C++20 code had to resort to the use
of <code>decltype</code>: <code>[](auto arg1, decltype(arg1) arg2) ... </code>. Not only is it obscure it also only approximates our goal: it requires
the second-argument type to be convertible to the first-argument type.</p>
<p>Moreover, similar issues may appear for normal functions, that declare parameters with <code>auto</code> in place of type using C++20 abbreviated
template syntax.</p>
<p>This rule reports the use of <code>decltype(arg)</code> for parameters introduced with <code>auto</code>.</p>
<h2>Noncompliant Code Example</h2>
<pre>
void f1() {
  auto sum = [](auto fir, decltype(fir) sec) { return fir + sec; }; // Noncompliant
  std::cout &lt;&lt; sum(true, 1); // Prints 2
}

void f2(auto param) {  // Noncompliant
   decltype(param) copy = param;
}
</pre>
<h2>Compliant Solution</h2>
<pre>
void f1() {
  auto sum = []&lt;class T&gt;(T fir, T sec) { return fir + sec; }; // Compliant
  // std::cout &lt;&lt; sum(true, 1); - compilation error
}

template&lt;class T&gt;
void f2(T param) { // Compliant
    T copy = param;
}
</pre>
<h2>See</h2>
<ul>
  <li> <a href="https://www.modernescpp.com/index.php/more-powerful-lambdas-with-c-20">Modern C++: More powerful lambdas with C++20</a> </li>
</ul>