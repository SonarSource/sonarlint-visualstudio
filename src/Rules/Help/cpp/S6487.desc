<p><code>std::format</code> takes as an argument a format string that contains replacement fields (surrounded with <code>{}</code>) and a set of extra
arguments that will be formatted inside the replacement fields. Even if the format string is checked at compile-time, it is possible to have a
mismatch between the format string and the arguments. For example, when:</p>
<ul>
  <li> The format string contains fewer replacement fields than the number of extra arguments: <code>std::format("{} {}", 1, 2, 3);</code> </li>
  <li> The format string uses indexes for the replacement fields, but one index is missing: <code>std::format("{0} {0} {2}", 1, 2, 3);</code> </li>
</ul>
<p>In these cases, the extra arguments are silently ignored. In the best-case scenario, it leads to dead code. Otherwise, it is a typo, and the output
will not be intended.</p>
<p>This rule raises an issue when an unused argument comes from a complex expression, for instance, a function call. Also, when there is a combination
of numbered replacement fields, a missing index, and a repeated index.</p>
<h2>Noncompliant Code Example</h2>
<pre>
std::cout &lt;&lt; std::format("{} {}", 1, 2, sqrt(2)); // Noncompliant
std::cout &lt;&lt; std::format("{0} {0} {2}", 1, 2, 3); // Noncompliant
</pre>
<h2>Compliant Solution</h2>
<pre>
std::cout &lt;&lt; std::format("{} {} {}", 1, 2, sqrt(2)); // Compliant
std::cout &lt;&lt; std::format("{0} {0} {2} {1}", 1, 2, 3); // Compliant
</pre>
<h2>See</h2>
<ul>
  <li> {rule:cpp:S6488} - A version of this rule that triggers on all unused arguments. </li>
</ul>