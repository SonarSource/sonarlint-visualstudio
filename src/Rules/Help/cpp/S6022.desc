<p>C++17 introduced std::byte. It allows you to have byte-oriented access to a memory in a type-safe unambiguous manner. Before, you had to use either
<code>char</code>, <code>signed char</code>, or <code>unsigned char</code> to access memory as bytes. The previous approach is error-prone as
<code>char</code> type allows you to accidentally perform arithmetic operations. Also, it is confusing since <code>char</code>, <code>signed
char</code>, and <code>unsigned char</code> are also used to represent actual characters and arithmetic values.</p>
<p><code>std::byte</code> is simply a scoped enumeration with bit-wise operators and a helper function <code>to_integer&lt;T&gt;</code> to convert
byte object to integral type T.</p>
<p>This rule will detect byte-like usage of <code>char</code>, <code>signed char</code>, and <code>unsigned char</code> and suggest replacing them by
<code>std::byte</code>.</p>
<h2>Noncompliant Code Example</h2>
<pre>
void handleFirstByte(char* byte);

void f(int* i) {
  char* c = reinterpret_cast&lt;char*&gt;(i); // Noncompliant
  handleFirstByte(c);
}

unsigned char negate(unsigned char byte) {
  return ~byte; // Noncompliant
}
</pre>
<h2>Compliant Solution</h2>
<pre>
void handleFirstByte(std::byte* byte);

void f(int* i) {
  std::byte* byte = reinterpret_cast&lt;std::byte*&gt;(i); // Compliant
  handleFirstByte(byte);
}

std::byte negate(std::byte byte) {
  return ~byte; // Compliant
}
</pre>