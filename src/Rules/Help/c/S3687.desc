<p>The main intended use-case for <code>volatile</code> in C and C++ is to access data that can be modified by something external to the program,
typically some hardware register. In contrast with other languages that provide a <code>volatile</code> keyword, it does not provide any useful
guarantees related to atomicity, memory ordering, or inter-thread synchronization. It is only really needed for the kind of low-level code found in
kernels or embedded software, i.e. using memory-mapped I/O registers to manipulate hardware directly.</p>
<p>According to the C standard:</p>
<blockquote>
  <p><code>volatile</code> is a hint to the implementation to avoid aggressive optimization involving the object because the value of the object might
  be changed by means undetectable by an implementation.</p>
</blockquote>
<p>Only C11/C++11 "atomic types" are free from data races, and you should use them or synchronization primitives if you want to avoid race
conditions.</p>
<p>This rule raises an issue when a local variable or class data member is declared as <code>volatile</code> (at the top level of the type, pointers
to volatile are not reported).</p>
<h2>Noncompliant Code Example</h2>
<pre>
volatile int counter; // Noncompliant
User * volatile vpUser; // Noncompliant; pointer is volatile
User volatile * pvUser;  // Compliant; User instance is volatile, not the pointer
</pre>
<h2>Compliant Solution</h2>
<pre>
atomic_int counter;
std::atomic&lt;User*&gt; vpUser;
User volatile * pvUser;
</pre>
<h2>See</h2>
<ul>
  <li> <a href="https://wiki.sei.cmu.edu/confluence/display/c/CON02-C.+Do+not+use+volatile+as+a+synchronization+primitive">CERT CON02-C</a> - Do not
  use volatile as a synchronization primitive </li>
  <li> <a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#cp200-use-volatile-only-to-talk-to-non-c-memory">C++ Core Guidelines
  CP.200</a> - Use volatile only to talk to non-C++ memory </li>
</ul>