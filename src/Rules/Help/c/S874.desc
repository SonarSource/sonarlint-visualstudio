<p>Most built-in bitwise operators (<code>~</code>, <code>&gt;&gt;</code>, <code>&gt;&gt;=</code>, <code>&amp;</code>, <code>&amp;=</code>,
<code>^</code>, <code>^=</code>, <code>|</code>, and <code>|=</code>) have implementation-dependent results when performed on signed operands, and
bitwise left shift (<code>&lt;&lt;</code> and <code>&lt;&lt;=</code>) has unspecified or undefined behavior when performed on negative operands.</p>
<p>Therefore bitwise operations should not be performed on signed operands.</p>
<p>Starting with C++20, the behaviors have been defined more accurately (negative values have to be represented using twoâ€™s complement), and therefore
this rule will only report an issue when the second operand of a shift operator is signed (shifting by a negative value is still undefined
behavior).</p>
<h2>Noncompliant Code Example</h2>
<pre>
if ( ( uint16_a &amp; int16_b ) == 0x1234U ) // Noncompliant until C++20
if ( ~int16_a == 0x1234U ) // Noncompliant until C++20

auto f(int i) {
    return 1 &lt;&lt; i; // Noncompliant
}
</pre>
<h2>Compliant Solution</h2>
<pre>
if ( ( uint16_a | uint16_b ) == 0x1234U )
if ( ~uint16_a == 0x1234U )

auto f(unsigned int i) {
    return 1 &lt;&lt; i;
}
</pre>
<h2>Exceptions</h2>
<p>When used as bit flags, it is acceptable to use preprocessor macros as arguments to the &amp; and | operators even if the value is not explicitly
declared as unsigned.</p>
<pre>
fd = open(file_name, UO_WRONLY | UO_CREAT | UO_EXCL | UO_TRUNC, 0600);
</pre>
<p>If the right-side operand to a shift operator is known at compile time, it is acceptable for the value to be represented with a signed type
provided it is positive.</p>
<pre>
#define SHIFT 24
foo = 15u &gt;&gt; SHIFT;
</pre>
<p>When combining several bitwise operations, even if all leaf operands are unsigned, if they are smaller than an <code>int</code>, some intermediate
results will be of type <code>signed int</code>, due to integral promotion. However, this situation is usually not an issue, and is an exception for
this rule:</p>
<pre>
unsigned int f(unsigned short src) {
  return (src &gt;&gt; 3) &amp; 0x1F; // (src &gt;&gt; 3) is of type signed int
}
</pre>
<h2>See</h2>
<ul>
  <li> MISRA C:2004, 12.7 - Bitwise operators shall not be applied to operands whose underlying type is signed </li>
  <li> MISRA C++:2008, 5-0-21 - Bitwise operators shall only be applied to operands of unsigned underlying type </li>
  <li> MISRA C:2012, 10.1 - Operands shall not be of an inappropriate essential type </li>
  <li> <a href="https://wiki.sei.cmu.edu/confluence/x/9tYxBQ">CERT, INT13-C.</a> - Use bitwise operators only on unsigned operands </li>
  <li> <a href="https://cwe.mitre.org/data/definitions/682">MITRE, CWE-682</a> - Incorrect Calculation </li>
</ul>