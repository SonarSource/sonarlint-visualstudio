<p>Using <code>free(...)</code> or <code>delete</code> releases the reservation on a memory location, making it immediately available for another
purpose. So releasing the same memory location twice can lead to corrupting the programâ€™s memory.</p>
<p>A best practice to avoid this bug calls for setting just-freed pointers to <code>NULL</code>, and always null-testing before a <code>free</code> or
<code>delete</code>.</p>
<h2>Noncompliant Code Example</h2>
<pre>
void doSomething(int size) {
  char *cp = (char *) malloc(sizeof(char) * size);

  // ...
  if (condition) {
    free(cp);
  }

  free(cp);  // Noncompliant
}
</pre>
<h2>Compliant Solution</h2>
<pre>
void doSomething(int size) {
  char *cp = (char *) malloc(sizeof(char) * size);

  // ...
  if (condition) {
    free(cp);
    cp = NULL; // This will prewent freeing the same memory again
  }

  free(cp); // This is OK: if the memory was freed in the if-block above, free(NULL) is a no-op
  cp = NULL; // This will prevent freeing the same memory again
}
</pre>
<h2>See</h2>
<ul>
  <li> <a href="https://cwe.mitre.org/data/definitions/415">MITRE, CWE-415</a> - Double Free </li>
  <li> <a href="https://owasp.org/www-community/vulnerabilities/Doubly_freeing_memory">OWASP, Doubly freeing memory</a> </li>
</ul>