<p>A dead store happens when a local variable is assigned a value that is not read by any subsequent instruction. Calculating or retrieving a value
only to then overwrite it or throw it away, could indicate a serious error in the code. Even if itâ€™s not an error, it is at best a waste of resources.
Therefore all calculated values should be used.</p>
<h2>Noncompliant Code Example</h2>
<pre>
i = a + b; // Noncompliant; calculation result not used before value is overwritten
i = compute();
</pre>
<h2>Compliant Solution</h2>
<pre>
i = a + b;
i += compute();
</pre>
<h2>Exceptions</h2>
<p>This rule ignores:</p>
<ul>
  <li> variable declarations initializers </li>
  <li> prefix and postfix increments and decrements <code>x++;</code> </li>
  <li> null pointer assignments <code>x = NULL;</code> </li>
  <li> self assignments (i.e. <code>x = x;</code>) </li>
</ul>
<h2>See</h2>
<ul>
  <li> <a href="https://cwe.mitre.org/data/definitions/563">MITRE, CWE-563</a> - Assignment to Variable without Use ('Unused Variable') </li>
  <li> <a href="https://wiki.sei.cmu.edu/confluence/x/39UxBQ">CERT, MSC13-C.</a> - Detect and remove unused values </li>
  <li> <a href="https://wiki.sei.cmu.edu/confluence/x/9DZGBQ">CERT, MSC56-J.</a> - Detect and remove superfluous code and values </li>
</ul>