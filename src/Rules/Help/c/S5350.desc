<p>This rule leads to greater precision in the definition of local variables by making the developer intention about modifying the variable explicit.
The <code>const</code> qualification shall be applied to the object pointed to, not to the pointer, since it is the object itself that is being
protected.</p>
<h2>Noncompliant Code Example</h2>
<pre>
std::string&amp; getString();
void myfunc()
{
  std::string&amp; s = getString(); // Noncompliant
  if (s.size()) {
   std::cout &lt;&lt; s;
  }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
std::string&amp; getString();
void myfunc () {
  const std::string&amp; x = getString();
  if (s.size()) {
    std::cout &lt;&lt; s;
  }
}
</pre>
<h2>See</h2>
<ul>
  <li> MISRA C:2012, 8.13 - A pointer should point to a const-qualified type whenever possible </li>
</ul>