<p>The use of dynamic memory can lead to out-of-storage run-time failures, which are undesirable.</p>
<p>The built-in <code>new</code> and <code>delete</code> operators, other than the placement versions, use dynamic heap memory. The functions
<code>calloc</code>, <code>malloc</code>, <code>realloc</code> and <code>free</code> also use dynamic heap memory.</p>
<p>There is a range of unspecified, undefined and implementation-defined behaviour associated with dynamic memory allocation, as well as a number of
other potential pitfalls. Dynamic heap memory allocation may lead to memory leaks, data inconsistency, memory exhaustion, non-deterministic behaviour,
etc.</p>
<p>Note that some implementations may use dynamic heap memory allocation to implement other functions (for example, functions in the library
<code>cstring</code>). If this is the case, then these functions shall also be avoided.</p>
<h2>Noncompliant Code Example</h2>
<pre>
int *b;
void initialize()
{
  b = (int*) malloc(1024 * sizeof(int)); // Noncompliant, could lead to an out-of-storage run-time failure.
  if (b == 0)
  {
    // handle case when dynamic allocation failed.
  }
}
</pre>
<h2>Compliant Solution</h2>
<pre>
int b[1024]; // Compliant solution.
</pre>
<h2>See</h2>
<ul>
  <li> MISRA C:2004, 20.4 - Dynamic heap memory allocation shall not be used. </li>
  <li> MISRA C++ 2008, 18-4-1 - Dynamic heap memory allocation shall not be used. </li>
  <li> MISRA C:2012, 21.3 The memory allocation and deallocation functions of &lt;stdlib.h&gt; shall not be used </li>
</ul>