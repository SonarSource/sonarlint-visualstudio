<p><em>Mutexes</em> are synchronization primitives that allow to manage concurrency.</p>
<ul>
  <li> <em>non recursive mutexes</em> are targeted by this rule. They can be locked/unlocked only once. Any locking/unlocking sequence that contains
  two consecutive identical operations leads to an undefined behaviour. </li>
  <li> <em>recursive mutexes</em> are not target by this rule. They can be locked several times and unlocked several times as long as the number of
  locks/unlocks is the same. </li>
</ul>
<p>This rule raises an issue when a <code>pthread_mutex_t</code> is locked or unlocked several times in a row. We assume that all
<code>pthread_mutex_t</code> are non-recursive (this is the most common case).</p>
<h2>Noncompliant Code Example</h2>
<pre>
pthread_mutex_t mtx1;

void bad1(void)
{
  pthread_mutex_lock(&amp;mtx1);
  pthread_mutex_lock(&amp;mtx1);
}

void bad2(void)
{
  pthread_mutex_unlock(&amp;mtx1);
  pthread_mutex_unlock(&amp;mtx1);
}
</pre>
<h2>Compliant Solution</h2>
<pre>
pthread_mutex_t mtx1;

void ok(void)
{
  pthread_mutex_lock(&amp;mtx1);
  pthread_mutex_unlock(&amp;mtx1);
}
</pre>
<h2>See</h2>
<ul>
  <li> <a href="https://pubs.opengroup.org/onlinepubs/009695399/functions/pthread_mutex_destroy.html">The Open Group</a> pthread_mutex_init,
  pthread_mutex_destroy </li>
</ul>