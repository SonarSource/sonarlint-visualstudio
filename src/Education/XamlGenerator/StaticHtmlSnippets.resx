<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="EducationPrinciplesDefenseInDepth" xml:space="preserve">
    <value>&lt;h3&gt;Defense-In-Depth&lt;/h3&gt;
&lt;p&gt;
    Applications and infrastructure benefit greatly from relying on multiple security mechanisms
    layered on top of each other. If one security mechanism fails, there is a high probability
    that the subsequent layers of security will successfully defend against the attack.
&lt;/p&gt;
&lt;p&gt;A non-exhaustive list of these code protection ramparts includes the following:&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;Minimizing the attack surface of the code&lt;/li&gt;
    &lt;li&gt;Application of the principle of least privilege&lt;/li&gt;
    &lt;li&gt;Validation and sanitization of data&lt;/li&gt;
    &lt;li&gt;Encrypting incoming, outgoing, or stored data with secure cryptography&lt;/li&gt;
    &lt;li&gt;Ensuring that internal errors cannot disrupt the overall runtime&lt;/li&gt;
    &lt;li&gt;Separation of tasks and access to information&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
    Note that these layers must be simple enough to use in an everyday workflow. Security
    measures should not break usability.
&lt;/p&gt;</value>
  </data>
  <data name="EducationPrinciplesHeader" xml:space="preserve">
    <value>&lt;h2&gt;Clean Code principles&lt;/h2&gt;</value>
  </data>
  <data name="EducationPrinciplesNeverTrustUserInput" xml:space="preserve">
    <value>&lt;h3&gt;Never Trust User Input&lt;/h3&gt;
&lt;p&gt;
    Applications must treat all user input and, more generally, all third-party data as
    attacker-controlled data.
&lt;/p&gt;
&lt;p&gt;
    The application must determine where the third-party data comes from and treat that data
    source as an attack vector. Two rules apply:
&lt;/p&gt;

&lt;p&gt;
    First, before using it in the application&amp;apos;s business logic, the application must
    validate the attacker-controlled data against predefined formats, such as:
&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;Character sets&lt;/li&gt;
    &lt;li&gt;Sizes&lt;/li&gt;
    &lt;li&gt;Types&lt;/li&gt;
    &lt;li&gt;Or any strict schema&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
    Second, the application must sanitize string data before inserting it into interpreted
    contexts (client-side code, file paths, SQL queries). Unsanitized code can corrupt the
    application&amp;apos;s logic.
&lt;/p&gt;</value>
  </data>
  <data name="HowToFixItFallbackContext" xml:space="preserve">
    <value>&lt;h3&gt;How can I fix it in another component or framework?&lt;/h3&gt;
&lt;p&gt;Although the main framework or component you use in your project is not listed, you may find helpful content in the instructions we provide.&lt;/p&gt;
&lt;p&gt;Caution: The libraries mentioned in these instructions may not be appropriate for your code.&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;Do use libraries that are compatible with the frameworks you are using.&lt;/li&gt;
    &lt;li&gt;Don't blindly copy and paste the fix-ups into your code.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Help us improve&lt;/h3&gt;
&lt;p&gt;Let us know if the instructions we provide do not work for you.
    Tell us which framework you use and why our solution does not work by submitting an idea on the SonarLint product-board.&lt;/p&gt;
&lt;a href="https://portal.productboard.com/sonarsource/4-sonarlint/submit-idea"&gt;Submit an idea&lt;/a&gt;
&lt;p&gt;We will do our best to provide you with more relevant instructions in the future.&lt;/p&gt;</value>
  </data>
  <data name="HowToFixItHeader" xml:space="preserve">
    <value>&lt;h2&gt;Which component or framework contains the issue?&lt;/h2&gt;</value>
  </data>
  <data name="ResourcesHeader" xml:space="preserve">
    <value>&lt;h2&gt;Resources&lt;/h2&gt;</value>
  </data>
</root>